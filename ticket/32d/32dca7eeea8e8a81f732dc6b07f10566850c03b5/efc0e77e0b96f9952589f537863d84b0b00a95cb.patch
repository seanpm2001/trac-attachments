--- wxWidgets.orig/build/bakefiles/files.bkl	Mon Sep 25 18:51:06 2006
+++ wxWidgets/build/bakefiles/files.bkl	Mon Sep 25 18:55:37 2006
@@ -569,4 +569,5 @@
     src/common/datacmn.cpp
     src/common/dcbase.cpp
+    src/common/dcbufcmn.cpp
     src/common/dlgcmn.cpp
     src/common/dndcmn.cpp
--- wxWidgets.orig/include/wx/cocoa/window.h	Thu Nov 10 14:49:02 2005
+++ wxWidgets/include/wx/cocoa/window.h	Fri Sep 22 20:04:40 2006
@@ -200,4 +200,6 @@
     virtual bool Show( bool show = true );
     virtual bool Enable( bool enable = true );
+
+    bool IsDoubleBuffered() const { return true; }
 };
 
--- wxWidgets.orig/include/wx/combo.h	Sat Sep 23 16:45:41 2006
+++ wxWidgets/include/wx/combo.h	Sun Sep 24 13:19:46 2006
@@ -433,7 +433,4 @@
 #endif
 
-    // Used by OnPaints of derived classes
-    wxBitmap& GetBufferBitmap(const wxSize& sz) const;
-
     // This is used when m_text is hidden (readonly).
     wxString                m_valueString;
--- wxWidgets.orig/include/wx/dc.h	Sat Sep  9 14:56:48 2006
+++ wxWidgets/include/wx/dc.h	Mon Sep 25 16:51:16 2006
@@ -502,12 +502,12 @@
     // ---------------------
 
-    int GetBackgroundMode() const { return m_backgroundMode; }
-    const wxBrush&  GetBackground() const { return m_backgroundBrush; }
-    const wxBrush&  GetBrush() const { return m_brush; }
-    const wxFont&   GetFont() const { return m_font; }
-    const wxPen&    GetPen() const { return m_pen; }
+    virtual int GetBackgroundMode() const { return m_backgroundMode; }
+    virtual const wxBrush&  GetBackground() const { return m_backgroundBrush; }
+    virtual const wxBrush&  GetBrush() const { return m_brush; }
+    virtual const wxFont&   GetFont() const { return m_font; }
+    virtual const wxPen&    GetPen() const { return m_pen; }
 
-    const wxColour& GetTextForeground() const { return m_textForegroundColour; }
-    const wxColour& GetTextBackground() const { return m_textBackgroundColour; }
+    virtual const wxColour& GetTextForeground() const { return m_textForegroundColour; }
+    virtual const wxColour& GetTextBackground() const { return m_textBackgroundColour; }
     virtual void SetTextForeground(const wxColour& colour)
         { m_textForegroundColour = colour; }
@@ -515,5 +515,5 @@
         { m_textBackgroundColour = colour; }
 
-    int GetMapMode() const { return m_mappingMode; }
+    virtual int GetMapMode() const { return m_mappingMode; }
     virtual void SetMapMode(int mode) = 0;
 
@@ -552,5 +552,5 @@
     virtual void SetAxisOrientation(bool xLeftRight, bool yBottomUp) = 0;
 
-    int GetLogicalFunction() const { return m_logicalFunction; }
+    virtual int GetLogicalFunction() const { return m_logicalFunction; }
     virtual void SetLogicalFunction(int function) = 0;
 
--- wxWidgets.orig/include/wx/dcbuffer.h	Tue Mar  8 02:38:53 2005
+++ wxWidgets/include/wx/dcbuffer.h	Mon Sep 25 20:24:40 2006
@@ -17,4 +17,27 @@
 #include "wx/window.h"
 
+
+// I think this patch should be test on wxMac with
+// wxTEST_PAINTDCDELEGATION as 1, and then with
+// with wxTEST_MEMORYDCDELEGATION as 1.
+#define wxTEST_PAINTDCDELEGATION        0
+#define wxTEST_MEMORYDCDELEGATION       0
+
+
+// Split platforms into two groups - those which have well-working
+// double-buffering by default, and those which do not.
+#if defined(__WXMAC__) || defined(__WXGTK20__)
+    #define wxALWAYS_NATIVE_DOUBLE_BUFFER       1
+#else
+    #define wxALWAYS_NATIVE_DOUBLE_BUFFER       0
+#endif
+
+
+#if wxTEST_PAINTDCDELEGATION || wxTEST_MEMORYDCDELEGATION
+    #undef wxALWAYS_NATIVE_DOUBLE_BUFFER
+    #define wxALWAYS_NATIVE_DOUBLE_BUFFER 0
+#endif
+
+
 // ----------------------------------------------------------------------------
 // Double buffering helper.
@@ -29,9 +52,10 @@
 #define wxBUFFER_CLIENT_AREA        0x02
 
-class wxBufferedDC : public wxMemoryDC
+class WXDLLEXPORT wxBufferedDC : public wxDC
 {
 public:
     // Default ctor, must subsequently call Init for two stage construction.
-    wxBufferedDC() : m_dc( 0 ), m_style(0)
+    wxBufferedDC() : wxDC(), m_targetDc(NULL), m_mainDc(NULL),
+                     m_buffer(NULL), m_style(0)
     {
     }
@@ -41,9 +65,10 @@
                  const wxBitmap &buffer = wxNullBitmap,
                  int style = wxBUFFER_CLIENT_AREA)
-        : m_dc( dc ),
-          m_buffer( buffer ),
-          m_style(style)
+        : wxDC(),
+          m_targetDc(NULL),
+          m_mainDc(NULL)
     {
-        UseBuffer();
+        // All other members except dcs are initialized in Init
+        Init(dc, buffer, style);
     }
 
@@ -52,10 +77,24 @@
     // being buffered)
     wxBufferedDC(wxDC *dc, const wxSize &area, int style = wxBUFFER_CLIENT_AREA)
-        : m_dc( dc ),
-          m_buffer( area.GetWidth(), area.GetHeight() ),
-          m_style(style)
+        : wxDC(),
+          m_targetDc(NULL),
+          m_mainDc(NULL)
+    {
+        // All other members except dcs are initialized in Init
+        Init(NULL, dc, area, style);
+    }
 
+    // Same, but also receives window to detect whether it is
+    // natively double-buffered.
+    wxBufferedDC(wxWindow* win,
+                 wxDC *dc,
+                 const wxSize &area,
+                 int style = wxBUFFER_CLIENT_AREA)
+        : wxDC(),
+          m_targetDc(NULL),
+          m_mainDc(NULL)
     {
-        UseBuffer();
+        // All other members except dcs are initialized in Init
+        Init(win, dc, area, style);
     }
 
@@ -65,24 +104,53 @@
     virtual ~wxBufferedDC()
     {
-        if ( m_dc ) UnMask();
+        UnMask();
     }
 
-    // These reimplement the actions of the ctors for two stage creation, but
-    // are not used by the ctors themselves to save a few cpu cycles.
     void Init(wxDC *dc,
-              const wxBitmap &buffer=wxNullBitmap,
+              const wxBitmap &buffer,
               int style = wxBUFFER_CLIENT_AREA)
     {
-        wxASSERT_MSG( m_dc == 0 && m_buffer == wxNullBitmap,
-                      _T("wxBufferedDC already initialised") );
-        m_dc = dc;
-        m_buffer = buffer;
+        wxASSERT_MSG( m_mainDc == NULL,
+                      wxT("wxBufferedDC already initialised") );
+        wxASSERT_MSG( buffer.Ok(),
+                      wxT("invalid bitmap") );
+        m_mainDc = dc;
+        m_buffer = &buffer;
         m_style = style;
         UseBuffer();
     }
 
-    void Init(wxDC *dc, const wxSize &area, int style = wxBUFFER_CLIENT_AREA)
+    void Init(wxWindow* win,
+              wxDC *dc,
+              const wxSize &area = wxDefaultSize,
+              int style = wxBUFFER_CLIENT_AREA)
     {
-        Init(dc, wxBitmap(area.GetWidth(), area.GetHeight()), style);
+        wxASSERT_MSG( m_mainDc == NULL,
+                      wxT("wxBufferedDC already initialised") );
+
+        m_mainDc = dc;
+        m_style = style;
+
+#if wxTEST_MEMORYDCDELEGATION
+        if ( 0 )
+#elif wxTEST_PAINTDCDELEGATION
+        if ( 1 )
+#else
+        if ( win && win->IsDoubleBuffered() )
+#endif
+        {
+            AttachDC(dc);
+            m_buffer = NULL;
+        }
+        else
+        {
+            PrepareBuffer(win, area);
+            UseBuffer();
+        }
+    }
+
+    void Init(wxDC *dc, const wxSize &area = wxDefaultSize, int style = wxBUFFER_CLIENT_AREA)
+    {
+        Init(NULL, dc, area, style);
     }
 
@@ -93,19 +161,5 @@
     // BufferedDC must blit before the derived class (which may own the dc it's
     // blitting to) is destroyed.
-    void UnMask()
-    {
-        wxASSERT_MSG( m_dc != 0,
-                      _T("No underlying DC associated with wxBufferedDC (anymore)") );
-
-        wxCoord x=0, y=0;
-
-        if (m_style & wxBUFFER_CLIENT_AREA)
-            GetDeviceOrigin(& x, & y);
-
-        m_dc->Blit( 0, 0,
-                    m_buffer.GetWidth(), m_buffer.GetHeight(), this,
-                    -x, -y );
-        m_dc = NULL;
-    }
+    void UnMask();
 
     // Set and get the style
@@ -114,31 +168,436 @@
 
 private:
-    // check that the bitmap is valid and use it
-    void UseBuffer()
-    {
-        if (!m_buffer.Ok())
-        {
-            wxCoord w, h;
-            m_dc->GetSize(&w, &h);
-            m_buffer = wxBitmap(w, h);
-        }
+    // Prepares wxMemoryDC.
+    void UseBuffer();
 
-        SelectObject(m_buffer);
-    }
+    // Allocate m_buffer, if necessary.
+    void PrepareBuffer(wxWindow* win, const wxSize& area);
+
+    // DC to which calls are delegated.
+    wxDC*           m_targetDc;
 
-    // the underlying DC to which we copy everything drawn on this one in
-    // UnMask()
+    // This the underlying DC to which we copy everything drawn on
+    // this one in UnMask().
     //
     // NB: Without the existence of a wxNullDC, this must be a pointer, else it
     //     could probably be a reference.
-    wxDC *m_dc;
+    wxDC*           m_mainDc;
 
     // the buffer (selected in this DC)
-    wxBitmap m_buffer;
+    const wxBitmap* m_buffer;
 
     // the buffering style
-    int m_style;
+    int             m_style;
 
     DECLARE_NO_COPY_CLASS(wxBufferedDC)
+public:
+    //
+    // BEGIN DC-DELEGATION IMPLEMENTATION
+    //
+
+    wxDC& GetAttachedDC()
+    {
+        return *m_targetDc;
+    }
+
+    // Use this to set the DC which receives delegated calls.
+    void AttachDC(wxDC* dc)
+    {
+        m_targetDc = dc;
+    #ifdef __WXMSW__
+        SetHDC( dc ? dc->GetHDC() : NULL );
+    #endif
+    }
+
+    // Sets DC to NULL
+    wxDC* DetachDC()
+    {
+        wxDC* retDc = m_targetDc;
+        AttachDC(NULL);
+        return retDc;
+    }
+
+#ifdef __WXGTK__
+    virtual GdkWindow* GetGDKWindow() const
+    {
+        return m_targetDc->GetGDKWindow();
+    }
+#endif
+
+#if WXWIN_COMPATIBILITY_2_6
+    wxDEPRECATED( virtual void BeginDrawing() ){ m_targetDc->BeginDrawing(); }
+#endif // WXWIN_COMPATIBILITY_2_6
+    bool Blit(wxCoord xdest, wxCoord ydest, wxCoord width, wxCoord height,
+              wxDC *source, wxCoord xsrc, wxCoord ysrc,
+              int rop = wxCOPY, bool useMask = false, wxCoord xsrcMask = wxDefaultCoord, wxCoord ysrcMask = wxDefaultCoord)
+        { return m_targetDc->Blit(xdest, ydest, width, height,
+                                  source, xsrc, ysrc, rop,
+                                  useMask, xsrcMask, ysrcMask); }
+    bool Blit(const wxPoint& destPt, const wxSize& sz,
+              wxDC *source, const wxPoint& srcPt,
+              int rop = wxCOPY, bool useMask = false, const wxPoint& srcPtMask = wxDefaultPosition)
+        { return m_targetDc->Blit(destPt, sz, source, srcPt,
+                                  rop, useMask, srcPtMask); }
+    virtual void CalcBoundingBox(wxCoord x, wxCoord y) { m_targetDc->CalcBoundingBox(x, y); }
+#if defined(__WXWINCE__)
+    void CalculateEllipticPoints( wxList* points,
+                                  wxCoord xStart, wxCoord yStart,
+                                  wxCoord w, wxCoord h,
+                                  double sa, double ea )
+        { m_targetDc->CalculateEllipticPoints(points, xStart, yStart, w,
+                                              h, sa, ea); }
+#endif // defined(__WXWINCE__)
+    virtual bool CanDrawBitmap() const { return m_targetDc->CanDrawBitmap(); }
+    virtual bool CanGetTextExtent() const { return m_targetDc->CanGetTextExtent(); }
+    virtual void Clear() { m_targetDc->Clear(); }
+    virtual void ComputeScaleAndOrigin() { m_targetDc->ComputeScaleAndOrigin(); }
+    void CrossHair(wxCoord x, wxCoord y) { m_targetDc->CrossHair(x, y); }
+    void CrossHair(const wxPoint& pt) { m_targetDc->CrossHair(pt); }
+    virtual void DestroyClippingRegion() { m_targetDc->DestroyClippingRegion(); }
+    wxCoord DeviceToLogicalX(wxCoord x) const { return m_targetDc->DeviceToLogicalX(x); }
+    wxCoord DeviceToLogicalXRel(wxCoord x) const { return m_targetDc->DeviceToLogicalXRel(x); }
+    wxCoord DeviceToLogicalY(wxCoord y) const { return m_targetDc->DeviceToLogicalY(y); }
+    wxCoord DeviceToLogicalYRel(wxCoord y) const { return m_targetDc->DeviceToLogicalYRel(y); }
+#if defined(__WXWINCE__)
+    virtual void DoDrawEllipticArcRot( wxCoord x, wxCoord y,
+                                       wxCoord w, wxCoord h,
+                                       double sa = 0, double ea = 0, double angle = 0 )
+        { m_targetDc->DoDrawEllipticArcRot(x, y, w, h,
+                                           sa, ea, angle); }
+#endif // defined(__WXWINCE__)
+    void DrawArc(wxCoord x1, wxCoord y1, wxCoord x2, wxCoord y2,
+                 wxCoord xc, wxCoord yc)
+        { m_targetDc->DrawArc(x1, y1, x2, y2,
+                              xc, yc); }
+    void DrawArc(const wxPoint& pt1, const wxPoint& pt2, const wxPoint& centre)
+        { m_targetDc->DrawArc(pt1, pt2, centre); }
+    void DrawBitmap(const wxBitmap &bmp, wxCoord x, wxCoord y,
+                    bool useMask = false)
+        { m_targetDc->DrawBitmap(bmp, x, y, useMask); }
+    void DrawBitmap(const wxBitmap &bmp, const wxPoint& pt,
+                    bool useMask = false)
+        { m_targetDc->DrawBitmap(bmp, pt, useMask); }
+    void DrawCheckMark(wxCoord x, wxCoord y,
+                       wxCoord width, wxCoord height)
+        { m_targetDc->DrawCheckMark(x, y, width, height); }
+    void DrawCheckMark(const wxRect& rect) { m_targetDc->DrawCheckMark(rect); }
+    void DrawCircle(wxCoord x, wxCoord y, wxCoord radius) { m_targetDc->DrawCircle(x, y, radius); }
+    void DrawCircle(const wxPoint& pt, wxCoord radius) { m_targetDc->DrawCircle(pt, radius); }
+    void DrawEllipse(wxCoord x, wxCoord y, wxCoord width, wxCoord height)
+        { m_targetDc->DrawEllipse(x, y, width, height); }
+    void DrawEllipse(const wxPoint& pt, const wxSize& sz) { m_targetDc->DrawEllipse(pt, sz); }
+    void DrawEllipse(const wxRect& rect) { m_targetDc->DrawEllipse(rect); }
+    void DrawEllipticArc(wxCoord x, wxCoord y, wxCoord w, wxCoord h,
+                         double sa, double ea)
+        { m_targetDc->DrawEllipticArc(x, y, w, h,
+                                      sa, ea); }
+    void DrawEllipticArc(const wxPoint& pt, const wxSize& sz,
+                         double sa, double ea)
+        { m_targetDc->DrawEllipticArc(pt, sz, sa, ea); }
+#if defined(__WXWINCE__)
+    void DrawEllipticArcRot( wxCoord x, wxCoord y,
+                             wxCoord width, wxCoord height,
+                             double sa = 0, double ea = 0, double angle = 0 )
+        { m_targetDc->DrawEllipticArcRot(x, y, width, height,
+                                         sa, ea, angle); }
+    void DrawEllipticArcRot( const wxPoint& pt,
+                             const wxSize& sz,
+                             double sa = 0, double ea = 0, double angle = 0 )
+        { m_targetDc->DrawEllipticArcRot(pt, sz, sa, ea,
+                                         angle); }
+    void DrawEllipticArcRot( const wxRect& rect,
+                             double sa = 0, double ea = 0, double angle = 0 )
+        { m_targetDc->DrawEllipticArcRot(rect, sa, ea, angle); }
+#endif // defined(__WXWINCE__)
+    void DrawIcon(const wxIcon& icon, wxCoord x, wxCoord y) { m_targetDc->DrawIcon(icon, x, y); }
+    void DrawIcon(const wxIcon& icon, const wxPoint& pt) { m_targetDc->DrawIcon(icon, pt); }
+    virtual void DrawLabel(const wxString& text,
+                           const wxBitmap& image,
+                           const wxRect& rect,
+                           int alignment = wxALIGN_LEFT | wxALIGN_TOP,
+                           int indexAccel = -1,
+                           wxRect *rectBounding = NULL)
+        { m_targetDc->DrawLabel(text, image, rect, alignment,
+                                indexAccel, rectBounding); }
+    void DrawLabel(const wxString& text, const wxRect& rect,
+                   int alignment = wxALIGN_LEFT | wxALIGN_TOP,
+                   int indexAccel = -1)
+        { m_targetDc->DrawLabel(text, rect, alignment, indexAccel); }
+    void DrawLine(wxCoord x1, wxCoord y1, wxCoord x2, wxCoord y2)
+        { m_targetDc->DrawLine(x1, y1, x2, y2); }
+    void DrawLine(const wxPoint& pt1, const wxPoint& pt2) { m_targetDc->DrawLine(pt1, pt2); }
+    void DrawLines(int n, wxPoint points[],
+                   wxCoord xoffset = 0, wxCoord yoffset = 0)
+        { m_targetDc->DrawLines(n, points, xoffset, yoffset); }
+    void DrawLines(const wxList *list,
+                   wxCoord xoffset = 0, wxCoord yoffset = 0)
+        { m_targetDc->DrawLines(list, xoffset, yoffset); }
+    virtual void DrawObject(wxDrawObject* drawobject) { m_targetDc->DrawObject(drawobject); }
+    void DrawPoint(wxCoord x, wxCoord y) { m_targetDc->DrawPoint(x, y); }
+    void DrawPoint(const wxPoint& pt) { m_targetDc->DrawPoint(pt); }
+    void DrawPolyPolygon(int n, int count[], wxPoint points[],
+                         wxCoord xoffset = 0, wxCoord yoffset = 0,
+                         int fillStyle = wxODDEVEN_RULE)
+        { m_targetDc->DrawPolyPolygon(n, count, points, xoffset,
+                                      yoffset, fillStyle); }
+    void DrawPolygon(int n, wxPoint points[],
+                     wxCoord xoffset = 0, wxCoord yoffset = 0,
+                     int fillStyle = wxODDEVEN_RULE)
+        { m_targetDc->DrawPolygon(n, points, xoffset, yoffset,
+                                  fillStyle); }
+    void DrawPolygon(const wxList *list,
+                     wxCoord xoffset = 0, wxCoord yoffset = 0,
+                     int fillStyle = wxODDEVEN_RULE)
+        { m_targetDc->DrawPolygon(list, xoffset, yoffset, fillStyle); }
+    void DrawRectangle(wxCoord x, wxCoord y, wxCoord width, wxCoord height)
+        { m_targetDc->DrawRectangle(x, y, width, height); }
+    void DrawRectangle(const wxPoint& pt, const wxSize& sz) { m_targetDc->DrawRectangle(pt, sz); }
+    void DrawRectangle(const wxRect& rect) { m_targetDc->DrawRectangle(rect); }
+    void DrawRotatedText(const wxString& text, wxCoord x, wxCoord y, double angle)
+        { m_targetDc->DrawRotatedText(text, x, y, angle); }
+    void DrawRotatedText(const wxString& text, const wxPoint& pt, double angle)
+        { m_targetDc->DrawRotatedText(text, pt, angle); }
+    void DrawRoundedRectangle(wxCoord x, wxCoord y, wxCoord width, wxCoord height,
+                              double radius)
+        { m_targetDc->DrawRoundedRectangle(x, y, width, height,
+                                           radius); }
+    void DrawRoundedRectangle(const wxPoint& pt, const wxSize& sz,
+                             double radius)
+        { m_targetDc->DrawRoundedRectangle(pt, sz, radius); }
+    void DrawRoundedRectangle(const wxRect& r, double radius)
+        { m_targetDc->DrawRoundedRectangle(r, radius); }
+#if wxUSE_SPLINES
+    void DrawSpline(wxCoord x1, wxCoord y1,
+                    wxCoord x2, wxCoord y2,
+                    wxCoord x3, wxCoord y3)
+        { m_targetDc->DrawSpline(x1, y1, x2, y2,
+                                 x3, y3); }
+    void DrawSpline(int n, wxPoint points[]) { m_targetDc->DrawSpline(n, points); }
+    void DrawSpline(wxList *points) { m_targetDc->DrawSpline(points); }
+#endif // wxUSE_SPLINES
+    void DrawText(const wxString& text, wxCoord x, wxCoord y)
+        { m_targetDc->DrawText(text, x, y); }
+    void DrawText(const wxString& text, const wxPoint& pt) { m_targetDc->DrawText(text, pt); }
+    virtual void EndDoc() { m_targetDc->EndDoc(); }
+#if WXWIN_COMPATIBILITY_2_6
+    wxDEPRECATED( virtual void EndDrawing() ){ m_targetDc->EndDrawing(); }
+#endif // WXWIN_COMPATIBILITY_2_6
+    virtual void EndPage() { m_targetDc->EndPage(); }
+    bool FloodFill(wxCoord x, wxCoord y, const wxColour& col,
+                   int style = wxFLOOD_SURFACE)
+        { return m_targetDc->FloodFill(x, y, col, style); }
+    bool FloodFill(const wxPoint& pt, const wxColour& col,
+                   int style = wxFLOOD_SURFACE)
+        { return m_targetDc->FloodFill(pt, col, style); }
+    virtual const wxBrush&  GetBackground() const { return m_targetDc->GetBackground(); }
+    virtual int GetBackgroundMode() const { return m_targetDc->GetBackgroundMode(); }
+    virtual const wxBrush&  GetBrush() const { return m_targetDc->GetBrush(); }
+    virtual wxCoord GetCharHeight() const { return m_targetDc->GetCharHeight(); }
+    virtual wxCoord GetCharWidth() const { return m_targetDc->GetCharWidth(); }
+    void GetClippingBox(wxCoord *x, wxCoord *y, wxCoord *w, wxCoord *h) const
+        { m_targetDc->GetClippingBox(x, y, w, h); }
+    void GetClippingBox(wxRect& rect) const { m_targetDc->GetClippingBox(rect); }
+    void GetClippingBox(long *x, long *y, long *w, long *h) const
+        { m_targetDc->GetClippingBox(x, y, w, h); }
+    virtual int GetDepth() const { return m_targetDc->GetDepth(); }
+    void GetDeviceOrigin(wxCoord *x, wxCoord *y) const { m_targetDc->GetDeviceOrigin(x, y); }
+    wxPoint GetDeviceOrigin() const { return m_targetDc->GetDeviceOrigin(); }
+    void GetDeviceOrigin(long *x, long *y) const { m_targetDc->GetDeviceOrigin(x, y); }
+    virtual const wxFont&   GetFont() const { return m_targetDc->GetFont(); }
+    virtual int GetLogicalFunction() const { return m_targetDc->GetLogicalFunction(); }
+    void GetLogicalOrigin(wxCoord *x, wxCoord *y) const { m_targetDc->GetLogicalOrigin(x, y); }
+    wxPoint GetLogicalOrigin() const { return m_targetDc->GetLogicalOrigin(); }
+    void GetLogicalOrigin(long *x, long *y) const { m_targetDc->GetLogicalOrigin(x, y); }
+    virtual void GetLogicalScale(double *x, double *y) { m_targetDc->GetLogicalScale(x, y); }
+    virtual int GetMapMode() const { return m_targetDc->GetMapMode(); }
+    virtual void GetMultiLineTextExtent(const wxString& text,
+                                        wxCoord *width,
+                                        wxCoord *height,
+                                        wxCoord *heightLine = NULL,
+                                        wxFont *font = NULL)
+        { m_targetDc->GetMultiLineTextExtent(text, width, height, heightLine,
+                                             font); }
+#if WXWIN_COMPATIBILITY_2_4
+    virtual bool GetOptimization() { return m_targetDc->GetOptimization(); }
+#endif // WXWIN_COMPATIBILITY_2_4
+    virtual wxSize GetPPI() const { return m_targetDc->GetPPI(); }
+    bool GetPartialTextExtents(const wxString& text, wxArrayInt& widths) const
+        { return m_targetDc->GetPartialTextExtents(text, widths); }
+    virtual const wxPen&    GetPen() const { return m_targetDc->GetPen(); }
+    bool GetPixel(wxCoord x, wxCoord y, wxColour *col) const
+        { return m_targetDc->GetPixel(x, y, col); }
+    bool GetPixel(const wxPoint& pt, wxColour *col) const { return m_targetDc->GetPixel(pt, col); }
+    void GetSize(int *width, int *height) const { m_targetDc->GetSize(width, height); }
+    wxSize GetSize() const { return m_targetDc->GetSize(); }
+    void GetSizeMM(int* width, int* height) const { m_targetDc->GetSizeMM(width, height); }
+    wxSize GetSizeMM() const { return m_targetDc->GetSizeMM(); }
+    virtual const wxColour& GetTextBackground() const { return m_targetDc->GetTextBackground(); }
+    void GetTextExtent(const wxString& string,
+                       wxCoord *x, wxCoord *y,
+                       wxCoord *descent = NULL,
+                       wxCoord *externalLeading = NULL,
+                       wxFont *theFont = NULL) const
+        { m_targetDc->GetTextExtent(string, x, y, descent,
+                                    externalLeading, theFont); }
+    void GetTextExtent(const wxString& string,
+                       long *x, long *y,
+                       long *descent = NULL,
+                       long *externalLeading = NULL,
+                       wxFont *theFont = NULL) const
+        { m_targetDc->GetTextExtent(string, x, y, descent,
+                                    externalLeading, theFont); }
+    virtual const wxColour& GetTextForeground() const { return m_targetDc->GetTextForeground(); }
+    virtual void GetUserScale(double *x, double *y) const { m_targetDc->GetUserScale(x, y); }
+    void GradientFillConcentric(const wxRect& rect,
+                                const wxColour& initialColour,
+                                const wxColour& destColour)
+        { m_targetDc->GradientFillConcentric(rect, initialColour, destColour); }
+    void GradientFillConcentric(const wxRect& rect,
+                                const wxColour& initialColour,
+                                const wxColour& destColour,
+                                const wxPoint& circleCenter)
+        { m_targetDc->GradientFillConcentric(rect, initialColour, destColour, circleCenter); }
+    void GradientFillLinear(const wxRect& rect,
+                            const wxColour& initialColour,
+                            const wxColour& destColour,
+                            wxDirection nDirection = wxEAST)
+        { m_targetDc->GradientFillLinear(rect, initialColour, destColour, nDirection); }
+    wxCoord LogicalToDeviceX(wxCoord x) const { return m_targetDc->LogicalToDeviceX(x); }
+    wxCoord LogicalToDeviceXRel(wxCoord x) const { return m_targetDc->LogicalToDeviceXRel(x); }
+    wxCoord LogicalToDeviceY(wxCoord y) const { return m_targetDc->LogicalToDeviceY(y); }
+    wxCoord LogicalToDeviceYRel(wxCoord y) const { return m_targetDc->LogicalToDeviceYRel(y); }
+    wxCoord MaxX() const { return m_targetDc->MaxX(); }
+    wxCoord MaxY() const { return m_targetDc->MaxY(); }
+    wxCoord MinX() const { return m_targetDc->MinX(); }
+    wxCoord MinY() const { return m_targetDc->MinY(); }
+    virtual bool Ok() const { return m_targetDc->Ok(); }
+    void ResetBoundingBox()
+        { m_targetDc->ResetBoundingBox(); }
+#if defined(__WXWINCE__)
+    void Rotate( wxList* points, double angle, wxPoint center = wxPoint(0,0) )
+        { m_targetDc->Rotate(points, angle, center, 0)); }
+#endif // defined(__WXWINCE__)
+    virtual void SetAxisOrientation(bool xLeftRight, bool yBottomUp)
+        { m_targetDc->SetAxisOrientation(xLeftRight, yBottomUp); }
+    virtual void SetBackground(const wxBrush& brush) { m_targetDc->SetBackground(brush); }
+    virtual void SetBackgroundMode(int mode) { m_targetDc->SetBackgroundMode(mode); }
+    virtual void SetBrush(const wxBrush& brush) { m_targetDc->SetBrush(brush); }
+    void SetClippingRegion(wxCoord x, wxCoord y, wxCoord width, wxCoord height)
+        { m_targetDc->SetClippingRegion(x, y, width, height); }
+    void SetClippingRegion(const wxPoint& pt, const wxSize& sz)
+        { m_targetDc->SetClippingRegion(pt, sz); }
+    void SetClippingRegion(const wxRect& rect) { m_targetDc->SetClippingRegion(rect); }
+    void SetClippingRegion(const wxRegion& region) { m_targetDc->SetClippingRegion(region); }
+    virtual void SetDeviceOrigin(wxCoord x, wxCoord y) { m_targetDc->SetDeviceOrigin(x, y); }
+    virtual void SetFont(const wxFont& font) { m_targetDc->SetFont(font); }
+    virtual void SetLogicalFunction(int function) { m_targetDc->SetLogicalFunction(function); }
+    virtual void SetLogicalOrigin(wxCoord x, wxCoord y) { m_targetDc->SetLogicalOrigin(x, y); }
+    virtual void SetLogicalScale(double x, double y) { m_targetDc->SetLogicalScale(x, y); }
+    virtual void SetMapMode(int mode) { m_targetDc->SetMapMode(mode); }
+#if WXWIN_COMPATIBILITY_2_4
+    virtual void SetOptimization(bool opt) { m_targetDc->SetOptimization(opt); }
+#endif // WXWIN_COMPATIBILITY_2_4
+#if wxUSE_PALETTE
+    virtual void SetPalette(const wxPalette& palette) { m_targetDc->SetPalette(palette); }
+#endif // wxUSE_PALETTE
+    virtual void SetPen(const wxPen& pen) { m_targetDc->SetPen(pen); }
+    virtual void SetTextBackground(const wxColour& colour) { m_targetDc->SetTextBackground(colour); }
+    virtual void SetTextForeground(const wxColour& colour) { m_targetDc->SetTextForeground(colour); }
+    virtual void SetUserScale(double x, double y) { m_targetDc->SetUserScale(x, y); }
+    virtual bool StartDoc(const wxString& message) { return m_targetDc->StartDoc(message); }
+    virtual void StartPage() { m_targetDc->StartPage(); }
+protected:
+    virtual bool DoBlit(wxCoord xdest, wxCoord ydest,
+                        wxCoord width, wxCoord height,
+                        wxDC *source, wxCoord xsrc, wxCoord ysrc,
+                        int rop = wxCOPY, bool useMask = false, wxCoord xsrcMask = wxDefaultCoord, wxCoord ysrcMask = wxDefaultCoord)
+        { return m_targetDc->Blit(xdest, ydest, width, height,
+                                  source, xsrc, ysrc, rop,
+                                  useMask, xsrcMask, ysrcMask); }
+    virtual void DoCrossHair(wxCoord x, wxCoord y) { m_targetDc->CrossHair(x, y); }
+    virtual void DoDrawArc(wxCoord x1, wxCoord y1,
+                           wxCoord x2, wxCoord y2,
+                           wxCoord xc, wxCoord yc)
+        { m_targetDc->DrawArc(x1, y1, x2, y2,
+                              xc, yc); }
+    virtual void DoDrawBitmap(const wxBitmap &bmp, wxCoord x, wxCoord y,
+                              bool useMask = false)
+        { m_targetDc->DrawBitmap(bmp, x, y, useMask); }
+    virtual void DoDrawCheckMark(wxCoord x, wxCoord y,
+                                 wxCoord width, wxCoord height)
+        { m_targetDc->DrawCheckMark(x, y, width, height); }
+    virtual void DoDrawEllipse(wxCoord x, wxCoord y,
+                               wxCoord width, wxCoord height)
+        { m_targetDc->DrawEllipse(x, y, width, height); }
+    virtual void DoDrawEllipticArc(wxCoord x, wxCoord y, wxCoord w, wxCoord h,
+                                   double sa, double ea)
+        { m_targetDc->DrawEllipticArc(x, y, w, h,
+                                      sa, ea); }
+    virtual void DoDrawIcon(const wxIcon& icon, wxCoord x, wxCoord y)
+        { m_targetDc->DrawIcon(icon, x, y); }
+    virtual void DoDrawLine(wxCoord x1, wxCoord y1, wxCoord x2, wxCoord y2)
+        { m_targetDc->DrawLine(x1, y1, x2, y2); }
+    virtual void DoDrawLines(int n, wxPoint points[],
+                             wxCoord xoffset, wxCoord yoffset)
+        { m_targetDc->DrawLines(n, points, xoffset, yoffset); }
+    virtual void DoDrawPoint(wxCoord x, wxCoord y) { m_targetDc->DrawPoint(x, y); }
+    virtual void DoDrawPolyPolygon(int n, int count[], wxPoint points[],
+                               wxCoord xoffset, wxCoord yoffset,
+                               int fillStyle)
+        { m_targetDc->DrawPolyPolygon(n, count, points, xoffset,
+                                      yoffset, fillStyle); }
+    virtual void DoDrawPolygon(int n, wxPoint points[],
+                               wxCoord xoffset, wxCoord yoffset,
+                               int fillStyle = wxODDEVEN_RULE)
+        { m_targetDc->DrawPolygon(n, points, xoffset, yoffset,
+                                  fillStyle); }
+    virtual void DoDrawRectangle(wxCoord x, wxCoord y, wxCoord width, wxCoord height)
+        { m_targetDc->DrawRectangle(x, y, width, height); }
+    virtual void DoDrawRotatedText(const wxString& text,
+                                   wxCoord x, wxCoord y, double angle)
+        { m_targetDc->DrawRotatedText(text, x, y, angle); }
+    virtual void DoDrawRoundedRectangle(wxCoord x, wxCoord y,
+                                        wxCoord width, wxCoord height,
+                                        double radius)
+        { m_targetDc->DrawRoundedRectangle(x, y, width, height,
+                                           radius); }
+#if wxUSE_SPLINES
+    virtual void DoDrawSpline(wxList *points) { m_targetDc->DrawSpline(points); }
+#endif // wxUSE_SPLINES
+    virtual void DoDrawText(const wxString& text, wxCoord x, wxCoord y)
+        { m_targetDc->DrawText(text, x, y); }
+    virtual bool DoFloodFill(wxCoord x, wxCoord y, const wxColour& col,
+                             int style = wxFLOOD_SURFACE)
+        { return m_targetDc->FloodFill(x, y, col, style); }
+    virtual void DoGetClippingBox(wxCoord *x, wxCoord *y,
+                                  wxCoord *w, wxCoord *h) const
+        { m_targetDc->GetClippingBox(x, y, w, h); }
+    virtual void DoGetDeviceOrigin(wxCoord *x, wxCoord *y) const
+        { m_targetDc->GetDeviceOrigin(x, y); }
+    virtual void DoGetLogicalOrigin(wxCoord *x, wxCoord *y) const
+        { m_targetDc->GetLogicalOrigin(x, y); }
+    virtual bool DoGetPartialTextExtents(const wxString& text, wxArrayInt& widths) const
+        { return m_targetDc->GetPartialTextExtents(text, widths); }
+    virtual bool DoGetPixel(wxCoord x, wxCoord y, wxColour *col) const
+        { return m_targetDc->GetPixel(x, y, col); }
+    virtual void DoGetSize(int *width, int *height) const { m_targetDc->GetSize(width, height); }
+    virtual void DoGetSizeMM(int* width, int* height) const { m_targetDc->GetSizeMM(width, height); }
+    virtual void DoGetTextExtent(const wxString& string,
+                                 wxCoord *x, wxCoord *y,
+                                 wxCoord *descent = NULL,
+                                 wxCoord *externalLeading = NULL,
+                                 wxFont *theFont = NULL) const
+        { m_targetDc->GetTextExtent(string, x, y, descent,
+                                    externalLeading, theFont); }
+    virtual void DoGradientFillLinear(const wxRect& rect,
+                                      const wxColour& initialColour,
+                                      const wxColour& destColour,
+                                      wxDirection nDirection = wxEAST)
+        { m_targetDc->GradientFillLinear(rect, initialColour, destColour, nDirection); }
+    virtual void DoSetClippingRegion(wxCoord x, wxCoord y,
+                                     wxCoord width, wxCoord height)
+        { m_targetDc->SetClippingRegion(x, y, width, height); }
+    virtual void DoSetClippingRegionAsRegion(const wxRegion& region)
+        { m_targetDc->SetClippingRegion(region); }
 };
 
@@ -164,5 +623,5 @@
             Init(&m_paintdc, buffer, style);
         else
-            Init(&m_paintdc, window->GetClientSize(), style);
+            Init(window, &m_paintdc, window->GetClientSize(), style);
     }
 
@@ -175,5 +634,5 @@
             window->PrepareDC( m_paintdc );
 
-        Init(&m_paintdc, window->GetClientSize(), style);
+        Init(window, &m_paintdc, window->GetClientSize(), style);
     }
 
@@ -193,4 +652,53 @@
 };
 
-#endif  // _WX_DCBUFFER_H_
 
+
+//
+// wxAutoBufferedPaintDC is a wxPaintDC in toolkits which have double-
+// buffering by default. Otherwise it is a wxBufferedPaintDC. Thus,
+// you can only expect it work with a simple constructor that
+// accepts single wxWindow* argument.
+//
+#if wxALWAYS_NATIVE_DOUBLE_BUFFER
+    #define wxAutoBufferedPaintDCBase           wxPaintDC
+#else
+    #define wxAutoBufferedPaintDCBase           wxBufferedPaintDC
+#endif
+
+
+#ifdef __WXDEBUG__
+
+class wxAutoBufferedPaintDC : public wxAutoBufferedPaintDCBase
+{
+public:
+
+    wxAutoBufferedPaintDC(wxWindow* win)
+        : wxAutoBufferedPaintDCBase(win)
+    {
+        TestWinStyle(win);
+    }
+
+    virtual ~wxAutoBufferedPaintDC() { }
+
+private:
+
+    void TestWinStyle(wxWindow* win)
+    {
+        // Help the user to get the double-buffering working properly.
+        wxASSERT_MSG( win->GetBackgroundStyle() == wxBG_STYLE_CUSTOM,
+                      wxT("In constructor, you need to call GetBackgroundStyle(wxBG_STYLE_CUSTOM), ")
+                      wxT("and also, if needed, paint the background manually in the paint event handler."));
+    }
+
+    DECLARE_NO_COPY_CLASS(wxAutoBufferedPaintDC)
+};
+
+#else // !__WXDEBUG__
+
+// In release builds, just use typedef
+typedef wxAutoBufferedPaintDCBase wxAutoBufferedPaintDC;
+
+#endif
+
+
+#endif  // _WX_DCBUFFER_H_
--- wxWidgets.orig/include/wx/dfb/window.h	Sat Sep 23 16:45:42 2006
+++ wxWidgets/include/wx/dfb/window.h	Sat Sep 23 16:51:22 2006
@@ -110,4 +110,7 @@
     void OnInternalIdle();
 
+    // FIXME: Have this return correct value for this platform.
+    bool IsDoubleBuffered() const { return false; }
+
 protected:
     // implement the base class pure virtuals
--- wxWidgets.orig/include/wx/gtk/dc.h	Sat Sep  9 14:56:50 2006
+++ wxWidgets/include/wx/gtk/dc.h	Fri Sep 22 12:40:01 2006
@@ -95,4 +95,6 @@
     virtual void ComputeScaleAndOrigin();
 
+    virtual GdkWindow* GetGDKWindow() const { return NULL; }
+
 protected:
     // implementation
--- wxWidgets.orig/include/wx/gtk/dcclient.h	Tue Sep 12 17:32:58 2006
+++ wxWidgets/include/wx/gtk/dcclient.h	Fri Sep 22 12:31:27 2006
@@ -100,4 +100,6 @@
     virtual void SetAxisOrientation( bool xLeftRight, bool yBottomUp );
 
+    virtual GdkWindow* GetGDKWindow() const { return m_window; }
+
 // protected:
     // implementation
--- wxWidgets.orig/include/wx/gtk/window.h	Tue Sep 19 22:32:13 2006
+++ wxWidgets/include/wx/gtk/window.h	Fri Sep 22 12:40:01 2006
@@ -125,4 +125,5 @@
     // currently wxGTK2-only
     void SetDoubleBuffered(bool on);
+    bool IsDoubleBuffered() const;
 
     // implementation
--- wxWidgets.orig/include/wx/gtk1/dc.h	Sat Sep  9 14:56:51 2006
+++ wxWidgets/include/wx/gtk1/dc.h	Fri Sep 22 20:01:19 2006
@@ -67,4 +67,6 @@
     virtual void ComputeScaleAndOrigin();
 
+    virtual GdkWindow* GetGDKWindow() const { return NULL; }
+
     wxCoord XDEV2LOG(wxCoord x) const
     {
--- wxWidgets.orig/include/wx/gtk1/dcclient.h	Mon Jan 23 04:27:56 2006
+++ wxWidgets/include/wx/gtk1/dcclient.h	Fri Sep 22 20:02:27 2006
@@ -101,4 +101,6 @@
     virtual int GetDepth() const;
 
+    virtual GdkWindow* GetGDKWindow() const { return m_window; }
+
     // implementation
     // --------------
--- wxWidgets.orig/include/wx/gtk1/window.h	Mon Jan 23 04:28:01 2006
+++ wxWidgets/include/wx/gtk1/window.h	Fri Sep 22 20:00:04 2006
@@ -109,4 +109,6 @@
 #endif // wxUSE_DRAG_AND_DROP
 
+    bool IsDoubleBuffered() const { return false; }
+
     // implementation
     // --------------
--- wxWidgets.orig/include/wx/mac/carbon/window.h	Tue Sep 12 17:33:01 2006
+++ wxWidgets/include/wx/mac/carbon/window.h	Fri Sep 22 20:06:31 2006
@@ -143,4 +143,6 @@
     bool AcceptsFocus() const;
 
+    bool IsDoubleBuffered() const { return true; }
+
 public:
     static long         MacRemoveBordersFromStyle( long style ) ;
--- wxWidgets.orig/include/wx/mac/classic/window.h	Mon Nov  7 16:37:13 2005
+++ wxWidgets/include/wx/mac/classic/window.h	Fri Sep 22 20:10:51 2006
@@ -148,4 +148,7 @@
     bool AcceptsFocus() const ;
 
+    // FIXME: Have this return correct value for this platform.
+    bool IsDoubleBuffered() const { return false; }
+
 public:
     void OnInternalIdle();
--- wxWidgets.orig/include/wx/mgl/window.h	Fri Nov  4 20:49:47 2005
+++ wxWidgets/include/wx/mgl/window.h	Fri Sep 22 20:10:35 2006
@@ -101,4 +101,7 @@
     void OnInternalIdle();
 
+    // FIXME: Have this return correct value for this platform.
+    bool IsDoubleBuffered() const { return false; }
+
 protected:
     // the window handle
--- wxWidgets.orig/include/wx/motif/window.h	Thu Nov  3 22:58:01 2005
+++ wxWidgets/include/wx/motif/window.h	Fri Sep 22 20:11:19 2006
@@ -148,4 +148,7 @@
     void OnInternalIdle();
 
+    // FIXME: Have this return correct value for this platform.
+    bool IsDoubleBuffered() const { return false; }
+
 protected:
     // Responds to colour changes: passes event on to children.
--- wxWidgets.orig/include/wx/msw/missing.h	Sat Sep  9 14:56:54 2006
+++ wxWidgets/include/wx/msw/missing.h	Thu Sep 21 17:44:15 2006
@@ -127,4 +127,8 @@
 #endif
 
+#ifndef WS_EX_COMPOSITED
+#define WS_EX_COMPOSITED 0x02000000L
+#endif
+
 #ifndef WS_EX_LAYERED
 #define WS_EX_LAYERED 0x00080000
--- wxWidgets.orig/include/wx/msw/window.h	Fri Sep 15 17:49:26 2006
+++ wxWidgets/include/wx/msw/window.h	Fri Sep 22 12:40:04 2006
@@ -421,4 +421,7 @@
     bool IsMouseInWindow() const;
 
+    // check if a native double-buffering applies for this window
+    bool IsDoubleBuffered() const;
+
     // synthesize a wxEVT_LEAVE_WINDOW event and set m_mouseInWindow to false
     void GenerateMouseLeave();
--- wxWidgets.orig/include/wx/os2/window.h	Fri Aug 25 17:22:51 2006
+++ wxWidgets/include/wx/os2/window.h	Fri Sep 22 20:12:21 2006
@@ -181,4 +181,7 @@
     void             SetTransparentBackground(bool bT = true) { m_bBackgroundTransparent = bT; }
 
+    // FIXME: Have this return correct value for this platform.
+    bool IsDoubleBuffered() const { return false; }
+
     // event handlers
     // --------------
--- wxWidgets.orig/include/wx/palmos/window.h	Fri Nov 18 20:34:13 2005
+++ wxWidgets/include/wx/palmos/window.h	Fri Sep 22 20:13:30 2006
@@ -136,4 +136,7 @@
     virtual WXWidget GetHandle() const { return GetWinHandle(); }
 
+    // FIXME: Have this return correct value for this platform.
+    bool IsDoubleBuffered() const { return false; }
+
     // event handlers
     // --------------
--- wxWidgets.orig/include/wx/richtext/richtextctrl.h	Mon Sep 25 18:51:58 2006
+++ wxWidgets/include/wx/richtext/richtextctrl.h	Mon Sep 25 18:56:34 2006
@@ -610,7 +610,4 @@
     virtual void PaintBackground(wxDC& dc);
 
-    /// Recreate buffer bitmap if necessary
-    virtual bool RecreateBuffer(const wxSize& size = wxDefaultSize);
-
     /// Set the selection
     virtual void DoSetSelection(long from, long to, bool scrollCaret = true);
@@ -732,7 +729,4 @@
     /// Allows nested Freeze/Thaw
     int                     m_freezeCount;
-
-    /// Buffer bitmap
-    wxBitmap                m_bufferBitmap;
 
     /// Text buffer
--- wxWidgets.orig/include/wx/vlbox.h	Tue Jan 17 18:58:58 2006
+++ wxWidgets/include/wx/vlbox.h	Thu Sep 21 14:14:32 2006
@@ -288,7 +288,4 @@
     wxColour m_colBgSel;
 
-    // double buffer
-    wxBitmap* m_doubleBuffer;
-
     DECLARE_EVENT_TABLE()
     DECLARE_NO_COPY_CLASS(wxVListBox)
--- wxWidgets.orig/include/wx/x11/window.h	Thu Nov 10 14:03:37 2005
+++ wxWidgets/include/wx/x11/window.h	Fri Sep 22 20:14:27 2006
@@ -150,4 +150,7 @@
     virtual void OnInternalIdle();
 
+    // FIXME: Have this return correct value for this platform.
+    bool IsDoubleBuffered() const { return false; }
+
 protected:
     // Responds to colour changes: passes event on to children.
--- wxWidgets.orig/src/common/combocmn.cpp	Mon Sep 25 18:52:30 2006
+++ wxWidgets/src/common/combocmn.cpp	Mon Sep 25 19:22:13 2006
@@ -36,5 +36,4 @@
 #endif
 
-#include "wx/dcbuffer.h"
 #include "wx/tooltip.h"
 
@@ -611,7 +610,4 @@
 IMPLEMENT_ABSTRACT_CLASS(wxComboCtrlBase, wxControl)
 
-// Have global double buffer - should be enough for multiple combos
-static wxBitmap* gs_doubleBuffer = (wxBitmap*) NULL;
-
 void wxComboCtrlBase::Init()
 {
@@ -738,7 +734,4 @@
         ReleaseMouse();
 
-    delete gs_doubleBuffer;
-    gs_doubleBuffer = (wxBitmap*) NULL;
-
 #if INSTALL_TOPLEV_HANDLER
     delete ((wxComboFrameEventHandler*)m_toplevEvtHandler);
@@ -1237,17 +1230,4 @@
         Refresh();
     }
-}
-
-wxBitmap& wxComboCtrlBase::GetBufferBitmap( const wxSize& sz ) const
-{
-    // If size is larger, recalculate double buffer bitmap
-    if ( !gs_doubleBuffer ||
-         sz.x > gs_doubleBuffer->GetWidth() ||
-         sz.y > gs_doubleBuffer->GetHeight() )
-    {
-        delete gs_doubleBuffer;
-        gs_doubleBuffer = new wxBitmap(sz.x+25,sz.y);
-    }
-    return *gs_doubleBuffer;
 }
 
--- wxWidgets.orig/src/common/dcbufcmn.cpp	Mon Sep 25 20:33:24 2006
+++ wxWidgets/src/common/dcbufcmn.cpp	Mon Sep 25 18:34:12 2006
@@ -0,0 +1,136 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        src/common/dcbufcmn.cpp
+// Purpose:     Buffered DC implementation
+// Author:      Ron Lee, Jaakko Salli
+// Modified by:
+// Created:     Sep-20-2006
+// RCS-ID:      $Id:
+// Copyright:   (c) wxWidgets team
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+// ============================================================================
+// declarations
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// headers
+// ----------------------------------------------------------------------------
+
+// For compilers that support precompilation, includes "wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#ifndef WX_PRECOMP
+#endif
+
+#include "wx/dcbuffer.h"
+
+
+// ============================================================================
+// implementation
+// ============================================================================
+
+// ============================================================================
+// wxSharedDCBufferManager
+//   Helper class to free shared buffer when the app exists.
+// ============================================================================
+
+class wxSharedDCBufferManager
+{
+    friend class wxBufferedDC;
+public:
+
+    wxSharedDCBufferManager()
+    {
+        m_buffer = NULL;
+    }
+
+    ~wxSharedDCBufferManager()
+    {
+        delete m_buffer;
+    }
+
+    wxBitmap* GetBuffer(wxWindow* win, const wxSize& area)
+    {
+        int width = area.x;
+        int height = area.y;
+
+        if ( width <= 0 )
+            win->GetClientSize(&width, &height);
+
+        if ( !m_buffer ||
+             width > m_buffer->GetWidth() ||
+             height > m_buffer->GetHeight() )
+        {
+            delete m_buffer;
+
+            // Create slightly larger bitmap so we don't need to
+            // be reallocating constantly when the user enlarges
+            // the frame for the first time.
+            m_buffer = new wxBitmap(width+20, height+20);
+        }
+
+        return m_buffer;
+    }
+
+private:
+    wxBitmap*   m_buffer;
+};
+
+static wxSharedDCBufferManager gs_sharedDCBufferManager;
+
+// ============================================================================
+// wxBufferedDC
+// ============================================================================
+
+// Blits the buffer to the dc, and detaches the dc from the buffer (so it
+// can be effectively used once only).
+//
+// Usually called in the dtor or by the dtor of derived classes if the
+// BufferedDC must blit before the derived class (which may own the dc it's
+// blitting to) is destroyed.
+void wxBufferedDC::UnMask()
+{
+    if ( m_buffer )
+    {
+        wxASSERT_MSG( m_mainDc != NULL,
+                      _T("No underlying DC associated with wxBufferedDC (anymore)") );
+
+        wxDC* bufferDc = DetachDC();
+
+        wxASSERT( bufferDc->IsKindOf(CLASSINFO(wxMemoryDC)) );
+
+        wxCoord x=0, y=0;
+
+        if (m_style & wxBUFFER_CLIENT_AREA)
+            bufferDc->GetDeviceOrigin(& x, & y);
+
+        m_mainDc->Blit( 0, 0,
+                        m_buffer->GetWidth(), m_buffer->GetHeight(), bufferDc,
+                        -x, -y );
+        m_mainDc = NULL;
+        m_buffer = NULL;
+        delete bufferDc;
+    }
+}
+
+void wxBufferedDC::PrepareBuffer(wxWindow* win, const wxSize& area)
+{
+    m_buffer = gs_sharedDCBufferManager.GetBuffer(win, area);
+}
+
+void wxBufferedDC::UseBuffer()
+{
+    wxASSERT(m_buffer);
+
+    wxMemoryDC* memoryDc = new wxMemoryDC(m_mainDc);
+    memoryDc->SelectObject(*m_buffer);
+
+    AttachDC(memoryDc);
+}
+
+
--- wxWidgets.orig/src/generic/combog.cpp	Tue Sep 19 22:33:11 2006
+++ wxWidgets/src/generic/combog.cpp	Sun Sep 24 13:05:20 2006
@@ -202,5 +202,5 @@
 {
     wxSize sz = GetClientSize();
-    wxBufferedPaintDC dc(this,GetBufferBitmap(sz));
+    wxAutoBufferedPaintDC dc(this);
 
     const wxRect& rectb = m_btnArea;
--- wxWidgets.orig/src/generic/datavgen.cpp	Sat Sep  9 14:57:24 2006
+++ wxWidgets/src/generic/datavgen.cpp	Mon Sep 25 17:55:03 2006
@@ -36,4 +36,5 @@
 #include "wx/popupwin.h"
 #include "wx/renderer.h"
+#include "wx/dcbuffer.h"
 
 //-----------------------------------------------------------------------------
@@ -610,4 +611,5 @@
 
     wxVisualAttributes attr = wxPanel::GetClassDefaultAttributes();
+    SetBackgroundStyle( wxBG_STYLE_CUSTOM );
     SetOwnForegroundColour( attr.colFg );
     SetOwnBackgroundColour( attr.colBg );
@@ -626,5 +628,8 @@
     GetClientSize( &w, &h );
 
-    wxPaintDC dc( this );
+    wxAutoBufferedPaintDC dc( this );
+
+    dc.SetBackground(GetBackgroundColour());
+    dc.Clear();
 
     int xpix;
@@ -881,4 +886,5 @@
     m_hasFocus = false;
 
+    SetBackgroundStyle( wxBG_STYLE_CUSTOM );
     SetBackgroundColour( *wxWHITE );
 
@@ -1022,5 +1028,8 @@
 void wxDataViewMainWindow::OnPaint( wxPaintEvent &WXUNUSED(event) )
 {
-    wxPaintDC dc( this );
+    wxAutoBufferedPaintDC dc( this );
+
+    dc.SetBackground(GetBackgroundColour());
+    dc.Clear();
 
     GetOwner()->PrepareDC( dc );
--- wxWidgets.orig/src/generic/vlbox.cpp	Sun Aug 13 14:25:32 2006
+++ wxWidgets/src/generic/vlbox.cpp	Mon Sep 25 19:26:06 2006
@@ -65,5 +65,4 @@
     m_anchor = wxNOT_FOUND;
     m_selStore = NULL;
-    m_doubleBuffer = NULL;
 }
 
@@ -95,5 +94,4 @@
 wxVListBox::~wxVListBox()
 {
-    delete m_doubleBuffer;
     delete m_selStore;
 }
@@ -361,16 +359,7 @@
 void wxVListBox::OnPaint(wxPaintEvent& WXUNUSED(event))
 {
-    // If size is larger, recalculate double buffer bitmap
     wxSize clientSize = GetClientSize();
 
-    if ( !m_doubleBuffer ||
-         clientSize.x > m_doubleBuffer->GetWidth() ||
-         clientSize.y > m_doubleBuffer->GetHeight() )
-    {
-        delete m_doubleBuffer;
-        m_doubleBuffer = new wxBitmap(clientSize.x+25,clientSize.y+25);
-    }
-
-    wxBufferedPaintDC dc(this,*m_doubleBuffer);
+    wxAutoBufferedPaintDC dc(this);
 
     // the update rectangle
--- wxWidgets.orig/src/gtk/renderer.cpp	Fri Sep 15 17:50:16 2006
+++ wxWidgets/src/gtk/renderer.cpp	Mon Sep 25 20:28:52 2006
@@ -193,4 +193,8 @@
     GtkWidget *button = GetButtonWidget();
 
+    GdkWindow* gdk_window = dc.GetGDKWindow();
+    wxASSERT_MSG( gdk_window,
+                  wxT("cannot use wxRendererNative on wxDC of this type") );
+
     int x_diff = 0;
     if (win->GetLayoutDirection() == wxLayout_RightToLeft)
@@ -200,7 +204,5 @@
     (
         button->style,
-        // FIXME: I suppose GTK_PIZZA(win->m_wxwindow)->bin_window doesn't work with wxMemoryDC.
-        //   Maybe use code similar as in DrawPushButton below?
-        GTK_PIZZA(win->m_wxwindow)->bin_window,
+        gdk_window,
         flags & wxCONTROL_DISABLED ? GTK_STATE_INSENSITIVE : GTK_STATE_NORMAL,
         GTK_SHADOW_OUT,
@@ -221,4 +223,8 @@
     GtkWidget *tree = GetTreeWidget();
 
+    GdkWindow* gdk_window = dc.GetGDKWindow();
+    wxASSERT_MSG( gdk_window,
+                  wxT("cannot use wxRendererNative on wxDC of this type") );
+
     GtkStateType state;
     if ( flags & wxCONTROL_CURRENT )
@@ -230,5 +236,5 @@
     if (win->GetLayoutDirection() == wxLayout_RightToLeft)
         x_diff = rect.width;
-        
+
     // VZ: I don't know how to get the size of the expander so as to centre it
     //     in the given rectangle, +2/3 below is just what looks good here...
@@ -236,5 +242,5 @@
     (
         tree->style,
-        GTK_PIZZA(win->m_wxwindow)->bin_window,
+        gdk_window,
         state,
         NULL,
@@ -300,4 +306,8 @@
     }
 
+    GdkWindow* gdk_window = dc.GetGDKWindow();
+    wxASSERT_MSG( gdk_window,
+                  wxT("cannot use wxRendererNative on wxDC of this type") );
+
     wxCoord full_size = GetGtkSplitterFullSize();
 
@@ -333,5 +343,5 @@
     (
         win->m_wxwindow->style,
-        GTK_PIZZA(win->m_wxwindow)->bin_window,
+        gdk_window,
         flags & wxCONTROL_CURRENT ? GTK_STATE_PRELIGHT : GTK_STATE_NORMAL,
         GTK_SHADOW_NONE,
@@ -348,5 +358,5 @@
 
 void
-wxRendererGTK::DrawDropArrow(wxWindow *win,
+wxRendererGTK::DrawDropArrow(wxWindow *WXUNUSED(win),
                              wxDC& dc,
                              const wxRect& rect,
@@ -360,9 +370,7 @@
     // is wxWindowDC (wxClientDC, wxMemoryDC and wxPaintDC
     // are derived from it) and use its m_window.
-    wxWindowDC& wdc = (wxWindowDC&)dc;
-
-    // only doing debug-time checking here (it should
-    // probably be enough)
-    wxASSERT ( wdc.IsKindOf(CLASSINFO(wxWindowDC)) );
+    GdkWindow* gdk_window = dc.GetGDKWindow();
+    wxASSERT_MSG( gdk_window,
+                  wxT("cannot use wxRendererNative on wxDC of this type") );
 
     // draw arrow so that there is even space horizontally
@@ -391,5 +399,5 @@
     (
         button->style,
-        wdc.m_window,
+        gdk_window,
         state,
         flags & wxCONTROL_PRESSED ? GTK_SHADOW_IN : GTK_SHADOW_OUT,
@@ -417,5 +425,5 @@
 
 void
-wxRendererGTK::DrawCheckBox(wxWindow *win,
+wxRendererGTK::DrawCheckBox(wxWindow *WXUNUSED(win),
                             wxDC& dc,
                             const wxRect& rect,
@@ -425,6 +433,7 @@
 
     // for reason why we do this, see DrawDropArrow
-    wxWindowDC& wdc = (wxWindowDC&)dc;
-    wxASSERT ( wdc.IsKindOf(CLASSINFO(wxWindowDC)) );
+    GdkWindow* gdk_window = dc.GetGDKWindow();
+    wxASSERT_MSG( gdk_window,
+                  wxT("cannot use wxRendererNative on wxDC of this type") );
 
     GtkStateType state;
@@ -442,5 +451,5 @@
     (
         button->style,
-        wdc.m_window,
+        gdk_window,
         state,
         flags & wxCONTROL_CHECKED ? GTK_SHADOW_IN : GTK_SHADOW_OUT,
@@ -455,5 +464,5 @@
 
 void
-wxRendererGTK::DrawPushButton(wxWindow *win,
+wxRendererGTK::DrawPushButton(wxWindow *WXUNUSED(win),
                               wxDC& dc,
                               const wxRect& rect,
@@ -463,6 +472,7 @@
 
     // for reason why we do this, see DrawDropArrow
-    wxWindowDC& wdc = (wxWindowDC&)dc;
-    wxASSERT ( wdc.IsKindOf(CLASSINFO(wxWindowDC)) );
+    GdkWindow* gdk_window = dc.GetGDKWindow();
+    wxASSERT_MSG( gdk_window,
+                  wxT("cannot use wxRendererNative on wxDC of this type") );
 
     // draw button
@@ -481,5 +491,5 @@
     (
         button->style,
-        wdc.m_window,
+        gdk_window,
         state,
         flags & wxCONTROL_PRESSED ? GTK_SHADOW_IN : GTK_SHADOW_OUT,
@@ -497,4 +507,8 @@
                                      int flags )
 {
+    GdkWindow* gdk_window = dc.GetGDKWindow();
+    wxASSERT_MSG( gdk_window,
+                  wxT("cannot use wxRendererNative on wxDC of this type") );
+
     GtkStateType state;
     if (flags & wxCONTROL_SELECTED)
@@ -506,5 +520,5 @@
 
         gtk_paint_flat_box( win->m_wxwindow->style,
-                        GTK_PIZZA(win->m_wxwindow)->bin_window,
+                        gdk_window,
                         state,
                         GTK_SHADOW_NONE,
--- wxWidgets.orig/src/gtk/window.cpp	Tue Sep 19 22:33:13 2006
+++ wxWidgets/src/gtk/window.cpp	Fri Sep 22 12:40:10 2006
@@ -3936,4 +3936,9 @@
 }
 
+bool wxWindowGTK::IsDoubleBuffered() const
+{
+    return GTK_WIDGET_DOUBLE_BUFFERED( m_wxwindow );
+}
+
 void wxWindowGTK::ClearBackground()
 {
--- wxWidgets.orig/src/gtk1/renderer.cpp	Sun May  7 00:50:49 2006
+++ wxWidgets/src/gtk1/renderer.cpp	Fri Sep 22 19:58:46 2006
@@ -310,9 +310,7 @@
     // is wxWindowDC (wxClientDC, wxMemoryDC and wxPaintDC
     // are derived from it) and use its m_window.
-    wxWindowDC& wdc = (wxWindowDC&)dc;
-
-    // only doing debug-time checking here (it should
-    // probably be enough)
-    wxASSERT ( wdc.IsKindOf(CLASSINFO(wxWindowDC)) );
+    GdkWindow* gdk_window = dc.GetGDKWindow();
+    wxASSERT_MSG( gdk_window,
+                  wxT("cannot use wxRendererNative on wxDC of this type") );
 
     // draw arrow so that there is even space horizontally
@@ -341,5 +339,5 @@
     (
         button->style,
-        wdc.m_window,
+        gdk_window,
         state,
         flags & wxCONTROL_PRESSED ? GTK_SHADOW_IN : GTK_SHADOW_OUT,
@@ -365,6 +363,7 @@
 
     // for reason why we do this, see DrawDropArrow
-    wxWindowDC& wdc = (wxWindowDC&)dc;
-    wxASSERT ( wdc.IsKindOf(CLASSINFO(wxWindowDC)) );
+    GdkWindow* gdk_window = dc.GetGDKWindow();
+    wxASSERT_MSG( gdk_window,
+                  wxT("cannot use wxRendererNative on wxDC of this type") );
 
     // draw button
@@ -383,5 +382,5 @@
     (
         button->style,
-        wdc.m_window,
+        gdk_window,
         state,
         flags & wxCONTROL_PRESSED ? GTK_SHADOW_IN : GTK_SHADOW_OUT,
--- wxWidgets.orig/src/msw/combo.cpp	Fri Sep 15 17:50:56 2006
+++ wxWidgets/src/msw/combo.cpp	Mon Sep 25 19:38:30 2006
@@ -389,5 +389,5 @@
 
     wxSize sz = GetClientSize();
-    wxBufferedPaintDC dc(this,GetBufferBitmap(sz));
+    wxAutoBufferedPaintDC dc(this);
 
     const wxRect& rectb = m_btnArea;
--- wxWidgets.orig/src/msw/window.cpp	Tue Sep 12 17:33:55 2006
+++ wxWidgets/src/msw/window.cpp	Fri Sep 22 12:40:13 2006
@@ -3951,4 +3951,18 @@
 }
 
+bool wxWindowMSW::IsDoubleBuffered() const
+{
+    const wxWindow* wnd = this;
+
+    while ( wnd )
+    {
+        if ( ::GetWindowLong((HWND)wnd->GetHWND(), GWL_EXSTYLE) & WS_EX_COMPOSITED )
+            return true;
+        wnd = wnd->GetParent();
+    }
+
+    return false;
+}
+
 // ---------------------------------------------------------------------------
 // owner drawn stuff
--- wxWidgets.orig/src/richtext/richtextctrl.cpp	Mon Sep 25 18:52:54 2006
+++ wxWidgets/src/richtext/richtextctrl.cpp	Mon Sep 25 18:58:09 2006
@@ -156,7 +156,4 @@
     SetBestFittingSize(size);
 
-    // Create a buffer
-    RecreateBuffer(size);
-
     SetCursor(wxCursor(wxCURSOR_IBEAM));
 
@@ -236,5 +233,5 @@
 
     {
-        wxBufferedPaintDC dc(this, m_bufferBitmap);
+        wxAutoBufferedPaintDC dc(this);
         //wxLogDebug(wxT("OnPaint"));
 
@@ -1413,6 +1410,4 @@
         GetBuffer().Invalidate(wxRICHTEXT_ALL);
 
-    RecreateBuffer();
-
     event.Skip();
 }
@@ -1505,19 +1500,4 @@
     CalcUnscrolledPosition(windowRect.x, windowRect.y, & windowRect.x, & windowRect.y);
     dc.DrawRectangle(windowRect);
-}
-
-/// Recreate buffer bitmap if necessary
-bool wxRichTextCtrl::RecreateBuffer(const wxSize& size)
-{
-    wxSize sz = size;
-    if (sz == wxDefaultSize)
-        sz = GetClientSize();
-
-    if (sz.x < 1 || sz.y < 1)
-        return false;
-
-    if (!m_bufferBitmap.Ok() || m_bufferBitmap.GetWidth() < sz.x || m_bufferBitmap.GetHeight() < sz.y)
-        m_bufferBitmap = wxBitmap(sz.x, sz.y);
-    return m_bufferBitmap.Ok();
 }
 

 	  	 
