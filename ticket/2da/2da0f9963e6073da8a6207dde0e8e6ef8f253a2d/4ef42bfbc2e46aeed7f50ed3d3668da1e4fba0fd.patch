diff -bu2rN wxOld/build/bakefiles/files.bkl wxWidgets/build/bakefiles/files.bkl
--- wxOld/build/bakefiles/files.bkl	2006-03-12 10:39:37.000000000 -0800
+++ wxWidgets/build/bakefiles/files.bkl	2006-03-12 10:43:30.000000000 -0800
@@ -957,4 +957,5 @@
     src/gtk/textctrl.cpp
     src/gtk/tglbtn.cpp
+    src/gtk/treectrl.cpp
     src/gtk/treeentry_gtk.c
     src/gtk/utilsres.cpp
diff -bu2rN wxOld/include/wx/generic/treectlg.h wxWidgets/include/wx/generic/treectlg.h
--- wxOld/include/wx/generic/treectlg.h	2006-03-12 10:39:42.000000000 -0800
+++ wxWidgets/include/wx/generic/treectlg.h	2006-03-12 11:09:36.000000000 -0800
@@ -350,5 +350,5 @@
 };
 
-#if !defined(__WXMSW__) || defined(__WXUNIVERSAL__)
+#if (!wxUSE_NATIVE_GTK2TREECTRL && !defined(__WXMSW__)) || defined(__WXUNIVERSAL__)
 /*
  * wxTreeCtrl has to be a real class or we have problems with
diff -bu2rN wxOld/include/wx/gtk/textctrl.h wxWidgets/include/wx/gtk/textctrl.h
--- wxOld/include/wx/gtk/textctrl.h	2006-03-12 10:39:42.000000000 -0800
+++ wxWidgets/include/wx/gtk/textctrl.h	2006-03-12 10:49:09.000000000 -0800
@@ -168,4 +168,7 @@
     GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL);
 
+    virtual void AssociateHandle(GtkWidget* handle);
+    virtual void DissociateHandle();
+
 protected:
     virtual wxSize DoGetBestSize() const;
diff -bu2rN wxOld/include/wx/gtk/treectrl.h wxWidgets/include/wx/gtk/treectrl.h
--- wxOld/include/wx/gtk/treectrl.h	2006-03-12 10:39:42.000000000 -0800
+++ wxWidgets/include/wx/gtk/treectrl.h	2006-03-12 11:42:00.000000000 -0800
@@ -2,9 +2,9 @@
 // Name:        treectrl.h
 // Purpose:     wxTreeCtrl class
-// Author:      Denis Pershin
+// Author:      Ryan Norton
 // Modified by:
-// Created:     08/08/98
+// Created:     02/22/06
 // RCS-ID:      $Id: treectrl.h,v 1.21 2005/09/23 12:49:20 MR Exp $
-// Copyright:   (c) Denis Pershin
+// Copyright:   (c) Ryan Norton
 // Licence:     wxWindows licence
 /////////////////////////////////////////////////////////////////////////////
@@ -13,130 +13,20 @@
 #define _WX_TREECTRL_H_
 
-#include "wx/textctrl.h"
-#include "wx/imaglist.h"
-
-#include <gtk/gtk.h>
-
-// the type for "untyped" data
-typedef long wxDataType;
-
-// fwd decl
-class  WXDLLIMPEXP_CORE wxImageList;
-struct wxTreeViewItem;
-
-// a callback function used for sorting tree items, it should return -1 if the
-// first item precedes the second, +1 if the second precedes the first or 0 if
-// they're equivalent
-class WXDLLIMPEXP_CORE wxTreeItemData;
-typedef int (*wxTreeItemCmpFunc)(wxTreeItemData *item1, wxTreeItemData *item2);
-
-// ----------------------------------------------------------------------------
-// constants
-// ----------------------------------------------------------------------------
-
-// values for the `flags' parameter of wxTreeCtrl::HitTest() which determine
-// where exactly the specified point is situated:
-    // above the client area.
-static const int wxTREE_HITTEST_ABOVE            = 0x0001;
-    // below the client area.
-static const int wxTREE_HITTEST_BELOW            = 0x0002;
-    // in the client area but below the last item.
-static const int wxTREE_HITTEST_NOWHERE          = 0x0004;
-    // on the button associated with an item.
-static const int wxTREE_HITTEST_ONITEMBUTTON     = 0x0010;
-    // on the bitmap associated with an item.
-static const int wxTREE_HITTEST_ONITEMICON       = 0x0020;
-    // in the indentation associated with an item.
-static const int wxTREE_HITTEST_ONITEMINDENT     = 0x0040;
-    // on the label (string) associated with an item.
-static const int wxTREE_HITTEST_ONITEMLABEL      = 0x0080;
-    // in the area to the right of an item.
-static const int wxTREE_HITTEST_ONITEMRIGHT      = 0x0100;
-    // on the state icon for a tree view item that is in a user-defined state.
-static const int wxTREE_HITTEST_ONITEMSTATEICON  = 0x0200;
-    // to the right of the client area.
-static const int wxTREE_HITTEST_TOLEFT           = 0x0400;
-    // to the left of the client area.
-static const int wxTREE_HITTEST_TORIGHT          = 0x0800;
-    // anywhere on the item
-static const int wxTREE_HITTEST_ONITEM  = wxTREE_HITTEST_ONITEMICON |
-                                          wxTREE_HITTEST_ONITEMLABEL |
-                                          wxTREE_HITTEST_ONITEMSTATEICON;
-
-// NB: all the following flags are for compatbility only and will be removed in
-//     next versions
-
-// flags for deprecated InsertItem() variant
-#define wxTREE_INSERT_FIRST 0xFFFF0001
-#define wxTREE_INSERT_LAST  0xFFFF0002
-
-// ----------------------------------------------------------------------------
-// wxTreeItemId identifies an element of the tree. In this implementation, it's
-// just a trivial wrapper around GTK GtkTreeItem *. It's opaque for the
-// application.
-// ----------------------------------------------------------------------------
-class WXDLLEXPORT wxTreeItemId {
-public:
-  // ctors
-  wxTreeItemId() { m_itemId = NULL; }
-
-      // default copy ctor/assignment operator are ok for us
-
-  // accessors
-      // is this a valid tree item?
-  bool IsOk() const { return m_itemId != NULL; }
-
-  // conversion to/from either real (system-dependent) tree item id or
-  // to "long" which used to be the type for tree item ids in previous
-  // versions of wxWidgets
-
-  // for wxTreeCtrl usage only
-  wxTreeItemId(GtkTreeItem *itemId) { m_itemId = itemId; }
-  operator GtkTreeItem *() const { return m_itemId; }
-  void operator =(GtkTreeItem *item) { m_itemId = item; }
-
-protected:
-  GtkTreeItem *m_itemId;
-};
-
-// ----------------------------------------------------------------------------
-// wxTreeItemData is some (arbitrary) user class associated with some item. The
-// main advantage of having this class (compared to old untyped interface) is
-// that wxTreeItemData's are destroyed automatically by the tree and, as this
-// class has virtual dtor, it means that the memory will be automatically
-// freed. OTOH, we don't just use wxObject instead of wxTreeItemData because
-// the size of this class is critical: in any real application, each tree leaf
-// will have wxTreeItemData associated with it and number of leaves may be
-// quite big.
-//
-// Because the objects of this class are deleted by the tree, they should
-// always be allocated on the heap!
-// ----------------------------------------------------------------------------
-class WXDLLEXPORT wxTreeItemData : private wxTreeItemId {
-public:
-    // default ctor/copy ctor/assignment operator are ok
-
-    // dtor is virtual and all the items are deleted by the tree control when
-    // it's deleted, so you normally don't have to care about freeing memory
-    // allocated in your wxTreeItemData-derived class
-    virtual ~wxTreeItemData() { }
-
-    // accessors: set/get the item associated with this node
-    void SetId(const wxTreeItemId& id) { m_itemId = id; }
-    const wxTreeItemId& GetId() const { return (wxTreeItemId&) m_itemId; }
-};
-
-class WXDLLEXPORT wxTreeCtrl: public wxControl {
+class WXDLLEXPORT wxTreeCtrl: public wxTreeCtrlBase
+{
 public:
   // creation
   // --------
-  wxTreeCtrl() { Init(); }
+    wxTreeCtrl() : m_treeview(NULL), m_textctrl(NULL), 
+                   m_dragstart(wxDefaultPosition) { }
 
   wxTreeCtrl(wxWindow *parent, wxWindowID id = wxID_ANY,
              const wxPoint& pos = wxDefaultPosition,
              const wxSize& size = wxDefaultSize,
-             long style = wxTR_HAS_BUTTONS | wxTR_LINES_AT_ROOT,
+             long style = wxTR_NO_BUTTONS | wxTR_NO_LINES,
              const wxValidator& validator = wxDefaultValidator,
-             const wxString& name = "wxTreeCtrl") {
+             const wxString& name = "wxTreeCtrl") 
+     : m_treeview(NULL), m_textctrl(NULL), m_dragstart(wxDefaultPosition)
+    {
       Create(parent, id, pos, size, style, validator, name);
   }
@@ -155,11 +45,11 @@
 
         // get the total number of items in the control
-    size_t GetCount() const;
+    virtual size_t GetCount() const;
 
         // indent is the number of pixels the children are indented relative to
         // the parents position. SetIndent() also redraws the control
         // immediately.
-    unsigned int GetIndent() const;
-    void SetIndent(unsigned int indent);
+    virtual unsigned int GetIndent() const;
+    virtual void SetIndent(unsigned int indent);
 
         // image list: these functions allow to associate an image list with
@@ -173,9 +63,9 @@
         // which corresponds to an app-defined item state (for example,
         // checked/unchecked) which are taken from the state image list.
-    wxImageList *GetImageList() const;
-    wxImageList *GetStateImageList() const;
+    wxImageList *GetImageList() const { return m_imageListNormal; }
+    wxImageList *GetStateImageList() const { return m_imageListState; }
 
-    void SetImageList(wxImageList *imageList);
-    void SetStateImageList(wxImageList *imageList);
+    virtual void SetImageList(wxImageList *imageList);
+    virtual void SetStateImageList(wxImageList *imageList);
 
     // Functions to work with tree ctrl items. Unfortunately, they can _not_ be
@@ -187,24 +77,64 @@
     // ---------
 
+        // Get item spacing between image and text
+    virtual unsigned int GetSpacing() const;
+
         // retrieve items label
-    wxString GetItemText(const wxTreeItemId& item) const;
-        // get the normal item image
-    int GetItemImage(const wxTreeItemId& item) const;
-        // get the selected item image
-    int GetItemSelectedImage(const wxTreeItemId& item) const;
+    virtual wxString GetItemText(const wxTreeItemId& item) const ;
+        // get one of the images associated with the item (normal by default)
+    virtual int GetItemImage(const wxTreeItemId& item,
+                     wxTreeItemIcon which = wxTreeItemIcon_Normal) const;
         // get the data associated with the item
-    wxTreeItemData *GetItemData(const wxTreeItemId& item) const;
+    virtual wxTreeItemData *GetItemData(const wxTreeItemId& item) const;
+
+        // get the item's text colour
+    virtual wxColour GetItemTextColour(const wxTreeItemId& item) const;
+
+        // get the item's background colour
+    virtual wxColour GetItemBackgroundColour(const wxTreeItemId& item) const;
+
+        // get the item's font
+    virtual wxFont GetItemFont(const wxTreeItemId& item) const;
 
     // modifiers
     // ---------
 
+        // set item spacing between image and text
+    virtual void SetSpacing(unsigned int spacing);
+
         // set items label
-    void SetItemText(const wxTreeItemId& item, const wxString& text);
-        // set the normal item image
-    void SetItemImage(const wxTreeItemId& item, int image);
-        // set the selected item image
-    void SetItemSelectedImage(const wxTreeItemId& item, int image);
+    virtual void SetItemText(const wxTreeItemId& item, const wxString& text);
+        // get one of the images associated with the item (normal by default)
+    virtual void SetItemImage(const wxTreeItemId& item,
+                              int image,
+                              wxTreeItemIcon which = wxTreeItemIcon_Normal);
         // associate some data with the item
-    void SetItemData(const wxTreeItemId& item, wxTreeItemData *data);
+    virtual void SetItemData(const wxTreeItemId& item, wxTreeItemData *data);
+
+        // force appearance of [+] button near the item. This is useful to
+        // allow the user to expand the items which don't have any children now
+        // - but instead add them only when needed, thus minimizing memory
+        // usage and loading time.
+    virtual void SetItemHasChildren(const wxTreeItemId& item,
+                                    bool has = true);
+
+        // the item will be shown in bold
+    virtual void SetItemBold(const wxTreeItemId& item, bool bold = true);
+
+        // the item will be shown with a drop highlight
+    virtual void SetItemDropHighlight(const wxTreeItemId& item,
+                                      bool highlight = true);
+
+        // set the items text colour
+    virtual void SetItemTextColour(const wxTreeItemId& item,
+                                   const wxColour& col);
+
+        // set the items background colour
+    virtual void SetItemBackgroundColour(const wxTreeItemId& item,
+                                         const wxColour& col);
+
+        // set the items font (should be of the same height for all items)
+    virtual void SetItemFont(const wxTreeItemId& item,
+                             const wxFont& font);
 
     // item status inquiries
@@ -212,11 +142,16 @@
 
         // is the item visible (it might be outside the view or not expanded)?
-    bool IsVisible(const wxTreeItemId& item) const;
+    virtual bool IsVisible(const wxTreeItemId& item) const;
         // does the item has any children?
-    bool ItemHasChildren(const wxTreeItemId& item) const;
+    virtual bool ItemHasChildren(const wxTreeItemId& item) const;
+        // same as above
+    bool HasChildren(const wxTreeItemId& item) const
+      { return ItemHasChildren(item); }
         // is the item expanded (only makes sense if HasChildren())?
-    bool IsExpanded(const wxTreeItemId& item) const;
+    virtual bool IsExpanded(const wxTreeItemId& item) const;
         // is this item currently selected (the same as has focus)?
-    bool IsSelected(const wxTreeItemId& item) const;
+    virtual bool IsSelected(const wxTreeItemId& item) const;
+        // is item text in bold font?
+    virtual bool IsBold(const wxTreeItemId& item) const;
 
     // number of children
@@ -225,5 +160,6 @@
         // if 'recursively' is false, only immediate children count, otherwise
         // the returned number is the number of all items in this branch
-    size_t GetChildrenCount(const wxTreeItemId& item, bool recursively = true);
+    virtual size_t GetChildrenCount(const wxTreeItemId& item,
+                                    bool recursively = true) const;
 
     // navigation
@@ -233,11 +169,17 @@
 
         // get the root tree item
-    wxTreeItemId GetRootItem() const;
+    virtual wxTreeItemId GetRootItem() const;
 
         // get the item currently selected (may return NULL if no selection)
-    wxTreeItemId GetSelection() const;
+    virtual wxTreeItemId GetSelection() const;
+
+        // get the items currently selected, return the number of such item
+        //
+        // NB: this operation is expensive and can take a long time for a
+        //     control with a lot of items (~ O(number of items)).
+    virtual size_t GetSelections(wxArrayTreeItemIds& selections) const;
 
         // get the parent of this item (may return NULL if root)
-    wxTreeItemId GetItemParent(const wxTreeItemId& item) const;
+    virtual wxTreeItemId GetItemParent(const wxTreeItemId& item) const;
 
         // for this enumeration function you must pass in a "cookie" parameter
@@ -249,22 +191,24 @@
 
         // get the first child of this item
-    wxTreeItemId GetFirstChild(const wxTreeItemId& item, long& cookie) const;
-        // get the next child (after GetFirstChild or GetNextChild)
-    wxTreeItemId GetNextChild(const wxTreeItemId& item, long& cookie) const;
+    virtual wxTreeItemId GetFirstChild(const wxTreeItemId& item,
+                                       wxTreeItemIdValue& cookie) const;
+        // get the next child
+    virtual wxTreeItemId GetNextChild(const wxTreeItemId& item,
+                                      wxTreeItemIdValue& cookie) const;
         // get the last child of this item - this method doesn't use cookies
-    wxTreeItemId GetLastChild(const wxTreeItemId& item) const;
+    virtual wxTreeItemId GetLastChild(const wxTreeItemId& item) const;
 
         // get the next sibling of this item
-    wxTreeItemId GetNextSibling(const wxTreeItemId& item) const;
+    virtual wxTreeItemId GetNextSibling(const wxTreeItemId& item) const;
         // get the previous sibling
-    wxTreeItemId GetPrevSibling(const wxTreeItemId& item) const;
+    virtual wxTreeItemId GetPrevSibling(const wxTreeItemId& item) const;
 
         // get first visible item
-    wxTreeItemId GetFirstVisibleItem() const;
+    virtual wxTreeItemId GetFirstVisibleItem() const;
         // get the next visible item: item must be visible itself!
         // see IsVisible() and wxTreeCtrl::GetFirstVisibleItem()
-    wxTreeItemId GetNextVisible(const wxTreeItemId& item) const;
+    virtual wxTreeItemId GetNextVisible(const wxTreeItemId& item) const;
         // get the previous visible item: item must be visible itself!
-    wxTreeItemId GetPrevVisible(const wxTreeItemId& item) const;
+    virtual wxTreeItemId GetPrevVisible(const wxTreeItemId& item) const;
 
     // operations
@@ -272,50 +216,38 @@
 
         // add the root node to the tree
-    wxTreeItemId AddRoot(const wxString& text,
-                         int image = -1, int selectedImage = -1,
-                         wxTreeItemData *data = NULL);
-
-        // insert a new item in as the first child of the parent
-    wxTreeItemId PrependItem(const wxTreeItemId& parent,
-                             const wxString& text,
-                             int image = -1, int selectedImage = -1,
-                             wxTreeItemData *data = NULL);
-
-        // insert a new item after a given one
-    wxTreeItemId InsertItem(const wxTreeItemId& parent,
-                            const wxTreeItemId& idPrevious,
-                            const wxString& text,
-                            int image = -1, int selectedImage = -1,
-                            wxTreeItemData *data = NULL);
-
-        // insert a new item in as the last child of the parent
-    wxTreeItemId AppendItem(const wxTreeItemId& parent,
-                            const wxString& text,
-                            int image = -1, int selectedImage = -1,
+    virtual wxTreeItemId AddRoot(const wxString& text,
+                                 int image = -1, int selImage = -1,
                             wxTreeItemData *data = NULL);
 
         // delete this item and associated data if any
-    void Delete(const wxTreeItemId& item);
+    virtual void Delete(const wxTreeItemId& item);
+        // delete all children (but don't delete the item itself)
+        // NB: this won't send wxEVT_COMMAND_TREE_ITEM_DELETED events
+    virtual void DeleteChildren(const wxTreeItemId& item);
         // delete all items from the tree
-    void DeleteAllItems();
+        // NB: this won't send wxEVT_COMMAND_TREE_ITEM_DELETED events
+    virtual void DeleteAllItems();
 
         // expand this item
-    void Expand(const wxTreeItemId& item);
+    virtual void Expand(const wxTreeItemId& item);
         // collapse the item without removing its children
-    void Collapse(const wxTreeItemId& item);
+    virtual void Collapse(const wxTreeItemId& item);
         // collapse the item and remove all children
-    void CollapseAndReset(const wxTreeItemId& item);
+    virtual void CollapseAndReset(const wxTreeItemId& item);
         // toggles the current state
-    void Toggle(const wxTreeItemId& item);
+    virtual void Toggle(const wxTreeItemId& item);
 
         // remove the selection from currently selected item (if any)
-    void Unselect();
+    virtual void Unselect();
+        // unselect all items (only makes sense for multiple selection control)
+    virtual void UnselectAll();
         // select this item
-    void SelectItem(const wxTreeItemId& item);
+    virtual void SelectItem(const wxTreeItemId& item, bool select = true);
+
         // make sure this item is visible (expanding the parent item and/or
         // scrolling to this item if necessary)
-    void EnsureVisible(const wxTreeItemId& item);
+    virtual void EnsureVisible(const wxTreeItemId& item);
         // scroll to this item (but don't expand its parent)
-    void ScrollTo(const wxTreeItemId& item);
+    virtual void ScrollTo(const wxTreeItemId& item);
 
         // start editing the item label: this (temporarily) replaces the item
@@ -323,71 +255,121 @@
         // been before. textCtrlClass parameter allows you to create an edit
         // control of arbitrary user-defined class deriving from wxTextCtrl.
-    wxTextCtrl* EditLabel(const wxTreeItemId& item,
+    virtual wxTextCtrl *EditLabel(const wxTreeItemId& item,
                           wxClassInfo* textCtrlClass = CLASSINFO(wxTextCtrl));
+
         // returns the same pointer as StartEdit() if the item is being edited,
         // NULL otherwise (it's assumed that no more than one item may be
         // edited simultaneously)
-    wxTextCtrl* GetEditControl() const;
+    virtual wxTextCtrl *GetEditControl() const;
+
         // end editing and accept or discard the changes to item label
-    void EndEditLabel(const wxTreeItemId& item, bool discardChanges = false);
+    virtual void EndEditLabel(const wxTreeItemId& item,
+                              bool discardChanges = false);
+
+    // sorting
+    // -------
 
-        // sort the children of this item using the specified callback function
-        // (it should return -1, 0 or +1 as usual), if it's not specified
-        // alphabetical comparaison is performed.
+        // sort the children of this item using OnCompareItems
         //
-        // NB: this function is not reentrant!
-    void SortChildren(const wxTreeItemId& item,
-                      wxTreeItemCmpFunc *cmpFunction = NULL);
+        // NB: this function is not reentrant and not MT-safe (FIXME)!
+    virtual void SortChildren(const wxTreeItemId& item);
 
-    // deprecated
-    // ----------
+    // items geometry
+    // --------------
 
-    // these methods are deprecated and will be removed in future versions of
-    // wxWidgets, they're here for compatibility only, don't use them in new
-    // code (the comments indicate why these methods are now useless and how to
-    // replace them)
+        // get the bounding rectangle of the item (or of its label only)
+    virtual bool GetBoundingRect(const wxTreeItemId& item,
+                                 wxRect& rect,
+                                 bool textOnly = false) const;
 
-        // use Expand, Collapse, CollapseAndReset or Toggle
-    void ExpandItem(const wxTreeItemId& item, int action);
+    //-------------------------------------------------------------------------
+    // GTK implementation
 
-        // use AddRoot, PrependItem or AppendItem
-    wxTreeItemId InsertItem(const wxTreeItemId& parent,
+    void GtkUpdateItem(const wxTreeItemId& item);
+    wxTreeItemId GtkInsertItem(const wxTreeItemId& parent,
+                               const wxTreeItemId& idPrevious,
                             const wxString& text,
-                            int image = -1, int selImage = -1,
-                            long insertAfter = wxTREE_INSERT_LAST);
+                               int image, int selImage,
+                               wxTreeItemData *data,
+                               bool bAppend,
+                               struct _GtkTreeEntry* entry = NULL);
+    class wxTreeEntryData* GtkItemEntryData(const wxTreeItemId& item) const;
+    bool GtkSendEvent(struct _GtkTreeIter* iter, const wxEventType& type,
+                      const wxTreeItemId& olditem = wxTreeItemId(),
+                      const wxString& label = wxEmptyString);
+    struct _GtkTreeEntry* GtkIterEntry(struct _GtkTreeIter* iter) const;
+    GtkAdjustment* GtkGetVAdjustment() const;
+    void GtkSelectItem(const wxTreeItemId& item, 
+                       const bool select, const bool blockEvent);
+    void GtkDeleteItem(const wxTreeItemId& item);
+    void GtkRecalcPaths(const wxTreeItemId& item,
+                        const wxTreeItemId& parent,
+                        const wxTreeItemId& prevsib);
+    wxTreeItemId GtkHitTest(const wxPoint& point = wxPoint(0,0), 
+                            int* flags = NULL) const;
+    void GtkMoveAfter(const wxTreeItemId& cur, const wxTreeItemId& next,
+                      const wxTreeItemId& parent, const wxTreeItemId& prev);
+    bool GtkIsValidItem(const wxTreeItemId& item) const;
+    bool GtkIsFakeItem(const wxTreeItemId& item) const;
+    bool GtkIsVirtualRoot(const wxTreeItemId& item) const;
+    wxTreeItemId GtkRealFirstChild(const wxTreeItemId& item) const;
+
+    void OnChar(class wxKeyEvent& event);
+    void OnMiddleDown(class wxMouseEvent& event);
+    void OnRightDown(class wxMouseEvent& event);
+    virtual int OnCompareItems(const wxTreeItemId& item1,
+                               const wxTreeItemId& item2);
+
+    virtual void SetWindowStyleFlag( long style ); //yes, we do support it at runtime
+
+    struct _GtkTreeView  *m_treeview;
+    struct _GtkTreeStore *m_treestore;
+    struct _GtkCellRenderer *m_textrenderer;
+    bool       m_blockEvent;
+    wxArrayTreeItemIds m_lastSelections;
+    wxTreeItemId m_dragitem;
+    wxTextCtrl* m_textctrl;
+    wxTreeItemId m_root, m_separator, m_fakechild; //special and "virtual" items
+    wxPoint m_dragstart;
+
+    // Extra junk 
+    static wxVisualAttributes
+    GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL);
+
+    GtkWidget *GetConnectWidget();
+    bool IsOwnGtkWindow( GdkWindow *window );
+    void OnInternalIdle();
+
+#if wxUSE_TOOLTIPS
+    void ApplyToolTip( GtkTooltips *tips, const wxChar *tip );
+#endif // wxUSE_TOOLTIPS
+    void DoApplyWidgetStyle(GtkRcStyle *style);
 
-        // use Set/GetImageList and Set/GetStateImageList
-    wxImageList *GetImageList(int) const
-        { return GetImageList(); }
-    void SetImageList(wxImageList *imageList, int)
-        { SetImageList(imageList); }
-
-  void SendExpanding(const wxTreeItemId& item);
-  void SendExpanded(const wxTreeItemId& item);
-  void SendCollapsing(const wxTreeItemId& item);
-  void SendCollapsed(const wxTreeItemId& item);
-  void SendSelChanging(const wxTreeItemId& item);
-  void SendSelChanged(const wxTreeItemId& item);
 protected:
-  wxTreeItemId m_editItem;
-  GtkTree *m_tree;
-  GtkTreeItem *m_anchor;
-  wxTextCtrl*  m_textCtrl;
-  wxImageList* m_imageListNormal;
-  wxImageList* m_imageListState;
-
-  long m_curitemId;
-
-  void SendMessage(wxEventType command, const wxTreeItemId& item);
-//  GtkTreeItem *findGtkTreeItem(wxTreeCtrlId &id) const;
-
-    // the common part of all ctors
-  void Init();
-      // insert a new item in as the last child of the parent
-  wxTreeItemId p_InsertItem(GtkTreeItem *p,
+    virtual wxSize DoGetBestSize() const;
+
+    // common part of Append/Prepend/InsertItem()
+    //
+    // pos is the position at which to insert the item or (size_t)-1 to append
+    // it to the end
+    virtual wxTreeItemId DoInsertItem(const wxTreeItemId& parent,
+                                      size_t pos,
                           const wxString& text,
-                          int image, int selectedImage,
+                                      int image, int selImage,
                           wxTreeItemData *data);
 
+    // and this function implements overloaded InsertItem() taking wxTreeItemId
+    // (it can't be called InsertItem() as we'd have virtual function hiding
+    // problem in derived classes then)
+    virtual wxTreeItemId DoInsertAfter(const wxTreeItemId& parent,
+                                       const wxTreeItemId& idPrevious,
+                                       const wxString& text,
+                                       int image = -1, int selImage = -1,
+                                       wxTreeItemData *data = NULL);
+
+    // real HitTest() implementation: again, can't be called just HitTest()
+    // because it's overloaded and so the non-virtual overload would be hidden
+    // (and can't be called DoHitTest() because this is already in wxWindow)
+    virtual wxTreeItemId DoTreeHitTest(const wxPoint& point, int& flags);
 
   DECLARE_DYNAMIC_CLASS(wxTreeCtrl)
diff -bu2rN wxOld/include/wx/gtk/window.h wxWidgets/include/wx/gtk/window.h
--- wxOld/include/wx/gtk/window.h	2006-03-12 10:39:42.000000000 -0800
+++ wxWidgets/include/wx/gtk/window.h	2006-03-12 10:48:22.000000000 -0800
@@ -156,4 +156,5 @@
     virtual bool IsOwnGtkWindow( GdkWindow *window );
     void ConnectWidget( GtkWidget *widget );
+    void DisconnectWidget( GtkWidget *widget );
 
     // Override GTKWidgetNeedsMnemonic and return true if your
@@ -180,5 +181,9 @@
     void GtkUpdateSize() { m_sizeSet = false; }
 
-    // fix up the mouse event coords, used by wxListBox only so far
+    // NB: These currently are only tested on single-line wxTextCtrls
+    virtual void AssociateHandle(GtkWidget* handle);
+    virtual void DissociateHandle();
+
+    // fix up the mouse event coords, not used by anything, really
     virtual void FixUpMouseEvent(GtkWidget * WXUNUSED(widget),
                                  wxCoord& WXUNUSED(x),
diff -bu2rN wxOld/include/wx/treectrl.h wxWidgets/include/wx/treectrl.h
--- wxOld/include/wx/treectrl.h	2006-03-12 10:39:42.000000000 -0800
+++ wxWidgets/include/wx/treectrl.h	2006-03-12 14:00:22.000000000 -0800
@@ -61,6 +61,6 @@
         // spacing is the number of pixels between the start and the Text
         // (has no effect under wxMSW)
-    unsigned int GetSpacing() const { return m_spacing; }
-    void SetSpacing(unsigned int spacing) { m_spacing = spacing; }
+    virtual unsigned int GetSpacing() const { return m_spacing; }
+    virtual void SetSpacing(unsigned int spacing) { m_spacing = spacing; }
 
         // image list: these functions allow to associate an image list with
@@ -411,4 +411,13 @@
 // ----------------------------------------------------------------------------
 
+//turn this to 1 to use the NATIVE gtk2 treectrl, which isn't quite as mature
+//as the generic one
+
+#if defined(__WXGTK__) && defined(__WXGTK20__) 
+    #define wxUSE_NATIVE_GTK2TREECTRL 0
+#else
+    #define wxUSE_NATIVE_GTK2TREECTRL 0
+#endif
+
 #if defined(__WXUNIVERSAL__)
     #include "wx/generic/treectlg.h"
@@ -417,7 +426,11 @@
 #elif defined(__WXMSW__)
     #include "wx/msw/treectrl.h"
-#elif defined(__WXMOTIF__)
-    #include "wx/generic/treectlg.h"
 #elif defined(__WXGTK__)
+    #if wxUSE_NATIVE_GTK2TREECTRL
+        #include "wx/gtk/treectrl.h"
+    #else
+        #include "wx/generic/treectlg.h"
+    #endif
+#elif defined(__WXMOTIF__)
     #include "wx/generic/treectlg.h"
 #elif defined(__WXMAC__)
diff -bu2rN wxOld/samples/treectrl/treetest.cpp wxWidgets/samples/treectrl/treetest.cpp
--- wxOld/samples/treectrl/treetest.cpp	2006-03-12 10:39:52.000000000 -0800
+++ wxWidgets/samples/treectrl/treetest.cpp	2006-03-12 13:08:33.000000000 -0800
@@ -95,4 +95,9 @@
     MENU_LINK(DeleteChildren)
     MENU_LINK(DeleteAll)
+    MENU_LINK(ForceHasChildren)
+    MENU_LINK(ForceHasNoChildren)
+    MENU_LINK(ForceExpand)
+    MENU_LINK(ForceCollapse)
+    MENU_LINK(PrintVisible)
     MENU_LINK(Recreate)
     MENU_LINK(ToggleImages)
@@ -231,4 +236,5 @@
     tree_menu->AppendSeparator();
     tree_menu->Append(TreeTest_EnsureVisible, wxT("Make the last item &visible"));
+    tree_menu->Append(TreeTest_PrintVisible, wxT("Show visible items"));
     tree_menu->AppendSeparator();
     tree_menu->Append(TreeTest_IncIndent, wxT("Add 5 points to indentation\tAlt-I"));
@@ -245,4 +251,9 @@
     item_menu->Append(TreeTest_ClearBold, wxT("Make item &not bold"));
     item_menu->AppendSeparator();
+    item_menu->Append(TreeTest_ForceHasNoChildren, wxT("Force item to have no children"));
+    item_menu->Append(TreeTest_ForceHasChildren, wxT("Force item to have children"));
+    item_menu->Append(TreeTest_ForceExpand, wxT("Expand item"));
+    item_menu->Append(TreeTest_ForceCollapse, wxT("Collapse item"));
+    item_menu->AppendSeparator();
     item_menu->Append(TreeTest_ToggleIcon, wxT("Toggle the item's &icon"));
 
@@ -333,5 +344,5 @@
     long style = m_treeCtrl->GetWindowStyle() ^ flag;
 
-    // most treectrl styles can't be changed on the fly using the native
+    // most treectrl styles can't be changed on the fly using the native msw
     // control and the tree must be recreated
 #ifndef __WXMSW__
@@ -351,10 +362,13 @@
     {
         wxTreeItemId idRoot = m_treeCtrl->GetRootItem();
+        wxTreeItemId idLastChild;
+        if(idRoot.IsOk())   
+            idLastChild = m_treeCtrl->GetLastChild(idRoot);
 
         SetStatusText(wxString::Format
                       (
                         _T("Root/last item is %svisible/%svisible"),
-                        m_treeCtrl->IsVisible(idRoot) ? _T("") : _T("not "),
-                        m_treeCtrl->IsVisible(m_treeCtrl->GetLastChild(idRoot))
+                        idRoot.IsOk() && m_treeCtrl->IsVisible(idRoot) ? _T("") : _T("not "),
+                        idLastChild.IsOk() && m_treeCtrl->IsVisible(idLastChild)
                             ? _T("") : _T("not ")
                       ), 1);
@@ -404,4 +418,20 @@
 }
 
+// Custom text control with in-place editing
+class MyInPlaceTextCtrl : public wxTextCtrl
+{
+    MyInPlaceTextCtrl() : m_extraname(wxT("MyInPlaceTextCtrl:"))
+    { Connect(GetId(), wxEVT_CHAR, wxKeyEventHandler(MyInPlaceTextCtrl::OnChar)); }
+    void OnChar(wxKeyEvent& ev) 
+    {
+        wxLogDebug(wxT("%s%c"), (const wxChar*)m_extraname, (wxChar)ev.GetKeyCode());
+        ev.Skip(); //Make sure you skip this to keep native behaviour
+    }
+    wxString m_extraname;
+    wxTreeCtrl* m_tree;
+    DECLARE_DYNAMIC_CLASS(MyInPlaceTextCtrl)
+};
+IMPLEMENT_DYNAMIC_CLASS(MyInPlaceTextCtrl, wxTextCtrl)
+
 void MyFrame::OnRename(wxCommandEvent& WXUNUSED(event))
 {
@@ -421,6 +451,12 @@
 #endif // 0
 
-    // TODO demonstrate creating a custom edit control...
-    (void)m_treeCtrl->EditLabel(item);
+    wxTextCtrl* textctrl = m_treeCtrl->EditLabel(item, CLASSINFO(MyInPlaceTextCtrl));
+
+    if(textctrl && textctrl->GetClassInfo() == CLASSINFO(MyInPlaceTextCtrl))
+        wxLogStatus(wxT("wxTextCtrl successfuly created for in-place editing"));
+    else if (textctrl)
+        wxLogStatus(wxT("Could not create wxTextCtrl of desired type"));
+    else
+        wxLogStatus(wxT("Could not edit in place in the wxTreeCtrl"));
 }
 
@@ -534,4 +570,69 @@
 }
 
+void MyFrame::OnForceHasChildren(wxCommandEvent& WXUNUSED(event))
+{
+    wxTreeItemId item = m_treeCtrl->GetSelection();
+
+    CHECK_ITEM( item );
+
+    m_treeCtrl->SetItemHasChildren(item, true);
+}
+
+void MyFrame::OnForceHasNoChildren(wxCommandEvent& WXUNUSED(event))
+{
+    wxTreeItemId item = m_treeCtrl->GetSelection();
+
+    CHECK_ITEM( item );
+
+    m_treeCtrl->SetItemHasChildren(item, false);
+}
+
+void MyFrame::OnForceExpand(wxCommandEvent& WXUNUSED(event))
+{
+    wxTreeItemId item = m_treeCtrl->GetSelection();
+
+    CHECK_ITEM( item );
+
+    m_treeCtrl->Expand(item);
+}
+
+void MyFrame::OnForceCollapse(wxCommandEvent& WXUNUSED(event))
+{
+    wxTreeItemId item = m_treeCtrl->GetSelection();
+
+    CHECK_ITEM( item );
+
+    m_treeCtrl->Collapse(item);
+}
+
+void MyFrame::OnPrintVisible(wxCommandEvent& WXUNUSED(event))
+{
+    wxTreeItemId item = m_treeCtrl->GetFirstVisibleItem();
+    wxTreeItemId next = item, prev = item;
+
+    if(!item)
+        wxLogMessage(wxT("No visible items"));
+    else
+        wxLogMessage(wxT("First visible item is:%s"), 
+                     m_treeCtrl->GetItemText(item).c_str());
+                 
+    while(next.IsOk())
+    {
+        prev = next;
+        next = m_treeCtrl->GetNextVisible(next);
+        if(next)
+            wxLogMessage(wxT("Next visible item is:%s"), 
+                     m_treeCtrl->GetItemText(next).c_str());
+    }
+
+    while(prev.IsOk())
+    {
+        prev = m_treeCtrl->GetPrevVisible(prev);
+        if(prev)
+            wxLogMessage(wxT("Visible item before last is:%s"), 
+                         m_treeCtrl->GetItemText(prev).c_str());        
+    }    
+}
+
 void MyFrame::OnRecreate(wxCommandEvent& event)
 {
@@ -569,5 +670,5 @@
 void MyFrame::OnToggleButtons(wxCommandEvent& WXUNUSED(event))
 {
-#if USE_GENERIC_TREECTRL || !defined(__WXMSW__)
+#if USE_GENERIC_TREECTRL
     if ( wxGetApp().ShowButtons() )
     {
@@ -722,5 +823,5 @@
 }
 
-#if USE_GENERIC_TREECTRL || !defined(__WXMSW__)
+#if USE_GENERIC_TREECTRL
 void MyTreeCtrl::CreateButtonsImageList(int size)
 {
@@ -900,5 +1001,4 @@
 TREE_EVENT_HANDLER(OnSetInfo)
 TREE_EVENT_HANDLER(OnItemExpanded)
-TREE_EVENT_HANDLER(OnItemExpanding)
 TREE_EVENT_HANDLER(OnItemCollapsed)
 TREE_EVENT_HANDLER(OnSelChanged)
@@ -1143,4 +1243,19 @@
 }
 
+void MyTreeCtrl::OnItemExpanding(wxTreeEvent& event)
+{
+    wxLogMessage(wxT("OnItemExpanding"));
+
+    // for testing, prevent the user from collapsing the first child folder
+    wxTreeItemId itemId = event.GetItem();
+    wxTreeItemIdValue cookie;
+    if ( !GetFirstChild(itemId, cookie).IsOk() )
+    {
+        //add a couple items at runtime
+        InsertItem(itemId, 0, wxT("2nd item"));
+        InsertItem(itemId, 0, wxT("3rd item"));        
+    }
+}
+
 void MyTreeCtrl::OnItemActivated(wxTreeEvent& event)
 {
@@ -1250,5 +1365,6 @@
 void MyTreeCtrl::OnRMouseDClick(wxMouseEvent& event)
 {
-    wxTreeItemId id = HitTest(event.GetPosition());
+    int flags;
+    wxTreeItemId id = HitTest(event.GetPosition(), flags);
     if ( !id )
         wxLogMessage(wxT("No item under mouse"));
@@ -1257,5 +1373,6 @@
         MyTreeItemData *item = (MyTreeItemData *)GetItemData(id);
         if ( item )
-            wxLogMessage(wxT("Item '%s' under mouse"), item->GetDesc());
+            wxLogMessage(wxT("Item '%s' under mouse with flags 0x%X"), 
+                         item->GetDesc(), flags);
     }
 
@@ -1270,6 +1387,10 @@
 void MyTreeItemData::ShowInfo(wxTreeCtrl *tree)
 {
+    wxRect rect;
+    tree->GetBoundingRect(GetId(), rect, false);
+
     wxLogMessage(wxT("Item '%s': %sselected, %sexpanded, %sbold,\n")
-                 wxT("%u children (%u immediately under this item)."),
+                 wxT("with %u children (%u immediately under this item).\n")
+                 wxT("Item bounds: [%i,%i]"),
                  m_desc.c_str(),
                  Bool2String(tree->IsSelected(GetId())),
@@ -1277,4 +1398,6 @@
                  Bool2String(tree->IsBold(GetId())),
                  tree->GetChildrenCount(GetId()),
-                 tree->GetChildrenCount(GetId(), false));
+                 tree->GetChildrenCount(GetId(), false),
+                 rect.x,
+                 rect.y);
 }
diff -bu2rN wxOld/samples/treectrl/treetest.h wxWidgets/samples/treectrl/treetest.h
--- wxOld/samples/treectrl/treetest.h	2006-03-12 10:39:52.000000000 -0800
+++ wxWidgets/samples/treectrl/treetest.h	2006-03-12 13:08:31.000000000 -0800
@@ -188,4 +188,11 @@
     void OnDeleteAll(wxCommandEvent& event);
 
+    void OnForceHasChildren(wxCommandEvent& event);
+    void OnForceHasNoChildren(wxCommandEvent& event);
+    void OnForceExpand(wxCommandEvent& event);
+    void OnForceCollapse(wxCommandEvent& event);
+
+    void OnPrintVisible(wxCommandEvent& event);
+
     void OnRecreate(wxCommandEvent& event);
     void OnToggleButtons(wxCommandEvent& event);
@@ -268,4 +275,9 @@
     TreeTest_DeleteChildren,
     TreeTest_DeleteAll,
+    TreeTest_ForceHasChildren,
+    TreeTest_ForceHasNoChildren,
+    TreeTest_ForceExpand,
+    TreeTest_ForceCollapse,
+    TreeTest_PrintVisible,
     TreeTest_Recreate,
     TreeTest_ToggleImages,
diff -bu2rN wxOld/src/gtk/textctrl.cpp wxWidgets/src/gtk/textctrl.cpp
--- wxOld/src/gtk/textctrl.cpp	2006-03-12 10:39:57.000000000 -0800
+++ wxWidgets/src/gtk/textctrl.cpp	2006-03-12 10:59:16.000000000 -0800
@@ -727,4 +727,23 @@
 }
 
+void wxTextCtrl::AssociateHandle(GtkWidget* widget)
+{
+    wxCHECK_RET( !HasFlag(wxTE_MULTILINE), wxT("single-line text ctrl only") );
+
+    if(m_widget)
+        DissociateHandle();
+
+    m_text = widget;
+    wxWindowGTK::AssociateHandle(widget);
+}
+
+void wxTextCtrl::DissociateHandle()
+{
+    wxCHECK_RET( m_widget != NULL, wxT("already dissociated/not created") );
+    wxCHECK_RET( !HasFlag(wxTE_MULTILINE), wxT("single-line text ctrl only") );
+
+    wxWindowGTK::DissociateHandle();
+    m_text = NULL;
+}
 
 void wxTextCtrl::CalculateScrollbar()
@@ -1426,5 +1445,5 @@
         // as the clicking the default button.
 
-        wxWindow *top_frame = m_parent;
+        wxWindow *top_frame = this; //RN: Parent could be NULL...
         while (top_frame->GetParent() && !(top_frame->IsTopLevel()))
             top_frame = top_frame->GetParent();
diff -bu2rN wxOld/src/gtk/treectrl.cpp wxWidgets/src/gtk/treectrl.cpp
--- wxOld/src/gtk/treectrl.cpp	1969-12-31 16:00:00.000000000 -0800
+++ wxWidgets/src/gtk/treectrl.cpp	2006-03-12 13:51:02.000000000 -0800
@@ -0,0 +1,2852 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        treectrl.cpp
+// Purpose:     GtkTreeView wxTreeCtrl implementation
+// Author:      Ryan Norton <wxprojects@comcast.net>
+// Modified by:
+// Created:     02/22/06
+// RCS-ID:      $Id: treegtk.cpp,v 1.13 2006/02/03 23:39:48 MR Exp $
+// Copyright:   (c) Ryan Norton
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+// For compilers that support precompilation, includes "wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+
+#ifndef WX_PRECOMP
+#include "wx/wx.h"
+#endif
+
+#include "wx/treectrl.h"
+
+#if wxUSE_TREECTRL && wxUSE_NATIVE_GTK2TREECTRL
+
+#include "wx/log.h"
+
+#include <gtk/gtk.h>
+#include "wx/gtk/private.h"
+#include "wx/gtk/treeentry_gtk.h"
+
+#include "wx/fontutil.h"
+#include "wx/dnd.h"
+
+//-----------------------------------------------------------------------------
+// implementation notes
+//-----------------------------------------------------------------------------
+
+/*
+    This is the wxTreeCtrl implementation for GTK2. Here we support most 
+    features of wxTreeCtrl except: 
+        wxTR_FULL_ROW_HIGHLIGHT - This is always on essentially as it is 
+                                  the native behaviour on GTK
+        wxTR_HAS_BUTTONS        - Generic-only    
+        wxTR_LINES_AT_ROOT      - Not available, really
+
+    Not implemented/buggy:
+        wxTR_ROW_LINES          - Implemented using separators but the
+                                  spacing is horrible and it needs more testing
+        wxTR_HAS_VARIABLE_ROW_HEIGHT - Available, but looks terrible, basically
+                                       this means that if it is on, rows are
+                                       automatically sized while off the 2.6+
+                                       fixed height property would be used
+        Get/SetIndent           - There is an "indent_expanders" style for
+                                  GtkTreeView but it is a boolean not an
+                                  integer value (might be able to set this 
+                                  through the column attributes as well)
+
+    Each wxTreeItemId has its m_pItem member pointing to a GtkTreeEntry
+    that contains the label and an instance of wxTreeEntryData that we
+    dynamically allocate and destroy.  The main part about wxTreeEntryData
+    is that it contains the GtkTreePath in it so that we know where the
+    node is located in the tree, except for virtual nodes.
+
+    Virtual nodes include the root (m_root) if the wxTR_HIDE_ROOT style is
+    set as well as seperators or fake children (Used for SetItemHasChildren)
+    if they are enabled. There is a GtkTreeModelFilter available as well that
+    may be able to simulate this but it is only available on 2.4+.
+
+    Even though it looks like it we don't use more than one column, rather
+    we simply pack both the image and text renderers into the one column.
+
+    Also, for SetItemHasChildren we use a fake node and simply don't expand
+    it on the expanding event if the user didn't add any valid nodes there.
+
+    
+    BUGS:
+        Refresh bugs when changing font/bold as only part of the text is
+            updated sometimes. Perhaps we could just tell the cell to render
+            directly....
+        Setting the spacing to a higher value then the previous one works but
+            usually setting it lower has no effect, which may be due to the 
+            sizing policy of the column...
+        Text cancelling from a wxEVT_COMMAND_TREE_BEGIN_LABEL_EDIT event 
+            will actually show the textbox for a split second before
+            removing it - maybe this is because the GtkCellEditable is 
+            not fully initialized by the time the "editing-started" 
+            callback has been called...
+
+    TODO:
+        Clean up boolean inconsistancy
+        Have the wxGTK event guards and idle stuff in all the callbacks here?
+        Set the "editable" gobject prop to FALSE on the textrenderer instead of
+            g_idle_add for ending editing prematurely?
+        Optimize DeleteChildren to delete children starting from the last
+            going backwards to avoid GtkRecalcPaths
+*/
+
+//-----------------------------------------------------------------------------
+// data
+//-----------------------------------------------------------------------------
+
+extern bool           g_blockEventsOnDrag;
+extern bool           g_blockEventsOnScroll;
+extern wxCursor       g_globalCursor;
+
+//----------------------------------------------------------------------------
+// Macros
+//----------------------------------------------------------------------------
+
+#define WXTREECTRL_IMAGEINDEX   0 //Virtual column of images in view
+#define WXTREECTRL_TEXTINDEX    1 //Virtual column of text in view
+
+#define wxUSE_SEPARATORS        0 //Use treectrl separators (looks bad)
+
+//-----------------------------------------------------------------------------
+// wxTreeCtrlEntryData (gtk_tree_entry_get_userdata(item.m_pItem))
+//-----------------------------------------------------------------------------
+
+class wxTreeEntryData
+{
+public:
+    wxTreeEntryData() 
+        : path(NULL), bBold(false), bHasChildren(false), itemdata(NULL)
+    {
+        images[0]= 
+        images[1]=
+        images[2]=
+        images[3]=-1;
+    }
+    ~wxTreeEntryData()
+    {
+        if(path)
+            gtk_tree_path_free(path);
+        if(itemdata)
+            delete itemdata;
+    }   
+
+    int GetImage(wxTreeCtrl* tree, GtkTreeEntry* entry) const
+    {
+#if 0 //MSW way (?)
+        int imageindex = 0;
+
+        if(tree->IsExpanded(entry))
+            imageindex += 2;
+
+        if(tree->IsSelected(entry))
+            imageindex += 1;
+
+        int image = images[imageindex];
+#else //More "flexible" generic way
+        int image = -1;
+        if(tree->IsExpanded(entry))
+        {
+            if(tree->IsSelected(entry))
+                image = images[wxTreeItemIcon_SelectedExpanded];
+    
+            if(image == -1)
+                image = images[wxTreeItemIcon_Expanded];
+        }
+        else if (tree->IsSelected(entry))
+        {
+            image = images[wxTreeItemIcon_Selected];
+        }
+    
+        if(image == -1) //try default as the last try
+            image = images[wxTreeItemIcon_Normal]; 
+#endif
+        return image;
+    }
+
+    GtkTreePath* path;
+    wxColour foreColour;
+    wxColour backColour;
+    wxFont font;
+    bool bBold;
+    int images[4];
+    bool bHasChildren;
+    wxTreeItemData* itemdata;
+};
+
+//----------------------------------------------------------------------------
+// Helper to copying one node to another as if you delete a node
+// it always deletes its children. In GTK2.2+ there are swapping and 
+// moving functions but in the case of a virtual root for example
+// this would still be a bit cleaner then moving the root after 
+// its deepest child
+//
+// SaveBeforeCopy refs and saves all children (recursively) of an item 
+// so that later use of InsertCopy can reinsert all the children to another
+// item in the tree
+//----------------------------------------------------------------------------
+
+struct wxGTKTreeCopierNode
+{
+    wxGTKTreeCopierNode* next;
+    wxGTKTreeCopierNode* child;
+    wxTreeItemId item;
+};
+
+class wxGTKTreeCopier
+{
+public:
+    wxGTKTreeCopier(wxTreeCtrl* tree, const wxTreeItemId& item = wxTreeItemId())
+    {
+        if(item == wxTreeItemId()) //copy all items?
+        {
+            wxTreeItemId child;
+            GtkTreeIter iter;
+            if(gtk_tree_model_get_iter_first(GTK_TREE_MODEL(tree->m_treestore), &iter))
+               child = tree->GtkIterEntry(&iter);
+            SaveBeforeCopy(tree, child);
+        }
+        else
+        {
+            wxTreeItemId child = tree->GtkRealFirstChild(item);
+            if(child)
+                SaveBeforeCopy(tree, child);
+            else
+                m_node = NULL;
+        }
+    }
+
+    ~wxGTKTreeCopier()
+    { 
+        if(m_node)
+            DoDelete(m_node);
+    }
+    
+    void DoDelete(wxGTKTreeCopierNode* node)
+    {
+        if(node->next)
+            DoDelete(node->next);
+        if(node->child)
+            DoDelete(node->child);
+        delete node;
+    }
+
+    void SaveBeforeCopy(wxTreeCtrl* tree, wxTreeItemId item)
+    {
+        m_node = new wxGTKTreeCopierNode;
+        DoSaveBeforeCopy(tree, item, m_node);
+    }
+
+    void DoSaveBeforeCopy(wxTreeCtrl* tree, wxTreeItemId item, 
+                          wxGTKTreeCopierNode* node)
+    {
+        node->item = item;
+        g_object_ref(G_OBJECT(item.m_pItem));
+
+        wxTreeItemId child = tree->GtkRealFirstChild(item);
+        if(child)
+        {
+            node->child = new wxGTKTreeCopierNode;
+            DoSaveBeforeCopy(tree, child, node->child);
+        }
+        else
+            node->child = NULL;
+    
+        wxTreeItemId next = tree->GetNextSibling(item);
+        if(next)
+        {
+            node->next = new wxGTKTreeCopierNode;
+            DoSaveBeforeCopy(tree, next, node->next);
+        }
+        else
+            node->next = NULL;
+    }
+
+    void InsertCopy(wxTreeCtrl* tree, wxTreeItemId parent)
+    {
+        if(m_node)
+            DoInsertCopy(tree, parent, wxTreeItemId(), m_node);
+    }
+
+    void DoInsertCopy(wxTreeCtrl* tree, wxTreeItemId parent,
+                      wxTreeItemId prev, wxGTKTreeCopierNode* node)
+    {
+        wxTreeItemId item = node->item;
+        tree->GtkInsertItem(parent, prev, 
+                            wxT(""), -1, -1, NULL, true, 
+                            GTK_TREE_ENTRY(item.m_pItem));
+
+        if(node->child)
+            DoInsertCopy(tree, node->item, wxTreeItemId(), node->child);
+        if(node->next)
+            DoInsertCopy(tree, parent, node->item, node->next);
+    }
+
+    wxGTKTreeCopierNode* m_node;
+};
+
+//----------------------------------------------------------------------------
+// Image rendering
+//----------------------------------------------------------------------------
+
+extern "C" {
+static void gtk_image_render_callback(GtkTreeViewColumn *col,
+                                      GtkCellRenderer   *renderer,
+                                      GtkTreeModel      *model,
+                                      GtkTreeIter       *iter,
+                                      wxTreeCtrl        *tree)
+{
+    //Relevant members of wxTreeEntryData: backColour, images
+    GtkTreeEntry* entry = tree->GtkIterEntry(iter);
+    wxTreeEntryData* data = 
+        (wxTreeEntryData*) gtk_tree_entry_get_userdata(entry);
+
+#if wxUSE_SEPARATORS
+    if(tree->GtkIsFakeItem(entry))
+        return;
+#endif
+
+    if(data->backColour.Ok())
+    {
+        g_object_set(G_OBJECT(renderer), 
+            "cell-background-gdk", data->backColour.GetColor(), NULL);
+        g_object_set(G_OBJECT(renderer), 
+            "cell-background-set", TRUE, NULL);
+    }
+    else
+        g_object_set(G_OBJECT(renderer), 
+            "cell-background-set", FALSE, NULL);
+
+    int image = data->GetImage(tree, entry);
+    if(image != -1)
+    {
+        wxImageList* imageList = tree->GetImageList();
+        GdkPixbuf* pixbuf = imageList->GetBitmap(image).GetPixbuf();
+
+        g_object_set(G_OBJECT(renderer), 
+            "pixbuf", pixbuf, NULL);        
+        g_object_set(G_OBJECT(renderer), 
+            "visible", TRUE, NULL);        
+        //TODO: unref pixbuf?
+    }
+    else
+        g_object_set(G_OBJECT(renderer), 
+            "visible", FALSE, NULL);        
+}
+}
+
+//----------------------------------------------------------------------------
+// Text rendering
+//----------------------------------------------------------------------------
+
+extern "C" {
+static void gtk_text_render_callback(GtkTreeViewColumn *col,
+                                     GtkCellRenderer   *renderer,
+                                     GtkTreeModel      *model,
+                                     GtkTreeIter       *iter,
+                                     wxTreeCtrl        *tree)
+{
+    //Relevant members of wxTreeEntryData: foreColour, backColour, font, bBold
+    GtkTreeEntry* entry = tree->GtkIterEntry(iter);
+    wxTreeEntryData* data = 
+        (wxTreeEntryData*) gtk_tree_entry_get_userdata(entry);
+
+#if wxUSE_SEPARATORS
+    if(tree->GtkIsFakeItem(entry))
+        return;
+#endif
+
+    if(data->backColour.Ok())
+    {
+        g_object_set(G_OBJECT(renderer), 
+            "cell-background-gdk", data->backColour.GetColor(), NULL);
+        g_object_set(G_OBJECT(renderer), 
+            "cell-background-set", TRUE, NULL);
+    }
+    else
+        g_object_set(G_OBJECT(renderer), 
+            "cell-background-set", FALSE, NULL);
+
+    if(data->foreColour.Ok())
+    {
+        g_object_set(G_OBJECT(renderer), 
+            "foreground-gdk", data->foreColour.GetColor(), NULL);
+        g_object_set(G_OBJECT(renderer), 
+            "foreground-set", TRUE, NULL);
+    }
+    else
+        g_object_set(G_OBJECT(renderer), 
+            "foreground-set", FALSE, NULL);
+
+    if(data->font.Ok())
+    {
+        PangoFontDescription *desc;
+        if(data->bBold && data->font.GetWeight() < wxFONTWEIGHT_BOLD)
+        {
+            wxFont realfont(data->font);
+            realfont.SetWeight(wxFONTWEIGHT_BOLD);
+            desc = realfont.GetNativeFontInfo()->description;
+        }
+        else
+            desc = data->font.GetNativeFontInfo()->description;
+
+        g_object_set(G_OBJECT(renderer), "font-desc", desc, NULL);
+    }
+    else if(data->bBold)
+    {
+        g_object_set(G_OBJECT(renderer), "weight-set", TRUE, NULL);
+        g_object_set(G_OBJECT(renderer), "weight", PANGO_WEIGHT_BOLD, NULL);    
+    }
+    else
+    {
+        g_object_set(G_OBJECT(renderer), "font", NULL, NULL);
+    }
+}
+}
+
+//----------------------------------------------------------------------------
+// Separator callback from treeview on whether to render a row as one
+//----------------------------------------------------------------------------
+
+#if wxUSE_SEPARATORS
+extern "C" {
+static gboolean  gtk_treectrl_row_separator_cb(GtkTreeModel *model,
+                                               GtkTreeIter *iter,
+                                               wxTreeCtrl* tree)
+{
+    return tree->GtkIterEntry(iter) == tree->m_separator;
+}
+}
+#endif
+
+//----------------------------------------------------------------------------
+// GtkTreeEntry destruction
+//----------------------------------------------------------------------------
+
+extern "C" {
+static void gtk_tree_entry_destroy_callback(GtkTreeEntry* entry, 
+                                            wxTreeCtrl* tree)
+{
+    wxTreeEntryData* data = 
+        (wxTreeEntryData*) gtk_tree_entry_get_userdata(entry);
+
+    if(data)
+        delete data;
+}
+}
+
+//-----------------------------------------------------------------------------
+// Searching callback (TRUE == not equal, FALSE == equal)
+//-----------------------------------------------------------------------------
+
+extern "C" {
+static gboolean gtk_treectrl_searchequal_callback(GtkTreeModel* model,
+                                                  gint column,
+                                                  const gchar* key,
+                                                  GtkTreeIter* iter,
+                                                  wxTreeCtrl* tree)
+{
+    GtkTreeEntry* entry = tree->GtkIterEntry(iter);
+
+    if(tree->GtkIsFakeItem(entry))
+        return TRUE;
+
+    gchar* keycollatekey = g_utf8_collate_key(key, -1);
+
+    int ret = strcmp(keycollatekey,
+                     gtk_tree_entry_get_collate_key(entry));
+
+    g_free(keycollatekey);
+    return ret != 0;
+}
+}
+
+//----------------------------------------------------------------------------
+// "row-activated"
+//----------------------------------------------------------------------------
+
+extern "C" {
+static void gtk_treectrl_row_activated_callback(GtkTreeView        *treeview,
+                                                GtkTreePath        *path,
+                                                GtkTreeViewColumn  *col,
+                                                wxTreeCtrl         *tree)
+{
+    if(tree->m_blockEvent) return;
+
+    GtkTreeIter iter;
+    gtk_tree_model_get_iter(GTK_TREE_MODEL(tree->m_treestore), &iter, path);
+    tree->GtkSendEvent(&iter, wxEVT_COMMAND_TREE_ITEM_ACTIVATED);
+} 
+}
+
+//----------------------------------------------------------------------------
+// "test-collapse-row" - FALSE == collapse, TRUE == don't collapse
+//----------------------------------------------------------------------------
+
+extern "C" {
+static gboolean gtk_treectrl_row_collapsing_callback(GtkTreeView *treeview,
+                                                     GtkTreeIter *iter,
+                                                     GtkTreePath *path,
+                                                     wxTreeCtrl  *tree)
+{
+    if(tree->m_blockEvent) return FALSE;
+
+    if(!tree->GtkSendEvent(iter, wxEVT_COMMAND_TREE_ITEM_COLLAPSING))
+        return TRUE;
+
+    return FALSE;
+} 
+}
+
+//----------------------------------------------------------------------------
+// "test-expand-row" - FALSE == expand, TRUE == don't expand
+//----------------------------------------------------------------------------
+
+extern "C" {
+static gboolean gtk_treectrl_row_expanding_callback(GtkTreeView *treeview,
+                                                    GtkTreeIter *iter,
+                                                    GtkTreePath *path,
+                                                    wxTreeCtrl  *tree)
+{
+    if(tree->m_blockEvent) return FALSE;
+
+    if(!tree->GtkSendEvent(iter, wxEVT_COMMAND_TREE_ITEM_EXPANDING))
+        return TRUE;
+
+    if(tree->GtkRealFirstChild(tree->GtkIterEntry(iter)) == tree->m_fakechild)
+        return TRUE; //don't expand if no valid children were added
+
+    return FALSE;
+} 
+}
+
+//----------------------------------------------------------------------------
+// "row-collapsed"
+//----------------------------------------------------------------------------
+
+extern "C" {
+static void gtk_treectrl_row_collapsed_callback(GtkTreeView *treeview,
+                                               GtkTreeIter *iter,
+                                               GtkTreePath *path,
+                                               wxTreeCtrl  *tree)
+{
+    if(tree->m_blockEvent) return;
+
+    tree->InvalidateBestSize();
+    tree->GtkSendEvent(iter, wxEVT_COMMAND_TREE_ITEM_COLLAPSED);
+} 
+}
+
+//----------------------------------------------------------------------------
+// "row-expanded"
+//----------------------------------------------------------------------------
+
+extern "C" {
+static void gtk_treectrl_row_expanded_callback(GtkTreeView *treeview,
+                                               GtkTreeIter *iter,
+                                               GtkTreePath *path,
+                                               wxTreeCtrl  *tree)
+{
+    if(tree->m_blockEvent) return;
+
+    tree->InvalidateBestSize();
+    tree->GtkSendEvent(iter, wxEVT_COMMAND_TREE_ITEM_EXPANDED);
+} 
+}
+
+//----------------------------------------------------------------------------
+// "row-deleted" from m_treestore
+//----------------------------------------------------------------------------
+
+extern "C" {
+static void gtk_treectrl_row_deleted_callback(GtkTreeModel *treemodel,
+                                              GtkTreePath  *path,
+                                              wxTreeCtrl   *tree)
+{
+    if(tree->m_blockEvent) return;
+
+    //Row is already deleted and docs even specify that the row pointed
+    //to by path may not be valid anymore
+    wxTreeEvent event( wxEVT_COMMAND_TREE_DELETE_ITEM, tree->GetId() );
+    event.SetEventObject(tree);
+    tree->ProcessEvent(event);
+} 
+}
+
+//-----------------------------------------------------------------------------
+// "select" and "deselect"
+//-----------------------------------------------------------------------------
+
+extern "C" {
+static gboolean gtk_treectrl_select_cb( GtkTreeSelection* selection,
+                                        GtkTreeModel* model,
+                                        GtkTreePath* path,
+                                        gboolean is_selected,
+                                        wxTreeCtrl* tree )
+{
+    if (g_isIdle) wxapp_install_idle_handler();
+
+    if (!tree->m_hasVMT) return TRUE;
+    if (g_blockEventsOnDrag) return TRUE;
+
+    if (tree->m_blockEvent) return TRUE;
+
+    // The event process in single selections in GtkTreeStore:
+    // 1) Select destination, if TRUE then (2)
+    // 2) Unselect prev selection, if TRUE then (3)
+    // 3) Select destination [again]
+    // So we need to ignore #1
+    if(!tree->HasFlag(wxTR_MULTIPLE) && !tree->HasFlag(wxTR_EXTENDED) &&
+       tree->GetSelection() != wxTreeItemId() && !is_selected) return TRUE;
+
+    GtkTreeIter iter;
+    gtk_tree_model_get_iter(GTK_TREE_MODEL(tree->m_treestore), &iter, path);
+
+    // NB: wxdocs explicitly say that this event only gets sent when
+    // something is actually selected, plus the controls example
+    // assumes so and passes -1 to the dogetclientdata funcs if not
+
+    // OK, so basically we need to do a bit of a run-around here as
+    // 1) is_selected says whether the item(s?) are CURRENTLY selected -    
+    //    i.e. if is_selected is FALSE then the item is going to be 
+    //    selected right now!
+    // 2) However, since it is not already selected and the user 
+    //    will expect it to be we need to manually select it and
+    //    return FALSE telling GTK we handled the selection
+    if (is_selected) 
+    {
+        tree->m_lastSelections.Add(tree->GtkIterEntry(&iter));
+        return TRUE;
+    }
+
+    wxTreeItemId olditem;
+    if(tree->m_lastSelections.GetCount())
+        olditem = tree->m_lastSelections[tree->m_lastSelections.GetCount()-1];
+
+    bool bPass = 
+        tree->GtkSendEvent(&iter, wxEVT_COMMAND_TREE_SEL_CHANGING, olditem);
+    if(!bPass)
+    {
+        //reselect all those old items        
+        for(size_t i = 0; i < tree->m_lastSelections.GetCount(); ++i)
+            tree->GtkSelectItem(tree->m_lastSelections[i], true, true);
+    }
+    else
+        tree->GtkSendEvent(&iter, wxEVT_COMMAND_TREE_SEL_CHANGED);
+
+    
+    tree->m_lastSelections.Clear();
+    return !!bPass;
+}
+}
+
+//----------------------------------------------------------------------------
+// "edited" from m_textrenderer
+//----------------------------------------------------------------------------
+
+extern "C" {
+static void gtk_treectrl_edited_callback(GtkCellRendererText *renderer,
+                                         gchar               *path_string,
+                                         gchar               *new_text,
+                                         wxTreeCtrl          *tree)
+{
+    if(tree->m_blockEvent) return;
+
+    GtkTreeIter iter;
+    gtk_tree_model_get_iter_from_string(
+        GTK_TREE_MODEL(tree->m_treestore), &iter, path_string );
+    GtkTreeEntry* entry = tree->GtkIterEntry(&iter);
+    
+    if(tree->GtkSendEvent(&iter, wxEVT_COMMAND_TREE_END_LABEL_EDIT, 
+                          wxTreeItemId(), wxConvUTF8.cMB2WX(new_text)))
+    {
+        gtk_tree_entry_set_label(entry, new_text);
+    }
+
+    if(tree->m_textctrl)
+    {
+        tree->m_textctrl->DissociateHandle();        
+        delete tree->m_textctrl;
+        tree->m_textctrl = NULL;
+    }
+
+    if(!tree->HasFlag(wxTR_EDIT_LABELS)) //restore old editable state
+    {   
+        g_object_set(G_OBJECT(renderer), "editable", FALSE, NULL);
+        g_object_set(G_OBJECT(renderer), "editable-set", FALSE, NULL);
+    }
+} 
+}
+
+//----------------------------------------------------------------------------
+// Callback to edit editing prematurely on user request (2.6+)
+//----------------------------------------------------------------------------
+
+#if GTK_CHECK_VERSION(2, 6, 0)
+extern "C" {
+static gboolean gtk_treectrl_cancel_editing_idle_cb(wxTreeCtrl* tree)
+{
+    tree->EndEditLabel(wxTreeItemId(), TRUE);
+
+    return FALSE;
+}
+}
+#endif
+
+//----------------------------------------------------------------------------
+// "editing-started" from m_textrenderer (2.6+)
+//----------------------------------------------------------------------------
+
+#if GTK_CHECK_VERSION(2, 6, 0)
+extern "C" {
+static void gtk_treectrl_editing_started_cb(GtkCellRenderer *renderer,
+                                            GtkCellEditable *editable,
+                                            gchar           *pathstring,
+                                            wxTreeCtrl      *tree)
+{
+    if(tree->m_blockEvent) return;
+
+    GtkTreeIter iter;
+    gtk_tree_model_get_iter_from_string(
+        GTK_TREE_MODEL(tree->m_treestore), &iter, pathstring );
+
+    //NOTE: DO NOT CALL ::Create HERE! This will trigger an
+    //activation event (due to control creation?) and cause editing
+    //to end immediately and destroy the GtkCellEditable!
+    if(!tree->m_textctrl)
+        tree->m_textctrl = new wxTextCtrl();
+    tree->m_textctrl->AssociateHandle(GTK_WIDGET(editable));        
+
+    if(!tree->GtkSendEvent(&iter, wxEVT_COMMAND_TREE_BEGIN_LABEL_EDIT))
+    {
+        //treeview won't let us cancel right away (maybe because 
+        //editing started is called before attaching the widget?)
+        //so set up a idle callback and do it then
+        g_idle_add((GSourceFunc)gtk_treectrl_cancel_editing_idle_cb, tree);
+    }
+} 
+}
+#endif
+
+//----------------------------------------------------------------------------
+// "button_press_event"
+//----------------------------------------------------------------------------
+
+extern "C" {
+static gboolean gtk_treectrl_button_press_callback(GtkWidget *widget,
+                                                   GdkEventButton *gdkevent,
+                                                   wxTreeCtrl *tree )
+{
+    tree->m_dragstart = wxPoint((int)gdkevent->x, (int)gdkevent->y);
+    return FALSE;
+}
+}
+
+//----------------------------------------------------------------------------
+// "button_release_event"
+//----------------------------------------------------------------------------
+
+extern "C" {
+static gboolean gtk_treectrl_button_release_callback(GtkWidget *widget,
+                                                     GdkEventButton *gdkevent,
+                                                     wxTreeCtrl *tree )
+{
+    tree->m_dragstart = wxDefaultPosition;
+    return FALSE;
+}
+}
+
+//----------------------------------------------------------------------------
+// "motion_notify_event"
+//----------------------------------------------------------------------------
+
+extern "C" {
+static gboolean gtk_treectrl_motion_notify_callback(GtkTreeView* treeview,
+                                                    GdkEventMotion* gdkevent,
+                                                    wxTreeCtrl* tree )
+{
+    if(gtk_drag_check_threshold(GTK_WIDGET(treeview), 
+                                tree->m_dragstart.x, tree->m_dragstart.y,
+                                (gint)gdkevent->x, (gint)gdkevent->y))
+    {
+        GdkModifierType modtype; gint x, y;
+        gdk_window_get_pointer(gtk_tree_view_get_bin_window(treeview),
+                               &x, &y, &modtype);
+
+        gint button = (modtype & GDK_BUTTON1_MASK) ? 1 :
+                      (modtype & GDK_BUTTON3_MASK) ? 3 : 0;
+        if(button)
+        {
+            wxTreeItemId dragitem;
+
+            //Find the item (note how we pass dragstart instead of the 
+            //current coordinates)
+            GtkTreePath* path;
+            if(gtk_tree_view_get_path_at_pos(
+                treeview, tree->m_dragstart.x, tree->m_dragstart.y,
+                &path, NULL, NULL, NULL)) //Item found so send the event
+            {
+                GtkTreeIter iter;
+                gtk_tree_model_get_iter(GTK_TREE_MODEL(tree->m_treestore), 
+                                        &iter, path);
+                gtk_tree_path_free(path);
+                dragitem = tree->GtkIterEntry(&iter);
+
+               if(tree->GtkIsFakeItem(dragitem))
+                    return FALSE;
+
+                wxTreeEvent event(button == 1 ? wxEVT_COMMAND_TREE_BEGIN_DRAG :
+                                                wxEVT_COMMAND_TREE_BEGIN_RDRAG,
+                                  tree->GetId() );
+            
+                event.SetItem(dragitem);
+                event.SetEventObject(tree);
+                event.Veto(); //not allowed by default
+
+                if(tree->ProcessEvent(event) && event.IsAllowed())
+                {
+                    tree->m_dragitem = dragitem;
+                    GtkTargetEntry te;
+                    te.target = "wxTreeCtrl";
+                    te.flags = GTK_TARGET_SAME_WIDGET; 
+                    te.info = 0;
+
+                    //TODO: Free target list somehow?
+                    gtk_drag_begin(GTK_WIDGET(treeview), 
+                                   gtk_target_list_new( &te, 1 ),
+                                   GDK_ACTION_MOVE,
+                                   button, 
+                                   (GdkEvent*) gdkevent);
+                }
+            }//if path found
+        }//if button pressed
+    }//if drag threshold reached
+
+    return FALSE;    
+}
+}
+
+//-----------------------------------------------------------------------------
+// "drag-data-received"
+//-----------------------------------------------------------------------------
+
+extern "C" {
+static void gtk_treectrl_drag_data_received_cb(GtkTreeView* treeview, 
+                                               GdkDragContext* dragcontext, 
+                                               gint x, gint y, 
+                                               GtkSelectionData* data, 
+                                               gint info, gint time,
+                                               wxTreeCtrl* tree)
+{
+    wxLogDebug(wxT("gtk_treectrl_drag_data_received_cb"));
+    if(tree->m_dragitem.IsOk())
+    {
+        GtkTreePath* path;
+        if(gtk_tree_view_get_path_at_pos(
+            treeview, x, y,
+            &path, NULL, NULL, NULL)) //Item found so send the event        
+        {
+            GtkTreeIter iter;
+            gtk_tree_model_get_iter(GTK_TREE_MODEL(tree->m_treestore), 
+                                    &iter, path);
+            gtk_tree_path_free(path);
+
+            //dragcontext->action has positioning info...
+            tree->GtkSendEvent(&iter, wxEVT_COMMAND_TREE_END_DRAG, 
+                                    tree->m_dragitem);
+        }
+        tree->m_dragitem = wxTreeItemId();
+    }
+    //Override native behaviour and tell it not to modify rows etc.
+    //(Note that it appears in the implementation that the source row is
+    // set in the motion event which means we could already override it there)
+    gtk_tree_view_set_drag_dest_row(treeview, NULL, GTK_TREE_VIEW_DROP_BEFORE);
+}
+}
+
+//-----------------------------------------------------------------------------
+// wxEVT_MIDDLE_DOWN
+//-----------------------------------------------------------------------------
+
+void wxTreeCtrl::OnMiddleDown(wxMouseEvent& mouseevent)
+{
+    wxTreeEvent event( wxEVT_COMMAND_TREE_ITEM_MIDDLE_CLICK, GetId() );
+    event.m_item = GtkHitTest(mouseevent.GetPosition());
+    if(event.m_item.IsOk())
+    {
+        event.SetPoint(mouseevent.GetPosition());
+        event.SetEventObject(this);
+        if(!ProcessEvent(event))
+            mouseevent.Skip(); 
+    }
+    else
+        mouseevent.Skip();
+}
+
+//-----------------------------------------------------------------------------
+// wxEVT_RIGHT_DOWN
+//-----------------------------------------------------------------------------
+
+void wxTreeCtrl::OnRightDown(wxMouseEvent& mouseevent)
+{
+    wxTreeEvent event( wxEVT_COMMAND_TREE_ITEM_RIGHT_CLICK, GetId() );
+    event.m_item = GtkHitTest(mouseevent.GetPosition());
+    if(event.m_item.IsOk())
+    {
+        event.SetPoint(mouseevent.GetPosition());
+        event.SetEventObject(this);
+        if(!ProcessEvent(event))    
+            mouseevent.Skip();
+    }
+    else
+        mouseevent.Skip();
+}
+
+//-----------------------------------------------------------------------------
+// wxEVT_CHAR (RN: Shouldn't we send KeyDown as well?)
+//-----------------------------------------------------------------------------
+
+void wxTreeCtrl::OnChar(wxKeyEvent& charevent)
+{
+    wxTreeEvent event( wxEVT_COMMAND_TREE_KEY_DOWN, GetId() );
+    event.m_evtKey = charevent;
+    event.SetEventObject(this);
+    if(!ProcessEvent(event))
+        charevent.Skip();
+}
+
+
+//----------------------------------------------------------------------------
+// creation/destruction
+//----------------------------------------------------------------------------
+
+bool wxTreeCtrl::Create(wxWindow *parent, wxWindowID id,
+                        const wxPoint& pos,
+                        const wxSize& size,
+                        long style,
+                        const wxValidator& validator,
+                        const wxString& name)
+{
+    m_needParent = TRUE;
+    m_acceptsFocus = TRUE;
+    m_blockEvent = FALSE;
+
+    if (!PreCreation( parent, pos, size ) ||
+        !CreateBase( parent, id, pos, size, style, validator, name ))
+    {
+        wxFAIL_MSG( wxT("wxTreeCtrl creation failed") );
+        return FALSE;
+    }
+
+    // Create virtual items
+    m_separator = gtk_tree_entry_new();
+    gtk_tree_entry_set_userdata(GTK_TREE_ENTRY(m_separator.m_pItem), 
+                                new wxTreeEntryData());
+    m_fakechild = gtk_tree_entry_new();
+    gtk_tree_entry_set_userdata(GTK_TREE_ENTRY(m_fakechild.m_pItem), 
+                                new wxTreeEntryData());
+    
+    // Create widgets
+    m_widget = gtk_scrolled_window_new( NULL, NULL );
+     
+    gtk_scrolled_window_set_policy( GTK_SCROLLED_WINDOW(m_widget),
+                                    GTK_POLICY_AUTOMATIC, 
+                                    GTK_POLICY_AUTOMATIC );
+
+    m_treeview = GTK_TREE_VIEW( gtk_tree_view_new( ) );
+
+    //wxTreeCtrl doesn't have a header :)
+    //NB: If enabled ScrollToItem doesn't work correctly
+    gtk_tree_view_set_headers_visible(m_treeview, FALSE);
+    
+    GtkTreeViewColumn* column = gtk_tree_view_column_new();
+    GtkCellRenderer* pixbufrenderer = gtk_cell_renderer_pixbuf_new();
+    GtkCellRenderer* textrenderer = gtk_cell_renderer_text_new();
+    m_textrenderer = textrenderer;
+
+    gtk_tree_view_column_pack_start(column, pixbufrenderer,
+                                    FALSE); //true gives columns equal weight
+    gtk_tree_view_column_pack_start(column, textrenderer,
+                                    FALSE); //ditto
+
+    gtk_tree_view_column_set_attributes(column, pixbufrenderer,
+                                        "pixbuf", WXTREECTRL_IMAGEINDEX,
+                                        NULL);
+    gtk_tree_view_column_set_attributes(column, textrenderer,
+                                        "text", WXTREECTRL_TEXTINDEX,
+                                        NULL);
+
+#if 0
+    // NB: OK, this is a bit of a hack but sort of a clever one - basically
+    // for DoGetBestSize we want only the area covered the text and
+    // checkboxes but the GtkTreeView cell functions only let us know 
+    // how much it is DRAWING to which is the size of the greater of
+    // either of the current size of the window or the text size - the problem
+    // is that it will never decrease pass the x size of the window. Here
+    // what we do is insert a "dummy" column which makes the cell functions
+    // return the real x bounds of the text and checkboxes.
+    // RN: The only real problem with this approach is that you can focus
+    //     on this column as well, but then you can focus on the toggle
+    //     column also...
+    gtk_tree_view_insert_column_with_attributes(m_treeview, -1, "", 
+                                                gtk_cell_renderer_pixbuf_new(), 
+                                                NULL);
+#endif
+
+    //drag n' drop
+    g_signal_connect(m_treeview, "drag-data-received",
+                     G_CALLBACK(gtk_treectrl_drag_data_received_cb), this);
+
+    g_signal_connect (m_treeview, "button_press_event",
+                      G_CALLBACK (gtk_treectrl_button_press_callback), this);
+    g_signal_connect (m_treeview, "button_release_event",
+                      G_CALLBACK (gtk_treectrl_button_release_callback), this);
+    g_signal_connect (m_treeview, "motion_notify_event",
+                      G_CALLBACK (gtk_treectrl_motion_notify_callback), this);
+
+    
+    GtkTargetEntry te;
+    te.target = "wxTreeCtrl";//"GTK_TREE_MODEL_ROW" is evidently
+                             //some kind of internal atom and will cause
+                             //data_recieved to be called constantly...
+    te.flags = GTK_TARGET_SAME_WIDGET; 
+    te.info = 0;
+    gtk_tree_view_enable_model_drag_source(
+                m_treeview, 
+                (GdkModifierType)(0), //we handle this ourselves
+                &te, 1, 
+                /*(GdkDragAction)*/(GDK_ACTION_MOVE));
+    gtk_tree_view_enable_model_drag_dest(
+                m_treeview, &te, 1, 
+                /*(GdkDragAction)*/(GDK_ACTION_MOVE));
+
+    //Renderer callbacks
+    gtk_tree_view_column_set_cell_data_func(column, pixbufrenderer,
+            (GtkTreeCellDataFunc) gtk_image_render_callback, this, NULL);
+    gtk_tree_view_column_set_cell_data_func(column, textrenderer,
+            (GtkTreeCellDataFunc) gtk_text_render_callback, this, NULL);
+    g_signal_connect(textrenderer, "edited", 
+                     (GCallback) gtk_treectrl_edited_callback, this);
+#if GTK_CHECK_VERSION(2, 6, 0)
+        if(!gtk_check_version(2,6,0))
+            g_signal_connect(textrenderer, "editing-started", 
+                     (GCallback) gtk_treectrl_editing_started_cb, this);
+#endif    
+
+    gtk_tree_view_append_column(m_treeview, column);
+
+    //Now create+set the model (GtkTreeStore) - first argument # of columns
+
+    m_treestore = gtk_tree_store_new(2, GDK_TYPE_PIXBUF, GTK_TYPE_TREE_ENTRY);
+
+    gtk_tree_view_set_model(m_treeview, GTK_TREE_MODEL(m_treestore));
+    
+    g_object_unref(G_OBJECT(m_treestore)); //free on treeview destruction
+    
+    gtk_tree_view_set_search_column(m_treeview, WXTREECTRL_TEXTINDEX);
+    gtk_tree_view_set_search_equal_func(m_treeview, 
+       (GtkTreeViewSearchEqualFunc) gtk_treectrl_searchequal_callback,
+                                        this,
+                                        NULL);
+
+
+    GtkTreeSelection* selection = gtk_tree_view_get_selection( m_treeview );
+    gtk_tree_selection_set_select_function(selection, 
+                     (GtkTreeSelectionFunc)gtk_treectrl_select_cb,
+                                           this, NULL); //NULL == destroycb         
+
+    wxTreeCtrl::SetWindowStyleFlag(style); //apply flag options
+
+    // make list scroll when moving the focus down using cursor keys etc.
+    gtk_container_add (GTK_CONTAINER (m_widget), GTK_WIDGET(m_treeview) );
+
+    gtk_widget_show( GTK_WIDGET(m_treeview) );
+
+    //treeview-specific events
+    g_signal_connect(m_treeview, "row-activated",
+                     G_CALLBACK(gtk_treectrl_row_activated_callback), this);
+    g_signal_connect(m_treeview, "row-collapsed",
+                     G_CALLBACK(gtk_treectrl_row_collapsed_callback), this);
+    g_signal_connect(m_treeview, "row-expanded",
+                     G_CALLBACK(gtk_treectrl_row_expanded_callback), this);
+    g_signal_connect(m_treeview, "test-collapse-row",
+                     G_CALLBACK(gtk_treectrl_row_collapsing_callback), this);
+    g_signal_connect(m_treeview, "test-expand-row",
+                     G_CALLBACK(gtk_treectrl_row_expanding_callback), this);
+
+    //treemodel-specific events
+    g_signal_connect(GTK_TREE_MODEL(m_treestore), "row-deleted",
+                     G_CALLBACK(gtk_treectrl_row_deleted_callback), this);
+
+    //other events
+    Connect(GetId(), wxEVT_CHAR, wxKeyEventHandler(wxTreeCtrl::OnChar)); //keydown instead?
+    Connect(GetId(), wxEVT_MIDDLE_DOWN, 
+            wxMouseEventHandler(wxTreeCtrl::OnMiddleDown));
+    Connect(GetId(), wxEVT_RIGHT_DOWN, 
+            wxMouseEventHandler(wxTreeCtrl::OnRightDown));
+
+    m_parent->DoAddChild( this );
+
+    PostCreation(size);
+    SetBestSize(size); // need this too because this is a wxControlWithItems
+
+    return TRUE;
+}
+
+void wxTreeCtrl::SetWindowStyleFlag( long style )
+{
+    int oldstyle = m_windowStyle;
+    m_windowStyle = style;
+
+    if(m_treeview)  //called in CreateBase while m_treeview is still null...
+    {
+        if(style & wxTR_EDIT_LABELS)
+        {
+            g_object_set(G_OBJECT(m_textrenderer), "editable", TRUE, NULL);
+            g_object_set(G_OBJECT(m_textrenderer), "editable-set", TRUE, NULL);             
+        }
+        else
+        {
+            g_object_set(G_OBJECT(m_textrenderer), "editable", FALSE, NULL);
+            g_object_set(G_OBJECT(m_textrenderer), "editable-set", FALSE, NULL);             
+        }
+
+        GtkTreeSelection* selection = gtk_tree_view_get_selection( m_treeview );
+
+        GtkSelectionMode mode;
+        if (style & wxTR_MULTIPLE)
+        {
+            mode = GTK_SELECTION_MULTIPLE;
+        }
+        else if (style & wxTR_EXTENDED)
+        {
+            mode = GTK_SELECTION_EXTENDED;
+        }
+        else
+        {
+            // if style was 0 set single mode
+            m_windowStyle |= wxTR_SINGLE;
+            mode = GTK_SELECTION_SINGLE;
+        }
+    
+        gtk_tree_selection_set_mode( selection, mode );    
+
+        //Fixed height/separators.. (2.6+)
+#if GTK_CHECK_VERSION(2, 6, 0)
+        if(!gtk_check_version(2,6,0))
+        {
+#if 0  //variable row height - BUGGY looks-wise - rows are only partially 
+       //vertically shown etc.
+            GtkTreeViewColumn* column = gtk_tree_view_get_column(m_treeview,0);
+
+            if(style & wxTR_HAS_VARIABLE_ROW_HEIGHT)
+            {
+                gtk_tree_view_column_set_sizing(column, GTK_TREE_VIEW_COLUMN_GROW_ONLY);
+                gtk_tree_view_set_fixed_height_mode(m_treeview, FALSE);
+            }
+            else
+            {
+                gtk_tree_view_column_set_sizing(column, GTK_TREE_VIEW_COLUMN_FIXED);
+                gtk_tree_view_set_fixed_height_mode(m_treeview, TRUE);
+            }
+#endif
+
+#if wxUSE_SEPARATORS
+            if(style & wxTR_ROW_LINES)
+            {
+                gtk_tree_view_set_row_separator_func(m_treeview,
+                    (GtkTreeViewRowSeparatorFunc) gtk_treectrl_row_separator_cb,
+                                                this, NULL);
+            }
+            else
+                gtk_tree_view_set_row_separator_func(m_treeview, NULL, NULL, NULL);
+#endif
+        }
+#endif
+        if(style & wxTR_HIDE_ROOT)
+        {
+            if(m_root.IsOk() && !(oldstyle & wxTR_HIDE_ROOT))
+            {
+                //detach root   
+                wxGTKTreeCopier copier(this, m_root);
+                g_object_ref(G_OBJECT(m_root.m_pItem));
+                m_blockEvent = TRUE;
+                GtkDeleteItem(m_root);
+                m_blockEvent = FALSE;
+                gtk_tree_path_free(GtkItemEntryData(m_root)->path);
+                GtkItemEntryData(m_root)->path = NULL;
+                copier.InsertCopy(this, wxTreeItemId());
+            }
+        }
+        else if(m_root.IsOk() && (oldstyle & wxTR_HIDE_ROOT))
+        {
+            //attach root            
+            wxGTKTreeCopier copier(this);
+            m_blockEvent = TRUE;
+            gtk_tree_store_clear(m_treestore);
+            m_blockEvent = FALSE;
+            GtkInsertItem(wxTreeItemId(), wxTreeItemId(), wxT(""), -1, -1,
+                          NULL, true, GTK_TREE_ENTRY(m_root.m_pItem));
+            copier.InsertCopy(this, m_root);
+        }               
+    }
+}
+
+wxTreeCtrl::~wxTreeCtrl()
+{
+    //Destroy virtual items
+    if(HasFlag(wxTR_HIDE_ROOT) && m_root.IsOk())
+        g_object_unref(G_OBJECT(m_root.m_pItem));
+    g_object_unref(G_OBJECT(m_separator.m_pItem));
+    g_object_unref(G_OBJECT(m_fakechild.m_pItem));   
+}
+
+//----------------------------------------------------------------------------
+// accessors
+//----------------------------------------------------------------------------
+
+size_t wxTreeCtrl::GetCount() const
+{
+    wxCHECK_MSG(m_treeview, 0, wxT("Invalid tree control"));
+
+    wxTreeItemId cur = m_root;
+    if(!GTK_IS_TREE_ENTRY(cur.m_pItem))
+        return 0; //no nodes whatsoever
+
+    gint count = GetChildrenCount(cur, true);
+
+    //take into account virtual root
+    return HasFlag(wxTR_HIDE_ROOT) ? count : count + 1;    
+}
+
+unsigned int wxTreeCtrl::GetIndent() const
+{
+    wxLogDebug(wxT("Not implemented"));
+    return 0;
+}
+
+void wxTreeCtrl::SetIndent(unsigned int indent)
+{
+    wxLogDebug(wxT("Not implemented"));
+}
+
+unsigned int wxTreeCtrl::GetSpacing() const
+{
+    wxCHECK_MSG(m_treeview, 0, wxT("Invalid tree control"));
+
+    return gtk_tree_view_column_get_spacing(
+                gtk_tree_view_get_column(m_treeview, 0)
+                                           );
+}
+
+void wxTreeCtrl::SetSpacing(unsigned int spacing)
+{
+    wxCHECK_RET(m_treeview, wxT("Invalid tree control"));
+
+    gtk_tree_view_column_set_spacing(
+                gtk_tree_view_get_column(m_treeview, 0),
+                spacing
+                                    );
+
+    Refresh();
+    Update();
+}
+
+wxString wxTreeCtrl::GetItemText(const wxTreeItemId& item) const 
+{
+    wxCHECK_MSG(m_treeview, wxT(""), wxT("Invalid tree control"));
+    wxCHECK_MSG(GtkIsValidItem(item), wxT(""), wxT("Invalid item"));
+
+    GtkTreeEntry* entry = GTK_TREE_ENTRY(item.m_pItem);
+    return wxConvUTF8.cMB2WX(gtk_tree_entry_get_label(entry));    
+}
+
+int wxTreeCtrl::GetItemImage(const wxTreeItemId& item,
+                             wxTreeItemIcon which) const
+{
+    wxCHECK_MSG(m_treeview, -1, wxT("Invalid tree control"));
+    wxCHECK_MSG(GtkIsValidItem(item), -1, wxT("Invalid item"));
+
+    return GtkItemEntryData(item)->images[which];
+}
+
+wxTreeItemData *wxTreeCtrl::GetItemData(const wxTreeItemId& item) const
+{
+    wxCHECK_MSG(m_treeview, NULL, wxT("Invalid tree control"));
+    wxCHECK_MSG(GtkIsValidItem(item), NULL, wxT("Invalid item"));
+
+    return GtkItemEntryData(item)->itemdata;
+}
+
+wxColour wxTreeCtrl::GetItemTextColour(const wxTreeItemId& item) const
+{
+    wxCHECK_MSG(m_treeview, wxColour(), wxT("Invalid tree control"));
+    wxCHECK_MSG(GtkIsValidItem(item), wxColour(), wxT("Invalid item"));
+
+    return GtkItemEntryData(item)->foreColour;
+}
+
+wxColour wxTreeCtrl::GetItemBackgroundColour(const wxTreeItemId& item) const
+{
+    wxCHECK_MSG(m_treeview, wxColour(), wxT("Invalid tree control"));
+    wxCHECK_MSG(GtkIsValidItem(item), wxColour(), wxT("Invalid item"));
+
+    return GtkItemEntryData(item)->backColour;
+}
+
+wxFont wxTreeCtrl::GetItemFont(const wxTreeItemId& item) const
+{
+    wxCHECK_MSG(m_treeview, wxFont(), wxT("Invalid tree control"));
+    wxCHECK_MSG(GtkIsValidItem(item), wxFont(), wxT("Invalid item"));
+
+    return GtkItemEntryData(item)->font;
+}
+
+
+//----------------------------------------------------------------------------
+// modifiers
+//----------------------------------------------------------------------------
+
+void wxTreeCtrl::SetImageList(wxImageList *imageList)
+{
+    if (m_ownsImageListNormal) delete m_imageListNormal;
+    m_imageListNormal = imageList;
+    m_ownsImageListNormal = false;
+    
+    Refresh();
+    Update();
+}
+
+void wxTreeCtrl::SetStateImageList(wxImageList *imageList)
+{
+    if (m_ownsImageListState) delete m_imageListState;
+    m_imageListState = imageList;
+    m_ownsImageListState = false;
+
+    Refresh();
+    Update();
+}
+
+void wxTreeCtrl::SetItemText(const wxTreeItemId& item, const wxString& text)
+{
+    wxCHECK_RET(m_treeview, wxT("Invalid tree control"));
+    wxCHECK_RET(GtkIsValidItem(item), wxT("Invalid item"));
+
+    GtkTreeEntry* entry = GTK_TREE_ENTRY(item.m_pItem);
+    
+    gtk_tree_entry_set_label(entry, wxConvUTF8.cWX2MB(text));
+    GtkUpdateItem(item);
+}
+
+void wxTreeCtrl::SetItemImage(const wxTreeItemId& item,
+                              int image,
+                              wxTreeItemIcon which)
+{
+    wxCHECK_RET(m_treeview, wxT("Invalid tree control"));
+    wxCHECK_RET(GtkIsValidItem(item), wxT("Invalid item"));
+
+    GtkItemEntryData(item)->images[which] = image;
+    GtkUpdateItem(item);
+}
+
+void wxTreeCtrl::SetItemData(const wxTreeItemId& item, wxTreeItemData *data)
+{
+    wxCHECK_RET(m_treeview, wxT("Invalid tree control"));
+    wxCHECK_RET(GtkIsValidItem(item), wxT("Invalid item"));
+
+    GtkItemEntryData(item)->itemdata = data;
+}
+
+void wxTreeCtrl::SetItemHasChildren(const wxTreeItemId& item, bool has)
+{
+    wxCHECK_RET(m_treeview, wxT("Invalid tree control"));
+    wxCHECK_RET(GtkIsValidItem(item), wxT("Invalid item"));
+
+    if(GtkIsVirtualRoot(item))
+        return;
+
+    wxTreeItemId realchild = GtkRealFirstChild(item);
+    if(has)
+    {
+        if(realchild != m_fakechild)
+            GtkInsertItem(item, wxTreeItemId(), wxT(""), -1, -1,
+                         NULL, false, GTK_TREE_ENTRY(m_fakechild.m_pItem));
+    }
+    else if(realchild == m_fakechild)
+    {
+        m_blockEvent = TRUE;
+        GtkDeleteItem(realchild);
+        m_blockEvent = FALSE;
+    }
+
+    GtkItemEntryData(item)->bHasChildren = has;
+}
+
+void wxTreeCtrl::SetItemBold(const wxTreeItemId& item, bool bold)
+{
+    wxCHECK_RET(m_treeview, wxT("Invalid tree control"));
+    wxCHECK_RET(GtkIsValidItem(item), wxT("Invalid item"));
+
+    GtkItemEntryData(item)->bBold = bold;
+    GtkUpdateItem(item);
+}
+
+void wxTreeCtrl::SetItemDropHighlight(const wxTreeItemId& item,
+                                      bool highlight)
+{
+    wxCHECK_RET(m_treeview, wxT("Invalid tree control"));
+    wxCHECK_RET(GtkIsValidItem(item), wxT("Invalid item"));
+
+    wxColour fg, bg;
+
+    if (highlight)
+    {
+        bg = wxSystemSettings::GetColour(wxSYS_COLOUR_HIGHLIGHT);
+        fg = wxSystemSettings::GetColour(wxSYS_COLOUR_HIGHLIGHTTEXT);
+    }
+
+    wxTreeEntryData* data = GtkItemEntryData(item);
+    data->foreColour = fg;
+    data->backColour = bg;
+    GtkUpdateItem(item);
+}
+
+void wxTreeCtrl::SetItemTextColour(const wxTreeItemId& item,
+                                   const wxColour& col)
+{
+    wxCHECK_RET(m_treeview, wxT("Invalid tree control"));
+    wxCHECK_RET(GtkIsValidItem(item), wxT("Invalid item"));
+
+    GtkItemEntryData(item)->foreColour = col;
+    GtkUpdateItem(item);
+}
+
+void wxTreeCtrl::SetItemBackgroundColour(const wxTreeItemId& item,
+                                         const wxColour& col)
+{
+    wxCHECK_RET(m_treeview, wxT("Invalid tree control"));
+    wxCHECK_RET(GtkIsValidItem(item), wxT("Invalid item"));
+
+    GtkItemEntryData(item)->backColour = col;
+    GtkUpdateItem(item);
+}
+
+void wxTreeCtrl::SetItemFont(const wxTreeItemId& item,
+                             const wxFont& font)
+{
+    wxCHECK_RET(m_treeview, wxT("Invalid tree control"));
+    wxCHECK_RET(GtkIsValidItem(item), wxT("Invalid item"));
+
+    GtkItemEntryData(item)->font = font;
+    GtkUpdateItem(item);
+}
+
+//----------------------------------------------------------------------------
+// item status inquiries
+//----------------------------------------------------------------------------
+
+bool wxTreeCtrl::IsVisible(const wxTreeItemId& item) const
+{
+    wxCHECK_MSG(m_treeview, false, wxT("Invalid tree control"));
+    wxCHECK_MSG(GtkIsValidItem(item), false, wxT("Invalid item"));
+
+    wxTreeItemId parent = GetItemParent(item);
+    
+    if(GtkIsVirtualRoot(item))
+        return false;
+
+    if(!parent)
+        return true;
+
+    if(!IsExpanded(parent))
+        return false;
+
+    wxRect box;
+    GetBoundingRect(item, box, false);
+    GtkAdjustment* adjustment = GtkGetVAdjustment();
+    return adjustment->value <= box.y + box.height &&
+           adjustment->value + adjustment->page_size > box.y;
+}
+
+bool wxTreeCtrl::ItemHasChildren(const wxTreeItemId& item) const
+{
+    wxCHECK_MSG(m_treeview, false, wxT("Invalid tree control"));
+    wxCHECK_MSG(GtkIsValidItem(item), false, wxT("Invalid item"));
+
+    if(GtkIsVirtualRoot(item))
+        return GetChildrenCount(item, false) != 0;
+    else
+        return GtkRealFirstChild(item).IsOk();
+}
+
+bool wxTreeCtrl::IsExpanded(const wxTreeItemId& item) const
+{
+    wxCHECK_MSG(m_treeview, false, wxT("Invalid tree control"));
+    wxCHECK_MSG(GtkIsValidItem(item), false, wxT("Invalid item"));
+
+    if(GtkIsVirtualRoot(item))
+        return true; 
+
+    return gtk_tree_view_row_expanded(m_treeview, GtkItemEntryData(item)->path);
+}
+
+bool wxTreeCtrl::IsSelected(const wxTreeItemId& item) const
+{
+    wxCHECK_MSG(m_treeview, false, wxT("Invalid tree control"));
+    wxCHECK_MSG(GtkIsValidItem(item), false, wxT("Invalid item"));
+
+    if(GtkIsVirtualRoot(item))
+        return false;
+
+    wxTreeEntryData* data = GtkItemEntryData(item);
+    
+    GtkTreeSelection* selection = gtk_tree_view_get_selection(m_treeview); 
+    return gtk_tree_selection_path_is_selected(selection, data->path);
+}
+
+bool wxTreeCtrl::IsBold(const wxTreeItemId& item) const
+{
+    wxCHECK_MSG(m_treeview, false, wxT("Invalid tree control"));
+    wxCHECK_MSG(GtkIsValidItem(item), false, wxT("Invalid item"));
+
+    wxTreeEntryData* data = GtkItemEntryData(item);
+    return data->bBold ||
+           (data->font.Ok() && data->font.GetWeight() >= wxFONTWEIGHT_BOLD);
+}
+
+//----------------------------------------------------------------------------
+// number of children
+//----------------------------------------------------------------------------
+
+size_t wxTreeCtrl::GetChildrenCount(const wxTreeItemId& item, 
+                                    bool recursively) const
+{
+    wxCHECK_MSG(m_treeview, 0, wxT("Invalid tree control"));
+    wxCHECK_MSG(GtkIsValidItem(item), 0, wxT("Invalid item"));
+
+    GtkTreeIter* pIter;
+    GtkTreeIter iter;
+    
+    if(!GtkIsVirtualRoot(item))
+    {
+        gtk_tree_model_get_iter(GTK_TREE_MODEL(m_treestore), 
+                            &iter, GtkItemEntryData(item)->path);
+        pIter = &iter;
+    }
+    else
+        pIter = NULL;
+
+    gint count =
+        gtk_tree_model_iter_n_children(GTK_TREE_MODEL(m_treestore), pIter);    
+
+#if wxUSE_SEPARATORS
+    if(count > 1)
+        count /= 2; //filter out separators
+    else 
+#endif
+        if(count == 1 && !GtkIsVirtualRoot(item) &&
+            GtkRealFirstChild(item) == m_fakechild)
+        count = 0; //no children, really
+
+    if(recursively && count != 0)
+    {
+        wxTreeItemIdValue cookie;
+        wxTreeItemId child = GetFirstChild(item, cookie);
+
+        do
+        {   
+            count += GetChildrenCount(child);
+        }
+        while((child = GetNextSibling(child)).IsOk());    
+    }
+        
+    return count;
+}
+
+//----------------------------------------------------------------------------
+// navigation
+//----------------------------------------------------------------------------
+
+wxTreeItemId wxTreeCtrl::GetRootItem() const
+{
+    return m_root;
+}
+
+wxTreeItemId wxTreeCtrl::GetSelection() const
+{
+    wxCHECK_MSG(m_treeview, wxTreeItemId(), wxT("invalid treeview"));
+    wxCHECK_MSG(!HasFlag(wxTR_MULTIPLE) && !HasFlag(wxTR_EXTENDED), 
+                  wxTreeItemId(), 
+                  wxT("must be single selection treectrl"));
+
+    GtkTreeIter iter;    
+    GtkTreeSelection* selection = gtk_tree_view_get_selection(m_treeview);
+
+    //only works on single-sel    
+    if(!gtk_tree_selection_get_selected(selection, NULL, &iter))
+        return wxTreeItemId();
+
+    return GtkIterEntry(&iter);
+}
+
+size_t wxTreeCtrl::GetSelections(wxArrayTreeItemIds& selections) const
+{
+    wxCHECK_MSG(m_treeview, 0, wxT("invalid treeview") );
+    wxCHECK_MSG(HasFlag(wxTR_MULTIPLE) || HasFlag(wxTR_EXTENDED), 
+                    wxTreeItemId(), 
+                    wxT("must be multiple/extended selection treectrl"));
+
+    selections.Empty();
+
+    GtkTreeIter iter;    
+    GtkTreeSelection* selection = gtk_tree_view_get_selection(m_treeview);
+
+    if(gtk_tree_model_get_iter_first(GTK_TREE_MODEL(m_treestore), &iter))
+    { //gtk_tree_selection_get_selected_rows is GTK 2.2+ so iter instead
+        do
+        {
+            if(gtk_tree_selection_iter_is_selected(selection, &iter))
+               selections.Add(GtkIterEntry(&iter));
+
+        }while(gtk_tree_model_iter_next(GTK_TREE_MODEL(m_treestore), &iter));
+    }
+    
+    return selections.GetCount();
+}
+
+wxTreeItemId wxTreeCtrl::GetItemParent(const wxTreeItemId& item) const
+{
+    wxCHECK_MSG(m_treeview, wxTreeItemId(), wxT("invalid treectrl"));
+    wxCHECK_MSG(GtkIsValidItem(item), wxTreeItemId(), wxT("Invalid item"));
+
+    if(item == m_root)
+        return wxTreeItemId();
+
+    GtkTreeEntry* entry = GTK_TREE_ENTRY(item.m_pItem);
+    wxTreeEntryData* data = (wxTreeEntryData*) gtk_tree_entry_get_userdata(entry);
+
+    GtkTreeIter iter, iterparent;
+    gtk_tree_model_get_iter(GTK_TREE_MODEL(m_treestore), &iter, data->path);
+    if(!gtk_tree_model_iter_parent(GTK_TREE_MODEL(m_treestore), 
+                                   &iterparent, &iter))
+    {
+        if(HasFlag(wxTR_HIDE_ROOT))
+            return m_root;
+        else
+            return wxTreeItemId();
+    }
+
+    gtk_tree_model_get(GTK_TREE_MODEL(m_treestore), &iterparent,
+                       WXTREECTRL_TEXTINDEX, &entry, -1);
+    g_object_unref(G_OBJECT(entry)); //free on destruction
+    
+    return entry;
+}
+
+wxTreeItemId wxTreeCtrl::GetFirstChild(const wxTreeItemId& item,
+                                   wxTreeItemIdValue& cookie) const
+{
+    wxCHECK_MSG(m_treeview, wxTreeItemId(), wxT("invalid treectrl"));
+    wxCHECK_MSG(GtkIsValidItem(item), wxTreeItemId(), wxT("Invalid item"));
+
+    wxTreeItemId child;
+    if(GtkIsVirtualRoot(item))
+    {
+        GtkTreeIter iter;
+        if(gtk_tree_model_get_iter_first(GTK_TREE_MODEL(m_treestore), &iter))
+           child = GtkIterEntry(&iter);
+    }
+    else
+    {
+        child = GtkRealFirstChild(item);
+        if(child == m_fakechild)
+            child = wxTreeItemId();
+    }
+
+    cookie = (wxTreeItemIdValue)child.m_pItem;
+    return cookie;
+}
+
+wxTreeItemId wxTreeCtrl::GetNextChild(const wxTreeItemId& item,
+                                      wxTreeItemIdValue& cookie) const
+{
+    cookie = (wxTreeItemIdValue)GetNextSibling(cookie).m_pItem;
+    return cookie;
+}
+
+wxTreeItemId wxTreeCtrl::GetLastChild(const wxTreeItemId& item) const
+{
+    wxCHECK_MSG(m_treeview, wxTreeItemId(), wxT("invalid treectrl"));
+    wxCHECK_MSG(GtkIsValidItem(item), wxTreeItemId(), wxT("Invalid item"));
+
+    gint numchildren = GetChildrenCount(item, false);
+
+    GtkTreeIter* pIter;
+    GtkTreeIter iter;
+    
+    if(!GtkIsVirtualRoot(item))
+    {
+        gtk_tree_model_get_iter(GTK_TREE_MODEL(m_treestore), 
+                            &iter, GtkItemEntryData(item)->path);
+        pIter = &iter;
+    }
+    else
+        pIter = NULL;
+
+    if(numchildren)
+    {
+        GtkTreeIter iterchild;
+#if wxUSE_SEPARATORS
+        if(!gtk_tree_model_iter_nth_child(GTK_TREE_MODEL(m_treestore), 
+                                          &iterchild, pIter, (numchildren*2)-2))
+#else
+        if(!gtk_tree_model_iter_nth_child(GTK_TREE_MODEL(m_treestore), 
+                                          &iterchild, pIter, numchildren-1))
+#endif
+            return wxTreeItemId();
+
+        return GtkIterEntry(&iterchild);
+    }
+    else
+        return wxTreeItemId();
+}
+
+wxTreeItemId wxTreeCtrl::GetNextSibling(const wxTreeItemId& item) const
+{
+    wxCHECK_MSG(m_treeview, wxTreeItemId(), wxT("invalid treectrl"));
+    wxCHECK_MSG(GtkIsValidItem(item), wxTreeItemId(), wxT("Invalid item"));
+
+    GtkTreeIter iter;
+    gtk_tree_model_get_iter(GTK_TREE_MODEL(m_treestore), 
+                            &iter, GtkItemEntryData(item)->path);
+
+    if(!gtk_tree_model_iter_next(GTK_TREE_MODEL(m_treestore), &iter))
+        return wxTreeItemId();
+
+    GtkTreeEntry* entry = GtkIterEntry(&iter);
+
+#if wxUSE_SEPARATORS
+    if(entry == m_separator)
+    {
+        if(!gtk_tree_model_iter_next(GTK_TREE_MODEL(m_treestore), &iter))
+            return wxTreeItemId();
+        entry = GtkIterEntry(&iter);
+    }
+#endif
+
+    return entry;
+}
+
+wxTreeItemId wxTreeCtrl::GetPrevSibling(const wxTreeItemId& item) const
+{
+    wxCHECK_MSG(m_treeview, wxTreeItemId(), wxT("invalid treectrl"));
+    wxCHECK_MSG(GtkIsValidItem(item), wxTreeItemId(), wxT("Invalid item"));
+
+    wxTreeItemIdValue cookie;
+    wxTreeItemId cur, last, parent;
+    parent = GetItemParent(item);
+    if(!parent)
+        return wxTreeItemId();
+
+    cur = GetFirstChild(parent, cookie);
+    while(cur.IsOk())
+    {
+        if(cur == item)
+            break;
+
+        last = cur;
+        cur = GetNextSibling(cur);
+    }
+
+    return last;
+}
+
+wxTreeItemId wxTreeCtrl::GetFirstVisibleItem() const
+{
+    wxCHECK_MSG(m_treeview, wxTreeItemId(), wxT("invalid treectrl"));
+
+    return GtkHitTest();
+}
+
+wxTreeItemId wxTreeCtrl::GetNextVisible(const wxTreeItemId& item) const
+{
+    wxCHECK_MSG(m_treeview, wxTreeItemId(), wxT("invalid treectrl"));
+    wxCHECK_MSG(GtkIsValidItem(item), wxTreeItemId(), wxT("Invalid item"));
+
+    GdkRectangle fullbounds;   //== cellbounds + borders + indent
+    gtk_tree_view_get_background_area(m_treeview, 
+                                GtkItemEntryData(item)->path,
+                                gtk_tree_view_get_column(m_treeview, 0),              
+                                &fullbounds); 
+
+    return GtkHitTest(wxPoint(0, fullbounds.y + fullbounds.height+1));
+}
+
+wxTreeItemId wxTreeCtrl::GetPrevVisible(const wxTreeItemId& item) const
+{
+    wxCHECK_MSG(m_treeview, wxTreeItemId(), wxT("invalid treectrl"));
+    wxCHECK_MSG(GtkIsValidItem(item), wxTreeItemId(), wxT("Invalid item"));
+
+    GdkRectangle fullbounds;   //== cellbounds + borders + indent
+    gtk_tree_view_get_background_area(m_treeview, 
+                                GtkItemEntryData(item)->path,
+                                gtk_tree_view_get_column(m_treeview, 0),              
+                                &fullbounds); 
+
+    return GtkHitTest(wxPoint(0, fullbounds.y - 1));
+}
+
+//----------------------------------------------------------------------------
+// operations
+//----------------------------------------------------------------------------
+
+wxTreeItemId wxTreeCtrl::AddRoot(const wxString& text,
+                                 int image, int selImage,
+                                 wxTreeItemData *itemdata)
+{
+    wxCHECK_MSG(m_treeview, wxTreeItemId(), wxT("invalid treectrl"));
+    wxCHECK_MSG(!GetRootItem().IsOk(), wxTreeItemId(), wxT("Already have a root"));
+    
+    if(HasFlag(wxTR_HIDE_ROOT))
+    {
+        GtkTreeEntry* entry = gtk_tree_entry_new();
+        gtk_tree_entry_set_label(entry, wxConvUTF8.cWX2MB(text));
+        gtk_tree_entry_set_destroy_func(entry, 
+                (GtkTreeEntryDestroy)gtk_tree_entry_destroy_callback,
+                                        this);
+
+        wxTreeEntryData* data = new wxTreeEntryData;
+        gtk_tree_entry_set_userdata(entry, data);
+        data->images[0] = image;
+        data->images[1] = selImage;
+        //RN: Personally I think these two should be image+selImage 
+        //respectively instead of no image...
+        data->images[2] = data->images[3] = -1; 
+        data->itemdata = itemdata;       
+        
+        if(data->itemdata)
+            data->itemdata->SetId(entry);
+
+        m_root = entry;
+    }
+    else
+        m_root = GtkInsertItem(wxTreeItemId(), wxTreeItemId(),
+                           text, image, selImage, itemdata, false);
+    return m_root;
+}
+
+void wxTreeCtrl::Delete(const wxTreeItemId& item)
+{
+    wxCHECK_RET(m_treeview, wxT("invalid treectrl"));
+    wxCHECK_RET(GtkIsValidItem(item), wxT("Invalid item"));
+
+    if(GtkIsVirtualRoot(item))
+    {
+        InvalidateBestSize();
+        gtk_tree_store_clear(m_treestore);
+        g_object_unref(G_OBJECT(m_root.m_pItem));
+        m_root = wxTreeItemId();
+    }
+    else
+        GtkDeleteItem(item);
+}
+
+void wxTreeCtrl::DeleteChildren(const wxTreeItemId& item)
+{
+    wxTreeItemId child;
+    wxTreeItemIdValue cookie;
+
+    m_blockEvent = TRUE;
+
+    child = GetFirstChild(item, cookie);
+    while(child.IsOk())
+    {
+        GtkDeleteItem(child);        
+        child = GetFirstChild(item, cookie);
+    }
+
+    m_blockEvent = FALSE;
+}
+
+void wxTreeCtrl::DeleteAllItems()
+{
+    wxCHECK_RET(m_treeview, wxT("invalid treectrl"));
+
+    m_blockEvent = TRUE;
+    if(HasFlag(wxTR_HIDE_ROOT))
+        Delete(m_root);
+    else
+    {
+        InvalidateBestSize();
+        gtk_tree_store_clear(m_treestore);
+        m_root = wxTreeItemId();
+    }
+    m_blockEvent = FALSE;
+}
+
+void wxTreeCtrl::Expand(const wxTreeItemId& item)
+{
+    wxCHECK_RET(m_treeview, wxT("invalid treectrl"));
+    wxCHECK_RET(GtkIsValidItem(item), wxT("Invalid item"));
+
+    if(GtkIsVirtualRoot(item))
+        return;
+
+    //Third param is whether to recursively expand all children (NO :))
+    gtk_tree_view_expand_row(m_treeview, GtkItemEntryData(item)->path, FALSE);
+    GtkUpdateItem(item);
+}
+
+void wxTreeCtrl::Collapse(const wxTreeItemId& item)
+{
+    wxCHECK_RET(m_treeview, wxT("invalid treectrl"));
+    wxCHECK_RET(GtkIsValidItem(item), wxT("Invalid item"));
+
+    if(GtkIsVirtualRoot(item))
+        return;
+
+    //Note that this function and the expand return a boolean, but we
+    //use events for that sort of thing and these two functions don't return
+    //anything
+    gtk_tree_view_collapse_row(m_treeview, GtkItemEntryData(item)->path);
+    GtkUpdateItem(item);
+}
+
+void wxTreeCtrl::CollapseAndReset(const wxTreeItemId& item)
+{
+    wxCHECK_RET(m_treeview, wxT("invalid treectrl"));
+    wxCHECK_RET(GtkIsValidItem(item), wxT("Invalid item"));
+
+    Collapse(item);
+    DeleteChildren(item);
+}
+
+void wxTreeCtrl::Toggle(const wxTreeItemId& item)
+{
+    if(IsExpanded(item))
+        Collapse(item);
+    else
+        Expand(item);
+}
+
+void wxTreeCtrl::Unselect()
+{  
+    wxCHECK_RET(m_treeview, wxT("invalid treectrl"));
+
+    if(HasFlag(wxTR_SINGLE))
+        UnselectAll();
+    else
+    {
+        wxArrayTreeItemIds ids;
+        GetSelections(ids);
+    
+        if(ids.GetCount())
+            GtkSelectItem(ids[0], false, TRUE);
+    }
+}
+
+void wxTreeCtrl::UnselectAll()
+{
+    wxCHECK_RET(m_treeview, wxT("invalid treectrl"));
+
+    GtkTreeSelection* selection = gtk_tree_view_get_selection(m_treeview);
+
+    m_blockEvent = TRUE;//TODO: Send events also?
+    gtk_tree_selection_unselect_all(selection);
+    m_blockEvent = FALSE;
+}
+
+void wxTreeCtrl::SelectItem(const wxTreeItemId& item, bool select)
+{
+    wxCHECK_RET(m_treeview, wxT("invalid treectrl"));
+    wxCHECK_RET(GtkIsValidItem(item), wxT("Invalid item"));
+
+    GtkSelectItem(item, select, TRUE); //TODO: Send events also?
+}
+
+void wxTreeCtrl::EnsureVisible(const wxTreeItemId& item)
+{
+    wxCHECK_RET(m_treeview, wxT("invalid treectrl"));
+    wxCHECK_RET(GtkIsValidItem(item), wxT("Invalid item"));
+    wxCHECK_RET(!GtkIsVirtualRoot(item), wxT("Cannot show hidden root"));
+
+    //HACKHACKHACK: the treectrl sample and possibly other programs
+    //will set item.m_pItem in the expanded callback
+    //to 0x0 which will cause an assert in the ScrollTo
+    //below (LOLZ HACK FOR THE SAMPLEZ -- RN) 
+    wxTreeItemId zOMGBADSAMPLEHACK = item;
+
+    //expand parents (must expand from top down)
+    wxArrayTreeItemIds parents;
+    int i = 0;
+    
+    wxTreeItemId parent = GetItemParent(item);
+    while(parent.IsOk())
+    {
+        parents.Add(parent);
+        ++i;
+        parent = GetItemParent(parent);
+    }
+    
+    while(i != 0)
+        Expand(parents[--i]);
+
+    ScrollTo(zOMGBADSAMPLEHACK);
+}
+
+void wxTreeCtrl::ScrollTo(const wxTreeItemId& item)
+{
+    wxCHECK_RET(m_treeview, wxT("invalid treectrl"));
+    wxCHECK_RET(GtkIsValidItem(item), wxT("Invalid item"));
+    wxCHECK_RET(!GtkIsVirtualRoot(item), wxT("Cannot show hidden root"));
+
+#if 0 //old set_viewport way
+    GtkAdjustment* adjustment = GtkGetVAdjustment();
+
+    wxRect box;
+    GetBoundingRect(item, box);
+
+    float y = (float) box.y;
+    if (y > adjustment->upper - adjustment->page_size)
+        y = adjustment->upper - adjustment->page_size;
+    gtk_adjustment_set_value( adjustment, y );
+#else
+    // Scroll to the desired cell (0.0 == topleft alignment)
+    gtk_tree_view_scroll_to_cell(m_treeview, GtkItemEntryData(item)->path, 
+                                 NULL, TRUE, 0.0f, 0.0f);
+#endif
+}
+
+wxTextCtrl * wxTreeCtrl::EditLabel(const wxTreeItemId& item,
+                                   wxClassInfo* textCtrlClass)
+{
+    wxCHECK_MSG(m_treeview, NULL, wxT("invalid treectrl"));
+    wxCHECK_MSG(GtkIsValidItem(item), NULL, wxT("Invalid item"));
+    wxCHECK_MSG(!GtkIsVirtualRoot(item), NULL, wxT("Cannot edit hidden root"));
+
+#if GTK_CHECK_VERSION(2, 6, 0)
+    if(!gtk_check_version(2,6,0))
+    {
+        if(m_textctrl)
+            EndEditLabel(item /*parameter not used :)*/, FALSE);
+
+        if(!HasFlag(wxTR_EDIT_LABELS)) //make editable
+        {
+            g_object_set(G_OBJECT(m_textrenderer), "editable", TRUE, NULL);
+            g_object_set(G_OBJECT(m_textrenderer), "editable-set", TRUE, NULL);
+        }
+            
+
+        gtk_widget_grab_focus(GTK_WIDGET(m_treeview));
+        m_textctrl = (wxTextCtrl *)textCtrlClass->CreateObject();
+        gtk_tree_view_set_cursor(m_treeview,
+                             GtkItemEntryData(item)->path,
+                             gtk_tree_view_get_column(m_treeview, 0),
+                             TRUE);
+        return m_textctrl;
+    }
+#else
+    wxFAIL_MSG(wxT("not implemented"));
+#endif
+    return NULL; 
+}
+
+wxTextCtrl *wxTreeCtrl::GetEditControl() const
+{
+    return m_textctrl;
+}
+
+void wxTreeCtrl::EndEditLabel(const wxTreeItemId& item,
+                              bool discardChanges)
+{
+    wxCHECK_RET(m_treeview, wxT("invalid treectrl"));
+
+    //Note that gtk_cell_editable_editing_done is not really what we want
+    //here as that is only a hint to the renderer, rather we notify the
+    //GtkCellEditable directly in our cached in wxTextCtrl to stop
+    if(m_textctrl)
+    {
+        if(GTK_IS_CELL_EDITABLE(m_textctrl->m_widget))
+        {
+            GtkCellEditable* editable = 
+                GTK_CELL_EDITABLE(m_textctrl->m_widget);
+            if(discardChanges)
+                m_textctrl->DissociateHandle();        
+
+            m_blockEvent = discardChanges;
+            gtk_cell_editable_editing_done(editable);
+            gtk_cell_editable_remove_widget(editable);
+            m_blockEvent = FALSE;
+        }
+
+        if(discardChanges)
+        {
+            delete m_textctrl;
+            m_textctrl = NULL;
+            if(!HasFlag(wxTR_EDIT_LABELS)) //restore old editable state
+            {
+                g_object_set(G_OBJECT(m_textrenderer), 
+                             "editable", FALSE, NULL);
+                g_object_set(G_OBJECT(m_textrenderer), 
+                             "editable-set", FALSE, NULL);
+            }
+        }
+    }
+    else
+        wxLogSysError(wxT("Not editing anything!"));
+}
+
+//----------------------------------------------------------------------------
+// sorting - case sensitive by default
+//----------------------------------------------------------------------------
+
+int wxTreeCtrl::OnCompareItems(const wxTreeItemId& item1,
+                               const wxTreeItemId& item2)
+{
+    return strcmp(gtk_tree_entry_get_collate_key(GTK_TREE_ENTRY(item1.m_pItem)),
+                  gtk_tree_entry_get_collate_key(GTK_TREE_ENTRY(item2.m_pItem)));
+}
+
+void wxTreeCtrl::SortChildren(const wxTreeItemId& item)
+{
+    wxCHECK_RET(m_treeview, wxT("invalid treectrl"));
+    wxCHECK_RET(GtkIsValidItem(item), wxT("Invalid item"));
+
+    //RN: We either have two choices here:
+    //1) Recursively save and then re-insert all children
+    //   of an item
+    //2) use gtk_tree_store_swap and require GTK 2.2+
+    //We do (1) but have code for both...
+#if 0
+    gchar* message = gtk_check_version(2,2,0);
+    if(message)
+    {
+        wxLogSysError(message);
+        return;
+    }
+#endif
+
+    bool bSorted;  //if sorted already
+    wxTreeItemIdValue cookie;
+	wxTreeItemId cur = GetFirstChild(item, cookie), last = cur, prev;
+    if(!cur.IsOk())     
+        return;
+
+    //bubble sort :)
+    do
+    {
+        bSorted = true;
+        last = GetNextSibling(last);
+        
+        for(wxTreeItemId next = last; next.IsOk(); 
+                prev = cur, cur = next, next = GetNextSibling(cur)) 
+        {		
+    		if (OnCompareItems(cur, next) > 0)
+    		{
+                //swap them
+                GtkMoveAfter(cur, next, item /* is parent */, prev);
+
+                bSorted = false;
+    		}
+        } //end next for loop
+
+        cur = last;
+        prev = NULL;
+    }while(!bSorted && last.IsOk());
+}
+
+
+//----------------------------------------------------------------------------
+// items geometry
+//----------------------------------------------------------------------------
+
+bool wxTreeCtrl::GetBoundingRect(const wxTreeItemId& item,
+                                 wxRect& rect,
+                                 bool textOnly) const
+{
+    wxCHECK_MSG(m_treeview, false, wxT("invalid treectrl"));
+    wxCHECK_MSG(GtkIsValidItem(item), false, wxT("Invalid item"));
+    wxCHECK_MSG(!GtkIsVirtualRoot(item), false, wxT("Cannot show hidden root"));
+
+    GtkTreeViewColumn* column = gtk_tree_view_get_column(m_treeview, 0);
+    
+    GdkRectangle gdkrect;
+    gtk_tree_view_get_background_area(m_treeview, 
+                                      GtkItemEntryData(item)->path,
+                                      column,              
+                                      &gdkrect); 
+    if(textOnly)
+    {
+        wxFont* pFont = &(GtkItemEntryData(item)->font);
+        int tw, th;
+        GetTextExtent(wxConvUTF8.cMB2WX(
+                            gtk_tree_entry_get_label(
+                                    GTK_TREE_ENTRY(item.m_pItem)
+                                                    )
+                                       ),
+                      &tw, &th, NULL, NULL, pFont->Ok() ? pFont : NULL
+                     );
+        rect = wxRect(gdkrect.x + gdkrect.width - tw, 
+                      gdkrect.y + gdkrect.height - th, 
+                      tw, 
+                      th);
+    }
+    else
+        rect = wxRect(gdkrect.x, gdkrect.y, 
+                      gdkrect.width, gdkrect.height);
+
+    return true;
+}
+
+//----------------------------------------------------------------------------
+// implementation/protected
+//----------------------------------------------------------------------------
+
+wxSize wxTreeCtrl::DoGetBestSize() const
+{
+    wxCHECK_MSG(m_treeview, wxDefaultSize, wxT("invalid tree view"));
+
+#if 0 // FIXME: Something like this should work, but other implementations
+      // don't overload DoGetBestSize...
+    if(!GTK_WIDGET_REALIZED(m_treeview) ||
+       !GTK_WIDGET_REALIZED(m_widget))
+        return wxDefaultSize; //not realized yet, wait a while...
+
+    int lbWidth;
+    int lbHeight;
+
+    //descend down and get last visible child
+    wxTreeItemId item = GetRootItem(), child;
+
+    do
+    {
+        child = item;
+        item = GetLastChild(child);
+    }
+    while(item.IsOk() && IsExpanded(item));
+
+    //Now get the low y point (base height)
+    wxRect box;
+    GetBoundingRect(child, box, false);
+    lbHeight = box.y + box.height;
+
+    // Get the base width
+    GtkTreeViewColumn* column = gtk_tree_view_get_column(m_treeview, 0);
+    lbWidth = gtk_tree_view_column_get_width(column);
+
+    // Get the visible area of the tree view
+    GdkRectangle rect;
+    gtk_tree_view_get_visible_rect(m_treeview, &rect);
+    lbWidth = rect.width;
+    lbHeight = rect.height;
+
+    // don't make the treeview too tall (limit height to around 10 items) but don't
+    // make it too small neither
+    int cy;
+    gtk_tree_view_column_cell_get_size(
+                                       column,
+                                       NULL, NULL, NULL, NULL,
+                                       &cy);
+    lbHeight = wxMin(cy*10, lbHeight);
+
+    // add room for the scrollbars (TODO: Only add if it has the style)
+    lbWidth  += wxSystemSettings::GetMetric(wxSYS_VSCROLL_X);
+    lbHeight += wxSystemSettings::GetMetric(wxSYS_HSCROLL_Y);
+
+    // finish up
+    wxSize best(lbWidth, lbHeight);
+    CacheBestSize(best);
+    return best;
+#else
+    return wxControl::DoGetBestSize();
+#endif
+}
+
+wxTreeItemId wxTreeCtrl::DoInsertItem(const wxTreeItemId& parent,
+                                      size_t pos,
+                                      const wxString& text,
+                                      int image, int selImage,
+                                      wxTreeItemData *data)
+{
+    wxCHECK_MSG(m_treeview, wxTreeItemId(), wxT("invalid treectrl"));
+    wxCHECK_MSG(GtkIsValidItem(parent), wxTreeItemId(), wxT("invalid parent"));
+
+    if(pos == (size_t)-1)
+        return GtkInsertItem(parent, wxTreeItemId(), text, 
+                             image, selImage, data, false);
+//  We don't allow without a parent but here's the way it would be
+//    else if(!parent.IsOk())
+//        return GtkInsertItem(parent, wxTreeItemId(), text, 
+//                             image, selImage, data, true);
+    else
+    {
+        size_t index = 0;
+
+        wxTreeItemIdValue cookie;
+        wxTreeItemId cur;
+        cur = GetFirstChild(parent, cookie);
+
+        for(; index < pos; ++index)
+            cur = GetNextChild(cur, cookie);
+
+        return GtkInsertItem(parent, cur, text, 
+                             image, selImage, data, false);
+    }    
+}
+
+wxTreeItemId wxTreeCtrl::DoInsertAfter(const wxTreeItemId& parent,
+                                       const wxTreeItemId& idPrevious,
+                                       const wxString& text,
+                                       int image, int selImage,
+                                       wxTreeItemData *data)
+{
+    wxCHECK_MSG(m_treeview, wxTreeItemId(), wxT("invalid treectrl"));
+    wxCHECK_MSG(GtkIsValidItem(parent), wxTreeItemId(), wxT("invalid parent"));
+
+    return GtkInsertItem(parent, idPrevious, text, image, 
+                         selImage, data, true);
+}
+
+wxTreeItemId wxTreeCtrl::DoTreeHitTest(const wxPoint& point, int& flags)
+{
+    wxCHECK_MSG(m_treeview, wxTreeItemId(), wxT("invalid treectrl"));
+
+    return GtkHitTest(point, &flags);
+}
+
+//-----------------------------------------------------------------------------
+// GTK implementation
+//-----------------------------------------------------------------------------
+
+void wxTreeCtrl::GtkUpdateItem(const wxTreeItemId& item)
+{   
+    //TODO: Use gtk_cell_renderer_render instead?
+    Refresh();
+    Update();
+}
+
+wxTreeItemId wxTreeCtrl::GtkInsertItem(const wxTreeItemId& desiredparent,
+                                       const wxTreeItemId& idPrevious,
+                                       const wxString& text,
+                                       int image, int selImage,
+                                       wxTreeItemData *itemdata,
+                                       bool bAppend,
+                                       GtkTreeEntry* entry)
+{
+    InvalidateBestSize();
+
+    wxTreeItemId parent;
+    if(GtkIsVirtualRoot(desiredparent))
+        parent = wxTreeItemId(); //insert at top
+    else
+        parent = desiredparent;
+
+    // Get parent/prev iterators
+    GtkTreeIter iterparent, iterprev;
+    GtkTreeIter* pIterparent;
+    GtkTreeIter* pIterprev;
+    
+    if(parent.IsOk())
+    {
+        gtk_tree_model_get_iter(GTK_TREE_MODEL(m_treestore), 
+                                &iterparent, GtkItemEntryData(parent)->path);
+        pIterparent = &iterparent;
+    }
+    else
+        pIterparent = NULL;
+
+    if(idPrevious.IsOk())
+    {
+        gtk_tree_model_get_iter(GTK_TREE_MODEL(m_treestore), 
+                                &iterprev, GtkItemEntryData(idPrevious)->path);
+        pIterprev = &iterprev;
+    }
+    else
+        pIterprev = NULL;
+
+    wxTreeEntryData* data;
+    if(!entry)  //no replacement entry? Create a new one
+    {
+        entry = gtk_tree_entry_new();
+        gtk_tree_entry_set_label(entry, wxConvUTF8.cWX2MB(text));
+        gtk_tree_entry_set_destroy_func(entry, 
+                (GtkTreeEntryDestroy)gtk_tree_entry_destroy_callback,
+                                        this);
+
+        data = new wxTreeEntryData;
+        gtk_tree_entry_set_userdata(entry, data);
+        data->images[0] = image;
+        data->images[1] = selImage;
+        //RN: Personally I think these two should be image+selImage 
+        //respectively instead of no image...
+        data->images[2] = data->images[3] = -1; 
+        data->itemdata = itemdata;       
+        
+        if(data->itemdata)
+            data->itemdata->SetId(entry);
+    }
+    else
+        data = (wxTreeEntryData*) gtk_tree_entry_get_userdata(entry);
+    
+    //Now do actual insertion
+    GtkTreeIter itercur;
+    if(parent && GtkRealFirstChild(parent) == m_fakechild)
+    {
+        //Special case of forced children - simply set the entry of the fake one
+        gtk_tree_model_iter_children(GTK_TREE_MODEL(m_treestore), &itercur,
+                                     pIterparent);
+    } 
+    else if(bAppend)
+        gtk_tree_store_insert_after(m_treestore, &itercur, pIterparent, pIterprev);
+    else
+        gtk_tree_store_insert_before(m_treestore, &itercur, pIterparent, pIterprev);
+ 
+    gtk_tree_store_set(m_treestore, &itercur, WXTREECTRL_TEXTINDEX, entry, -1);
+
+    //Now recalc the paths
+    if(data->path)
+        gtk_tree_path_free(data->path);
+
+
+    if(!GtkIsFakeItem(entry))
+    {
+        data->path = gtk_tree_model_get_path(GTK_TREE_MODEL(m_treestore), &itercur);
+
+        wxTreeItemId recalcitem = GetNextSibling(entry);
+        if(recalcitem.IsOk())
+            GtkRecalcPaths(recalcitem, parent, entry);
+
+        g_object_unref(G_OBJECT(entry)); //treemodel always refs
+
+#if wxUSE_SEPARATORS
+        //Now insert (possibly virtual) seperator
+        GtkInsertItem(parent, entry, wxT(""), -1, -1, NULL, true, 
+                      GTK_TREE_ENTRY(m_separator.m_pItem));
+#endif
+    }
+
+    return entry;
+}
+
+wxTreeEntryData* wxTreeCtrl::GtkItemEntryData(const wxTreeItemId& item) const
+{
+    GtkTreeEntry* entry = GTK_TREE_ENTRY(item.m_pItem);
+    return (wxTreeEntryData*) gtk_tree_entry_get_userdata(entry);  
+}
+
+bool wxTreeCtrl::GtkSendEvent(GtkTreeIter* iter, const wxEventType& type,
+                              const wxTreeItemId& olditem, const wxString& label)
+{ //RN: An attempt to simplify event sending...
+    GtkTreeEntry* entry;
+    gtk_tree_model_get(GTK_TREE_MODEL(m_treestore), iter,
+                       WXTREECTRL_TEXTINDEX, &entry, -1);
+    g_object_unref(G_OBJECT(entry));
+
+    if(!GtkIsValidItem(entry))
+        return false; //don't process
+    
+    wxTreeEvent event( type, GetId() );
+    event.m_item = entry;
+    event.m_itemOld = olditem;
+    event.m_label = label;
+    event.SetEventObject(this);
+    ProcessEvent(event);
+
+    return event.IsAllowed();
+}
+
+GtkTreeEntry* wxTreeCtrl::GtkIterEntry(GtkTreeIter* iter) const
+{
+    GtkTreeEntry* entry;
+    gtk_tree_model_get(GTK_TREE_MODEL(m_treestore), iter,
+                       WXTREECTRL_TEXTINDEX, &entry, -1);  
+    if(!entry)
+    {
+        GtkTreePath* path =
+            gtk_tree_model_get_path(GTK_TREE_MODEL(m_treestore), iter);
+        gchar* pathstring = gtk_tree_path_to_string(path);
+        wxString errormsg;
+        errormsg.Printf(wxT("NULL entry found, path:%s"), pathstring);
+        wxFAIL_MSG(errormsg);
+        g_free(pathstring);
+        gtk_tree_path_free(path);
+        return NULL;   
+    }
+    g_object_unref(G_OBJECT(entry)); //free on destruction
+    return entry;
+}
+
+GtkAdjustment* wxTreeCtrl::GtkGetVAdjustment() const
+{
+#if 0 //old code for use when using add_with_viewport from GtkScrolledWindow
+    //RN: I have no idea why this line is needed...
+    if (gdk_pointer_is_grabbed () && GTK_WIDGET_HAS_GRAB (m_treeview))
+        return NULL;
+
+    // RN: Note that evidently the vadjustment property "vadjustment" from
+    // GtkTreeView is different from the "gtk-vadjustment"...
+    // (i.e. gtk_tree_view_get_vadjustment)
+    const gchar *vadjustment_key = "gtk-vadjustment";
+    guint vadjustment_key_id = g_quark_from_static_string (vadjustment_key);
+
+    GtkAdjustment *adjustment =
+       (GtkAdjustment*) gtk_object_get_data_by_id (GTK_OBJECT (m_treeview), 
+                                                   vadjustment_key_id);
+    wxCHECK_MSG( adjustment, NULL, wxT("invalid treectrl code") );
+
+    return adjustment;
+#else
+    return gtk_tree_view_get_vadjustment(m_treeview);
+#endif
+}
+
+void wxTreeCtrl::GtkSelectItem(const wxTreeItemId& item, 
+                               const bool select, const bool blockEvent)
+{
+    GtkTreeSelection* selection = gtk_tree_view_get_selection(m_treeview);
+
+    GtkTreeIter iter;
+    gtk_tree_model_get_iter(GTK_TREE_MODEL(m_treestore), 
+                            &iter, GtkItemEntryData(item)->path);    
+
+    m_blockEvent = blockEvent;
+
+    if(select)
+        gtk_tree_selection_select_iter(selection, &iter);
+    else
+        gtk_tree_selection_unselect_iter(selection, &iter);
+
+    m_blockEvent = FALSE;
+} 
+
+void wxTreeCtrl::GtkDeleteItem(const wxTreeItemId& item)
+{
+    InvalidateBestSize();
+
+    wxTreeItemId sib = GetNextSibling(item);
+    wxTreeItemId parent = GetItemParent(item);
+    wxTreeItemId prev = GetPrevSibling(item);
+
+#if 0 //debugging
+        gchar* pathstring = gtk_tree_path_to_string(GtkItemEntryData(item)->path);
+        wxString errormsg;
+        errormsg.Printf(wxT("deleting path:%s"), pathstring);
+        wxLogDebug(errormsg);
+        g_free(pathstring);
+#endif
+
+    GtkTreeIter iter;
+    gtk_tree_model_get_iter(GTK_TREE_MODEL(m_treestore), 
+                            &iter, GtkItemEntryData(item)->path);    
+
+    gtk_tree_store_remove(m_treestore, &iter);
+    if(sib.IsOk())  
+        GtkRecalcPaths(sib, parent, prev);
+    //If the item has the spacer forced and all the real children have croaked
+    //reinsert the fake child
+    if(parent.IsOk() && !GtkIsVirtualRoot(parent) && 
+       GtkItemEntryData(parent)->bHasChildren &&
+       GetChildrenCount(parent, false) == 0)
+    {
+        wxTreeCtrl::SetItemHasChildren(parent, true);
+    }
+}
+
+void wxTreeCtrl::GtkRecalcPaths(const wxTreeItemId& item,
+                                const wxTreeItemId& parent,
+                                const wxTreeItemId& prevsib)
+{
+    //RN: OK, this function is sort of ugly - the idea is that
+    //each wxTreeEntryData contains a path that lets us know where
+    //the item actually is - unfortunately we need to update
+    //ones that get invalidated by insertions and deletions
+    //Here we Correct the path of item and its children and
+    //next siblings
+    gtk_tree_path_free(GtkItemEntryData(item)->path);
+    GtkTreeIter iter;
+    if(prevsib.IsOk())
+    {
+        gtk_tree_model_get_iter(GTK_TREE_MODEL(m_treestore), 
+                                &iter,
+                                GtkItemEntryData(prevsib)->path);
+        gtk_tree_model_iter_next(GTK_TREE_MODEL(m_treestore), &iter);     
+#if wxUSE_SEPARATORS
+        gtk_tree_model_iter_next(GTK_TREE_MODEL(m_treestore), &iter);     
+#endif
+    }
+    else if(parent.IsOk() && !GtkIsVirtualRoot(parent))
+    {
+        GtkTreeIter iterparent;
+        gtk_tree_model_get_iter(GTK_TREE_MODEL(m_treestore), 
+                                &iterparent,
+                                GtkItemEntryData(parent)->path);
+        gtk_tree_model_iter_children(GTK_TREE_MODEL(m_treestore),   
+                                     &iter, &iterparent);     
+    }
+    else //root
+        gtk_tree_model_get_iter_first(GTK_TREE_MODEL(m_treestore), &iter);
+    
+    GtkItemEntryData(item)->path = 
+            gtk_tree_model_get_path(GTK_TREE_MODEL(m_treestore), &iter);
+    
+    wxTreeItemIdValue cookie;
+    wxTreeItemId sib = GetNextSibling(item);
+    wxTreeItemId child = GetFirstChild(item, cookie);
+
+    if(sib.IsOk())  
+        GtkRecalcPaths(sib, wxTreeItemId(), item);
+    if(child.IsOk())
+        GtkRecalcPaths(child, item, wxTreeItemId());
+}
+
+wxTreeItemId wxTreeCtrl::GtkHitTest(const wxPoint& point, int* flags) const
+{
+    //gtk_tree_view_get_path_at_pos also gets items that are not visible -
+    //we only want visible items so check here as well as setting flags
+    int w, h;
+    GetClientSize(&w, &h);
+    if (point.x<0) 
+    {
+        if(flags)
+            *flags = wxTREE_HITTEST_TOLEFT;
+        return wxTreeItemId();
+    }
+    else if (point.x>w) 
+    {
+        if(flags)
+            *flags = wxTREE_HITTEST_TORIGHT;
+        return wxTreeItemId();
+    }
+    else if (point.y<0) 
+    {
+        if(flags)
+            *flags = wxTREE_HITTEST_ABOVE;
+        return wxTreeItemId();
+    }
+    else if (point.y>h) 
+    {
+        if(flags)
+            *flags = wxTREE_HITTEST_BELOW;
+        return wxTreeItemId();
+    }
+    
+
+    if (flags) //clear flags, as not outside client area
+        *flags = 0;
+
+    //Need to translate from master window
+    gint binx, biny;
+    gdk_window_get_geometry(gtk_tree_view_get_bin_window(m_treeview), 
+                            &binx, &biny, NULL, NULL, NULL);
+
+    GtkTreePath* path;
+    if(!gtk_tree_view_get_path_at_pos(m_treeview, 
+                                  point.x - binx, point.y - biny,
+                                  &path, NULL, NULL, NULL)) //last two == x,y rel to cell
+    {
+        if(flags)
+            *flags = wxTREE_HITTEST_NOWHERE;
+        return wxTreeItemId();
+    }
+    GtkTreeIter iter;
+    gtk_tree_model_get_iter(GTK_TREE_MODEL(m_treestore), &iter, path);
+    gtk_tree_path_free(path);
+
+    GtkTreeEntry* entry;
+    gtk_tree_model_get(GTK_TREE_MODEL(m_treestore), &iter,
+                       WXTREECTRL_TEXTINDEX, &entry, -1);    
+    g_object_unref(G_OBJECT(entry));
+
+    if(flags)   
+    {
+        wxTreeEntryData* data = GtkItemEntryData(entry);
+        GtkTreeViewColumn* column = gtk_tree_view_get_column(m_treeview, 0);
+
+        GdkRectangle cellbounds;   
+        gtk_tree_view_get_cell_area(m_treeview, 
+                                data->path,
+                                column,              
+                                &cellbounds); 
+ 
+        GdkRectangle fullbounds;   //== cellbounds + borders + indent
+        gtk_tree_view_get_background_area(m_treeview, 
+                                data->path,
+                                column,              
+                                &fullbounds); 
+
+
+        if(point.y > fullbounds.y + (fullbounds.height/2))
+            (*flags) |= wxTREE_HITTEST_ONITEMLOWERPART;
+        else
+            (*flags) |= wxTREE_HITTEST_ONITEMUPPERPART;
+
+        int buttonsize = 12; //default treeview spacer size, 
+                             //could get dynamically
+
+        //RN: cellbounds.width here is incorrect because it could go past
+        //text width, however there isn't really a reliable way
+        //to get the width of it as the font could be invalid... 
+        //we could try a GetTextExtent here anyways though...
+        //(Note that the neat hack to add an "invisible" 
+        // column here should fix it)
+        if(point.x >= cellbounds.x + buttonsize && 
+           point.x <= cellbounds.x + cellbounds.width)
+        {
+            // assuming every image (normal and selected) has the same size!
+            int image_w, image_h;
+            int image = data->GetImage((wxTreeCtrl*)this, entry);
+            if ( (image != -1) && m_imageListNormal )
+                m_imageListNormal->GetSize(image, image_w, image_h);
+
+            int spacing = GetSpacing();
+            if ((image_w != -1) && 
+                    (point.x <= cellbounds.x + buttonsize + image_w + spacing))
+                (*flags) |= wxTREE_HITTEST_ONITEMICON;
+            else
+                (*flags) |= wxTREE_HITTEST_ONITEMLABEL;
+        }
+        else
+        {   
+            if (point.x <= fullbounds.x + buttonsize && ItemHasChildren(entry))
+                (*flags) |= wxTREE_HITTEST_ONITEMBUTTON;
+            else if (point.x <= cellbounds.x + buttonsize)
+                (*flags) |= wxTREE_HITTEST_ONITEMINDENT;
+            else
+                (*flags) |= wxTREE_HITTEST_ONITEMRIGHT;
+        }
+    }
+
+    return entry;
+}
+
+void wxTreeCtrl::GtkMoveAfter(const wxTreeItemId& cur, 
+                              const wxTreeItemId& next,
+                              const wxTreeItemId& parent, 
+                              const wxTreeItemId& prev)
+{
+#if 0 //GTK_CHECK_VERSION(2, 2, 0)
+    GtkTreeIter itercur, iternext;
+    gtk_tree_model_get_iter(GTK_TREE_MODEL(m_treestore), 
+                            &itercur,
+                            GtkItemEntryData(cur)->path);
+    gtk_tree_model_get_iter(GTK_TREE_MODEL(m_treestore), 
+                            &iternext,
+                            GtkItemEntryData(next)->path);
+
+
+    gtk_tree_store_move_after(m_treestore, &itercur, &iternext); //2.2+ only
+
+    GtkRecalcPaths(next, parent, prev);
+#else //2.2.0+
+    wxGTKTreeCopier copier(this, cur);
+    g_object_ref(G_OBJECT(cur.m_pItem));
+    m_blockEvent = true;
+    Delete(cur);
+    m_blockEvent = false;
+    GtkInsertItem(parent, next, wxT(""), -1, -1, NULL, true, 
+                  GTK_TREE_ENTRY(cur.m_pItem));    
+    copier.InsertCopy(this, cur);
+    GtkRecalcPaths(next, parent, prev);
+#endif
+}
+
+bool wxTreeCtrl::GtkIsValidItem(const wxTreeItemId& item) const
+{
+    return GTK_IS_TREE_ENTRY(item.m_pItem) && !GtkIsFakeItem(item);
+}
+
+bool wxTreeCtrl::GtkIsFakeItem(const wxTreeItemId& item) const
+{
+    return item == m_separator || item == m_fakechild;
+}
+
+bool wxTreeCtrl::GtkIsVirtualRoot(const wxTreeItemId& item) const
+{
+    return item == m_root && HasFlag(wxTR_HIDE_ROOT);
+}
+
+wxTreeItemId wxTreeCtrl::GtkRealFirstChild(const wxTreeItemId& item) const
+{
+    GtkTreeIter iter;
+    GtkTreeIter iterparent;
+    gtk_tree_model_get_iter(GTK_TREE_MODEL(m_treestore),
+                            &iterparent,
+                            GtkItemEntryData(item)->path);
+    if(!gtk_tree_model_iter_children(GTK_TREE_MODEL(m_treestore),
+                                     &iter,&iterparent))
+        return wxTreeItemId();
+    return GtkIterEntry(&iter);
+}
+
+// ----------------------------------------------------------------------------
+// helpers
+// ----------------------------------------------------------------------------
+
+#if wxUSE_TOOLTIPS
+void wxTreeCtrl::ApplyToolTip( GtkTooltips *tips, const wxChar *tip )
+{
+    gtk_tooltips_set_tip( tips, GTK_WIDGET( m_treeview ), 
+                          wxConvCurrent->cWX2MB(tip), (gchar*) NULL );
+}
+#endif // wxUSE_TOOLTIPS
+
+GtkWidget *wxTreeCtrl::GetConnectWidget()
+{ //RN: This is needed because m_widget is a scrollwindow...
+    return GTK_WIDGET(m_treeview);
+}
+
+bool wxTreeCtrl::IsOwnGtkWindow( GdkWindow *window )
+{ 
+    return window == gtk_tree_view_get_bin_window(m_treeview);
+}
+
+void wxTreeCtrl::DoApplyWidgetStyle(GtkRcStyle *style)
+{
+    if (m_hasBgCol && m_backgroundColour.Ok())
+    {
+        GdkWindow *window = GTK_WIDGET(m_treeview)->window;
+        if ( window )
+        {
+            m_backgroundColour.CalcPixel( gdk_window_get_colormap( window ) );
+            gdk_window_set_background( window, m_backgroundColour.GetColor() );
+            gdk_window_clear( window );
+        }
+    }
+
+    gtk_widget_modify_style( GTK_WIDGET(m_treeview), style );
+}
+
+void wxTreeCtrl::OnInternalIdle()
+{
+    wxCursor cursor = m_cursor;
+    if (g_globalCursor.Ok()) cursor = g_globalCursor;
+
+    if (GTK_WIDGET(m_treeview)->window && cursor.Ok())
+    {
+        /* I now set the cursor the anew in every OnInternalIdle call
+           as setting the cursor in a parent window also effects the
+           windows above so that checking for the current cursor is
+           not possible. */
+
+        gdk_window_set_cursor( GTK_WIDGET(m_treeview)->window, 
+                               cursor.GetCursor() );
+    }
+
+    if (wxUpdateUIEvent::CanUpdate(this))
+        UpdateWindowUI(wxUPDATE_UI_FROMIDLE);
+}
+
+// static
+wxVisualAttributes
+wxTreeCtrl::GetClassDefaultAttributes(wxWindowVariant WXUNUSED(variant))
+{
+    return GetDefaultAttributesFromGTKWidget(gtk_tree_view_new, true);
+}
+
+#endif //wxUSE_TREECTRL
diff -bu2rN wxOld/src/gtk/treegtk.cpp wxWidgets/src/gtk/treegtk.cpp
--- wxOld/src/gtk/treegtk.cpp	2006-03-12 10:39:57.000000000 -0800
+++ wxWidgets/src/gtk/treegtk.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,926 +0,0 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        treectrl.cpp
-// Purpose:     wxTreeCtrl
-// Author:      Denis Pershin
-// Modified by:
-// Created:     07/05/98
-// RCS-ID:      $Id: treegtk.cpp,v 1.13 2006/02/03 23:39:48 MR Exp $
-// Copyright:   (c) Denis Pershin
-// Licence:     wxWindows licence
-/////////////////////////////////////////////////////////////////////////////
-
-// For compilers that support precompilation, includes "wx.h".
-#include "wx/wxprec.h"
-
-#ifdef __BORLANDC__
-#pragma hdrstop
-#endif
-
-#ifndef WX_PRECOMP
-#include "wx/wx.h"
-#endif
-
-#include "wx/gtk/treectrl.h"
-#include "wx/textctrl.h"
-#include "wx/log.h"
-
-#include <gtk/gtk.h>
-
-//static void wxConvertToGtkTreeItem(wxTreeCtrl *owner, wxTreeItem& info, GtkTreeItem **gtkItem);
-//static void wxConvertFromGtkTreeItem(wxTreeItem& info, GtkTreeItem *gtkItem);
-
-static void gtk_treectrl_count_callback (GtkWidget *widget, gpointer data);
-static void gtk_treectrl_first_selected_callback(GtkWidget *widget, gpointer data);
-static void gtk_treectrl_first_visible_callback(GtkWidget *widget, gpointer data);
-
-// static void gtk_treectrl_next_callback (GtkWidget *widget, gpointer data);
-// static void gtk_treectrl_next_visible_callback (GtkWidget *widget, gpointer data);
-// static void gtk_treectrl_next_selected_callback (GtkWidget *widget, gpointer data);
-
-static void gtk_treeitem_expand_callback(GtkWidget *widget, wxTreeItemId *treeitem);
-static void gtk_treeitem_collapse_callback(GtkWidget *widget, wxTreeItemId *treeitem);
-static void gtk_treeitem_select_callback(GtkWidget *widget, wxTreeItemId *treeitem);
-
-static void gtk_treeitem_expand_callback(GtkWidget *widget, wxTreeItemId *treeitem) {
-  wxTreeCtrl *owner = (wxTreeCtrl *)gtk_object_get_data(GTK_OBJECT(widget), "owner");
-  if (owner == NULL)
-    return;
-
-//  long id = (long)gtk_object_get_data(GTK_OBJECT(widget), "id");
-  owner->SendExpanding(GTK_TREE_ITEM(widget));
-  owner->SendExpanded(GTK_TREE_ITEM(widget));
-};
-
-static void gtk_treeitem_collapse_callback(GtkWidget *widget, wxTreeItemId *treeitem) {
-  wxTreeCtrl *owner = (wxTreeCtrl *)gtk_object_get_data(GTK_OBJECT(widget), "owner");
-  if (owner == NULL)
-    return;
-
-//  long id = (long)gtk_object_get_data(GTK_OBJECT(widget), "id");
-  owner->SendCollapsing(GTK_TREE_ITEM(widget));
-  owner->SendCollapsed(GTK_TREE_ITEM(widget));
-};
-
-static void gtk_treeitem_select_callback(GtkWidget *widget, wxTreeItemId *treeitem) {
-  wxTreeCtrl *owner = (wxTreeCtrl *)gtk_object_get_data(GTK_OBJECT(widget), "owner");
-  if (owner == NULL)
-    return;
-
-//  long id = (long)gtk_object_get_data(GTK_OBJECT(widget), "id");
-  owner->SendSelChanging(GTK_TREE_ITEM(widget));
-  owner->SendSelChanged(GTK_TREE_ITEM(widget));
-}
-
-IMPLEMENT_DYNAMIC_CLASS(wxTreeCtrl, wxControl)
-
-
-void wxTreeCtrl::Init() {
-  m_imageListNormal = NULL;
-  m_imageListState = NULL;
-  m_textCtrl = NULL;
-}
-
-bool wxTreeCtrl::Create(wxWindow *parent, wxWindowID id, const wxPoint& pos,
-                        const wxSize& size, long style,
-                        const wxValidator& validator, const wxString& name) {
-  Init();
-
-  int x = pos.x;
-  int y = pos.y;
-  int width = size.x;
-  int height = size.y;
-
-  m_windowStyle = style;
-
-  SetParent(parent);
-
-  if (width <= 0)
-    width = 100;
-  if (height <= 0)
-    height = 30;
-  if (x < 0)
-    x = 0;
-  if (y < 0)
-    y = 0;
-
-  m_needParent = TRUE;
-
-printf("precreate\n");
-  PreCreation( parent, id, pos, size, style, name );
-
-printf("1\n");
-
-  m_widget = gtk_scrolled_window_new(NULL, NULL);
-printf("2\n");
-  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(m_widget),
-      GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
-
-printf("3\n");
-  m_tree = GTK_TREE(gtk_tree_new());
-
-printf("4\n");
-  gtk_container_add(GTK_CONTAINER(m_widget), GTK_WIDGET(m_tree));
-printf("5\n");
-  gtk_widget_show(GTK_WIDGET(m_tree));
-
-  SetName(name);
-  SetValidator(validator);
-
-printf("Robert's new insertion code :-)\n");
-  m_parent->DoAddChild( this );
-printf("postcreate\n");
-  PostCreation();
-
-  gtk_widget_realize(GTK_WIDGET(m_tree));
-
-  Show(TRUE);
-
-  return TRUE;
-}
-
-wxTreeCtrl::~wxTreeCtrl(void) {
-  if (m_textCtrl)
-    delete m_textCtrl;
-}
-
-// Attributes
-static void gtk_treectrl_count_callback (GtkWidget *widget, gpointer data) {
-  int count = (*((int *)data));
-
-  count++;
-  if (GTK_IS_CONTAINER(widget))
-    gtk_container_foreach(GTK_CONTAINER(widget), gtk_treectrl_count_callback, data);
-}
-
-size_t wxTreeCtrl::GetCount() const {
-  int count = 0;
-
-  if (m_anchor != NULL)
-    gtk_treectrl_count_callback(GTK_WIDGET(m_anchor), &count);
-  return count;
-}
-
-unsigned int wxTreeCtrl::GetIndent() const {
-  return m_tree->indent_value;
-}
-
-void wxTreeCtrl::SetIndent(unsigned int indent) {
-  m_tree->indent_value = indent;
-}
-
-wxImageList *wxTreeCtrl::GetImageList() const {
-  return m_imageListNormal;
-}
-
-wxImageList *wxTreeCtrl::GetStateImageList() const {
-  return m_imageListState;
-}
-
-void wxTreeCtrl::SetImageList(wxImageList *imageList) {
-  m_imageListNormal = imageList;
-}
-
-void wxTreeCtrl::SetStateImageList(wxImageList *imageList) {
-  m_imageListState = imageList;
-}
-
-wxString wxTreeCtrl::GetItemText(const wxTreeItemId &item) const {
-  char *t;
-
-  if (!item.IsOk())
-    return wxString("");
-
-  GtkLabel *l = GTK_LABEL(gtk_object_get_data(GTK_OBJECT((GtkTreeItem *)item), "w_label"));
-  gtk_label_get(l, &t);
-
-  return t;
-}
-
-int wxTreeCtrl::GetItemImage(const wxTreeItemId& item) const {
-  if (!item.IsOk())
-    return (-1);
-
-  return (int)gtk_object_get_data(GTK_OBJECT((GtkTreeItem *)item), "image");
-}
-
-int wxTreeCtrl::GetItemSelectedImage(const wxTreeItemId& item) const {
-  if (!item.IsOk())
-    return (-1);
-
-  return (int)gtk_object_get_data(GTK_OBJECT((GtkTreeItem *)item), "selectedImage");
-}
-
-wxTreeItemData *wxTreeCtrl::GetItemData(const wxTreeItemId& item) const {
-  if (!item.IsOk())
-    return NULL;
-
-  return (wxTreeItemData *)gtk_object_get_data(GTK_OBJECT((GtkTreeItem *)item), "data");
-}
-
-void wxTreeCtrl::SetItemText(const wxTreeItemId& item, const wxString& text) {
-  if (!item.IsOk())
-    return;
-
-  GtkLabel *l = GTK_LABEL(gtk_object_get_data(GTK_OBJECT((GtkTreeItem *)item), "w_label"));
-  gtk_label_set_text(l, text);
-}
-
-void wxTreeCtrl::SetItemImage(const wxTreeItemId& item, int image) {
-  if (!item.IsOk())
-    return;
-
-  gtk_object_set_data(GTK_OBJECT((GtkTreeItem *)item), "image", (void *)image);
-}
-
-void wxTreeCtrl::SetItemSelectedImage(const wxTreeItemId& item, int image) {
-  if (!item.IsOk())
-    return;
-
-  gtk_object_set_data(GTK_OBJECT((GtkTreeItem *)item), "selectedImage", (void *)image);
-}
-
-void wxTreeCtrl::SetItemData(const wxTreeItemId& item, wxTreeItemData *data) {
-  if (!item.IsOk())
-    return;
-
-  gtk_object_set_data(GTK_OBJECT((GtkTreeItem *)item), "data", data);
-}
-
-bool wxTreeCtrl::IsVisible(const wxTreeItemId& item) const {
-  return GTK_WIDGET_VISIBLE(GTK_TREE_ITEM((GtkTreeItem *)item));
-}
-
-bool wxTreeCtrl::ItemHasChildren(const wxTreeItemId& item) const {
-  GtkTreeItem *p = (GtkTreeItem *)item;
-
-  if (p->subtree == NULL)
-    return wxFalse;
-
-  if (GTK_TREE(p->subtree)->children == NULL)
-    return wxFalse;
-
-  if (g_list_length(GTK_TREE(p->subtree)->children) == 0)
-    return wxFalse;
-
-  return wxTrue;
-}
-
-bool wxTreeCtrl::IsExpanded(const wxTreeItemId& item) const {
-  return (((GtkTreeItem *)item)->expanded != 0);
-}
-
-bool wxTreeCtrl::IsSelected(const wxTreeItemId& item) const {
-  GtkTreeItem *p = (GtkTreeItem *)item;
-  GtkWidget *parent = GTK_WIDGET(p)->parent;
-
-  if (!GTK_IS_TREE(parent))
-    return wxFalse;
-
-  if (g_list_index(GTK_TREE(parent)->children, p) == -1)
-    return wxFalse;
-
-  return wxTrue;
-}
-
-wxTreeItemId wxTreeCtrl::GetRootItem() const {
-  return m_anchor;
-}
-
-static void gtk_treectrl_first_selected_callback(GtkWidget *widget, gpointer data) {
-  GtkTreeItem *p = (*((GtkTreeItem **)data));
-
-  GtkTree *tree = GTK_TREE(GTK_TREE_ITEM(widget)->subtree);
-
-  if (tree->selection != NULL) {
-    p = (GtkTreeItem *)tree->selection->data;
-    return;
-  }
-
-  if (GTK_IS_CONTAINER(widget))
-    gtk_container_foreach(GTK_CONTAINER(widget), gtk_treectrl_first_selected_callback, data);
-}
-
-wxTreeItemId wxTreeCtrl::GetSelection() const {
-  GtkTreeItem *p = NULL;
-
-  if (m_anchor == NULL)
-    return NULL;
-
-  gtk_treectrl_first_selected_callback(GTK_WIDGET(m_anchor), &p);
-
-  return p;
-}
-
-wxTreeItemId wxTreeCtrl::GetItemParent(const wxTreeItemId& item) const {
-  if (item.IsOk())
-    return (GtkTreeItem *)gtk_object_get_data(GTK_OBJECT((GtkTreeItem *)item), "parent");
-
-  return NULL;
-}
-
-wxTreeItemId wxTreeCtrl::GetFirstChild(const wxTreeItemId& item, long& cookie) const {
-  GtkTreeItem *p = (GtkTreeItem *)item;
-  GtkWidget *parent = GTK_WIDGET(p)->parent;
-
-  if (!GTK_IS_TREE(parent))
-    return NULL;
-
-  cookie = 0;
-  return GTK_TREE_ITEM(g_list_first(GTK_TREE(parent)->children)->data);
-}
-
-wxTreeItemId wxTreeCtrl::GetNextChild(const wxTreeItemId& item, long& cookie) const {
-  GtkTreeItem *p = (GtkTreeItem *)item;
-  GtkWidget *parent = GTK_WIDGET(p)->parent;
-
-  if (!GTK_IS_TREE(parent))
-    return NULL;
-
-  cookie++;
-  return GTK_TREE_ITEM(g_list_nth(GTK_TREE(parent)->children, cookie)->data);
-}
-
-wxTreeItemId wxTreeCtrl::GetLastChild(const wxTreeItemId& item) const
-{
-  GtkTreeItem *p = (GtkTreeItem *)item;
-  GtkWidget *parent = GTK_WIDGET(p)->parent;
-
-  wxCHECK_MSG( GTK_IS_TREE(parent), NULL, "invalid tree item" );
-
-  return GTK_TREE_ITEM(g_list_last(GTK_TREE(parent)->children)->data);
-}
-
-wxTreeItemId wxTreeCtrl::GetNextSibling(const wxTreeItemId& item) const {
-  GtkTreeItem *p = (GtkTreeItem *)item;
-  GtkWidget *parent = GTK_WIDGET(p)->parent;
-
-  if (!GTK_IS_TREE(parent))
-    return NULL;
-
-  if (g_list_index(GTK_TREE(parent)->children, p) == -1)
-    return NULL;
-
-  return GTK_TREE_ITEM(g_list_next(g_list_find(GTK_TREE(parent)->children, p))->data);
-}
-
-wxTreeItemId wxTreeCtrl::GetPrevSibling(const wxTreeItemId& item) const {
-  GtkTreeItem *p = (GtkTreeItem *)item;
-  GtkWidget *parent = GTK_WIDGET(p)->parent;
-
-  if (!GTK_IS_TREE(parent))
-    return NULL;
-
-  if (g_list_index(GTK_TREE(parent)->children, p) == -1)
-    return NULL;
-
-  return GTK_TREE_ITEM(g_list_previous(g_list_find(GTK_TREE(parent)->children, p))->data);
-}
-
-static void gtk_treectrl_first_visible_callback(GtkWidget *widget, gpointer data) {
-  GtkTreeItem *p = (*((GtkTreeItem **)data));
-
-  GtkTree *tree = GTK_TREE(GTK_TREE_ITEM(widget)->subtree);
-
-  if (tree->children != NULL) {
-    guint len = g_list_length(tree->children);
-    for (guint i=0; i<len; i++) {
-      if (GTK_WIDGET_VISIBLE(GTK_WIDGET(GTK_TREE_ITEM((GtkTreeItem *)g_list_nth(tree->children, i)->data)))) {
-        p = GTK_TREE_ITEM((GtkTreeItem *)g_list_nth(tree->children, i)->data);
-        return;
-      }
-    }
-  }
-
-  if (GTK_IS_CONTAINER(widget))
-    gtk_container_foreach(GTK_CONTAINER(widget), gtk_treectrl_first_visible_callback, data);
-}
-
-wxTreeItemId wxTreeCtrl::GetFirstVisibleItem() const {
-  GtkTreeItem *p = NULL;
-
-  if (m_anchor == NULL)
-    return NULL;
-
-  gtk_treectrl_first_visible_callback(GTK_WIDGET(m_anchor), &p);
-
-  return p;
-}
-
-wxTreeItemId wxTreeCtrl::GetNextVisible(const wxTreeItemId& item) const {
-  GtkTreeItem *p = (GtkTreeItem *)item;
-  GtkTree *parent = GTK_TREE(GTK_WIDGET(p)->parent);
-  GtkTreeItem *q;
-
-  if (!GTK_IS_TREE(parent))
-    return NULL;
-
-  if (parent->children == NULL)
-    return NULL;
-
-  q = GTK_TREE_ITEM(g_list_next(g_list_find(GTK_TREE(parent)->children, p))->data);
-
-  while (q != p) {
-    q = GTK_TREE_ITEM(g_list_next(g_list_find(GTK_TREE(parent)->children, q))->data);
-    if (GTK_WIDGET_VISIBLE(GTK_WIDGET(q)))
-      return q;
-  }
-
-  return NULL;
-}
-
-wxTreeItemId wxTreeCtrl::GetPrevVisible(const wxTreeItemId& item) const {
-  GtkTreeItem *p = (GtkTreeItem *)item;
-  GtkTree *parent = GTK_TREE(GTK_WIDGET(p)->parent);
-  GtkTreeItem *q;
-
-  if (!GTK_IS_TREE(parent))
-    return NULL;
-
-  if (parent->children == NULL)
-    return NULL;
-
-  q = GTK_TREE_ITEM(g_list_previous(g_list_find(GTK_TREE(parent)->children, p))->data);
-
-  while (q != p) {
-    q = GTK_TREE_ITEM(g_list_previous(g_list_find(GTK_TREE(parent)->children, q))->data);
-    if (GTK_WIDGET_VISIBLE(GTK_WIDGET(q)))
-      return q;
-  }
-
-  return NULL;
-}
-
-wxTreeItemId wxTreeCtrl::AddRoot(const wxString& text, int image,
-                     int selectedImage, wxTreeItemData *data) {
-  return p_InsertItem(0, text, image, selectedImage, data);
-}
-
-wxTreeItemId wxTreeCtrl::PrependItem(const wxTreeItemId& parent,
-                         const wxString& text, int image, int selectedImage,
-                         wxTreeItemData *data) {
-#warning "Need to implement PrependItem"
-  return NULL;
-}
-
-wxTreeItemId wxTreeCtrl::InsertItem(const wxTreeItemId& parent,
-                        const wxTreeItemId& idPrevious, const wxString& text,
-                        int image, int selectedImage, wxTreeItemData *data) {
-#warning "Need to implement InsertItem"
-  return NULL;
-}
-
-wxTreeItemId wxTreeCtrl::AppendItem(const wxTreeItemId& parent,
-                        const wxString& text, int image, int selectedImage,
-                        wxTreeItemData *data) {
-  return p_InsertItem(parent, text, image, selectedImage, data);
-}
-
-wxTreeItemId wxTreeCtrl::p_InsertItem(GtkTreeItem *p,
-                        const wxString& text, int image, int selectedImage,
-                        wxTreeItemData *data) {
-  GtkTreeItem *item;
-
-printf("begin insert\n");
-
-  item = GTK_TREE_ITEM(gtk_tree_item_new());
-
-  GtkHBox *m_box = GTK_HBOX(gtk_hbox_new(FALSE, 0));
-  gtk_container_add (GTK_CONTAINER (item), GTK_WIDGET(m_box));
-
-  gtk_object_set_data(GTK_OBJECT(item), "w_box", m_box);
-
-  const wxBitmap *bmp;
-  const wxImageList *list;
-  if ((list = GetImageList(wxIMAGE_LIST_NORMAL)) != NULL)
-    if ((bmp = list->GetBitmapPtr(image)) != NULL)
-      if (bmp->Ok()) {
-        GdkBitmap *mask = NULL;
-        if (bmp->GetMask())
-          mask = bmp->GetMask()->GetBitmap();
-        GtkPixmap *m_image_widget = GTK_PIXMAP(gtk_pixmap_new(bmp->GetPixmap(), mask));
-        gtk_misc_set_alignment (GTK_MISC (m_image_widget), 0.0, 0.5);
-        gtk_box_pack_start(GTK_BOX(m_box), GTK_WIDGET(m_image_widget), FALSE, FALSE, 0);
-        gtk_object_set_data(GTK_OBJECT(item), "w_image", (void *)m_image_widget);
-        gtk_object_set_data(GTK_OBJECT(item), "image", (void *)image);
-        gtk_widget_show (GTK_WIDGET(m_image_widget));
-      }
-  GtkLabel *m_label_widget = GTK_LABEL(gtk_label_new ((char *)(const char *)text));
-  gtk_misc_set_alignment (GTK_MISC (m_label_widget), 0.5, 0.5);
-  gtk_box_pack_start(GTK_BOX(m_box), GTK_WIDGET(m_label_widget), FALSE, FALSE, 0);
-  gtk_object_set_data(GTK_OBJECT(item), "w_label", m_label_widget);
-  gtk_widget_show (GTK_WIDGET(m_label_widget));
-
-  gtk_widget_show(GTK_WIDGET(m_box));
-
-  gtk_object_set_data(GTK_OBJECT(item), "owner", this);
-  gtk_object_set_data(GTK_OBJECT(item), "data", data);
-  gtk_object_set_data(GTK_OBJECT(item), "parent", p);
-
-  if (p != 0) {
-    if (p->subtree == NULL) {
-      GtkTree *tree = GTK_TREE(gtk_tree_new());
-      gtk_tree_item_set_subtree(GTK_TREE_ITEM(p), GTK_WIDGET(tree));
-      gtk_widget_show(GTK_WIDGET(tree));
-      p->expanded = 1;
-    }
-
-    gtk_container_add(GTK_CONTAINER(p->subtree), GTK_WIDGET(item));
-  } else {
-printf("Adding root\n");
-printf("m_tree = %p\n", m_tree);
-    m_anchor = item;
-    gtk_container_add(GTK_CONTAINER(m_tree), GTK_WIDGET(item));
-  }
-
-  gtk_widget_show(GTK_WIDGET(item));
-
-  g_signal_connect (item, "select",
-                    G_CALLBACK (gtk_treeitem_select_callback), this);
-  g_signal_connect (item, "deselect",
-                    G_CALLBACK (gtk_treeitem_select_callback), this);
-  g_signal_connect (item, "expand",
-                    G_CALLBACK (gtk_treeitem_expand_callback), this);
-  g_signal_connect (item, "collapse",
-                    G_CALLBACK (gtk_treeitem_collapse_callback), this);
-
-  return item;
-}
-
-void wxTreeCtrl::Delete(const wxTreeItemId& item) {
-  if (!item.IsOk())
-    return;
-
-  GtkTreeItem *parent = GTK_TREE_ITEM(GTK_WIDGET((GtkTreeItem *)item)->parent);
-  if (parent == NULL)
-    return;
-
-  gtk_container_remove(GTK_CONTAINER(parent), GTK_WIDGET((GtkTreeItem *)item));
-
-  return;
-}
-
-void wxTreeCtrl::DeleteAllItems() {
-  gtk_tree_item_remove_subtree(m_anchor);
-}
-
-void wxTreeCtrl::Expand(const wxTreeItemId& item) {
-  if (!item.IsOk())
-    return;
-
-  gtk_tree_item_expand(GTK_TREE_ITEM((GtkTreeItem *)item));
-}
-
-void wxTreeCtrl::Collapse(const wxTreeItemId& item) {
-  if (!item.IsOk())
-    return;
-
-  gtk_tree_item_collapse(GTK_TREE_ITEM((GtkTreeItem *)item));
-}
-
-void wxTreeCtrl::CollapseAndReset(const wxTreeItemId& item) {
-  if (!item.IsOk())
-    return;
-
-  gtk_tree_item_collapse(GTK_TREE_ITEM((GtkTreeItem *)item));
-  gtk_tree_item_remove_subtree(GTK_TREE_ITEM((GtkTreeItem *)item));
-}
-
-void wxTreeCtrl::Toggle(const wxTreeItemId& item) {
-  if (!item.IsOk())
-    return;
-
-  if (((GtkTreeItem *)item)->expanded)
-    gtk_tree_item_collapse(GTK_TREE_ITEM((GtkTreeItem *)item));
-  else
-    gtk_tree_item_expand(GTK_TREE_ITEM((GtkTreeItem *)item));
-}
-
-static void gtk_treectrl_unselect_callback(GtkWidget *widget, gpointer data) {
-  GtkTreeItem *p;
-
-  GtkTree *tree = GTK_TREE(GTK_TREE_ITEM(widget)->subtree);
-
-  if (tree->selection != NULL) {
-    guint len = g_list_length(tree->selection);
-    for (guint i=0; i<len; i++) {
-      p = GTK_TREE_ITEM((GtkTreeItem *)g_list_nth(tree->selection, i)->data);
-      gtk_tree_unselect_child(tree, GTK_WIDGET(p));
-    }
-  }
-
-  if (GTK_IS_CONTAINER(widget))
-    gtk_container_foreach(GTK_CONTAINER(widget), gtk_treectrl_unselect_callback, data);
-}
-
-void wxTreeCtrl::Unselect() {
-  if (m_anchor == NULL)
-    return;
-
-  gtk_treectrl_unselect_callback(GTK_WIDGET(m_anchor), NULL);
-}
-
-void wxTreeCtrl::SelectItem(const wxTreeItemId& item) {
-  if (!item.IsOk())
-    return;
-
-  gtk_tree_item_select((GtkTreeItem *)item);
-}
-
-void wxTreeCtrl::EnsureVisible(const wxTreeItemId& item) {
-#warning "Need to implement EnsureVisible"
-}
-
-void wxTreeCtrl::ScrollTo(const wxTreeItemId& item) {
-#warning "Need to implement ScrollTo"
-}
-
-wxTextCtrl* wxTreeCtrl::EditLabel(const wxTreeItemId& item,
-                          wxClassInfo* textControlClass) {
-    wxASSERT( textControlClass->IsKindOf(CLASSINFO(wxTextCtrl)) );
-#warning "Need to implement EditLabel"
-/*
-  char *s;
-  m_editItem = item;
-
-  GtkLabel *m_label = (GtkLabel *)gtk_object_get_data(GTK_OBJECT((GtkTreeItem *)item), "w_label");
-  gtk_label_get(m_label, &s);
-
-  m_textCtrl = new wxTextCtrl(this, -1, s);
-//  m_textCtrl->SetValue(s);
-
-  gtk_object_set_data(GTK_OBJECT((GtkTreeItem *)item), "w_edit", m_textCtrl->m_widget);
-
-  gtk_container_remove(GTK_CONTAINER((GtkTreeItem *)item), GTK_WIDGET(m_label));
-  gtk_container_add(GTK_CONTAINER((GtkTreeItem *)item), m_textCtrl->m_widget);
-
-*/
-  return m_textCtrl;
-}
-
-wxTextCtrl* wxTreeCtrl::GetEditControl() const {
-  return m_textCtrl;
-}
-
-void wxTreeCtrl::EndEditLabel(const wxTreeItemId& item, bool discardChanges) {
-#warning "Need to implement EndEditLabel"
-/*
-  GtkLabel *m_label = (GtkLabel *)gtk_object_get_data(GTK_OBJECT((GtkTreeItem *)m_editItem), "w_label");
-  gtk_label_set_text(m_label, m_textCtrl->GetValue());
-
-  gtk_object_remove_data(GTK_OBJECT((GtkTreeItem *)m_editItem), "w_edit");
-
-  gtk_container_remove(GTK_CONTAINER((GtkTreeItem *)m_editItem), m_textCtrl->m_widget);
-  gtk_container_add(GTK_CONTAINER((GtkTreeItem *)m_editItem), GTK_WIDGET(m_label));
-
-  delete m_textCtrl;
-  m_textCtrl = NULL;
-*/
-}
-
-void wxTreeCtrl::ExpandItem(const wxTreeItemId& item, int action) {
-  switch (action) {
-    case wxTREE_EXPAND_EXPAND:
-      Expand(item);
-      break;
-
-    case wxTREE_EXPAND_COLLAPSE:
-      Collapse(item);
-      break;
-
-    case wxTREE_EXPAND_COLLAPSE_RESET:
-      CollapseAndReset(item);
-      break;
-
-    case wxTREE_EXPAND_TOGGLE:
-      Toggle(item);
-      break;
-
-    default:
-      wxFAIL_MSG("unknown action in wxTreeCtrl::ExpandItem");
-  }
-}
-
-wxTreeItemId wxTreeCtrl::InsertItem(const wxTreeItemId& parent,
-                            const wxString& text, int image, int selImage,
-                            long insertAfter) {
-//  InsertItem(parent, insertAfter, text, image, selImage);
-  #warning "Need to implement InsertItem"
-  return NULL;
-}
-
-/* Old functions
-long wxTreeCtrl::GetChild(long item) const {
-  GtkTreeItem *p;
-  GtkTreeItem *next = NULL;
-
-  p = findGtkTreeItem(item);
-  GList *list = gtk_container_get_children(GTK_CONTAINER(p));
-  next = GTK_TREE_ITEM(list->data);
-
-  if (next != NULL)
-    return (long)gtk_object_get_data(GTK_OBJECT(next), "id");
-
-  return (-1);
-}
-
-long wxTreeCtrl::GetFirstVisibleItem(void) const {
-  GtkTreeItem *next = NULL;
-
-  GList *list = gtk_container_get_children(GTK_CONTAINER(m_anchor));
-  next = GTK_TREE_ITEM(list->data);
-//  gtk_container_foreach(GTK_CONTAINER(m_anchor), gtk_treectrl_next_visible_callback, &next);
-
-  if (next != NULL)
-    return (long)gtk_object_get_data(GTK_OBJECT(next), "id");
-
-  return (-1);
-}
-
-long wxTreeCtrl::GetNextVisibleItem(long item) const {
-  GtkTreeItem *p;
-  GtkTreeItem *next = NULL;
-
-  p = findGtkTreeItem(item);
-  GList *list = gtk_container_get_children(GTK_CONTAINER(p));
-  next = GTK_TREE_ITEM(list->data);
-//  gtk_container_foreach(GTK_CONTAINER(p), gtk_treectrl_next_visible_callback, &next);
-
-  if (next != NULL)
-    return (long)gtk_object_get_data(GTK_OBJECT(next), "id");
-
-  return (-1);
-}
-
-bool wxTreeCtrl::GetItem(wxTreeItem& info) const {
-  GtkTreeItem *p;
-
-  p = findGtkTreeItem(info.m_itemId);
-
-  if (p == NULL) {
-    wxLogSysError("TreeCtrl::GetItem failed");
-    return FALSE;
-  }
-
-  wxConvertFromGtkTreeItem(info, p);
-
-  return TRUE;
-}
-
-bool wxTreeCtrl::SetItem(wxTreeItem& info) {
-  GtkTreeItem *p;
-
-  p = findGtkTreeItem(info.m_itemId);
-
-  if (p == NULL) {
-    wxLogSysError("TreeCtrl::SetItem failed");
-    return FALSE;
-  }
-
-  wxConvertToGtkTreeItem(this, info, &p);
-
-  return TRUE;
-}
-
-int wxTreeCtrl::GetItemState(long item, long stateMask) const {
-  wxTreeItem info;
-
-  info.m_mask = wxTREE_MASK_STATE ;
-  info.m_stateMask = stateMask;
-  info.m_itemId = item;
-
-  if (!GetItem(info))
-    return 0;
-
-  return info.m_state;
-}
-
-bool wxTreeCtrl::SetItemState(long item, long state, long stateMask) {
-  wxTreeItem info;
-
-  info.m_mask = wxTREE_MASK_STATE ;
-  info.m_state = state;
-  info.m_stateMask = stateMask;
-  info.m_itemId = item;
-
-  return SetItem(info);
-}
-*/
-
-// Operations
-/*
-bool wxTreeCtrl::DeleteChildren(long item) {
-  GtkTreeItem *p;
-
-  p = findGtkTreeItem(item);
-  if (p == NULL)
-    return FALSE;
-
-  gtk_tree_item_remove_subtree(GTK_TREE_ITEM(p));
-
-  return TRUE;
-}
-*/
-
-/*
-long wxTreeCtrl::InsertItem(long parent, wxTreeItem& info, long insertAfter) {
-  GtkTreeItem *p;
-  GtkTreeItem *item = NULL;
-
-  info.m_itemId = m_curitemId;
-  m_curitemId++;
-
-  wxConvertToGtkTreeItem(this, info, &item);
-
-  if (parent != 0) {
-    p = findGtkTreeItem(parent);
-    if (p->subtree == NULL) {
-      GtkTree *tree = GTK_TREE(gtk_tree_new());
-      gtk_tree_item_set_subtree(GTK_TREE_ITEM(p), GTK_WIDGET(tree));
-      gtk_widget_show(GTK_WIDGET(tree));
-      p->expanded = 1;
-    }
-
-    gtk_container_add(GTK_CONTAINER(p->subtree), GTK_WIDGET(item));
-  } else {
-    m_anchor = item;
-    gtk_container_add(GTK_CONTAINER(m_tree), GTK_WIDGET(item));
-  }
-
-  if ((info.m_mask & wxTREE_MASK_CHILDREN) != 0) {
-    GtkTree *tree = GTK_TREE(gtk_tree_new());
-    gtk_tree_item_set_subtree(GTK_TREE_ITEM(item), GTK_WIDGET(tree));
-    gtk_widget_show(GTK_WIDGET(tree));
-  }
-
-  gtk_widget_show(GTK_WIDGET(item));
-
-  g_signal_connect (item, "select",
-                    G_CALLBACK (gtk_treeitem_select_callback), this);
-  g_signal_connect (item, "deselect",
-                    G_CALLBACK (gtk_treeitem_select_callback), this);
-  g_signal_connect (item, "expand",
-                    G_CALLBACK (gtk_treeitem_expand_callback), this);
-  g_signal_connect (item, "collapse",
-                    G_CALLBACK (gtk_treeitem_collapse_callback), this);
-
-  return info.m_itemId;
-}
-
-long wxTreeCtrl::InsertItem(long parent, const wxString& label, int image,
-  int selImage, long insertAfter) {
-
-  wxTreeItem info;
-  info.m_text = label;
-  info.m_mask = wxTREE_MASK_TEXT;
-  if (image > -1) {
-    info.m_mask |= wxTREE_MASK_IMAGE | wxTREE_MASK_SELECTED_IMAGE;
-    info.m_image = image;
-    if (selImage == -1)
-      info.m_selectedImage = image;
-    else
-      info.m_selectedImage = selImage;
-  }
-
-  return InsertItem(parent, info, insertAfter);
-}
-*/
-
-void wxTreeCtrl::SendMessage(wxEventType command, const wxTreeItemId& item) {
-  wxTreeEvent event(command, GetId());
-  event.SetEventObject(this);
-  event.m_item = item;
-  ProcessEvent(event);
-}
-
-void wxTreeCtrl::SendExpanding(const wxTreeItemId& item) {
-  SendMessage(wxEVT_COMMAND_TREE_ITEM_EXPANDING, item);
-}
-
-void wxTreeCtrl::SendExpanded(const wxTreeItemId& item) {
-  SendMessage(wxEVT_COMMAND_TREE_ITEM_EXPANDED, item);
-}
-
-void wxTreeCtrl::SendCollapsing(const wxTreeItemId& item) {
-  SendMessage(wxEVT_COMMAND_TREE_ITEM_COLLAPSING, item);
-}
-
-void wxTreeCtrl::SendCollapsed(const wxTreeItemId& item) {
-  SendMessage(wxEVT_COMMAND_TREE_ITEM_COLLAPSED, item);
-}
-
-void wxTreeCtrl::SendSelChanging(const wxTreeItemId& item) {
-  SendMessage(wxEVT_COMMAND_TREE_SEL_CHANGED, item);
-}
-
-void wxTreeCtrl::SendSelChanged(const wxTreeItemId& item) {
-  SendMessage(wxEVT_COMMAND_TREE_SEL_CHANGING, item);
-}
-
-// Tree event
-IMPLEMENT_DYNAMIC_CLASS(wxTreeEvent, wxCommandEvent)
-
-wxTreeEvent::wxTreeEvent(wxEventType commandType, int id):
-  wxCommandEvent(commandType, id) {
-  m_code = 0;
-  m_itemOld = 0;
-}
diff -bu2rN wxOld/src/gtk/window.cpp wxWidgets/src/gtk/window.cpp
--- wxOld/src/gtk/window.cpp	2006-03-12 10:39:57.000000000 -0800
+++ wxWidgets/src/gtk/window.cpp	2006-03-12 12:24:27.000000000 -0800
@@ -2699,4 +2699,6 @@
                                               (gpointer) gtk_window_focus_out_callback,
                                               this);
+
+        m_focusWidget = NULL;
     }
 
@@ -2874,4 +2876,26 @@
 }
 
+void wxWindowGTK::DisconnectWidget( GtkWidget *widget )
+{
+    g_signal_handlers_disconnect_by_func (widget,
+                      (gpointer) gtk_window_key_press_callback, this);
+    g_signal_handlers_disconnect_by_func (widget,
+                      (gpointer) gtk_window_key_release_callback, this);
+    g_signal_handlers_disconnect_by_func (widget,
+                      (gpointer) gtk_window_button_press_callback, this);
+    g_signal_handlers_disconnect_by_func (widget,
+                      (gpointer) gtk_window_button_release_callback, this);
+    g_signal_handlers_disconnect_by_func (widget,
+                      (gpointer) gtk_window_motion_notify_callback, this);
+    g_signal_handlers_disconnect_by_func (widget,
+                      (gpointer) gtk_window_wheel_callback, this);
+    g_signal_handlers_disconnect_by_func (widget,
+                      (gpointer) wxgtk_window_popup_menu_callback, this);
+    g_signal_handlers_disconnect_by_func (widget,
+                      (gpointer) gtk_window_enter_callback, this);
+    g_signal_handlers_disconnect_by_func (widget,
+                      (gpointer) gtk_window_leave_callback, this);
+}
+
 bool wxWindowGTK::Destroy()
 {
@@ -2883,4 +2907,44 @@
 }
 
+void wxWindowGTK::AssociateHandle(GtkWidget* widget) 
+{ 
+    //RN: Note that we need to be especially careful that no 
+    //activate events are sent
+    if(m_widget)
+        DissociateHandle();
+
+    m_widget = widget;
+    ConnectWidget(widget);
+
+    m_focusWidget = m_widget;
+
+    g_signal_connect_after (m_focusWidget, "focus_in_event",
+                            G_CALLBACK (gtk_window_focus_in_callback), this);
+    g_signal_connect_after (m_focusWidget, "focus_out_event",
+                            G_CALLBACK (gtk_window_focus_out_callback), this);  
+
+    m_hasVMT = true;      
+}
+
+void wxWindowGTK::DissociateHandle()
+{
+    m_hasVMT = false;
+
+    if(m_focusWidget)
+    {
+        g_signal_handlers_disconnect_by_func (m_focusWidget,
+                                              (gpointer) gtk_window_focus_in_callback,
+                                              this);
+        g_signal_handlers_disconnect_by_func (m_focusWidget,
+                                              (gpointer) gtk_window_focus_out_callback,
+                                              this);
+
+        m_focusWidget = NULL;
+    }
+
+    DisconnectWidget(m_widget);
+    m_widget = NULL;
+}
+
 void wxWindowGTK::DoMoveWindow(int x, int y, int width, int height)
 {

 	  	 
