Index: include/wx/mac/toolbar.h
===================================================================
RCS file: /home/wxcvs/wxWindows/include/wx/mac/toolbar.h,v
retrieving revision 1.5
diff -r1.5 toolbar.h
7c7
< // RCS-ID:      $Id: toolbar.h,v 1.5 2001/05/29 14:37:43 SC Exp $
---
> // RCS-ID:      $Id: toolbar.h,v 1.4 2000/08/09 11:02:59 SC Exp $
9c9
< // Licence:   	wxWindows licence
---
> // Licence:    wxWindows licence
22c22
< #include "wx/dynarray.h"
---
> #include "wx/scrolbar.h"
28,48c28,52
<   DECLARE_DYNAMIC_CLASS(wxToolBar)
<  public:
<   /*
<    * Public interface
<    */
< 
<    wxToolBar() { Init(); }
< 
< 
<   inline wxToolBar(wxWindow *parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize,
<             long style = wxNO_BORDER|wxTB_HORIZONTAL,
<             const wxString& name = wxToolBarNameStr)
<   {
<     Init();
<     Create(parent, id, pos, size, style, name);
<   }
<   ~wxToolBar();
< 
<   bool Create(wxWindow *parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize,
<             long style = wxNO_BORDER|wxTB_HORIZONTAL,
<             const wxString& name = wxToolBarNameStr);
---
>     DECLARE_DYNAMIC_CLASS(wxToolBar);
>   public:
>     /*
>      * Public interface
>      */
> 
>     wxToolBar() { Init(); }
> 
> 
>     inline wxToolBar(wxWindow *parent, wxWindowID id,
>                      const wxPoint& pos = wxDefaultPosition,
>                      const wxSize& size = wxDefaultSize,
>                      long style = wxNO_BORDER|wxTB_HORIZONTAL,
>                      const wxString& name = wxToolBarNameStr)
>     {
>         Init();
>         Create(parent, id, pos, size, style, name);
>     }
>     virtual ~wxToolBar();
> 
>     bool Create(wxWindow *parent, wxWindowID id,
>                 const wxPoint& pos = wxDefaultPosition,
>                 const wxSize& size = wxDefaultSize,
>                 long style = wxNO_BORDER|wxTB_HORIZONTAL,
>                 const wxString& name = wxToolBarNameStr);
54d57
< 
58c61,77
<     virtual void SetRows(int nRows);
---
>     virtual void SetRows(int nRows) { }  // Does nothing
> 
>     // Add all the buttons
> 
>     virtual void MacHandleControlClick(ControlHandle control,
>                                        SInt16 controlpart ) ;
>     virtual wxString MacGetToolTipString( wxPoint &where ) ;
>     virtual ControlHandle MacGetContainerForEmbedding() const;
> 
>     void OnPaint(wxPaintEvent& event) ;
>     void OnMouse(wxMouseEvent& event) ;
> 
>     void RedrawToolBar() const;
>     void OnScrollToolBar(wxScrollEvent &event);
> 
>     int  ScrollOffsetX() const;
>     int  ScrollOffsetY() const;
60c79
<   // Add all the buttons
---
>     void SetFrameHandledToolBar() { m_frameHandled = true; }
62,67c81
< 	virtual void MacHandleControlClick( ControlHandle control , SInt16 controlpart ) ;
< 	virtual wxString MacGetToolTipString( wxPoint &where ) ;
< 	void OnPaint(wxPaintEvent& event) ;
< 	void OnMouse(wxMouseEvent& event) ;
< 	virtual void MacSuperChangedPosition() ;
< protected:
---
>   protected:
71a86
>     virtual void DoSetSize(int x, int y, int width, int height, int sizeFlags);
88c103,106
< 	wxArrayPtrVoid	m_macToolHandles ;
---
>   private:
>     bool m_frameHandled;
>     wxScrollBar m_scrollbar;
>     int  m_scrollOffset;
90c108
< 	DECLARE_EVENT_TABLE()
---
>     DECLARE_EVENT_TABLE();
96c114
<     // _WX_TOOLBAR_H_
---
> // _WX_TOOLBAR_H_
Index: src/mac/toolbar.cpp
===================================================================
RCS file: /home/wxcvs/wxWindows/src/mac/toolbar.cpp,v
retrieving revision 1.18
diff -r1.18 toolbar.cpp
5c5
< // Modified by:
---
> // Modified by: Mark Newsam
7c7
< // RCS-ID:      $Id: toolbar.cpp,v 1.18 2001/07/14 18:49:06 RR Exp $
---
> // RCS-ID:      $Id: toolbar.cpp,v 1.8 2000/10/06 16:52:28 juliansmart Exp $
15c15
< #include "wx/wx.h"
---
> #include "wx/setup.h"
20,21c20,22
< #include "wx/notebook.h"
< #include "wx/tabctrl.h"
---
> #include "wx/app.h"
> #include "wx/scrolbar.h"
> #include "wx/icon.h"
24c25,28
< IMPLEMENT_DYNAMIC_CLASS(wxToolBar, wxToolBarBase)
---
> IMPLEMENT_DYNAMIC_CLASS(wxToolBar, wxToolBarBase);
> 
> // Scroll bar ID
> #define wxTOOLBAR_SCROLLBAR  5996
27,29c31,34
< 	EVT_MOUSE_EVENTS( wxToolBar::OnMouse ) 
< 	EVT_PAINT( wxToolBar::OnPaint ) 
< END_EVENT_TABLE()
---
>     EVT_MOUSE_EVENTS( wxToolBar::OnMouse )
>     EVT_PAINT( wxToolBar::OnPaint )
>     EVT_COMMAND_SCROLL(wxTOOLBAR_SCROLLBAR, wxToolBar::OnScrollToolBar )
> END_EVENT_TABLE();
33a39,43
> // Constants for toolbar layout
> #define kwxMacToolBarTopMargin   2
> #define kwxMacToolBarLeftMargin  2
> 
> 
40c50
< public:
---
>   public:
48,50c58,139
<                   const wxString& longHelpString)
<         : wxToolBarToolBase(tbar, id, bitmap1, bitmap2, toggle,
<                             clientData, shortHelpString, longHelpString)
---
>                   const wxString& longHelpString);
>     wxToolBarTool(wxToolBar *tbar, wxControl *control);
>     ~wxToolBarTool();
> 
>     void CreateSeparator();
> 
>     void DrawTool() const;
>     void Show(bool show);
> 
>     ControlHandle GetControlHandle() { return m_macHandle; }
> 
>     void SetSize(int x, int y, int w = -1, int h = -1);
>     wxSize GetSize() const;
>     wxPoint GetPosition() const;
>     void UpdatePosition();
> 
>     bool PointInTool(int x, int y) const;
> 
>     void Enable(bool enable);
>     bool Toggle(bool toggle);
>     void Toggle();
> 
>   private:
>     // handle for tool control, if a wxControl this is stored in 
>     // wxToolBarToolBase.
>     ControlHandle m_macHandle;
>     int m_x, m_y;
>     wxIcon m_icon;
> };
> 
> 
> // ============================================================================
> // implementation
> // ============================================================================
> 
> // ----------------------------------------------------------------------------
> // wxToolBarTool
> // ----------------------------------------------------------------------------
> 
> wxToolBarTool::wxToolBarTool(wxToolBar *tbar,
>                              int id,
>                              const wxBitmap& bitmap1,
>                              const wxBitmap& bitmap2,
>                              bool toggle,
>                              wxObject *clientData,
>                              const wxString& shortHelpString,
>                              const wxString& longHelpString)
>     : wxToolBarToolBase(tbar, id, bitmap1, bitmap2, toggle,
>                         clientData, shortHelpString, longHelpString)
> {
>     // First check whether its a button or a separator as both use the
>     // same constructor (They should really be different and not have to
>     // use wxID_SEPARATOR).
>     if( !IsButton() ) {
>         CreateSeparator();
>         return;
>     }
> 
>     WindowPtr window = tbar->GetMacRootWindow();
>     wxSize toolSize  = tbar->GetToolBitmapSize();
>     Rect toolrect    = { 0,0, toolSize.y, toolSize.x };
>     m_x = 0;
>     m_y = 0;
> 
>     m_icon = bitmap1;
> 
>     SInt16 behaviour = kControlBehaviorOffsetContents ;
> 
>     if ( CanBeToggled() ) {
>         behaviour += kControlBehaviorToggles ;
>     }
>     if ( m_icon.Ok() )
>     {
>         ControlButtonContentInfo info ;
> 
>         info.contentType = kControlContentCIconHandle;
>         info.u.cIconHandle = m_icon.GetHICON();
> 
>         CreateBevelButtonControl(window, &toolrect, CFSTR(""), kControlBevelButtonNormalBevelProc,
>                                  behaviour, &info, 0, 0, 0, &m_macHandle);
>     }
>     else
52,53c141,168
<         m_nSepCount = 0;
<         m_index = -1 ;
---
>         CreateBevelButtonControl(window, &toolrect, CFSTR(""), kControlBevelButtonNormalBevelProc,
>                                  behaviour, NULL, 0, 0, 0, &m_macHandle);
>     }
>     SetControlReference(m_macHandle, (long) tbar);
> 
>     ControlFontStyleRec controlstyle;
> 
>     controlstyle.flags = kControlUseFontMask;
>     controlstyle.font  = kControlFontSmallSystemFont;
>     UMASetControlFontStyle( m_macHandle , &controlstyle ) ;
> 
>     ControlHandle container = tbar->MacGetContainerForEmbedding();
>     wxASSERT_MSG( container != NULL , wxT("No valid mac container control") );
>     UMAEmbedControl( m_macHandle , container ) ;
> }
> 
> wxToolBarTool::wxToolBarTool(wxToolBar *tbar, wxControl *control)
>     : wxToolBarToolBase(tbar, control)
> {
>     m_macHandle = 0;
>     m_x = 0;
>     m_y = 0;
> }
> 
> wxToolBarTool::~wxToolBarTool()
> {
>     if(m_macHandle) {
>         UMADisposeControl(m_macHandle);
54a170
> }
56,57c172,185
<     wxToolBarTool(wxToolBar *tbar, wxControl *control)
<         : wxToolBarToolBase(tbar, control)
---
> void wxToolBarTool::CreateSeparator()
> {
>     Rect bounds = {0,0, 20,1};
> 
>     CreateSeparatorControl(m_tbar->GetMacRootWindow(), &bounds, &m_macHandle);
> 
>     ControlHandle container = m_tbar->MacGetContainerForEmbedding();
>     wxASSERT_MSG( container != NULL , wxT("No valid mac container control") );
>     UMAEmbedControl( m_macHandle , container ) ;
> }
> 
> void wxToolBarTool::SetSize(int x,int y, int w, int h)
> {
>     switch(GetStyle())
59,60c187,204
<         m_nSepCount = 1;
<         m_index = -1 ;
---
>      case wxTOOL_STYLE_BUTTON:
>          UMAMoveControl(m_macHandle, x,y);
>          break;
>      case wxTOOL_STYLE_CONTROL:
>          {
>              wxControl *control = GetControl();
> 
>              control->SetSize(x,y, w,h);
>          }
>          break;
>      case wxTOOL_STYLE_SEPARATOR:
>          UMAMoveControl(m_macHandle, x,y);
>          if(m_tbar->GetWindowStyleFlag() & wxTB_VERTICAL) {
>              UMASizeControl(m_macHandle, w,1);
>          }
>          else {
>              UMASizeControl(m_macHandle, 1,h);
>          }
61a206,208
>     m_x = x;
>     m_y = y;
> }
63,66c210,212
<     // set/get the number of separators which we use to cover the space used by
<     // a control in the toolbar
<     void SetSeparatorsCount(size_t count) { m_nSepCount = count; }
<     size_t GetSeparatorsCount() const { return m_nSepCount; }
---
> wxSize wxToolBarTool::GetSize() const
> {
>     wxSize size;
68,71c214,234
<     int		m_index ;
< private:
<     size_t m_nSepCount;
< };
---
>     if(IsButton()) {
>         size = m_tbar->GetToolSize();
>     }
>     else if(IsControl()) {
>         wxControl *control = GetControl();
> 
>         size = control->GetSize();
>     }
>     else    // Otherwise assume Separator
>     {
>         if(m_tbar->GetWindowStyleFlag() & wxTB_VERTICAL) {
>             size.y = m_tbar->GetToolPacking() + 1;
>             size.x = m_tbar->GetToolSize().x;
>         }
>         else {
>             size.x = m_tbar->GetToolPacking() + 1;
>             size.y = m_tbar->GetToolSize().y + 2;
>         }
>     }
>     return size;
> }
72a236,342
> void wxToolBarTool::UpdatePosition()
> {
>     wxToolBar *tbar = (wxToolBar *)m_tbar;
> 
>     if(!IsControl()) {
>         UMAMoveControl(m_macHandle, m_x - tbar->ScrollOffsetX(), m_y - tbar->ScrollOffsetY());
>     }
>     else {
>         wxControl *control = GetControl();
> 
>         control->Move(m_x - tbar->ScrollOffsetX(), m_y - tbar->ScrollOffsetY());
>     }
> }
> 
> wxPoint wxToolBarTool::GetPosition() const
> {
>     wxPoint pt;
> 
>     if(IsButton())
>     {
>         pt.x = m_x;
>         pt.y = m_y;
>     }
>     return pt;
> }
> 
> void wxToolBarTool::Show(bool show)
> {
>     if(IsButton())
>     {
>         if(show == true) {
>             UMAShowControl(m_macHandle);
>         }
>         else {
>             UMAHideControl(m_macHandle);
>         }
>     }
>     else if(IsControl()) {
>         wxControl *control = GetControl();
> 
>         control->Show(show);
>     }
> }
> 
> bool wxToolBarTool::PointInTool(int x, int y) const
> {
>     if(IsButton())
>     {
>         Point pt = { y, x };
>         Rect bounds;
> 
>         GetControlBounds(m_macHandle, &bounds);
>         if(PtInRect(pt, &bounds)) {
>             return true;
>         }
>     }
>     return false;
> }
> 
> void wxToolBarTool::Enable(bool enable)
> {
>     if(IsButton())
>     {
>         if(enable == true) {
>             UMAActivateControl(m_macHandle);
>         }
>         else {
>             UMADeactivateControl(m_macHandle);
>         }
>     }
>     else if(IsControl())
>     {
>         wxControl *control = GetControl();
> 
>         control->Enable(enable);
>     }
> }
> 
> bool wxToolBarTool::Toggle(bool toggle)
> {
>     if(IsButton()) {
>         SetControlValue(m_macHandle, toggle);
>         return true;
>     }
>     return false;
> }
> 
> void wxToolBarTool::Toggle()
> {
>     if(IsButton()) {
>         wxToolBarToolBase::Toggle();
>         Toggle(GetControlValue(m_macHandle));
>     }
> }
> 
> void wxToolBarTool::DrawTool() const
> {
>     if(!IsControl()) {
>         UMADrawControl(m_macHandle);
>     }
>     else if(IsControl()) {
>         wxControl *control = GetControl();
> 
>         wxPaintEvent paint(control->GetId());
>         control->GetEventHandler()->ProcessEvent(paint);
>     }
> }
74,76d343
< // ============================================================================
< // implementation
< // ============================================================================
79c346
< // wxToolBarTool
---
> // wxToolBar
82,86c349,350
< const short kwxMacToolBarToolDefaultWidth = 24 ;
< const short kwxMacToolBarToolDefaultHeight = 22 ;
< const short kwxMacToolBarTopMargin = 2 ;
< const short kwxMacToolBarLeftMargin = 2 ;
< 
---
> #define DEFAULT_WIDTH  24 ;
> #define DEFAULT_HEIGHT 22 ;
107,154c371,386
<   m_maxWidth = -1;
<   m_maxHeight = -1;
<   m_defaultWidth = kwxMacToolBarToolDefaultWidth;
<   m_defaultHeight = kwxMacToolBarToolDefaultHeight;
< }
< 
< bool wxToolBar::Create(wxWindow *parent, wxWindowID id, const wxPoint& pos, const wxSize& size,
<             long style, const wxString& name)
< {
<   
<   int x = pos.x;
<   int y = pos.y;
<   int width = size.x;
<   int height = size.y;
< 
<   if (width <= 0)
<     width = 100;
<   if (height <= 0)
<     height = 30;
<   if (x < 0)
<     x = 0;
<   if (y < 0)
<     y = 0;
< 
<   SetName(name);
< 
<   m_windowStyle = style;
<   parent->AddChild(this);
< 
<   m_backgroundColour = parent->GetBackgroundColour() ;
<   m_foregroundColour = parent->GetForegroundColour() ;
< 
<   if (id == -1)
<       m_windowId = NewControlId();
<   else
<       m_windowId = id;
< 
<   {
< 	m_width = size.x ;
< 	m_height = size.y ;
< 	int x = pos.x ;
< 	int y = pos.y ;
< 	AdjustForParentClientOrigin(x, y, wxSIZE_USE_EXISTING);
< 	m_x = x ;
< 	m_y = y ;
<   }
<   
<   return TRUE;
---
>     m_maxWidth = -1;
>     m_maxHeight = -1;
>     m_defaultWidth =  DEFAULT_WIDTH;
>     m_defaultHeight = DEFAULT_HEIGHT;
> 
>     m_x = m_y = 0;
>     m_xMargin = kwxMacToolBarLeftMargin;
>     m_yMargin = kwxMacToolBarTopMargin;
>     m_toolPacking = 5;
> 
>     m_maxRows = 1;
>     m_maxCols = 1;
> 
>     m_scrollOffset = 0;
> 
>     m_frameHandled = false;
157c389,390
< wxToolBar::~wxToolBar()
---
> bool wxToolBar::Create(wxWindow *parent, wxWindowID id, const wxPoint& pos,
>                        const wxSize& size, long style, const wxString& name)
159,160c392,405
<     // we must refresh the frame size when the toolbar is deleted but the frame
<     // is not - otherwise toolbar leaves a hole in the place it used to occupy
---
>     Rect bounds ;
>     Str255 title ;
>     wxValidator validator;
> 
>     MacPreControlCreate( parent, id, "", pos, size, style, validator, name, &bounds, title );
> 
>     CreateWindowHeaderControl(parent->GetMacRootWindow(), &bounds, false, &m_macControl);
> 
>     MacPostControlCreate();
> 
>     m_scrollbar.Create(this, wxTOOLBAR_SCROLLBAR);
>     m_scrollbar.Show(false);
> 
>     return true;
163,164c408
< PicHandle MakePict(GWorldPtr wp, GWorldPtr mask ) ;
< PicHandle MakePict(GWorldPtr wp, GWorldPtr mask ) 
---
> wxToolBar::~wxToolBar()
166,244d409
< 	CGrafPtr		origPort ;
< 	GDHandle		origDev ;
< 	
< 	PicHandle		pict;				// this is the Picture we give back
< 
< 	RGBColor		gray = { 0xCCCC ,0xCCCC , 0xCCCC } ;
< 	RGBColor		white = { 0xffff ,0xffff , 0xffff } ;
< 	RGBColor		black = { 0x0000 ,0x0000 , 0x0000 } ;
< 	
< 	unsigned char *maskimage = NULL ;
< 	Rect portRect ;
< 	GetPortBounds( wp , &portRect ) ;
< 	int width = portRect.right - portRect.left ;
< 	int height = portRect.bottom - portRect.top ;
< 	
< 	LockPixels( GetGWorldPixMap( wp ) ) ;
< 	GetGWorld( &origPort , &origDev ) ;
< 
< 	if ( mask )
< 	{
< 		
< 		maskimage = (unsigned char*) malloc( width * height ) ;
< 		SetGWorld( mask , NULL ) ;
< 		LockPixels( GetGWorldPixMap( mask ) ) ;
< 		for ( int y = 0 ; y < height ; ++y )
< 		{
< 			for( int x = 0 ; x < width ; ++x )
< 			{
< 				RGBColor col ;
< 				
< 				GetCPixel( x + portRect.left , y + portRect.top , &col ) ;
< 				maskimage[y*width + x] = ( col.red == 0 ) ; // for monochrome masks
< 			}
< 		}
< 		UnlockPixels( GetGWorldPixMap( mask ) ) ;
< 	}
< 	
< 	SetGWorld( wp , NULL ) ;
< 	
< 	pict = OpenPicture(&portRect);	// open a picture, this disables drawing
< 	if(!pict)	
< 		return NULL;
< 
< 	RGBBackColor( &gray ) ;
< 	RGBForeColor( &black ) ;
< 	EraseRect(&portRect) ;
< 	RGBBackColor( &white ) ;
< 
< 	if ( maskimage )
< 	{
< 		for ( int y = 0 ; y < height ; ++y )
< 		{
< 			for( int x = 0 ; x < width ; ++x )
< 			{
< 				if ( maskimage[y*width + x] )
< 				{
< 					RGBColor col ;
< 				
< 					GetCPixel( x + portRect.left , y + portRect.top , &col ) ;
< 					SetCPixel( x + portRect.left , y + portRect.top , &col ) ;
< 				}
< 			}
< 		}
< 		free( maskimage ) ;
< 		maskimage = NULL ;
< 	}
< 	else
< 	{
< 		CopyBits(GetPortBitMapForCopyBits(wp),			// src PixMap	- we copy image over itself -
< 				GetPortBitMapForCopyBits(wp),		// dst PixMap	- no drawing occurs -
< 				&portRect,			// srcRect		- it will be recorded and compressed -
< 				&portRect,			// dstRect		- into the picture that is open -
< 				srcCopy,NULL);			// copyMode and no clip region
< 
< 	}
< 	ClosePicture();						// We are done recording the picture
< 	UnlockPixels( GetGWorldPixMap( wp ) ) ;
< 	SetGWorld( origPort , origDev ) ;
< 	return pict;						// return our groovy pict handle
249,250c414
<   if (m_tools.Number() == 0)
<       return FALSE;
---
>     int sizeFlags = wxSIZE_AUTO;
252,384c416,419
< 	Point localOrigin ;
< 	Rect clipRect ;
< 	WindowRef window ;
< 	wxWindow *win ;
< 	
< 	GetParent()->MacGetPortParams( &localOrigin , &clipRect , &window , &win ) ;
< 
< 	Rect toolbarrect = { m_y + localOrigin.v , m_x  + localOrigin.h , 
< 		m_y + m_height + localOrigin.v  , m_x + m_width + localOrigin.h} ;
< 	ControlFontStyleRec		controlstyle ;
< 
< 	controlstyle.flags = kControlUseFontMask ;
< 	controlstyle.font = kControlFontSmallSystemFont ;
< 	
< 	wxNode *node = m_tools.First();
< 	int noButtons = 0;
< 	int x = 0 ;
< 	wxSize toolSize = GetToolSize() ;
<     int tw, th;
<     GetSize(& tw, & th);
<     
<     int maxWidth = 0 ;
<     int maxHeight = 0 ;
<     
< 	while (node)
< 	{
< 		wxToolBarTool *tool = (wxToolBarTool *)node->Data();
< 		wxBitmapRefData * bmap = (wxBitmapRefData*) ( tool->GetBitmap1().GetRefData()) ;
< 		
< 		if(  !tool->IsSeparator()  )
< 		{
< 			Rect toolrect = { toolbarrect.top + m_yMargin + kwxMacToolBarTopMargin, toolbarrect.left + x + m_xMargin + kwxMacToolBarLeftMargin , 0 , 0 } ;
< 			toolrect.right = toolrect.left + toolSize.x ;
< 			toolrect.bottom = toolrect.top + toolSize.y ;
< 			
< 			PicHandle	icon = NULL ;
< 			if ( bmap )
< 			{
< 				if ( bmap->m_bitmapType == kMacBitmapTypePict )
< 					icon = bmap->m_hPict ;
< 				else if ( bmap->m_bitmapType == kMacBitmapTypeGrafWorld )
< 				{
< 					if ( tool->GetBitmap1().GetMask() )
< 					{
< 						icon = MakePict( bmap->m_hBitmap , tool->GetBitmap1().GetMask()->GetMaskBitmap() ) ;
< 					}
< 					else
< 					{
< 						icon = MakePict( bmap->m_hBitmap , NULL ) ;
< 					}
< 				}
< 			}
< 			
< 			ControlHandle m_macToolHandle ;
< 			
< 			SInt16 behaviour = kControlBehaviorOffsetContents ;
< 			if ( tool->CanBeToggled() )
< 				behaviour += kControlBehaviorToggles ;
< 				
< 			if ( icon )
< 			{
< 				m_macToolHandle = UMANewControl( window , &toolrect , "\p" , false , 0 , 
< 					behaviour + kControlContentPictHandle , 0 , kControlBevelButtonNormalBevelProc , (long) this ) ;
< 				ControlButtonContentInfo info ;
< 				
< 				info.contentType = kControlContentPictHandle ;
< 				info.u.picture = icon ;
< 				
< 				UMASetControlData( m_macToolHandle , kControlButtonPart , kControlBevelButtonContentTag , sizeof(info) , (char*) &info ) ;
< 			}
< 			else
< 			{
< 						m_macToolHandle = UMANewControl( window , &toolrect , "\p" , false , 0 , 
< 						behaviour  , 0 , kControlBevelButtonNormalBevelProc , (long) this ) ;
< 			}
< 			UMAShowControl( m_macToolHandle ) ;
< 			m_macToolHandles.Add( m_macToolHandle ) ;
< 			tool->m_index = m_macToolHandles.Count() -1 ;
< 			if ( !tool->IsEnabled() )
< 			{
< 				UMADeactivateControl( m_macToolHandle ) ;
< 			}
< 			if ( tool->CanBeToggled() && tool->IsToggled() )
< 			{
<    				::SetControlValue( m_macToolHandle , 1 ) ;
< 			}
< 			UMASetControlFontStyle( m_macToolHandle , &controlstyle ) ;
< 			ControlHandle container = GetParent()->MacGetContainerForEmbedding() ;
< 			wxASSERT_MSG( container != NULL , "No valid mac container control" ) ;
< 			UMAEmbedControl( m_macToolHandle , container ) ;
< 			
< 			x += (int)toolSize.x;
< 			noButtons ++;
< 		}
< 		else
< 		{
< 			m_macToolHandles.Add( NULL ) ;
< 			x += (int)toolSize.x / 4;
< 		}
< 	    if ( toolbarrect.left + x + m_xMargin  + kwxMacToolBarLeftMargin- m_x - localOrigin.h > maxWidth)
<     	  	maxWidth = toolbarrect.left + x  + kwxMacToolBarLeftMargin+ m_xMargin - m_x - localOrigin.h;
<     	if (toolbarrect.top + m_yMargin  + kwxMacToolBarTopMargin - m_y - localOrigin.v > maxHeight)
<       		maxHeight = toolbarrect.top  + kwxMacToolBarTopMargin + m_yMargin - m_y - localOrigin.v ;
< 
< 		node = node->Next();
< 	}
< 
<   if ( GetWindowStyleFlag() & wxTB_HORIZONTAL )
<   {
<     if ( m_maxRows == 0 )
<     {
<         // if not set yet, only one row
<         SetRows(1);
<     }
<    	maxWidth = tw ; 
<     maxHeight += toolSize.y;
<   	maxHeight += m_yMargin + kwxMacToolBarTopMargin;
<   	m_maxHeight = maxHeight ;
<   }
<   else
<   {
<     if ( noButtons > 0 && m_maxRows == 0 )
<     {
<         // if not set yet, have one column
<         SetRows(noButtons);
<     }
<     maxHeight = th ;
<     maxWidth += toolSize.x;
<   	maxWidth += m_xMargin + kwxMacToolBarLeftMargin;
<   	m_maxWidth = maxWidth ;
<   }
< 
<   SetSize(maxWidth, maxHeight);
---
>     if(m_frameHandled) {
>         sizeFlags = wxSIZE_NO_ADJUSTMENTS;
>     }
>     DoSetSize(m_x, m_y, m_width, m_height, sizeFlags);
386c421
<   return TRUE;
---
>     return true;
391c426,427
<     m_defaultWidth = size.x+4; m_defaultHeight = size.y+4;
---
>     m_defaultWidth = size.x;
>     m_defaultHeight = size.y;
400c436,437
< void wxToolBar::MacHandleControlClick( ControlHandle control , SInt16 controlpart ) 
---
> void wxToolBar::MacHandleControlClick(ControlHandle control, 
>                                       SInt16 controlpart) 
402,416c439,440
< 	int index = 0 ;
< 	for ( index = 0 ; index < m_macToolHandles.Count() ; ++index )
< 	{
< 		if ( m_macToolHandles[index] == (void*) control )
< 		{
<    			wxToolBarTool *tool = (wxToolBarTool *)m_tools.Nth( index )->Data();
< 			if ( tool->CanBeToggled() )
<     		{
<         		tool->Toggle( GetControlValue( control ) ) ;
<     		}
< 			OnLeftClick( tool->GetId() , tool -> IsToggled() ) ;
< 			break ;
< 		}
< 	}
< }
---
>     wxNode *node;
>     wxToolBarTool *tool;
418,420c442
< void wxToolBar::SetRows(int nRows)
< {
<     if ( nRows == m_maxRows )
---
>     for(node = m_tools.First(); node; node = node->Next())
422,547c444,452
<         // avoid resizing the frame uselessly
<         return;
<     }
< 
<     m_maxRows = nRows;
< }
< 
< void wxToolBar::MacSuperChangedPosition() 
< {
<   if (m_tools.Number() > 0)
<   {
< 
< 	Point localOrigin ;
< 	Rect clipRect ;
< 	WindowRef window ;
< 	wxWindow *win ;
< 	
< 	GetParent()->MacGetPortParams( &localOrigin , &clipRect , &window , &win ) ;
< 
< 	Rect toolbarrect = { m_y + localOrigin.v , m_x  + localOrigin.h , 
< 		m_y + m_height + localOrigin.v  , m_x + m_width + localOrigin.h} ;
< 	ControlFontStyleRec		controlstyle ;
< 
< 	controlstyle.flags = kControlUseFontMask ;
< 	controlstyle.font = kControlFontSmallSystemFont ;
< 	
< 	wxNode *node = m_tools.First();
< 	int noButtons = 0;
< 	int x = 0 ;
< 	wxSize toolSize = GetToolSize() ;
<     int tw, th;
<     GetSize(& tw, & th);
<     
<     int maxWidth = 0 ;
<     int maxHeight = 0 ;
<     int toolcount = 0 ;
<     {
<    		WindowRef rootwindow = GetMacRootWindow() ;
<    		wxWindow* wxrootwindow = wxFindWinFromMacWindow( rootwindow ) ;
<    		UMASetThemeWindowBackground( rootwindow , kThemeBrushDialogBackgroundActive , false ) ;
<    		wxMacDrawingHelper focus( wxrootwindow ) ;
<     	while (node)
<     	{
<     		wxToolBarTool *tool = (wxToolBarTool *)node->Data();
<     		wxBitmapRefData * bmap = (wxBitmapRefData*) ( tool->GetBitmap1().GetRefData()) ;
<     		
<     		if(  !tool->IsSeparator()  )
<     		{
<     			Rect toolrect = { toolbarrect.top + m_yMargin + kwxMacToolBarTopMargin, toolbarrect.left + x + m_xMargin + kwxMacToolBarLeftMargin , 0 , 0 } ;
<     			toolrect.right = toolrect.left + toolSize.x ;
<     			toolrect.bottom = toolrect.top + toolSize.y ;
<     						
<     			ControlHandle m_macToolHandle = (ControlHandle) m_macToolHandles[toolcount++] ;
<     			
<             	{
<             		Rect contrlRect ;		
<             		GetControlBounds( m_macToolHandle , &contrlRect ) ; 
<             		int former_mac_x = contrlRect.left ;
<             		int former_mac_y = contrlRect.top ;
<             		int mac_x = toolrect.left ;
<             		int mac_y = toolrect.top ;
<              		        	
<             		if ( mac_x != former_mac_x || mac_y != former_mac_y )
<             		{
<             			{
<             				Rect inval = { former_mac_y , former_mac_x , former_mac_y + toolSize.y , former_mac_x + toolSize.y } ;
<             				InvalWindowRect( rootwindow , &inval ) ;
<             			}
<             	  		UMAMoveControl( m_macToolHandle , mac_x , mac_y ) ;
<             			{
<             				Rect inval = { mac_y , mac_x , mac_y + toolSize.y , mac_x + toolSize.y } ;
<             				InvalWindowRect( rootwindow , &inval ) ;
<             			}
<             		}
<             	}
<     			
<     			x += (int)toolSize.x;
<     			noButtons ++;
<     		}
<     		else
<     		{
<                 toolcount++ ;
<     			x += (int)toolSize.x / 4;
<     		}
<     	    if ( toolbarrect.left + x + m_xMargin  + kwxMacToolBarLeftMargin- m_x - localOrigin.h > maxWidth)
<         	  	maxWidth = toolbarrect.left + x  + kwxMacToolBarLeftMargin+ m_xMargin - m_x - localOrigin.h;
<         	if (toolbarrect.top + m_yMargin  + kwxMacToolBarTopMargin - m_y - localOrigin.v > maxHeight)
<           		maxHeight = toolbarrect.top  + kwxMacToolBarTopMargin + m_yMargin - m_y - localOrigin.v ;
< 
<     		node = node->Next();
<     	}
<   		if ( wxrootwindow->IsKindOf( CLASSINFO( wxDialog ) ) )
<   		{
<   		}
<   		else
<   		{
<   			UMASetThemeWindowBackground( rootwindow , kThemeBrushDocumentWindowBackground , false ) ;
<   		}
<     }
< 
<      if ( GetWindowStyleFlag() & wxTB_HORIZONTAL )
<      {
<        if ( m_maxRows == 0 )
<        {
<            // if not set yet, only one row
<            SetRows(1);
<        }
<       	maxWidth = tw ; 
<        maxHeight += toolSize.y;
<      	maxHeight += m_yMargin + kwxMacToolBarTopMargin;
<      	m_maxHeight = maxHeight ;
<      }
<      else
<      {
<        if ( noButtons > 0 && m_maxRows == 0 )
<        {
<            // if not set yet, have one column
<            SetRows(noButtons);
<        }
<        maxHeight = th ;
<        maxWidth += toolSize.x;
<      	maxWidth += m_xMargin + kwxMacToolBarLeftMargin;
<      	m_maxWidth = maxWidth ;
<      }
< 
<      SetSize(maxWidth, maxHeight);
---
>         tool = (wxToolBarTool *)node->GetData();
>         if(tool->GetControlHandle() == control)
>         {
>             if(tool->CanBeToggled()) {
>                 tool->Toggle();
>             }
>             OnLeftClick(tool->GetId(), tool->IsToggled());
>             break;
>         }
549,550d453
< 
<     wxWindow::MacSuperChangedPosition() ;
556c459,460
<     Point pt = { y ,x } ;
---
>     wxNode *node;
>     wxToolBarTool *tool;
558,570c462,464
< 	int index = 0 ;
< 	for ( index = 0 ; index < m_macToolHandles.Count() ; ++index )
< 	{
< 		if ( m_macToolHandles[index] )
< 		{
< 			Rect bounds ;
< 			GetControlBounds((ControlHandle) m_macToolHandles[index], &bounds ) ;
< 			if ( PtInRect( pt , &bounds ) )
< 			{
< 				return  (wxToolBarTool*) (m_tools.Nth( index )->Data() ) ;
< 			}
< 		}
< 	}
---
>     for(node = m_tools.First(); node; node = node->Next())
>     {
>         tool = (wxToolBarTool *)node->GetData();
571a466,469
>         if(tool->PointInTool(x,y) == true) {
>             return tool;
>         }
>     }
577,582c475,480
< 	wxToolBarToolBase* tool = FindToolForPosition( pt.x , pt.y ) ;
< 	if ( tool )
< 	{
< 		return tool->GetShortHelp() ;
< 	}
< 	return "" ;
---
>     wxToolBarToolBase* tool = FindToolForPosition( pt.x , pt.y ) ;
>     if ( tool )
>     {
>         return tool->GetShortHelp() ;
>     }
>     return "" ;
587,596c485,487
<         wxToolBarTool *tool = (wxToolBarTool *)t;
<         if ( tool->m_index < 0 )
<         	return ;
<         	
<         ControlHandle control = (ControlHandle) m_macToolHandles[ tool->m_index ] ;
< 
< 		if ( enable )
< 			UMAActivateControl( control ) ;
< 		else
< 			UMADeactivateControl( control ) ;
---
>     wxToolBarTool *tool = (wxToolBarTool *)t;
> 
>     tool->Enable(enable);
601,606c492,494
<        wxToolBarTool *tool = (wxToolBarTool *)t;
<         if ( tool->m_index < 0 )
<         	return ;
<         
<        ControlHandle control = (ControlHandle) m_macToolHandles[ tool->m_index ] ;
<    		::SetControlValue( control , toggle ) ;
---
>     wxToolBarTool *tool = (wxToolBarTool *)t;
> 
>     tool->Toggle(toggle);
609,610c497
< bool wxToolBar::DoInsertTool(size_t WXUNUSED(pos),
<                              wxToolBarToolBase *tool)
---
> bool wxToolBar::DoInsertTool(size_t pos, wxToolBarToolBase *tool)
612,613d498
<     // nothing special to do here - we really create the toolbar buttons in
<     // Realize() later
616c501
<     return TRUE;
---
>     return true;
621,622c506,508
<        wxToolBarTool *tool = (wxToolBarTool *)t;
<        // TODO: set toggle state
---
>     wxToolBarTool *tool = (wxToolBarTool *)t;
> 
>     tool->SetToggle(toggle);
627c513,550
< 		return TRUE ;
---
>     // Tool is removed when caller deletes tool from list
>     return true;
> }
> 
> void wxToolBar::OnScrollToolBar(wxScrollEvent &event)
> {
>     wxNode *node;
>     wxToolBarTool *tool;
> 
>     for(node = m_tools.First(); node; node = node->Next())
>     {
>         tool = (wxToolBarTool *)node->GetData();
> 
>         tool->UpdatePosition();
>     }
>     RedrawToolBar();
> }
> 
> int wxToolBar::ScrollOffsetX() const
> {
>     if(GetWindowStyleFlag() & wxTB_HORIZONTAL)
>     {
>         if(m_scrollbar.IsShown()) {
>             return m_scrollbar.GetThumbPosition();
>         }
>     }
>     return 0;
> }
> 
> int wxToolBar::ScrollOffsetY() const
> {
>     if(GetWindowStyleFlag() & wxTB_VERTICAL)
>     {
>         if(m_scrollbar.IsShown()) {
>             return m_scrollbar.GetThumbPosition();
>         }
>     }
>     return 0;
632,737c555
< 	Point localOrigin ;
< 	Rect clipRect ;
< 	WindowRef window ;
< 	wxWindow *win ;
< 	
< 	GetParent()->MacGetPortParams( &localOrigin , &clipRect , &window , &win ) ;
< 	if ( window && win )
< 	{
< 		wxMacDrawingHelper help( win ) ;
< 		// the mac control manager always assumes to have the origin at 0,0
< 		SetOrigin( 0 , 0 ) ;
< 		
< 		bool			hasTabBehind = false ;
< 		wxWindow* parent = GetParent() ;
< 		while ( parent )
< 		{
< 			if( parent->MacGetWindowData() )
< 			{
< 				UMASetThemeWindowBackground( win->MacGetWindowData()->m_macWindow , kThemeBrushDialogBackgroundActive , false ) ;
< 				break ;
< 			}
< 			
< 			if( parent->IsKindOf( CLASSINFO( wxNotebook ) ) ||  parent->IsKindOf( CLASSINFO( wxTabCtrl ) ))
< 			{
< 				if ( ((wxControl*)parent)->GetMacControl() )
< 					SetUpControlBackground( ((wxControl*)parent)->GetMacControl() , -1 , true ) ;
< 				break ;
< 			}
< 			
< 			parent = parent->GetParent() ;
< 		} 
< 
< 		Rect toolbarrect = { m_y + localOrigin.v , m_x + localOrigin.h , 
< 			m_y  + localOrigin.v + m_height , m_x + localOrigin.h + m_width } ;
< 
< 		UMADrawThemePlacard( &toolbarrect , IsEnabled() ? kThemeStateActive : kThemeStateInactive) ;
< 		{
< 			int index = 0 ;
< 			for ( index = 0 ; index < m_macToolHandles.Count() ; ++index )
< 			{
< 				if ( m_macToolHandles[index] )
< 				{
< 					UMADrawControl( (ControlHandle) m_macToolHandles[index] ) ;
< 				}
< 			}
< 		}
< 		UMASetThemeWindowBackground( win->MacGetWindowData()->m_macWindow , win->MacGetWindowData()->m_macWindowBackgroundTheme , false ) ;
< 	}
< }
< 
< void  wxToolBar::OnMouse( wxMouseEvent &event ) 
< {
< 		
< 	if (event.GetEventType() == wxEVT_LEFT_DOWN || event.GetEventType() == wxEVT_LEFT_DCLICK )
< 	{
< 			
< 		int x = event.m_x ;
< 		int y = event.m_y ;
< 		
< 		MacClientToRootWindow( &x , &y ) ;
< 			
< 		ControlHandle	control ;
< 		Point		localwhere ;
< 		GrafPtr		port ;
< 		SInt16		controlpart ;
< 		WindowRef	window = GetMacRootWindow() ;
< 		
< 		localwhere.h = x ;
< 		localwhere.v = y ;
< 	
< 		short modifiers = 0;
< 		
< 		if ( !event.m_leftDown && !event.m_rightDown )
< 			modifiers  |= btnState ;
< 	
< 		if ( event.m_shiftDown )
< 			modifiers |= shiftKey ;
< 			
< 		if ( event.m_controlDown )
< 			modifiers |= controlKey ;
< 	
< 		if ( event.m_altDown )
< 			modifiers |= optionKey ;
< 	
< 		if ( event.m_metaDown )
< 			modifiers |= cmdKey ;
< 	
< 		controlpart = FindControl( localwhere , window , &control ) ;
< 		{
< 			if ( control && UMAIsControlActive( control ) )
< 			{
< 				{
< 					if ( controlpart == kControlIndicatorPart && !UMAHasAppearance() )
< 						controlpart = UMAHandleControlClick( control , localwhere , modifiers , (ControlActionUPP) NULL ) ;
< 					else
< 						controlpart = UMAHandleControlClick( control , localwhere , modifiers , (ControlActionUPP) -1 ) ;
< 					wxTheApp->s_lastMouseDown = 0 ;
< 					if ( controlpart && ! ( ( UMAHasAppearance() || (controlpart != kControlIndicatorPart) ) 
< 						&& (IsKindOf( CLASSINFO( wxScrollBar ) ) ) ) ) // otherwise we will get the event twice
< 					{
< 						MacHandleControlClick( control , controlpart ) ;
< 					}
< 				}
< 			}
< 		}
< 	}
---
>     RedrawToolBar();
740c558,662
< #endif // wxUSE_TOOLBAR
---
> void wxToolBar::RedrawToolBar() const
> {
>     // Set up port
>     WindowRef rootwindow = GetMacRootWindow() ;
>     wxWindow* wxrootwindow = wxFindWinFromMacWindow( rootwindow ) ;
>     wxMacDrawingHelper focus( wxrootwindow );
> 
>     UMADrawControl(m_macControl);
> }
> 
> void wxToolBar::OnMouse( wxMouseEvent &event ) 
> {
>     if (event.GetEventType() == wxEVT_LEFT_DOWN || event.GetEventType() == wxEVT_LEFT_DCLICK )
>     {
>         ControlHandle control ;
>         Point         localwhere ;
>         SInt16        controlpart ;
>         WindowRef     window = GetMacRootWindow() ;
> 
>         localwhere.h = m_x + event.m_x;
>         localwhere.v = m_y + event.m_y;
>    
>         short modifiers = 0;
>       
>         if ( !event.m_leftDown && !event.m_rightDown )
>             modifiers  |= btnState ;
>    
>         if ( event.m_shiftDown )
>             modifiers |= shiftKey ;
>          
>         if ( event.m_controlDown )
>             modifiers |= controlKey ;
>    
>         if ( event.m_altDown )
>             modifiers |= optionKey ;
>    
>         if ( event.m_metaDown )
>             modifiers |= cmdKey ;
>    
>         controlpart = FindControl( localwhere , window , &control ) ;
> 
>         if ( AcceptsFocus() && FindFocus() != this )
>         {
>             SetFocus() ;
>         }
>         if ( control && UMAIsControlActive( control ) )
>         {
>             if(controlpart == kControlIndicatorPart && !UMAHasAppearance())
>             {
>                 controlpart = UMAHandleControlClick(control , localwhere ,
>                                                     modifiers,
>                                                     (ControlActionUPP) NULL);
>             }
>             else {
>                 controlpart = UMAHandleControlClick(control, localwhere,
>                                                     modifiers,
>                                                     (ControlActionUPP) -1);
>             }
>             wxTheApp->s_lastMouseDown = 0 ;
>             if(controlpart && ! ( (UMAHasAppearance() ||
>                                    (controlpart != kControlIndicatorPart))
>                                   && (IsKindOf( CLASSINFO(wxScrollBar)))))
>                 // otherwise we will get the event twice
>             {
>                 MacHandleControlClick( control , controlpart ) ;
>             }
>         }
>     }
> }
> 
> /* A tool bar will appear at the x,y, width and height specified if any are -1 then
>  * this will use 0,0 and screen width by tool height for the horizontal case
>  * NB The height will always be specified by the tool size plus margins in the
>  * horizontal case.
>  */
> void wxToolBar::DoSetSize(int x, int y, int width, int height, int sizeFlags)
> {
>     int mac_x, mac_y;
> 
>     if(x == -1)   x = 0;
>     if(y == -1)   y = 0;
> 
>     AdjustForParentClientOrigin(x,y, sizeFlags);
> 
>     mac_x = x;
>     mac_y = y;
>     if(GetParent()) {
>         GetParent()->MacClientToRootWindow(&mac_x, &mac_y);
>     }
> 
>     // Set up width and height if no values given
>     wxSize winSize;
> 
>     if(sizeFlags & wxSIZE_NO_ADJUSTMENTS) {
>         winSize = GetParent()->GetSize();
>     }
>     else {
>         winSize = GetParent()->GetClientSize();
>     }
>     if(width == -1) {
>         width = winSize.x;
>     }
>     if(height == -1) {
>         height = winSize.y;
>     }
741a664,803
>     // Reset the scrolled position to 0
>     m_scrollOffset = 0;
> 
>     wxSize toolSize;
>     wxNode *node = m_tools.First();
>     wxToolBarTool *tool;
>     wxSize size;
> 
>     toolSize = GetToolSize();
> 
>     if(GetWindowStyleFlag() & wxTB_VERTICAL)
>     {
>         int totalToolbarHeight = m_yMargin;
>         int xpos;
>         int ypos = mac_y + m_yMargin;
> 
>         width = toolSize.x + 2 * m_xMargin;
> 
>         for(node = m_tools.First(); node; node = node->Next())
>         {
>             tool = (wxToolBarTool *)node->GetData();
>             size = tool->GetSize();
> 
>             xpos = mac_x + (((toolSize.x + 2 * m_xMargin) - size.x) / 2);
>             tool->SetSize(xpos, ypos, size.x, size.y);
>             tool->Enable(tool->IsEnabled());
>             tool->Toggle(tool->IsToggled());
>             tool->Show(true);
> 
>             ypos += size.y + m_toolPacking;
>             totalToolbarHeight += size.y + m_toolPacking;
>         }
>         if(totalToolbarHeight > height)
>         {
>             int sw, sh;
> 
>             m_scrollbar.SetSize(toolSize.x + 2 * m_xMargin, m_yMargin,
>                                 -1, height - 2 * m_yMargin);
>             m_scrollbar.Show(true);
>             m_scrollbar.GetSize(&sw, &sh);
>             width += sw + m_xMargin;
>             m_scrollbar.SetScrollbar(0, height, totalToolbarHeight, height);
>         }
>         else {
>             m_scrollbar.Show(false);
>         }
>     }
>     else  // wxTB_HORIZONTAL
>     {
>         int totalToolbarWidth = m_xMargin;
>         int xpos = mac_x + m_xMargin;
>         int ypos;
> 
>         height = toolSize.y + 2 * m_yMargin;
> 
>         for(node = m_tools.First(); node; node = node->Next())
>         {
>             tool = (wxToolBarTool *)node->GetData();
>             size = tool->GetSize();
> 
>             ypos = mac_y + (((toolSize.y + 2 * m_yMargin) - size.y) / 2);
>             tool->SetSize(xpos, ypos, size.x, size.y);
>             tool->Enable(tool->IsEnabled());
>             tool->Toggle(tool->IsToggled());
>             tool->Show(true);
> 
>             xpos += size.x + m_toolPacking;
>             totalToolbarWidth += size.x + m_toolPacking;
>         }
>         if(totalToolbarWidth > width)
>         {
>             int sw, sh;
> 
>             m_scrollbar.SetSize(m_xMargin, toolSize.y + 2 * m_yMargin,
>                                 width - 2 * m_xMargin, -1);
>             m_scrollbar.Show(true);
>             m_scrollbar.GetSize(&sw, &sh);
>             height += sh + m_yMargin;
>             m_scrollbar.SetScrollbar(0, width, totalToolbarWidth, width);
>         }
>         else {
>             m_scrollbar.Show(false);
>         }
>     }
> 
>     bool doMove = false;
>     bool doSize = false;
>     Rect oldbounds;
> 
>     GetControlBounds(m_macControl, &oldbounds);
> 
>     if( (mac_x != oldbounds.left) || (mac_y != oldbounds.top) ) {
>         doMove = true;
>     }
>     if( (width != m_width) || (height != m_height) ) {
>         doSize = true;
>     }
> 
>     if(doMove || doSize)
>     {
>         Rect newbounds;
> 
>         SetRect(&newbounds, mac_x, mac_y, mac_x + width, mac_y + height);
> 
>         if(doMove)
>         {
>             m_x = x;
>             m_y = y;
> 
>             UMAMoveControl(m_macControl, mac_x, mac_y);
>         }
>         if(doSize)
>         {
>             m_width  = width;
>             m_height = height;
> 
>             UMASizeControl( m_macControl, m_width, m_height);
> 
>             wxSizeEvent event(wxSize(m_width, m_height), GetId());
>             event.SetEventObject(this);
>             GetParent()->GetEventHandler()->ProcessEvent(event);
>         }
> 
>         // Set up port
>         WindowRef rootwindow = GetMacRootWindow() ;
>         wxWindow* wxrootwindow = wxFindWinFromMacWindow( rootwindow ) ;
>         wxMacDrawingHelper focus( wxrootwindow );
> 
>         // Update window at old and new positions
>         InvalWindowRect( rootwindow , &oldbounds );
>         InvalWindowRect( rootwindow , &newbounds );
>     }
> }
> 
> ControlHandle wxToolBar::MacGetContainerForEmbedding() const
> {
>     return m_macControl;
> }
> 
> #endif // wxUSE_TOOLBAR

 	  	 
