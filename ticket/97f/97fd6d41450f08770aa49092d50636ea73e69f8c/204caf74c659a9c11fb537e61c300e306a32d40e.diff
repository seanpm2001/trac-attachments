diff --git a/build/bakefiles/files.bkl b/build/bakefiles/files.bkl
index 3c575fa..a530a51 100644
--- a/build/bakefiles/files.bkl
+++ b/build/bakefiles/files.bkl
@@ -648,6 +648,7 @@ IMPORTANT: please read docs/tech/tn0016.txt before modifying this file!
 <!-- ====================================================================== -->
 
 <set var="GUI_CMN_SRC" hints="files">
+    src/common/abstractbuttoncmn.cpp
     src/common/accelcmn.cpp
     src/common/accesscmn.cpp
     src/common/anidecod.cpp
@@ -810,6 +811,7 @@ IMPORTANT: please read docs/tech/tn0016.txt before modifying this file!
     src/generic/vscroll.cpp
 </set>
 <set var="GUI_CMN_HDR" hints="files">
+    wx/abstractbutton.h
     wx/affinematrix2dbase.h
     wx/affinematrix2d.h
     wx/bmpbuttn.h
@@ -1726,6 +1728,7 @@ IMPORTANT: please read docs/tech/tn0016.txt before modifying this file!
     src/generic/fontpickerg.cpp
     src/generic/statusbr.cpp
     src/generic/prntdlgg.cpp
+    src/msw/abstractbutton.cpp
     src/msw/accel.cpp
     src/msw/artmsw.cpp
     src/msw/bmpbuttn.cpp
@@ -1781,6 +1784,7 @@ IMPORTANT: please read docs/tech/tn0016.txt before modifying this file!
     wx/generic/collpaneg.h
     wx/generic/filepickerg.h
     wx/generic/fontpickerg.h
+    wx/msw/abstractbutton.h
     wx/msw/accel.h
     wx/msw/app.h
     wx/msw/bitmap.h
diff --git a/docs/changes.txt b/docs/changes.txt
index 32bd411..3a66b99 100644
--- a/docs/changes.txt
+++ b/docs/changes.txt
@@ -524,6 +524,7 @@ MSW:
 - wxAutomationObject::GetInstance() creates objects on demand (Kolya Kosenko).
 - Fix EVT_UPDATE_UI generation for items in submenus (wsu).
 - Added support for world transformation matrix to wxDC (Catalin Raceanu).
+- Add wxAbstractButton and refactor the code to use it (Hans de Ruiter).
 
 OSX:
 
diff --git a/include/wx/abstractbutton.h b/include/wx/abstractbutton.h
index e69de29..d2132bf 100644
--- a/include/wx/abstractbutton.h
+++ b/include/wx/abstractbutton.h
@@ -0,0 +1,212 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/abstractbutton.h
+// Purpose:     Abstract base class for all button classes.
+// Author:      Hans de Ruiter, based largely on original wxButton by
+//              Vadim Zetlin
+// Created:     2011-04-08
+// RCS-ID:      $Id:$
+// Copyright:   (c) Hans de Ruiter, Vadim Zetlin
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_ABSTRACTBUTTON_H_BASE_
+#define _WX_ABSTRACTBUTTON_H_BASE_
+
+#include "wx/defs.h"
+
+// We only need this class if we compile any button classes.
+#if wxUSE_TOGGLEBTN || wxUSE_BUTTON
+    #define wxHAS_ABSTRACT_BUTTON
+#endif
+
+#ifdef wxHAS_ABSTRACT_BUTTON
+
+// ----------------------------------------------------------------------------
+// Flags common to all button classes
+// ----------------------------------------------------------------------------
+
+// These flags affect label alignment
+#define wxBU_LEFT            0x0040
+#define wxBU_TOP             0x0080
+#define wxBU_RIGHT           0x0100
+#define wxBU_BOTTOM          0x0200
+#define wxBU_ALIGN_MASK      ( wxBU_LEFT | wxBU_TOP | wxBU_RIGHT | wxBU_BOTTOM )
+
+// These two flags are obsolete
+#define wxBU_NOAUTODRAW      0x0000
+#define wxBU_AUTODRAW        0x0004
+
+// by default, the buttons will be created with some (system dependent)
+// minimal size to make them look nicer, giving this style will make them as
+// small as possible
+#define wxBU_EXACTFIT        0x0001
+
+// this flag can be used to disable using the text label in the button: it is
+// mostly useful when creating buttons showing bitmap and having stock id as
+// without it both the standard label corresponding to the stock id and the
+// bitmap would be shown
+#define wxBU_NOTEXT          0x0002
+
+
+#include "wx/bitmap.h"
+#include "wx/control.h"
+
+extern WXDLLIMPEXP_DATA_CORE(const char) wxButtonNameStr[];
+
+// ----------------------------------------------------------------------------
+// wxAbstractButton: Base class for all button types
+// ----------------------------------------------------------------------------
+
+class WXDLLIMPEXP_CORE wxAbstractButtonBase : public wxControl
+{
+public:
+    wxAbstractButtonBase() { }
+
+    // show the authentication needed symbol on the button: this is currently
+    // only implemented on Windows Vista and newer (on which it shows the UAC
+    // shield symbol)
+    void SetAuthNeeded(bool show = true) { DoSetAuthNeeded(show); }
+    bool GetAuthNeeded() const { return DoGetAuthNeeded(); }
+
+    // show the image in the button in addition to the label: this method is
+    // supported on all (major) platforms
+    void SetBitmap(const wxBitmap& bitmap, wxDirection dir = wxLEFT)
+    {
+        SetBitmapLabel(bitmap);
+        SetBitmapPosition(dir);
+    }
+
+    wxBitmap GetBitmap() const { return DoGetBitmap(State_Normal); }
+
+    // Methods for setting individual images for different states: normal,
+    // selected (meaning pushed or pressed), focused (meaning normal state for
+    // a focused button), disabled or hover (a.k.a. hot or current).
+    //
+    // Remember that SetBitmap() itself must be called before any other
+    // SetBitmapXXX() methods (except for SetBitmapLabel() which is a synonym
+    // for it anyhow) and that all bitmaps passed to these functions should be
+    // of the same size.
+    void SetBitmapLabel(const wxBitmap& bitmap)
+        { DoSetBitmap(bitmap, State_Normal); }
+    void SetBitmapPressed(const wxBitmap& bitmap)
+        { DoSetBitmap(bitmap, State_Pressed); }
+    void SetBitmapDisabled(const wxBitmap& bitmap)
+        { DoSetBitmap(bitmap, State_Disabled); }
+    void SetBitmapCurrent(const wxBitmap& bitmap)
+        { DoSetBitmap(bitmap, State_Current); }
+    void SetBitmapFocus(const wxBitmap& bitmap)
+        { DoSetBitmap(bitmap, State_Focused); }
+
+    wxBitmap GetBitmapLabel() const { return DoGetBitmap(State_Normal); }
+    wxBitmap GetBitmapPressed() const { return DoGetBitmap(State_Pressed); }
+    wxBitmap GetBitmapDisabled() const { return DoGetBitmap(State_Disabled); }
+    wxBitmap GetBitmapCurrent() const { return DoGetBitmap(State_Current); }
+    wxBitmap GetBitmapFocus() const { return DoGetBitmap(State_Focused); }
+
+
+    // set the margins around the image
+    void SetBitmapMargins(wxCoord x, wxCoord y) { DoSetBitmapMargins(x, y); }
+    void SetBitmapMargins(const wxSize& sz) { DoSetBitmapMargins(sz.x, sz.y); }
+    wxSize GetBitmapMargins() { return DoGetBitmapMargins(); }
+
+    // set the image position relative to the text, i.e. wxLEFT means that the
+    // image is to the left of the text (this is the default)
+    void SetBitmapPosition(wxDirection dir);
+
+
+    // make this button the default button in its top level window
+    //
+    // returns the old default item (possibly NULL)
+    virtual wxWindow *SetDefault();
+
+    // Buttons on MSW can look bad if they are not native colours, because
+    // then they become owner-drawn and not theme-drawn.  Disable it here
+    // in wxButtonBase to make it consistent.
+    virtual bool ShouldInheritColours() const { return false; }
+
+    // returns the default button size for this platform
+    static wxSize GetDefaultSize();
+
+    // wxUniv-compatible and deprecated equivalents to SetBitmapXXX()
+#if WXWIN_COMPATIBILITY_2_8
+    void SetImageLabel(const wxBitmap& bitmap) { SetBitmap(bitmap); }
+    void SetImageMargins(wxCoord x, wxCoord y) { SetBitmapMargins(x, y); }
+#endif // WXWIN_COMPATIBILITY_2_8
+
+    // backwards compatible names for pressed/current bitmaps: they're not
+    // deprecated as there is nothing really wrong with using them and no real
+    // advantage to using the new names but the new names are still preferred
+    wxBitmap GetBitmapSelected() const { return GetBitmapPressed(); }
+    wxBitmap GetBitmapHover() const { return GetBitmapCurrent(); }
+
+    void SetBitmapSelected(const wxBitmap& bitmap) { SetBitmapPressed(bitmap); }
+    void SetBitmapHover(const wxBitmap& bitmap) { SetBitmapCurrent(bitmap); }
+
+
+    // this enum is not part of wx public API, it is public because it is used
+    // in non wxButton-derived classes internally
+    //
+    // also notice that MSW code relies on the values of the enum elements, do
+    // not change them without revising src/msw/button.cpp
+    enum State
+    {
+        State_Normal,
+        State_Current,    // a.k.a. hot or "hovering"
+        State_Pressed,    // a.k.a. "selected" in public API for some reason
+        State_Disabled,
+        State_Focused,
+        State_Max
+    };
+
+    // return true if this button shouldn't show the text label, either because
+    // it doesn't have it or because it was explicitly disabled with wxBU_NOTEXT
+    bool DontShowLabel() const
+    {
+        return HasFlag(wxBU_NOTEXT) || GetLabel().empty();
+    }
+
+    // return true if we do show the label
+    bool ShowsLabel() const
+    {
+        return !DontShowLabel();
+    }
+
+protected:
+    // choose the default border for this window
+    virtual wxBorder GetDefaultBorder() const { return wxBORDER_NONE; }
+
+    virtual bool DoGetAuthNeeded() const { return false; }
+    virtual void DoSetAuthNeeded(bool WXUNUSED(show)) { }
+
+    virtual wxBitmap DoGetBitmap(State WXUNUSED(which)) const
+        { return wxBitmap(); }
+    virtual void DoSetBitmap(const wxBitmap& WXUNUSED(bitmap),
+                             State WXUNUSED(which))
+        { }
+
+    virtual wxSize DoGetBitmapMargins() const
+        { return wxSize(0, 0); }
+
+    virtual void DoSetBitmapMargins(wxCoord WXUNUSED(x), wxCoord WXUNUSED(y))
+        { }
+
+    virtual void DoSetBitmapPosition(wxDirection WXUNUSED(dir))
+        { }
+
+
+    wxDECLARE_NO_COPY_CLASS(wxAbstractButtonBase);
+};
+
+#if defined(__WXMSW__) && !defined(__WXUNIVERSAL__)
+    #include "wx/msw/abstractbutton.h"
+#else
+    // Currently only wxMSW implements the real wxAbstractButton, the other
+    // ports should be updated to do it in the future.
+    class wxAbstractButton : public wxAbstractButtonBase
+    {
+    };
+#endif
+
+#endif // wxHAS_ABSTRACT_BUTTON
+
+#endif // _WX_ABSTRACTBUTTON_H_BASE_
diff --git a/include/wx/button.h b/include/wx/button.h
index 0e987d1..d5cd30f 100644
--- a/include/wx/button.h
+++ b/include/wx/button.h
@@ -2,7 +2,6 @@
 // Name:        wx/button.h
 // Purpose:     wxButtonBase class
 // Author:      Vadim Zetlin
-// Modified by:
 // Created:     15.08.00
 // RCS-ID:      $Id$
 // Copyright:   (c) Vadim Zetlin
@@ -12,190 +11,19 @@
 #ifndef _WX_BUTTON_H_BASE_
 #define _WX_BUTTON_H_BASE_
 
-#include "wx/defs.h"
-
-// ----------------------------------------------------------------------------
-// wxButton flags shared with other classes
-// ----------------------------------------------------------------------------
-
-#if wxUSE_TOGGLEBTN || wxUSE_BUTTON
-
-// These flags affect label alignment
-#define wxBU_LEFT            0x0040
-#define wxBU_TOP             0x0080
-#define wxBU_RIGHT           0x0100
-#define wxBU_BOTTOM          0x0200
-#define wxBU_ALIGN_MASK      ( wxBU_LEFT | wxBU_TOP | wxBU_RIGHT | wxBU_BOTTOM )
-#endif
+#include "wx/abstractbutton.h"
 
 #if wxUSE_BUTTON
 
 // ----------------------------------------------------------------------------
-// wxButton specific flags
-// ----------------------------------------------------------------------------
-
-// These two flags are obsolete
-#define wxBU_NOAUTODRAW      0x0000
-#define wxBU_AUTODRAW        0x0004
-
-// by default, the buttons will be created with some (system dependent)
-// minimal size to make them look nicer, giving this style will make them as
-// small as possible
-#define wxBU_EXACTFIT        0x0001
-
-// this flag can be used to disable using the text label in the button: it is
-// mostly useful when creating buttons showing bitmap and having stock id as
-// without it both the standard label corresponding to the stock id and the
-// bitmap would be shown
-#define wxBU_NOTEXT          0x0002
-
-
-#include "wx/bitmap.h"
-#include "wx/control.h"
-
-extern WXDLLIMPEXP_DATA_CORE(const char) wxButtonNameStr[];
-
-// ----------------------------------------------------------------------------
 // wxButton: a push button
 // ----------------------------------------------------------------------------
 
-class WXDLLIMPEXP_CORE wxButtonBase : public wxControl
+class WXDLLIMPEXP_CORE wxButtonBase : public wxAbstractButton
 {
 public:
     wxButtonBase() { }
 
-    // show the authentication needed symbol on the button: this is currently
-    // only implemented on Windows Vista and newer (on which it shows the UAC
-    // shield symbol)
-    void SetAuthNeeded(bool show = true) { DoSetAuthNeeded(show); }
-    bool GetAuthNeeded() const { return DoGetAuthNeeded(); }
-
-    // show the image in the button in addition to the label: this method is
-    // supported on all (major) platforms
-    void SetBitmap(const wxBitmap& bitmap, wxDirection dir = wxLEFT)
-    {
-        SetBitmapLabel(bitmap);
-        SetBitmapPosition(dir);
-    }
-
-    wxBitmap GetBitmap() const { return DoGetBitmap(State_Normal); }
-
-    // Methods for setting individual images for different states: normal,
-    // selected (meaning pushed or pressed), focused (meaning normal state for
-    // a focused button), disabled or hover (a.k.a. hot or current).
-    //
-    // Remember that SetBitmap() itself must be called before any other
-    // SetBitmapXXX() methods (except for SetBitmapLabel() which is a synonym
-    // for it anyhow) and that all bitmaps passed to these functions should be
-    // of the same size.
-    void SetBitmapLabel(const wxBitmap& bitmap)
-        { DoSetBitmap(bitmap, State_Normal); }
-    void SetBitmapPressed(const wxBitmap& bitmap)
-        { DoSetBitmap(bitmap, State_Pressed); }
-    void SetBitmapDisabled(const wxBitmap& bitmap)
-        { DoSetBitmap(bitmap, State_Disabled); }
-    void SetBitmapCurrent(const wxBitmap& bitmap)
-        { DoSetBitmap(bitmap, State_Current); }
-    void SetBitmapFocus(const wxBitmap& bitmap)
-        { DoSetBitmap(bitmap, State_Focused); }
-
-    wxBitmap GetBitmapLabel() const { return DoGetBitmap(State_Normal); }
-    wxBitmap GetBitmapPressed() const { return DoGetBitmap(State_Pressed); }
-    wxBitmap GetBitmapDisabled() const { return DoGetBitmap(State_Disabled); }
-    wxBitmap GetBitmapCurrent() const { return DoGetBitmap(State_Current); }
-    wxBitmap GetBitmapFocus() const { return DoGetBitmap(State_Focused); }
-
-
-    // set the margins around the image
-    void SetBitmapMargins(wxCoord x, wxCoord y) { DoSetBitmapMargins(x, y); }
-    void SetBitmapMargins(const wxSize& sz) { DoSetBitmapMargins(sz.x, sz.y); }
-    wxSize GetBitmapMargins() { return DoGetBitmapMargins(); }
-
-    // set the image position relative to the text, i.e. wxLEFT means that the
-    // image is to the left of the text (this is the default)
-    void SetBitmapPosition(wxDirection dir);
-
-
-    // make this button the default button in its top level window
-    //
-    // returns the old default item (possibly NULL)
-    virtual wxWindow *SetDefault();
-
-    // Buttons on MSW can look bad if they are not native colours, because
-    // then they become owner-drawn and not theme-drawn.  Disable it here
-    // in wxButtonBase to make it consistent.
-    virtual bool ShouldInheritColours() const { return false; }
-
-    // returns the default button size for this platform
-    static wxSize GetDefaultSize();
-
-    // wxUniv-compatible and deprecated equivalents to SetBitmapXXX()
-#if WXWIN_COMPATIBILITY_2_8
-    void SetImageLabel(const wxBitmap& bitmap) { SetBitmap(bitmap); }
-    void SetImageMargins(wxCoord x, wxCoord y) { SetBitmapMargins(x, y); }
-#endif // WXWIN_COMPATIBILITY_2_8
-
-    // backwards compatible names for pressed/current bitmaps: they're not
-    // deprecated as there is nothing really wrong with using them and no real
-    // advantage to using the new names but the new names are still preferred
-    wxBitmap GetBitmapSelected() const { return GetBitmapPressed(); }
-    wxBitmap GetBitmapHover() const { return GetBitmapCurrent(); }
-
-    void SetBitmapSelected(const wxBitmap& bitmap) { SetBitmapPressed(bitmap); }
-    void SetBitmapHover(const wxBitmap& bitmap) { SetBitmapCurrent(bitmap); }
-
-
-    // this enum is not part of wx public API, it is public because it is used
-    // in non wxButton-derived classes internally
-    //
-    // also notice that MSW code relies on the values of the enum elements, do
-    // not change them without revising src/msw/button.cpp
-    enum State
-    {
-        State_Normal,
-        State_Current,    // a.k.a. hot or "hovering"
-        State_Pressed,    // a.k.a. "selected" in public API for some reason
-        State_Disabled,
-        State_Focused,
-        State_Max
-    };
-
-    // return true if this button shouldn't show the text label, either because
-    // it doesn't have it or because it was explicitly disabled with wxBU_NOTEXT
-    bool DontShowLabel() const
-    {
-        return HasFlag(wxBU_NOTEXT) || GetLabel().empty();
-    }
-
-    // return true if we do show the label
-    bool ShowsLabel() const
-    {
-        return !DontShowLabel();
-    }
-
-protected:
-    // choose the default border for this window
-    virtual wxBorder GetDefaultBorder() const { return wxBORDER_NONE; }
-
-    virtual bool DoGetAuthNeeded() const { return false; }
-    virtual void DoSetAuthNeeded(bool WXUNUSED(show)) { }
-
-    virtual wxBitmap DoGetBitmap(State WXUNUSED(which)) const
-        { return wxBitmap(); }
-    virtual void DoSetBitmap(const wxBitmap& WXUNUSED(bitmap),
-                             State WXUNUSED(which))
-        { }
-
-    virtual wxSize DoGetBitmapMargins() const
-        { return wxSize(0, 0); }
-
-    virtual void DoSetBitmapMargins(wxCoord WXUNUSED(x), wxCoord WXUNUSED(y))
-        { }
-
-    virtual void DoSetBitmapPosition(wxDirection WXUNUSED(dir))
-        { }
-
-
     wxDECLARE_NO_COPY_CLASS(wxButtonBase);
 };
 
@@ -221,5 +49,4 @@ protected:
 
 #endif // wxUSE_BUTTON
 
-#endif
-    // _WX_BUTTON_H_BASE_
+#endif // _WX_BUTTON_H_BASE_
diff --git a/include/wx/msw/abstractbutton.h b/include/wx/msw/abstractbutton.h
index e69de29..20cf968 100644
--- a/include/wx/msw/abstractbutton.h
+++ b/include/wx/msw/abstractbutton.h
@@ -0,0 +1,120 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/msw/abstractbutton.h
+// Purpose:     Windows implementation of the abstract base class for all
+//              buttons
+// Author:      Hans de Ruiter, based largely on original MSW wxButton code
+//              by Julian Smart and Vadim Zeitlin
+// Created:     2011-04-08
+// RCS-ID:      $Id:$
+// Copyright:   (c) Hans de Ruiter, Julian Smart, Vadim Zeitlin
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_ABSTRACTBUTTON_H_
+#define _WX_ABSTRACTBUTTON_H_
+
+#include "wx/msw/wrapwin.h"
+
+class WXDLLIMPEXP_CORE wxAbstractButton : public wxAbstractButtonBase
+{
+public:
+    wxAbstractButton() { Init(); }
+    wxAbstractButton(wxWindow *parent,
+             wxWindowID id,
+             const wxString& label = wxEmptyString,
+             const wxPoint& pos = wxDefaultPosition,
+             const wxSize& size = wxDefaultSize,
+             long style = 0,
+             const wxValidator& validator = wxDefaultValidator,
+             const wxString& name = wxButtonNameStr)
+    {
+        Init();
+
+        Create(parent, id, label, pos, size, style, validator, name);
+    }
+
+    bool Create(wxWindow *parent,
+                wxWindowID id,
+                const wxString& label = wxEmptyString,
+                const wxPoint& pos = wxDefaultPosition,
+                const wxSize& size = wxDefaultSize,
+                long style = 0,
+                const wxValidator& validator = wxDefaultValidator,
+                const wxString& name = wxButtonNameStr);
+
+    virtual ~wxAbstractButton();
+
+    // overridden base class methods
+    virtual void SetLabel(const wxString& label);
+    virtual bool SetBackgroundColour(const wxColour &colour);
+    virtual bool SetForegroundColour(const wxColour &colour);
+
+    // implementation from now on
+    virtual void Command(wxCommandEvent& event);
+    virtual WXLRESULT MSWWindowProc(WXUINT nMsg, WXWPARAM wParam, WXLPARAM lParam);
+    virtual bool MSWCommand(WXUINT param, WXWORD id);
+
+    virtual bool MSWOnDraw(WXDRAWITEMSTRUCT *item);
+
+    // Child classes must provide this.
+    virtual WXDWORD MSWGetStyle(long style, WXDWORD *exstyle) const = 0;
+
+    // returns true if the platform should explicitly apply a theme border
+    virtual bool CanApplyThemeBorder() const { return false; }
+
+protected:
+    // send a notification event, return true if processed
+    virtual bool SendClickEvent() = 0;
+
+    // Get the current button state
+    virtual State GetButtonState(unsigned state);
+
+    // usually overridden base class virtuals
+    virtual wxSize DoGetBestSize() const;
+
+    virtual bool DoGetAuthNeeded() const;
+    virtual void DoSetAuthNeeded(bool show);
+    virtual wxBitmap DoGetBitmap(State which) const;
+    virtual void DoSetBitmap(const wxBitmap& bitmap, State which);
+    virtual wxSize DoGetBitmapMargins() const;
+    virtual void DoSetBitmapMargins(wxCoord x, wxCoord y);
+    virtual void DoSetBitmapPosition(wxDirection dir);
+
+#if wxUSE_MARKUP
+    virtual bool DoSetLabelMarkup(const wxString& markup);
+#endif // wxUSE_MARKUP
+
+    // Increases the passed in size to account for the button image.
+    //
+    // Should only be called if we do have a button, i.e. if m_imageData is
+    // non-NULL.
+    void AdjustForBitmapSize(wxSize& size) const;
+
+    class wxButtonImageData *m_imageData;
+
+#if wxUSE_MARKUP
+    class wxMarkupText *m_markupText;
+#endif // wxUSE_MARKUP
+
+    // true if the UAC symbol is shown
+    bool m_authNeeded;
+
+private:
+    void Init()
+    {
+        m_imageData = NULL;
+#if wxUSE_MARKUP
+        m_markupText = NULL;
+#endif // wxUSE_MARKUP
+        m_authNeeded = false;
+    }
+
+    // Switches button into owner-drawn mode: this is used if we need to draw
+    // something not supported by the native control, such as using non default
+    // colours or a bitmap on pre-XP systems.
+    void MakeOwnerDrawn();
+
+    wxDECLARE_NO_COPY_CLASS(wxAbstractButton);
+};
+
+#endif // _WX_ABSTRACTBUTTON_H_
diff --git a/include/wx/msw/button.h b/include/wx/msw/button.h
index 89e9dbb..e28c734 100644
--- a/include/wx/msw/button.h
+++ b/include/wx/msw/button.h
@@ -45,79 +45,25 @@ public:
 
     virtual ~wxButton();
 
-    virtual wxWindow *SetDefault();
-
-    // overridden base class methods
-    virtual void SetLabel(const wxString& label);
-    virtual bool SetBackgroundColour(const wxColour &colour);
-    virtual bool SetForegroundColour(const wxColour &colour);
-
-    // implementation from now on
-    virtual void Command(wxCommandEvent& event);
     virtual WXLRESULT MSWWindowProc(WXUINT nMsg, WXWPARAM wParam, WXLPARAM lParam);
-    virtual bool MSWCommand(WXUINT param, WXWORD id);
-
-    virtual bool MSWOnDraw(WXDRAWITEMSTRUCT *item);
-    virtual WXDWORD MSWGetStyle(long style, WXDWORD *exstyle) const;
 
-    // returns true if the platform should explicitly apply a theme border
-    virtual bool CanApplyThemeBorder() const { return false; }
+    virtual wxWindow *SetDefault();
 
 protected:
-    // send a notification event, return true if processed
-    bool SendClickEvent();
+    virtual WXDWORD MSWGetStyle(long style, WXDWORD *exstyle) const;
 
     // default button handling
     void SetTmpDefault();
     void UnsetTmpDefault();
 
     // set or unset BS_DEFPUSHBUTTON style
-    static void SetDefaultStyle(wxButton *btn, bool on);
-
-    // usually overridden base class virtuals
-    virtual wxSize DoGetBestSize() const;
+    static void SetDefaultStyle(wxAbstractButton *btn, bool on);
 
-    virtual bool DoGetAuthNeeded() const;
-    virtual void DoSetAuthNeeded(bool show);
-    virtual wxBitmap DoGetBitmap(State which) const;
-    virtual void DoSetBitmap(const wxBitmap& bitmap, State which);
-    virtual wxSize DoGetBitmapMargins() const;
-    virtual void DoSetBitmapMargins(wxCoord x, wxCoord y);
-    virtual void DoSetBitmapPosition(wxDirection dir);
-
-#if wxUSE_MARKUP
-    virtual bool DoSetLabelMarkup(const wxString& markup);
-#endif // wxUSE_MARKUP
-
-    // Increases the passed in size to account for the button image.
-    //
-    // Should only be called if we do have a button, i.e. if m_imageData is
-    // non-NULL.
-    void AdjustForBitmapSize(wxSize& size) const;
-
-    class wxButtonImageData *m_imageData;
-
-#if wxUSE_MARKUP
-    class wxMarkupText *m_markupText;
-#endif // wxUSE_MARKUP
-
-    // true if the UAC symbol is shown
-    bool m_authNeeded;
+    // send a notification event, return true if processed
+    bool SendClickEvent();
 
 private:
-    void Init()
-    {
-        m_imageData = NULL;
-#if wxUSE_MARKUP
-        m_markupText = NULL;
-#endif // wxUSE_MARKUP
-        m_authNeeded = false;
-    }
-
-    // Switches button into owner-drawn mode: this is used if we need to draw
-    // something not supported by the native control, such as using non default
-    // colours or a bitmap on pre-XP systems.
-    void MakeOwnerDrawn();
+    void Init();
 
     wxDECLARE_DYNAMIC_CLASS_NO_COPY(wxButton);
 };
diff --git a/include/wx/msw/tglbtn.h b/include/wx/msw/tglbtn.h
index 5a2984f..bc31d42 100644
--- a/include/wx/msw/tglbtn.h
+++ b/include/wx/msw/tglbtn.h
@@ -3,7 +3,7 @@
 // Purpose:     Declaration of the wxToggleButton class, which implements a
 //              toggle button under wxMSW.
 // Author:      John Norris, minor changes by Axel Schlueter
-// Modified by:
+// Modified by: Hans de Ruiter
 // Created:     08.02.01
 // RCS-ID:      $Id$
 // Copyright:   (c) 2000 Johnny C. Norris II
@@ -13,76 +13,81 @@
 #ifndef _WX_TOGGLEBUTTON_H_
 #define _WX_TOGGLEBUTTON_H_
 
-#include "wx/bitmap.h"
-
-//-----------------------------------------------------------------------------
-// wxBitmapToggleButton
-//-----------------------------------------------------------------------------
-
-
-class WXDLLIMPEXP_CORE wxBitmapToggleButton: public wxToggleButtonBase
+// Checkbox item (single checkbox)
+class WXDLLIMPEXP_CORE wxToggleButton : public wxToggleButtonBase
 {
 public:
-    // construction/destruction
-    wxBitmapToggleButton() { Init(); }
-    wxBitmapToggleButton(wxWindow *parent,
+    wxToggleButton()
+    {
+        Init();
+    }
+
+    wxToggleButton(wxWindow *parent,
                    wxWindowID id,
-                   const wxBitmap& label,
+                   const wxString& label,
                    const wxPoint& pos = wxDefaultPosition,
                    const wxSize& size = wxDefaultSize,
                    long style = 0,
                    const wxValidator& validator = wxDefaultValidator,
                    const wxString& name = wxCheckBoxNameStr)
     {
+        Init();
         Create(parent, id, label, pos, size, style, validator, name);
     }
 
-    // Create the control
     bool Create(wxWindow *parent,
                 wxWindowID id,
-                const wxBitmap& label,
+                const wxString& label,
                 const wxPoint& pos = wxDefaultPosition,
-                const wxSize& size = wxDefaultSize, long style = 0,
+                const wxSize& size = wxDefaultSize,
+                long style = 0,
                 const wxValidator& validator = wxDefaultValidator,
                 const wxString& name = wxCheckBoxNameStr);
 
-    // Get/set the value
-    void SetValue(bool state);
-    bool GetValue() const;
+    virtual void SetValue(bool value);
+    virtual bool GetValue() const ;
+
+    virtual void Command(wxCommandEvent& event);
 
-    // Set the label
-    virtual void SetLabel(const wxString& label) { wxControl::SetLabel(label); }
-    virtual void SetLabel(const wxBitmap& label);
-    bool Enable(bool enable = true);
+    // returns true if the platform should explicitly apply a theme border
+    virtual bool CanApplyThemeBorder() const { return false; }
+
+    virtual bool MSWCommand(WXUINT param, WXWORD id);
 
 protected:
-    void Init();
+    virtual wxBorder GetDefaultBorder() const { return wxBORDER_NONE; }
 
-    wxBitmap  m_bitmap;
-    wxBitmap  m_disabledBitmap;
-    bool      m_capturing;
-    bool      m_depressed,m_oldValue;
+    virtual WXDWORD MSWGetStyle(long flags, WXDWORD *exstyle = NULL) const;
 
-    void OnPaint(wxPaintEvent &event);
-    void OnMouse(wxMouseEvent &event);
-    void OnChar(wxKeyEvent &event);
-    void OnSize(wxSizeEvent &event);
+    virtual bool SendClickEvent();
 
-    virtual wxSize DoGetBestSize() const;
+    virtual State GetButtonState(UINT state);
 
 private:
-    DECLARE_EVENT_TABLE()
-    DECLARE_DYNAMIC_CLASS(wxBitmapToggleButton)
+
+    void Init();
+
+    // Flag indicating whether the toggle button is selected or not
+    // Unfortunately the BS_OWNERDRAW overrides all of the others,
+    // and we need to draw buttons with bitmaps ourselves
+    bool selected;
+
+    DECLARE_DYNAMIC_CLASS_NO_COPY(wxToggleButton)
 };
 
-// Checkbox item (single checkbox)
-class WXDLLIMPEXP_CORE wxToggleButton : public wxToggleButtonBase
+
+//-----------------------------------------------------------------------------
+// wxBitmapToggleButton
+//-----------------------------------------------------------------------------
+
+class WXDLLIMPEXP_CORE wxBitmapToggleButton: public wxToggleButton
 {
 public:
-    wxToggleButton() {}
-    wxToggleButton(wxWindow *parent,
+    // construction/destruction
+    wxBitmapToggleButton() { Init(); }
+    wxBitmapToggleButton(wxWindow *parent,
                    wxWindowID id,
-                   const wxString& label,
+                   const wxBitmap& label,
                    const wxPoint& pos = wxDefaultPosition,
                    const wxSize& size = wxDefaultSize,
                    long style = 0,
@@ -92,35 +97,21 @@ public:
         Create(parent, id, label, pos, size, style, validator, name);
     }
 
+    // Create the control
     bool Create(wxWindow *parent,
                 wxWindowID id,
-                const wxString& label,
+                const wxBitmap& label,
                 const wxPoint& pos = wxDefaultPosition,
-                const wxSize& size = wxDefaultSize,
-                long style = 0,
+                const wxSize& size = wxDefaultSize, long style = 0,
                 const wxValidator& validator = wxDefaultValidator,
                 const wxString& name = wxCheckBoxNameStr);
 
-    virtual void SetValue(bool value);
-    virtual bool GetValue() const ;
-
-    virtual void SetLabel(const wxString& label);
-
-    virtual bool MSWCommand(WXUINT param, WXWORD id);
-    virtual void Command(wxCommandEvent& event);
-
-    // returns true if the platform should explicitly apply a theme border
-    virtual bool CanApplyThemeBorder() const { return false; }
-
-protected:
-    virtual wxBorder GetDefaultBorder() const { return wxBORDER_NONE; }
-    virtual wxSize DoGetBestSize() const;
-
-    virtual WXDWORD MSWGetStyle(long flags, WXDWORD *exstyle = NULL) const;
-
 private:
-    DECLARE_DYNAMIC_CLASS_NO_COPY(wxToggleButton)
+    void Init();
+
+    DECLARE_DYNAMIC_CLASS_NO_COPY(wxBitmapToggleButton)
 };
 
+
 #endif // _WX_TOGGLEBUTTON_H_
 
diff --git a/include/wx/tglbtn.h b/include/wx/tglbtn.h
index bf455bf..fcb6785 100644
--- a/include/wx/tglbtn.h
+++ b/include/wx/tglbtn.h
@@ -18,7 +18,7 @@
 #if wxUSE_TOGGLEBTN
 
 #include "wx/event.h"
-#include "wx/control.h"     // base class
+#include "wx/abstractbutton.h"
 
 extern WXDLLIMPEXP_DATA_CORE(const char) wxCheckBoxNameStr[];
 
@@ -28,7 +28,7 @@ wxDECLARE_EXPORTED_EVENT( WXDLLIMPEXP_CORE, wxEVT_COMMAND_TOGGLEBUTTON_CLICKED,
 // wxToggleButtonBase
 // ----------------------------------------------------------------------------
 
-class WXDLLIMPEXP_CORE wxToggleButtonBase : public wxControl
+class WXDLLIMPEXP_CORE wxToggleButtonBase : public wxAbstractButton
 {
 public:
     wxToggleButtonBase() { }
diff --git a/src/common/abstractbuttoncmn.cpp b/src/common/abstractbuttoncmn.cpp
index e69de29..3d66fa5 100644
--- a/src/common/abstractbuttoncmn.cpp
+++ b/src/common/abstractbuttoncmn.cpp
@@ -0,0 +1,61 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        src/common/abstractbuttoncmn.cpp
+// Purpose:     Abstract base class for all buttons
+// Author:      Hans de Ruiter
+// Created:     2011-04-08
+// RCS-ID:      $Id:$
+// Copyright:   (c) Hans de Ruiter
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+// ============================================================================
+// declarations
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// headers
+// ----------------------------------------------------------------------------
+
+// For compilers that support precompilation, includes "wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#include "wx/abstractbutton.h"
+
+#ifdef wxHAS_ABSTRACT_BUTTON
+
+#ifndef WX_PRECOMP
+    #include "wx/toplevel.h"
+#endif //WX_PRECOMP
+
+// ============================================================================
+// implementation
+// ============================================================================
+
+wxWindow *wxAbstractButtonBase::SetDefault()
+{
+    wxTopLevelWindow * const
+        tlw = wxDynamicCast(wxGetTopLevelParent(this), wxTopLevelWindow);
+
+    wxCHECK_MSG( tlw, NULL, wxT("button without top level window?") );
+
+    return tlw->SetDefaultItem(this);
+}
+
+void wxAbstractButtonBase::SetBitmapPosition(wxDirection dir)
+{
+    wxASSERT_MSG( !(dir & ~wxDIRECTION_MASK), "non-direction flag used" );
+    wxASSERT_MSG( !!(dir & wxLEFT) +
+                    !!(dir & wxRIGHT) +
+                      !!(dir & wxTOP) +
+                       !!(dir & wxBOTTOM) == 1,
+                   "exactly one direction flag must be set" );
+
+    DoSetBitmapPosition(dir);
+
+}
+
+#endif // wxHAS_ABSTRACT_BUTTON
diff --git a/src/common/btncmn.cpp b/src/common/btncmn.cpp
index f8be59a..08457fc 100644
--- a/src/common/btncmn.cpp
+++ b/src/common/btncmn.cpp
@@ -27,7 +27,6 @@
 
 #ifndef WX_PRECOMP
     #include "wx/button.h"
-    #include "wx/toplevel.h"
 #endif //WX_PRECOMP
 
 extern WXDLLEXPORT_DATA(const char) wxButtonNameStr[] = "button";
@@ -72,7 +71,7 @@ wxFLAGS_MEMBER(wxBU_BOTTOM)
 wxFLAGS_MEMBER(wxBU_EXACTFIT)
 wxEND_FLAGS( wxButtonStyle )
 
-wxIMPLEMENT_DYNAMIC_CLASS_XTI(wxButton, wxControl, "wx/button.h")
+wxIMPLEMENT_DYNAMIC_CLASS_XTI(wxButton, wxAbstractButton, "wx/button.h")
 
 wxBEGIN_PROPERTIES_TABLE(wxButton)
 wxEVENT_PROPERTY( Click, wxEVT_COMMAND_BUTTON_CLICKED, wxCommandEvent )
@@ -92,31 +91,4 @@ wxEMPTY_HANDLERS_TABLE(wxButton)
 wxCONSTRUCTOR_6( wxButton, wxWindow*, Parent, wxWindowID, Id, wxString, \
                 Label, wxPoint, Position, wxSize, Size, long, WindowStyle )
 
-
-// ============================================================================
-// implementation
-// ============================================================================
-
-wxWindow *wxButtonBase::SetDefault()
-{
-    wxTopLevelWindow * const
-        tlw = wxDynamicCast(wxGetTopLevelParent(this), wxTopLevelWindow);
-
-    wxCHECK_MSG( tlw, NULL, wxT("button without top level window?") );
-
-    return tlw->SetDefaultItem(this);
-}
-
-void wxButtonBase::SetBitmapPosition(wxDirection dir)
-{
-    wxASSERT_MSG( !(dir & ~wxDIRECTION_MASK), "non-direction flag used" );
-    wxASSERT_MSG( !!(dir & wxLEFT) +
-                    !!(dir & wxRIGHT) +
-                      !!(dir & wxTOP) +
-                       !!(dir & wxBOTTOM) == 1,
-                   "exactly one direction flag must be set" );
-
-    DoSetBitmapPosition(dir);
-
-}
 #endif // wxUSE_BUTTON
diff --git a/src/msw/abstractbutton.cpp b/src/msw/abstractbutton.cpp
index e69de29..3e0ac23 100644
--- a/src/msw/abstractbutton.cpp
+++ b/src/msw/abstractbutton.cpp
@@ -0,0 +1,1342 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        src/msw/abstractbutton.cpp
+// Purpose:     wxAbstractButton implementation for wxMSW.
+// Author:      Hans de Ruiter, largely based on code of the original
+//              wxButton by Julian Smart and Vadim Zeitlin.
+// Created:     2011-04-08
+// RCS-ID:      $Id:$
+// Copyright:   (c) Hans de Ruiter, Julian Smart, Vadim Zeitlin
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+// ============================================================================
+// declarations
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// headers
+// ----------------------------------------------------------------------------
+
+// For compilers that support precompilation, includes "wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#include "wx/abstractbutton.h"
+
+#ifdef wxHAS_ABSTRACT_BUTTON
+
+#ifndef WX_PRECOMP
+    #include "wx/app.h"
+    #include "wx/brush.h"
+    #include "wx/panel.h"
+    #include "wx/bmpbuttn.h"
+    #include "wx/settings.h"
+    #include "wx/dcscreen.h"
+    #include "wx/dcclient.h"
+    #include "wx/toplevel.h"
+    #include "wx/msw/wrapcctl.h"
+    #include "wx/msw/private.h"
+    #include "wx/msw/missing.h"
+#endif
+
+#include "wx/imaglist.h"
+#include "wx/stockitem.h"
+#include "wx/msw/private/button.h"
+#include "wx/msw/private/dc.h"
+#include "wx/private/window.h"
+
+#if wxUSE_MARKUP
+    #include "wx/generic/private/markuptext.h"
+#endif // wxUSE_MARKUP
+
+using namespace wxMSWImpl;
+
+#if wxUSE_UXTHEME
+    #include "wx/msw/uxtheme.h"
+
+    // no need to include tmschema.h
+    #ifndef BP_PUSHBUTTON
+        #define BP_PUSHBUTTON 1
+
+        #define PBS_NORMAL    1
+        #define PBS_HOT       2
+        #define PBS_PRESSED   3
+        #define PBS_DISABLED  4
+        #define PBS_DEFAULTED 5
+
+        #define TMT_CONTENTMARGINS 3602
+    #endif
+
+    // provide the necessary declarations ourselves if they're missing from
+    // headers
+    #ifndef BCM_SETIMAGELIST
+        #define BCM_SETIMAGELIST    0x1602
+        #define BCM_SETTEXTMARGIN   0x1604
+
+        enum
+        {
+            BUTTON_IMAGELIST_ALIGN_LEFT,
+            BUTTON_IMAGELIST_ALIGN_RIGHT,
+            BUTTON_IMAGELIST_ALIGN_TOP,
+            BUTTON_IMAGELIST_ALIGN_BOTTOM
+        };
+
+        struct BUTTON_IMAGELIST
+        {
+            HIMAGELIST himl;
+            RECT margin;
+            UINT uAlign;
+        };
+    #endif
+#endif // wxUSE_UXTHEME
+
+#ifndef WM_THEMECHANGED
+    #define WM_THEMECHANGED     0x031A
+#endif
+
+#ifndef ODS_NOACCEL
+    #define ODS_NOACCEL         0x0100
+#endif
+
+#ifndef ODS_NOFOCUSRECT
+    #define ODS_NOFOCUSRECT     0x0200
+#endif
+
+#ifndef DT_HIDEPREFIX
+    #define DT_HIDEPREFIX       0x00100000
+#endif
+
+// set the value for BCM_SETSHIELD (for the UAC shield) if it's not defined in
+// the header
+#ifndef BCM_SETSHIELD
+    #define BCM_SETSHIELD       0x160c
+#endif
+
+#if wxUSE_UXTHEME
+extern wxWindowMSW *wxWindowBeingErased; // From src/msw/window.cpp
+#endif // wxUSE_UXTHEME
+
+// ----------------------------------------------------------------------------
+// button image data
+// ----------------------------------------------------------------------------
+
+// we use different data classes for owner drawn buttons and for themed XP ones
+
+class wxButtonImageData
+{
+public:
+    wxButtonImageData() { }
+    virtual ~wxButtonImageData() { }
+
+    virtual wxBitmap GetBitmap(wxAbstractButton::State which) const = 0;
+    virtual void SetBitmap(const wxBitmap& bitmap, wxAbstractButton::State which) = 0;
+
+    virtual wxSize GetBitmapMargins() const = 0;
+    virtual void SetBitmapMargins(wxCoord x, wxCoord y) = 0;
+
+    virtual wxDirection GetBitmapPosition() const = 0;
+    virtual void SetBitmapPosition(wxDirection dir) = 0;
+
+private:
+    wxDECLARE_NO_COPY_CLASS(wxButtonImageData);
+};
+
+namespace
+{
+
+// the gap between button edge and the interior area used by Windows for the
+// standard buttons
+const int OD_BUTTON_MARGIN = 4;
+
+class wxODButtonImageData : public wxButtonImageData
+{
+public:
+    wxODButtonImageData(wxAbstractButton *btn, const wxBitmap& bitmap)
+    {
+        SetBitmap(bitmap, wxButton::State_Normal);
+        SetBitmap(bitmap.ConvertToDisabled(), wxButton::State_Disabled);
+
+        m_dir = wxLEFT;
+
+        // we use margins when we have both bitmap and text, but when we have
+        // only the bitmap it should take up the entire button area
+        if ( btn->ShowsLabel() )
+        {
+            m_margin.x = btn->GetCharWidth();
+            m_margin.y = btn->GetCharHeight() / 2;
+        }
+    }
+
+    virtual wxBitmap GetBitmap(wxAbstractButton::State which) const
+    {
+        return m_bitmaps[which];
+    }
+
+    virtual void SetBitmap(const wxBitmap& bitmap, wxAbstractButton::State which)
+    {
+        m_bitmaps[which] = bitmap;
+    }
+
+    virtual wxSize GetBitmapMargins() const
+    {
+        return m_margin;
+    }
+
+    virtual void SetBitmapMargins(wxCoord x, wxCoord y)
+    {
+        m_margin = wxSize(x, y);
+    }
+
+    virtual wxDirection GetBitmapPosition() const
+    {
+        return m_dir;
+    }
+
+    virtual void SetBitmapPosition(wxDirection dir)
+    {
+        m_dir = dir;
+    }
+
+private:
+    // just store the values passed to us to be able to retrieve them later
+    // from the drawing code
+    wxBitmap m_bitmaps[wxAbstractButton::State_Max];
+    wxSize m_margin;
+    wxDirection m_dir;
+
+    wxDECLARE_NO_COPY_CLASS(wxODButtonImageData);
+};
+
+#if wxUSE_UXTHEME
+
+// somehow the margin is one pixel greater than the value returned by
+// GetThemeMargins() call
+const int XP_BUTTON_EXTRA_MARGIN = 1;
+
+class wxXPButtonImageData : public wxButtonImageData
+{
+public:
+    // we must be constructed with the size of our images as we need to create
+    // the image list
+    wxXPButtonImageData(wxAbstractButton *btn, const wxBitmap& bitmap)
+        : m_iml(bitmap.GetWidth(), bitmap.GetHeight(), true /* use mask */,
+                wxButton::State_Max),
+          m_hwndBtn(GetHwndOf(btn))
+    {
+        // initialize all bitmaps except for the disabled one to normal state
+        for ( int n = 0; n < wxAbstractButton::State_Max; n++ )
+        {
+            m_iml.Add(n == wxAbstractButton::State_Disabled ? bitmap.ConvertToDisabled()
+                                                    : bitmap);
+        }
+
+        m_data.himl = GetHimagelistOf(&m_iml);
+
+        // no margins by default
+        m_data.margin.left =
+        m_data.margin.right =
+        m_data.margin.top =
+        m_data.margin.bottom = 0;
+
+        // use default alignment
+        m_data.uAlign = BUTTON_IMAGELIST_ALIGN_LEFT;
+
+        UpdateImageInfo();
+    }
+
+    virtual wxBitmap GetBitmap(wxAbstractButton::State which) const
+    {
+        return m_iml.GetBitmap(which);
+    }
+
+    virtual void SetBitmap(const wxBitmap& bitmap, wxAbstractButton::State which)
+    {
+        m_iml.Replace(which, bitmap);
+
+        UpdateImageInfo();
+    }
+
+    virtual wxSize GetBitmapMargins() const
+    {
+        return wxSize(m_data.margin.left, m_data.margin.top);
+    }
+
+    virtual void SetBitmapMargins(wxCoord x, wxCoord y)
+    {
+        RECT& margin = m_data.margin;
+        margin.left =
+        margin.right = x;
+        margin.top =
+        margin.bottom = y;
+
+        if ( !::SendMessage(m_hwndBtn, BCM_SETTEXTMARGIN, 0, (LPARAM)&margin) )
+        {
+            wxLogDebug("SendMessage(BCM_SETTEXTMARGIN) failed");
+        }
+    }
+
+    virtual wxDirection GetBitmapPosition() const
+    {
+        switch ( m_data.uAlign )
+        {
+            default:
+                wxFAIL_MSG( "invalid image alignment" );
+                // fall through
+
+            case BUTTON_IMAGELIST_ALIGN_LEFT:
+                return wxLEFT;
+
+            case BUTTON_IMAGELIST_ALIGN_RIGHT:
+                return wxRIGHT;
+
+            case BUTTON_IMAGELIST_ALIGN_TOP:
+                return wxTOP;
+
+            case BUTTON_IMAGELIST_ALIGN_BOTTOM:
+                return wxBOTTOM;
+        }
+    }
+
+    virtual void SetBitmapPosition(wxDirection dir)
+    {
+        UINT alignNew;
+        switch ( dir )
+        {
+            default:
+                wxFAIL_MSG( "invalid direction" );
+                // fall through
+
+            case wxLEFT:
+                alignNew = BUTTON_IMAGELIST_ALIGN_LEFT;
+                break;
+
+            case wxRIGHT:
+                alignNew = BUTTON_IMAGELIST_ALIGN_RIGHT;
+                break;
+
+            case wxTOP:
+                alignNew = BUTTON_IMAGELIST_ALIGN_TOP;
+                break;
+
+            case wxBOTTOM:
+                alignNew = BUTTON_IMAGELIST_ALIGN_BOTTOM;
+                break;
+        }
+
+        if ( alignNew != m_data.uAlign )
+        {
+            m_data.uAlign = alignNew;
+            UpdateImageInfo();
+        }
+    }
+
+private:
+    void UpdateImageInfo()
+    {
+        if ( !::SendMessage(m_hwndBtn, BCM_SETIMAGELIST, 0, (LPARAM)&m_data) )
+        {
+            wxLogDebug("SendMessage(BCM_SETIMAGELIST) failed");
+        }
+    }
+
+    // we store image list separately to be able to use convenient wxImageList
+    // methods instead of working with raw HIMAGELIST
+    wxImageList m_iml;
+
+    // store the rest of the data in BCM_SETIMAGELIST-friendly form
+    BUTTON_IMAGELIST m_data;
+
+    // the button we're associated with
+    const HWND m_hwndBtn;
+
+
+    wxDECLARE_NO_COPY_CLASS(wxXPButtonImageData);
+};
+
+#endif // wxUSE_UXTHEME
+
+} // anonymous namespace
+
+// ----------------------------------------------------------------------------
+// macros
+// ----------------------------------------------------------------------------
+
+// ============================================================================
+// implementation
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// helper functions from wx/msw/private/button.h
+// ----------------------------------------------------------------------------
+
+void wxMSWButton::UpdateMultilineStyle(HWND hwnd, const wxString& label)
+{
+    // update BS_MULTILINE style depending on the new label (resetting it
+    // doesn't seem to do anything very useful but it shouldn't hurt and we do
+    // have to set it whenever the label becomes multi line as otherwise it
+    // wouldn't be shown correctly as we don't use BS_MULTILINE when creating
+    // the control unless it already has new lines in its label)
+    long styleOld = ::GetWindowLong(hwnd, GWL_STYLE),
+         styleNew;
+    if ( label.find(wxT('\n')) != wxString::npos )
+        styleNew = styleOld | BS_MULTILINE;
+    else
+        styleNew = styleOld & ~BS_MULTILINE;
+
+    if ( styleNew != styleOld )
+        ::SetWindowLong(hwnd, GWL_STYLE, styleNew);
+}
+
+wxSize wxMSWButton::GetFittingSize(wxWindow *win,
+                                   const wxSize& sizeLabel,
+                                   int flags)
+{
+    // FIXME: this is pure guesswork, need to retrieve the real button margins
+    wxSize sizeBtn = sizeLabel;
+
+    sizeBtn.x += 3*win->GetCharWidth();
+    sizeBtn.y += win->GetCharHeight()/2;
+
+    // account for the shield UAC icon if we have it
+    if ( flags & Size_AuthNeeded )
+        sizeBtn.x += wxSystemSettings::GetMetric(wxSYS_SMALLICON_X);
+
+    return sizeBtn;
+}
+
+wxSize wxMSWButton::ComputeBestFittingSize(wxControl *btn, int flags)
+{
+    wxClientDC dc(btn);
+
+    wxSize sizeBtn;
+    dc.GetMultiLineTextExtent(btn->GetLabelText(), &sizeBtn.x, &sizeBtn.y);
+
+    return GetFittingSize(btn, sizeBtn, flags);
+}
+
+wxSize wxMSWButton::IncreaseToStdSizeAndCache(wxControl *btn, const wxSize& size)
+{
+    wxSize sizeBtn(size);
+
+    // All buttons have at least the standard height and, unless the user
+    // explicitly wants them to be as small as possible and used wxBU_EXACTFIT
+    // style to indicate this, of at least the standard width too.
+    //
+    // Notice that we really want to make all buttons equally high, otherwise
+    // they look ugly and the existing code using wxBU_EXACTFIT only uses it to
+    // control width and not height.
+
+    // The 50x14 button size is documented in the "Recommended sizing and
+    // spacing" section of MSDN layout article.
+    //
+    // Note that we intentionally don't use GetDefaultSize() here, because
+    // it's inexact -- dialog units depend on this dialog's font.
+    const wxSize sizeDef = btn->ConvertDialogToPixels(wxSize(50, 14));
+    if ( !btn->HasFlag(wxBU_EXACTFIT) )
+    {
+        if ( sizeBtn.x < sizeDef.x )
+            sizeBtn.x = sizeDef.x;
+    }
+    if ( sizeBtn.y < sizeDef.y )
+        sizeBtn.y = sizeDef.y;
+
+    btn->CacheBestSize(sizeBtn);
+
+    return sizeBtn;
+}
+
+// ----------------------------------------------------------------------------
+// creation/destruction
+// ----------------------------------------------------------------------------
+
+bool wxAbstractButton::Create(wxWindow *parent,
+                      wxWindowID id,
+                      const wxString& lbl,
+                      const wxPoint& pos,
+                      const wxSize& size,
+                      long style,
+                      const wxValidator& validator,
+                      const wxString& name)
+{
+    wxString label(lbl);
+    if (label.empty() && wxIsStockID(id))
+    {
+        // On Windows, some buttons aren't supposed to have mnemonics
+        label = wxGetStockLabel
+                (
+                    id,
+                    id == wxID_OK || id == wxID_CANCEL || id == wxID_CLOSE
+                        ? wxSTOCK_NOFLAGS
+                        : wxSTOCK_WITH_MNEMONIC
+                );
+    }
+
+    if ( !CreateControl(parent, id, pos, size, style, validator, name) )
+        return false;
+
+    WXDWORD exstyle;
+    WXDWORD msStyle = MSWGetStyle(style, &exstyle);
+
+    // if the label contains several lines we must explicitly tell the button
+    // about it or it wouldn't draw it correctly ("\n"s would just appear as
+    // black boxes)
+    //
+    // NB: we do it here and not in MSWGetStyle() because we need the label
+    //     value and the label is not set yet when MSWGetStyle() is called
+    msStyle |= wxMSWButton::GetMultilineStyle(label);
+
+    return MSWCreateControl(wxT("BUTTON"), msStyle, pos, size, label, exstyle);
+}
+
+wxAbstractButton::~wxAbstractButton()
+{
+    delete m_imageData;
+#if wxUSE_MARKUP
+    delete m_markupText;
+#endif // wxUSE_MARKUP
+}
+
+// ----------------------------------------------------------------------------
+// flags
+// ----------------------------------------------------------------------------
+
+void wxAbstractButton::SetLabel(const wxString& label)
+{
+    wxMSWButton::UpdateMultilineStyle(GetHwnd(), label);
+
+    wxAbstractButtonBase::SetLabel(label);
+
+#if wxUSE_MARKUP
+    // If we have a plain text label, we shouldn't be using markup any longer.
+    if ( m_markupText )
+    {
+        delete m_markupText;
+        m_markupText = NULL;
+
+        // Unfortunately we don't really know whether we can reset the button
+        // to be non-owner-drawn or not: if we had made it owner-drawn just
+        // because of a call to SetLabelMarkup(), we could, but not if there
+        // were [also] calls to Set{Fore,Back}groundColour(). If it's really a
+        // problem to have button remain owner-drawn forever just because it
+        // had markup label once, we should record the reason for our current
+        // owner-drawnness and check it here.
+    }
+#endif // wxUSE_MARKUP
+}
+
+// ----------------------------------------------------------------------------
+// size management including autosizing
+// ----------------------------------------------------------------------------
+
+void wxAbstractButton::AdjustForBitmapSize(wxSize &size) const
+{
+    wxCHECK_RET( m_imageData, wxT("shouldn't be called if no image") );
+
+    // account for the bitmap size
+    const wxSize sizeBmp = m_imageData->GetBitmap(State_Normal).GetSize();
+    const wxDirection dirBmp = m_imageData->GetBitmapPosition();
+    if ( dirBmp == wxLEFT || dirBmp == wxRIGHT )
+    {
+        size.x += sizeBmp.x;
+        if ( sizeBmp.y > size.y )
+            size.y = sizeBmp.y;
+    }
+    else // bitmap on top/below the text
+    {
+        size.y += sizeBmp.y;
+        if ( sizeBmp.x > size.x )
+            size.x = sizeBmp.x;
+    }
+
+    // account for the user-specified margins
+    size += 2*m_imageData->GetBitmapMargins();
+
+    // and also for the margins we always add internally (unless we have no
+    // border at all in which case the button has exactly the same size as
+    // bitmap and so no margins should be used)
+    if ( !HasFlag(wxBORDER_NONE) )
+    {
+        int marginH = 0,
+            marginV = 0;
+#if wxUSE_UXTHEME
+        if ( wxUxThemeEngine::GetIfActive() )
+        {
+            wxUxThemeHandle theme(const_cast<wxAbstractButton *>(this), L"BUTTON");
+
+            MARGINS margins;
+            wxUxThemeEngine::Get()->GetThemeMargins(theme, NULL,
+                                                    BP_PUSHBUTTON,
+                                                    PBS_NORMAL,
+                                                    TMT_CONTENTMARGINS,
+                                                    NULL,
+                                                    &margins);
+
+            // XP doesn't draw themed buttons correctly when the client
+            // area is smaller than 8x8 - enforce this minimum size for
+            // small bitmaps
+            size.IncTo(wxSize(8, 8));
+
+            marginH = margins.cxLeftWidth + margins.cxRightWidth
+                        + 2*XP_BUTTON_EXTRA_MARGIN;
+            marginV = margins.cyTopHeight + margins.cyBottomHeight
+                        + 2*XP_BUTTON_EXTRA_MARGIN;
+        }
+        else
+#endif // wxUSE_UXTHEME
+        {
+            marginH =
+            marginV = OD_BUTTON_MARGIN;
+        }
+
+        size.IncBy(marginH, marginV);
+    }
+}
+
+// return the button state using both the ODS_XXX flags specified in state
+// parameter and the current button state
+wxAbstractButtonBase::State wxAbstractButton::GetButtonState(unsigned state)
+{
+    if ( state & ODS_DISABLED )
+        return wxButton::State_Disabled;
+
+    if ( state & ODS_SELECTED || state & ODS_CHECKED )
+        return wxButton::State_Pressed;
+
+    if ( HasCapture() || IsMouseInWindow() )
+        return wxButton::State_Current;
+
+    if ( state & ODS_FOCUS )
+        return wxButton::State_Focused;
+
+    return wxButton::State_Normal;
+}
+
+wxSize wxAbstractButton::DoGetBestSize() const
+{
+    wxAbstractButton * const self = const_cast<wxAbstractButton *>(this);
+
+    wxSize size;
+
+    // Account for the text part if we have it.
+    if ( ShowsLabel() )
+    {
+        int flags = 0;
+        if ( GetAuthNeeded() )
+            flags |= wxMSWButton::Size_AuthNeeded;
+
+#if wxUSE_MARKUP
+        if ( m_markupText )
+        {
+            wxClientDC dc(self);
+            size = wxMSWButton::GetFittingSize(self,
+                                               m_markupText->Measure(dc),
+                                               flags);
+        }
+        else // Normal plain text (but possibly multiline) label.
+#endif // wxUSE_MARKUP
+        {
+            size = wxMSWButton::ComputeBestFittingSize(self, flags);
+        }
+    }
+
+    if ( m_imageData )
+        AdjustForBitmapSize(size);
+
+    return wxMSWButton::IncreaseToStdSizeAndCache(self, size);
+}
+
+/* static */
+wxSize wxAbstractButtonBase::GetDefaultSize()
+{
+    static wxSize s_sizeBtn;
+
+    if ( s_sizeBtn.x == 0 )
+    {
+        wxScreenDC dc;
+        dc.SetFont(wxSystemSettings::GetFont(wxSYS_DEFAULT_GUI_FONT));
+
+        // The size of a standard button in the dialog units is 50x14,
+        // translate this to pixels.
+        //
+        // Windows' computes dialog units using average character width over
+        // upper- and lower-case ASCII alphabet and not using the average
+        // character width metadata stored in the font; see
+        // http://support.microsoft.com/default.aspx/kb/145994 for detailed
+        // discussion.
+        //
+        // NB: wxMulDivInt32() is used, because it correctly rounds the result
+
+        const wxSize base = wxPrivate::GetAverageASCIILetterSize(dc);
+        s_sizeBtn.x = wxMulDivInt32(50, base.x, 4);
+        s_sizeBtn.y = wxMulDivInt32(14, base.y, 8);
+    }
+
+    return s_sizeBtn;
+}
+
+// ----------------------------------------------------------------------------
+// helpers
+// ----------------------------------------------------------------------------
+
+void wxAbstractButton::Command(wxCommandEvent & event)
+{
+    ProcessCommand(event);
+}
+
+// ----------------------------------------------------------------------------
+// event/message handlers
+// ----------------------------------------------------------------------------
+
+bool wxAbstractButton::MSWCommand(WXUINT param, WXWORD WXUNUSED(id))
+{
+    bool processed = false;
+    switch ( param )
+    {
+        // NOTE: Apparently older versions (NT 4?) of the common controls send
+        //       BN_DOUBLECLICKED but not a second BN_CLICKED for owner-drawn
+        //       buttons, so in order to send two EVT_BUTTON events we should
+        //       catch both types.  Currently (Feb 2003) up-to-date versions of
+        //       win98, win2k and winXP all send two BN_CLICKED messages for
+        //       all button types, so we don't catch BN_DOUBLECLICKED anymore
+        //       in order to not get 3 EVT_BUTTON events.  If this is a problem
+        //       then we need to figure out which version of the comctl32 changed
+        //       this behaviour and test for it.
+
+        case 1:                     // message came from an accelerator
+        case BN_CLICKED:            // normal buttons send this
+            processed = SendClickEvent();
+            break;
+    }
+
+    return processed;
+}
+
+WXLRESULT wxAbstractButton::MSWWindowProc(WXUINT nMsg, WXWPARAM wParam, WXLPARAM lParam)
+{
+    if ( nMsg == WM_LBUTTONDBLCLK )
+    {
+        // emulate a click event to force an owner-drawn button to change its
+        // appearance - without this, it won't do it
+        (void)wxControl::MSWWindowProc(WM_LBUTTONDOWN, wParam, lParam);
+
+        // and continue with processing the message normally as well
+    }
+#if wxUSE_UXTHEME
+    else if ( nMsg == WM_THEMECHANGED )
+    {
+        // need to recalculate the best size here
+        // as the theme size might have changed
+        InvalidateBestSize();
+    }
+#endif // wxUSE_UXTHEME
+    // must use m_mouseInWindow here instead of IsMouseInWindow()
+    // since we need to know the first time the mouse enters the window
+    // and IsMouseInWindow() would return true in this case
+    else if ( (nMsg == WM_MOUSEMOVE && !m_mouseInWindow) ||
+                nMsg == WM_MOUSELEAVE )
+    {
+        if (
+                IsEnabled() &&
+                (
+#if wxUSE_UXTHEME
+                wxUxThemeEngine::GetIfActive() ||
+#endif // wxUSE_UXTHEME
+                 (m_imageData && m_imageData->GetBitmap(State_Current).IsOk())
+                )
+           )
+        {
+            Refresh();
+        }
+    }
+
+    // let the base class do all real processing
+    return wxControl::MSWWindowProc(nMsg, wParam, lParam);
+}
+
+// ----------------------------------------------------------------------------
+// authentication needed handling
+// ----------------------------------------------------------------------------
+
+bool wxAbstractButton::DoGetAuthNeeded() const
+{
+    return m_authNeeded;
+}
+
+void wxAbstractButton::DoSetAuthNeeded(bool show)
+{
+    // show/hide UAC symbol on Windows Vista and later
+    if ( wxGetWinVersion() >= wxWinVersion_6 )
+    {
+        m_authNeeded = show;
+        ::SendMessage(GetHwnd(), BCM_SETSHIELD, 0, show);
+        InvalidateBestSize();
+    }
+}
+
+// ----------------------------------------------------------------------------
+// button images
+// ----------------------------------------------------------------------------
+
+wxBitmap wxAbstractButton::DoGetBitmap(State which) const
+{
+    return m_imageData ? m_imageData->GetBitmap(which) : wxBitmap();
+}
+
+void wxAbstractButton::DoSetBitmap(const wxBitmap& bitmap, State which)
+{
+#if wxUSE_UXTHEME
+    wxXPButtonImageData *oldData = NULL;
+#endif // wxUSE_UXTHEME
+
+    // Check if we already had bitmaps of different size.
+    if ( m_imageData &&
+          bitmap.GetSize() != m_imageData->GetBitmap(State_Normal).GetSize() )
+    {
+        wxASSERT_MSG( which == State_Normal,
+                      "Must set normal bitmap with the new size first" );
+
+#if wxUSE_UXTHEME
+        if ( ShowsLabel() && wxUxThemeEngine::GetIfActive() )
+        {
+            // We can't change the size of the images stored in wxImageList
+            // in wxXPButtonImageData::m_iml so force recreating it below but
+            // keep the current data to copy its values into the new one.
+            oldData = static_cast<wxXPButtonImageData *>(m_imageData);
+            m_imageData = NULL;
+        }
+#endif // wxUSE_UXTHEME
+        //else: wxODButtonImageData doesn't require anything special
+    }
+
+    // allocate the image data when the first bitmap is set
+    if ( !m_imageData )
+    {
+#if wxUSE_UXTHEME
+        // using image list doesn't work correctly if we don't have any label
+        // (even if we use BUTTON_IMAGELIST_ALIGN_CENTER alignment and
+        // BS_BITMAP style), at least under Windows 2003 so use owner drawn
+        // strategy for bitmap-only buttons
+        if ( ShowsLabel() && wxUxThemeEngine::GetIfActive() )
+        {
+            m_imageData = new wxXPButtonImageData(this, bitmap);
+
+            if ( oldData )
+            {
+                // Preserve the old values in case the user changed them.
+                m_imageData->SetBitmapPosition(oldData->GetBitmapPosition());
+
+                const wxSize oldMargins = oldData->GetBitmapMargins();
+                m_imageData->SetBitmapMargins(oldMargins.x, oldMargins.y);
+
+                // No need to preserve the bitmaps though as they were of wrong
+                // size anyhow.
+
+                delete oldData;
+            }
+        }
+        else
+#endif // wxUSE_UXTHEME
+        {
+            m_imageData = new wxODButtonImageData(this, bitmap);
+            MakeOwnerDrawn();
+        }
+    }
+    else
+    {
+        m_imageData->SetBitmap(bitmap, which);
+    }
+
+    // it should be enough to only invalidate the best size when the normal
+    // bitmap changes as all bitmaps assigned to the button should be of the
+    // same size anyhow
+    if ( which == State_Normal )
+        InvalidateBestSize();
+
+    Refresh();
+}
+
+wxSize wxAbstractButton::DoGetBitmapMargins() const
+{
+    return m_imageData ? m_imageData->GetBitmapMargins() : wxSize(0, 0);
+}
+
+void wxAbstractButton::DoSetBitmapMargins(wxCoord x, wxCoord y)
+{
+    wxCHECK_RET( m_imageData, "SetBitmap() must be called first" );
+
+    m_imageData->SetBitmapMargins(x, y);
+    InvalidateBestSize();
+}
+
+void wxAbstractButton::DoSetBitmapPosition(wxDirection dir)
+{
+    wxCHECK_RET( m_imageData, "SetBitmap() must be called first" );
+
+    m_imageData->SetBitmapPosition(dir);
+    InvalidateBestSize();
+}
+
+// ----------------------------------------------------------------------------
+// markup support
+// ----------------------------------------------------------------------------
+
+#if wxUSE_MARKUP
+
+bool wxAbstractButton::DoSetLabelMarkup(const wxString& markup)
+{
+    if ( !wxAbstractButtonBase::DoSetLabelMarkup(markup) )
+        return false;
+
+    if ( !m_markupText )
+    {
+        m_markupText = new wxMarkupText(markup);
+        MakeOwnerDrawn();
+    }
+    else
+    {
+        // We are already owner-drawn so just update the text.
+        m_markupText->SetMarkup(markup);
+    }
+
+    Refresh();
+
+    return true;
+}
+
+#endif // wxUSE_MARKUP
+
+// ----------------------------------------------------------------------------
+// owner-drawn buttons support
+// ----------------------------------------------------------------------------
+
+// drawing helpers
+namespace
+{
+void DrawButtonText(HDC hdc,
+                    RECT *pRect,
+                    wxAbstractButton *btn,
+                    int flags)
+{
+    const wxString text = btn->GetLabel();
+
+    if ( text.find(wxT('\n')) != wxString::npos )
+    {
+        // draw multiline label
+
+        // center text horizontally in any case
+        flags |= DT_CENTER;
+
+        // first we need to compute its bounding rect
+        RECT rc;
+        ::CopyRect(&rc, pRect);
+        ::DrawText(hdc, text.wx_str(), text.length(), &rc,
+                   DT_CENTER | DT_CALCRECT);
+
+        // now center this rect inside the entire button area
+        const LONG w = rc.right - rc.left;
+        const LONG h = rc.bottom - rc.top;
+        rc.left = (pRect->right - pRect->left)/2 - w/2;
+        rc.right = rc.left+w;
+        rc.top = (pRect->bottom - pRect->top)/2 - h/2;
+        rc.bottom = rc.top+h;
+
+        ::DrawText(hdc, text.wx_str(), text.length(), &rc, flags);
+    }
+    else // single line label
+    {
+        // translate wx button flags to alignment flags for DrawText()
+        if ( btn->HasFlag(wxBU_RIGHT) )
+        {
+            flags |= DT_RIGHT;
+        }
+        else if ( !btn->HasFlag(wxBU_LEFT) )
+        {
+            flags |= DT_CENTER;
+        }
+        //else: DT_LEFT is the default anyhow (and its value is 0 too)
+
+        if ( btn->HasFlag(wxBU_BOTTOM) )
+        {
+            flags |= DT_BOTTOM;
+        }
+        else if ( !btn->HasFlag(wxBU_TOP) )
+        {
+            flags |= DT_VCENTER;
+        }
+        //else: as above, DT_TOP is the default
+
+        // notice that we must have DT_SINGLELINE for vertical alignment flags
+        // to work
+        ::DrawText(hdc, text.wx_str(), text.length(), pRect,
+                   flags | DT_SINGLELINE );
+    }
+}
+
+void DrawRect(HDC hdc, const RECT& r)
+{
+    wxDrawLine(hdc, r.left, r.top, r.right, r.top);
+    wxDrawLine(hdc, r.right, r.top, r.right, r.bottom);
+    wxDrawLine(hdc, r.right, r.bottom, r.left, r.bottom);
+    wxDrawLine(hdc, r.left, r.bottom, r.left, r.top);
+}
+
+/*
+   The button frame looks like this normally:
+
+   WWWWWWWWWWWWWWWWWWB
+   WHHHHHHHHHHHHHHHHGB  W = white       (HILIGHT)
+   WH               GB  H = light grey  (LIGHT)
+   WH               GB  G = dark grey   (SHADOW)
+   WH               GB  B = black       (DKSHADOW)
+   WH               GB
+   WGGGGGGGGGGGGGGGGGB
+   BBBBBBBBBBBBBBBBBBB
+
+   When the button is selected, the button becomes like this (the total button
+   size doesn't change):
+
+   BBBBBBBBBBBBBBBBBBB
+   BWWWWWWWWWWWWWWWWBB
+   BWHHHHHHHHHHHHHHGBB
+   BWH             GBB
+   BWH             GBB
+   BWGGGGGGGGGGGGGGGBB
+   BBBBBBBBBBBBBBBBBBB
+   BBBBBBBBBBBBBBBBBBB
+
+   When the button is pushed (while selected) it is like:
+
+   BBBBBBBBBBBBBBBBBBB
+   BGGGGGGGGGGGGGGGGGB
+   BG               GB
+   BG               GB
+   BG               GB
+   BG               GB
+   BGGGGGGGGGGGGGGGGGB
+   BBBBBBBBBBBBBBBBBBB
+*/
+void DrawButtonFrame(HDC hdc, RECT& rectBtn,
+                     bool selected, bool pushed)
+{
+    RECT r;
+    CopyRect(&r, &rectBtn);
+
+    AutoHPEN hpenBlack(GetSysColor(COLOR_3DDKSHADOW)),
+             hpenGrey(GetSysColor(COLOR_3DSHADOW)),
+             hpenLightGr(GetSysColor(COLOR_3DLIGHT)),
+             hpenWhite(GetSysColor(COLOR_3DHILIGHT));
+
+    SelectInHDC selectPen(hdc, hpenBlack);
+
+    r.right--;
+    r.bottom--;
+
+    if ( pushed )
+    {
+        DrawRect(hdc, r);
+
+        (void)SelectObject(hdc, hpenGrey);
+        ::InflateRect(&r, -1, -1);
+
+        DrawRect(hdc, r);
+    }
+    else // !pushed
+    {
+        if ( selected )
+        {
+            DrawRect(hdc, r);
+
+            ::InflateRect(&r, -1, -1);
+        }
+
+        wxDrawLine(hdc, r.left, r.bottom, r.right, r.bottom);
+        wxDrawLine(hdc, r.right, r.bottom, r.right, r.top - 1);
+
+        (void)SelectObject(hdc, hpenWhite);
+        wxDrawLine(hdc, r.left, r.bottom - 1, r.left, r.top);
+        wxDrawLine(hdc, r.left, r.top, r.right, r.top);
+
+        (void)SelectObject(hdc, hpenLightGr);
+        wxDrawLine(hdc, r.left + 1, r.bottom - 2, r.left + 1, r.top + 1);
+        wxDrawLine(hdc, r.left + 1, r.top + 1, r.right - 1, r.top + 1);
+
+        (void)SelectObject(hdc, hpenGrey);
+        wxDrawLine(hdc, r.left + 1, r.bottom - 1, r.right - 1, r.bottom - 1);
+        wxDrawLine(hdc, r.right - 1, r.bottom - 1, r.right - 1, r.top);
+    }
+
+    InflateRect(&rectBtn, -OD_BUTTON_MARGIN, -OD_BUTTON_MARGIN);
+}
+
+#if wxUSE_UXTHEME
+void DrawXPBackground(wxAbstractButton *button, HDC hdc, RECT& rectBtn,
+                      wxAbstractButton::State state)
+{
+    wxUxThemeHandle theme(button, L"BUTTON");
+
+    // this array is indexed by wxButton::State values and so must be kept in
+    // sync with it
+    static const int uxStates[] =
+    {
+        PBS_NORMAL, PBS_HOT, PBS_PRESSED, PBS_DISABLED, PBS_DEFAULTED
+    };
+
+    int iState = uxStates[state];
+
+    wxUxThemeEngine * const engine = wxUxThemeEngine::Get();
+
+    // draw parent background if needed
+    if ( engine->IsThemeBackgroundPartiallyTransparent
+                 (
+                    theme,
+                    BP_PUSHBUTTON,
+                    iState
+                 ) )
+    {
+        // Set this button as the one whose background is being erased: this
+        // allows our WM_ERASEBKGND handler used by DrawThemeParentBackground()
+        // to correctly align the background brush with this window instead of
+        // the parent window to which WM_ERASEBKGND is sent. Notice that this
+        // doesn't work with custom user-defined EVT_ERASE_BACKGROUND handlers
+        // as they won't be aligned but unfortunately all the attempts to fix
+        // it by shifting DC origin before calling DrawThemeParentBackground()
+        // failed to work so we at least do this, even though this is far from
+        // being the perfect solution.
+        wxWindowBeingErased = button;
+
+        engine->DrawThemeParentBackground(GetHwndOf(button), hdc, &rectBtn);
+
+        wxWindowBeingErased = NULL;
+    }
+
+    // draw background
+    engine->DrawThemeBackground(theme, hdc, BP_PUSHBUTTON, iState,
+                                &rectBtn, NULL);
+
+    // calculate content area margins
+    MARGINS margins;
+    engine->GetThemeMargins(theme, hdc, BP_PUSHBUTTON, iState,
+                            TMT_CONTENTMARGINS, &rectBtn, &margins);
+    ::InflateRect(&rectBtn, -margins.cxLeftWidth, -margins.cyTopHeight);
+    ::InflateRect(&rectBtn, -XP_BUTTON_EXTRA_MARGIN, -XP_BUTTON_EXTRA_MARGIN);
+
+    if ( button->UseBgCol() )
+    {
+        COLORREF colBg = wxColourToRGB(button->GetBackgroundColour());
+        AutoHBRUSH hbrushBackground(colBg);
+
+        // don't overwrite the focus rect
+        RECT rectClient;
+        ::CopyRect(&rectClient, &rectBtn);
+        ::InflateRect(&rectClient, -1, -1);
+        FillRect(hdc, &rectClient, hbrushBackground);
+    }
+}
+#endif // wxUSE_UXTHEME
+
+} // anonymous namespace
+
+// ----------------------------------------------------------------------------
+// owner drawn buttons support
+// ----------------------------------------------------------------------------
+
+void wxAbstractButton::MakeOwnerDrawn()
+{
+    long style = GetWindowLong(GetHwnd(), GWL_STYLE);
+    if ( (style & BS_OWNERDRAW) != BS_OWNERDRAW )
+    {
+        // make it so
+        style |= BS_OWNERDRAW;
+        SetWindowLong(GetHwnd(), GWL_STYLE, style);
+    }
+}
+
+bool wxAbstractButton::SetBackgroundColour(const wxColour &colour)
+{
+    if ( !wxControl::SetBackgroundColour(colour) )
+    {
+        // nothing to do
+        return false;
+    }
+
+    MakeOwnerDrawn();
+
+    Refresh();
+
+    return true;
+}
+
+bool wxAbstractButton::SetForegroundColour(const wxColour &colour)
+{
+    if ( !wxControl::SetForegroundColour(colour) )
+    {
+        // nothing to do
+        return false;
+    }
+
+    MakeOwnerDrawn();
+
+    Refresh();
+
+    return true;
+}
+
+bool wxAbstractButton::MSWOnDraw(WXDRAWITEMSTRUCT *wxdis)
+{
+    LPDRAWITEMSTRUCT lpDIS = (LPDRAWITEMSTRUCT)wxdis;
+    HDC hdc = lpDIS->hDC;
+
+    UINT state = lpDIS->itemState;
+    wxAbstractButton::State buttonState = GetButtonState(state);
+    bool pushed = (SendMessage(GetHwnd(), BM_GETSTATE, 0, 0) & BST_PUSHED) != 0;
+
+    RECT rectBtn;
+    CopyRect(&rectBtn, &lpDIS->rcItem);
+
+    // draw the button background
+    if ( !HasFlag(wxBORDER_NONE) )
+    {
+#if wxUSE_UXTHEME
+        if ( wxUxThemeEngine::GetIfActive() )
+        {
+            DrawXPBackground(this, hdc, rectBtn, buttonState);
+        }
+        else
+#endif // wxUSE_UXTHEME
+        {
+            COLORREF colBg = wxColourToRGB(GetBackgroundColour());
+
+            // first, draw the background
+            AutoHBRUSH hbrushBackground(colBg);
+            FillRect(hdc, &rectBtn, hbrushBackground);
+
+            // draw the border for the current state
+            bool selected = (state & ODS_SELECTED) != 0;
+            if ( !selected )
+            {
+                wxTopLevelWindow *
+                    tlw = wxDynamicCast(wxGetTopLevelParent(this), wxTopLevelWindow);
+                if ( tlw )
+                {
+                    selected = tlw->GetDefaultItem() == this;
+                }
+            }
+
+            DrawButtonFrame(hdc, rectBtn, selected, pushed);
+        }
+
+        // draw the focus rectangle if we need it
+        if ( (state & ODS_FOCUS) && !(state & ODS_NOFOCUSRECT) )
+        {
+            DrawFocusRect(hdc, &rectBtn);
+
+#if wxUSE_UXTHEME
+            if ( !wxUxThemeEngine::GetIfActive() )
+#endif // wxUSE_UXTHEME
+            {
+                if ( pushed )
+                {
+                    // the label is shifted by 1 pixel to create "pushed" effect
+                    OffsetRect(&rectBtn, 1, 1);
+                }
+            }
+        }
+    }
+
+
+    // draw the image, if any
+    if ( m_imageData )
+    {
+        wxBitmap bmp = m_imageData->GetBitmap(buttonState);
+        if ( !bmp.IsOk() )
+            bmp = m_imageData->GetBitmap(State_Normal);
+
+        const wxSize sizeBmp = bmp.GetSize();
+        const wxSize margin = m_imageData->GetBitmapMargins();
+        const wxSize sizeBmpWithMargins(sizeBmp + 2*margin);
+        wxRect rectButton(wxRectFromRECT(rectBtn));
+
+        // for simplicity, we start with centred rectangle and then move it to
+        // the appropriate edge
+        wxRect rectBitmap = wxRect(sizeBmp).CentreIn(rectButton);
+
+        // move bitmap only if we have a label, otherwise keep it centered
+        if ( ShowsLabel() )
+        {
+            switch ( m_imageData->GetBitmapPosition() )
+            {
+                default:
+                    wxFAIL_MSG( "invalid direction" );
+                    // fall through
+
+                case wxLEFT:
+                    rectBitmap.x = rectButton.x + margin.x;
+                    rectButton.x += sizeBmpWithMargins.x;
+                    rectButton.width -= sizeBmpWithMargins.x;
+                    break;
+
+                case wxRIGHT:
+                    rectBitmap.x = rectButton.GetRight() - sizeBmp.x - margin.x;
+                    rectButton.width -= sizeBmpWithMargins.x;
+                    break;
+
+                case wxTOP:
+                    rectBitmap.y = rectButton.y + margin.y;
+                    rectButton.y += sizeBmpWithMargins.y;
+                    rectButton.height -= sizeBmpWithMargins.y;
+                    break;
+
+                case wxBOTTOM:
+                    rectBitmap.y = rectButton.GetBottom() - sizeBmp.y - margin.y;
+                    rectButton.height -= sizeBmpWithMargins.y;
+                    break;
+            }
+        }
+
+        wxDCTemp dst((WXHDC)hdc);
+        dst.DrawBitmap(bmp, rectBitmap.GetPosition(), true);
+
+        wxCopyRectToRECT(rectButton, rectBtn);
+    }
+
+
+    // finally draw the label
+    if ( ShowsLabel() )
+    {
+        COLORREF colFg = state & ODS_DISABLED
+                            ? ::GetSysColor(COLOR_GRAYTEXT)
+                            : wxColourToRGB(GetForegroundColour());
+
+        wxTextColoursChanger changeFg(hdc, colFg, CLR_INVALID);
+        wxBkModeChanger changeBkMode(hdc, wxBRUSHSTYLE_TRANSPARENT);
+
+#if wxUSE_MARKUP
+        if ( m_markupText )
+        {
+            wxDCTemp dc((WXHDC)hdc);
+            dc.SetTextForeground(wxColour(colFg));
+            dc.SetFont(GetFont());
+
+            m_markupText->Render(dc, wxRectFromRECT(rectBtn),
+                                 state & ODS_NOACCEL
+                                    ? wxMarkupText::Render_Default
+                                    : wxMarkupText::Render_ShowAccels);
+        }
+        else // Plain text label
+#endif // wxUSE_MARKUP
+        {
+            // notice that DT_HIDEPREFIX doesn't work on old (pre-Windows 2000)
+            // systems but by happy coincidence ODS_NOACCEL is not used under
+            // them neither so DT_HIDEPREFIX should never be used there
+            DrawButtonText(hdc, &rectBtn, this,
+                           state & ODS_NOACCEL ? DT_HIDEPREFIX : 0);
+        }
+    }
+
+    return true;
+}
+
+#endif // wxHAS_ABSTRACT_BUTTON
diff --git a/src/msw/button.cpp b/src/msw/button.cpp
index 10bb135..101cac8 100644
--- a/src/msw/button.cpp
+++ b/src/msw/button.cpp
@@ -2,7 +2,7 @@
 // Name:        src/msw/button.cpp
 // Purpose:     wxButton
 // Author:      Julian Smart
-// Modified by:
+// Modified by: Hans de Ruiter
 // Created:     04/01/98
 // RCS-ID:      $Id$
 // Copyright:   (c) Julian Smart
@@ -28,427 +28,16 @@
 
 #include "wx/button.h"
 
-#ifndef WX_PRECOMP
-    #include "wx/app.h"
-    #include "wx/brush.h"
-    #include "wx/panel.h"
-    #include "wx/bmpbuttn.h"
-    #include "wx/settings.h"
-    #include "wx/dcscreen.h"
-    #include "wx/dcclient.h"
-    #include "wx/toplevel.h"
-    #include "wx/msw/wrapcctl.h"
-    #include "wx/msw/private.h"
-    #include "wx/msw/missing.h"
-#endif
-
-#include "wx/imaglist.h"
-#include "wx/stockitem.h"
 #include "wx/msw/private/button.h"
 #include "wx/msw/private/dc.h"
 #include "wx/private/window.h"
 
-#if wxUSE_MARKUP
-    #include "wx/generic/private/markuptext.h"
-#endif // wxUSE_MARKUP
-
-using namespace wxMSWImpl;
-
-#if wxUSE_UXTHEME
-    #include "wx/msw/uxtheme.h"
-
-    // no need to include tmschema.h
-    #ifndef BP_PUSHBUTTON
-        #define BP_PUSHBUTTON 1
-
-        #define PBS_NORMAL    1
-        #define PBS_HOT       2
-        #define PBS_PRESSED   3
-        #define PBS_DISABLED  4
-        #define PBS_DEFAULTED 5
-
-        #define TMT_CONTENTMARGINS 3602
-    #endif
-
-    // provide the necessary declarations ourselves if they're missing from
-    // headers
-    #ifndef BCM_SETIMAGELIST
-        #define BCM_SETIMAGELIST    0x1602
-        #define BCM_SETTEXTMARGIN   0x1604
-
-        enum
-        {
-            BUTTON_IMAGELIST_ALIGN_LEFT,
-            BUTTON_IMAGELIST_ALIGN_RIGHT,
-            BUTTON_IMAGELIST_ALIGN_TOP,
-            BUTTON_IMAGELIST_ALIGN_BOTTOM
-        };
-
-        struct BUTTON_IMAGELIST
-        {
-            HIMAGELIST himl;
-            RECT margin;
-            UINT uAlign;
-        };
-    #endif
-#endif // wxUSE_UXTHEME
-
-#ifndef WM_THEMECHANGED
-    #define WM_THEMECHANGED     0x031A
-#endif
-
-#ifndef ODS_NOACCEL
-    #define ODS_NOACCEL         0x0100
-#endif
-
-#ifndef ODS_NOFOCUSRECT
-    #define ODS_NOFOCUSRECT     0x0200
-#endif
-
-#ifndef DT_HIDEPREFIX
-    #define DT_HIDEPREFIX       0x00100000
-#endif
-
-// set the value for BCM_SETSHIELD (for the UAC shield) if it's not defined in
-// the header
-#ifndef BCM_SETSHIELD
-    #define BCM_SETSHIELD       0x160c
-#endif
-
-#if wxUSE_UXTHEME
-extern wxWindowMSW *wxWindowBeingErased; // From src/msw/window.cpp
-#endif // wxUSE_UXTHEME
-
-// ----------------------------------------------------------------------------
-// button image data
-// ----------------------------------------------------------------------------
-
-// we use different data classes for owner drawn buttons and for themed XP ones
-
-class wxButtonImageData
-{
-public:
-    wxButtonImageData() { }
-    virtual ~wxButtonImageData() { }
-
-    virtual wxBitmap GetBitmap(wxButton::State which) const = 0;
-    virtual void SetBitmap(const wxBitmap& bitmap, wxButton::State which) = 0;
-
-    virtual wxSize GetBitmapMargins() const = 0;
-    virtual void SetBitmapMargins(wxCoord x, wxCoord y) = 0;
-
-    virtual wxDirection GetBitmapPosition() const = 0;
-    virtual void SetBitmapPosition(wxDirection dir) = 0;
-
-private:
-    wxDECLARE_NO_COPY_CLASS(wxButtonImageData);
-};
-
-namespace
-{
-
-// the gap between button edge and the interior area used by Windows for the
-// standard buttons
-const int OD_BUTTON_MARGIN = 4;
-
-class wxODButtonImageData : public wxButtonImageData
-{
-public:
-    wxODButtonImageData(wxButton *btn, const wxBitmap& bitmap)
-    {
-        SetBitmap(bitmap, wxButton::State_Normal);
-        SetBitmap(bitmap.ConvertToDisabled(), wxButton::State_Disabled);
-
-        m_dir = wxLEFT;
-
-        // we use margins when we have both bitmap and text, but when we have
-        // only the bitmap it should take up the entire button area
-        if ( btn->ShowsLabel() )
-        {
-            m_margin.x = btn->GetCharWidth();
-            m_margin.y = btn->GetCharHeight() / 2;
-        }
-    }
-
-    virtual wxBitmap GetBitmap(wxButton::State which) const
-    {
-        return m_bitmaps[which];
-    }
-
-    virtual void SetBitmap(const wxBitmap& bitmap, wxButton::State which)
-    {
-        m_bitmaps[which] = bitmap;
-    }
-
-    virtual wxSize GetBitmapMargins() const
-    {
-        return m_margin;
-    }
-
-    virtual void SetBitmapMargins(wxCoord x, wxCoord y)
-    {
-        m_margin = wxSize(x, y);
-    }
-
-    virtual wxDirection GetBitmapPosition() const
-    {
-        return m_dir;
-    }
-
-    virtual void SetBitmapPosition(wxDirection dir)
-    {
-        m_dir = dir;
-    }
-
-private:
-    // just store the values passed to us to be able to retrieve them later
-    // from the drawing code
-    wxBitmap m_bitmaps[wxButton::State_Max];
-    wxSize m_margin;
-    wxDirection m_dir;
-
-    wxDECLARE_NO_COPY_CLASS(wxODButtonImageData);
-};
-
-#if wxUSE_UXTHEME
-
-// somehow the margin is one pixel greater than the value returned by
-// GetThemeMargins() call
-const int XP_BUTTON_EXTRA_MARGIN = 1;
-
-class wxXPButtonImageData : public wxButtonImageData
-{
-public:
-    // we must be constructed with the size of our images as we need to create
-    // the image list
-    wxXPButtonImageData(wxButton *btn, const wxBitmap& bitmap)
-        : m_iml(bitmap.GetWidth(), bitmap.GetHeight(), true /* use mask */,
-                wxButton::State_Max),
-          m_hwndBtn(GetHwndOf(btn))
-    {
-        // initialize all bitmaps except for the disabled one to normal state
-        for ( int n = 0; n < wxButton::State_Max; n++ )
-        {
-            m_iml.Add(n == wxButton::State_Disabled ? bitmap.ConvertToDisabled()
-                                                    : bitmap);
-        }
-
-        m_data.himl = GetHimagelistOf(&m_iml);
-
-        // no margins by default
-        m_data.margin.left =
-        m_data.margin.right =
-        m_data.margin.top =
-        m_data.margin.bottom = 0;
-
-        // use default alignment
-        m_data.uAlign = BUTTON_IMAGELIST_ALIGN_LEFT;
-
-        UpdateImageInfo();
-    }
-
-    virtual wxBitmap GetBitmap(wxButton::State which) const
-    {
-        return m_iml.GetBitmap(which);
-    }
-
-    virtual void SetBitmap(const wxBitmap& bitmap, wxButton::State which)
-    {
-        m_iml.Replace(which, bitmap);
-
-        UpdateImageInfo();
-    }
-
-    virtual wxSize GetBitmapMargins() const
-    {
-        return wxSize(m_data.margin.left, m_data.margin.top);
-    }
-
-    virtual void SetBitmapMargins(wxCoord x, wxCoord y)
-    {
-        RECT& margin = m_data.margin;
-        margin.left =
-        margin.right = x;
-        margin.top =
-        margin.bottom = y;
-
-        if ( !::SendMessage(m_hwndBtn, BCM_SETTEXTMARGIN, 0, (LPARAM)&margin) )
-        {
-            wxLogDebug("SendMessage(BCM_SETTEXTMARGIN) failed");
-        }
-    }
-
-    virtual wxDirection GetBitmapPosition() const
-    {
-        switch ( m_data.uAlign )
-        {
-            default:
-                wxFAIL_MSG( "invalid image alignment" );
-                // fall through
-
-            case BUTTON_IMAGELIST_ALIGN_LEFT:
-                return wxLEFT;
-
-            case BUTTON_IMAGELIST_ALIGN_RIGHT:
-                return wxRIGHT;
-
-            case BUTTON_IMAGELIST_ALIGN_TOP:
-                return wxTOP;
-
-            case BUTTON_IMAGELIST_ALIGN_BOTTOM:
-                return wxBOTTOM;
-        }
-    }
-
-    virtual void SetBitmapPosition(wxDirection dir)
-    {
-        UINT alignNew;
-        switch ( dir )
-        {
-            default:
-                wxFAIL_MSG( "invalid direction" );
-                // fall through
-
-            case wxLEFT:
-                alignNew = BUTTON_IMAGELIST_ALIGN_LEFT;
-                break;
-
-            case wxRIGHT:
-                alignNew = BUTTON_IMAGELIST_ALIGN_RIGHT;
-                break;
-
-            case wxTOP:
-                alignNew = BUTTON_IMAGELIST_ALIGN_TOP;
-                break;
-
-            case wxBOTTOM:
-                alignNew = BUTTON_IMAGELIST_ALIGN_BOTTOM;
-                break;
-        }
-
-        if ( alignNew != m_data.uAlign )
-        {
-            m_data.uAlign = alignNew;
-            UpdateImageInfo();
-        }
-    }
-
-private:
-    void UpdateImageInfo()
-    {
-        if ( !::SendMessage(m_hwndBtn, BCM_SETIMAGELIST, 0, (LPARAM)&m_data) )
-        {
-            wxLogDebug("SendMessage(BCM_SETIMAGELIST) failed");
-        }
-    }
-
-    // we store image list separately to be able to use convenient wxImageList
-    // methods instead of working with raw HIMAGELIST
-    wxImageList m_iml;
-
-    // store the rest of the data in BCM_SETIMAGELIST-friendly form
-    BUTTON_IMAGELIST m_data;
-
-    // the button we're associated with
-    const HWND m_hwndBtn;
-
-
-    wxDECLARE_NO_COPY_CLASS(wxXPButtonImageData);
-};
-
-#endif // wxUSE_UXTHEME
-
-} // anonymous namespace
-
-// ----------------------------------------------------------------------------
-// macros
-// ----------------------------------------------------------------------------
 
 // ============================================================================
 // implementation
 // ============================================================================
 
 // ----------------------------------------------------------------------------
-// helper functions from wx/msw/private/button.h
-// ----------------------------------------------------------------------------
-
-void wxMSWButton::UpdateMultilineStyle(HWND hwnd, const wxString& label)
-{
-    // update BS_MULTILINE style depending on the new label (resetting it
-    // doesn't seem to do anything very useful but it shouldn't hurt and we do
-    // have to set it whenever the label becomes multi line as otherwise it
-    // wouldn't be shown correctly as we don't use BS_MULTILINE when creating
-    // the control unless it already has new lines in its label)
-    long styleOld = ::GetWindowLong(hwnd, GWL_STYLE),
-         styleNew;
-    if ( label.find(wxT('\n')) != wxString::npos )
-        styleNew = styleOld | BS_MULTILINE;
-    else
-        styleNew = styleOld & ~BS_MULTILINE;
-
-    if ( styleNew != styleOld )
-        ::SetWindowLong(hwnd, GWL_STYLE, styleNew);
-}
-
-wxSize wxMSWButton::GetFittingSize(wxWindow *win,
-                                   const wxSize& sizeLabel,
-                                   int flags)
-{
-    // FIXME: this is pure guesswork, need to retrieve the real button margins
-    wxSize sizeBtn = sizeLabel;
-
-    sizeBtn.x += 3*win->GetCharWidth();
-    sizeBtn.y += win->GetCharHeight()/2;
-
-    // account for the shield UAC icon if we have it
-    if ( flags & Size_AuthNeeded )
-        sizeBtn.x += wxSystemSettings::GetMetric(wxSYS_SMALLICON_X);
-
-    return sizeBtn;
-}
-
-wxSize wxMSWButton::ComputeBestFittingSize(wxControl *btn, int flags)
-{
-    wxClientDC dc(btn);
-
-    wxSize sizeBtn;
-    dc.GetMultiLineTextExtent(btn->GetLabelText(), &sizeBtn.x, &sizeBtn.y);
-
-    return GetFittingSize(btn, sizeBtn, flags);
-}
-
-wxSize wxMSWButton::IncreaseToStdSizeAndCache(wxControl *btn, const wxSize& size)
-{
-    wxSize sizeBtn(size);
-
-    // All buttons have at least the standard height and, unless the user
-    // explicitly wants them to be as small as possible and used wxBU_EXACTFIT
-    // style to indicate this, of at least the standard width too.
-    //
-    // Notice that we really want to make all buttons equally high, otherwise
-    // they look ugly and the existing code using wxBU_EXACTFIT only uses it to
-    // control width and not height.
-
-    // The 50x14 button size is documented in the "Recommended sizing and
-    // spacing" section of MSDN layout article.
-    //
-    // Note that we intentionally don't use GetDefaultSize() here, because
-    // it's inexact -- dialog units depend on this dialog's font.
-    const wxSize sizeDef = btn->ConvertDialogToPixels(wxSize(50, 14));
-    if ( !btn->HasFlag(wxBU_EXACTFIT) )
-    {
-        if ( sizeBtn.x < sizeDef.x )
-            sizeBtn.x = sizeDef.x;
-    }
-    if ( sizeBtn.y < sizeDef.y )
-        sizeBtn.y = sizeDef.y;
-
-    btn->CacheBestSize(sizeBtn);
-
-    return sizeBtn;
-}
-
-// ----------------------------------------------------------------------------
 // creation/destruction
 // ----------------------------------------------------------------------------
 
@@ -461,34 +50,7 @@ bool wxButton::Create(wxWindow *parent,
                       const wxValidator& validator,
                       const wxString& name)
 {
-    wxString label(lbl);
-    if (label.empty() && wxIsStockID(id))
-    {
-        // On Windows, some buttons aren't supposed to have mnemonics
-        label = wxGetStockLabel
-                (
-                    id,
-                    id == wxID_OK || id == wxID_CANCEL || id == wxID_CLOSE
-                        ? wxSTOCK_NOFLAGS
-                        : wxSTOCK_WITH_MNEMONIC
-                );
-    }
-
-    if ( !CreateControl(parent, id, pos, size, style, validator, name) )
-        return false;
-
-    WXDWORD exstyle;
-    WXDWORD msStyle = MSWGetStyle(style, &exstyle);
-
-    // if the label contains several lines we must explicitly tell the button
-    // about it or it wouldn't draw it correctly ("\n"s would just appear as
-    // black boxes)
-    //
-    // NB: we do it here and not in MSWGetStyle() because we need the label
-    //     value and the label is not set yet when MSWGetStyle() is called
-    msStyle |= wxMSWButton::GetMultilineStyle(label);
-
-    return MSWCreateControl(wxT("BUTTON"), msStyle, pos, size, label, exstyle);
+    return wxAbstractButton::Create(parent, id, lbl, pos, size, style, validator, name);
 }
 
 wxButton::~wxButton()
@@ -498,11 +60,25 @@ wxButton::~wxButton()
     {
         UnsetTmpDefault();
     }
+}
 
-    delete m_imageData;
-#if wxUSE_MARKUP
-    delete m_markupText;
-#endif // wxUSE_MARKUP
+WXLRESULT wxButton::MSWWindowProc(WXUINT nMsg, WXWPARAM wParam, WXLPARAM lParam)
+{
+    // when we receive focus, we want to temporarily become the default button in
+    // our parent panel so that pressing "Enter" would activate us -- and when
+    // losing it we should restore the previous default button as well
+    if ( nMsg == WM_SETFOCUS )
+    {
+        SetTmpDefault();
+
+        // let the default processing take place too
+    }
+    else if ( nMsg == WM_KILLFOCUS )
+    {
+        UnsetTmpDefault();
+    }
+
+    return wxAbstractButton::MSWWindowProc(nMsg, wParam, lParam);
 }
 
 // ----------------------------------------------------------------------------
@@ -541,161 +117,6 @@ WXDWORD wxButton::MSWGetStyle(long style, WXDWORD *exstyle) const
     return msStyle;
 }
 
-void wxButton::SetLabel(const wxString& label)
-{
-    wxMSWButton::UpdateMultilineStyle(GetHwnd(), label);
-
-    wxButtonBase::SetLabel(label);
-
-#if wxUSE_MARKUP
-    // If we have a plain text label, we shouldn't be using markup any longer.
-    if ( m_markupText )
-    {
-        delete m_markupText;
-        m_markupText = NULL;
-
-        // Unfortunately we don't really know whether we can reset the button
-        // to be non-owner-drawn or not: if we had made it owner-drawn just
-        // because of a call to SetLabelMarkup(), we could, but not if there
-        // were [also] calls to Set{Fore,Back}groundColour(). If it's really a
-        // problem to have button remain owner-drawn forever just because it
-        // had markup label once, we should record the reason for our current
-        // owner-drawnness and check it here.
-    }
-#endif // wxUSE_MARKUP
-}
-
-// ----------------------------------------------------------------------------
-// size management including autosizing
-// ----------------------------------------------------------------------------
-
-void wxButton::AdjustForBitmapSize(wxSize &size) const
-{
-    wxCHECK_RET( m_imageData, wxT("shouldn't be called if no image") );
-
-    // account for the bitmap size
-    const wxSize sizeBmp = m_imageData->GetBitmap(State_Normal).GetSize();
-    const wxDirection dirBmp = m_imageData->GetBitmapPosition();
-    if ( dirBmp == wxLEFT || dirBmp == wxRIGHT )
-    {
-        size.x += sizeBmp.x;
-        if ( sizeBmp.y > size.y )
-            size.y = sizeBmp.y;
-    }
-    else // bitmap on top/below the text
-    {
-        size.y += sizeBmp.y;
-        if ( sizeBmp.x > size.x )
-            size.x = sizeBmp.x;
-    }
-
-    // account for the user-specified margins
-    size += 2*m_imageData->GetBitmapMargins();
-
-    // and also for the margins we always add internally (unless we have no
-    // border at all in which case the button has exactly the same size as
-    // bitmap and so no margins should be used)
-    if ( !HasFlag(wxBORDER_NONE) )
-    {
-        int marginH = 0,
-            marginV = 0;
-#if wxUSE_UXTHEME
-        if ( wxUxThemeEngine::GetIfActive() )
-        {
-            wxUxThemeHandle theme(const_cast<wxButton *>(this), L"BUTTON");
-
-            MARGINS margins;
-            wxUxThemeEngine::Get()->GetThemeMargins(theme, NULL,
-                                                    BP_PUSHBUTTON,
-                                                    PBS_NORMAL,
-                                                    TMT_CONTENTMARGINS,
-                                                    NULL,
-                                                    &margins);
-
-            // XP doesn't draw themed buttons correctly when the client
-            // area is smaller than 8x8 - enforce this minimum size for
-            // small bitmaps
-            size.IncTo(wxSize(8, 8));
-
-            marginH = margins.cxLeftWidth + margins.cxRightWidth
-                        + 2*XP_BUTTON_EXTRA_MARGIN;
-            marginV = margins.cyTopHeight + margins.cyBottomHeight
-                        + 2*XP_BUTTON_EXTRA_MARGIN;
-        }
-        else
-#endif // wxUSE_UXTHEME
-        {
-            marginH =
-            marginV = OD_BUTTON_MARGIN;
-        }
-
-        size.IncBy(marginH, marginV);
-    }
-}
-
-wxSize wxButton::DoGetBestSize() const
-{
-    wxButton * const self = const_cast<wxButton *>(this);
-
-    wxSize size;
-
-    // Account for the text part if we have it.
-    if ( ShowsLabel() )
-    {
-        int flags = 0;
-        if ( GetAuthNeeded() )
-            flags |= wxMSWButton::Size_AuthNeeded;
-
-#if wxUSE_MARKUP
-        if ( m_markupText )
-        {
-            wxClientDC dc(self);
-            size = wxMSWButton::GetFittingSize(self,
-                                               m_markupText->Measure(dc),
-                                               flags);
-        }
-        else // Normal plain text (but possibly multiline) label.
-#endif // wxUSE_MARKUP
-        {
-            size = wxMSWButton::ComputeBestFittingSize(self, flags);
-        }
-    }
-
-    if ( m_imageData )
-        AdjustForBitmapSize(size);
-
-    return wxMSWButton::IncreaseToStdSizeAndCache(self, size);
-}
-
-/* static */
-wxSize wxButtonBase::GetDefaultSize()
-{
-    static wxSize s_sizeBtn;
-
-    if ( s_sizeBtn.x == 0 )
-    {
-        wxScreenDC dc;
-        dc.SetFont(wxSystemSettings::GetFont(wxSYS_DEFAULT_GUI_FONT));
-
-        // The size of a standard button in the dialog units is 50x14,
-        // translate this to pixels.
-        //
-        // Windows' computes dialog units using average character width over
-        // upper- and lower-case ASCII alphabet and not using the average
-        // character width metadata stored in the font; see
-        // http://support.microsoft.com/default.aspx/kb/145994 for detailed
-        // discussion.
-        //
-        // NB: wxMulDivInt32() is used, because it correctly rounds the result
-
-        const wxSize base = wxPrivate::GetAverageASCIILetterSize(dc);
-        s_sizeBtn.x = wxMulDivInt32(50, base.x, 4);
-        s_sizeBtn.y = wxMulDivInt32(14, base.y, 8);
-    }
-
-    return s_sizeBtn;
-}
-
 // ----------------------------------------------------------------------------
 // default button handling
 // ----------------------------------------------------------------------------
@@ -746,7 +167,7 @@ wxSize wxButtonBase::GetDefaultSize()
 wxWindow *wxButton::SetDefault()
 {
     // set this one as the default button both for wxWidgets ...
-    wxWindow *winOldDefault = wxButtonBase::SetDefault();
+    wxWindow *winOldDefault = wxAbstractButtonBase::SetDefault();
 
     // ... and Windows
     SetDefaultStyle(wxDynamicCast(winOldDefault, wxButton), false);
@@ -814,7 +235,7 @@ void wxButton::UnsetTmpDefault()
 
 /* static */
 void
-wxButton::SetDefaultStyle(wxButton *btn, bool on)
+wxButton::SetDefaultStyle(wxAbstractButton *btn, bool on)
 {
     // we may be called with NULL pointer -- simpler to do the check here than
     // in the caller which does wxDynamicCast()
@@ -874,693 +295,8 @@ bool wxButton::SendClickEvent()
     return ProcessCommand(event);
 }
 
-void wxButton::Command(wxCommandEvent & event)
-{
-    ProcessCommand(event);
-}
-
-// ----------------------------------------------------------------------------
-// event/message handlers
-// ----------------------------------------------------------------------------
-
-bool wxButton::MSWCommand(WXUINT param, WXWORD WXUNUSED(id))
+void wxButton::Init()
 {
-    bool processed = false;
-    switch ( param )
-    {
-        // NOTE: Apparently older versions (NT 4?) of the common controls send
-        //       BN_DOUBLECLICKED but not a second BN_CLICKED for owner-drawn
-        //       buttons, so in order to send two EVT_BUTTON events we should
-        //       catch both types.  Currently (Feb 2003) up-to-date versions of
-        //       win98, win2k and winXP all send two BN_CLICKED messages for
-        //       all button types, so we don't catch BN_DOUBLECLICKED anymore
-        //       in order to not get 3 EVT_BUTTON events.  If this is a problem
-        //       then we need to figure out which version of the comctl32 changed
-        //       this behaviour and test for it.
-
-        case 1:                     // message came from an accelerator
-        case BN_CLICKED:            // normal buttons send this
-            processed = SendClickEvent();
-            break;
-    }
-
-    return processed;
-}
-
-WXLRESULT wxButton::MSWWindowProc(WXUINT nMsg, WXWPARAM wParam, WXLPARAM lParam)
-{
-    // when we receive focus, we want to temporarily become the default button in
-    // our parent panel so that pressing "Enter" would activate us -- and when
-    // losing it we should restore the previous default button as well
-    if ( nMsg == WM_SETFOCUS )
-    {
-        SetTmpDefault();
-
-        // let the default processing take place too
-    }
-    else if ( nMsg == WM_KILLFOCUS )
-    {
-        UnsetTmpDefault();
-    }
-    else if ( nMsg == WM_LBUTTONDBLCLK )
-    {
-        // emulate a click event to force an owner-drawn button to change its
-        // appearance - without this, it won't do it
-        (void)wxControl::MSWWindowProc(WM_LBUTTONDOWN, wParam, lParam);
-
-        // and continue with processing the message normally as well
-    }
-#if wxUSE_UXTHEME
-    else if ( nMsg == WM_THEMECHANGED )
-    {
-        // need to recalculate the best size here
-        // as the theme size might have changed
-        InvalidateBestSize();
-    }
-#endif // wxUSE_UXTHEME
-    // must use m_mouseInWindow here instead of IsMouseInWindow()
-    // since we need to know the first time the mouse enters the window
-    // and IsMouseInWindow() would return true in this case
-    else if ( (nMsg == WM_MOUSEMOVE && !m_mouseInWindow) ||
-                nMsg == WM_MOUSELEAVE )
-    {
-        if (
-                IsEnabled() &&
-                (
-#if wxUSE_UXTHEME
-                wxUxThemeEngine::GetIfActive() ||
-#endif // wxUSE_UXTHEME
-                 (m_imageData && m_imageData->GetBitmap(State_Current).IsOk())
-                )
-           )
-        {
-            Refresh();
-        }
-    }
-
-    // let the base class do all real processing
-    return wxControl::MSWWindowProc(nMsg, wParam, lParam);
-}
-
-// ----------------------------------------------------------------------------
-// authentication needed handling
-// ----------------------------------------------------------------------------
-
-bool wxButton::DoGetAuthNeeded() const
-{
-    return m_authNeeded;
-}
-
-void wxButton::DoSetAuthNeeded(bool show)
-{
-    // show/hide UAC symbol on Windows Vista and later
-    if ( wxGetWinVersion() >= wxWinVersion_6 )
-    {
-        m_authNeeded = show;
-        ::SendMessage(GetHwnd(), BCM_SETSHIELD, 0, show);
-        InvalidateBestSize();
-    }
-}
-
-// ----------------------------------------------------------------------------
-// button images
-// ----------------------------------------------------------------------------
-
-wxBitmap wxButton::DoGetBitmap(State which) const
-{
-    return m_imageData ? m_imageData->GetBitmap(which) : wxBitmap();
-}
-
-void wxButton::DoSetBitmap(const wxBitmap& bitmap, State which)
-{
-#if wxUSE_UXTHEME
-    wxXPButtonImageData *oldData = NULL;
-#endif // wxUSE_UXTHEME
-
-    // Check if we already had bitmaps of different size.
-    if ( m_imageData &&
-          bitmap.GetSize() != m_imageData->GetBitmap(State_Normal).GetSize() )
-    {
-        wxASSERT_MSG( which == State_Normal,
-                      "Must set normal bitmap with the new size first" );
-
-#if wxUSE_UXTHEME
-        if ( ShowsLabel() && wxUxThemeEngine::GetIfActive() )
-        {
-            // We can't change the size of the images stored in wxImageList
-            // in wxXPButtonImageData::m_iml so force recreating it below but
-            // keep the current data to copy its values into the new one.
-            oldData = static_cast<wxXPButtonImageData *>(m_imageData);
-            m_imageData = NULL;
-        }
-#endif // wxUSE_UXTHEME
-        //else: wxODButtonImageData doesn't require anything special
-    }
-
-    // allocate the image data when the first bitmap is set
-    if ( !m_imageData )
-    {
-#if wxUSE_UXTHEME
-        // using image list doesn't work correctly if we don't have any label
-        // (even if we use BUTTON_IMAGELIST_ALIGN_CENTER alignment and
-        // BS_BITMAP style), at least under Windows 2003 so use owner drawn
-        // strategy for bitmap-only buttons
-        if ( ShowsLabel() && wxUxThemeEngine::GetIfActive() )
-        {
-            m_imageData = new wxXPButtonImageData(this, bitmap);
-
-            if ( oldData )
-            {
-                // Preserve the old values in case the user changed them.
-                m_imageData->SetBitmapPosition(oldData->GetBitmapPosition());
-
-                const wxSize oldMargins = oldData->GetBitmapMargins();
-                m_imageData->SetBitmapMargins(oldMargins.x, oldMargins.y);
-
-                // No need to preserve the bitmaps though as they were of wrong
-                // size anyhow.
-
-                delete oldData;
-            }
-        }
-        else
-#endif // wxUSE_UXTHEME
-        {
-            m_imageData = new wxODButtonImageData(this, bitmap);
-            MakeOwnerDrawn();
-        }
-    }
-    else
-    {
-        m_imageData->SetBitmap(bitmap, which);
-    }
-
-    // it should be enough to only invalidate the best size when the normal
-    // bitmap changes as all bitmaps assigned to the button should be of the
-    // same size anyhow
-    if ( which == State_Normal )
-        InvalidateBestSize();
-
-    Refresh();
-}
-
-wxSize wxButton::DoGetBitmapMargins() const
-{
-    return m_imageData ? m_imageData->GetBitmapMargins() : wxSize(0, 0);
-}
-
-void wxButton::DoSetBitmapMargins(wxCoord x, wxCoord y)
-{
-    wxCHECK_RET( m_imageData, "SetBitmap() must be called first" );
-
-    m_imageData->SetBitmapMargins(x, y);
-    InvalidateBestSize();
-}
-
-void wxButton::DoSetBitmapPosition(wxDirection dir)
-{
-    wxCHECK_RET( m_imageData, "SetBitmap() must be called first" );
-
-    m_imageData->SetBitmapPosition(dir);
-    InvalidateBestSize();
-}
-
-// ----------------------------------------------------------------------------
-// markup support
-// ----------------------------------------------------------------------------
-
-#if wxUSE_MARKUP
-
-bool wxButton::DoSetLabelMarkup(const wxString& markup)
-{
-    if ( !wxButtonBase::DoSetLabelMarkup(markup) )
-        return false;
-
-    if ( !m_markupText )
-    {
-        m_markupText = new wxMarkupText(markup);
-        MakeOwnerDrawn();
-    }
-    else
-    {
-        // We are already owner-drawn so just update the text.
-        m_markupText->SetMarkup(markup);
-    }
-
-    Refresh();
-
-    return true;
-}
-
-#endif // wxUSE_MARKUP
-
-// ----------------------------------------------------------------------------
-// owner-drawn buttons support
-// ----------------------------------------------------------------------------
-
-// drawing helpers
-namespace
-{
-
-// return the button state using both the ODS_XXX flags specified in state
-// parameter and the current button state
-wxButton::State GetButtonState(wxButton *btn, UINT state)
-{
-    if ( state & ODS_DISABLED )
-        return wxButton::State_Disabled;
-
-    if ( state & ODS_SELECTED )
-        return wxButton::State_Pressed;
-
-    if ( btn->HasCapture() || btn->IsMouseInWindow() )
-        return wxButton::State_Current;
-
-    if ( state & ODS_FOCUS )
-        return wxButton::State_Focused;
-
-    return wxButton::State_Normal;
-}
-
-void DrawButtonText(HDC hdc,
-                    RECT *pRect,
-                    wxButton *btn,
-                    int flags)
-{
-    const wxString text = btn->GetLabel();
-
-    if ( text.find(wxT('\n')) != wxString::npos )
-    {
-        // draw multiline label
-
-        // center text horizontally in any case
-        flags |= DT_CENTER;
-
-        // first we need to compute its bounding rect
-        RECT rc;
-        ::CopyRect(&rc, pRect);
-        ::DrawText(hdc, text.wx_str(), text.length(), &rc,
-                   DT_CENTER | DT_CALCRECT);
-
-        // now center this rect inside the entire button area
-        const LONG w = rc.right - rc.left;
-        const LONG h = rc.bottom - rc.top;
-        rc.left = (pRect->right - pRect->left)/2 - w/2;
-        rc.right = rc.left+w;
-        rc.top = (pRect->bottom - pRect->top)/2 - h/2;
-        rc.bottom = rc.top+h;
-
-        ::DrawText(hdc, text.wx_str(), text.length(), &rc, flags);
-    }
-    else // single line label
-    {
-        // translate wx button flags to alignment flags for DrawText()
-        if ( btn->HasFlag(wxBU_RIGHT) )
-        {
-            flags |= DT_RIGHT;
-        }
-        else if ( !btn->HasFlag(wxBU_LEFT) )
-        {
-            flags |= DT_CENTER;
-        }
-        //else: DT_LEFT is the default anyhow (and its value is 0 too)
-
-        if ( btn->HasFlag(wxBU_BOTTOM) )
-        {
-            flags |= DT_BOTTOM;
-        }
-        else if ( !btn->HasFlag(wxBU_TOP) )
-        {
-            flags |= DT_VCENTER;
-        }
-        //else: as above, DT_TOP is the default
-
-        // notice that we must have DT_SINGLELINE for vertical alignment flags
-        // to work
-        ::DrawText(hdc, text.wx_str(), text.length(), pRect,
-                   flags | DT_SINGLELINE );
-    }
-}
-
-void DrawRect(HDC hdc, const RECT& r)
-{
-    wxDrawLine(hdc, r.left, r.top, r.right, r.top);
-    wxDrawLine(hdc, r.right, r.top, r.right, r.bottom);
-    wxDrawLine(hdc, r.right, r.bottom, r.left, r.bottom);
-    wxDrawLine(hdc, r.left, r.bottom, r.left, r.top);
-}
-
-/*
-   The button frame looks like this normally:
-
-   WWWWWWWWWWWWWWWWWWB
-   WHHHHHHHHHHHHHHHHGB  W = white       (HILIGHT)
-   WH               GB  H = light grey  (LIGHT)
-   WH               GB  G = dark grey   (SHADOW)
-   WH               GB  B = black       (DKSHADOW)
-   WH               GB
-   WGGGGGGGGGGGGGGGGGB
-   BBBBBBBBBBBBBBBBBBB
-
-   When the button is selected, the button becomes like this (the total button
-   size doesn't change):
-
-   BBBBBBBBBBBBBBBBBBB
-   BWWWWWWWWWWWWWWWWBB
-   BWHHHHHHHHHHHHHHGBB
-   BWH             GBB
-   BWH             GBB
-   BWGGGGGGGGGGGGGGGBB
-   BBBBBBBBBBBBBBBBBBB
-   BBBBBBBBBBBBBBBBBBB
-
-   When the button is pushed (while selected) it is like:
-
-   BBBBBBBBBBBBBBBBBBB
-   BGGGGGGGGGGGGGGGGGB
-   BG               GB
-   BG               GB
-   BG               GB
-   BG               GB
-   BGGGGGGGGGGGGGGGGGB
-   BBBBBBBBBBBBBBBBBBB
-*/
-void DrawButtonFrame(HDC hdc, RECT& rectBtn,
-                     bool selected, bool pushed)
-{
-    RECT r;
-    CopyRect(&r, &rectBtn);
-
-    AutoHPEN hpenBlack(GetSysColor(COLOR_3DDKSHADOW)),
-             hpenGrey(GetSysColor(COLOR_3DSHADOW)),
-             hpenLightGr(GetSysColor(COLOR_3DLIGHT)),
-             hpenWhite(GetSysColor(COLOR_3DHILIGHT));
-
-    SelectInHDC selectPen(hdc, hpenBlack);
-
-    r.right--;
-    r.bottom--;
-
-    if ( pushed )
-    {
-        DrawRect(hdc, r);
-
-        (void)SelectObject(hdc, hpenGrey);
-        ::InflateRect(&r, -1, -1);
-
-        DrawRect(hdc, r);
-    }
-    else // !pushed
-    {
-        if ( selected )
-        {
-            DrawRect(hdc, r);
-
-            ::InflateRect(&r, -1, -1);
-        }
-
-        wxDrawLine(hdc, r.left, r.bottom, r.right, r.bottom);
-        wxDrawLine(hdc, r.right, r.bottom, r.right, r.top - 1);
-
-        (void)SelectObject(hdc, hpenWhite);
-        wxDrawLine(hdc, r.left, r.bottom - 1, r.left, r.top);
-        wxDrawLine(hdc, r.left, r.top, r.right, r.top);
-
-        (void)SelectObject(hdc, hpenLightGr);
-        wxDrawLine(hdc, r.left + 1, r.bottom - 2, r.left + 1, r.top + 1);
-        wxDrawLine(hdc, r.left + 1, r.top + 1, r.right - 1, r.top + 1);
-
-        (void)SelectObject(hdc, hpenGrey);
-        wxDrawLine(hdc, r.left + 1, r.bottom - 1, r.right - 1, r.bottom - 1);
-        wxDrawLine(hdc, r.right - 1, r.bottom - 1, r.right - 1, r.top);
-    }
-
-    InflateRect(&rectBtn, -OD_BUTTON_MARGIN, -OD_BUTTON_MARGIN);
-}
-
-#if wxUSE_UXTHEME
-void DrawXPBackground(wxButton *button, HDC hdc, RECT& rectBtn, UINT state)
-{
-    wxUxThemeHandle theme(button, L"BUTTON");
-
-    // this array is indexed by wxButton::State values and so must be kept in
-    // sync with it
-    static const int uxStates[] =
-    {
-        PBS_NORMAL, PBS_HOT, PBS_PRESSED, PBS_DISABLED, PBS_DEFAULTED
-    };
-
-    int iState = uxStates[GetButtonState(button, state)];
-
-    wxUxThemeEngine * const engine = wxUxThemeEngine::Get();
-
-    // draw parent background if needed
-    if ( engine->IsThemeBackgroundPartiallyTransparent
-                 (
-                    theme,
-                    BP_PUSHBUTTON,
-                    iState
-                 ) )
-    {
-        // Set this button as the one whose background is being erased: this
-        // allows our WM_ERASEBKGND handler used by DrawThemeParentBackground()
-        // to correctly align the background brush with this window instead of
-        // the parent window to which WM_ERASEBKGND is sent. Notice that this
-        // doesn't work with custom user-defined EVT_ERASE_BACKGROUND handlers
-        // as they won't be aligned but unfortunately all the attempts to fix
-        // it by shifting DC origin before calling DrawThemeParentBackground()
-        // failed to work so we at least do this, even though this is far from
-        // being the perfect solution.
-        wxWindowBeingErased = button;
-
-        engine->DrawThemeParentBackground(GetHwndOf(button), hdc, &rectBtn);
-
-        wxWindowBeingErased = NULL;
-    }
-
-    // draw background
-    engine->DrawThemeBackground(theme, hdc, BP_PUSHBUTTON, iState,
-                                &rectBtn, NULL);
-
-    // calculate content area margins
-    MARGINS margins;
-    engine->GetThemeMargins(theme, hdc, BP_PUSHBUTTON, iState,
-                            TMT_CONTENTMARGINS, &rectBtn, &margins);
-    ::InflateRect(&rectBtn, -margins.cxLeftWidth, -margins.cyTopHeight);
-    ::InflateRect(&rectBtn, -XP_BUTTON_EXTRA_MARGIN, -XP_BUTTON_EXTRA_MARGIN);
-
-    if ( button->UseBgCol() )
-    {
-        COLORREF colBg = wxColourToRGB(button->GetBackgroundColour());
-        AutoHBRUSH hbrushBackground(colBg);
-
-        // don't overwrite the focus rect
-        RECT rectClient;
-        ::CopyRect(&rectClient, &rectBtn);
-        ::InflateRect(&rectClient, -1, -1);
-        FillRect(hdc, &rectClient, hbrushBackground);
-    }
-}
-#endif // wxUSE_UXTHEME
-
-} // anonymous namespace
-
-// ----------------------------------------------------------------------------
-// owner drawn buttons support
-// ----------------------------------------------------------------------------
-
-void wxButton::MakeOwnerDrawn()
-{
-    long style = GetWindowLong(GetHwnd(), GWL_STYLE);
-    if ( (style & BS_OWNERDRAW) != BS_OWNERDRAW )
-    {
-        // make it so
-        style |= BS_OWNERDRAW;
-        SetWindowLong(GetHwnd(), GWL_STYLE, style);
-    }
-}
-
-bool wxButton::SetBackgroundColour(const wxColour &colour)
-{
-    if ( !wxControl::SetBackgroundColour(colour) )
-    {
-        // nothing to do
-        return false;
-    }
-
-    MakeOwnerDrawn();
-
-    Refresh();
-
-    return true;
-}
-
-bool wxButton::SetForegroundColour(const wxColour &colour)
-{
-    if ( !wxControl::SetForegroundColour(colour) )
-    {
-        // nothing to do
-        return false;
-    }
-
-    MakeOwnerDrawn();
-
-    Refresh();
-
-    return true;
-}
-
-bool wxButton::MSWOnDraw(WXDRAWITEMSTRUCT *wxdis)
-{
-    LPDRAWITEMSTRUCT lpDIS = (LPDRAWITEMSTRUCT)wxdis;
-    HDC hdc = lpDIS->hDC;
-
-    UINT state = lpDIS->itemState;
-    bool pushed = (SendMessage(GetHwnd(), BM_GETSTATE, 0, 0) & BST_PUSHED) != 0;
-
-    RECT rectBtn;
-    CopyRect(&rectBtn, &lpDIS->rcItem);
-
-    // draw the button background
-    if ( !HasFlag(wxBORDER_NONE) )
-    {
-#if wxUSE_UXTHEME
-        if ( wxUxThemeEngine::GetIfActive() )
-        {
-            DrawXPBackground(this, hdc, rectBtn, state);
-        }
-        else
-#endif // wxUSE_UXTHEME
-        {
-            COLORREF colBg = wxColourToRGB(GetBackgroundColour());
-
-            // first, draw the background
-            AutoHBRUSH hbrushBackground(colBg);
-            FillRect(hdc, &rectBtn, hbrushBackground);
-
-            // draw the border for the current state
-            bool selected = (state & ODS_SELECTED) != 0;
-            if ( !selected )
-            {
-                wxTopLevelWindow *
-                    tlw = wxDynamicCast(wxGetTopLevelParent(this), wxTopLevelWindow);
-                if ( tlw )
-                {
-                    selected = tlw->GetDefaultItem() == this;
-                }
-            }
-
-            DrawButtonFrame(hdc, rectBtn, selected, pushed);
-        }
-
-        // draw the focus rectangle if we need it
-        if ( (state & ODS_FOCUS) && !(state & ODS_NOFOCUSRECT) )
-        {
-            DrawFocusRect(hdc, &rectBtn);
-
-#if wxUSE_UXTHEME
-            if ( !wxUxThemeEngine::GetIfActive() )
-#endif // wxUSE_UXTHEME
-            {
-                if ( pushed )
-                {
-                    // the label is shifted by 1 pixel to create "pushed" effect
-                    OffsetRect(&rectBtn, 1, 1);
-                }
-            }
-        }
-    }
-
-
-    // draw the image, if any
-    if ( m_imageData )
-    {
-        wxBitmap bmp = m_imageData->GetBitmap(GetButtonState(this, state));
-        if ( !bmp.IsOk() )
-            bmp = m_imageData->GetBitmap(State_Normal);
-
-        const wxSize sizeBmp = bmp.GetSize();
-        const wxSize margin = m_imageData->GetBitmapMargins();
-        const wxSize sizeBmpWithMargins(sizeBmp + 2*margin);
-        wxRect rectButton(wxRectFromRECT(rectBtn));
-
-        // for simplicity, we start with centred rectangle and then move it to
-        // the appropriate edge
-        wxRect rectBitmap = wxRect(sizeBmp).CentreIn(rectButton);
-
-        // move bitmap only if we have a label, otherwise keep it centered
-        if ( ShowsLabel() )
-        {
-            switch ( m_imageData->GetBitmapPosition() )
-            {
-                default:
-                    wxFAIL_MSG( "invalid direction" );
-                    // fall through
-
-                case wxLEFT:
-                    rectBitmap.x = rectButton.x + margin.x;
-                    rectButton.x += sizeBmpWithMargins.x;
-                    rectButton.width -= sizeBmpWithMargins.x;
-                    break;
-
-                case wxRIGHT:
-                    rectBitmap.x = rectButton.GetRight() - sizeBmp.x - margin.x;
-                    rectButton.width -= sizeBmpWithMargins.x;
-                    break;
-
-                case wxTOP:
-                    rectBitmap.y = rectButton.y + margin.y;
-                    rectButton.y += sizeBmpWithMargins.y;
-                    rectButton.height -= sizeBmpWithMargins.y;
-                    break;
-
-                case wxBOTTOM:
-                    rectBitmap.y = rectButton.GetBottom() - sizeBmp.y - margin.y;
-                    rectButton.height -= sizeBmpWithMargins.y;
-                    break;
-            }
-        }
-
-        wxDCTemp dst((WXHDC)hdc);
-        dst.DrawBitmap(bmp, rectBitmap.GetPosition(), true);
-
-        wxCopyRectToRECT(rectButton, rectBtn);
-    }
-
-
-    // finally draw the label
-    if ( ShowsLabel() )
-    {
-        COLORREF colFg = state & ODS_DISABLED
-                            ? ::GetSysColor(COLOR_GRAYTEXT)
-                            : wxColourToRGB(GetForegroundColour());
-
-        wxTextColoursChanger changeFg(hdc, colFg, CLR_INVALID);
-        wxBkModeChanger changeBkMode(hdc, wxBRUSHSTYLE_TRANSPARENT);
-
-#if wxUSE_MARKUP
-        if ( m_markupText )
-        {
-            wxDCTemp dc((WXHDC)hdc);
-            dc.SetTextForeground(wxColour(colFg));
-            dc.SetFont(GetFont());
-
-            m_markupText->Render(dc, wxRectFromRECT(rectBtn),
-                                 state & ODS_NOACCEL
-                                    ? wxMarkupText::Render_Default
-                                    : wxMarkupText::Render_ShowAccels);
-        }
-        else // Plain text label
-#endif // wxUSE_MARKUP
-        {
-            // notice that DT_HIDEPREFIX doesn't work on old (pre-Windows 2000)
-            // systems but by happy coincidence ODS_NOACCEL is not used under
-            // them neither so DT_HIDEPREFIX should never be used there
-            DrawButtonText(hdc, &rectBtn, this,
-                           state & ODS_NOACCEL ? DT_HIDEPREFIX : 0);
-        }
-    }
-
-    return true;
 }
 
 #endif // wxUSE_BUTTON
diff --git a/src/msw/tglbtn.cpp b/src/msw/tglbtn.cpp
index cde1757..03c6865 100644
--- a/src/msw/tglbtn.cpp
+++ b/src/msw/tglbtn.cpp
@@ -54,202 +54,11 @@ wxDEFINE_EVENT( wxEVT_COMMAND_TOGGLEBUTTON_CLICKED, wxCommandEvent );
 // implementation
 // ============================================================================
 
-//-----------------------------------------------------------------------------
-// wxBitmapToggleButton
-//-----------------------------------------------------------------------------
-
-IMPLEMENT_DYNAMIC_CLASS(wxBitmapToggleButton, wxControl)
-
-BEGIN_EVENT_TABLE(wxBitmapToggleButton,wxToggleButtonBase)
-   EVT_PAINT(wxBitmapToggleButton::OnPaint)
-   EVT_MOUSE_EVENTS(wxBitmapToggleButton::OnMouse)
-   EVT_CHAR(wxBitmapToggleButton::OnChar)
-   EVT_SIZE(wxBitmapToggleButton::OnSize)
-END_EVENT_TABLE()
-
-void wxBitmapToggleButton::Init()
-{
-    m_depressed = false;
-    m_oldValue = false;
-    m_capturing = false;
-}
-
-bool wxBitmapToggleButton::Create( wxWindow *parent, wxWindowID id,
-                const wxBitmap& label,const wxPoint& pos, const wxSize& size, long style,
-                const wxValidator& validator, const wxString& name )
-{
-    Init();
-
-    if (!wxToggleButtonBase::Create( parent, id, pos, size, style, validator, name ))
-        return false;
-
-    m_bitmap = label;
-
-    if (size.x == -1 || size.y == -1)
-    {
-        wxSize new_size = GetBestSize();
-        if (size.x != -1)
-            new_size.x = size.x;
-        if (size.y != -1)
-            new_size.y = size.y;
-        SetSize( new_size );
-    }
-
-    return true;
-}
-
-void wxBitmapToggleButton::SetValue(bool state)
-{
-    if (m_capturing) return;
-
-    if (state == m_depressed) return;
-
-    m_depressed = state;
-    Refresh();
-}
-
-bool wxBitmapToggleButton::GetValue() const
-{
-    return m_depressed;
-}
-
-void wxBitmapToggleButton::SetLabel(const wxBitmap& label)
-{
-    m_bitmap = label;
-    m_disabledBitmap = wxBitmap();
-
-    Refresh();
-}
-
-bool wxBitmapToggleButton::Enable(bool enable)
-{
-    if (m_capturing) return false;
-
-    if (!wxToggleButtonBase::Enable( enable ))
-      return false;
-
-    Refresh();
-
-    return true;
-}
-
-void wxBitmapToggleButton::OnPaint(wxPaintEvent &WXUNUSED(event))
-{
-    wxSize size = GetSize();
-
-    wxBitmap bitmap = m_bitmap;
-
-    wxPaintDC dc(this);
-    wxRendererNative &renderer = wxRendererNative::Get();
-    int flags = 0;
-    if (m_depressed)
-        flags |= wxCONTROL_PRESSED;
-    wxRect rect(0,0,size.x,size.y);
-    renderer.DrawPushButton( this, dc, rect, flags );
-
-    if (bitmap.IsOk())
-    {
-        if (!IsEnabled())
-        {
-            if (!m_disabledBitmap.IsOk())
-            {
-                wxImage image = m_bitmap.ConvertToImage();
-                m_disabledBitmap = wxBitmap( image.ConvertToGreyscale() );
-            }
-
-            bitmap = m_disabledBitmap;
-        }
-
-        wxSize bsize = bitmap.GetSize();
-        int offset = 0;
-        if (m_depressed) offset = 1;
-        dc.DrawBitmap( bitmap, (size.x-bsize.x) / 2 + offset, (size.y-bsize.y) / 2 + offset, true );
-    }
-
-}
-
-void wxBitmapToggleButton::OnMouse(wxMouseEvent &event)
-{
-    if (!IsEnabled())
-        return;
-
-    wxSize size = GetSize();
-    bool mouse_in = ((event.GetX() > 0) && (event.GetX() < size.x) &&
-                     (event.GetY() > 0) && (event.GetY() < size.y));
-
-    if (m_capturing)
-    {
-        bool old_depressed = m_depressed;
-        if (mouse_in)
-            m_depressed = !m_oldValue;
-        else
-            m_depressed = m_oldValue;
-
-        if (event.LeftUp())
-        {
-            ReleaseMouse();
-            m_capturing = false;
-            if (mouse_in)
-            {
-                wxCommandEvent event(wxEVT_COMMAND_TOGGLEBUTTON_CLICKED, m_windowId);
-                event.SetInt(GetValue());
-                event.SetEventObject(this);
-                ProcessCommand(event);
-            }
-        }
-
-        if (old_depressed != m_depressed)
-           Refresh();
-    }
-    else
-    {
-        if (event.LeftDown())
-        {
-            m_capturing = true;
-            m_oldValue = m_depressed;
-            m_depressed = !m_oldValue;
-            CaptureMouse();
-            Refresh();
-        }
-    }
-}
-
-void wxBitmapToggleButton::OnChar(wxKeyEvent &event)
-{
-   if (event.GetKeyCode() == WXK_SPACE)
-   {
-       m_depressed = !m_depressed;
-       Refresh();
-
-       wxCommandEvent event(wxEVT_COMMAND_TOGGLEBUTTON_CLICKED, m_windowId);
-       event.SetInt(GetValue());
-       event.SetEventObject(this);
-       ProcessCommand(event);
-   }
-}
-
-void wxBitmapToggleButton::OnSize(wxSizeEvent &WXUNUSED(event))
-{
-    Refresh();
-}
-
-wxSize wxBitmapToggleButton::DoGetBestSize() const
-{
-    if (!m_bitmap.IsOk())
-        return wxSize(16,16);
-
-    wxSize ret = m_bitmap.GetSize();
-    ret.x += 8;
-    ret.y += 8;
-    return ret;
-}
-
-
 // ----------------------------------------------------------------------------
 // wxToggleButton
 // ----------------------------------------------------------------------------
 
-IMPLEMENT_DYNAMIC_CLASS(wxToggleButton, wxControl)
+IMPLEMENT_DYNAMIC_CLASS(wxToggleButton, wxAbstractButton)
 
 // Single check box item
 bool wxToggleButton::Create(wxWindow *parent,
@@ -260,27 +69,30 @@ bool wxToggleButton::Create(wxWindow *parent,
                             const wxValidator& validator,
                             const wxString& name)
 {
-    if ( !CreateControl(parent, id, pos, size, style, validator, name) )
-        return false;
+    bool success =
+        wxAbstractButton::Create(parent, id, label, pos, size, style, validator, name);
+
+    if(success)
+    {
+        // Make sure that the shadow variable and button states are in sync
+        SetValue(selected);
+    }
 
-    // if the label contains several lines we must explicitly tell the button
-    // about it or it wouldn't draw it correctly ("\n"s would just appear as
-    // black boxes)
-    //
-    // NB: we do it here and not in MSWGetStyle() because we need the label
-    //     value and the label is not set yet when MSWGetStyle() is called
-    WXDWORD exstyle;
-    WXDWORD msStyle = MSWGetStyle(style, &exstyle);
-    msStyle |= wxMSWButton::GetMultilineStyle(label);
-
-    return MSWCreateControl(wxT("BUTTON"), msStyle, pos, size, label, exstyle);
+    return success;
+}
+
+bool wxToggleButton::MSWCommand(WXUINT WXUNUSED(param), WXWORD WXUNUSED(id))
+{
+    SendClickEvent();
+
+    return true;
 }
 
 WXDWORD wxToggleButton::MSWGetStyle(long style, WXDWORD *exstyle) const
 {
     WXDWORD msStyle = wxControl::MSWGetStyle(style, exstyle);
 
-    msStyle |= BS_AUTOCHECKBOX | BS_PUSHLIKE | WS_TABSTOP;
+    msStyle |= BS_CHECKBOX | BS_PUSHLIKE | WS_TABSTOP;
 
     if ( style & wxBU_LEFT )
       msStyle |= BS_LEFT;
@@ -294,26 +106,21 @@ WXDWORD wxToggleButton::MSWGetStyle(long style, WXDWORD *exstyle) const
     return msStyle;
 }
 
-wxSize wxToggleButton::DoGetBestSize() const
-{
-    return wxMSWButton::ComputeBestSize(const_cast<wxToggleButton *>(this));
-}
-
-void wxToggleButton::SetLabel(const wxString& label)
+void wxToggleButton::SetValue(bool val)
 {
-    wxMSWButton::UpdateMultilineStyle(GetHwnd(), label);
+    // The text only case requires Windows to know the state
+    ::SendMessage(GetHwnd(), BM_SETCHECK, val, 0);
 
-    wxToggleButtonBase::SetLabel(label);
-}
+    // But the bitmap & bitmap + label cases rely on a shadow
+    // variable
+    selected = val;
 
-void wxToggleButton::SetValue(bool val)
-{
-   ::SendMessage(GetHwnd(), BM_SETCHECK, val, 0);
+    Refresh();
 }
 
 bool wxToggleButton::GetValue() const
 {
-    return ::SendMessage(GetHwnd(), BM_GETCHECK, 0, 0) == BST_CHECKED;
+    return selected;
 }
 
 void wxToggleButton::Command(wxCommandEvent& event)
@@ -322,13 +129,63 @@ void wxToggleButton::Command(wxCommandEvent& event)
     ProcessCommand(event);
 }
 
-bool wxToggleButton::MSWCommand(WXUINT WXUNUSED(param), WXWORD WXUNUSED(id))
+bool wxToggleButton::SendClickEvent()
 {
+    // Do the toggle here
+    SetValue(!selected);
+
     wxCommandEvent event(wxEVT_COMMAND_TOGGLEBUTTON_CLICKED, m_windowId);
-    event.SetInt(GetValue());
+    event.SetInt(selected);
     event.SetEventObject(this);
     ProcessCommand(event);
     return true;
 }
 
+wxAbstractButtonBase::State wxToggleButton::GetButtonState(UINT state)
+{
+    if ( state & ODS_DISABLED )
+        return wxButton::State_Disabled;
+
+    if ( HasCapture() || IsMouseInWindow() )
+        return wxButton::State_Current;
+
+    if ( selected || state & ODS_SELECTED || state & ODS_CHECKED )
+        return wxButton::State_Pressed;
+
+    if ( state & ODS_FOCUS )
+        return wxButton::State_Focused;
+
+    return wxButton::State_Normal;
+}
+
+void wxToggleButton::Init()
+{
+    selected = false;
+}
+
+
+//-----------------------------------------------------------------------------
+// wxBitmapToggleButton
+//-----------------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(wxBitmapToggleButton, wxToggleButton)
+
+bool wxBitmapToggleButton::Create( wxWindow *parent, wxWindowID id,
+                const wxBitmap& label,const wxPoint& pos, const wxSize& size, long style,
+                const wxValidator& validator, const wxString& name )
+{
+    Init();
+
+    if (!wxToggleButton::Create( parent, id, wxT(""), pos, size, style, validator, name ))
+        return false;
+
+    SetBitmap(label);
+
+    return true;
+}
+
+void wxBitmapToggleButton::Init()
+{
+}
+
 #endif // wxUSE_TOGGLEBTN
