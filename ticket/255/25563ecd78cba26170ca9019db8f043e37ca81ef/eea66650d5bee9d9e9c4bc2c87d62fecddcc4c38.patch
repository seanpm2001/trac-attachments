Index: build/bakefiles/files.bkl
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/build/bakefiles/files.bkl,v
retrieving revision 1.415
diff -u2 -r1.415 build/bakefiles/files.bkl
--- build/bakefiles/files.bkl
+++ build/bakefiles/files.bkl
@@ -641,4 +641,5 @@
     src/common/srchcmn.cpp
     src/common/statbar.cpp
+    src/common/stattextcmn.cpp
     src/common/stockitem.cpp
     src/common/tbarbase.cpp
Index: docs/latex/wx/stattext.tex
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/docs/latex/wx/stattext.tex,v
retrieving revision 1.13
diff -u2 -r1.13 docs/latex/wx/stattext.tex
--- docs/latex/wx/stattext.tex
+++ docs/latex/wx/stattext.tex
@@ -27,4 +27,12 @@
 with controls which also have wxALIGN\_RIGHT or CENTER style because otherwise
 they won't make sense any longer after a call to SetLabel)}
+\twocolitem{\windowstyle{wxST\_ELLIPSIZE\_START}}{If the text exceeds the control's
+available space, ellipsize it at the beginning}
+\twocolitem{\windowstyle{wxST\_ELLIPSIZE\_MIDDLE}}{If the text exceeds the control's
+available space, ellipsize it at the middle}
+\twocolitem{\windowstyle{wxST\_ELLIPSIZE\_END}}{If the text exceeds the control's
+available space, ellipsize it at the end}
+\twocolitem{\windowstyle{wxST_MARKUP}}{Support markup in the label; see
+\helpref{SetLabel}{wxstatictextsetlabel} for more info}
 \end{twocollist}
 
@@ -80,4 +88,7 @@
 
 
+
+
+
 \membersection{wxStaticText::GetLabel}\label{wxstatictextgetlabel}
 
@@ -86,4 +97,24 @@
 Returns the contents of the control.
 
+Note that the returned string contains both the mnemonics (\texttt{\&} characters),
+if any, and the markup, if any.
+
+Use \helpref{wxStaticText::GetLabelText}{wxstatictextgetlabeltext} if they are
+undesired.
+
+
+\membersection{wxStaticText::GetLabelText}\label{wxstatictextgetlabeltext}
+
+\constfunc{const wxString\&}{GetLabelText}{\void}
+
+Returns the control's label or the given \arg{label} string for the static
+version without the mnemonics characters (if any) and without the markup (if any and
+if \tt{wxST_MARKUP} is in use).
+
+Note that unlike for \helpref{wxControl::GetLabelText}{wxcontrolgetlabeltext} there
+isn't a static version of this function since the markup
+
+
+
 
 \membersection{wxStaticText::SetLabel}\label{wxstatictextsetlabel}
@@ -94,10 +125,72 @@
 label unless the control has wxST\_NO\_AUTORESIZE flag.
 
+This function allows to set decorated static label text on platforms which support
+it natively (currently only GTK+ 2).
+Platforms which do not support markup in static text labels, will simply remove the 
+markup from the given string.
+
+The supported markup tags are:
+
+\twocolwidtha{5cm}
+\begin{twocollist}\itemsep=0pt
+\twocolitem{<b>}{bold text}
+\twocolitem{<big>}{bigger text}
+\twocolitem{<i>}{italic text}
+\twocolitem{<s>}{text with strikethrough}
+\twocolitem{<sub>}{subscript text}
+\twocolitem{<sup>}{superscript text}
+\twocolitem{<small>}{smaller text}
+\twocolitem{<tt>}{monospaced text}
+\twocolitem{<u>}{underlined text}
+\twocolitem{<span>}{generic formatter tag; see \urlref{Pango Markup}{http://developer.gnome.org/doc/API/2.0/pango/PangoMarkupFormat.html} for more info.}
+\end{twocollist}
+
+Note that the string needs to be well-formed (e.g. all tags must be correctly closed)
+otherwise the string won't be shown correctly (or won't be shown at all).
+
+Also note that you need to escape the following special characters:
+
+\twocolwidtha{5cm}
+\begin{twocollist}\itemsep=0pt
+\twocolitem{\bf{Special character}}{\bf{Escape as}}
+\twocolitem{\tt{&}}{\tt{&amp;} or as \tt{&&}}
+\twocolitem{\tt{'}}{\tt{&apos;}}
+\twocolitem{\tt{"}}{\tt{&quot;}}
+\twocolitem{\tt{<}}{\tt{&lt;}}
+\twocolitem{\tt{>}}{\tt{&gt;}}
+\end{twocollist}
+
+Note that single ampersand \tt{&} characters in the given text will be interpreted as 
+mnemonics; see \helpref{wxControl::SetLabel}{wxcontrolsetlabel} for more info.
+
+
+Example:
+
+%% TEX NOTE: in the following block we need to write the (ugly) &&amp;amp;
+%%           string in order to force Tex2rtf to show the &&amp; string
+\begin{verbatim}
+    // this will set the wxStaticText to show the "Hello world!" string
+    // with the "Hello" world bolded on platforms which support markup
+    // and will be equivalent to
+    //        SetLabel(wxT("Hello world!"));
+    // on platforms which do not support markup:
+    pStaticText->SetLabelWithMarkup(wxT("<b>Hello</b> world!"));
+
+    // this will set into the wxStaticText the string:
+    //
+    //              Specials: & ' " < >"
+    //
+    // On platforms which support markup, the "Specials" word will be smaller
+    pStaticText->SetLabelWithMarkup(
+        wxT("<small>Specials</small>: &amp;amp; &amp;apos; &amp;quot;; &amp;lt; &amp;gt;"));
+\end{verbatim}
+
 \wxheading{Parameters}
 
-\docparam{label}{The new label to set. It may contain newline characters.}
+\docparam{label}{The new label to set. It may contain newline characters and the markup described above.}
+
 
 
-\membersection{wxStaticText::Wrap}\label{wxstatictextwrpa}
+\membersection{wxStaticText::Wrap}\label{wxstatictextwrap}
 
 \func{void}{Wrap}{\param{int }{width}}
Index: include/wx/control.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/include/wx/control.h,v
retrieving revision 1.52
diff -u2 -r1.52 include/wx/control.h
--- include/wx/control.h
+++ include/wx/control.h
@@ -47,9 +47,33 @@
     int GetAlignment() const { return m_windowStyle & wxALIGN_MASK; }
 
+    // get just the text of the label, without mnemonic characters ('&')
+    wxString GetLabelText() const { return GetLabelText(GetLabel()); }
+
+    virtual void SetLabel(const wxString &str)
+    {
+        m_strOriginalLabel = str;
+
+        InvalidateBestSize();
+        wxWindow::SetLabel(str);
+    }
+
+    virtual wxString GetLabel() const
+    {
+        // return the original string, as it was passed to SetLabel()
+        // (i.e. with wx-style mnemonics)
+        return m_strOriginalLabel;
+    }
+
+    // static utilities:
+
     // get the string without mnemonic characters ('&')
     static wxString GetLabelText(const wxString& label);
 
-    // get just the text of the label, without mnemonic characters ('&')
-    wxString GetLabelText() const { return GetLabelText(GetLabel()); }
+    // removes the mnemonics characters
+    static wxString RemoveMnemonics(const wxString &str);
+
+    // escapes the mnemonics characters & simply doubling them.
+    static wxString EscapeMnemonics(const wxString &str);
+
 
     // controls by default inherit the colours of their parents, if a
@@ -65,5 +89,4 @@
     virtual void Command(wxCommandEvent &event);
 
-    virtual void SetLabel( const wxString &label );
     virtual bool SetFont(const wxFont& font);
 
@@ -85,4 +108,7 @@
     void InitCommandEvent(wxCommandEvent& event) const;
 
+    // this field contains the label in wx format, i.e. with "&" mnemonics
+    wxString m_strOriginalLabel;
+
     DECLARE_NO_COPY_CLASS(wxControlBase)
 };
Index: include/wx/stattext.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/include/wx/stattext.h,v
retrieving revision 1.25
diff -u2 -r1.25 include/wx/stattext.h
--- include/wx/stattext.h
+++ include/wx/stattext.h
@@ -0,0 +1,120 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        stattext.h
+// Purpose:     wxStaticText base header
+// Author:      Julian Smart
+// Modified by:
+// Created:
+// Copyright:   (c) Julian Smart
+// RCS-ID:      $Id: stattext.h,v 1.25 2006/01/23 03:27:34 MR Exp $
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_STATTEXT_H_BASE_
+#define _WX_STATTEXT_H_BASE_
+
+#include "wx/defs.h"
+
+#if wxUSE_STATTEXT
+
+#include "wx/control.h"
+
+/*
+ * wxStaticText flags
+ */
+#define wxST_NO_AUTORESIZE         0x0001
+#define wxST_MARKUP                0x0002
+
+#define wxST_ELLIPSIZE_START       0x0004
+#define wxST_ELLIPSIZE_MIDDLE      0x0008
+#define wxST_ELLIPSIZE_END         0x0010
+
+
+extern WXDLLEXPORT_DATA(const wxChar) wxStaticTextNameStr[];
+
+class WXDLLEXPORT wxStaticTextBase : public wxControl
+{
+public:
+    wxStaticTextBase() { }
+
+    // wrap the text of the control so that no line is longer than the given
+    // width (if possible: this function won't break words)
+    // This function will modify the value returned by GetLabel()!
+    void Wrap(int width);
+
+    // overriden base virtuals
+    virtual bool AcceptsFocus() const { return false; }
+    virtual bool HasTransparentBackground() { return true; }
+
+    bool IsEllipsized() const
+    {
+        return HasFlag(wxST_ELLIPSIZE_START) || 
+               HasFlag(wxST_ELLIPSIZE_MIDDLE) ||
+               HasFlag(wxST_ELLIPSIZE_END);
+    }
+
+    // get the string without mnemonic characters ('&') and without markup
+    // (if wxST_MARKUP is being used)
+    virtual wxString GetLabelText() const;
+
+    // public utilities (symmetric to those in wxControl about mnemonics):
+
+    // removes the markup accepted by wxStaticText when wxST_MARKUP is used,
+    // and then returns the cleaned string
+    static wxString RemoveMarkup(const wxString &str);
+
+    // escapes the < > " ' & symbols eventually-present inside the given string
+    // using the &lt; &gt; &quot; &apos; &amp; entities
+    static wxString EscapeMarkup(const wxString &str);
+
+
+protected:      // functions required for wxST_ELLIPSIZE_* support
+
+    // just calls RemoveMarkup & Ellipsize on the original label.
+    virtual wxString GetEllipsizedLabelWithoutMarkup() const;
+
+    // ellipsizes the given string and returns it
+    wxString Ellipsize(const wxString &label) const;
+
+    // to be called when updating the size of the static text:
+    // updates the label redoing ellipsization calculations
+    void UpdateLabel();
+
+    // These function are platform-specific and must be overridden by ports
+    // which do not natively support ellipsization and they must be implemented
+    // in a way so that the m_label member of wxControl is not touched:
+
+    // returns the real label currently displayed inside the control.
+    virtual wxString GetRealLabel() const  { return wxEmptyString; }
+
+    // sets the real label currently displayed inside the control,
+    // _without_ invaliding the size. The text passed is always markup-free.
+    virtual void SetRealLabel(const wxString &WXUNUSED(str)) {}
+
+private:
+    DECLARE_NO_COPY_CLASS(wxStaticTextBase)
+};
+
+#if defined(__WXUNIVERSAL__)
+    #include "wx/univ/stattext.h"
+#elif defined(__WXMSW__)
+    #include "wx/msw/stattext.h"
+#elif defined(__WXMOTIF__)
+    #include "wx/motif/stattext.h"
+#elif defined(__WXGTK20__)
+    #include "wx/gtk/stattext.h"
+#elif defined(__WXGTK__)
+    #include "wx/gtk1/stattext.h"
+#elif defined(__WXMAC__)
+    #include "wx/mac/stattext.h"
+#elif defined(__WXCOCOA__)
+    #include "wx/cocoa/stattext.h"
+#elif defined(__WXPM__)
+    #include "wx/os2/stattext.h"
+#elif defined(__WXPALMOS__)
+    #include "wx/palmos/stattext.h"
+#endif
+
+#endif // wxUSE_STATTEXT
+
+#endif
+    // _WX_STATTEXT_H_BASE_
Index: include/wx/gtk/control.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/include/wx/gtk/control.h,v
retrieving revision 1.34
diff -u2 -r1.34 include/wx/gtk/control.h
--- include/wx/gtk/control.h
+++ include/wx/gtk/control.h
@@ -44,6 +44,4 @@
             const wxString& name = wxControlNameStr);
 
-    virtual void SetLabel( const wxString &label );
-    virtual wxString GetLabel() const;
 
     virtual wxVisualAttributes GetDefaultAttributes() const;
@@ -57,4 +55,5 @@
     // sets the label to the given string and also sets it for the given widget
     void GTKSetLabelForLabel(GtkLabel *w, const wxString& label);
+    void GTKSetLabelWithMarkupForLabel(GtkLabel *w, const wxString& label);
 
     // GtkFrame helpers
@@ -68,9 +67,9 @@
 
     // converts wx label to GTK+ label, i.e. basically replace "&"s with "_"s
-    //
-    // for GTK+ 1 (which doesn't support mnemonics) this is the same as
-    // GTKRemoveMnemonics()
     static wxString GTKConvertMnemonics(const wxString &label);
 
+    // converts wx label to GTK+ labels preserving Pango markup
+    static wxString GTKConvertMnemonicsWithMarkup(const wxString &label);
+
     // These are used by GetDefaultAttributes
     static wxVisualAttributes
@@ -96,7 +95,4 @@
     virtual bool UseGTKStyleBase() const { return false; }
 
-    // this field contains the label in wx format, i.e. with "&" mnemonics
-    wxString m_label;
-
 private:
     DECLARE_DYNAMIC_CLASS(wxControl)
Index: include/wx/gtk/stattext.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/include/wx/gtk/stattext.h,v
retrieving revision 1.23
diff -u2 -r1.23 include/wx/gtk/stattext.h
--- include/wx/gtk/stattext.h
+++ include/wx/gtk/stattext.h
@@ -15,5 +15,5 @@
 //-----------------------------------------------------------------------------
 
-class WXDLLIMPEXP_CORE wxStaticText : public wxControl
+class WXDLLIMPEXP_CORE wxStaticText : public wxStaticTextBase
 {
 public:
@@ -44,6 +44,5 @@
     GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL);
 
-    // see wx/stattext.h
-    void Wrap(int width);
+
 
     // implementation
@@ -60,4 +59,7 @@
     virtual wxSize DoGetBestSize() const;
 
+    virtual wxString GetRealLabel() const;
+    virtual void SetRealLabel(const wxString &str);
+
     DECLARE_DYNAMIC_CLASS(wxStaticText)
 };
Index: include/wx/mac/carbon/stattext.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/include/wx/mac/carbon/stattext.h,v
retrieving revision 1.8
diff -u2 -r1.8 include/wx/mac/carbon/stattext.h
--- include/wx/mac/carbon/stattext.h
+++ include/wx/mac/carbon/stattext.h
@@ -43,4 +43,9 @@
 protected :
 
+    // for wxST_ELLIPSIZE_* support:
+
+    virtual wxString GetRealLabel() const;
+    virtual void SetRealLabel(const wxString &str);
+
   virtual wxSize DoGetBestSize() const ;
 
Index: include/wx/motif/stattext.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/include/wx/motif/stattext.h,v
retrieving revision 1.16
diff -u2 -r1.16 include/wx/motif/stattext.h
--- include/wx/motif/stattext.h
+++ include/wx/motif/stattext.h
@@ -53,4 +53,10 @@
         { return m_labelWidget; }
 
+
+    // for wxST_ELLIPSIZE_* support:
+
+    virtual void SetRealLabel(const wxString &str);
+    virtual wxString GetRealLabel() const;
+
 protected:
     WXWidget              m_labelWidget;
Index: include/wx/msw/stattext.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/include/wx/msw/stattext.h,v
retrieving revision 1.30
diff -u2 -r1.30 include/wx/msw/stattext.h
--- include/wx/msw/stattext.h
+++ include/wx/msw/stattext.h
@@ -50,4 +50,13 @@
     virtual wxSize DoGetBestSize() const;
 
+    // for wxST_ELLIPSIZE_* support:
+
+    // WinNT supports ellipsization at the end of the string; thus
+    // we don't need to always use wx's own ellipsization code
+    //virtual wxString GetFilteredLabel(const wxString &str) const;
+
+    virtual wxString GetRealLabel() const;
+    virtual void SetRealLabel(const wxString &str);
+
     DECLARE_DYNAMIC_CLASS_NO_COPY(wxStaticText)
 };
Index: include/wx/os2/stattext.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/include/wx/os2/stattext.h,v
retrieving revision 1.12
diff -u2 -r1.12 include/wx/os2/stattext.h
--- include/wx/os2/stattext.h
+++ include/wx/os2/stattext.h
@@ -68,4 +68,10 @@
     virtual wxSize DoGetBestSize(void) const;
 
+
+    // for wxST_ELLIPSIZE_* support:
+
+    virtual void SetRealLabel(const wxString &str);
+    virtual wxString GetRealLabel() const;
+
 private:
     DECLARE_DYNAMIC_CLASS(wxStaticText)
Index: include/wx/private/stattext.h
--- /dev/null
+++ include/wx/private/stattext.h
@@ -0,0 +1,86 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        include/wx/private/stattext.h
+// Purpose:     Internal declarations for dlgcmn.cpp and stattextcmn.cpp
+// Author:      Francesco Montorsi
+// Modified by:
+// Created:     7-1-2007
+// RCS-ID:      $Id: filename.h,v 1.1 2006/10/23 13:10:12 MW Exp $
+// Copyright:   (c) 2007 wxWidgets team
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_PRIVATE_STATTEXT_H_
+#define _WX_PRIVATE_STATTEXT_H_
+
+#if wxUSE_STATTEXT
+
+// ----------------------------------------------------------------------------
+// wxTextWrapper
+// ----------------------------------------------------------------------------
+
+// this class is used to wrap the text on word boundary: wrapping is done by
+// calling OnStartLine() and OnOutputLine() functions
+class wxTextWrapper
+{
+public:
+    wxTextWrapper() { m_eol = false; }
+
+    // win is used for getting the font, text is the text to wrap, width is the
+    // max line width or -1 to disable wrapping
+    void Wrap(wxWindow *win, const wxString& text, int widthMax);
+
+    // we don't need it, but just to avoid compiler warnings
+    virtual ~wxTextWrapper() { }
+
+protected:
+    // line may be empty
+    virtual void OnOutputLine(const wxString& line) = 0;
+
+    // called at the start of every new line (except the very first one)
+    virtual void OnNewLine() { }
+
+private:
+    // call OnOutputLine() and set m_eol to true
+    void DoOutputLine(const wxString& line)
+    {
+        OnOutputLine(line);
+
+        m_eol = true;
+    }
+
+    // this function is a destructive inspector: when it returns true it also
+    // resets the flag to false so calling it again woulnd't return true any
+    // more
+    bool IsStartOfNewLine()
+    {
+        if ( !m_eol )
+            return false;
+
+        m_eol = false;
+
+        return true;
+    }
+
+
+    bool m_eol;
+};
+
+#define wxMARKUP_ENTITIES_NUM           5
+
+enum
+{
+    wxMARKUP_ENTITY = 0,
+    wxMARKUP_ENTITY_REF
+};
+
+// these are the only entities treated in a special way by wxStaticText::SetLabel()
+// when the wxST_MARKUP style is used; use as:
+//
+//    wxMarkupEntities[wxMARKUP_ENTITY][2]       to refer to e.g. &gt;
+//    wxMarkupEntities[wxMARKUP_ENTITY_REF][2]   to refer to e.g. >
+//
+extern const wxChar *wxMarkupEntities[2][wxMARKUP_ENTITIES_NUM];
+
+#endif // wxUSE_STATTEXT
+
+#endif // _WX_PRIVATE_STATTEXT_H_
Index: include/wx/univ/stattext.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/include/wx/univ/stattext.h,v
retrieving revision 1.16
diff -u2 -r1.16 include/wx/univ/stattext.h
--- include/wx/univ/stattext.h
+++ include/wx/univ/stattext.h
@@ -61,4 +61,9 @@
     virtual void DoDraw(wxControlRenderer *renderer);
 
+    // for wxST_ELLIPSIZE_* support:
+
+    virtual void SetRealLabel(const wxString &str);
+    virtual wxString GetRealLabel() const;
+
     DECLARE_ABSTRACT_CLASS(wxStaticText)
 };
Index: samples/widgets/static.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/samples/widgets/static.cpp,v
retrieving revision 1.23
diff -u2 -r1.23 samples/widgets/static.cpp
--- samples/widgets/static.cpp
+++ samples/widgets/static.cpp
@@ -54,5 +54,6 @@
     StaticPage_Reset = wxID_HIGHEST,
     StaticPage_BoxText,
-    StaticPage_LabelText
+    StaticPage_LabelText,
+    StaticPage_LabelTextWithMarkup
 };
 
@@ -74,4 +75,11 @@
 };
 
+enum
+{
+    StaticEllipsize_Start,
+    StaticEllipsize_Middle,
+    StaticEllipsize_End
+};
+
 // ----------------------------------------------------------------------------
 // MyStaticText and MyStaticBox
@@ -156,4 +164,5 @@
     void OnButtonBoxText(wxCommandEvent& event);
     void OnButtonLabelText(wxCommandEvent& event);
+    void OnButtonLabelWithMarkupText(wxCommandEvent& event);
 
     // reset all parameters
@@ -168,13 +177,17 @@
     // the check/radio boxes for styles
     wxCheckBox *m_chkVert,
-               *m_chkAutoResize;
+               *m_chkAutoResize,
+               *m_chkEllipsize,
+               *m_chkMarkup;
 
     wxRadioBox *m_radioHAlign,
-               *m_radioVAlign;
+               *m_radioVAlign,
+               *m_radioEllipsize;
 
     // the controls and the sizer containing them
     wxStaticBox *m_staticBox;
     wxStaticBoxSizer *m_sizerStatBox;
-    wxStaticText *m_statText;
+    wxStaticText *m_statText,
+                 *m_statTextWithMarkup;
 #if wxUSE_STATLINE
     wxStaticLine *m_statLine;
@@ -184,5 +197,6 @@
     // the text entries for command parameters
     wxTextCtrl *m_textBox,
-               *m_textLabel;
+               *m_textLabel,
+               *m_textLabelWithMarkup;
 
 private:
@@ -198,4 +212,5 @@
     EVT_BUTTON(StaticPage_Reset, StaticWidgetsPage::OnButtonReset)
     EVT_BUTTON(StaticPage_LabelText, StaticWidgetsPage::OnButtonLabelText)
+    EVT_BUTTON(StaticPage_LabelTextWithMarkup, StaticWidgetsPage::OnButtonLabelWithMarkupText)
     EVT_BUTTON(StaticPage_BoxText, StaticWidgetsPage::OnButtonBoxText)
 
@@ -226,9 +241,11 @@
     m_statLine = (wxStaticLine *)NULL;
 #endif // wxUSE_STATLINE
-    m_statText = (wxStaticText *)NULL;
+    m_statText = m_statTextWithMarkup = (wxStaticText *)NULL;
 
     m_staticBox = (wxStaticBox *)NULL;
     m_sizerStatBox = (wxStaticBoxSizer *)NULL;
     m_sizerStatic = (wxSizer *)NULL;
+
+    m_textBox = m_textLabel = m_textLabelWithMarkup = NULL;
 }
 
@@ -242,4 +259,5 @@
     wxSizer *sizerLeft = new wxStaticBoxSizer(box, wxVERTICAL);
 
+    m_chkMarkup = CreateCheckBoxAndAddToSizer(sizerLeft, _T("Support &markup"));
     m_chkVert = CreateCheckBoxAndAddToSizer(sizerLeft, _T("&Vertical line"));
     m_chkAutoResize = CreateCheckBoxAndAddToSizer(sizerLeft, _T("&Fit to text"));
@@ -270,4 +288,22 @@
     sizerLeft->Add(m_radioVAlign, 0, wxGROW | wxALL, 5);
 
+
+    sizerLeft->Add(5, 5, 0, wxGROW | wxALL, 5); // spacer
+
+    m_chkEllipsize = CreateCheckBoxAndAddToSizer(sizerLeft, _T("&Ellipsize"));
+
+    static const wxString ellipsizeMode[] =
+    {
+        _T("start"),
+        _T("middle"),
+        _T("end"),
+    };
+
+    m_radioEllipsize = new wxRadioBox(this, wxID_ANY, _T("&Ellipsize mode"),
+                                      wxDefaultPosition, wxDefaultSize,
+                                      WXSIZEOF(ellipsizeMode), ellipsizeMode);
+
+    sizerLeft->Add(m_radioEllipsize, 0, wxGROW | wxALL, 5);
+
     wxButton *btn = new wxButton(this, StaticPage_Reset, _T("&Reset"));
     sizerLeft->Add(btn, 0, wxALIGN_CENTRE_HORIZONTAL | wxALL, 15);
@@ -289,6 +325,21 @@
     sizerMiddle->Add(sizerRow, 0, wxGROW | wxALL, 5);
 
+    sizerRow = CreateSizerWithTextAndButton(StaticPage_LabelTextWithMarkup,
+                                            _T("Change decorated text label"),
+                                            wxID_ANY, &m_textLabelWithMarkup);
+    sizerMiddle->Add(sizerRow, 0, wxGROW | wxALL, 5);
+
+
+    // final initializations
+    // NB: must be done _before_ calling CreateStatic()
+    Reset();
+
     m_textBox->SetValue(_T("This is a box"));
-    m_textLabel->SetValue(_T("And this is a label\ninside the box"));
+    m_textLabel->SetValue(_T("And this is a\n\tlabel inside the box with a &mnemonic.\n")
+                          _T("Only this text is affected by the ellipsize settings."));
+    m_textLabelWithMarkup->SetValue(_T("Another label, this time <b>decorated</b> ")
+                                    _T("with <u>markup</u>; here you need entities ")
+                                    _T("for the symbols: &lt; &gt; &amp; &apos; &quot; ")
+                                    _T(" but you can still place &mnemonics..."));
 
     // right pane
@@ -304,7 +355,4 @@
     sizerTop->Add(sizerRight, 1, wxGROW | (wxALL & ~wxRIGHT), 10);
 
-    // final initializations
-    Reset();
-
     SetSizer(sizerTop);
 }
@@ -318,4 +366,6 @@
     m_chkVert->SetValue(false);
     m_chkAutoResize->SetValue(true);
+    m_chkEllipsize->SetValue(true);
+    m_chkMarkup->SetValue(true);
 
     m_radioHAlign->SetSelection(StaticHAlign_Left);
@@ -333,4 +383,5 @@
         m_sizerStatic->Remove(m_sizerStatBox);
         delete m_statText;
+        delete m_statTextWithMarkup;
 #if wxUSE_STATLINE
         delete m_statLine;
@@ -339,9 +390,17 @@
 
     int flagsBox = 0,
-        flagsText = ms_defaultFlags;
+        flagsText = ms_defaultFlags,
+        flagsDummyText = ms_defaultFlags;
 
     if ( !m_chkAutoResize->GetValue() )
     {
         flagsText |= wxST_NO_AUTORESIZE;
+        flagsDummyText |= wxST_NO_AUTORESIZE;
+    }
+
+    if ( m_chkMarkup->GetValue() )
+    {
+        flagsText |= wxST_MARKUP;
+        flagsDummyText |= wxST_MARKUP;
     }
 
@@ -385,4 +444,27 @@
     }
 
+    if (m_chkEllipsize->GetValue())
+    {
+        switch ( m_radioEllipsize->GetSelection() )
+        {
+            default:
+                wxFAIL_MSG(_T("unexpected radiobox selection"));
+                // fall through
+
+            case StaticEllipsize_Start:
+                flagsDummyText |= wxST_ELLIPSIZE_START;
+                break;
+
+            case StaticEllipsize_Middle:
+                flagsDummyText |= wxST_ELLIPSIZE_MIDDLE;
+                break;
+
+            case StaticEllipsize_End:
+                flagsDummyText |= wxST_ELLIPSIZE_END;
+                break;
+        }
+    }
+
+    flagsDummyText |= align;
     flagsText |= align;
     flagsBox |= align;
@@ -396,5 +478,9 @@
     m_statText = new MyStaticText(this, wxID_ANY, m_textLabel->GetValue(),
                                   wxDefaultPosition, wxDefaultSize,
-                                  flagsText);
+                                            flagsDummyText);
+    m_statTextWithMarkup = new wxStaticText(this, wxID_ANY, 
+                                            m_textLabelWithMarkup->GetValue(),
+                                            wxDefaultPosition, wxDefaultSize,
+                                            flagsText);
 
 #if wxUSE_STATLINE
@@ -408,5 +494,5 @@
     m_sizerStatBox->Add(m_statLine, 0, wxGROW | wxALL, 5);
 #endif // wxUSE_STATLINE
-    m_sizerStatBox->Add(0, 0, 1);
+    m_sizerStatBox->Add(m_statTextWithMarkup, 1, wxGROW | wxALL, 5);
 
     m_sizerStatic->Add(m_sizerStatBox, 1, wxGROW);
@@ -426,6 +512,11 @@
 }
 
-void StaticWidgetsPage::OnCheckOrRadioBox(wxCommandEvent& WXUNUSED(event))
+void StaticWidgetsPage::OnCheckOrRadioBox(wxCommandEvent& event)
 {
+    if (event.GetEventObject() == wx_static_cast(wxObject*, m_chkEllipsize))
+    {
+        m_radioEllipsize->Enable(event.IsChecked());
+    }
+
     CreateStatic();
 }
@@ -436,7 +527,28 @@
 }
 
+void StaticWidgetsPage::OnButtonLabelWithMarkupText(wxCommandEvent& WXUNUSED(event))
+{
+    m_statTextWithMarkup->SetLabel(m_textLabelWithMarkup->GetValue());
+
+    // test GetLabel() and GetLabelText(); the first should return the
+    // label as it is written in the relative text control; the second should
+    // return the label as it's shown in the wxStaticText
+    wxLogMessage(wxT("The original label should be '%s'"),
+                 m_statTextWithMarkup->GetLabel().c_str());
+    wxLogMessage(wxT("The label text is '%s'"),
+                 m_statTextWithMarkup->GetLabelText().c_str());
+}
+
 void StaticWidgetsPage::OnButtonLabelText(wxCommandEvent& WXUNUSED(event))
 {
     m_statText->SetLabel(m_textLabel->GetValue());
+
+    // test GetLabel() and GetLabelText(); the first should return the
+    // label as it is written in the relative text control; the second should
+    // return the label as it's shown in the wxStaticText
+    wxLogMessage(wxT("The original label should be '%s'"),
+                 m_statText->GetLabel().c_str());
+    wxLogMessage(wxT("The label text is '%s'"),
+                 m_statText->GetLabelText().c_str());
 }
 
Index: samples/widgets/toggle.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/samples/widgets/toggle.cpp,v
retrieving revision 1.4
diff -u2 -r1.4 samples/widgets/toggle.cpp
--- samples/widgets/toggle.cpp
+++ samples/widgets/toggle.cpp
@@ -27,4 +27,6 @@
 #if wxUSE_TOGGLEBTN
 
+#include "wx/log.h"
+
 #include "wx/tglbtn.h"
 
Index: samples/widgets/widgets.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/samples/widgets/widgets.cpp,v
retrieving revision 1.59
diff -u2 -r1.59 samples/widgets/widgets.cpp
--- samples/widgets/widgets.cpp
+++ samples/widgets/widgets.cpp
@@ -413,5 +413,5 @@
         wxVERTICAL);
 
-    m_lboxLog = new wxListBox(m_panel, wxID_ANY);
+    m_lboxLog = new wxListBox(m_panel, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0, NULL, wxLB_HSCROLL );
     sizerDown->Add(m_lboxLog, 1, wxGROW | wxALL, 5);
     sizerDown->SetMinSize(100, 150);
Index: src/common/ctrlcmn.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/common/ctrlcmn.cpp,v
retrieving revision 1.37
diff -u2 -r1.37 src/common/ctrlcmn.cpp
--- src/common/ctrlcmn.cpp
+++ src/common/ctrlcmn.cpp
@@ -121,11 +121,4 @@
 }
 
-
-void wxControlBase::SetLabel( const wxString &label )
-{
-    InvalidateBestSize();
-    wxWindow::SetLabel(label);
-}
-
 bool wxControlBase::SetFont(const wxFont& font)
 {
@@ -160,4 +153,10 @@
 }
 
+/* static */
+wxString wxControlBase::RemoveMnemonics(const wxString &str)
+{
+    return wxStripMenuCodes(str, wxStrip_Mnemonics);
+}
+
 // ----------------------------------------------------------------------------
 // wxStaticBitmap
Index: src/common/dlgcmn.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/common/dlgcmn.cpp,v
retrieving revision 1.64
diff -u2 -r1.64 src/common/dlgcmn.cpp
--- src/common/dlgcmn.cpp
+++ src/common/dlgcmn.cpp
@@ -39,59 +39,6 @@
 #include "wx/statline.h"
 #include "wx/sysopt.h"
+#include "wx/private/stattext.h"
 
-#if wxUSE_STATTEXT
-
-// ----------------------------------------------------------------------------
-// wxTextWrapper
-// ----------------------------------------------------------------------------
-
-// this class is used to wrap the text on word boundary: wrapping is done by
-// calling OnStartLine() and OnOutputLine() functions
-class wxTextWrapper
-{
-public:
-    wxTextWrapper() { m_eol = false; }
-
-    // win is used for getting the font, text is the text to wrap, width is the
-    // max line width or -1 to disable wrapping
-    void Wrap(wxWindow *win, const wxString& text, int widthMax);
-
-    // we don't need it, but just to avoid compiler warnings
-    virtual ~wxTextWrapper() { }
-
-protected:
-    // line may be empty
-    virtual void OnOutputLine(const wxString& line) = 0;
-
-    // called at the start of every new line (except the very first one)
-    virtual void OnNewLine() { }
-
-private:
-    // call OnOutputLine() and set m_eol to true
-    void DoOutputLine(const wxString& line)
-    {
-        OnOutputLine(line);
-
-        m_eol = true;
-    }
-
-    // this function is a destructive inspector: when it returns true it also
-    // resets the flag to false so calling it again woulnd't return true any
-    // more
-    bool IsStartOfNewLine()
-    {
-        if ( !m_eol )
-            return false;
-
-        m_eol = false;
-
-        return true;
-    }
-
-
-    bool m_eol;
-};
-
-#endif // wxUSE_STATTEXT
 
 // ----------------------------------------------------------------------------
@@ -127,56 +74,4 @@
 #if wxUSE_STATTEXT
 
-void wxTextWrapper::Wrap(wxWindow *win, const wxString& text, int widthMax)
-{
-    const wxChar *lastSpace = NULL;
-    wxString line;
-
-    const wxChar *lineStart = text.c_str();
-    for ( const wxChar *p = lineStart; ; p++ )
-    {
-        if ( IsStartOfNewLine() )
-        {
-            OnNewLine();
-
-            lastSpace = NULL;
-            line.clear();
-            lineStart = p;
-        }
-
-        if ( *p == _T('\n') || *p == _T('\0') )
-        {
-            DoOutputLine(line);
-
-            if ( *p == _T('\0') )
-                break;
-        }
-        else // not EOL
-        {
-            if ( *p == _T(' ') )
-                lastSpace = p;
-
-            line += *p;
-
-            if ( widthMax >= 0 && lastSpace )
-            {
-                int width;
-                win->GetTextExtent(line, &width, NULL);
-
-                if ( width > widthMax )
-                {
-                    // remove the last word from this line
-                    line.erase(lastSpace - lineStart, p + 1 - lineStart);
-                    DoOutputLine(line);
-
-                    // go back to the last word of this line which we didn't
-                    // output yet
-                    p = lastSpace;
-                }
-            }
-            //else: no wrapping at all or impossible to wrap
-        }
-    }
-}
-
 class wxTextSizerWrapper : public wxTextWrapper
 {
@@ -239,43 +134,4 @@
 }
 
-class wxLabelWrapper : public wxTextWrapper
-{
-public:
-    void WrapLabel(wxWindow *text, int widthMax)
-    {
-        m_text.clear();
-        Wrap(text, text->GetLabel(), widthMax);
-        text->SetLabel(m_text);
-    }
-
-protected:
-    virtual void OnOutputLine(const wxString& line)
-    {
-        m_text += line;
-    }
-
-    virtual void OnNewLine()
-    {
-        m_text += _T('\n');
-    }
-
-private:
-    wxString m_text;
-};
-
-// NB: don't "factor out" the scope operator, SGI MIPSpro 7.3 (but not 7.4)
-//     gets confused if it doesn't immediately follow the class name
-void
-#if defined(__WXGTK__) && !defined(__WXUNIVERSAL__)
-wxStaticText::
-#else
-wxStaticTextBase::
-#endif
-Wrap(int width)
-{
-    wxLabelWrapper wrapper;
-    wrapper.WrapLabel(this, width);
-}
-
 #endif // wxUSE_STATTEXT
 
Index: src/common/stattextcmn.cpp
--- /dev/null
+++ src/common/stattextcmn.cpp
@@ -0,0 +1,483 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        src/common/stattextcmn.cpp
+// Purpose:     common (to all ports) wxStaticText functions
+// Author:      Vadim Zeitlin
+// Modified by:
+// Created:     7/1/2006 (extracted from dlgcmn.cpp)
+// RCS-ID:      $Id$
+// Copyright:   (c) Vadim Zeitlin
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+// ============================================================================
+// declarations
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// headers
+// ----------------------------------------------------------------------------
+
+// For compilers that support precompilation, includes "wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#include "wx/private/stattext.h"
+
+#ifndef WX_PRECOMP
+    #include "wx/button.h"
+    #include "wx/dcclient.h"
+    #include "wx/intl.h"
+    #include "wx/settings.h"
+    #include "wx/stattext.h"
+    #include "wx/sizer.h"
+    #include "wx/containr.h"
+#endif
+
+#if wxUSE_STATTEXT
+
+const wxChar *wxMarkupEntities[][wxMARKUP_ENTITIES_NUM] =
+{
+    // the entities handled by SetLabel() when wxST_MARKUP is used and their referenced string
+
+    { wxT("&amp;"), wxT("&lt;"), wxT("&gt;"), wxT("&apos;"), wxT("&quot;") },
+    { wxT("&"),     wxT("<"),    wxT(">"),    wxT("'"),      wxT("\"")     }
+};
+
+
+// ----------------------------------------------------------------------------
+// wxTextWrapper
+// ----------------------------------------------------------------------------
+
+void wxTextWrapper::Wrap(wxWindow *win, const wxString& text, int widthMax)
+{
+    const wxChar *lastSpace = NULL;
+    wxString line;
+
+    const wxChar *lineStart = text.c_str();
+    for ( const wxChar *p = lineStart; ; p++ )
+    {
+        if ( IsStartOfNewLine() )
+        {
+            OnNewLine();
+
+            lastSpace = NULL;
+            line.clear();
+            lineStart = p;
+        }
+
+        if ( *p == _T('\n') || *p == _T('\0') )
+        {
+            DoOutputLine(line);
+
+            if ( *p == _T('\0') )
+                break;
+        }
+        else // not EOL
+        {
+            if ( *p == _T(' ') )
+                lastSpace = p;
+
+            line += *p;
+
+            if ( widthMax >= 0 && lastSpace )
+            {
+                int width;
+                win->GetTextExtent(line, &width, NULL);
+
+                if ( width > widthMax )
+                {
+                    // remove the last word from this line
+                    line.erase(lastSpace - lineStart, p + 1 - lineStart);
+                    DoOutputLine(line);
+
+                    // go back to the last word of this line which we didn't
+                    // output yet
+                    p = lastSpace;
+                }
+            }
+            //else: no wrapping at all or impossible to wrap
+        }
+    }
+}
+
+
+// ----------------------------------------------------------------------------
+// wxLabelWrapper: helper class for wxStaticTextBase::Wrap()
+// ----------------------------------------------------------------------------
+
+class wxLabelWrapper : public wxTextWrapper
+{
+public:
+    void WrapLabel(wxWindow *text, int widthMax)
+    {
+        m_text.clear();
+        Wrap(text, text->GetLabel(), widthMax);
+        text->SetLabel(m_text);
+    }
+
+protected:
+    virtual void OnOutputLine(const wxString& line)
+    {
+        m_text += line;
+    }
+
+    virtual void OnNewLine()
+    {
+        m_text += _T('\n');
+    }
+
+private:
+    wxString m_text;
+};
+
+
+// ----------------------------------------------------------------------------
+// wxStaticTextBase
+// ----------------------------------------------------------------------------
+
+void wxStaticTextBase::Wrap(int width)
+{
+    wxLabelWrapper wrapper;
+    wrapper.WrapLabel(this, width);
+}
+
+wxString wxStaticTextBase::GetLabelText() const
+{
+    wxString ret(GetLabel());
+
+    if (HasFlag(wxST_MARKUP))
+        ret = RemoveMarkup(ret);
+    return RemoveMnemonics(ret);
+}
+
+/*static*/
+wxString wxStaticTextBase::RemoveMarkup(const wxString &text)
+{
+    // strip out of "text" the markup for platforms which don't support it natively
+    bool inside_tag = false;
+
+    wxString label;
+    const wxChar *source = text;
+    for (size_t i=0, max=text.length(); i<max; i++)
+    {
+        switch (source[i])
+        {
+            case wxT('<'):
+                if (inside_tag)
+                {
+                    wxLogDebug(wxT("Invalid markup !"));
+                    return wxEmptyString;
+                }
+                inside_tag = true;
+                break;
+
+            case wxT('>'):
+                if (!inside_tag)
+                {
+                    wxLogDebug(wxT("Invalid markup !"));
+                    return wxEmptyString;
+                }
+                inside_tag = false;
+                break;
+
+            case wxT('&'):
+                {
+                    if (i == max-1)
+                    {
+                        wxLogDebug(wxT("Cannot use & as last character of the string '%s'"),
+                                   text.c_str());
+                        return wxEmptyString;
+                    }
+
+                    // is this ampersand introducing a mnemonic or rather an entity?
+                    bool isMnemonic = true;
+                    for (size_t j=0; j < wxMARKUP_ENTITIES_NUM; j++)
+                    {
+                        const wxChar *entity = wxMarkupEntities[wxMARKUP_ENTITY][j];
+                        size_t entityLen = wxStrlen(entity);
+
+                        if (max - i >= entityLen &&
+                            wxStrncmp(entity, &source[i], entityLen) == 0)
+                        {
+                            // replace the &entity; string with the entity reference
+                            label << wxMarkupEntities[wxMARKUP_ENTITY_REF][j];
+                            
+                            // little exception: when the entity reference is "&"
+                            // (i.e. when entity is "&amp;"), substitute it with &&
+                            // instead of a single ampersand:
+                            if (*wxMarkupEntities[wxMARKUP_ENTITY_REF][j] == wxT('&'))
+                                label << wxT('&');
+                            i += entityLen - 1;     // the -1 is because main for()
+                                                    // loop already increments i
+                            isMnemonic = false;
+                            break;
+                        }
+                    }
+
+                    if (isMnemonic)
+                        label << text[i];
+                }
+                break;
+
+
+            default:
+                if (!inside_tag)
+                    label << text[i];
+        }
+    }
+
+    return label;
+}
+
+/* static */
+wxString wxStaticTextBase::EscapeMarkup(const wxString &text)
+{
+    wxString ret;
+
+    for (const wxChar *source = text; *source != wxT('\0'); source++)
+    {
+        bool isEntity = false;
+
+        // search in the list of the entities and eventually escape this character
+        for (size_t j=0; j < wxMARKUP_ENTITIES_NUM; j++)
+        {
+            if (*source == *wxMarkupEntities[wxMARKUP_ENTITY_REF][j])
+            {
+                ret << wxMarkupEntities[wxMARKUP_ENTITY][j];
+                isEntity = true;
+                break;
+            }
+        }
+
+        if (!isEntity)
+            ret << *source;     // this character does not need to be escaped
+    }
+
+    return ret;
+}
+
+
+
+// ----------------------------------------------------------------------------
+// wxStaticTextBase - generic implementation for wxST_ELLIPSIZE_* support
+// ----------------------------------------------------------------------------
+
+void wxStaticTextBase::UpdateLabel()
+{
+    if (!IsEllipsized())
+        return;
+
+    wxString newlabel = GetEllipsizedLabelWithoutMarkup();
+
+    // we need to touch the "real" label (i.e. the text set inside the control,
+    // using port-specific functions) instead of the string returned by GetLabel().
+    //
+    // Infact, we must be careful not to touch the the original label passed to 
+    // SetLabel() otherwise GetLabel() will behave in a strange way to the user's eyes
+    // (e.g. returning a "Ver...ing" instead of "Very long string") !
+    if (newlabel == GetRealLabel())
+        return;
+    SetRealLabel(newlabel);
+}
+
+wxString wxStaticTextBase::GetEllipsizedLabelWithoutMarkup() const
+{
+    // this function should be used only by ports which do not support
+    // ellipsing in static texts: we first remove markup (which cannot
+    // be handled safely by Ellipsize()) and then ellipsize the result.
+
+    wxString ret(m_strOriginalLabel);
+
+    // the order of the following two blocks is important!
+
+    if (HasFlag(wxST_MARKUP))
+        ret = RemoveMarkup(ret);
+
+    if (IsEllipsized())
+        ret = Ellipsize(ret);
+
+    return ret;
+}
+
+#define wxELLIPSE_REPLACEMENT       wxT("...")
+
+wxString wxStaticTextBase::Ellipsize(const wxString &label) const
+{
+    wxSize sz(this->GetSize());
+    if (sz.GetWidth() < 2 || sz.GetHeight() < 2)
+    {
+        // the size of this window is not valid (yet)
+        return label;
+    }
+
+    wxClientDC dc(wx_const_cast(wxStaticTextBase*, this));
+    dc.SetFont(this->GetFont());
+
+    wxArrayInt charOffsets;
+    wxString ret;
+
+    // these cannot be cached as they can change because of e.g. a font change
+    int replacementWidth = dc.GetTextExtent(wxELLIPSE_REPLACEMENT).GetWidth();
+    int marginWidth = dc.GetCharWidth()*2;
+
+    // handle correctly labels with newlines
+    wxString curLine;
+    wxSize reqsize;
+    size_t len;
+    for ( const wxChar *pc = label; ; pc++ )
+    {
+        switch ( *pc )
+        {
+        case _T('\n'):
+        case _T('\0'):
+            len = curLine.length();
+            if (len > 0 &&
+                dc.GetPartialTextExtents(curLine, charOffsets))
+            {
+                wxASSERT(charOffsets.GetCount() == len);
+
+                size_t totalWidth = charOffsets.Last();
+                if ( totalWidth > (size_t)sz.GetWidth() )
+                {
+                    // we need to ellipsize this row
+                    int excessPixels = totalWidth - sz.GetWidth() + 
+                                       replacementWidth +
+                                       marginWidth;     // security margin (NEEDED!)
+
+                    // remove characters in excess
+                    size_t initialChar,     // index of first char to erase
+                           nChars;          // how many chars do we need to erase?
+                    if (HasFlag(wxST_ELLIPSIZE_START))
+                    {
+                        initialChar = 0;
+                        for (nChars=0;
+                             nChars < len && charOffsets[nChars] < excessPixels;
+                             nChars++)
+                            ;
+                    }
+                    else if (HasFlag(wxST_ELLIPSIZE_MIDDLE))
+                    {
+                        // the start & end of the removed span of chars
+                        initialChar = len/2;
+                        size_t endChar = len/2;
+
+                        int removed = 0;
+                        for ( ; removed < excessPixels; )
+                        {
+                            if (initialChar > 0)
+                            {
+                                // width of the initialChar-th character
+                                int width = charOffsets[initialChar] -
+                                            charOffsets[initialChar-1];
+
+                                // remove the initialChar-th character
+                                removed += width;
+                                initialChar--;
+                            }
+
+                            if (endChar < len - 1 &&
+                                removed < excessPixels)
+                            {
+                                // width of the (endChar+1)-th character
+                                int width = charOffsets[endChar+1] -
+                                            charOffsets[endChar];
+
+                                // remove the endChar-th character
+                                removed += width;
+                                endChar++;
+                            }
+
+                            if (initialChar == 0 && endChar == len-1)
+                            {
+                                nChars = len+1;
+                                break;
+                            }
+                        }
+
+                        initialChar++;
+                        nChars = endChar - initialChar + 1;
+                    }
+                    else
+                    {
+                        wxASSERT(HasFlag(wxST_ELLIPSIZE_END));
+                        wxASSERT(len > 0);
+
+                        int maxWidth = totalWidth - excessPixels;
+                        for (initialChar=0; 
+                             initialChar < len && 
+                             charOffsets[initialChar] < maxWidth; 
+                             initialChar++)
+                            ;
+
+                        if (initialChar == 0)
+                        {
+                            nChars = len;
+                        }
+                        else
+                        {
+                            initialChar--;      // go back one character 
+                            nChars = len - initialChar;
+                        }
+                    }
+
+                    if (nChars > len)
+                    {
+                        // need to remove the entire row!
+                        curLine.clear();
+                    }
+                    else
+                    {
+                        // erase nChars characters after initialChar (included):
+                        curLine.erase(initialChar, nChars+1);
+
+                        // if there is space for the replacement dots, add them
+                        if (sz.GetWidth() > replacementWidth)
+                            curLine.insert(initialChar, wxELLIPSE_REPLACEMENT);
+                    }
+
+                    // if everything was ok, we should have shortened this line
+                    // enough to make it fit in sz.GetWidth():
+#ifdef __WXDEBUG__
+                    wxSize used = dc.GetTextExtent(curLine);
+                    wxASSERT(used.GetWidth() < sz.GetWidth());
+#endif
+                }
+            }
+
+            // add this (ellipsized) row to the rest of the label
+            ret << curLine << *pc;
+            curLine.clear();
+
+            if ( *pc == _T('\0') )
+                return ret;
+
+            break;
+
+            // we need to remove mnemonics from the label for
+            // correct calculations
+        case _T('&'):
+            // pc+1 is safe: at worst we'll hit the \0
+            if (*(pc+1) == _T('&'))
+                curLine += _T('&');          // && becomes &
+            //else: remove this ampersand
+
+            break;
+
+            // we need also to expand tabs to properly calc their size
+        case _T('\t'):
+            // Win natively expands the TABs to 6 spaces. Do the same:
+            curLine += wxT("      ");
+            break;
+
+        default:
+            curLine += *pc;
+        }
+    }
+
+    //return ret;
+}
+
+#endif // wxUSE_STATTEXT
Index: src/gtk/checkbox.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/gtk/checkbox.cpp,v
retrieving revision 1.79
diff -u2 -r1.79 src/gtk/checkbox.cpp
--- src/gtk/checkbox.cpp
+++ src/gtk/checkbox.cpp
@@ -205,4 +205,7 @@
     wxCHECK_RET( m_widgetLabel != NULL, wxT("invalid checkbox") );
 
+    // save the label inside m_label in case user calls GetLabel() later
+    wxControl::SetLabel(label);
+
     GTKSetLabelForLabel(GTK_LABEL(m_widgetLabel), label);
 }
Index: src/gtk/control.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/gtk/control.cpp,v
retrieving revision 1.56
diff -u2 -r1.56 src/gtk/control.cpp
--- src/gtk/control.cpp
+++ src/gtk/control.cpp
@@ -23,4 +23,7 @@
 #include "wx/gtk/private.h"
 
+#include "wx/private/stattext.h"
+
+
 // ============================================================================
 // wxControl implementation
@@ -90,27 +93,16 @@
 // ----------------------------------------------------------------------------
 
-void wxControl::SetLabel( const wxString &label )
+void wxControl::GTKSetLabelForLabel(GtkLabel *w, const wxString& label)
 {
-    // keep the original string internally to be able to return it later (for
-    // consistency with the other ports)
-    m_label = label;
-
-    InvalidateBestSize();
+    const wxString labelGTK = GTKConvertMnemonics(label);
+    gtk_label_set_text_with_mnemonic(w, wxGTK_CONV(labelGTK));
 }
 
-wxString wxControl::GetLabel() const
+void wxControl::GTKSetLabelWithMarkupForLabel(GtkLabel *w, const wxString& label)
 {
-    return m_label;
+    const wxString labelGTK = GTKConvertMnemonicsWithMarkup(label);
+    gtk_label_set_markup_with_mnemonic(w, wxGTK_CONV(labelGTK));
 }
 
-void wxControl::GTKSetLabelForLabel(GtkLabel *w, const wxString& label)
-{
-    // don't call the virtual function which might call this one back again
-    wxControl::SetLabel(label);
-
-    const wxString labelGTK = GTKConvertMnemonics(label);
-
-    gtk_label_set_text_with_mnemonic(w, wxGTK_CONV(labelGTK));
-}
 
 // ----------------------------------------------------------------------------
@@ -155,9 +147,5 @@
 
 // ----------------------------------------------------------------------------
-// worker function implementing both GTKConvert/RemoveMnemonics()
-//
-// notice that under GTK+ 1 we only really need to support MNEMONICS_REMOVE as
-// it doesn't support mnemonics anyhow but this would make the code so ugly
-// that we do the same thing for GKT+ 1 and 2
+// worker function implementing GTK*Mnemonics() functions
 // ----------------------------------------------------------------------------
 
@@ -165,10 +153,11 @@
 {
     MNEMONICS_REMOVE,
-    MNEMONICS_CONVERT
+    MNEMONICS_CONVERT,
+    MNEMONICS_CONVERT_MARKUP
 };
 
-static wxString GTKProcessMnemonics(const wxString& label, MnemonicsFlag flag)
+static wxString GTKProcessMnemonics(const wxChar* label, MnemonicsFlag flag)
 {
-    const size_t len = label.length();
+    const size_t len = wxStrlen(label);
     wxString labelGTK;
     labelGTK.reserve(len);
@@ -183,8 +172,34 @@
                 {
                     // "&" at the end of string is an error
-                    wxLogDebug(wxT("Invalid label \"%s\"."), label.c_str());
+                    wxLogDebug(wxT("Invalid label \"%s\"."), label);
                     break;
                 }
 
+                if ( flag == MNEMONICS_CONVERT_MARKUP )
+                {
+                    bool isMnemonic = true;
+
+                    // is this ampersand introducing a mnemonic or rather an entity?
+                    for (size_t j=0; j < wxMARKUP_ENTITIES_NUM; j++)
+                    {
+                        const wxChar *entity = wxMarkupEntities[wxMARKUP_ENTITY][j];
+                        size_t entityLen = wxStrlen(entity);
+
+                        if (len - i >= entityLen &&
+                            wxStrncmp(entity, &label[i], entityLen) == 0)
+                        {
+                            labelGTK << entity;
+                            i += entityLen - 1;     // the -1 is because main for()
+                                                    // loop already increments i
+                            isMnemonic = false;
+
+                            break;
+                        }
+                    }
+
+                    if (!isMnemonic)
+                        continue;
+                }
+
                 ch = label[++i]; // skip '&' itself
                 switch ( ch )
@@ -193,9 +208,12 @@
                         // special case: "&&" is not a mnemonic at all but just
                         // an escaped "&"
-                        labelGTK += wxT('&');
+                        if ( flag == MNEMONICS_CONVERT_MARKUP )
+                            labelGTK += wxT("&amp;");
+                        else
+                            labelGTK += wxT('&');
                         break;
 
                     case wxT('_'):
-                        if ( flag == MNEMONICS_CONVERT )
+                        if ( flag != MNEMONICS_REMOVE )
                         {
                             // '_' can't be a GTK mnemonic apparently so
@@ -207,5 +225,5 @@
 
                     default:
-                        if ( flag == MNEMONICS_CONVERT )
+                        if ( flag != MNEMONICS_REMOVE )
                             labelGTK += wxT('_');
                         labelGTK += ch;
@@ -214,5 +232,5 @@
 
             case wxT('_'):
-                if ( flag == MNEMONICS_CONVERT )
+                if ( flag != MNEMONICS_REMOVE )
                 {
                     // escape any existing underlines in the string so that
@@ -243,4 +261,10 @@
 }
 
+/* static */
+wxString wxControl::GTKConvertMnemonicsWithMarkup(const wxString& label)
+{
+    return GTKProcessMnemonics(label, MNEMONICS_CONVERT_MARKUP);
+}
+
 // ----------------------------------------------------------------------------
 // wxControl styles (a.k.a. attributes)
Index: src/gtk/radiobox.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/gtk/radiobox.cpp,v
retrieving revision 1.130
diff -u2 -r1.130 src/gtk/radiobox.cpp
--- src/gtk/radiobox.cpp
+++ src/gtk/radiobox.cpp
@@ -450,4 +450,7 @@
     wxCHECK_RET( m_widget != NULL, wxT("invalid radiobox") );
 
+    // save the label inside m_label in case user calls GetLabel() later
+    wxControl::SetLabel(label);
+
     GTKSetLabelForFrame(GTK_FRAME(m_widget), label);
 }
Index: src/gtk/radiobut.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/gtk/radiobut.cpp,v
retrieving revision 1.65
diff -u2 -r1.65 src/gtk/radiobut.cpp
--- src/gtk/radiobut.cpp
+++ src/gtk/radiobut.cpp
@@ -117,4 +117,7 @@
     wxCHECK_RET( m_widget != NULL, wxT("invalid radiobutton") );
 
+    // save the label inside m_label in case user calls GetLabel() later
+    wxControl::SetLabel(label);
+
     GTKSetLabelForLabel(GTK_LABEL(GTK_BIN(m_widget)->child), label);
 }
Index: src/gtk/statbox.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/gtk/statbox.cpp,v
retrieving revision 1.46
diff -u2 -r1.46 src/gtk/statbox.cpp
--- src/gtk/statbox.cpp
+++ src/gtk/statbox.cpp
@@ -83,4 +83,7 @@
     wxCHECK_RET( m_widget != NULL, wxT("invalid staticbox") );
 
+    // save the label inside m_label in case user calls GetLabel() later
+    wxControl::SetLabel(label);
+
     GTKSetLabelForFrame(GTK_FRAME(m_widget), label);
 }
Index: src/gtk/stattext.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/gtk/stattext.cpp,v
retrieving revision 1.67
diff -u2 -r1.67 src/gtk/stattext.cpp
--- src/gtk/stattext.cpp
+++ src/gtk/stattext.cpp
@@ -42,5 +42,5 @@
                            const wxString &name)
 {
-  Create( parent, id, label, pos, size, style, name );
+    Create( parent, id, label, pos, size, style, name );
 }
 
@@ -62,7 +62,5 @@
     }
 
-    const wxString labelGTK = GTKConvertMnemonics(label);
-    m_label = label;
-    m_widget = gtk_label_new_with_mnemonic(wxGTK_CONV(labelGTK));
+    m_widget = gtk_label_new(NULL);
 
     GtkJustification justify;
@@ -73,7 +71,7 @@
     else // wxALIGN_LEFT is 0
       justify = GTK_JUSTIFY_LEFT;
-      
+
     if (GetLayoutDirection() == wxLayout_RightToLeft)
-    {  
+    {
          if (justify == GTK_JUSTIFY_RIGHT)
             justify = GTK_JUSTIFY_LEFT;
@@ -81,5 +79,5 @@
             justify = GTK_JUSTIFY_RIGHT;
     }
-    
+
     gtk_label_set_justify(GTK_LABEL(m_widget), justify);
 
@@ -90,4 +88,22 @@
     gtk_label_set_line_wrap( GTK_LABEL(m_widget), TRUE );
 
+#ifdef __WXGTK26__
+    if (!gtk_check_version(2,6,0))
+    {
+        // set ellipsize mode
+        PangoEllipsizeMode ellipsizeMode = PANGO_ELLIPSIZE_NONE;
+        if ( style & wxST_ELLIPSIZE_START )
+            ellipsizeMode = PANGO_ELLIPSIZE_START;
+        else if ( style & wxST_ELLIPSIZE_MIDDLE )
+            ellipsizeMode = PANGO_ELLIPSIZE_MIDDLE;
+        else if ( style & wxST_ELLIPSIZE_END )
+            ellipsizeMode = PANGO_ELLIPSIZE_END;
+
+        gtk_label_set_ellipsize( GTK_LABEL(m_widget), ellipsizeMode );
+    }
+#endif
+
+    SetLabel(label);
+
     m_parent->DoAddChild( this );
 
@@ -111,18 +127,37 @@
 wxString wxStaticText::GetLabel() const
 {
-    GtkLabel *label = GTK_LABEL(m_widget);
-    wxString str = wxGTK_CONV_BACK( gtk_label_get_text( label ) );
-
-    return wxString(str);
+    // we need to return the label just like it was passed to the last call
+    // to SetLabel(): i.e. with wx-style mnemonics and with markup
+    return wxControl::GetLabel();
 }
 
-void wxStaticText::SetLabel( const wxString &label )
+void wxStaticText::SetLabel( const wxString &str )
 {
     wxCHECK_RET( m_widget != NULL, wxT("invalid static text") );
 
-    GTKSetLabelForLabel(GTK_LABEL(m_widget), label);
+    // save the label inside m_strOriginalLabel in case user calls GetLabel() later
+    m_strOriginalLabel = str;
+
+    wxString label(str);
+    if (gtk_check_version(2,6,0) &&
+        IsEllipsized())
+    {
+        // GTK+ < 2.6 does not support ellipsization:
+        // since we need to use our generic code for ellipsization (which does not
+        // behaves well in conjunction with markup; i.e. it may break the markup
+        // validity erasing portions of the string), we also need to strip out
+        // the markup (if present) from the label.
+
+        label = GetEllipsizedLabelWithoutMarkup();
+    }
+
+    if ( HasFlag(wxST_MARKUP) )
+        GTKSetLabelWithMarkupForLabel(GTK_LABEL(m_widget), label);
+    else
+        GTKSetLabelForLabel(GTK_LABEL(m_widget), label);
 
     // adjust the label size to the new label unless disabled
-    if ( !HasFlag(wxST_NO_AUTORESIZE) )
+    if ( !HasFlag(wxST_NO_AUTORESIZE) && 
+         !IsEllipsized() )  // if ellipsize is ON, then we don't want to get resized!
         SetSize( GetBestSize() );
 }
@@ -146,4 +181,11 @@
 {
     wxControl::DoSetSize( x, y, width, height, sizeFlags );
+
+    if (gtk_check_version(2,6,0))
+    {
+        // GTK+ < 2.6 does not support ellipsization - we need to run our
+        // generic code (actually it will be run only if IsEllipsized() == true)
+        UpdateLabel();
+    }
 }
 
@@ -187,4 +229,18 @@
 }
 
+
+// These function should be used only when GTK+ < 2.6 by wxStaticTextBase::UpdateLabel()
+
+wxString wxStaticText::GetRealLabel() const
+{
+    GtkLabel *label = GTK_LABEL(m_widget);
+    return wxGTK_CONV_BACK( gtk_label_get_text( label ) );
+}
+
+void wxStaticText::SetRealLabel(const wxString &str)
+{
+    GTKSetLabelForLabel(GTK_LABEL(m_widget), str);
+}
+
 // static
 wxVisualAttributes
Index: src/mac/carbon/stattext.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/mac/carbon/stattext.cpp,v
retrieving revision 1.69
diff -u2 -r1.69 src/mac/carbon/stattext.cpp
--- src/mac/carbon/stattext.cpp
+++ src/mac/carbon/stattext.cpp
@@ -44,11 +44,9 @@
     m_macIsUserPane = false;
 
-    m_label = GetLabelText( label );
-
     if ( !wxControl::Create( parent, id, pos, size, style, wxDefaultValidator, name ) )
         return false;
 
     Rect bounds = wxMacGetBoundsForControl( this, pos, size );
-    wxMacCFStringHolder str( m_label, m_font.GetEncoding() );
+    wxMacCFStringHolder str( wxEmptyString, m_font.GetEncoding() );
 
     m_peer = new wxMacControl( this );
@@ -58,8 +56,8 @@
     verify_noerr( err );
 
-    if ( ( style & wxST_DOTS_END ) || ( style & wxST_DOTS_MIDDLE ) )
+    if ( ( style & wxST_ELLIPSIZE_END ) || ( style & wxST_ELLIPSIZE_MIDDLE ) )
     {
         TruncCode tCode = truncEnd;
-        if ( style & wxST_DOTS_MIDDLE )
+        if ( style & wxST_ELLIPSIZE_MIDDLE )
             tCode = truncMiddle;
 
@@ -70,4 +68,6 @@
     MacPostControlCreate( pos, size );
 
+    SetLabel(label);
+
     return true;
 }
@@ -133,12 +133,22 @@
 void wxStaticText::SetLabel( const wxString& st )
 {
-    m_label = GetLabelText( st );
+    wxControl::SetLabel(st);        // save original label
 
-    wxMacCFStringHolder str( m_label, m_font.GetEncoding() );
-    CFStringRef ref = str;
-    OSStatus err = m_peer->SetData<CFStringRef>(kControlEntireControl, kControlStaticTextCFStringTag, ref );
-    verify_noerr( err );
+    // middle/end ellipsization is handled by the OS:
+    if (HasFlag(wxST_ELLIPSIZE_END) || HasFlag(wxST_ELLIPSIZE_MIDDLE)
+    {
+        // remove markup
+        wxString str(st);
+        if (HasFlag(wxST_MARKUP))
+            str = RemoveMarkup(st);
+
+        // and leave ellipsization to the OS
+        SetRealLabel(str);
+    }
+    else
+        SetRealLabel(GetEllipsizedLabelWithoutMarkup(st));
 
-    if ( !(GetWindowStyle() & wxST_NO_AUTORESIZE) )
+    if ( !(GetWindowStyle() & wxST_NO_AUTORESIZE) &&
+         !IsEllipsized() )  // if ellipsize is ON, then we don't want to get resized!
     {
         InvalidateBestSize();
@@ -168,3 +178,26 @@
 }
 
+
+// for wxST_ELLIPSIZE_* support:
+
+void wxStaticText::SetRealLabel(const wxString &str)
+{
+    m_label = RemoveMnemonics(str);
+
+    wxMacCFStringHolder str( m_label, m_font.GetEncoding() );
+    CFStringRef ref = str;
+    OSStatus err = m_peer->SetData<CFStringRef>(kControlEntireControl, kControlStaticTextCFStringTag, ref );
+    verify_noerr( err );
+}
+
+wxString wxStaticText::GetRealLabel() const
+{
+    return m_label;
+}
+
+/*
+   FIXME: UpdateLabel() should be called on size events when wxST_ELLIPSIZE_START is set
+          to allow correct dynamic ellipsizing of the label
+*/
+
 #endif //if wxUSE_STATTEXT
Index: src/motif/stattext.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/motif/stattext.cpp,v
retrieving revision 1.35
diff -u2 -r1.35 src/motif/stattext.cpp
--- src/motif/stattext.cpp
+++ src/motif/stattext.cpp
@@ -48,5 +48,4 @@
     Widget borderWidget =
         (Widget) wxCreateBorderWidget( (WXWidget)parentWidget, style );
-    wxXmString text( GetLabelText( label ) );
 
     m_labelWidget =
@@ -55,5 +54,5 @@
             borderWidget ? borderWidget : parentWidget,
             wxFont::GetFontTag(), m_font.GetFontTypeC(XtDisplay(parentWidget)),
-            XmNlabelString, text(),
+            XmNlabelString, wxEmptyString,
             XmNalignment, ((style & wxALIGN_RIGHT)  ? XmALIGNMENT_END :
                           ((style & wxALIGN_CENTRE) ? XmALIGNMENT_CENTER :
@@ -69,4 +68,6 @@
     ChangeBackgroundColour ();
 
+    SetLabel(label);
+
     return true;
 }
@@ -74,5 +75,21 @@
 void wxStaticText::SetLabel(const wxString& label)
 {
-    wxXmString label_str(GetLabelText(label));
+    m_strOriginalLabel = label;       // save original label
+
+    // Motif does not support nor ellipsize nor markup in static text:
+    SetRealLabel(GetEllipsizedLabelWithoutMarkup(label));
+}
+
+// for wxST_ELLIPSIZE_* support:
+
+wxString wxStaticText::GetRealLabel() const
+{
+    return XmTextGetString((Widget) m_labelWidget);
+}
+
+void wxStaticText::SetRealLabel(const wxString &str)
+{
+    // build our own cleaned label
+    wxXmString label_str(RemoveMnemonics(str));
 
     // This variable means we don't need so many casts later.
@@ -85,3 +102,8 @@
 }
 
+/*
+   FIXME: UpdateLabel() should be called on size events to allow correct
+          dynamic ellipsizing of the label
+*/
+
 #endif // wxUSE_STATTEXT
Index: src/msw/control.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/msw/control.cpp,v
retrieving revision 1.112
diff -u2 -r1.112 src/msw/control.cpp
--- src/msw/control.cpp
+++ src/msw/control.cpp
@@ -163,4 +163,8 @@
     }
 
+    // saving the label in m_strOriginalLabel to return it verbatim
+    // later in GetLabel()
+    m_strOriginalLabel = label;
+
     // install wxWidgets window proc for this window
     SubclassWin(m_hWnd);
Index: src/msw/stattext.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/msw/stattext.cpp,v
retrieving revision 1.70
diff -u2 -r1.70 src/msw/stattext.cpp
--- src/msw/stattext.cpp
+++ src/msw/stattext.cpp
@@ -122,4 +122,14 @@
 
     // this style is necessary to receive mouse events
+    // Win NT and later have the SS_ENDELLIPSIS style which is useful to us:
+    if (wxGetOsVersion() == wxOS_WINDOWS_NT)
+    {
+        // for now, add the SS_ENDELLIPSIS style if wxST_ELLIPSIZE_END is given;
+        // we may need to remove it later in ::SetLabel() if the given label
+        // has newlines...
+        if ( style & wxST_ELLIPSIZE_END )
+            msStyle |= SS_ENDELLIPSIS;
+    }
+
     msStyle |= SS_NOTIFY;
 
@@ -182,8 +192,19 @@
 void wxStaticText::DoSetSize(int x, int y, int w, int h, int sizeFlags)
 {
-    // we need to refresh the window after changing its size as the standard
-    // control doesn't always update itself properly
+    // note: we first need to set the size and _then_ call UpdateLabel
     wxStaticTextBase::DoSetSize(x, y, w, h, sizeFlags);
 
+    // do we need to ellipsize the contents?
+    long styleReal = ::GetWindowLong(GetHwnd(), GWL_STYLE);
+    if ( (styleReal & SS_ENDELLIPSIS) == 0 )
+    {
+        // we don't have SS_ENDELLIPSIS style:
+        // we need to (eventually) do ellipsization ourselves
+        UpdateLabel();
+    }
+    //else: we don't have ellipsization turned on or the OS will do it for us
+
+    // we need to refresh the window after changing its size as the standard
+    // control doesn't always update itself properly
     Refresh();
 }
@@ -191,9 +212,39 @@
 void wxStaticText::SetLabel(const wxString& label)
 {
-    wxStaticTextBase::SetLabel(label);
+    long styleReal = ::GetWindowLong(GetHwnd(), GWL_STYLE);
+    if (HasFlag(wxST_ELLIPSIZE_END) &&
+        wxGetOsVersion() == wxOS_WINDOWS_NT)
+    {
+        // adding SS_ENDELLIPSIS or SS_ENDELLIPSIS "disables" the correct 
+        // newline handling in static texts: the newlines in the labels are 
+        // shown as square. Thus we don't use it even on newer OS when 
+        // the static label contains a newline.
+        if (label.Contains(wxT('\n')))
+            styleReal &= ~SS_ENDELLIPSIS;
+        else
+            styleReal |= SS_ENDELLIPSIS;
+
+        ::SetWindowLong(GetHwnd(), GWL_STYLE, styleReal);
+    }
+    else
+    {
+        // start or middle ellipsize has been chosen - remove SS_ENDELLIPSIS
+        styleReal &= ~SS_ENDELLIPSIS;
+        ::SetWindowLong(GetHwnd(), GWL_STYLE, styleReal);
+    }
+
+    // this call will save the label in m_strOriginalLabel and set it into this window
+    // (through wxWindow::SetLabel)
+    m_strOriginalLabel = label;
+
+    if ((styleReal & SS_ENDELLIPSIS) == 0)
+        SetRealLabel(GetEllipsizedLabelWithoutMarkup());
+    else
+        SetRealLabel(RemoveMarkup(label));
 
     // adjust the size of the window to fit to the label unless autoresizing is
     // disabled
-    if ( !(GetWindowStyle() & wxST_NO_AUTORESIZE) )
+    if ( !HasFlag(wxST_NO_AUTORESIZE) &&
+         !IsEllipsized() )  // if ellipsize is ON, then we don't want to get resized!
     {
         InvalidateBestSize();
@@ -203,5 +254,4 @@
 }
 
-
 bool wxStaticText::SetFont(const wxFont& font)
 {
@@ -210,5 +260,5 @@
     // adjust the size of the window to fit to the label unless autoresizing is
     // disabled
-    if ( !(GetWindowStyle() & wxST_NO_AUTORESIZE) )
+    if ( !HasFlag(wxST_NO_AUTORESIZE) )
     {
         InvalidateBestSize();
@@ -220,3 +270,16 @@
 }
 
+// for wxST_ELLIPSIZE_* support:
+
+wxString wxStaticText::GetRealLabel() const
+{
+    return wxGetWindowText(GetHwnd());
+}
+
+void wxStaticText::SetRealLabel(const wxString &str)
+{
+    SetWindowText(GetHwnd(), str.c_str());
+}
+
+
 #endif // wxUSE_STATTEXT
Index: src/os2/stattext.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/os2/stattext.cpp,v
retrieving revision 1.25
diff -u2 -r1.25 src/os2/stattext.cpp
--- src/os2/stattext.cpp
+++ src/os2/stattext.cpp
@@ -67,9 +67,7 @@
         lSstyle |= DT_LEFT;
 
-    wxString sLabel = ::wxPMTextToLabel(rsLabel);
-
     m_hWnd = (WXHWND)::WinCreateWindow( (HWND)GetHwndOf(pParent) // Parent window handle
                                        ,WC_STATIC                // Window class
-                                       ,(PSZ)sLabel.c_str()      // Initial Text
+                                       ,NULL                     // Initial Text
                                        ,(ULONG)lSstyle           // Style flags
                                        ,0L, 0L, 0L, 0L           // Origin -- 0 size
@@ -104,4 +102,6 @@
     SetSize( nX, nY, nWidth, nHeight );
 
+    SetLabel(rsLabel);
+
     return true;
 } // end of wxStaticText::Create
@@ -109,5 +109,5 @@
 wxSize wxStaticText::DoGetBestSize() const
 {
-    wxString sText(wxGetWindowText(GetHWND()));
+    wxString sText(GetLabel());
     int      nWidthTextMax = 0;
     int      nWidthLine = 0;
@@ -206,4 +206,8 @@
                                 ,nSizeFlags
                                );
+
+    // eventually update label (if ellipsizing is on):
+    UpdateLabel();
+
     Refresh();
 } // end of wxStaticText::DoSetSize
@@ -230,6 +234,8 @@
 )
 {
-    wxString                        sLabel = ::wxPMTextToLabel(rsLabel);
-    ::WinSetWindowText(GetHwnd(), (PSZ)sLabel.c_str());
+    m_strOriginalLabel = rsLabel;       // save original label
+
+    // Motif does not support nor ellipsize nor markup in static text:
+    SetRealLabel(GetEllipsizedLabelWithoutMarkup(label));
 
     //
@@ -237,5 +243,6 @@
     // disabled
     //
-    if (!(GetWindowStyle() & wxST_NO_AUTORESIZE))
+    if (!(GetWindowStyle() & wxST_NO_AUTORESIZE) &&
+        !IsEllipsized())
     {
         wxCoord                     vX;
@@ -264,2 +271,18 @@
                                   );
 } // end of wxStaticText::OS2WindowProc
+
+
+// for wxST_ELLIPSIZE_* support:
+
+void wxStaticText::SetRealLabel(const wxString &str)
+{
+    wxString sLabel = ::wxPMTextToLabel(str);
+    ::WinSetWindowText(GetHwnd(), (PSZ)sLabel.c_str());
+}
+
+wxString wxStaticText::GetRealLabel() const
+{
+    // FIXME: how to retrieve the text?
+    //return wxGetWindowText(GetHWND());
+}
+
Index: src/univ/control.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/univ/control.cpp,v
retrieving revision 1.18
diff -u2 -r1.18 src/univ/control.cpp
--- src/univ/control.cpp
+++ src/univ/control.cpp
@@ -124,4 +124,7 @@
 void wxControl::SetLabel(const wxString& label)
 {
+    // save original label
+    wxControlBase::SetLabel(label);
+
     wxString labelOld = m_label;
     m_indexAccel = FindAccelIndex(label, &m_label);
@@ -135,5 +138,6 @@
 wxString wxControl::GetLabel() const
 {
-    return m_label;
+    // return the original label as passed to SetLabel()
+    return wxControlBase::GetLabel();
 }
 
Index: src/univ/stattext.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/univ/stattext.cpp,v
retrieving revision 1.17
diff -u2 -r1.17 src/univ/stattext.cpp
--- src/univ/stattext.cpp
+++ src/univ/stattext.cpp
@@ -67,9 +67,4 @@
 // ----------------------------------------------------------------------------
 
-void wxStaticText::SetLabel(const wxString& label)
-{
-    wxControl::SetLabel(label);
-}
-
 wxSize wxStaticText::DoGetBestClientSize() const
 {
@@ -100,3 +95,35 @@
 }
 
+void wxStaticText::SetLabel(const wxString &str)
+{
+    // save original label
+    m_strOriginalLabel = str;
+
+    // draw as real label the result of GetEllipsizedLabelWithoutMarkup:
+    SetRealLabel(GetEllipsizedLabelWithoutMarkup(str));
+}
+
+// for wxST_ELLIPSIZE_* support:
+
+void wxStaticText::SetRealLabel(const wxString &str)
+{
+    wxString labelOld = m_label;
+    m_indexAccel = FindAccelIndex(label, &m_label);
+
+    if ( m_label != labelOld )
+    {
+        Refresh();
+    }
+}
+
+wxString wxStaticText::GetRealLabel() const
+{
+    return m_label;
+}
+
+/*
+   FIXME: UpdateLabel() should be called on size events to allow correct
+          dynamic ellipsizing of the label
+*/
+
 #endif // wxUSE_STATTEXT

 	  	 
