Index: build/bakefiles/files.bkl
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/build/bakefiles/files.bkl,v
retrieving revision 1.265
diff -b -u -2 -r1.265 files.bkl
--- build/bakefiles/files.bkl	2005/06/22 02:51:03	1.265
+++ build/bakefiles/files.bkl	2005/08/20 05:36:48
@@ -2466,6 +2466,8 @@
 <set var="MEDIA_MSW_SRC" hints="files">
     src/msw/mediactrl.cpp
+    src/msw/ole/activex.cpp
 </set>
 <set var="MEDIA_MSW_HDR" hints="files">
+    wx/msw/ole/activex.h
 </set>
 <!-- not built on WindowsCE: -->
Index: include/wx/mediactrl.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/include/wx/mediactrl.h,v
retrieving revision 1.24
diff -b -u -2 -r1.24 mediactrl.h
--- include/wx/mediactrl.h	2005/07/28 23:56:50	1.24
+++ include/wx/mediactrl.h	2005/08/20 04:47:54
@@ -327,4 +327,5 @@
 };
 
+
 //Event ID to give to our events
 #define wxMEDIA_FINISHED_ID    13000
@@ -350,4 +351,32 @@
 #   define EVT_MEDIA_LOADED(winid, fn) DECLARE_EVENT_TABLE_ENTRY( wxEVT_MEDIA_LOADED, winid, wxID_ANY, wxMediaEventHandler(fn), (wxObject *) NULL ),
 #endif
+
+// ----------------------------------------------------------------------------
+// common backend base class used by many other backends
+// ----------------------------------------------------------------------------
+
+class WXDLLIMPEXP_MEDIA wxMediaBackendCommonBase : public wxMediaBackend
+{
+public:
+    // add a pending wxMediaEvent of the given type
+    void QueueEvent(wxEventType evtType);
+
+    // notify that the movie playback is finished
+    void QueueFinishEvent() { QueueEvent(wxEVT_MEDIA_FINISHED); }
+
+    // send the stop event and return true if it hasn't been vetoed
+    bool SendStopEvent();
+
+protected:
+    // call this when the movie size has changed but not because it has just
+    // been loaded (in this case, call NotifyMovieLoaded() below)
+    void NotifyMovieSizeChanged();
+
+    // call this when the movie is fully loaded
+    void NotifyMovieLoaded();
+
+
+    wxMediaCtrl *m_ctrl;      // parent control
+};
 
 // ----------------------------------------------------------------------------
diff -bu2rN wxold\include\wx\msw\ole/activex.h wxWidgets\include\wx\msw\ole/activex.h
--- wxold\include\wx\msw\ole/activex.h	1969-12-31 16:00:00.000000000 -0800
+++ wxWidgets\include\wx\msw\ole/activex.h	2005-08-19 21:46:37.689947200 -0700
@@ -0,0 +1,190 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        wx/activex.h
+// Purpose:     wxActiveXContainer class
+// Author:      Ryan Norton <wxprojects@comcast.net>
+// Modified by:
+// Created:     8/18/05
+// RCS-ID:      $Id: mediactrl.h,v 1.24 2005/07/28 23:56:50 VZ Exp $
+// Copyright:   (c) Ryan Norton
+// Licence:     wxWindows licence
+///////////////////////////////////////////////////////////////////////////////
+
+// ============================================================================
+// Definitions
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// Header guard
+// ----------------------------------------------------------------------------
+#ifndef _WX_ACTIVEXCONTAINER_H_
+#define _WX_ACTIVEXCONTAINER_H_
+
+//---------------------------------------------------------------------------
+//  COM includes
+//---------------------------------------------------------------------------
+#include "wx/msw/ole/oleutils.h" //wxBasicString, IID etc.
+#include "wx/msw/ole/uuid.h" //IID etc..
+
+//---------------------------------------------------------------------------
+//  COM compatability definitions
+//---------------------------------------------------------------------------
+#ifndef STDMETHODCALLTYPE
+#define STDMETHODCALLTYPE __stdcall
+#endif
+#ifndef STDMETHOD
+#define STDMETHOD(funcname)  virtual HRESULT STDMETHODCALLTYPE funcname
+#endif
+#ifndef PURE
+#define PURE = 0
+#endif
+#ifndef __RPC_FAR
+#define __RPC_FAR FAR
+#endif
+
+//---------------------------------------------------------------------------
+//  WX includes
+//---------------------------------------------------------------------------
+#include "wx/window.h"
+
+//---------------------------------------------------------------------------
+// MSW COM includes
+//---------------------------------------------------------------------------
+#include <oleidl.h>
+#include <olectl.h>
+#include <exdisp.h>
+#include <docobj.h>
+
+//
+//  These defines are from another ole header - but its not in the
+//  latest sdk.  Also the ifndef DISPID_READYSTATE is here because at
+//  least on my machine with the latest sdk olectl.h defines these 3
+//
+#ifndef DISPID_READYSTATE
+    #define DISPID_READYSTATE                               -525
+    #define DISPID_READYSTATECHANGE                         -609
+    #define DISPID_AMBIENT_TRANSFERPRIORITY                 -728
+#endif
+
+#define DISPID_AMBIENT_OFFLINEIFNOTCONNECTED            -5501
+#define DISPID_AMBIENT_SILENT                           -5502
+
+#ifndef DISPID_AMBIENT_CODEPAGE
+#   define DISPID_AMBIENT_CODEPAGE                         -725
+#   define DISPID_AMBIENT_CHARSET                          -727
+#endif
+
+
+//---------------------------------------------------------------------------
+//
+//  wxActiveXContainer
+//
+//---------------------------------------------------------------------------
+
+#define WX_DECLARE_AUTOOLE(wxAutoOleInterface, I) \
+class wxAutoOleInterface \
+{   \
+    protected: \
+    I *m_interface; \
+\
+    public: \
+    explicit wxAutoOleInterface(I *pInterface = NULL) : m_interface(pInterface) {} \
+    wxAutoOleInterface(REFIID riid, IUnknown *pUnk) : m_interface(NULL) \
+    {   QueryInterface(riid, pUnk); } \
+    wxAutoOleInterface(REFIID riid, IDispatch *pDispatch) : m_interface(NULL) \
+    {   QueryInterface(riid, pDispatch); } \
+    wxAutoOleInterface(REFCLSID clsid, REFIID riid) : m_interface(NULL)\
+    {   CreateInstance(clsid, riid); }\
+    wxAutoOleInterface(const wxAutoOleInterface& ti) : m_interface(NULL)\
+    {   operator = (ti); }\
+\
+    wxAutoOleInterface& operator = (const wxAutoOleInterface& ti)\
+    {\
+        if (ti.m_interface)\
+            ti.m_interface->AddRef();\
+        Free();\
+        m_interface = ti.m_interface;\
+        return *this;\
+    }\
+\
+    wxAutoOleInterface& operator = (I *&ti)\
+    {\
+        Free();\
+        m_interface = ti;\
+        return *this;\
+    }\
+\
+    ~wxAutoOleInterface() {   Free();   }\
+\
+    inline void Free()\
+    {\
+        if (m_interface)\
+            m_interface->Release();\
+        m_interface = NULL;\
+    }\
+\
+    HRESULT QueryInterface(REFIID riid, IUnknown *pUnk)\
+    {\
+        Free();\
+        wxASSERT(pUnk != NULL);\
+        return pUnk->QueryInterface(riid, (void **) &m_interface);\
+    }\
+\
+    HRESULT CreateInstance(REFCLSID clsid, REFIID riid)\
+    {\
+        Free();\
+        return CoCreateInstance(clsid, NULL, CLSCTX_ALL, riid, (void **) &m_interface);\
+    }\
+\
+    inline operator I *() const {return m_interface;}\
+    inline I* operator ->() {return m_interface;}\
+    inline I** GetRef()    {return &m_interface;}\
+    inline bool Ok() const    {return m_interface != NULL;}\
+};
+
+WX_DECLARE_AUTOOLE(wxAutoIDispatch, IDispatch)
+WX_DECLARE_AUTOOLE(wxAutoIOleClientSite, IOleClientSite)
+WX_DECLARE_AUTOOLE(wxAutoIUnknown, IUnknown)
+WX_DECLARE_AUTOOLE(wxAutoIOleObject, IOleObject)
+WX_DECLARE_AUTOOLE(wxAutoIOleInPlaceObject, IOleInPlaceObject)
+WX_DECLARE_AUTOOLE(wxAutoIOleInPlaceActiveObject, IOleInPlaceActiveObject)
+WX_DECLARE_AUTOOLE(wxAutoIOleDocumentView, IOleDocumentView)
+WX_DECLARE_AUTOOLE(wxAutoIViewObject, IViewObject)
+WX_DECLARE_AUTOOLE(wxAutoIOleInPlaceSite, IOleInPlaceSite)
+WX_DECLARE_AUTOOLE(wxAutoIOleDocument, IOleDocument)
+WX_DECLARE_AUTOOLE(wxAutoIPersistStreamInit, IPersistStreamInit)
+WX_DECLARE_AUTOOLE(wxAutoIAdviseSink, IAdviseSink)
+
+class wxActiveXContainer : public wxWindow
+{
+public:
+    wxActiveXContainer(wxWindow * parent, REFIID iid, IUnknown* pUnk);
+    virtual ~wxActiveXContainer();
+
+    void OnSize(wxSizeEvent&);
+    void OnPaint(wxPaintEvent&);
+    void OnSetFocus(wxFocusEvent&);
+    void OnKillFocus(wxFocusEvent&);
+
+protected:
+    friend class FrameSite;
+
+    wxAutoIDispatch            m_Dispatch;
+    wxAutoIOleClientSite      m_clientSite;
+    wxAutoIUnknown         m_ActiveX;
+    wxAutoIOleObject            m_oleObject;
+    wxAutoIOleInPlaceObject    m_oleInPlaceObject;
+    wxAutoIOleInPlaceActiveObject m_oleInPlaceActiveObject;
+    wxAutoIOleDocumentView    m_docView;
+    wxAutoIViewObject            m_viewObject;
+    HWND m_oleObjectHWND;
+    bool m_bAmbientUserMode;
+    DWORD m_docAdviseCookie;
+    wxWindow* m_realparent;
+
+    void CreateActiveX(REFIID, IUnknown*);
+};
+
+// ----------------------------------------------------------------------------
+// END Header guard
+// ----------------------------------------------------------------------------
+#endif

Index: src/common/mediactrlcmn.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/common/mediactrlcmn.cpp,v
retrieving revision 1.15
diff -b -u -2 -r1.15 mediactrlcmn.cpp
--- src/common/mediactrlcmn.cpp	2005/07/28 23:56:51	1.15
+++ src/common/mediactrlcmn.cpp	2005/08/20 04:38:19
@@ -469,4 +469,47 @@
 }
 
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//
+//  wxMediaBackendCommonBase
+//
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+void wxMediaBackendCommonBase::NotifyMovieSizeChanged()
+{
+    // our best size changed after opening a new file
+    m_ctrl->InvalidateBestSize();
+    m_ctrl->SetSize(m_ctrl->GetSize());
+
+    // if the parent of the control has a sizer ask it to refresh our size
+    wxWindow * const parent = m_ctrl->GetParent();
+    if ( parent->GetSizer() )
+    {
+        m_ctrl->GetParent()->Layout();
+        m_ctrl->GetParent()->Refresh();
+        m_ctrl->GetParent()->Update();
+    }
+}
+
+void wxMediaBackendCommonBase::NotifyMovieLoaded()
+{
+    NotifyMovieSizeChanged();
+
+    // notify about movie being fully loaded
+    QueueEvent(wxEVT_MEDIA_LOADED);
+}
+
+bool wxMediaBackendCommonBase::SendStopEvent()
+{
+    wxMediaEvent theEvent(wxEVT_MEDIA_STOP, m_ctrl->GetId());
+
+    return !m_ctrl->ProcessEvent(theEvent) || theEvent.IsAllowed();
+}
+
+void wxMediaBackendCommonBase::QueueEvent(wxEventType evtType)
+{
+    wxMediaEvent theEvent(evtType, m_ctrl->GetId());
+    m_ctrl->AddPendingEvent(theEvent);
+}
+
 #include "wx/html/forcelnk.h"
 FORCE_LINK(basewxmediabackends);
Index: src/generic/listctrl.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/generic/listctrl.cpp,v
retrieving revision 1.377
diff -b -u -2 -r1.377 listctrl.cpp
--- src/generic/listctrl.cpp	2005/07/22 22:29:18	1.377
+++ src/generic/listctrl.cpp	2005/08/20 08:32:12
@@ -675,4 +675,5 @@
     {
         wxListItem info;
+        info.m_mask = wxLIST_MASK_TEXT;
         info.m_itemId = item;
         GetItem( info );
@@ -998,6 +999,9 @@
 void wxListItemData::GetItem( wxListItem &info ) const
 {
+    if ( info.m_mask & wxLIST_MASK_TEXT )
     info.m_text = m_text;
+    if ( info.m_mask & wxLIST_MASK_IMAGE )
     info.m_image = m_image;
+    if ( info.m_mask & wxLIST_MASK_DATA )
     info.m_data = m_data;
 
@@ -3649,4 +3653,8 @@
         line->SetItem( item.m_col, item );
 
+        // Set item state if user wants
+        if ( item.m_mask & wxLIST_MASK_STATE )
+            SetItemState( item.m_itemId, item.m_state, item.m_state );
+        
         if (InReportView())
         {
@@ -3832,4 +3840,9 @@
     wxListLineData *line = GetLine((size_t)item.m_itemId);
     line->GetItem( item.m_col, item );
+
+    // Get item state if user wants it    
+    if ( item.m_mask & wxLIST_MASK_STATE )
+        item.m_state = GetItemState( item.m_itemId, wxLIST_STATE_SELECTED |
+                                                 wxLIST_STATE_FOCUSED );
 }
 
@@ -4997,4 +5010,5 @@
 {
     wxListItem info;
+    info.m_mask = wxLIST_MASK_DATA;
     info.m_itemId = item;
     m_mainWin->GetItem( info );
 
Index: src/msw/mediactrl.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/msw/mediactrl.cpp,v
retrieving revision 1.55
diff -b -u -2 -r1.55 mediactrl.cpp
--- src/msw/mediactrl.cpp	2005/08/05 23:16:15	1.55
+++ src/msw/mediactrl.cpp	2005/08/21 06:05:18
@@ -16,6 +16,4 @@
       this file is huge and also separate the standard contents from our code
       itself
-    - extract ~1000 lines of wxActiveX code in its own file, why does it have
-      to be here??
  */
 
@@ -76,32 +74,4 @@
 //===========================================================================
 
-// ----------------------------------------------------------------------------
-// common backend base class used by all other backends
-// ----------------------------------------------------------------------------
-
-class WXDLLIMPEXP_MEDIA wxMediaBackendCommonBase : public wxMediaBackend
-{
-public:
-    // add a pending wxMediaEvent of the given type
-    void QueueEvent(wxEventType evtType);
-
-    // notify that the movie playback is finished
-    void QueueFinishEvent() { QueueEvent(wxEVT_MEDIA_FINISHED); }
-
-    // send the stop event and return true if it hasn't been vetoed
-    bool SendStopEvent();
-
-protected:
-    // call this when the movie size has changed but not because it has just
-    // been loaded (in this case, call NotifyMovieLoaded() below)
-    void NotifyMovieSizeChanged();
-
-    // call this when the movie is fully loaded
-    void NotifyMovieLoaded();
-
-
-    wxControl *m_ctrl;      // parent control
-};
-
 //---------------------------------------------------------------------------
 //
@@ -111,49 +81,9 @@
 
 //---------------------------------------------------------------------------
-//  COM includes
+//  wxActiveXContainer - includes all the COM-specific stuff we need
 //---------------------------------------------------------------------------
-#include "wx/msw/ole/oleutils.h" //wxBasicString, IID etc.
-#include "wx/msw/ole/uuid.h" //IID etc..
-#include <oleidl.h>
-#include <olectl.h>
-#include <exdisp.h>
-#include <docobj.h>
-
-//
-//  These defines are from another ole header - but its not in the
-//  latest sdk.  Also the ifndef DISPID_READYSTATE is here because at
-//  least on my machine with the latest sdk olectl.h defines these 3
-//
-#ifndef DISPID_READYSTATE
-    #define DISPID_READYSTATE                               -525
-    #define DISPID_READYSTATECHANGE                         -609
-    #define DISPID_AMBIENT_TRANSFERPRIORITY                 -728
-#endif
-
-#define DISPID_AMBIENT_OFFLINEIFNOTCONNECTED            -5501
-#define DISPID_AMBIENT_SILENT                           -5502
-
-#ifndef DISPID_AMBIENT_CODEPAGE
-#   define DISPID_AMBIENT_CODEPAGE                         -725
-#   define DISPID_AMBIENT_CHARSET                          -727
-#endif
+#include "wx/msw/ole/activex.h"
 
 //---------------------------------------------------------------------------
-//  COM compatability definitions
-//---------------------------------------------------------------------------
-#ifndef STDMETHODCALLTYPE
-#define STDMETHODCALLTYPE __stdcall
-#endif
-#ifndef STDMETHOD
-#define STDMETHOD(funcname)  virtual HRESULT STDMETHODCALLTYPE funcname
-#endif
-#ifndef PURE
-#define PURE = 0
-#endif
-#ifndef __RPC_FAR
-#define __RPC_FAR FAR
-#endif
-
-//---------------------------------------------------------------------------
 //  IIDS - used by CoCreateInstance and IUnknown::QueryInterface
 //
@@ -901,908 +831,5 @@
 };
 
-//---------------------------------------------------------------------------
-//
-//  wxActiveX (Ryan Norton's version :))
-//  wxActiveX is (C) 2003 Lindsay Mathieson
-//
-//---------------------------------------------------------------------------
-#define WX_DECLARE_AUTOOLE(wxAutoOleInterface, I) \
-class wxAutoOleInterface \
-{   \
-    protected: \
-    I *m_interface; \
-\
-    public: \
-    explicit wxAutoOleInterface(I *pInterface = NULL) : m_interface(pInterface) {} \
-    wxAutoOleInterface(REFIID riid, IUnknown *pUnk) : m_interface(NULL) \
-    {   QueryInterface(riid, pUnk); } \
-    wxAutoOleInterface(REFIID riid, IDispatch *pDispatch) : m_interface(NULL) \
-    {   QueryInterface(riid, pDispatch); } \
-    wxAutoOleInterface(REFCLSID clsid, REFIID riid) : m_interface(NULL)\
-    {   CreateInstance(clsid, riid); }\
-    wxAutoOleInterface(const wxAutoOleInterface& ti) : m_interface(NULL)\
-    {   operator = (ti); }\
-\
-    wxAutoOleInterface& operator = (const wxAutoOleInterface& ti)\
-    {\
-        if (ti.m_interface)\
-            ti.m_interface->AddRef();\
-        Free();\
-        m_interface = ti.m_interface;\
-        return *this;\
-    }\
-\
-    wxAutoOleInterface& operator = (I *&ti)\
-    {\
-        Free();\
-        m_interface = ti;\
-        return *this;\
-    }\
-\
-    ~wxAutoOleInterface() {   Free();   }\
-\
-    inline void Free()\
-    {\
-        if (m_interface)\
-            m_interface->Release();\
-        m_interface = NULL;\
-    }\
-\
-    HRESULT QueryInterface(REFIID riid, IUnknown *pUnk)\
-    {\
-        Free();\
-        wxASSERT(pUnk != NULL);\
-        return pUnk->QueryInterface(riid, (void **) &m_interface);\
-    }\
-\
-    HRESULT CreateInstance(REFCLSID clsid, REFIID riid)\
-    {\
-        Free();\
-        return CoCreateInstance(clsid, NULL, CLSCTX_ALL, riid, (void **) &m_interface);\
-    }\
-\
-    inline operator I *() const {return m_interface;}\
-    inline I* operator ->() {return m_interface;}\
-    inline I** GetRef()    {return &m_interface;}\
-    inline bool Ok() const    {return m_interface != NULL;}\
-};
-
-WX_DECLARE_AUTOOLE(wxAutoIDispatch, IDispatch)
-WX_DECLARE_AUTOOLE(wxAutoIOleClientSite, IOleClientSite)
-WX_DECLARE_AUTOOLE(wxAutoIUnknown, IUnknown)
-WX_DECLARE_AUTOOLE(wxAutoIOleObject, IOleObject)
-WX_DECLARE_AUTOOLE(wxAutoIOleInPlaceObject, IOleInPlaceObject)
-WX_DECLARE_AUTOOLE(wxAutoIOleInPlaceActiveObject, IOleInPlaceActiveObject)
-WX_DECLARE_AUTOOLE(wxAutoIOleDocumentView, IOleDocumentView)
-WX_DECLARE_AUTOOLE(wxAutoIViewObject, IViewObject)
-WX_DECLARE_AUTOOLE(wxAutoIOleInPlaceSite, IOleInPlaceSite)
-WX_DECLARE_AUTOOLE(wxAutoIOleDocument, IOleDocument)
-WX_DECLARE_AUTOOLE(wxAutoIPersistStreamInit, IPersistStreamInit)
-WX_DECLARE_AUTOOLE(wxAutoIAdviseSink, IAdviseSink)
-
-class wxActiveX : public wxWindow
-{
-public:
-    wxActiveX(wxWindow * parent, REFIID iid, IUnknown* pUnk);
-    virtual ~wxActiveX();
-
-    void OnSize(wxSizeEvent&);
-    void OnPaint(wxPaintEvent&);
-    void OnSetFocus(wxFocusEvent&);
-    void OnKillFocus(wxFocusEvent&);
-
-protected:
-    friend class FrameSite;
-
-    wxAutoIDispatch            m_Dispatch;
-    wxAutoIOleClientSite      m_clientSite;
-    wxAutoIUnknown         m_ActiveX;
-    wxAutoIOleObject            m_oleObject;
-    wxAutoIOleInPlaceObject    m_oleInPlaceObject;
-    wxAutoIOleInPlaceActiveObject m_oleInPlaceActiveObject;
-    wxAutoIOleDocumentView    m_docView;
-    wxAutoIViewObject            m_viewObject;
-    HWND m_oleObjectHWND;
-    bool m_bAmbientUserMode;
-    DWORD m_docAdviseCookie;
-    wxWindow* m_realparent;
-
-    void CreateActiveX(REFIID, IUnknown*);
-};
-
-#define DECLARE_OLE_UNKNOWN(cls)\
-    private:\
-    class TAutoInitInt\
-    {\
-        public:\
-        LONG l;\
-        TAutoInitInt() : l(0) {}\
-    };\
-    TAutoInitInt refCount, lockCount;\
-    static void _GetInterface(cls *self, REFIID iid, void **_interface, const char *&desc);\
-    public:\
-    LONG GetRefCount();\
-    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void ** ppvObject);\
-    ULONG STDMETHODCALLTYPE AddRef();\
-    ULONG STDMETHODCALLTYPE Release();\
-    ULONG STDMETHODCALLTYPE AddLock();\
-    ULONG STDMETHODCALLTYPE ReleaseLock()
-
-#define DEFINE_OLE_TABLE(cls)\
-    LONG cls::GetRefCount() {return refCount.l;}\
-    HRESULT STDMETHODCALLTYPE cls::QueryInterface(REFIID iid, void ** ppvObject)\
-    {\
-        if (! ppvObject)\
-        {\
-            return E_FAIL;\
-        };\
-        const char *desc = NULL;\
-        cls::_GetInterface(this, iid, ppvObject, desc);\
-        if (! *ppvObject)\
-        {\
-            return E_NOINTERFACE;\
-        };\
-        ((IUnknown * )(*ppvObject))->AddRef();\
-        return S_OK;\
-    };\
-    ULONG STDMETHODCALLTYPE cls::AddRef()\
-    {\
-        InterlockedIncrement(&refCount.l);\
-        return refCount.l;\
-    };\
-    ULONG STDMETHODCALLTYPE cls::Release()\
-    {\
-        if (refCount.l > 0)\
-        {\
-            InterlockedDecrement(&refCount.l);\
-            if (refCount.l == 0)\
-            {\
-                delete this;\
-                return 0;\
-            };\
-            return refCount.l;\
-        }\
-        else\
-            return 0;\
-    }\
-    ULONG STDMETHODCALLTYPE cls::AddLock()\
-    {\
-        InterlockedIncrement(&lockCount.l);\
-        return lockCount.l;\
-    };\
-    ULONG STDMETHODCALLTYPE cls::ReleaseLock()\
-    {\
-        if (lockCount.l > 0)\
-        {\
-            InterlockedDecrement(&lockCount.l);\
-            return lockCount.l;\
-        }\
-        else\
-            return 0;\
-    }\
-    DEFINE_OLE_BASE(cls)
-
-#define DEFINE_OLE_BASE(cls)\
-    void cls::_GetInterface(cls *self, REFIID iid, void **_interface, const char *&desc)\
-    {\
-        *_interface = NULL;\
-        desc = NULL;
-
-#define OLE_INTERFACE(_iid, _type)\
-    if (IsEqualIID(iid, _iid))\
-    {\
-        *_interface = (IUnknown *) (_type *) self;\
-        desc = # _iid;\
-        return;\
-    }
-
-#define OLE_IINTERFACE(_face) OLE_INTERFACE(IID_##_face, _face)
-
-#define OLE_INTERFACE_CUSTOM(func)\
-    if (func(self, iid, _interface, desc))\
-    {\
-        return;\
-    }
-
-#define END_OLE_TABLE\
-    }
-
-
-class FrameSite :
-    public IOleClientSite,
-    public IOleInPlaceSiteEx,
-    public IOleInPlaceFrame,
-    public IOleItemContainer,
-    public IDispatch,
-    public IOleCommandTarget,
-    public IOleDocumentSite,
-    public IAdviseSink,
-    public IOleControlSite
-{
-private:
-    DECLARE_OLE_UNKNOWN(FrameSite);
-
-public:
-    FrameSite(wxWindow * win, wxActiveX * win2)
-    {
-        m_window = win2;
-        m_bSupportsWindowlessActivation = true;
-        m_bInPlaceLocked = false;
-        m_bUIActive = false;
-        m_bInPlaceActive = false;
-        m_bWindowless = false;
-
-        m_nAmbientLocale = 0;
-        m_clrAmbientForeColor = ::GetSysColor(COLOR_WINDOWTEXT);
-        m_clrAmbientBackColor = ::GetSysColor(COLOR_WINDOW);
-        m_bAmbientShowHatching = true;
-        m_bAmbientShowGrabHandles = true;
-        m_bAmbientAppearance = true;
-
-        m_hDCBuffer = NULL;
-        m_hWndParent = (HWND)win->GetHWND();
-    }
-    virtual ~FrameSite(){}
-    //***************************IDispatch*****************************
-    HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID, OLECHAR ** ,
-                                            unsigned int , LCID ,
-                                            DISPID * )
-    {   return E_NOTIMPL;   }
-    STDMETHOD(GetTypeInfo)(unsigned int, LCID, ITypeInfo **)
-    {   return E_NOTIMPL;   }
-    HRESULT STDMETHODCALLTYPE GetTypeInfoCount(unsigned int *)
-    {   return E_NOTIMPL;   }
-    HRESULT STDMETHODCALLTYPE Invoke(DISPID dispIdMember, REFIID, LCID,
-                            WORD wFlags, DISPPARAMS *,
-                            VARIANT * pVarResult, EXCEPINFO *,
-                            unsigned int *)
-    {
-        if (!(wFlags & DISPATCH_PROPERTYGET))
-            return S_OK;
-
-        if (pVarResult == NULL)
-            return E_INVALIDARG;
-
-        //The most common case is boolean, use as an initial type
-        V_VT(pVarResult) = VT_BOOL;
-
-        switch (dispIdMember)
-        {
-            case DISPID_AMBIENT_MESSAGEREFLECT:
-                V_BOOL(pVarResult)= FALSE;
-                return S_OK;
-
-            case DISPID_AMBIENT_DISPLAYASDEFAULT:
-                V_BOOL(pVarResult)= TRUE;
-                return S_OK;
-
-            case DISPID_AMBIENT_OFFLINEIFNOTCONNECTED:
-                V_BOOL(pVarResult) = TRUE;
-                return S_OK;
-
-            case DISPID_AMBIENT_SILENT:
-                V_BOOL(pVarResult)= TRUE;
-                return S_OK;
-
-            case DISPID_AMBIENT_APPEARANCE:
-                pVarResult->vt = VT_BOOL;
-                pVarResult->boolVal = m_bAmbientAppearance;
-                break;
-
-            case DISPID_AMBIENT_FORECOLOR:
-                pVarResult->vt = VT_I4;
-                pVarResult->lVal = (long) m_clrAmbientForeColor;
-                break;
-
-            case DISPID_AMBIENT_BACKCOLOR:
-                pVarResult->vt = VT_I4;
-                pVarResult->lVal = (long) m_clrAmbientBackColor;
-                break;
-
-            case DISPID_AMBIENT_LOCALEID:
-                pVarResult->vt = VT_I4;
-                pVarResult->lVal = (long) m_nAmbientLocale;
-                break;
-
-            case DISPID_AMBIENT_USERMODE:
-                pVarResult->vt = VT_BOOL;
-                pVarResult->boolVal = m_window->m_bAmbientUserMode;
-                break;
-
-            case DISPID_AMBIENT_SHOWGRABHANDLES:
-                pVarResult->vt = VT_BOOL;
-                pVarResult->boolVal = m_bAmbientShowGrabHandles;
-                break;
-
-            case DISPID_AMBIENT_SHOWHATCHING:
-                pVarResult->vt = VT_BOOL;
-                pVarResult->boolVal = m_bAmbientShowHatching;
-                break;
-
-            default:
-                return DISP_E_MEMBERNOTFOUND;
-        }
-
-        return S_OK;
-    }
-
-    //**************************IOleWindow***************************
-    HRESULT STDMETHODCALLTYPE GetWindow(HWND * phwnd)
-    {
-        if (phwnd == NULL)
-            return E_INVALIDARG;
-        (*phwnd) = m_hWndParent;
-        return S_OK;
-    }
-    HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL)
-    {return S_OK;}
-    //**************************IOleInPlaceUIWindow*****************
-    HRESULT STDMETHODCALLTYPE GetBorder(LPRECT lprectBorder)
-    {
-        if (lprectBorder == NULL)
-            return E_INVALIDARG;
-        return INPLACE_E_NOTOOLSPACE;
-    }
-    HRESULT STDMETHODCALLTYPE RequestBorderSpace(LPCBORDERWIDTHS pborderwidths)
-    {
-        if (pborderwidths == NULL)
-            return E_INVALIDARG;
-        return INPLACE_E_NOTOOLSPACE;
-    }
-    HRESULT STDMETHODCALLTYPE SetBorderSpace(LPCBORDERWIDTHS)
-    {return S_OK;}
-    HRESULT STDMETHODCALLTYPE SetActiveObject(
-        IOleInPlaceActiveObject *pActiveObject, LPCOLESTR)
-    {
-        if (pActiveObject)
-            pActiveObject->AddRef();
-
-        m_window->m_oleInPlaceActiveObject = pActiveObject;
-        return S_OK;
-    }
-
-    //********************IOleInPlaceFrame************************
-
-    STDMETHOD(InsertMenus)(HMENU, LPOLEMENUGROUPWIDTHS){return S_OK;}
-    STDMETHOD(SetMenu)(HMENU, HOLEMENU, HWND){  return S_OK;}
-    STDMETHOD(RemoveMenus)(HMENU){return S_OK;}
-    STDMETHOD(SetStatusText)(LPCOLESTR){ return S_OK;}
-    HRESULT STDMETHODCALLTYPE EnableModeless(BOOL){return S_OK;}
-    HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG lpmsg, WORD)
-    {
-        // TODO: send an event with this id
-        if (m_window->m_oleInPlaceActiveObject.Ok())
-            m_window->m_oleInPlaceActiveObject->TranslateAccelerator(lpmsg);
-        return S_FALSE;
-    }
-
-    //*******************IOleInPlaceSite**************************
-    HRESULT STDMETHODCALLTYPE CanInPlaceActivate(){return S_OK;}
-    HRESULT STDMETHODCALLTYPE OnInPlaceActivate()
-    {   m_bInPlaceActive = true;    return S_OK;    }
-    HRESULT STDMETHODCALLTYPE OnUIActivate()
-    {   m_bUIActive = true;         return S_OK;    }
-    HRESULT STDMETHODCALLTYPE GetWindowContext(IOleInPlaceFrame **ppFrame,
-                                        IOleInPlaceUIWindow **ppDoc,
-                                        LPRECT lprcPosRect,
-                                        LPRECT lprcClipRect,
-                                        LPOLEINPLACEFRAMEINFO lpFrameInfo)
-    {
-        if (ppFrame == NULL || ppDoc == NULL || lprcPosRect == NULL ||
-            lprcClipRect == NULL || lpFrameInfo == NULL)
-        {
-            if (ppFrame != NULL)
-                (*ppFrame) = NULL;
-            if (ppDoc != NULL)
-                (*ppDoc) = NULL;
-            return E_INVALIDARG;
-        }
-
-        HRESULT hr = QueryInterface(IID_IOleInPlaceFrame, (void **) ppFrame);
-        if (! SUCCEEDED(hr))
-        {
-            return E_UNEXPECTED;
-        };
-
-        hr = QueryInterface(IID_IOleInPlaceUIWindow, (void **) ppDoc);
-        if (! SUCCEEDED(hr))
-        {
-            (*ppFrame)->Release();
-            *ppFrame = NULL;
-            return E_UNEXPECTED;
-        };
-
-        RECT rect;
-        ::GetClientRect(m_hWndParent, &rect);
-        if (lprcPosRect)
-        {
-            lprcPosRect->left = lprcPosRect->top = 0;
-            lprcPosRect->right = rect.right;
-            lprcPosRect->bottom = rect.bottom;
-        };
-        if (lprcClipRect)
-        {
-            lprcClipRect->left = lprcClipRect->top = 0;
-            lprcClipRect->right = rect.right;
-            lprcClipRect->bottom = rect.bottom;
-        };
-
-        memset(lpFrameInfo, 0, sizeof(OLEINPLACEFRAMEINFO));
-        lpFrameInfo->cb = sizeof(OLEINPLACEFRAMEINFO);
-        lpFrameInfo->hwndFrame = m_hWndParent;
-
-        return S_OK;
-    }
-    HRESULT STDMETHODCALLTYPE Scroll(SIZE){return S_OK;}
-    HRESULT STDMETHODCALLTYPE OnUIDeactivate(BOOL)
-    {   m_bUIActive = false;         return S_OK;    }
-    HRESULT STDMETHODCALLTYPE OnInPlaceDeactivate()
-    {   m_bInPlaceActive = false;    return S_OK;    }
-    HRESULT STDMETHODCALLTYPE DiscardUndoState(){return S_OK;}
-    HRESULT STDMETHODCALLTYPE DeactivateAndUndo(){return S_OK; }
-    HRESULT STDMETHODCALLTYPE OnPosRectChange(LPCRECT lprcPosRect)
-    {
-        if (m_window->m_oleInPlaceObject.Ok() && lprcPosRect)
-        {
-            m_window->m_oleInPlaceObject->SetObjectRects(
-                lprcPosRect, lprcPosRect);
-        }
-        return S_OK;
-    }
-    //*************************IOleInPlaceSiteEx***********************
-    HRESULT STDMETHODCALLTYPE OnInPlaceActivateEx(BOOL * pfNoRedraw, DWORD)
-    {
-        OleLockRunning(m_window->m_ActiveX, TRUE, FALSE);
-        if (pfNoRedraw)
-            (*pfNoRedraw) = FALSE;
-        return S_OK;
-    }
-
-    HRESULT STDMETHODCALLTYPE OnInPlaceDeactivateEx(BOOL)
-    {
-        OleLockRunning(m_window->m_ActiveX, FALSE, FALSE);
-        return S_OK;
-    }
-    STDMETHOD(RequestUIActivate)(){ return S_OK;}
-    //*************************IOleClientSite**************************
-    HRESULT STDMETHODCALLTYPE SaveObject(){return S_OK;}
-    const char *OleGetMonikerToStr(DWORD dwAssign)
-    {
-        switch (dwAssign)
-        {
-        case OLEGETMONIKER_ONLYIFTHERE  : return "OLEGETMONIKER_ONLYIFTHERE";
-        case OLEGETMONIKER_FORCEASSIGN  : return "OLEGETMONIKER_FORCEASSIGN";
-        case OLEGETMONIKER_UNASSIGN     : return "OLEGETMONIKER_UNASSIGN";
-        case OLEGETMONIKER_TEMPFORUSER  : return "OLEGETMONIKER_TEMPFORUSER";
-        default                         : return "Bad Enum";
-        };
-    };
-
-    const char *OleGetWhicMonikerStr(DWORD dwWhichMoniker)
-    {
-        switch(dwWhichMoniker)
-        {
-        case OLEWHICHMK_CONTAINER   : return "OLEWHICHMK_CONTAINER";
-        case OLEWHICHMK_OBJREL      : return "OLEWHICHMK_OBJREL";
-        case OLEWHICHMK_OBJFULL     : return "OLEWHICHMK_OBJFULL";
-        default                     : return "Bad Enum";
-        };
-    };
-    STDMETHOD(GetMoniker)(DWORD, DWORD, IMoniker **){return E_FAIL;}
-    HRESULT STDMETHODCALLTYPE GetContainer(LPOLECONTAINER * ppContainer)
-    {
-        if (ppContainer == NULL)
-            return E_INVALIDARG;
-        HRESULT hr = QueryInterface(
-            IID_IOleContainer, (void**)(ppContainer));
-        wxASSERT(SUCCEEDED(hr));
-        return hr;
-    }
-    HRESULT STDMETHODCALLTYPE ShowObject()
-    {
-        if (m_window->m_oleObjectHWND)
-            ::ShowWindow(m_window->m_oleObjectHWND, SW_SHOW);
-        return S_OK;
-    }
-    STDMETHOD(OnShowWindow)(BOOL){return S_OK;}
-    STDMETHOD(RequestNewObjectLayout)(){return E_NOTIMPL;}
-    //********************IParseDisplayName***************************
-    HRESULT STDMETHODCALLTYPE ParseDisplayName(
-        IBindCtx *, LPOLESTR, ULONG *, IMoniker **){return E_NOTIMPL;}
-    //********************IOleContainer*******************************
-    STDMETHOD(EnumObjects)(DWORD, IEnumUnknown **){return E_NOTIMPL;}
-    HRESULT STDMETHODCALLTYPE LockContainer(BOOL){return S_OK;}
-    //********************IOleItemContainer***************************
-    HRESULT STDMETHODCALLTYPE
-    #ifdef _UNICODE
-    GetObjectW
-    #else
-    GetObjectA
-    #endif
-    (LPOLESTR pszItem, DWORD, IBindCtx *, REFIID, void ** ppvObject)
-    {
-        if (pszItem == NULL || ppvObject == NULL)
-            return E_INVALIDARG;
-        *ppvObject = NULL;
-        return MK_E_NOOBJECT;
-    }
-    HRESULT STDMETHODCALLTYPE GetObjectStorage(
-        LPOLESTR pszItem, IBindCtx * , REFIID, void ** ppvStorage)
-    {
-        if (pszItem == NULL || ppvStorage == NULL)
-            return E_INVALIDARG;
-        *ppvStorage = NULL;
-        return MK_E_NOOBJECT;
-    }
-    HRESULT STDMETHODCALLTYPE IsRunning(LPOLESTR pszItem)
-    {
-        if (pszItem == NULL)
-            return E_INVALIDARG;
-        return MK_E_NOOBJECT;
-    }
-    //***********************IOleControlSite*****************************
-    HRESULT STDMETHODCALLTYPE OnControlInfoChanged()
-    {return S_OK;}
-    HRESULT STDMETHODCALLTYPE LockInPlaceActive(BOOL fLock)
-    {
-        m_bInPlaceLocked = (fLock) ? true : false;
-        return S_OK;
-    }
-    HRESULT STDMETHODCALLTYPE GetExtendedControl(IDispatch **)
-    {return E_NOTIMPL;}
-    HRESULT STDMETHODCALLTYPE TransformCoords(
-        POINTL * pPtlHimetric, POINTF * pPtfContainer, DWORD)
-    {
-        if (pPtlHimetric == NULL || pPtfContainer == NULL)
-            return E_INVALIDARG;
-        return E_NOTIMPL;
-    }
-    HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG, DWORD)
-    {return E_NOTIMPL;}
-    HRESULT STDMETHODCALLTYPE OnFocus(BOOL){return S_OK;}
-    HRESULT STDMETHODCALLTYPE ShowPropertyFrame(){return E_NOTIMPL;}
-    //**************************IOleCommandTarget***********************
-    HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *, ULONG cCmds,
-                                OLECMD prgCmds[], OLECMDTEXT *)
-    {
-        if (prgCmds == NULL) return E_INVALIDARG;
-        for (ULONG nCmd = 0; nCmd < cCmds; nCmd++)
-        {
-            // unsupported by default
-            prgCmds[nCmd].cmdf = 0;
-        }
-        return OLECMDERR_E_UNKNOWNGROUP;
-    }
-
-    HRESULT STDMETHODCALLTYPE Exec(const GUID *, DWORD,
-                            DWORD, VARIANTARG *, VARIANTARG *)
-    {return OLECMDERR_E_NOTSUPPORTED;}
-
-    //**********************IAdviseSink************************************
-    void STDMETHODCALLTYPE OnDataChange(FORMATETC *, STGMEDIUM *) {}
-    void STDMETHODCALLTYPE OnViewChange(DWORD, LONG) {}
-    void STDMETHODCALLTYPE OnRename(IMoniker *){}
-    void STDMETHODCALLTYPE OnSave(){}
-    void STDMETHODCALLTYPE OnClose(){}
-
-    //**********************IOleDocumentSite***************************
-    HRESULT STDMETHODCALLTYPE ActivateMe(
-        IOleDocumentView __RPC_FAR *pViewToActivate)
-    {
-        wxAutoIOleInPlaceSite inPlaceSite(
-            IID_IOleInPlaceSite, (IDispatch *) this);
-        if (!inPlaceSite.Ok())
-            return E_FAIL;
-
-        if (pViewToActivate)
-        {
-            m_window->m_docView = pViewToActivate;
-            m_window->m_docView->SetInPlaceSite(inPlaceSite);
-        }
-        else
-        {
-            wxAutoIOleDocument oleDoc(
-                IID_IOleDocument, m_window->m_oleObject);
-            if (! oleDoc.Ok())
-                return E_FAIL;
-
-            HRESULT hr = oleDoc->CreateView(inPlaceSite, NULL,
-                                    0, m_window->m_docView.GetRef());
-            if (hr != S_OK)
-                return E_FAIL;
-
-            m_window->m_docView->SetInPlaceSite(inPlaceSite);
-        };
-
-        m_window->m_docView->UIActivate(TRUE);
-        return S_OK;
-    };
-
-
-protected:
-    wxActiveX * m_window;
-
-    HDC m_hDCBuffer;
-    HWND m_hWndParent;
-
-    bool m_bSupportsWindowlessActivation;
-    bool m_bInPlaceLocked;
-    bool m_bInPlaceActive;
-    bool m_bUIActive;
-    bool m_bWindowless;
-
-    LCID m_nAmbientLocale;
-    COLORREF m_clrAmbientForeColor;
-    COLORREF m_clrAmbientBackColor;
-    bool m_bAmbientShowHatching;
-    bool m_bAmbientShowGrabHandles;
-    bool m_bAmbientAppearance;
-};
-
-DEFINE_OLE_TABLE(FrameSite)
-    OLE_INTERFACE(IID_IUnknown, IOleClientSite)
-    OLE_IINTERFACE(IOleClientSite)
-    OLE_INTERFACE(IID_IOleWindow, IOleInPlaceSite)
-    OLE_IINTERFACE(IOleInPlaceSite)
-    OLE_IINTERFACE(IOleInPlaceSiteEx)
-    OLE_IINTERFACE(IOleInPlaceUIWindow)
-    OLE_IINTERFACE(IOleInPlaceFrame)
-    OLE_IINTERFACE(IParseDisplayName)
-    OLE_IINTERFACE(IOleContainer)
-    OLE_IINTERFACE(IOleItemContainer)
-    OLE_IINTERFACE(IDispatch)
-    OLE_IINTERFACE(IOleCommandTarget)
-    OLE_IINTERFACE(IOleDocumentSite)
-    OLE_IINTERFACE(IAdviseSink)
-    OLE_IINTERFACE(IOleControlSite)
-END_OLE_TABLE;
-
-
-wxActiveX::wxActiveX(wxWindow * parent, REFIID iid, IUnknown* pUnk)
-    : m_realparent(parent)
-{
-    m_bAmbientUserMode = true;
-    m_docAdviseCookie = 0;
-    CreateActiveX(iid, pUnk);
-}
-
-wxActiveX::~wxActiveX()
-{
-    // disconnect connection points
-    if (m_oleInPlaceObject.Ok())
-    {
-        m_oleInPlaceObject->InPlaceDeactivate();
-        m_oleInPlaceObject->UIDeactivate();
-    }
-
-    if (m_oleObject.Ok())
-    {
-        if (m_docAdviseCookie != 0)
-            m_oleObject->Unadvise(m_docAdviseCookie);
-
-        m_oleObject->DoVerb(
-            OLEIVERB_HIDE, NULL, m_clientSite, 0, (HWND) GetHWND(), NULL);
-        m_oleObject->Close(OLECLOSE_NOSAVE);
-        m_oleObject->SetClientSite(NULL);
-    }
-}
-
-void wxActiveX::CreateActiveX(REFIID iid, IUnknown* pUnk)
-{
-    HRESULT hret;
-    hret = m_ActiveX.QueryInterface(iid, pUnk);
-    wxASSERT(SUCCEEDED(hret));
-
-    // FrameSite
-    FrameSite *frame = new FrameSite(m_realparent, this);
-    // oleClientSite
-    hret = m_clientSite.QueryInterface(
-        IID_IOleClientSite, (IDispatch *) frame);
-    wxASSERT(SUCCEEDED(hret));
-    // adviseSink
-    wxAutoIAdviseSink adviseSink(IID_IAdviseSink, (IDispatch *) frame);
-    wxASSERT(adviseSink.Ok());
-
-    // Get Dispatch interface
-    hret = m_Dispatch.QueryInterface(IID_IDispatch, m_ActiveX);
-
-    // Get IOleObject interface
-    hret = m_oleObject.QueryInterface(IID_IOleObject, m_ActiveX);
-    wxASSERT(SUCCEEDED(hret));
 
-    // get IViewObject Interface
-    hret = m_viewObject.QueryInterface(IID_IViewObject, m_ActiveX);
-    wxASSERT(SUCCEEDED(hret));
-
-    // document advise
-    m_docAdviseCookie = 0;
-    hret = m_oleObject->Advise(adviseSink, &m_docAdviseCookie);
-    m_oleObject->SetHostNames(L"wxActiveXContainer", NULL);
-    OleSetContainedObject(m_oleObject, TRUE);
-    OleRun(m_oleObject);
-
-
-    // Get IOleInPlaceObject interface
-    hret = m_oleInPlaceObject.QueryInterface(
-        IID_IOleInPlaceObject, m_ActiveX);
-    wxASSERT(SUCCEEDED(hret));
-
-    // status
-    DWORD dwMiscStatus;
-    m_oleObject->GetMiscStatus(DVASPECT_CONTENT, &dwMiscStatus);
-    wxASSERT(SUCCEEDED(hret));
-
-    // set client site first ?
-    if (dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST)
-        m_oleObject->SetClientSite(m_clientSite);
-
-
-    // stream init
-    wxAutoIPersistStreamInit
-        pPersistStreamInit(IID_IPersistStreamInit, m_oleObject);
-
-    if (pPersistStreamInit.Ok())
-    {
-        hret = pPersistStreamInit->InitNew();
-    }
-
-    if (! (dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST))
-        m_oleObject->SetClientSite(m_clientSite);
-
-
-    RECT posRect;
-    ::GetClientRect((HWND)m_realparent->GetHWND(), &posRect);
-
-    m_oleObjectHWND = 0;
-
-    if (m_oleInPlaceObject.Ok())
-    {
-        hret = m_oleInPlaceObject->GetWindow(&m_oleObjectHWND);
-        if (SUCCEEDED(hret))
-            ::SetActiveWindow(m_oleObjectHWND);
-    }
-
-
-    if (! (dwMiscStatus & OLEMISC_INVISIBLEATRUNTIME))
-    {
-        if (posRect.right > 0 && posRect.bottom > 0 &&
-            m_oleInPlaceObject.Ok())
-                m_oleInPlaceObject->SetObjectRects(&posRect, &posRect);
-
-        hret = m_oleObject->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL,
-            m_clientSite, 0, (HWND)m_realparent->GetHWND(), &posRect);
-        hret = m_oleObject->DoVerb(OLEIVERB_SHOW, 0, m_clientSite, 0,
-            (HWND)m_realparent->GetHWND(), &posRect);
-    }
-
-    if (! m_oleObjectHWND && m_oleInPlaceObject.Ok())
-    {
-        hret = m_oleInPlaceObject->GetWindow(&m_oleObjectHWND);
-    }
-
-    if (m_oleObjectHWND)
-    {
-        ::SetActiveWindow(m_oleObjectHWND);
-        ::ShowWindow(m_oleObjectHWND, SW_SHOW);
-
-        this->AssociateHandle(m_oleObjectHWND);
-        this->Reparent(m_realparent);
-
-        wxWindow* pWnd = m_realparent;
-        int id = m_realparent->GetId();
-
-        pWnd->Connect(id, wxEVT_SIZE,
-            wxSizeEventHandler(wxActiveX::OnSize), 0, this);
-        pWnd->Connect(id, wxEVT_SET_FOCUS,
-            wxFocusEventHandler(wxActiveX::OnSetFocus), 0, this);
-        pWnd->Connect(id, wxEVT_KILL_FOCUS,
-            wxFocusEventHandler(wxActiveX::OnKillFocus), 0, this);
-    }
-}
-
-#define HIMETRIC_PER_INCH   2540
-#define MAP_PIX_TO_LOGHIM(x,ppli)   MulDiv(HIMETRIC_PER_INCH, (x), (ppli))
-
-static void PixelsToHimetric(SIZEL &sz)
-{
-    static int logX = 0;
-    static int logY = 0;
-
-    if (logY == 0)
-    {
-        // initaliase
-        HDC dc = GetDC(NULL);
-        logX = GetDeviceCaps(dc, LOGPIXELSX);
-        logY = GetDeviceCaps(dc, LOGPIXELSY);
-        ReleaseDC(NULL, dc);
-    };
-
-#define HIMETRIC_INCH   2540
-#define CONVERT(x, logpixels)   MulDiv(HIMETRIC_INCH, (x), (logpixels))
-
-    sz.cx = CONVERT(sz.cx, logX);
-    sz.cy = CONVERT(sz.cy, logY);
-
-#undef CONVERT
-#undef HIMETRIC_INCH
-}
-
-
-void wxActiveX::OnSize(wxSizeEvent& event)
-{
-    int w, h;
-    GetParent()->GetClientSize(&w, &h);
-
-    RECT posRect;
-    posRect.left = 0;
-    posRect.top = 0;
-    posRect.right = w;
-    posRect.bottom = h;
-
-    if (w <= 0 && h <= 0)
-        return;
-
-    // extents are in HIMETRIC units
-    if (m_oleObject.Ok())
-    {
-        SIZEL sz = {w, h};
-        PixelsToHimetric(sz);
-
-        SIZEL sz2;
-
-        m_oleObject->GetExtent(DVASPECT_CONTENT, &sz2);
-        if (sz2.cx !=  sz.cx || sz.cy != sz2.cy)
-            m_oleObject->SetExtent(DVASPECT_CONTENT, &sz);
-    };
-
-    if (m_oleInPlaceObject.Ok())
-        m_oleInPlaceObject->SetObjectRects(&posRect, &posRect);
-
-    event.Skip();
-}
-
-void wxActiveX::OnPaint(wxPaintEvent& WXUNUSED(event))
-{
-    wxPaintDC dc(this);
-    // Draw only when control is windowless or deactivated
-    if (m_viewObject)
-    {
-        dc.BeginDrawing();
-        int w, h;
-        GetParent()->GetSize(&w, &h);
-        RECT posRect;
-        posRect.left = 0;
-        posRect.top = 0;
-        posRect.right = w;
-        posRect.bottom = h;
-
-        ::RedrawWindow(m_oleObjectHWND, NULL, NULL, RDW_INTERNALPAINT);
-        RECTL *prcBounds = (RECTL *) &posRect;
-        m_viewObject->Draw(DVASPECT_CONTENT, -1, NULL, NULL, NULL,
-            (HDC)dc.GetHDC(), prcBounds, NULL, NULL, 0);
-
-        dc.EndDrawing();
-    }
-
-//  We've got this one I think
-//    event.Skip();
-}
-
-void wxActiveX::OnSetFocus(wxFocusEvent& event)
-{
-    if (m_oleInPlaceActiveObject.Ok())
-        m_oleInPlaceActiveObject->OnFrameWindowActivate(TRUE);
-
-    event.Skip();
-}
-
-void wxActiveX::OnKillFocus(wxFocusEvent& event)
-{
-    if (m_oleInPlaceActiveObject.Ok())
-        m_oleInPlaceActiveObject->OnFrameWindowActivate(FALSE);
-
-    event.Skip();
-}
-
 //###########################################################################
 //
@@ -1873,5 +900,5 @@
     }
 
-    wxActiveX* m_pAX;
+    wxActiveXContainer* m_pAX;
     IActiveMovie* m_pAM;
     IMediaPlayer* m_pMP;
@@ -2314,4 +1341,5 @@
     ComponentInstance m_pMC;        //Movie Controller
 
+    friend class wxQTMediaEvtHandler;
     DECLARE_DYNAMIC_CLASS(wxQTMediaBackend)
 };
@@ -2325,4 +1353,10 @@
         m_qtb = qtb;
         m_hwnd = hwnd;
+
+        m_qtb->m_ctrl->Connect(m_qtb->m_ctrl->GetId(),
+            wxEVT_ERASE_BACKGROUND, 
+            wxEraseEventHandler(wxQTMediaEvtHandler::OnEraseBackground),
+            NULL, this
+                              );
     }
 
@@ -2699,5 +1733,5 @@
     //
     m_ctrl = ctrl;
-    m_pAX = new wxActiveX(ctrl,
+    m_pAX = new wxActiveXContainer(ctrl,
                 m_pMP ? IID_IMediaPlayer : IID_IActiveMovie,
                 m_pAM);
diff -bu2rN wxold\src\msw\ole/activex.cpp wxWidgets\src\msw\ole/activex.cpp
--- wxold\src\msw\ole/activex.cpp	1969-12-31 16:00:00.000000000 -0800
+++ wxWidgets\src\msw\ole/activex.cpp	2005-08-19 21:48:16.812478400 -0700
@@ -0,0 +1,824 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        msw/ole/activex.cpp
+// Purpose:     wxActiveXContainer implementation
+// Author:      Ryan Norton <wxprojects@comcast.net>, Lindsay Mathieson <???>
+// Modified by: 
+// Created:     11/07/04
+// RCS-ID:      $Id: mediactrl.cpp,v 1.55 2005/08/05 23:16:15 VZ Exp $
+// Copyright:   (c) 2003 Lindsay Mathieson, (c) 2005 Ryan Norton
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+//===========================================================================
+//  DECLARATIONS
+//===========================================================================
+
+//---------------------------------------------------------------------------
+// WX include
+//---------------------------------------------------------------------------
+#include "wx/wxprec.h"
+
+#include "wx/msw/ole/activex.h"
+
+
+
+
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//
+// wxActiveXContainer
+//
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#define DECLARE_OLE_UNKNOWN(cls)\
+    private:\
+    class TAutoInitInt\
+    {\
+        public:\
+        LONG l;\
+        TAutoInitInt() : l(0) {}\
+    };\
+    TAutoInitInt refCount, lockCount;\
+    static void _GetInterface(cls *self, REFIID iid, void **_interface, const char *&desc);\
+    public:\
+    LONG GetRefCount();\
+    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void ** ppvObject);\
+    ULONG STDMETHODCALLTYPE AddRef();\
+    ULONG STDMETHODCALLTYPE Release();\
+    ULONG STDMETHODCALLTYPE AddLock();\
+    ULONG STDMETHODCALLTYPE ReleaseLock()
+
+#define DEFINE_OLE_TABLE(cls)\
+    LONG cls::GetRefCount() {return refCount.l;}\
+    HRESULT STDMETHODCALLTYPE cls::QueryInterface(REFIID iid, void ** ppvObject)\
+    {\
+        if (! ppvObject)\
+        {\
+            return E_FAIL;\
+        };\
+        const char *desc = NULL;\
+        cls::_GetInterface(this, iid, ppvObject, desc);\
+        if (! *ppvObject)\
+        {\
+            return E_NOINTERFACE;\
+        };\
+        ((IUnknown * )(*ppvObject))->AddRef();\
+        return S_OK;\
+    };\
+    ULONG STDMETHODCALLTYPE cls::AddRef()\
+    {\
+        InterlockedIncrement(&refCount.l);\
+        return refCount.l;\
+    };\
+    ULONG STDMETHODCALLTYPE cls::Release()\
+    {\
+        if (refCount.l > 0)\
+        {\
+            InterlockedDecrement(&refCount.l);\
+            if (refCount.l == 0)\
+            {\
+                delete this;\
+                return 0;\
+            };\
+            return refCount.l;\
+        }\
+        else\
+            return 0;\
+    }\
+    ULONG STDMETHODCALLTYPE cls::AddLock()\
+    {\
+        InterlockedIncrement(&lockCount.l);\
+        return lockCount.l;\
+    };\
+    ULONG STDMETHODCALLTYPE cls::ReleaseLock()\
+    {\
+        if (lockCount.l > 0)\
+        {\
+            InterlockedDecrement(&lockCount.l);\
+            return lockCount.l;\
+        }\
+        else\
+            return 0;\
+    }\
+    DEFINE_OLE_BASE(cls)
+
+#define DEFINE_OLE_BASE(cls)\
+    void cls::_GetInterface(cls *self, REFIID iid, void **_interface, const char *&desc)\
+    {\
+        *_interface = NULL;\
+        desc = NULL;
+
+#define OLE_INTERFACE(_iid, _type)\
+    if (IsEqualIID(iid, _iid))\
+    {\
+        *_interface = (IUnknown *) (_type *) self;\
+        desc = # _iid;\
+        return;\
+    }
+
+#define OLE_IINTERFACE(_face) OLE_INTERFACE(IID_##_face, _face)
+
+#define OLE_INTERFACE_CUSTOM(func)\
+    if (func(self, iid, _interface, desc))\
+    {\
+        return;\
+    }
+
+#define END_OLE_TABLE\
+    }
+
+
+class FrameSite :
+    public IOleClientSite,
+    public IOleInPlaceSiteEx,
+    public IOleInPlaceFrame,
+    public IOleItemContainer,
+    public IDispatch,
+    public IOleCommandTarget,
+    public IOleDocumentSite,
+    public IAdviseSink,
+    public IOleControlSite
+{
+private:
+    DECLARE_OLE_UNKNOWN(FrameSite);
+
+public:
+    FrameSite(wxWindow * win, wxActiveXContainer * win2)
+    {
+        m_window = win2;
+        m_bSupportsWindowlessActivation = true;
+        m_bInPlaceLocked = false;
+        m_bUIActive = false;
+        m_bInPlaceActive = false;
+        m_bWindowless = false;
+
+        m_nAmbientLocale = 0;
+        m_clrAmbientForeColor = ::GetSysColor(COLOR_WINDOWTEXT);
+        m_clrAmbientBackColor = ::GetSysColor(COLOR_WINDOW);
+        m_bAmbientShowHatching = true;
+        m_bAmbientShowGrabHandles = true;
+        m_bAmbientAppearance = true;
+
+        m_hDCBuffer = NULL;
+        m_hWndParent = (HWND)win->GetHWND();
+    }
+    virtual ~FrameSite(){}
+    //***************************IDispatch*****************************
+    HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID, OLECHAR ** ,
+                                            unsigned int , LCID ,
+                                            DISPID * )
+    {   return E_NOTIMPL;   }
+    STDMETHOD(GetTypeInfo)(unsigned int, LCID, ITypeInfo **)
+    {   return E_NOTIMPL;   }
+    HRESULT STDMETHODCALLTYPE GetTypeInfoCount(unsigned int *)
+    {   return E_NOTIMPL;   }
+    HRESULT STDMETHODCALLTYPE Invoke(DISPID dispIdMember, REFIID, LCID,
+                            WORD wFlags, DISPPARAMS *,
+                            VARIANT * pVarResult, EXCEPINFO *,
+                            unsigned int *)
+    {
+        if (!(wFlags & DISPATCH_PROPERTYGET))
+            return S_OK;
+
+        if (pVarResult == NULL)
+            return E_INVALIDARG;
+
+        //The most common case is boolean, use as an initial type
+        V_VT(pVarResult) = VT_BOOL;
+
+        switch (dispIdMember)
+        {
+            case DISPID_AMBIENT_MESSAGEREFLECT:
+                V_BOOL(pVarResult)= FALSE;
+                return S_OK;
+
+            case DISPID_AMBIENT_DISPLAYASDEFAULT:
+                V_BOOL(pVarResult)= TRUE;
+                return S_OK;
+
+            case DISPID_AMBIENT_OFFLINEIFNOTCONNECTED:
+                V_BOOL(pVarResult) = TRUE;
+                return S_OK;
+
+            case DISPID_AMBIENT_SILENT:
+                V_BOOL(pVarResult)= TRUE;
+                return S_OK;
+
+            case DISPID_AMBIENT_APPEARANCE:
+                pVarResult->vt = VT_BOOL;
+                pVarResult->boolVal = m_bAmbientAppearance;
+                break;
+
+            case DISPID_AMBIENT_FORECOLOR:
+                pVarResult->vt = VT_I4;
+                pVarResult->lVal = (long) m_clrAmbientForeColor;
+                break;
+
+            case DISPID_AMBIENT_BACKCOLOR:
+                pVarResult->vt = VT_I4;
+                pVarResult->lVal = (long) m_clrAmbientBackColor;
+                break;
+
+            case DISPID_AMBIENT_LOCALEID:
+                pVarResult->vt = VT_I4;
+                pVarResult->lVal = (long) m_nAmbientLocale;
+                break;
+
+            case DISPID_AMBIENT_USERMODE:
+                pVarResult->vt = VT_BOOL;
+                pVarResult->boolVal = m_window->m_bAmbientUserMode;
+                break;
+
+            case DISPID_AMBIENT_SHOWGRABHANDLES:
+                pVarResult->vt = VT_BOOL;
+                pVarResult->boolVal = m_bAmbientShowGrabHandles;
+                break;
+
+            case DISPID_AMBIENT_SHOWHATCHING:
+                pVarResult->vt = VT_BOOL;
+                pVarResult->boolVal = m_bAmbientShowHatching;
+                break;
+
+            default:
+                return DISP_E_MEMBERNOTFOUND;
+        }
+
+        return S_OK;
+    }
+
+    //**************************IOleWindow***************************
+    HRESULT STDMETHODCALLTYPE GetWindow(HWND * phwnd)
+    {
+        if (phwnd == NULL)
+            return E_INVALIDARG;
+        (*phwnd) = m_hWndParent;
+        return S_OK;
+    }
+    HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL)
+    {return S_OK;}
+    //**************************IOleInPlaceUIWindow*****************
+    HRESULT STDMETHODCALLTYPE GetBorder(LPRECT lprectBorder)
+    {
+        if (lprectBorder == NULL)
+            return E_INVALIDARG;
+        return INPLACE_E_NOTOOLSPACE;
+    }
+    HRESULT STDMETHODCALLTYPE RequestBorderSpace(LPCBORDERWIDTHS pborderwidths)
+    {
+        if (pborderwidths == NULL)
+            return E_INVALIDARG;
+        return INPLACE_E_NOTOOLSPACE;
+    }
+    HRESULT STDMETHODCALLTYPE SetBorderSpace(LPCBORDERWIDTHS)
+    {return S_OK;}
+    HRESULT STDMETHODCALLTYPE SetActiveObject(
+        IOleInPlaceActiveObject *pActiveObject, LPCOLESTR)
+    {
+        if (pActiveObject)
+            pActiveObject->AddRef();
+
+        m_window->m_oleInPlaceActiveObject = pActiveObject;
+        return S_OK;
+    }
+
+    //********************IOleInPlaceFrame************************
+
+    STDMETHOD(InsertMenus)(HMENU, LPOLEMENUGROUPWIDTHS){return S_OK;}
+    STDMETHOD(SetMenu)(HMENU, HOLEMENU, HWND){  return S_OK;}
+    STDMETHOD(RemoveMenus)(HMENU){return S_OK;}
+    STDMETHOD(SetStatusText)(LPCOLESTR){ return S_OK;}
+    HRESULT STDMETHODCALLTYPE EnableModeless(BOOL){return S_OK;}
+    HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG lpmsg, WORD)
+    {
+        // TODO: send an event with this id
+        if (m_window->m_oleInPlaceActiveObject.Ok())
+            m_window->m_oleInPlaceActiveObject->TranslateAccelerator(lpmsg);
+        return S_FALSE;
+    }
+
+    //*******************IOleInPlaceSite**************************
+    HRESULT STDMETHODCALLTYPE CanInPlaceActivate(){return S_OK;}
+    HRESULT STDMETHODCALLTYPE OnInPlaceActivate()
+    {   m_bInPlaceActive = true;    return S_OK;    }
+    HRESULT STDMETHODCALLTYPE OnUIActivate()
+    {   m_bUIActive = true;         return S_OK;    }
+    HRESULT STDMETHODCALLTYPE GetWindowContext(IOleInPlaceFrame **ppFrame,
+                                        IOleInPlaceUIWindow **ppDoc,
+                                        LPRECT lprcPosRect,
+                                        LPRECT lprcClipRect,
+                                        LPOLEINPLACEFRAMEINFO lpFrameInfo)
+    {
+        if (ppFrame == NULL || ppDoc == NULL || lprcPosRect == NULL ||
+            lprcClipRect == NULL || lpFrameInfo == NULL)
+        {
+            if (ppFrame != NULL)
+                (*ppFrame) = NULL;
+            if (ppDoc != NULL)
+                (*ppDoc) = NULL;
+            return E_INVALIDARG;
+        }
+
+        HRESULT hr = QueryInterface(IID_IOleInPlaceFrame, (void **) ppFrame);
+        if (! SUCCEEDED(hr))
+        {
+            return E_UNEXPECTED;
+        };
+
+        hr = QueryInterface(IID_IOleInPlaceUIWindow, (void **) ppDoc);
+        if (! SUCCEEDED(hr))
+        {
+            (*ppFrame)->Release();
+            *ppFrame = NULL;
+            return E_UNEXPECTED;
+        };
+
+        RECT rect;
+        ::GetClientRect(m_hWndParent, &rect);
+        if (lprcPosRect)
+        {
+            lprcPosRect->left = lprcPosRect->top = 0;
+            lprcPosRect->right = rect.right;
+            lprcPosRect->bottom = rect.bottom;
+        };
+        if (lprcClipRect)
+        {
+            lprcClipRect->left = lprcClipRect->top = 0;
+            lprcClipRect->right = rect.right;
+            lprcClipRect->bottom = rect.bottom;
+        };
+
+        memset(lpFrameInfo, 0, sizeof(OLEINPLACEFRAMEINFO));
+        lpFrameInfo->cb = sizeof(OLEINPLACEFRAMEINFO);
+        lpFrameInfo->hwndFrame = m_hWndParent;
+
+        return S_OK;
+    }
+    HRESULT STDMETHODCALLTYPE Scroll(SIZE){return S_OK;}
+    HRESULT STDMETHODCALLTYPE OnUIDeactivate(BOOL)
+    {   m_bUIActive = false;         return S_OK;    }
+    HRESULT STDMETHODCALLTYPE OnInPlaceDeactivate()
+    {   m_bInPlaceActive = false;    return S_OK;    }
+    HRESULT STDMETHODCALLTYPE DiscardUndoState(){return S_OK;}
+    HRESULT STDMETHODCALLTYPE DeactivateAndUndo(){return S_OK; }
+    HRESULT STDMETHODCALLTYPE OnPosRectChange(LPCRECT lprcPosRect)
+    {
+        if (m_window->m_oleInPlaceObject.Ok() && lprcPosRect)
+        {
+            m_window->m_oleInPlaceObject->SetObjectRects(
+                lprcPosRect, lprcPosRect);
+        }
+        return S_OK;
+    }
+    //*************************IOleInPlaceSiteEx***********************
+    HRESULT STDMETHODCALLTYPE OnInPlaceActivateEx(BOOL * pfNoRedraw, DWORD)
+    {
+        OleLockRunning(m_window->m_ActiveX, TRUE, FALSE);
+        if (pfNoRedraw)
+            (*pfNoRedraw) = FALSE;
+        return S_OK;
+    }
+
+    HRESULT STDMETHODCALLTYPE OnInPlaceDeactivateEx(BOOL)
+    {
+        OleLockRunning(m_window->m_ActiveX, FALSE, FALSE);
+        return S_OK;
+    }
+    STDMETHOD(RequestUIActivate)(){ return S_OK;}
+    //*************************IOleClientSite**************************
+    HRESULT STDMETHODCALLTYPE SaveObject(){return S_OK;}
+    const char *OleGetMonikerToStr(DWORD dwAssign)
+    {
+        switch (dwAssign)
+        {
+        case OLEGETMONIKER_ONLYIFTHERE  : return "OLEGETMONIKER_ONLYIFTHERE";
+        case OLEGETMONIKER_FORCEASSIGN  : return "OLEGETMONIKER_FORCEASSIGN";
+        case OLEGETMONIKER_UNASSIGN     : return "OLEGETMONIKER_UNASSIGN";
+        case OLEGETMONIKER_TEMPFORUSER  : return "OLEGETMONIKER_TEMPFORUSER";
+        default                         : return "Bad Enum";
+        };
+    };
+
+    const char *OleGetWhicMonikerStr(DWORD dwWhichMoniker)
+    {
+        switch(dwWhichMoniker)
+        {
+        case OLEWHICHMK_CONTAINER   : return "OLEWHICHMK_CONTAINER";
+        case OLEWHICHMK_OBJREL      : return "OLEWHICHMK_OBJREL";
+        case OLEWHICHMK_OBJFULL     : return "OLEWHICHMK_OBJFULL";
+        default                     : return "Bad Enum";
+        };
+    };
+    STDMETHOD(GetMoniker)(DWORD, DWORD, IMoniker **){return E_FAIL;}
+    HRESULT STDMETHODCALLTYPE GetContainer(LPOLECONTAINER * ppContainer)
+    {
+        if (ppContainer == NULL)
+            return E_INVALIDARG;
+        HRESULT hr = QueryInterface(
+            IID_IOleContainer, (void**)(ppContainer));
+        wxASSERT(SUCCEEDED(hr));
+        return hr;
+    }
+    HRESULT STDMETHODCALLTYPE ShowObject()
+    {
+        if (m_window->m_oleObjectHWND)
+            ::ShowWindow(m_window->m_oleObjectHWND, SW_SHOW);
+        return S_OK;
+    }
+    STDMETHOD(OnShowWindow)(BOOL){return S_OK;}
+    STDMETHOD(RequestNewObjectLayout)(){return E_NOTIMPL;}
+    //********************IParseDisplayName***************************
+    HRESULT STDMETHODCALLTYPE ParseDisplayName(
+        IBindCtx *, LPOLESTR, ULONG *, IMoniker **){return E_NOTIMPL;}
+    //********************IOleContainer*******************************
+    STDMETHOD(EnumObjects)(DWORD, IEnumUnknown **){return E_NOTIMPL;}
+    HRESULT STDMETHODCALLTYPE LockContainer(BOOL){return S_OK;}
+    //********************IOleItemContainer***************************
+    HRESULT STDMETHODCALLTYPE
+    #ifdef _UNICODE
+    GetObjectW
+    #else
+    GetObjectA
+    #endif
+    (LPOLESTR pszItem, DWORD, IBindCtx *, REFIID, void ** ppvObject)
+    {
+        if (pszItem == NULL || ppvObject == NULL)
+            return E_INVALIDARG;
+        *ppvObject = NULL;
+        return MK_E_NOOBJECT;
+    }
+    HRESULT STDMETHODCALLTYPE GetObjectStorage(
+        LPOLESTR pszItem, IBindCtx * , REFIID, void ** ppvStorage)
+    {
+        if (pszItem == NULL || ppvStorage == NULL)
+            return E_INVALIDARG;
+        *ppvStorage = NULL;
+        return MK_E_NOOBJECT;
+    }
+    HRESULT STDMETHODCALLTYPE IsRunning(LPOLESTR pszItem)
+    {
+        if (pszItem == NULL)
+            return E_INVALIDARG;
+        return MK_E_NOOBJECT;
+    }
+    //***********************IOleControlSite*****************************
+    HRESULT STDMETHODCALLTYPE OnControlInfoChanged()
+    {return S_OK;}
+    HRESULT STDMETHODCALLTYPE LockInPlaceActive(BOOL fLock)
+    {
+        m_bInPlaceLocked = (fLock) ? true : false;
+        return S_OK;
+    }
+    HRESULT STDMETHODCALLTYPE GetExtendedControl(IDispatch **)
+    {return E_NOTIMPL;}
+    HRESULT STDMETHODCALLTYPE TransformCoords(
+        POINTL * pPtlHimetric, POINTF * pPtfContainer, DWORD)
+    {
+        if (pPtlHimetric == NULL || pPtfContainer == NULL)
+            return E_INVALIDARG;
+        return E_NOTIMPL;
+    }
+    HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG, DWORD)
+    {return E_NOTIMPL;}
+    HRESULT STDMETHODCALLTYPE OnFocus(BOOL){return S_OK;}
+    HRESULT STDMETHODCALLTYPE ShowPropertyFrame(){return E_NOTIMPL;}
+    //**************************IOleCommandTarget***********************
+    HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *, ULONG cCmds,
+                                OLECMD prgCmds[], OLECMDTEXT *)
+    {
+        if (prgCmds == NULL) return E_INVALIDARG;
+        for (ULONG nCmd = 0; nCmd < cCmds; nCmd++)
+        {
+            // unsupported by default
+            prgCmds[nCmd].cmdf = 0;
+        }
+        return OLECMDERR_E_UNKNOWNGROUP;
+    }
+
+    HRESULT STDMETHODCALLTYPE Exec(const GUID *, DWORD,
+                            DWORD, VARIANTARG *, VARIANTARG *)
+    {return OLECMDERR_E_NOTSUPPORTED;}
+
+    //**********************IAdviseSink************************************
+    void STDMETHODCALLTYPE OnDataChange(FORMATETC *, STGMEDIUM *) {}
+    void STDMETHODCALLTYPE OnViewChange(DWORD, LONG) {}
+    void STDMETHODCALLTYPE OnRename(IMoniker *){}
+    void STDMETHODCALLTYPE OnSave(){}
+    void STDMETHODCALLTYPE OnClose(){}
+
+    //**********************IOleDocumentSite***************************
+    HRESULT STDMETHODCALLTYPE ActivateMe(
+        IOleDocumentView __RPC_FAR *pViewToActivate)
+    {
+        wxAutoIOleInPlaceSite inPlaceSite(
+            IID_IOleInPlaceSite, (IDispatch *) this);
+        if (!inPlaceSite.Ok())
+            return E_FAIL;
+
+        if (pViewToActivate)
+        {
+            m_window->m_docView = pViewToActivate;
+            m_window->m_docView->SetInPlaceSite(inPlaceSite);
+        }
+        else
+        {
+            wxAutoIOleDocument oleDoc(
+                IID_IOleDocument, m_window->m_oleObject);
+            if (! oleDoc.Ok())
+                return E_FAIL;
+
+            HRESULT hr = oleDoc->CreateView(inPlaceSite, NULL,
+                                    0, m_window->m_docView.GetRef());
+            if (hr != S_OK)
+                return E_FAIL;
+
+            m_window->m_docView->SetInPlaceSite(inPlaceSite);
+        };
+
+        m_window->m_docView->UIActivate(TRUE);
+        return S_OK;
+    };
+
+
+protected:
+    wxActiveXContainer * m_window;
+
+    HDC m_hDCBuffer;
+    HWND m_hWndParent;
+
+    bool m_bSupportsWindowlessActivation;
+    bool m_bInPlaceLocked;
+    bool m_bInPlaceActive;
+    bool m_bUIActive;
+    bool m_bWindowless;
+
+    LCID m_nAmbientLocale;
+    COLORREF m_clrAmbientForeColor;
+    COLORREF m_clrAmbientBackColor;
+    bool m_bAmbientShowHatching;
+    bool m_bAmbientShowGrabHandles;
+    bool m_bAmbientAppearance;
+};
+
+DEFINE_OLE_TABLE(FrameSite)
+    OLE_INTERFACE(IID_IUnknown, IOleClientSite)
+    OLE_IINTERFACE(IOleClientSite)
+    OLE_INTERFACE(IID_IOleWindow, IOleInPlaceSite)
+    OLE_IINTERFACE(IOleInPlaceSite)
+    OLE_IINTERFACE(IOleInPlaceSiteEx)
+    OLE_IINTERFACE(IOleInPlaceUIWindow)
+    OLE_IINTERFACE(IOleInPlaceFrame)
+    OLE_IINTERFACE(IParseDisplayName)
+    OLE_IINTERFACE(IOleContainer)
+    OLE_IINTERFACE(IOleItemContainer)
+    OLE_IINTERFACE(IDispatch)
+    OLE_IINTERFACE(IOleCommandTarget)
+    OLE_IINTERFACE(IOleDocumentSite)
+    OLE_IINTERFACE(IAdviseSink)
+    OLE_IINTERFACE(IOleControlSite)
+END_OLE_TABLE;
+
+
+wxActiveXContainer::wxActiveXContainer(wxWindow * parent, REFIID iid, IUnknown* pUnk)
+    : m_realparent(parent)
+{
+    m_bAmbientUserMode = true;
+    m_docAdviseCookie = 0;
+    CreateActiveX(iid, pUnk);
+}
+
+wxActiveXContainer::~wxActiveXContainer()
+{
+    // disconnect connection points
+    if (m_oleInPlaceObject.Ok())
+    {
+        m_oleInPlaceObject->InPlaceDeactivate();
+        m_oleInPlaceObject->UIDeactivate();
+    }
+
+    if (m_oleObject.Ok())
+    {
+        if (m_docAdviseCookie != 0)
+            m_oleObject->Unadvise(m_docAdviseCookie);
+
+        m_oleObject->DoVerb(
+            OLEIVERB_HIDE, NULL, m_clientSite, 0, (HWND) GetHWND(), NULL);
+        m_oleObject->Close(OLECLOSE_NOSAVE);
+        m_oleObject->SetClientSite(NULL);
+    }
+}
+
+void wxActiveXContainer::CreateActiveX(REFIID iid, IUnknown* pUnk)
+{
+    HRESULT hret;
+    hret = m_ActiveX.QueryInterface(iid, pUnk);
+    wxASSERT(SUCCEEDED(hret));
+
+    // FrameSite
+    FrameSite *frame = new FrameSite(m_realparent, this);
+    // oleClientSite
+    hret = m_clientSite.QueryInterface(
+        IID_IOleClientSite, (IDispatch *) frame);
+    wxASSERT(SUCCEEDED(hret));
+    // adviseSink
+    wxAutoIAdviseSink adviseSink(IID_IAdviseSink, (IDispatch *) frame);
+    wxASSERT(adviseSink.Ok());
+
+    // Get Dispatch interface
+    hret = m_Dispatch.QueryInterface(IID_IDispatch, m_ActiveX);
+
+    // Get IOleObject interface
+    hret = m_oleObject.QueryInterface(IID_IOleObject, m_ActiveX);
+    wxASSERT(SUCCEEDED(hret));
+
+    // get IViewObject Interface
+    hret = m_viewObject.QueryInterface(IID_IViewObject, m_ActiveX);
+    wxASSERT(SUCCEEDED(hret));
+
+    // document advise
+    m_docAdviseCookie = 0;
+    hret = m_oleObject->Advise(adviseSink, &m_docAdviseCookie);
+    m_oleObject->SetHostNames(L"wxActiveXContainer", NULL);
+    OleSetContainedObject(m_oleObject, TRUE);
+    OleRun(m_oleObject);
+
+
+    // Get IOleInPlaceObject interface
+    hret = m_oleInPlaceObject.QueryInterface(
+        IID_IOleInPlaceObject, m_ActiveX);
+    wxASSERT(SUCCEEDED(hret));
+
+    // status
+    DWORD dwMiscStatus;
+    m_oleObject->GetMiscStatus(DVASPECT_CONTENT, &dwMiscStatus);
+    wxASSERT(SUCCEEDED(hret));
+
+    // set client site first ?
+    if (dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST)
+        m_oleObject->SetClientSite(m_clientSite);
+
+
+    // stream init
+    wxAutoIPersistStreamInit
+        pPersistStreamInit(IID_IPersistStreamInit, m_oleObject);
+
+    if (pPersistStreamInit.Ok())
+    {
+        hret = pPersistStreamInit->InitNew();
+    }
+
+    if (! (dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST))
+        m_oleObject->SetClientSite(m_clientSite);
+
+
+    RECT posRect;
+    ::GetClientRect((HWND)m_realparent->GetHWND(), &posRect);
+
+    m_oleObjectHWND = 0;
+
+    if (m_oleInPlaceObject.Ok())
+    {
+        hret = m_oleInPlaceObject->GetWindow(&m_oleObjectHWND);
+        if (SUCCEEDED(hret))
+            ::SetActiveWindow(m_oleObjectHWND);
+    }
+
+
+    if (! (dwMiscStatus & OLEMISC_INVISIBLEATRUNTIME))
+    {
+        if (posRect.right > 0 && posRect.bottom > 0 &&
+            m_oleInPlaceObject.Ok())
+                m_oleInPlaceObject->SetObjectRects(&posRect, &posRect);
+
+        hret = m_oleObject->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL,
+            m_clientSite, 0, (HWND)m_realparent->GetHWND(), &posRect);
+        hret = m_oleObject->DoVerb(OLEIVERB_SHOW, 0, m_clientSite, 0,
+            (HWND)m_realparent->GetHWND(), &posRect);
+    }
+
+    if (! m_oleObjectHWND && m_oleInPlaceObject.Ok())
+    {
+        hret = m_oleInPlaceObject->GetWindow(&m_oleObjectHWND);
+    }
+
+    if (m_oleObjectHWND)
+    {
+        ::SetActiveWindow(m_oleObjectHWND);
+        ::ShowWindow(m_oleObjectHWND, SW_SHOW);
+
+        this->AssociateHandle(m_oleObjectHWND);
+        this->Reparent(m_realparent);
+
+        wxWindow* pWnd = m_realparent;
+        int id = m_realparent->GetId();
+
+        pWnd->Connect(id, wxEVT_SIZE,
+            wxSizeEventHandler(wxActiveXContainer::OnSize), 0, this);
+        pWnd->Connect(id, wxEVT_SET_FOCUS,
+            wxFocusEventHandler(wxActiveXContainer::OnSetFocus), 0, this);
+        pWnd->Connect(id, wxEVT_KILL_FOCUS,
+            wxFocusEventHandler(wxActiveXContainer::OnKillFocus), 0, this);
+    }
+}
+
+#define HIMETRIC_PER_INCH   2540
+#define MAP_PIX_TO_LOGHIM(x,ppli)   MulDiv(HIMETRIC_PER_INCH, (x), (ppli))
+
+static void PixelsToHimetric(SIZEL &sz)
+{
+    static int logX = 0;
+    static int logY = 0;
+
+    if (logY == 0)
+    {
+        // initaliase
+        HDC dc = GetDC(NULL);
+        logX = GetDeviceCaps(dc, LOGPIXELSX);
+        logY = GetDeviceCaps(dc, LOGPIXELSY);
+        ReleaseDC(NULL, dc);
+    };
+
+#define HIMETRIC_INCH   2540
+#define CONVERT(x, logpixels)   MulDiv(HIMETRIC_INCH, (x), (logpixels))
+
+    sz.cx = CONVERT(sz.cx, logX);
+    sz.cy = CONVERT(sz.cy, logY);
+
+#undef CONVERT
+#undef HIMETRIC_INCH
+}
+
+
+void wxActiveXContainer::OnSize(wxSizeEvent& event)
+{
+    int w, h;
+    GetParent()->GetClientSize(&w, &h);
+
+    RECT posRect;
+    posRect.left = 0;
+    posRect.top = 0;
+    posRect.right = w;
+    posRect.bottom = h;
+
+    if (w <= 0 && h <= 0)
+        return;
+
+    // extents are in HIMETRIC units
+    if (m_oleObject.Ok())
+    {
+        SIZEL sz = {w, h};
+        PixelsToHimetric(sz);
+
+        SIZEL sz2;
+
+        m_oleObject->GetExtent(DVASPECT_CONTENT, &sz2);
+        if (sz2.cx !=  sz.cx || sz.cy != sz2.cy)
+            m_oleObject->SetExtent(DVASPECT_CONTENT, &sz);
+    };
+
+    if (m_oleInPlaceObject.Ok())
+        m_oleInPlaceObject->SetObjectRects(&posRect, &posRect);
+
+    event.Skip();
+}
+
+void wxActiveXContainer::OnPaint(wxPaintEvent& WXUNUSED(event))
+{
+    wxPaintDC dc(this);
+    // Draw only when control is windowless or deactivated
+    if (m_viewObject)
+    {
+        dc.BeginDrawing();
+        int w, h;
+        GetParent()->GetSize(&w, &h);
+        RECT posRect;
+        posRect.left = 0;
+        posRect.top = 0;
+        posRect.right = w;
+        posRect.bottom = h;
+
+        ::RedrawWindow(m_oleObjectHWND, NULL, NULL, RDW_INTERNALPAINT);
+        RECTL *prcBounds = (RECTL *) &posRect;
+        m_viewObject->Draw(DVASPECT_CONTENT, -1, NULL, NULL, NULL,
+            (HDC)dc.GetHDC(), prcBounds, NULL, NULL, 0);
+
+        dc.EndDrawing();
+    }
+
+//  We've got this one I think
+//    event.Skip();
+}
+
+void wxActiveXContainer::OnSetFocus(wxFocusEvent& event)
+{
+    if (m_oleInPlaceActiveObject.Ok())
+        m_oleInPlaceActiveObject->OnFrameWindowActivate(TRUE);
+
+    event.Skip();
+}
+
+void wxActiveXContainer::OnKillFocus(wxFocusEvent& event)
+{
+    if (m_oleInPlaceActiveObject.Ok())
+        m_oleInPlaceActiveObject->OnFrameWindowActivate(FALSE);
+
+    event.Skip();
+}

Index: src/mac/carbon/mediactrl.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/mac/carbon/mediactrl.cpp,v
retrieving revision 1.17
diff -b -u -2 -r1.17 mediactrl.cpp
--- src/mac/carbon/mediactrl.cpp	2005/07/28 23:56:54	1.17
+++ src/mac/carbon/mediactrl.cpp	2005/08/21 05:16:26
@@ -6,8 +6,13 @@
 // Created:     11/07/04
 // RCS-ID:      $Id: mediactrl.cpp,v 1.17 2005/07/28 23:56:54 VZ Exp $
-// Copyright:   (c) 2004-2005 Ryan Norton, portions (c) 2004 Kevin Olliver
+// Copyright:   (c) 2004-2005 Ryan Norton
 // Licence:     wxWindows licence
 /////////////////////////////////////////////////////////////////////////////
 
+//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+// There are several known bugs with CreateMovieControl
+// on systems > 10.2 - see main.c of QTCarbonShell sample for details
+//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
 //===========================================================================
 //  DECLARATIONS
@@ -44,5 +49,6 @@
 //---------------------------------------------------------------------------
 #ifndef wxUSE_CREATEMOVIECONTROL
-#    if defined( __WXMAC_OSX__ ) && ( MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_2 )
+#    if defined( __WXMAC_OSX__ ) && \
+      ( MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_2 )
 #        define wxUSE_CREATEMOVIECONTROL 1
 #    else
@@ -51,4 +57,10 @@
 #endif
 
+//---------------------------------------------------------------------------
+// Height and Width of movie controller in the movie control
+//---------------------------------------------------------------------------
+#define wxMCWIDTH   320
+#define wxMCHEIGHT  16
+
 //===========================================================================
 //  BACKEND DECLARATIONS
@@ -75,18 +87,7 @@
 #endif
 
-//Determines whether version 4 of QT is installed (Pretty much for classic only)
-Boolean _wxIsQuickTime4Installed (void)
+class WXDLLIMPEXP_MEDIA wxQTMediaBackend : public wxMediaBackendCommonBase
 {
-    short error;
-    long result;
-
-    error = Gestalt (gestaltQuickTime, &result);
-    return (error == noErr) && (((result >> 16) & 0xffff) >= 0x0400);
-}
-
-class WXDLLIMPEXP_MEDIA wxQTMediaBackend : public wxMediaBackend
-{
 public:
-
     wxQTMediaBackend();
     ~wxQTMediaBackend();
@@ -124,19 +125,79 @@
     void Cleanup();
     void FinishLoad();
+
+    virtual bool ShowPlayerControls(wxMediaCtrlPlayerControls flags);
+        
+
+    //
+    //  ------  Implementation from now on  --------
+    //
+    void DoLoadBestSize();
+    void DoSetControllerVisible(wxMediaCtrlPlayerControls flags);
+
+    //TODO: Last param actually long - does this work on 64bit machines?
+    static Boolean MCFilterProc (MovieController theController,
+        short action, void *params, long refCon);
 
-    wxSize m_bestSize;              //Original movie size
+#if wxUSE_CREATEMOVIECONTROL
+    void DoCreateMovieControl();    
+#else
+    Boolean IsQuickTime4Installed();
+    void DoNewMovieController();
+    static void PPRMProc (Movie theMovie, OSErr theErr, void* theRefCon);
+#endif
+
+    wxSize m_bestSize;          // Original movie size
 #ifdef __WXMAC_OSX__
-    struct MovieType** m_movie;     //QT Movie handle/instance
+    struct MovieType** m_movie; // QT Movie handle/instance
 #else
-    Movie m_movie ;
+    Movie m_movie;              // Movie instance
 #endif
-    wxControl* m_ctrl;              //Parent control
-    bool m_bVideo;                  //Whether or not we have video
-    class _wxQTTimer* m_timer;      //Timer for streaming the movie
+    bool m_bPlaying;            // Whether media is playing or not
+    class wxTimer* m_timer;     // Timer for streaming the movie
+    MovieController m_mc;       // MovieController instance
+    wxMediaCtrlPlayerControls m_interfaceflags; // Saved interface flags
+#if !wxUSE_CREATEMOVIECONTROL
+    EventHandlerRef m_pEventHandlerRef; // Event handler to cleanup
 
+    friend class wxQTMediaEvtHandler;
+#endif    
     DECLARE_DYNAMIC_CLASS(wxQTMediaBackend)
 };
 
+#if !wxUSE_CREATEMOVIECONTROL
+// helper to hijack background erasing for the QT window
+class WXDLLIMPEXP_MEDIA wxQTMediaEvtHandler : public wxEvtHandler
+{
+public:
+    wxQTMediaEvtHandler(wxQTMediaBackend *qtb)
+    {
+        m_qtb = qtb;
+
+        qtb->m_ctrl->Connect(qtb->m_ctrl->GetId(), wxEVT_ERASE_BACKGROUND,
+            wxEraseEventHandler(wxQTMediaEvtHandler::OnEraseBackground),
+            NULL, this);
+    }
+
+    void OnEraseBackground(wxEraseEvent& event);
+
+private:
+    wxQTMediaBackend *m_qtb;
+
+    DECLARE_NO_COPY_CLASS(wxQTMediaEvtHandler)
+};
+
+// Window event handler
+static pascal OSStatus wxQTMediaWindowEventHandler(
+                                    EventHandlerCallRef inHandlerCallRef, 
+                                    EventRef inEvent, void *inUserData);
+DEFINE_ONE_SHOT_HANDLER_GETTER( wxQTMediaWindowEventHandler );
+
+#endif
 
+//===========================================================================
+//  IMPLEMENTATION
+//===========================================================================
+
+
 //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 //
@@ -147,56 +208,90 @@
 IMPLEMENT_DYNAMIC_CLASS(wxQTMediaBackend, wxMediaBackend);
 
-//Time between timer calls
-#define MOVIE_DELAY 100
+//Time between timer calls - this is the Apple recommondation to the TCL
+//team I believe
+#define MOVIE_DELAY 20
 
-// --------------------------------------------------------------------------
-//          wxQTTimer - Handle Asyncronous Playing
-// --------------------------------------------------------------------------
-class _wxQTTimer : public wxTimer
+//---------------------------------------------------------------------------
+//          wxQTMediaLoadTimer
+//
+//  QT, esp. QT for Windows is very picky about how you go about
+//  async loading.  If you were to go through a Windows message loop
+//  or a MoviesTask or both and then check the movie load state
+//  it would still return 1000 (loading)... even (pre)prerolling doesn't
+//  help.  However, making a load timer like this works
+//---------------------------------------------------------------------------
+class wxQTMediaLoadTimer : public wxTimer
 {
 public:
-    _wxQTTimer(Movie movie, wxQTMediaBackend* parent) :
-        m_movie(movie), m_bPaused(false), m_parent(parent)
-    {
-    }
+    wxQTMediaLoadTimer(Movie movie, wxQTMediaBackend* parent) :
+      m_movie(movie), m_parent(parent) {}
 
-    ~_wxQTTimer()
+    void Notify()
+    {
+        //Note that the CreateMovieControl variety performs
+        //its own custom idleing
+#if !wxUSE_CREATEMOVIECONTROL
+        ::MCIdle(m_parent->m_mc);
+#endif
+        //kMovieLoadStatePlayable is not enough on MAC
+        //- it plays, but IsMovieDone might return true (!)
+        //sure we need to wait until kMovieLoadStatePlaythroughOK
+        if(::GetMovieLoadState(m_movie) >= 20000)
     {
+            m_parent->FinishLoad();
+            delete this;
     }
+    }
 
-    bool GetPaused() {return m_bPaused;}
-    void SetPaused(bool bPaused) {m_bPaused = bPaused;}
+protected:
+    Movie m_movie;                  //Our movie instance
+    wxQTMediaBackend* m_parent;     //Backend pointer
+};
 
-    //-----------------------------------------------------------------------
-    // _wxQTTimer::Notify
-    //
-    // 1) Checks to see if the movie is done, and if not continues
-    //    streaming the movie
-    // 2) Sends the wxEVT_MEDIA_STOP event if we have reached the end of
-    //    the movie.
-    //-----------------------------------------------------------------------
+// --------------------------------------------------------------------------
+//          wxQTMediaPlayTimer - Handle Asyncronous Playing
+//
+// 1) Checks to see if the movie is done, and if not continues
+//    streaming the movie
+// 2) Sends the wxEVT_MEDIA_STOP event if we have reached the end of
+//    the movie.
+// --------------------------------------------------------------------------
+class wxQTMediaPlayTimer : public wxTimer
+{
+public:
+    wxQTMediaPlayTimer(Movie movie, wxQTMediaBackend* parent) :
+        m_movie(movie), m_parent(parent) {}
+
     void Notify()
-    {
-        if (!m_bPaused)
         {
-            if(!IsMovieDone(m_movie))
-                MoviesTask(m_movie, MOVIE_DELAY);
-            else
-            {
-                wxMediaEvent theEvent(wxEVT_MEDIA_STOP,
-                                      m_parent->m_ctrl->GetId());
-                m_parent->m_ctrl->ProcessEvent(theEvent);
+        //Note that CreateMovieControl performs its own idleing
+#if !wxUSE_CREATEMOVIECONTROL
+        //
+        //  OK, a little explaining - basically originally
+        //  we only called MoviesTask if the movie was actually
+        //  playing (not paused or stopped)... this was before
+        //  we realized MoviesTask actually handles repainting
+        //  of the current frame - so if you were to resize
+        //  or something it would previously not redraw that
+        //  portion of the movie.
+        //
+        //  So now we call MoviesTask always so that it repaints
+        //  correctly.
+        //
+        ::MCIdle(m_parent->m_mc);
+#endif
 
-                if(theEvent.IsAllowed())
+        //
+        //  Handle the stop event - if the movie has reached
+        //  the end, notify our handler
+        //
+        if(::IsMovieDone(m_movie))
                 {
-                    Stop();
+            if ( m_parent->SendStopEvent() )
+            {
                     m_parent->Stop();
                     wxASSERT(::GetMoviesError() == noErr);
 
-                    //send the event to our child
-                    wxMediaEvent theEvent(wxEVT_MEDIA_FINISHED,
-                                          m_parent->m_ctrl->GetId());
-                    m_parent->m_ctrl->ProcessEvent(theEvent);
-                }
+                m_parent->QueueFinishEvent();
             }
         }
@@ -205,8 +300,8 @@
 protected:
     Movie m_movie;                  //Our movie instance
-    bool m_bPaused;                 //Whether we are paused or not
     wxQTMediaBackend* m_parent;     //Backend pointer
 };
 
+
 //---------------------------------------------------------------------------
 // wxQTMediaBackend Constructor
@@ -214,5 +309,7 @@
 // Sets m_timer to NULL signifying we havn't loaded anything yet
 //---------------------------------------------------------------------------
-wxQTMediaBackend::wxQTMediaBackend() : m_timer(NULL)
+wxQTMediaBackend::wxQTMediaBackend() 
+    : m_movie(NULL), m_bPlaying(false), m_timer(NULL)
+      , m_mc(NULL), m_interfaceflags(wxMEDIACTRLPLAYERCONTROLS_NONE)
 {
 }
@@ -229,7 +326,18 @@
 wxQTMediaBackend::~wxQTMediaBackend()
 {
-    if(m_timer)
+    if(m_movie)
         Cleanup();
 
+#if !wxUSE_CREATEMOVIECONTROL
+    // Cleanup for moviecontroller
+    if(m_mc)
+    {
+        // destroy wxQTMediaEvtHandler we pushed on it
+        m_ctrl->PopEventHandler(true);
+        RemoveEventHandler((EventHandlerRef&)m_pEventHandlerRef);
+        ::DisposeMovieController(m_mc);
+    }
+#endif
+
     //Note that ExitMovies() is not necessary...
     ExitMovies();
@@ -251,6 +359,6 @@
 {
     //Don't bother in Native control mode
-#if defined( __WXMAC__ ) && TARGET_API_MAC_OSX && ( MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_2 )
-    if (!_wxIsQuickTime4Installed())
+#if !wxUSE_CREATEMOVIECONTROL
+    if (!IsQuickTime4Installed())
         return false;
 #endif
@@ -266,15 +374,7 @@
     // backends, we don't need wxCLIP_CHILDREN
     //
-    if ( !
-
-#if wxUSE_CREATEMOVIECONTROL
-          ctrl->wxWindow::Create(parent, id, pos, size,
+    if ( !ctrl->wxControl::Create(parent, id, pos, size,
                                  wxWindow::MacRemoveBordersFromStyle(style),
-                                 name)
-#else
-          ctrl->wxControl::Create(parent, id, pos, size,
-                                  wxWindow::MacRemoveBordersFromStyle(style),
                                   validator, name)
-#endif
         )
         return false;
@@ -284,9 +384,26 @@
 #endif
 
-    m_ctrl = ctrl;
+    m_ctrl = (wxMediaCtrl*)ctrl;
     return true;
 }
 
 //---------------------------------------------------------------------------
+// wxQTMediaBackend::IsQuickTime4Installed
+//
+// Determines whether version 4 of QT is installed 
+// (Pretty much for classic only)
+//---------------------------------------------------------------------------
+#if !wxUSE_CREATEMOVIECONTROL
+Boolean wxQTMediaBackend::IsQuickTime4Installed()
+{
+    short error;
+    long result;
+
+    error = Gestalt (gestaltQuickTime, &result);
+    return (error == noErr) && (((result >> 16) & 0xffff) >= 0x0400);
+}
+#endif
+
+//---------------------------------------------------------------------------
 // wxQTMediaBackend::Load (file version)
 //
@@ -299,5 +416,5 @@
 bool wxQTMediaBackend::Load(const wxString& fileName)
 {
-    if(m_timer)
+    if(m_movie)
         Cleanup();
 
@@ -327,14 +444,51 @@
     newMovieActive,
     NULL); //wasChanged
-
-    CloseMovieFile (movieResFile);
 
-    if (err != noErr)
-        return false;
+    //No ::GetMoviesStickyError() here because it returns -2009 
+    // a.k.a. invalid track on valid mpegs
+    if(err == noErr)
+    {
+        ::CloseMovieFile (movieResFile);
 
+        // Create movie controller/control
+#if wxUSE_CREATEMOVIECONTROL
+        DoCreateMovieControl();
+#else
+        DoNewMovieController();
+#endif
     FinishLoad();
+        return true;
+    }
+    else
+    {
+        return false;        
+    }
+}
 
-    return ::GetMoviesError() == noErr;
+//---------------------------------------------------------------------------
+// wxQTMediaBackend::PPRMProc (static)
+//
+// Called when done PrePrerolling the movie.
+// Note that in 99% of the cases this does nothing...
+// Anyway we set up the loading timer here to tell us when the movie is done
+//---------------------------------------------------------------------------
+#if !wxUSE_CREATEMOVIECONTROL
+void wxQTMediaBackend::PPRMProc (Movie theMovie,
+                                 OSErr WXUNUSED_UNLESS_DEBUG(theErr),
+                                 void* theRefCon)
+{
+    wxASSERT( theMovie );
+    wxASSERT( theRefCon );
+    wxASSERT( theErr == noErr );
+
+    wxQTMediaBackend* pBE = (wxQTMediaBackend*) theRefCon;
+
+    long lTime = ::GetMovieTime(theMovie,NULL);
+    Fixed rate = ::GetMoviePreferredRate(theMovie);
+    ::PrerollMovie(theMovie,lTime,rate);
+    pBE->m_timer = new wxQTMediaLoadTimer(pBE->m_movie, pBE);
+    pBE->m_timer->Start(MOVIE_DELAY);
 }
+#endif
 
 //---------------------------------------------------------------------------
@@ -351,5 +505,5 @@
 bool wxQTMediaBackend::Load(const wxURI& location)
 {
-    if(m_timer)
+    if(m_movie)
         Cleanup();
 
@@ -358,71 +512,77 @@
     OSErr err = noErr;
 
-    Handle theHandle = NewHandleClear(theURI.length() + 1);
+    Handle theHandle = ::NewHandleClear(theURI.length() + 1);
     wxASSERT(theHandle);
 
-    BlockMove(theURI.mb_str(), *theHandle, theURI.length() + 1);
+    ::BlockMove(theURI.mb_str(), *theHandle, theURI.length() + 1);
 
     //create the movie from the handle that refers to the URI
-    err = NewMovieFromDataRef(&m_movie, newMovieActive,
+    err = ::NewMovieFromDataRef(&m_movie, newMovieActive |
+                                                    newMovieAsyncOK
+                                                    /*|newMovieIdleImportOK*/,
                                 NULL, theHandle,
                                 URLDataHandlerSubType);
 
-    DisposeHandle(theHandle);
+    ::DisposeHandle(theHandle);
 
-    if (err != noErr)
-        return false;
+    if (err == noErr)
+    {
+#if wxUSE_CREATEMOVIECONTROL
+        // Movie control resets prerolling, so we must create first
+        DoCreateMovieControl();
 
-    //preroll movie for streaming
-    //TODO:Async this using threads?
-    TimeValue timeNow;
+        // Setup timer to catch load event
+        m_timer = new wxQTMediaLoadTimer(m_movie, this);
+        m_timer->Start(MOVIE_DELAY);
+#else
+        // Movie controller resets prerolling, so we must create first 
+        DoNewMovieController();
+        
+        long timeNow;
     Fixed playRate;
-    timeNow = GetMovieTime(m_movie, NULL);
-    playRate = GetMoviePreferredRate(m_movie);
-    PrePrerollMovie(m_movie, timeNow, playRate, NULL, NULL);
-    PrerollMovie(m_movie, timeNow, playRate);
-    SetMovieRate(m_movie, playRate);
 
-    FinishLoad();
+        timeNow = ::GetMovieTime(m_movie, NULL);
+        wxASSERT(::GetMoviesError() == noErr);
 
-    return ::GetMoviesError() == noErr;
+        playRate = ::GetMoviePreferredRate(m_movie);
+        wxASSERT(::GetMoviesError() == noErr);
+
+        //
+        //  Note that the callback here is optional,
+        //  but without it PrePrerollMovie can be buggy
+        //  (see Apple ml).  Also, some may wonder
+        //  why we need this at all - this is because
+        //  Apple docs say QuickTime streamed movies
+        //  require it if you don't use a Movie Controller,
+        //  which we don't by default.
+        //
+        ::PrePrerollMovie(m_movie, timeNow, playRate,
+                              wxQTMediaBackend::PPRMProc,
+                              (void*)this);
+#endif
+        return true;
+    }
+    else
+        return false;
 }
 
 //---------------------------------------------------------------------------
-// wxQTMediaBackend::FinishLoad
+// wxQTMediaBackend::DoCreateMovieControl
+//
+// Calls CreateMovieControl and performs setup related to it
 //
-// 1) Create the movie timer
-// 2) Get real size of movie for GetBestSize/sizers
-// 3) See if there is video in the movie, and if so then either
-//    SetMovieGWorld if < 10.2 or use Native CreateMovieControl
-// 4) Set the movie time scale to something usable so that seeking
-//    etc.  will work correctly
-// 5) Refresh parent window
+// Note that we always hide the controller initially becuase when loading
+// from a url it displays about a 40x40 box with the word loading... in it,
+// but the box is outside the range of the control, which is bad (0,0
+// i believe), so we need to wait until finishload to actually display
+// the movie controller in this instance
 //---------------------------------------------------------------------------
-void wxQTMediaBackend::FinishLoad()
-{
-    m_timer = new _wxQTTimer(m_movie, (wxQTMediaBackend*) this);
-    wxASSERT(m_timer);
-
-    //get the real size of the movie
-    Rect outRect;
-    ::GetMovieNaturalBoundsRect (m_movie, &outRect);
-    wxASSERT(::GetMoviesError() == noErr);
-
-    m_bestSize.x = outRect.right - outRect.left;
-    m_bestSize.y = outRect.bottom - outRect.top;
-
-    //reparent movie/*AudioMediaCharacteristic*/
-    if(GetMovieIndTrackType(m_movie, 1,
-                            VisualMediaCharacteristic,
-                            movieTrackCharacteristic |
-                                movieTrackEnabledOnly) != NULL)
-    {
 #if wxUSE_CREATEMOVIECONTROL
+void wxQTMediaBackend::DoCreateMovieControl()
+{
         //
         //Native CreateMovieControl QT control (Thanks to Kevin Olliver's
         //wxQTMovie for some of this).
         //
-        #define GetControlPeer(whatever) ctrl->m_peer
-        wxMediaCtrl* ctrl = (wxMediaCtrl*) m_ctrl;
             Rect bounds = wxMacGetBoundsForControl(m_ctrl,
                                                    m_ctrl->GetPosition(),
@@ -430,6 +590,6 @@
 
         //Dispose of old control for new one
-        if (GetControlPeer(m_ctrl) && GetControlPeer(m_ctrl)->Ok() )
-            GetControlPeer(m_ctrl)->Dispose();
+    if (m_ctrl->m_peer && m_ctrl->m_peer->Ok() )
+        m_ctrl->m_peer->Dispose();
 
         //Options-
@@ -443,5 +603,5 @@
         ::CreateMovieControl(
                     (WindowRef)
-                       ctrl->MacGetTopLevelWindowRef(), //parent
+                   m_ctrl->MacGetTopLevelWindowRef(), //parent
                        &bounds,                         //control bounds
                        m_movie,                         //movie handle
@@ -449,54 +609,169 @@
                        | kMovieControlOptionLocateTopLeft
                        | kMovieControlOptionSetKeysEnabled
-//                       | kMovieControlOptionManuallyIdled
+                 //  | kMovieControlOptionManuallyIdled
                        ,                                //flags
-                       ctrl->m_peer->GetControlRefAddr() );
+                   m_ctrl->m_peer->GetControlRefAddr() );
 
-        ::EmbedControl(ctrl->m_peer->GetControlRef(), (ControlRef)ctrl->GetParent()->GetHandle());
-#else
+    ::EmbedControl(m_ctrl->m_peer->GetControlRef(), 
+                    (ControlRef)m_ctrl->GetParent()->GetHandle());    
+                    
         //
-        //"Emulation"
+    // Setup MovieController for the new movie
         //
-        SetMovieGWorld(m_movie,
-                       (CGrafPtr)
-                       GetWindowPort(
-                       (WindowRef)
-                       m_ctrl->MacGetTopLevelWindowRef()
-                       ),
-                       nil);
+    long dataSize;
+
+    //Get movie controller from our control
+    ::GetControlData(   m_ctrl->m_peer->GetControlRef(), 0, 
+                    kMovieControlDataMovieController, 
+                    sizeof(MovieController), (Ptr)&m_mc, &dataSize );
+
+    // Setup a callback so we can tell when the user presses
+    // play on the player controls
+    ::MCSetActionFilterWithRefCon(m_mc, 
+            wxQTMediaBackend::MCFilterProc, (long)this);
+}
 #endif
+
+//---------------------------------------------------------------------------
+// wxQTMediaBackend::DoNewMovieController
+//
+// Attaches movie to moviecontroller or creates moviecontroller
+// if not created yet
+//---------------------------------------------------------------------------
+#if !wxUSE_CREATEMOVIECONTROL
+void wxQTMediaBackend::DoNewMovieController()
+{
+    if(!m_mc)
+    {
+        // Get top level window ref for some mac functions
+        WindowRef wrTLW = (WindowRef) m_ctrl->MacGetTopLevelWindowRef();
+        
+        // MovieController not setup yet - 
+        // so we need to create a new one.
+        // You have to pass a valid movie to 
+        // NewMovieController, evidently
+        ::SetMovieGWorld(m_movie,
+                       (CGrafPtr) GetWindowPort(wrTLW),
+                       NULL);
+        wxASSERT(::GetMoviesError() == noErr);
+
+        Rect bounds = wxMacGetBoundsForControl(m_ctrl,
+                                           m_ctrl->GetPosition(),
+                                           m_ctrl->GetSize());
+
+        m_mc = ::NewMovieController(m_movie, &bounds, mcTopLeftMovie |
+                                                //mcWithFrame |
+                                                mcNotVisible);
+        wxASSERT(::GetMoviesError() == noErr);
+        ::MCDoAction(m_mc, 32, (void*)true); //mcActionSetKeysEnabled
+        wxASSERT(::GetMoviesError() == noErr);
+
+        // Setup a callback so we can tell when the user presses
+        // play on the player controls
+        ::MCSetActionFilterWithRefCon(m_mc, 
+            wxQTMediaBackend::MCFilterProc, (long)this);
+        wxASSERT(::GetMoviesError() == noErr);
+
+        //Part of a suggestion from Greg Hazel to repaint
+        //movie when idle
+        m_ctrl->PushEventHandler(new wxQTMediaEvtHandler(this));
+        
+        // Event types to catch from the TLW
+        // for the moviecontroller
+        EventTypeSpec theEventTypes[] = { 
+                    { kEventClassMouse,     kEventMouseDown },
+                    { kEventClassMouse,     kEventMouseUp },
+                    { kEventClassKeyboard,  kEventRawKeyDown },
+                    { kEventClassKeyboard,  kEventRawKeyRepeat },
+                    { kEventClassKeyboard,  kEventRawKeyUp },
+                    { kEventClassWindow,    kEventWindowUpdate },
+                    { kEventClassWindow,    kEventWindowActivated },
+                    { kEventClassWindow,    kEventWindowDeactivated } 
+                                        };
+                                        
+        // Catch window messages - 
+        // if we do not do this and if the user clicks the play
+        // button on the controller, for instance, nothing will happen...
+        InstallWindowEventHandler( wrTLW, 
+                GetwxQTMediaWindowEventHandlerUPP(), 
+                GetEventTypeCount( theEventTypes ), theEventTypes, 
+                m_mc, (&(EventHandlerRef&)m_pEventHandlerRef) );
     }
+    else
+    {
+        // MovieController already created - 
+        // Just change the movie in it and we're good to go
+        Point thePoint;
+        thePoint.h = thePoint.v = 0;
+        ::MCSetMovie(m_mc, m_movie,  
+              (WindowRef)m_ctrl->MacGetTopLevelWindowRef(),
+               thePoint);
+        wxASSERT(::GetMoviesError() == noErr);
+    }
+}
+#endif
+
+//---------------------------------------------------------------------------
+// wxQTMediaBackend::FinishLoad
+//
+// Performs operations after a movie ready to play/loaded.
+//---------------------------------------------------------------------------
+void wxQTMediaBackend::FinishLoad()
+{                    
+    // get the real size of the movie
+    DoLoadBestSize();
 
+    // Show the player controls if the user wants to
+    if(m_interfaceflags)
+        DoSetControllerVisible(m_interfaceflags);
+
     //we want millisecond precision
     ::SetMovieTimeScale(m_movie, 1000);
     wxASSERT(::GetMoviesError() == noErr);
 
-    //
-    //Here, if the parent of the control has a sizer - we
-    //tell it to recalculate the size of this control since
-    //the user opened a separate media file
-    //
-    m_ctrl->InvalidateBestSize();
-    m_ctrl->GetParent()->Layout();
-    m_ctrl->GetParent()->Refresh();
-    m_ctrl->GetParent()->Update();
+    // Start movie progress timer
+    m_timer = new wxQTMediaPlayTimer(m_movie, (wxQTMediaBackend*) this);
+    wxASSERT(m_timer);
+    m_timer->Start(MOVIE_DELAY, wxTIMER_CONTINUOUS);
 
-    //send loaded event
-    wxMediaEvent theEvent(wxEVT_MEDIA_LOADED,
-                            m_ctrl->GetId());
-    m_ctrl->AddPendingEvent(theEvent);
+    //send loaded event & refresh size
+    NotifyMovieLoaded();
 }
 
 //---------------------------------------------------------------------------
+// wxQTMediaBackend::DoLoadBestSize
+//
+// Sets the best size of the control from the real size of the movie
+//---------------------------------------------------------------------------
+void wxQTMediaBackend::DoLoadBestSize()
+{
+    //get the real size of the movie
+    Rect outRect;
+    ::GetMovieNaturalBoundsRect (m_movie, &outRect);
+    wxASSERT(::GetMoviesError() == noErr);
+
+    //determine best size
+    m_bestSize.x = outRect.right - outRect.left;
+    m_bestSize.y = outRect.bottom - outRect.top;
+}
+
+//---------------------------------------------------------------------------
 // wxQTMediaBackend::Play
 //
-// 1) Start the QT movie
-// 2) Start the movie loading timer
+// Start the QT movie
 //---------------------------------------------------------------------------
 bool wxQTMediaBackend::Play()
 {
-    ::StartMovie(m_movie);
-    m_timer->SetPaused(false);
-    m_timer->Start(MOVIE_DELAY, wxTIMER_CONTINUOUS);
+    Fixed fixRate = (Fixed) (wxQTMediaBackend::GetPlaybackRate() * 0x10000);
+    if(!fixRate)
+        fixRate = ::GetMoviePreferredRate(m_movie);
+    
+    wxASSERT(fixRate != 0);
+
+    if(!m_bPlaying)
+        ::MCDoAction(   m_mc, 8, // mcActionPlay 
+           (void *) fixRate);
+
+    m_bPlaying = true;
     return ::GetMoviesError() == noErr;
 }
@@ -505,13 +780,17 @@
 // wxQTMediaBackend::Pause
 //
-// 1) Stop the movie
-// 2) Stop the movie timer
+// Stop the movie
 //---------------------------------------------------------------------------
 bool wxQTMediaBackend::Pause()
 {
-    ::StopMovie(m_movie);
-    m_timer->SetPaused(true);
-    m_timer->Stop();
+    //Stop the movie A.K.A. ::StopMovie(m_movie);
+    if(m_bPlaying)
+    {
+        ::MCDoAction(   m_mc, 8 /*mcActionPlay*/, 
+                        (void *) 0);
+        m_bPlaying = false;
     return ::GetMoviesError() == noErr;
+    }
+    return true; //already paused
 }
 
@@ -520,14 +799,9 @@
 //
 // 1) Stop the movie
-// 2) Stop the movie timer
-// 3) Seek to the beginning of the movie
+// 2) Seek to the beginning of the movie
 //---------------------------------------------------------------------------
 bool wxQTMediaBackend::Stop()
 {
-    m_timer->SetPaused(false);
-    m_timer->Stop();
-
-    ::StopMovie(m_movie);
-    if(::GetMoviesError() != noErr)
+    if(!wxQTMediaBackend::Pause())
         return false;
 
@@ -605,10 +879,10 @@
 double wxQTMediaBackend::GetVolume()
 {
-    short sVolume = GetMovieVolume(m_movie);
+    short sVolume = ::GetMovieVolume(m_movie);
 
     if(sVolume & (128 << 8)) //negative - no sound
         return 0.0;
 
-    return (sVolume & (127 << 8)) ? 1.0 : ((double)(sVolume & 255)) / 255.0;
+    return sVolume/256.0;
 }
 
@@ -630,6 +904,5 @@
 bool wxQTMediaBackend::SetVolume(double dVolume)
 {
-    short sVolume = (short) (dVolume >= .9999 ? 1 << 8 : (dVolume * 255) );
-    SetMovieVolume(m_movie, sVolume);
+    ::SetMovieVolume(m_movie, (short) (dVolume * 256));
     return true;
 }
@@ -653,10 +926,11 @@
 wxMediaState wxQTMediaBackend::GetState()
 {
-    if ( !m_timer || (m_timer->IsRunning() == false &&
-                      m_timer->GetPaused() == false) )
-        return wxMEDIASTATE_STOPPED;
-
-    if( m_timer->IsRunning() )
+    // Could use
+    // GetMovieActive/IsMovieDone/SetMovieActive 
+    // combo if implemented that way
+    if (m_bPlaying == true)
         return wxMEDIASTATE_PLAYING;
+    else if ( !m_movie || wxQTMediaBackend::GetPosition() == 0)
+        return wxMEDIASTATE_STOPPED;
     else
         return wxMEDIASTATE_PAUSED;
@@ -671,16 +945,64 @@
 void wxQTMediaBackend::Cleanup()
 {
+    m_bPlaying = false;
+    if(m_timer)
+    {
     delete m_timer;
     m_timer = NULL;
+    }
 
+    // Stop the movie
+    // Apple samples with CreateMovieControl typically
+    // install a event handler and do this on the dispose
+    // event, but we do it here for simplicity
+    // (It might keep playing for several seconds after
+    //  control destruction if not)
+    wxQTMediaBackend::Pause();
+    
+    //
+    // Dispose of control or remove movie from MovieController
+    //
 #if wxUSE_CREATEMOVIECONTROL
-    DisposeControl(((wxMediaCtrl*)m_ctrl)->m_peer->GetControlRef());
+    if (m_ctrl->m_peer && m_ctrl->m_peer->Ok() )
+        m_ctrl->m_peer->Dispose();
+#else
+    Point thePoint;
+    thePoint.h = thePoint.v = 0;
+    ::MCSetVisible(m_mc, false);
+    ::MCSetMovie(m_mc, NULL, NULL, thePoint);
 #endif
 
-    StopMovie(m_movie);
-    DisposeMovie(m_movie);
+    ::DisposeMovie(m_movie);
 }
 
 //---------------------------------------------------------------------------
+// wxQTMediaBackend::MCFilterProc (static)
+//
+// Callback for when the movie controller recieves a message
+//---------------------------------------------------------------------------
+Boolean wxQTMediaBackend::MCFilterProc(
+                               MovieController WXUNUSED(theController),
+                               short action,
+                               void * WXUNUSED(params),
+                               long refCon)
+{
+    if(action != 1) //don't process idle events
+    {
+        wxQTMediaBackend* pThis = (wxQTMediaBackend*)refCon;
+
+        switch(action)
+        {
+        case 8: //play button triggered - MC will set movie to opposite state
+                //of current - playing ? paused : playing
+            pThis->m_bPlaying = !(pThis->m_bPlaying);
+            break;
+        default:
+            break;
+        }
+    }
+    return 0;
+}
+
+//---------------------------------------------------------------------------
 // wxQTMediaBackend::GetVideoSize
 //
@@ -703,12 +1025,8 @@
     if(m_timer)
     {
-        if ( m_ctrl )
-        {
             m_ctrl->GetParent()->MacWindowToRootWindow(&x, &y);
-        }
-
         Rect theRect = {y, x, y+h, x+w};
 
-        ::SetMovieBox(m_movie, &theRect);
+        ::MCSetControllerBoundsRect(m_mc, &theRect);
         wxASSERT(::GetMoviesError() == noErr);
     }
@@ -725,4 +1043,123 @@
 }
 
+//---------------------------------------------------------------------------
+// wxQTMediaBackend::DoSetControllerVisible
+//
+// Utility function that takes care of showing the moviecontroller
+// and showing/hiding the particular controls on it
+//---------------------------------------------------------------------------
+void wxQTMediaBackend::DoSetControllerVisible(wxMediaCtrlPlayerControls flags)
+{    
+    ::MCSetVisible(m_mc, TRUE);
+    
+    //
+    // Take care of subcontrols
+    //
+    if(::GetMoviesError() == noErr)
+    {
+        long mcFlags = 0;
+        ::MCDoAction(m_mc, 39/*mcActionGetFlags*/, (void*)&mcFlags);
+        
+        if(::GetMoviesError() == noErr)
+        {            
+             mcFlags |= (  //(1<<0)/*mcFlagSuppressMovieFrame*/ |
+                     (1<<3)/*mcFlagsUseWindowPalette*/
+                       | ((flags & wxMEDIACTRLPLAYERCONTROLS_STEP)
+                          ? 0 : (1<<1)/*mcFlagSuppressStepButtons*/)
+                       | ((flags & wxMEDIACTRLPLAYERCONTROLS_VOLUME)
+                          ? 0 : (1<<2)/*mcFlagSuppressSpeakerButton*/)
+         //              | (1<<4) /*mcFlagDontInvalidate*/ //if we take care of repainting ourselves
+                          );
+            ::MCDoAction(m_mc, 38/*mcActionSetFlags*/, (void*)mcFlags);   
+        }
+    }    
+    
+    //
+    //Adjust height and width of best size for movie controller
+    //if the user wants it shown
+    //
+    m_bestSize.x = m_bestSize.x > wxMCWIDTH ? m_bestSize.x : wxMCWIDTH;
+    m_bestSize.y += wxMCHEIGHT;
+}
+
+//---------------------------------------------------------------------------
+// wxQTMediaBackend::ShowPlayerControls
+//
+// Shows/Hides subcontrols on the media control
+//---------------------------------------------------------------------------
+bool wxQTMediaBackend::ShowPlayerControls(wxMediaCtrlPlayerControls flags)
+{
+    if(!m_mc)
+        return false; //no movie controller...
+        
+    bool bSizeChanged = false;
+    
+    //if the controller is visible and we want to hide it do so
+    if(m_interfaceflags && !flags)
+    {
+        bSizeChanged = true;
+        DoLoadBestSize();
+        ::MCSetVisible(m_mc, FALSE);
+    }
+    else if(!m_interfaceflags && flags) //show controller if hidden
+    {
+        bSizeChanged = true;
+        DoSetControllerVisible(flags);
+    }
+    
+    //readjust parent sizers
+    if(bSizeChanged)
+    {
+        NotifyMovieSizeChanged();   
+        
+        //remember state in case of loading new media
+        m_interfaceflags = flags;
+    }        
+    
+    return ::GetMoviesError() == noErr;
+}
+
+//---------------------------------------------------------------------------
+// wxQTMediaBackend::OnEraseBackground
+//
+// Suggestion from Greg Hazel to repaint the movie when idle
+// (on pause also)
+//---------------------------------------------------------------------------
+#if !wxUSE_CREATEMOVIECONTROL
+void wxQTMediaEvtHandler::OnEraseBackground(wxEraseEvent& evt)
+{
+    // Work around Nasty OSX drawing bug -
+    // http://lists.apple.com/archives/QuickTime-API/2002/Feb/msg00311.html
+    WindowRef wrTLW = 
+        (WindowRef) m_qtb->m_ctrl->MacGetTopLevelWindowRef();
+
+    RgnHandle region = MCGetControllerBoundsRgn(m_qtb->m_mc);
+    MCInvalidate(m_qtb->m_mc, wrTLW, region);
+    MCIdle(m_qtb->m_mc);
+}
+#endif
+
+//---------------------------------------------------------------------------
+// wxQTMediaWindowEventHandler
+//
+// Event callback for the top level window of our control that passes
+// messages to our moviecontroller so it can recieve mouse clicks etc.
+//---------------------------------------------------------------------------
+#if !wxUSE_CREATEMOVIECONTROL
+OSStatus wxQTMediaWindowEventHandler(EventHandlerCallRef inHandlerCallRef, 
+                                        EventRef inEvent, void *inUserData)
+{
+    EventRecord theEvent;
+    ConvertEventRefToEventRecord( inEvent, &theEvent );
+    OSStatus err;
+    err = ::MCIsPlayerEvent( (MovieController) inUserData, &theEvent );
+    
+    // pass on to other event handlers if not handled- i.e. wx
+    if(err)
+        return noErr;
+    else
+        return eventNotHandledErr;
+}
+#endif
 
 //in source file that contains stuff you don't directly use
Index: samples/mediaplayer/mediaplayer.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/samples/mediaplayer/mediaplayer.cpp,v
retrieving revision 1.22
diff -b -u -2 -r1.22 mediaplayer.cpp
--- samples/mediaplayer/mediaplayer.cpp	2005/08/08 23:12:39	1.22
+++ samples/mediaplayer/mediaplayer.cpp	2005/08/20 08:32:08
@@ -208,11 +208,4 @@
     void DoPlayFile(const wxString& path);
 
-    // Get the controls of current notebook page
-    wxMediaCtrl* GetCurrentMediaCtrl();
-    wxSlider*    GetCurrentSlider();
-    wxGauge*    GetCurrentGauge();
-
-    int      m_nLastFileId;     //List ID of played file in listctrl
-    wxString m_szFile;          //Name of currently playing file/location
     class wxMediaPlayerTimer* m_timer;     //Timer to write info to status bar
     wxString m_basestatus;      //Base status string (see ResetStatus())
@@ -250,4 +243,7 @@
     friend class wxMediaPlayerFrame;
 
+    int      m_nLastFileId;     //List ID of played file in listctrl
+    wxString m_szFile;          //Name of currently playing file/location
+
     wxMediaCtrl* m_mediactrl;   //Our media control
     class wxMediaPlayerListCtrl* m_playlist;  //Our playlist
@@ -292,13 +288,12 @@
         wxListItem kNewItem;
         kNewItem.SetAlign(wxLIST_FORMAT_LEFT);
-
-        int nID;
 
-        kNewItem.SetId(nID = this->GetItemCount());
+        int nID = this->GetItemCount();
+        kNewItem.SetId(nID);
         kNewItem.SetMask(wxLIST_MASK_DATA);
         kNewItem.SetData(new wxString(szString));
 
         this->InsertItem(kNewItem);
-        this->SetItem(nID, 0, _T("*"));
+        this->SetItem(nID, 0, wxT("*"));
         this->SetItem(nID, 1, wxFileName(szString).GetName());
 
@@ -329,5 +324,4 @@
         this->GetItem(listitem);
     }
-
 };
 
@@ -417,5 +411,5 @@
 {
     wxMediaPlayerFrame *frame =
-        new wxMediaPlayerFrame(_T("MediaPlayer wxWidgets Sample"));
+        new wxMediaPlayerFrame(wxT("MediaPlayer wxWidgets Sample"));
     frame->Show(true);
 
@@ -480,6 +474,5 @@
 
 wxMediaPlayerFrame::wxMediaPlayerFrame(const wxString& title)
-       : wxFrame(NULL, wxID_ANY, title, wxDefaultPosition, wxSize(600,600)),
-       m_nLastFileId(-1)
+       : wxFrame(NULL, wxID_ANY, title, wxDefaultPosition, wxSize(600,600))
 {
     //
@@ -492,48 +485,48 @@
     wxMenu *debugMenu = new wxMenu;
 
-    fileMenu->Append(wxID_OPENFILESAMEPAGE, _T("&Open File\tCtrl-Shift-O"),
-                        _T("Open a File in the current notebook page"));
-    fileMenu->Append(wxID_OPENFILENEWPAGE, _T("&Open File in a new page"),
-                        _T("Open a File in a new notebook page"));
-    fileMenu->Append(wxID_OPENURLSAMEPAGE, _T("&Open URL"),
-                        _T("Open a URL in the current notebook page"));
-    fileMenu->Append(wxID_OPENURLNEWPAGE, _T("&Open URL in a new page"),
-                        _T("Open a URL in a new notebook page"));
+    fileMenu->Append(wxID_OPENFILESAMEPAGE, wxT("&Open File\tCtrl-Shift-O"),
+                        wxT("Open a File in the current notebook page"));
+    fileMenu->Append(wxID_OPENFILENEWPAGE, wxT("&Open File in a new page"),
+                        wxT("Open a File in a new notebook page"));
+    fileMenu->Append(wxID_OPENURLSAMEPAGE, wxT("&Open URL"),
+                        wxT("Open a URL in the current notebook page"));
+    fileMenu->Append(wxID_OPENURLNEWPAGE, wxT("&Open URL in a new page"),
+                        wxT("Open a URL in a new notebook page"));
     fileMenu->AppendSeparator();
-    fileMenu->Append(wxID_CLOSECURRENTPAGE, _T("&Close Current Page\tCtrl-C"),
-                        _T("Close current notebook page"));
+    fileMenu->Append(wxID_CLOSECURRENTPAGE, wxT("&Close Current Page\tCtrl-C"),
+                        wxT("Close current notebook page"));
     fileMenu->AppendSeparator();
     fileMenu->Append(wxID_EXIT,
-                     _T("E&xit\tAlt-X"),
-                     _T("Quit this program"));
+                     wxT("E&xit\tAlt-X"),
+                     wxT("Quit this program"));
 
-    controlsMenu->Append(wxID_PLAY, _T("&Play/Pause\tCtrl-P"), _T("Resume/Pause playback"));
-    controlsMenu->Append(wxID_STOP, _T("&Stop\tCtrl-S"), _T("Stop playback"));
+    controlsMenu->Append(wxID_PLAY, wxT("&Play/Pause\tCtrl-P"), wxT("Resume/Pause playback"));
+    controlsMenu->Append(wxID_STOP, wxT("&Stop\tCtrl-S"), wxT("Stop playback"));
     controlsMenu->AppendSeparator();
-    controlsMenu->Append(wxID_PREV, _T("&Previous\tCtrl-B"), _T("Go to previous track"));
-    controlsMenu->Append(wxID_NEXT, _T("&Next\tCtrl-N"), _T("Skip to next track"));
+    controlsMenu->Append(wxID_PREV, wxT("&Previous\tCtrl-B"), wxT("Go to previous track"));
+    controlsMenu->Append(wxID_NEXT, wxT("&Next\tCtrl-N"), wxT("Skip to next track"));
 
     optionsMenu->AppendCheckItem(wxID_LOOP,
-                              _T("&Loop\tCtrl-L"),
-                              _T("Loop Selected Media"));
+                              wxT("&Loop\tCtrl-L"),
+                              wxT("Loop Selected Media"));
     optionsMenu->AppendCheckItem(wxID_SHOWINTERFACE,
-                              _T("&Show Interface\tCtrl-I"),
-                              _T("Show wxMediaCtrl native controls"));
+                              wxT("&Show Interface\tCtrl-I"),
+                              wxT("Show wxMediaCtrl native controls"));
 
     debugMenu->Append(wxID_SELECTBACKEND,
-                     _T("&Select Backend...\tCtrl-D"),
-                     _T("Select a backend manually"));
+                     wxT("&Select Backend...\tCtrl-D"),
+                     wxT("Select a backend manually"));
 
     helpMenu->Append(wxID_ABOUT,
-                     _T("&About...\tF1"),
-                     _T("Show about dialog"));
+                     wxT("&About...\tF1"),
+                     wxT("Show about dialog"));
 
 
     wxMenuBar *menuBar = new wxMenuBar();
-    menuBar->Append(fileMenu, _T("&File"));
-    menuBar->Append(controlsMenu, _T("&Controls"));
-    menuBar->Append(optionsMenu, _T("&Options"));
-    menuBar->Append(debugMenu, _T("&Debug"));
-    menuBar->Append(helpMenu, _T("&Help"));
+    menuBar->Append(fileMenu, wxT("&File"));
+    menuBar->Append(controlsMenu, wxT("&Controls"));
+    menuBar->Append(optionsMenu, wxT("&Options"));
+    menuBar->Append(debugMenu, wxT("&Debug"));
+    menuBar->Append(helpMenu, wxT("&Help"));
     SetMenuBar(menuBar);
 
@@ -693,9 +686,31 @@
     //  to work with without having to go file->open every time :).
     //
-    m_notebook->AddPage(new wxMediaPlayerNotebookPage(this, m_notebook),
+    wxMediaPlayerNotebookPage* page = 
+        new wxMediaPlayerNotebookPage(this, m_notebook);
+    m_notebook->AddPage(page,
                         wxT(""),
                         true);
 
     //
+    //  Here we load the our configuration -
+    //  in our case we load all the files that were left in
+    //  the playlist the last time the user closed our application
+    //
+    //  As an exercise to the reader try modifying it so that
+    //  it properly loads the playlist for each page without
+    //  conflicting (loading the same data) with the other ones.
+    //
+    wxConfigBase* conf = wxConfigBase::Get();
+    wxString key, outstring;
+    for(int i = 0; ; ++i)
+    {
+        key.clear();
+        key << i;
+        if(!conf->Read(key, &outstring))
+            break;
+        page->m_playlist->AddToPlayList(outstring);
+    }
+
+    //
     //  Create a timer to update our status bar
     //
@@ -712,13 +727,4 @@
 wxMediaPlayerFrame::~wxMediaPlayerFrame()
 {
-    delete m_timer;
-
-}
-
-// ----------------------------------------------------------------------------
-// wxMediaPlayerFrame::OnClose
-// ----------------------------------------------------------------------------
-void wxMediaPlayerFrame::OnClose(wxCloseEvent& event)
-{
     //
     //  Here we save our info to the registry or whatever
@@ -737,14 +743,17 @@
     //  all you'd need to do is just remove everything after
     //  conf->DeleteAll() here
+    //
+    //  As an exercise to the reader, try modifying this so
+    //  that it saves the data for each notebook page
     //
-    wxMediaPlayerListCtrl* m_playlist =
-        ((wxMediaPlayerNotebookPage*)m_notebook->GetCurrentPage())->m_playlist;
+    wxMediaPlayerListCtrl* playlist =
+        ((wxMediaPlayerNotebookPage*)m_notebook->GetPage(0))->m_playlist;
 
     wxConfigBase* conf = wxConfigBase::Get();
     conf->DeleteAll();
 
-    for(int i = 0; i < m_playlist->GetItemCount(); ++i)
+    for(int i = 0; i < playlist->GetItemCount(); ++i)
     {
-        wxString* pData = (wxString*) m_playlist->GetItemData(i);
+        wxString* pData = (wxString*) playlist->GetItemData(i);
         wxString s;
         s << i;
@@ -753,4 +762,12 @@
     }
 
+    delete m_timer;
+}
+
+// ----------------------------------------------------------------------------
+// wxMediaPlayerFrame::OnClose
+// ----------------------------------------------------------------------------
+void wxMediaPlayerFrame::OnClose(wxCloseEvent& event)
+{
     event.Skip(); //really close the frame
 }
@@ -787,8 +804,9 @@
 void wxMediaPlayerFrame::ResetStatus()
 {
-    wxMediaCtrl* currentMediaCtrl = GetCurrentMediaCtrl();
+    wxMediaCtrl* currentMediaCtrl = 
+        ((wxMediaPlayerNotebookPage*)m_notebook->GetCurrentPage())->m_mediactrl;
 
-    m_basestatus = wxString::Format(_T("Size(x,y):%i,%i ")
-                                    _T("Length(Seconds):%u Speed:%1.1fx"),
+    m_basestatus = wxString::Format(wxT("Size(x,y):%i,%i ")
+                                    wxT("Length(Seconds):%u Speed:%1.1fx"),
     currentMediaCtrl->GetBestSize().x,
     currentMediaCtrl->GetBestSize().y,
@@ -799,35 +817,4 @@
 
 // ----------------------------------------------------------------------------
-// wxMediaPlayerFrame::GetCurrentMediaCtrl
-//
-// Obtains the media control of the current page, or NULL if there are no
-// pages open
-// ----------------------------------------------------------------------------
-wxMediaCtrl* wxMediaPlayerFrame::GetCurrentMediaCtrl()
-{
-    return ((wxMediaPlayerNotebookPage*)m_notebook->GetCurrentPage())->m_mediactrl;
-}
-
-// ----------------------------------------------------------------------------
-// wxMediaPlayerFrame::GetCurrentSlider
-//
-// Obtains the slider of the current page
-// ----------------------------------------------------------------------------
-wxSlider*    wxMediaPlayerFrame::GetCurrentSlider()
-{
-    return ((wxMediaPlayerNotebookPage*)m_notebook->GetCurrentPage())->m_slider;
-}
-
-// ----------------------------------------------------------------------------
-// wxMediaPlayerFrame::GetCurrentGauge
-//
-// Obtains the gauge of the current page
-// ----------------------------------------------------------------------------
-wxGauge*    wxMediaPlayerFrame::GetCurrentGauge()
-{
-    return ((wxMediaPlayerNotebookPage*)m_notebook->GetCurrentPage())->m_gauge;
-}
-
-// ----------------------------------------------------------------------------
 // wxMediaPlayerFrame::OnQuit
 //
@@ -850,8 +837,8 @@
 {
     wxString msg;
-    msg.Printf( _T("This is a test of wxMediaCtrl.\n")
-                _T("Welcome to %s"), wxVERSION_STRING);
+    msg.Printf( wxT("This is a test of wxMediaCtrl.\n")
+                wxT("Welcome to %s"), wxVERSION_STRING);
 
-    wxMessageBox(msg, _T("About wxMediaCtrl test"), wxOK | wxICON_INFORMATION, this);
+    wxMessageBox(msg, wxT("About wxMediaCtrl test"), wxOK | wxICON_INFORMATION, this);
 }
 
@@ -864,12 +851,8 @@
 void wxMediaPlayerFrame::OnLoop(wxCommandEvent& WXUNUSED(event))
 {
-    if(!m_notebook->GetCurrentPage())
-    {
-        wxMessageBox(wxT("No files are currently open!"));
-        return;
-    }
+    wxMediaPlayerNotebookPage* currentpage =
+        ((wxMediaPlayerNotebookPage*)m_notebook->GetCurrentPage());
 
-    ((wxMediaPlayerNotebookPage*)m_notebook->GetCurrentPage())->m_bLoop =
-            !((wxMediaPlayerNotebookPage*)m_notebook->GetCurrentPage())->m_bLoop;
+    currentpage->m_bLoop = !currentpage->m_bLoop;
 }
 
@@ -882,13 +865,21 @@
 void wxMediaPlayerFrame::OnShowInterface(wxCommandEvent& event)
 {
-    if(!m_notebook->GetCurrentPage())
-    {
-        wxMessageBox(wxT("No files are currently open!"));
-        return;
-    }
+    wxMediaPlayerNotebookPage* currentpage =
+        ((wxMediaPlayerNotebookPage*)m_notebook->GetCurrentPage());
 
-    GetCurrentMediaCtrl()->ShowPlayerControls(event.IsChecked() ?
+    if( !currentpage->m_mediactrl->ShowPlayerControls(event.IsChecked() ?
             wxMEDIACTRLPLAYERCONTROLS_DEFAULT :
-             wxMEDIACTRLPLAYERCONTROLS_NONE);
+             wxMEDIACTRLPLAYERCONTROLS_NONE)    )
+    {
+        //error - uncheck and warn user
+        wxMenuItem* pSIItem = GetMenuBar()->FindItem(wxID_SHOWINTERFACE);
+        wxASSERT(pSIItem);
+        pSIItem->Check(!event.IsChecked());
+        
+        if(event.IsChecked())
+            wxMessageBox(wxT("Could not show player controls"));
+        else
+            wxMessageBox(wxT("Could not hide player controls"));
+    }
 }
 
@@ -947,9 +938,10 @@
     }
 
-    wxMediaPlayerListCtrl* m_playlist =
-        ((wxMediaPlayerNotebookPage*)m_notebook->GetCurrentPage())->m_playlist;
+    wxMediaPlayerNotebookPage* currentpage = 
+        (wxMediaPlayerNotebookPage*) m_notebook->GetCurrentPage();
 
-    if(m_nLastFileId != -1)
-        m_playlist->SetItemState(m_nLastFileId, 0, wxLIST_STATE_SELECTED);
+    if(currentpage->m_nLastFileId != -1)
+        currentpage->m_playlist->SetItemState(currentpage->m_nLastFileId, 
+                                              0, wxLIST_STATE_SELECTED);
 
     wxListItem newlistitem;
@@ -958,21 +950,20 @@
     int nID;
 
-    newlistitem.SetId(nID = m_playlist->GetItemCount());
+    newlistitem.SetId(nID = currentpage->m_playlist->GetItemCount());
     newlistitem.SetMask(wxLIST_MASK_DATA | wxLIST_MASK_STATE);
     newlistitem.SetState(wxLIST_STATE_SELECTED);
     newlistitem.SetData(new wxString(path));
 
-    m_playlist->InsertItem(newlistitem);
-    m_playlist->SetItem(nID, 0, _T("*"));
-    m_playlist->SetItem(nID, 1, wxFileName(path).GetName());
+    currentpage->m_playlist->InsertItem(newlistitem);
+    currentpage->m_playlist->SetItem(nID, 0, wxT("*"));
+    currentpage->m_playlist->SetItem(nID, 1, wxFileName(path).GetName());
 
     if (nID % 2)
     {
         newlistitem.SetBackgroundColour(wxColour(192,192,192));
-        m_playlist->SetItem(newlistitem);
+        currentpage->m_playlist->SetItem(newlistitem);
     }
 
     DoPlayFile(path);
-     //        m_playlist->Focus(nID);
 }
 
@@ -985,67 +976,78 @@
 void wxMediaPlayerFrame::DoPlayFile(const wxString& path)
 {
-    wxMediaPlayerListCtrl* m_playlist =
-        ((wxMediaPlayerNotebookPage*)m_notebook->GetCurrentPage())->m_playlist;
+    wxMediaPlayerNotebookPage* currentpage = 
+        (wxMediaPlayerNotebookPage*) m_notebook->GetCurrentPage();
 
     wxListItem listitem;
-    m_playlist->GetSelectedItem(listitem);
+    currentpage->m_playlist->GetSelectedItem(listitem);
 
-    if(listitem.GetData() &&
-       m_szFile.compare(path) == 0 &&
-       m_nLastFileId == listitem.GetId())
+    if( (  listitem.GetData() &&
+           currentpage->m_nLastFileId == listitem.GetId() &&
+           currentpage->m_szFile.compare(path) == 0 ) ||
+        (  !listitem.GetData() &&
+            currentpage->m_nLastFileId != -1 &&
+            currentpage->m_szFile.compare(path) == 0)
+      )
     {
-        if(GetCurrentMediaCtrl()->GetState() == wxMEDIASTATE_PLAYING)
+        if(currentpage->m_mediactrl->GetState() == wxMEDIASTATE_PLAYING)
     {
-            if( !GetCurrentMediaCtrl()->Pause() )
+            if( !currentpage->m_mediactrl->Pause() )
                 wxMessageBox(wxT("Couldn't pause movie!"));
             else
-                m_playlist->SetItem(listitem.GetId(), 0, _T("||"));
+                currentpage->m_playlist->SetItem(
+                    currentpage->m_nLastFileId, 0, wxT("||"));
         }
         else
         {
-            if( !GetCurrentMediaCtrl()->Play() )
-                wxMessageBox(wxT("Couldn't pause movie!"));
+            if( !currentpage->m_mediactrl->Play() )
+                wxMessageBox(wxT("Couldn't play movie!"));
             else
-                m_playlist->SetItem(listitem.GetId(), 0, _T(">"));
+                currentpage->m_playlist->SetItem(
+                    currentpage->m_nLastFileId, 0, wxT(">"));
         }
     }
     else
     {
+        int nNewId = listitem.GetData() ? listitem.GetId() : 
+                            currentpage->m_playlist->GetItemCount()-1;
         m_notebook->SetPageText(m_notebook->GetSelection(),
                                 wxFileName(path).GetName());
 
-        if(m_nLastFileId != -1)
-            m_playlist->SetItem(m_nLastFileId, 0, _T("*"));
+        if(currentpage->m_nLastFileId != -1)
+           currentpage->m_playlist->SetItem(
+                    currentpage->m_nLastFileId, 0, wxT("*"));
 
         wxURI uripath(path);
         if( uripath.IsReference() )
         {
-            if( !GetCurrentMediaCtrl()->Load(path) )
+            if( !currentpage->m_mediactrl->Load(path) )
             {
                 wxMessageBox(wxT("Couldn't load file!"));
-                m_playlist->SetItem(listitem.GetId(), 0, _T("E"));
+                currentpage->m_playlist->SetItem(nNewId, 0, wxT("E"));
             }
             else
             {
-                m_playlist->SetItem(listitem.GetId(), 0, _T("O"));
+                currentpage->m_playlist->SetItem(nNewId, 0, wxT("O"));
             }
         }
         else
         {
-            if( !GetCurrentMediaCtrl()->Load(uripath) )
+            if( !currentpage->m_mediactrl->Load(uripath) )
             {
-            wxMessageBox(wxT("Couldn't load file!"));
-                m_playlist->SetItem(listitem.GetId(), 0, _T("E"));
+                wxMessageBox(wxT("Couldn't load URL!"));
+                currentpage->m_playlist->SetItem(nNewId, 0, wxT("E"));
             }
             else
             {
-                m_playlist->SetItem(listitem.GetId(), 0, _T("O"));
+                currentpage->m_playlist->SetItem(nNewId, 0, wxT("O"));
             }
         }
 
-        m_nLastFileId = listitem.GetId();
-        m_szFile = path;
-        m_playlist->SetItem(m_nLastFileId, 1, wxFileName(path).GetName());
-        m_playlist->SetItem(m_nLastFileId, 2, wxT(""));
+        currentpage->m_nLastFileId = nNewId;
+        currentpage->m_szFile = path;
+        currentpage->m_playlist->SetItem(currentpage->m_nLastFileId, 
+                                         1, wxFileName(path).GetName());
+        currentpage->m_playlist->SetItem(currentpage->m_nLastFileId, 
+                                         2, wxT(""));
     }
 }
@@ -1059,27 +1061,27 @@
 void wxMediaPlayerFrame::OnMediaLoaded(wxMediaEvent& WXUNUSED(evt))
 {
-    wxMediaPlayerListCtrl* m_playlist =
-        ((wxMediaPlayerNotebookPage*)m_notebook->GetCurrentPage())->m_playlist;
-    wxListItem listitem;
-    m_playlist->GetSelectedItem(listitem);
+    wxMediaPlayerNotebookPage* currentpage = 
+        (wxMediaPlayerNotebookPage*) m_notebook->GetCurrentPage();
 
-        if( !GetCurrentMediaCtrl()->Play() )
+    if( !currentpage->m_mediactrl->Play() )
     {
             wxMessageBox(wxT("Couldn't play movie!"));
-        m_playlist->SetItem(listitem.GetId(), 0, _T("E"));
+        currentpage->m_playlist->SetItem(currentpage->m_nLastFileId, 0, wxT("E"));
     }
     else
     {
-        m_playlist->SetItem(listitem.GetId(), 0, _T(">"));
+        currentpage->m_playlist->SetItem(currentpage->m_nLastFileId, 0, wxT(">"));
     }
 
-    m_playlist->SetItem(listitem.GetId(), 2, wxString::Format(wxT("%u"),
-                        (unsigned) GetCurrentMediaCtrl()->Length() / 1000) );
+    currentpage->m_playlist->SetItem(currentpage->m_nLastFileId, 
+                                     2, wxString::Format(wxT("%u"),
+                         (unsigned) currentpage->m_mediactrl->Length() / 1000) 
+                                    );
 
         ResetStatus();
 
-        GetCurrentSlider()->SetRange(0,
-                        (int)(GetCurrentMediaCtrl()->Length() / 1000));
-    GetCurrentGauge()->SetRange((int)(GetCurrentMediaCtrl()->Length() / 1000));
+    currentpage->m_slider->SetRange(0,
+                    (int)(currentpage->m_mediactrl->Length() / 1000));
+    currentpage->m_gauge->SetRange((int)(currentpage->m_mediactrl->Length() / 1000));
 }
 
@@ -1107,5 +1109,8 @@
                                                         sBackend
                                                         ), wxT(""), true);
-        DoOpenFile(m_szFile, false);
+
+        DoOpenFile(
+            ((wxMediaPlayerNotebookPage*) m_notebook->GetCurrentPage())->m_szFile, 
+            false);
     }
 }
@@ -1185,33 +1190,34 @@
 void wxMediaPlayerFrame::OnPlay(wxCommandEvent& WXUNUSED(event))
 {
-    wxMediaPlayerListCtrl* m_playlist =
-        ((wxMediaPlayerNotebookPage*)m_notebook->GetCurrentPage())->m_playlist;
+    wxMediaPlayerNotebookPage* currentpage = 
+        (wxMediaPlayerNotebookPage*) m_notebook->GetCurrentPage();
 
     wxListItem listitem;
-    m_playlist->GetSelectedItem(listitem);
+    currentpage->m_playlist->GetSelectedItem(listitem);
     if ( !listitem.GetData() )
     {
         int nLast = -1;
-        if ((nLast = m_playlist->GetNextItem(nLast,
+        if ((nLast = currentpage->m_playlist->GetNextItem(nLast,
                                          wxLIST_NEXT_ALL,
                                          wxLIST_STATE_DONTCARE)) == -1)
         {
             //no items in list
-            wxMessageBox(_T("No items in playlist!"));
-        return;
+            wxMessageBox(wxT("No items in playlist!"));
     }
-        wxListItem listitem;
+        else
+        {
         listitem.SetId(nLast);
-        m_playlist->GetItem(listitem);
+            currentpage->m_playlist->GetItem(listitem);
         listitem.SetMask(listitem.GetMask() | wxLIST_MASK_STATE);
         listitem.SetState(listitem.GetState() | wxLIST_STATE_SELECTED);
-        m_playlist->SetItem(listitem);
-        wxListEvent event;
-        OnChangeSong(event);
+            currentpage->m_playlist->SetItem(listitem);
+            wxASSERT(listitem.GetData());
+            DoPlayFile((*((wxString*) listitem.GetData())));            
     }
+    }
     else
     {
-        wxListEvent event;
-        OnChangeSong(event);
+        wxASSERT(listitem.GetData());
+        DoPlayFile((*((wxString*) listitem.GetData())));
     }
 }
@@ -1226,10 +1232,10 @@
    if(event.GetKeyCode() == WXK_BACK/*DELETE*/)
     {
-    wxMediaPlayerListCtrl* m_playlist =
-        ((wxMediaPlayerNotebookPage*)m_notebook->GetCurrentPage())->m_playlist;
+        wxMediaPlayerNotebookPage* currentpage = 
+            (wxMediaPlayerNotebookPage*) m_notebook->GetCurrentPage();
        //delete all selected items
        while(true)
        {
-           wxInt32 nSelectedItem = m_playlist->GetNextItem(
+           wxInt32 nSelectedItem = currentpage->m_playlist->GetNextItem(
                     -1, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
            if (nSelectedItem == -1)
@@ -1238,8 +1244,8 @@
            wxListItem listitem;
            listitem.SetId(nSelectedItem);
-           m_playlist->GetItem(listitem);
+           currentpage->m_playlist->GetItem(listitem);
            delete (wxString*) listitem.GetData();
 
-           m_playlist->DeleteItem(nSelectedItem);
+           currentpage->m_playlist->DeleteItem(nSelectedItem);
        }
     }
@@ -1261,19 +1267,12 @@
 void wxMediaPlayerFrame::OnStop(wxCommandEvent& WXUNUSED(evt))
 {
-    wxMediaPlayerListCtrl* m_playlist =
-        ((wxMediaPlayerNotebookPage*)m_notebook->GetCurrentPage())->m_playlist;
-
-    wxListItem listitem;
-    m_playlist->GetSelectedItem(listitem);
-    m_playlist->SetItem(listitem.GetId(), 0, _T("[]"));
-
-    if(!m_notebook->GetCurrentPage())
-    {
-        wxMessageBox(wxT("No files are currently open!"));
-        return;
-    }
+    wxMediaPlayerNotebookPage* currentpage = 
+        (wxMediaPlayerNotebookPage*) m_notebook->GetCurrentPage();
 
-    if( !GetCurrentMediaCtrl()->Stop() )
+    if( !currentpage->m_mediactrl->Stop() )
         wxMessageBox(wxT("Couldn't stop movie!"));
+    else
+        currentpage->m_playlist->SetItem(
+            currentpage->m_nLastFileId, 0, wxT("[]"));
 }
 
@@ -1288,10 +1287,13 @@
 void wxMediaPlayerFrame::OnChangeSong(wxListEvent& WXUNUSED(evt))
 {
-    wxMediaPlayerListCtrl* m_playlist =
-        ((wxMediaPlayerNotebookPage*)m_notebook->GetCurrentPage())->m_playlist;
+    wxMediaPlayerNotebookPage* currentpage = 
+        (wxMediaPlayerNotebookPage*) m_notebook->GetCurrentPage();
 
     wxListItem listitem;
-    m_playlist->GetSelectedItem(listitem);
+    currentpage->m_playlist->GetSelectedItem(listitem);
+    if(listitem.GetData())
     DoPlayFile((*((wxString*) listitem.GetData())));
+    else
+        wxMessageBox(wxT("No selected item!"));
 }
 
@@ -1304,8 +1306,8 @@
 void wxMediaPlayerFrame::OnPrev(wxCommandEvent& WXUNUSED(event))
 {
-    wxMediaPlayerListCtrl* m_playlist =
-        ((wxMediaPlayerNotebookPage*)m_notebook->GetCurrentPage())->m_playlist;
+    wxMediaPlayerNotebookPage* currentpage = 
+        (wxMediaPlayerNotebookPage*) m_notebook->GetCurrentPage();
 
-    if (m_playlist->GetItemCount() == 0)
+    if (currentpage->m_playlist->GetItemCount() == 0)
         return;
 
@@ -1313,26 +1315,38 @@
     while(true)
     {
-        wxInt32 nSelectedItem = m_playlist->GetNextItem(nLastSelectedItem,
+        wxInt32 nSelectedItem = currentpage->m_playlist->GetNextItem(nLastSelectedItem,
                                                      wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
         if (nSelectedItem == -1)
             break;
         nLastSelectedItem = nSelectedItem;
-        m_playlist->SetItemState(nSelectedItem, 0, wxLIST_STATE_SELECTED);
+        currentpage->m_playlist->SetItemState(nSelectedItem, 0, wxLIST_STATE_SELECTED);
     }
 
-    if (nLastSelectedItem <= 0)
-        nLastSelectedItem = m_playlist->GetItemCount() - 1;
+    if (nLastSelectedItem == -1) 
+    {
+        //nothing selected, default to the file before the currently playing one
+        if(currentpage->m_nLastFileId == 0)
+            nLastSelectedItem = currentpage->m_playlist->GetItemCount() - 1;
     else
+            nLastSelectedItem = currentpage->m_nLastFileId - 1;
+    }
+    else if (nLastSelectedItem == 0) 
+        nLastSelectedItem = currentpage->m_playlist->GetItemCount() - 1;
+    else
         nLastSelectedItem -= 1;
 
+    if(nLastSelectedItem == currentpage->m_nLastFileId)
+        return; //already playing... nothing to do
+
     wxListItem listitem;
     listitem.SetId(nLastSelectedItem);
-    m_playlist->GetItem(listitem);
+    listitem.SetMask(wxLIST_MASK_TEXT |  wxLIST_MASK_DATA);
+    currentpage->m_playlist->GetItem(listitem);
     listitem.SetMask(listitem.GetMask() | wxLIST_MASK_STATE);
     listitem.SetState(listitem.GetState() | wxLIST_STATE_SELECTED);
-    m_playlist->SetItem(listitem);
+    currentpage->m_playlist->SetItem(listitem);
 
-    wxListEvent emptyEvent;
-    OnChangeSong(emptyEvent);
+    wxASSERT(listitem.GetData());
+    DoPlayFile((*((wxString*) listitem.GetData())));
 }
 
@@ -1345,8 +1359,8 @@
 void wxMediaPlayerFrame::OnNext(wxCommandEvent& WXUNUSED(event))
 {
-    wxMediaPlayerListCtrl* m_playlist =
-        ((wxMediaPlayerNotebookPage*)m_notebook->GetCurrentPage())->m_playlist;
+    wxMediaPlayerNotebookPage* currentpage = 
+        (wxMediaPlayerNotebookPage*) m_notebook->GetCurrentPage();
 
-    if (m_playlist->GetItemCount() == 0)
+    if (currentpage->m_playlist->GetItemCount() == 0)
         return;
 
@@ -1354,31 +1368,37 @@
     while(true)
     {
-        wxInt32 nSelectedItem = m_playlist->GetNextItem(nLastSelectedItem,
+        wxInt32 nSelectedItem = currentpage->m_playlist->GetNextItem(nLastSelectedItem,
                                                      wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
         if (nSelectedItem == -1)
             break;
         nLastSelectedItem = nSelectedItem;
-        m_playlist->SetItemState(nSelectedItem, 0, wxLIST_STATE_SELECTED);
+        currentpage->m_playlist->SetItemState(nSelectedItem, 0, wxLIST_STATE_SELECTED);
     }
 
     if (nLastSelectedItem == -1)
+    {
+        if(currentpage->m_nLastFileId == currentpage->m_playlist->GetItemCount() - 1)
         nLastSelectedItem = 0;
     else
-    {
-        if (nLastSelectedItem == m_playlist->GetItemCount() - 1)
+            nLastSelectedItem = currentpage->m_nLastFileId + 1;                
+    }
+    else if (nLastSelectedItem == currentpage->m_playlist->GetItemCount() - 1)
             nLastSelectedItem = 0;
         else
             nLastSelectedItem += 1;
-    }
 
+    if(nLastSelectedItem == currentpage->m_nLastFileId)
+        return; //already playing... nothing to do
+
     wxListItem listitem;
+    listitem.SetMask(wxLIST_MASK_TEXT |  wxLIST_MASK_DATA);
     listitem.SetId(nLastSelectedItem);
-    m_playlist->GetItem(listitem);
+    currentpage->m_playlist->GetItem(listitem);
     listitem.SetMask(listitem.GetMask() | wxLIST_MASK_STATE);
     listitem.SetState(listitem.GetState() | wxLIST_STATE_SELECTED);
-    m_playlist->SetItem(listitem);
+    currentpage->m_playlist->SetItem(listitem);
 
-    wxListEvent emptyEvent;
-    OnChangeSong(emptyEvent);
+    wxASSERT(listitem.GetData());
+    DoPlayFile((*((wxString*) listitem.GetData())));
 }
 
@@ -1391,6 +1411,9 @@
 void wxMediaPlayerFrame::OnVolumeDown(wxCommandEvent& WXUNUSED(event))
 {
-    double dVolume = GetCurrentMediaCtrl()->GetVolume();
-    GetCurrentMediaCtrl()->SetVolume(dVolume < 0.1 ? 0.0 : dVolume - .1);
+    wxMediaPlayerNotebookPage* currentpage = 
+        (wxMediaPlayerNotebookPage*) m_notebook->GetCurrentPage();
+
+    double dVolume = currentpage->m_mediactrl->GetVolume();
+    currentpage->m_mediactrl->SetVolume(dVolume < 0.1 ? 0.0 : dVolume - .1);
 }
 
@@ -1402,14 +1425,16 @@
 void wxMediaPlayerFrame::OnVolumeUp(wxCommandEvent& WXUNUSED(event))
 {
-    double dVolume = GetCurrentMediaCtrl()->GetVolume();
-    GetCurrentMediaCtrl()->SetVolume(dVolume > 0.9 ? 1.0 : dVolume + .1);
+    wxMediaPlayerNotebookPage* currentpage = 
+        (wxMediaPlayerNotebookPage*) m_notebook->GetCurrentPage();
+
+    double dVolume = currentpage->m_mediactrl->GetVolume();
+    currentpage->m_mediactrl->SetVolume(dVolume > 0.9 ? 1.0 : dVolume + .1);
 }
 
 // ----------------------------------------------------------------------------
-// wxMediaPlayerFrame::OnCloseCurrentPage
+// wxMediaPlayerFrame::OnPageChange
 //
-// Called when the user wants to closes the current notebook page
+// Called when the user changes the current notebook page shown
 // ----------------------------------------------------------------------------
-
 void wxMediaPlayerFrame::OnPageChange(wxNotebookEvent& WXUNUSED(event))
 {
@@ -1433,33 +1458,28 @@
 void wxMediaPlayerTimer::Notify()
 {
-    if(m_frame->m_notebook->GetCurrentPage())
-    {
-            // get some control pointers from current notebook page
-        wxMediaCtrl* mediactrl =
-            ((wxMediaPlayerNotebookPage*)m_frame->m_notebook->GetCurrentPage())->m_mediactrl;
-        wxSlider* slider =
-            ((wxMediaPlayerNotebookPage*)m_frame->m_notebook->GetCurrentPage())->m_slider;
-        wxGauge* gauge =
-            ((wxMediaPlayerNotebookPage*)m_frame->m_notebook->GetCurrentPage())->m_gauge;
+    wxMediaPlayerNotebookPage* currentpage = 
+        (wxMediaPlayerNotebookPage*) m_frame->m_notebook->GetCurrentPage();
 
+    if(currentpage)
+    {
         // if the slider is being dragged then update it with the song position
-        if(((wxMediaPlayerNotebookPage*)m_frame->m_notebook->GetCurrentPage())->IsBeingDragged() == false)
+        if(currentpage->IsBeingDragged() == false)
         {
-            long lPosition = (long)( mediactrl->Tell() / 1000 );
-            slider->SetValue(lPosition);
+            long lPosition = (long)( currentpage->m_mediactrl->Tell() / 1000 );
+            currentpage->m_slider->SetValue(lPosition);
         }
 
         // update guage with value from slider
-        gauge->SetValue(slider->GetValue());
+        currentpage->m_gauge->SetValue(currentpage->m_slider->GetValue());
 #if wxUSE_STATUSBAR
         m_frame->SetStatusText(wxString::Format(
                         wxT("%s Pos:%u State:%s Loops:%i D/T:[%i]/[%i] V:%i%%"),
                         m_frame->m_basestatus.c_str(),
-                        slider->GetValue(),
-                        wxGetMediaStateText(mediactrl->GetState()),
-                        ((wxMediaPlayerNotebookPage*)m_frame->m_notebook->GetCurrentPage())->m_nLoops,
-                        (int)mediactrl->GetDownloadProgress(),
-                        (int)mediactrl->GetDownloadTotal(),
-                        (int)(mediactrl->GetVolume() * 100)));
+                        currentpage->m_slider->GetValue(),
+                        wxGetMediaStateText(currentpage->m_mediactrl->GetState()),
+                        currentpage->m_nLoops,
+                        (int)currentpage->m_mediactrl->GetDownloadProgress(),
+                        (int)currentpage->m_mediactrl->GetDownloadTotal(),
+                        (int)(currentpage->m_mediactrl->GetVolume() * 100)));
 #endif // wxUSE_STATUSBAR
     }
@@ -1479,9 +1499,9 @@
 // along with some sizers for positioning
 // ----------------------------------------------------------------------------
-
 wxMediaPlayerNotebookPage::wxMediaPlayerNotebookPage(wxMediaPlayerFrame* parentFrame,
                                                      wxNotebook* theBook,
                                                      const wxString& szBackend)
                          : wxPanel(theBook, wxID_ANY),
+                           m_nLastFileId(-1),
                            m_nLoops(0),
                            m_bLoop(false),
@@ -1564,28 +1584,4 @@
 
     //
-    //  Here we load the our configuration -
-    //  in our case we load all the files that were left in
-    //  the playlist the last time the user closed our application
-    //
-    //  TODO:  This is probably not the best practice since
-    //  the user will load multiple notebook pages with multiple
-    //  wxMediaCtrl elements.
-    //
-    //  As an exercise to the reader try modifying it so that
-    //  it properly loads the playlist for each page without
-    //  conflicting (loading the same data) with the other ones.
-    //
-    wxConfigBase* conf = wxConfigBase::Get();
-    wxString key, outstring;
-    for(int i = 0; ; ++i)
-    {
-        key.clear();
-        key << i;
-        if(!conf->Read(key, &outstring))
-            break;
-        m_playlist->AddToPlayList(outstring);
-    }
-
-    //
     //  Create the control buttons
     //  TODO/FIXME/HACK:  This part about sizers is really a nice hack
@@ -1602,10 +1598,10 @@
     m_vuButton = new wxButton();
 
-    m_prevButton->Create(this, wxID_BUTTONPREV, _T("|<"));
-    m_playButton->Create(this, wxID_BUTTONPLAY, _T(">"));
-    m_stopButton->Create(this, wxID_BUTTONSTOP, _T("[]"));
-    m_nextButton->Create(this, wxID_BUTTONNEXT, _T(">|"));
-    m_vdButton->Create(this, wxID_BUTTONVD, _T("(("));
-    m_vuButton->Create(this, wxID_BUTTONVU, _T("))"));
+    m_prevButton->Create(this, wxID_BUTTONPREV, wxT("|<"));
+    m_playButton->Create(this, wxID_BUTTONPLAY, wxT(">"));
+    m_stopButton->Create(this, wxID_BUTTONSTOP, wxT("[]"));
+    m_nextButton->Create(this, wxID_BUTTONNEXT, wxT(">|"));
+    m_vdButton->Create(this, wxID_BUTTONVD, wxT("(("));
+    m_vuButton->Create(this, wxID_BUTTONVU, wxT("))"));
     vertsizer->Add(m_prevButton, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);
     vertsizer->Add(m_playButton, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);
@@ -1736,5 +1732,5 @@
         {
             wxMessageBox(wxT("Couldn't loop movie!"));
-            m_playlist->SetItem(m_parentFrame->m_nLastFileId, 0, _T("E"));
+            m_playlist->SetItem(m_nLastFileId, 0, wxT("E"));
         }
         else
@@ -1743,5 +1739,5 @@
     else
     {
-        m_playlist->SetItem(m_parentFrame->m_nLastFileId, 0, _T("[]"));
+        m_playlist->SetItem(m_nLastFileId, 0, wxT("[]"));
     }
 }

 	  	 
