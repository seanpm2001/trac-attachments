Index: include/wx/combobox.h
===================================================================
RCS file: /spd/src/photon/wxwin/include/wx/combobox.h,v
retrieving revision 1.1.1.2
retrieving revision 1.2
diff -u -r1.1.1.2 -r1.2
--- include/wx/combobox.h	12 Mar 2002 16:43:19 -0000	1.1.1.2
+++ include/wx/combobox.h	20 Aug 2002 17:11:21 -0000	1.2
@@ -38,6 +38,7 @@
     virtual long GetInsertionPoint() const = 0;
     virtual long GetLastPosition() const = 0;
     virtual void Replace(long from, long to, const wxString& value) = 0;
+    virtual void GetSelection(long* from, long* to) const = 0;
     virtual void SetSelection(long from, long to) = 0;
     virtual void SetEditable(bool editable) = 0;
 
Index: include/wx/dialog.h
===================================================================
RCS file: /spd/src/photon/wxwin/include/wx/dialog.h,v
retrieving revision 1.1.1.2
retrieving revision 1.2
diff -u -r1.1.1.2 -r1.2
--- include/wx/dialog.h	12 Mar 2002 16:43:30 -0000	1.1.1.2
+++ include/wx/dialog.h	31 Jul 2002 23:01:13 -0000	1.2
@@ -19,6 +19,7 @@
 #include "wx/defs.h"
 #include "wx/containr.h"
 #include "wx/toplevel.h"
+#include "wx/log.h"
 
 // FIXME - temporary hack in absence of wxTLW !!
 #ifndef wxTopLevelWindowNative
@@ -36,7 +37,7 @@
 
     // the modal dialogs have a return code - usually the id of the last
     // pressed button
-    void SetReturnCode(int returnCode) { m_returnCode = returnCode; }
+    virtual void SetReturnCode(int returnCode) { m_returnCode = returnCode; }
     int GetReturnCode() const { return m_returnCode; }
 
 #if wxUSE_STATTEXT && wxUSE_TEXTCTRL
Index: include/wx/event.h
===================================================================
RCS file: /spd/src/photon/wxwin/include/wx/event.h,v
retrieving revision 1.1.1.2
retrieving revision 1.2.14.1
diff -u -r1.1.1.2 -r1.2.14.1
--- include/wx/event.h	12 Mar 2002 16:43:34 -0000	1.1.1.2
+++ include/wx/event.h	9 Oct 2002 16:15:50 -0000	1.2.14.1
@@ -160,6 +160,7 @@
     DECLARE_EVENT_TYPE(wxEVT_KILL_FOCUS, 113)
     DECLARE_EVENT_TYPE(wxEVT_CHILD_FOCUS, 114)
     DECLARE_EVENT_TYPE(wxEVT_MOUSEWHEEL, 115)
+    DECLARE_EVENT_TYPE(wxEVT_MOUSE_MONITOR, 116)
 
         // Non-client mouse events
     DECLARE_EVENT_TYPE(wxEVT_NC_LEFT_DOWN, 200)
@@ -181,6 +182,7 @@
     DECLARE_EVENT_TYPE(wxEVT_NAVIGATION_KEY, 214)
     DECLARE_EVENT_TYPE(wxEVT_KEY_DOWN, 215)
     DECLARE_EVENT_TYPE(wxEVT_KEY_UP, 216)
+    DECLARE_EVENT_TYPE(wxEVT_KEY_MONITOR, 217)
 
         // Set cursor event
     DECLARE_EVENT_TYPE(wxEVT_SET_CURSOR, 230)
@@ -1056,17 +1058,28 @@
 class WXDLLEXPORT wxMenuEvent : public wxEvent
 {
 public:
-    wxMenuEvent(wxEventType type = wxEVT_NULL, int id = 0)
-      { m_eventType = type; m_menuId = id; m_id = id; }
+    wxMenuEvent(wxEventType type = wxEVT_NULL, int id = 0, wxMenu *menu = 0)
+        : wxEvent(id, type)
+        { m_menuId = id;  m_menu = menu; }
+    wxMenuEvent(const wxMenuEvent & event)
+        : wxEvent(event)
+	{ m_menuId = event.m_menuId; m_menu = event.m_menu; }
 
+    // only for wxEVT_MENU_HIGHLIGHT
     int GetMenuId() const { return m_menuId; }
 
+    // only for wxEVT_MENU_OPEN/CLOSE
+    bool IsPopup() const { return m_menuId == -1; }
+
+    // only for wxEVT_POPUP_MENU_INIT
+    wxMenu *GetMenu() const { return m_menu; }
+
     virtual wxEvent *Clone() const { return new wxMenuEvent(*this); }
 
 private:
     int m_menuId;
+    wxMenu *m_menu;
 
-private:
     DECLARE_DYNAMIC_CLASS(wxMenuEvent)
 };
 
@@ -1955,7 +1968,9 @@
 #define EVT_CHAR(func)  DECLARE_EVENT_TABLE_ENTRY( wxEVT_CHAR, -1, -1, (wxObjectEventFunction) (wxEventFunction) (wxCharEventFunction) & func, (wxObject *) NULL ),
 #define EVT_KEY_DOWN(func)  DECLARE_EVENT_TABLE_ENTRY( wxEVT_KEY_DOWN, -1, -1, (wxObjectEventFunction) (wxEventFunction) (wxCharEventFunction) & func, (wxObject *) NULL ),
 #define EVT_KEY_UP(func)  DECLARE_EVENT_TABLE_ENTRY( wxEVT_KEY_UP, -1, -1, (wxObjectEventFunction) (wxEventFunction) (wxCharEventFunction) & func, (wxObject *) NULL ),
+#define EVT_KEY_MONITOR(func)  DECLARE_EVENT_TABLE_ENTRY( wxEVT_KEY_MONITOR, -1, -1, (wxObjectEventFunction) (wxEventFunction) (wxCharEventFunction) & func, (wxObject *) NULL ),
 #define EVT_CHAR_HOOK(func)  DECLARE_EVENT_TABLE_ENTRY( wxEVT_CHAR_HOOK, -1, -1, (wxObjectEventFunction) (wxEventFunction) (wxCharEventFunction) & func, NULL ),
+#define EVT_MENU_POPUP(func)  DECLARE_EVENT_TABLE_ENTRY( wxEVT_POPUP_MENU_INIT, -1, -1, (wxObjectEventFunction) (wxEventFunction) (wxMenuEventFunction) & func, (wxObject *) NULL ),
 #define EVT_MENU_HIGHLIGHT(id, func)  DECLARE_EVENT_TABLE_ENTRY( wxEVT_MENU_HIGHLIGHT, id, -1, (wxObjectEventFunction) (wxEventFunction) (wxMenuEventFunction) & func, (wxObject *) NULL ),
 #define EVT_MENU_HIGHLIGHT_ALL(func)  DECLARE_EVENT_TABLE_ENTRY( wxEVT_MENU_HIGHLIGHT, -1, -1, (wxObjectEventFunction) (wxEventFunction) (wxMenuEventFunction) & func, (wxObject *) NULL ),
 #define EVT_SET_FOCUS(func)  DECLARE_EVENT_TABLE_ENTRY( wxEVT_SET_FOCUS, -1, -1, (wxObjectEventFunction) (wxEventFunction) (wxFocusEventFunction) & func, (wxObject *) NULL ),
@@ -1992,6 +2007,7 @@
 #define EVT_LEAVE_WINDOW(func) DECLARE_EVENT_TABLE_ENTRY( wxEVT_LEAVE_WINDOW, -1, -1, (wxObjectEventFunction) (wxEventFunction) (wxMouseEventFunction) & func, (wxObject *) NULL ),
 #define EVT_ENTER_WINDOW(func) DECLARE_EVENT_TABLE_ENTRY( wxEVT_ENTER_WINDOW, -1, -1, (wxObjectEventFunction) (wxEventFunction) (wxMouseEventFunction) & func, (wxObject *) NULL ),
 #define EVT_MOUSEWHEEL(func) DECLARE_EVENT_TABLE_ENTRY( wxEVT_MOUSEWHEEL, -1, -1, (wxObjectEventFunction) (wxEventFunction) (wxMouseEventFunction) & func, (wxObject *) NULL ),
+#define EVT_MOUSE_MONITOR(func) DECLARE_EVENT_TABLE_ENTRY( wxEVT_MOUSE_MONITOR, -1, -1, (wxObjectEventFunction) (wxEventFunction) (wxMouseEventFunction) & func, (wxObject *) NULL ),
 
 // All mouse events
 #define EVT_MOUSE_EVENTS(func) \
Index: include/wx/ownerdrw.h
===================================================================
RCS file: /spd/src/photon/wxwin/include/wx/ownerdrw.h,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -r1.1.1.1 -r1.2
--- include/wx/ownerdrw.h	17 Sep 2001 23:30:36 -0000	1.1.1.1
+++ include/wx/ownerdrw.h	2 Oct 2002 23:08:34 -0000	1.2
@@ -4,7 +4,7 @@
 // Author:      Vadim Zeitlin
 // Modified by:
 // Created:     11.11.97
-// RCS-ID:      $Id: ownerdrw.h,v 1.15 2001/05/21 23:58:58 VZ Exp $
+// RCS-ID:      $Id: ownerdrw.h,v 1.17 2002/09/02 19:15:40 GD Exp $
 // Copyright:   (c) 1998 Vadim Zeitlin <zeitlin@dptmaths.ens-cachan.fr>
 // Licence:     wxWindows license
 ///////////////////////////////////////////////////////////////////////////////
@@ -14,7 +14,7 @@
 
 #if wxUSE_OWNER_DRAWN
 
-#ifdef    __GNUG__
+#if defined(__GNUG__) && !defined(__APPLE__)
     #pragma interface "ownerdrw.h"
 #endif
 
@@ -116,12 +116,17 @@
 
   enum wxODStatus
   {
-    wxODSelected  = 0x0001,         // control is currently selected
-    wxODGrayed    = 0x0002,         // item is to be grayed
-    wxODDisabled  = 0x0004,         // item is to be drawn as disabled
-    wxODChecked   = 0x0008,         // item is to be checked
-    wxODHasFocus  = 0x0010,         // item has the keyboard focus
-    wxODDefault   = 0x0020          // item is the default item
+    wxODSelected      = 0x0001,   // control is currently selected
+    wxODGrayed        = 0x0002,   // item is to be grayed
+    wxODDisabled      = 0x0004,   // item is to be drawn as disabled
+    wxODChecked       = 0x0008,   // item is to be checked
+    wxODHasFocus      = 0x0010,   // item has the keyboard focus
+    wxODDefault       = 0x0020,   // item is the default item
+    wxODHotlight      = 0x0040,   // item is being hot-tracked
+    wxODInactive      = 0x0080,   // item is inactive
+    wxODNoAccel       = 0x0100,   // item is to be drawn without keyboard accelerator cues
+    wxODNoFocusRect   = 0x0200,   // item is to be drawn without focus indicator cues
+    wxODComboBoxEdit  = 0x1000    // item is edit field in owner-drawn combo
   };
 
   // virtual functions to implement drawing (return TRUE if processed)
@@ -146,6 +151,7 @@
             m_bmpUnchecked; // (checked is used also for 'uncheckable' items)
 
   size_t    m_nHeight,      // font height
+            m_nMinHeight,   // minimum height, as determined by user's system settings
             m_nMarginWidth; // space occupied by bitmap to the left of the item
 };
 
Index: include/wx/window.h
===================================================================
RCS file: /spd/src/photon/wxwin/include/wx/window.h,v
retrieving revision 1.1.1.2
retrieving revision 1.3
diff -u -r1.1.1.2 -r1.3
--- include/wx/window.h	12 Mar 2002 16:44:26 -0000	1.1.1.2
+++ include/wx/window.h	9 Sep 2002 22:57:03 -0000	1.3
@@ -307,6 +307,7 @@
 
     bool IsShown() const { return m_isShown; }
     bool IsEnabled() const { return m_isEnabled; }
+    bool IsMenuActive() const { return m_isMenuActive; }
 
         // get/set window style (setting style won't update the window and so
         // is only useful for internal usage)
@@ -668,7 +669,7 @@
         // attach a tooltip to the window
     void SetToolTip( wxToolTip *tip ) { DoSetToolTip(tip); }
         // get the associated tooltip or NULL if none
-    wxToolTip* GetToolTip() const { return m_tooltip; }
+    virtual wxToolTip* GetToolTip() const { return m_tooltip; }
 #endif // wxUSE_TOOLTIPS
 
     // drag and drop
@@ -822,6 +823,7 @@
     bool                 m_isShown:1;
     bool                 m_isEnabled:1;
     bool                 m_isBeingDeleted:1;
+    bool                 m_isMenuActive:1;
 
     // was the window colours/font explicitly changed by user?
     bool                 m_hasBgCol:1;
Index: include/wx/gtk/combobox.h
===================================================================
RCS file: /spd/src/photon/wxwin/include/wx/gtk/combobox.h,v
retrieving revision 1.1.1.2
retrieving revision 1.3
diff -u -r1.1.1.2 -r1.3
--- include/wx/gtk/combobox.h	12 Mar 2002 16:44:54 -0000	1.1.1.2
+++ include/wx/gtk/combobox.h	20 Aug 2002 17:11:27 -0000	1.3
@@ -103,6 +103,7 @@
     long GetLastPosition() const;
     void Replace( long from, long to, const wxString& value );
     void Remove( long from, long to );
+    void GetSelection(long* from, long* to) const;
     void SetSelection( long from, long to );
     void SetEditable( bool editable );
   
Index: include/wx/gtk/frame.h
===================================================================
RCS file: /spd/src/photon/wxwin/include/wx/gtk/frame.h,v
retrieving revision 1.1.1.2
retrieving revision 1.2
diff -u -r1.1.1.2 -r1.2
--- include/wx/gtk/frame.h	12 Mar 2002 16:45:00 -0000	1.1.1.2
+++ include/wx/gtk/frame.h	4 Apr 2002 23:24:07 -0000	1.2
@@ -86,6 +86,10 @@
     bool          m_menuBarDetached;
     bool          m_toolBarDetached;
 
+    // dynamically set whether this window stays on top of all others
+    // This is a no-op for now - malmer
+    void StayOnTop(bool stayOnTop) {}
+
 protected:
     // common part of all ctors
     void Init();
Index: include/wx/gtk/tooltip.h
===================================================================
RCS file: /spd/src/photon/wxwin/include/wx/gtk/tooltip.h,v
retrieving revision 1.1.1.2
retrieving revision 1.4
diff -u -r1.1.1.2 -r1.4
--- include/wx/gtk/tooltip.h	12 Mar 2002 16:45:19 -0000	1.1.1.2
+++ include/wx/gtk/tooltip.h	26 Sep 2002 04:31:41 -0000	1.4
@@ -22,6 +22,7 @@
 // forward declarations
 //-----------------------------------------------------------------------------
 
+class wxOwnerDrawn;
 class wxToolTip;
 class wxWindow;
 
@@ -48,9 +49,40 @@
     // implementation
     void Apply( wxWindow *win );
 
+    //ownerdraw methods
+	bool IsShown() { return false; }
+    void SetOwnerDrawn(wxOwnerDrawn *ownerdrawn)
+    {
+        m_ownerdrawn = ownerdrawn;
+    }
+    bool IsOwnerDrawn()
+    {
+        return (false);
+    }
+    void GetOwnerdrawnSize(unsigned int *width, unsigned int *height)
+    {
+        *width = 0;
+        *height = 0;
+    }
+    void Draw(wxDC &hdc, const wxRect &rect)
+    {
+        return;
+    }
+    void Update()
+    {
+        return;
+    }
+
+    void SetWindow(wxWindow *win)
+    {
+        return;
+    }
+
+
 private:
     wxString     m_text;
     wxWindow    *m_window;
+    wxOwnerDrawn *m_ownerdrawn;
 
     DECLARE_ABSTRACT_CLASS(wxToolTip)
 };
Index: include/wx/mac/frame.h
===================================================================
RCS file: /spd/src/photon/wxwin/include/wx/mac/frame.h,v
retrieving revision 1.1.1.2
retrieving revision 1.2
diff -u -r1.1.1.2 -r1.2
--- include/wx/mac/frame.h	12 Mar 2002 16:46:05 -0000	1.1.1.2
+++ include/wx/mac/frame.h	22 Mar 2002 19:19:21 -0000	1.2
@@ -100,6 +100,9 @@
     void SetToolTipCtrl(wxMacToolTip *tt) { m_hwndToolTip = tt; }
     wxMacToolTip* m_hwndToolTip ;
 #endif // tooltips
+
+    // dynamically set whether this window stays ontop of all others or not
+    void StayOnTop(bool stayOnTop) {}
 
 protected:
     // common part of all ctors
Index: include/wx/mac/stattext.h
===================================================================
RCS file: /spd/src/photon/wxwin/include/wx/mac/stattext.h,v
retrieving revision 1.1.1.2
retrieving revision 1.4.8.1
diff -u -r1.1.1.2 -r1.4.8.1
--- include/wx/mac/stattext.h	12 Mar 2002 16:46:27 -0000	1.1.1.2
+++ include/wx/mac/stattext.h	11 Oct 2002 00:46:11 -0000	1.4.8.1
@@ -41,11 +41,14 @@
 
   // accessors
   void SetLabel( const wxString &str ) ;
+  bool SetFont( const wxFont &font );
+  wxString GetLabel() {return m_label;} ;
+
   // operations
   virtual void Command(wxCommandEvent& WXUNUSED(event)) {};
   virtual void ProcessCommand(wxCommandEvent& WXUNUSED(event)) {};
   // events
-  void DrawParagraph(wxDC &dc, wxString paragraph);
+  void DrawParagraph(wxDC &dc, wxString paragraph, int &y);
   void OnPaint( wxPaintEvent &event ) ;
   void OnDraw( wxDC &dc ) ;
   virtual wxSize DoGetBestSize() const ;
Index: include/wx/mac/tooltip.h
===================================================================
RCS file: /spd/src/photon/wxwin/include/wx/mac/tooltip.h,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -r1.1.1.1 -r1.3
--- include/wx/mac/tooltip.h	17 Sep 2001 23:31:21 -0000	1.1.1.1
+++ include/wx/mac/tooltip.h	26 Sep 2002 04:32:14 -0000	1.3
@@ -9,6 +9,7 @@
 // Licence:     wxWindows license
 ///////////////////////////////////////////////////////////////////////////////
 
+class wxOwnerDrawn;
 
 class wxToolTip : public wxObject
 {
@@ -40,8 +41,33 @@
     static void RelayEvent(wxWindow *win , wxMouseEvent &event);
     static void RemoveToolTips();
 
+    //ownerdraw methods
+	bool IsShown() { return false; }
+    void SetOwnerDrawn(wxOwnerDrawn *ownerdrawn)
+    {
+        m_ownerdrawn = ownerdrawn;
+    } 
+    bool IsOwnerDrawn()
+    {
+        return (false);
+    } 
+    void GetOwnerdrawnSize(unsigned int *width, unsigned int *height)
+    {
+        *width = 0;
+        *height = 0;
+    }
+    void Draw(wxDC &hdc, const wxRect &rect)
+    {
+        return;
+    }    
+    void Update()
+    {
+        return;
+    }
+
 private:
     wxString  m_text;           // tooltip text
     wxWindow *m_window;         // window we're associated with
+    wxOwnerDrawn *m_ownerdrawn;
 };
 
Index: include/wx/motif/frame.h
===================================================================
RCS file: /spd/src/photon/wxwin/include/wx/motif/frame.h,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -r1.1.1.1 -r1.2
--- include/wx/motif/frame.h	17 Sep 2001 23:31:25 -0000	1.1.1.1
+++ include/wx/motif/frame.h	22 Mar 2002 19:19:50 -0000	1.2
@@ -103,6 +103,9 @@
     bool GetVisibleStatus() const { return m_visibleStatus; }
 
     bool PreResize();
+
+    // dynamically set whether this window stays ontop of all others or not
+    void StayOnTop(bool stayOnTop) {}
 
 protected:
     // common part of all ctors
 
Index: include/wx/msw/frame.h
===================================================================
RCS file: /spd/src/photon/wxwin/include/wx/msw/frame.h,v
retrieving revision 1.1.1.2
retrieving revision 1.3.2.1
diff -u -r1.1.1.2 -r1.3.2.1
--- include/wx/msw/frame.h	12 Mar 2002 16:47:19 -0000	1.1.1.2
+++ include/wx/msw/frame.h	9 Oct 2002 16:15:54 -0000	1.3.2.1
@@ -90,7 +90,11 @@
     bool HandlePaint();
     bool HandleSize(int x, int y, WXUINT flag);
     bool HandleCommand(WXWORD id, WXWORD cmd, WXHWND control);
+    bool HandleMenuPopup(WXHMENU hMenu);
     bool HandleMenuSelect(WXWORD nItem, WXWORD nFlags, WXHMENU hMenu);
+#if wxUSE_MENUS && wxUSE_OWNER_DRAWN
+    bool HandleMenuChar(int ch, WXWORD type, WXHMENU hMenu, WXLPARAM *result);
+#endif // wxUSE_MENUS && wxUSE_OWNER_DRAWN
 
     // tooltip management
 #if wxUSE_TOOLTIPS
@@ -101,6 +105,9 @@
     // a MSW only function which sends a size event to the window using its
     // current size - this has an effect of refreshing the window layout
     void SendSizeEvent();
+
+    // dynamically set whether this window stays ontop of all others or not
+    void StayOnTop(bool stayOnTop);
 
     // called by wxWindow whenever it gets focus
     void SetLastFocus(wxWindow *win) { m_winLastFocused = win; }
Index: include/wx/msw/menu.h
===================================================================
RCS file: /spd/src/photon/wxwin/include/wx/msw/menu.h,v
retrieving revision 1.1.1.2
retrieving revision 1.2
diff -u -r1.1.1.2 -r1.2
--- include/wx/msw/menu.h	12 Mar 2002 16:47:28 -0000	1.1.1.2
+++ include/wx/msw/menu.h	2 Oct 2002 23:08:41 -0000	1.2
@@ -71,6 +71,9 @@
         // get the menu handle
     WXHMENU GetHMenu() const { return m_hMenu; }
 
+    // find the wxMenu for a given HMENU (returns NULL if not found)
+    wxMenu *FindHMenu(WXHMENU hmenu);
+
 #if wxUSE_ACCEL
     // called by wxMenuBar to build its accel table from the accels of all menus
     bool HasAccels() const { return !m_accels.IsEmpty(); }
@@ -149,7 +152,7 @@
     // get the accel table for all the menus
     const wxAcceleratorTable& GetAccelTable() const { return m_accelTable; }
 
-    // update the accel table (must be called after adding/deletign a menu)
+    // update the accel table (must be called after adding/deleting a menu)
     void RebuildAccelTable();
 #endif // wxUSE_ACCEL
 
Index: include/wx/msw/tooltip.h
===================================================================
RCS file: /spd/src/photon/wxwin/include/wx/msw/tooltip.h,v
retrieving revision 1.1.1.2
retrieving revision 1.3
diff -u -r1.1.1.2 -r1.3
--- include/wx/msw/tooltip.h	12 Mar 2002 16:47:53 -0000	1.1.1.2
+++ include/wx/msw/tooltip.h	26 Sep 2002 04:32:39 -0000	1.3
@@ -9,6 +9,8 @@
 // Licence:     wxWindows license
 ///////////////////////////////////////////////////////////////////////////////
 
+class wxOwnerDrawn;
+
 class WXDLLEXPORT wxToolTip : public wxObject
 {
 public:
@@ -17,14 +19,23 @@
     virtual ~wxToolTip();
 
     // accessors
-        // tip text
+    // tip text
     void SetTip(const wxString& tip);
     const wxString& GetTip() const { return m_text; }
 
-        // the window we're associated with
+        // the window we're associated with        
     void SetWindow(wxWindow *win);
     wxWindow *GetWindow() const { return m_window; }
+	
+	bool IsShown();
 
+    //ownerdraw methods
+    void SetOwnerDrawn(wxOwnerDrawn *ownerdrawn); 
+    bool IsOwnerDrawn(); 
+    void GetOwnerdrawnSize(unsigned int *width, unsigned int *height);
+    void Draw(wxDC &hdc, const wxRect &rect);    
+    void Update();
+     
     // controlling tooltip behaviour: globally change tooltip parameters
         // enable or disable the tooltips globally
     static void Enable(bool flag);
@@ -37,22 +48,24 @@
     // should be called in responde to WM_MOUSEMOVE
     void RelayEvent(WXMSG *msg);
 
+    // create the tooltip ctrl if it doesn't exist yet and return its HWND
+    static WXHWND GetToolTipCtrl();
+
 private:
     // the one and only one tooltip control we use - never access it directly
     // but use GetToolTipCtrl() which will create it when needed
     static WXHWND ms_hwndTT;
-
-    // create the tooltip ctrl if it doesn't exist yet and return its HWND
-    static WXHWND GetToolTipCtrl();
-
+    
     // remove this tooltip from the tooltip control
-    void Remove();
+    void Remove();    
+
 
     // add a window to the tooltip control
     void Add(WXHWND hwnd);
 
     wxString  m_text;           // tooltip text
     wxWindow *m_window;         // window we're associated with
+    wxOwnerDrawn *m_ownerdrawn;      
 
     DECLARE_ABSTRACT_CLASS(wxToolTip)
 };
Index: src/common/event.cpp
===================================================================
RCS file: /spd/src/photon/wxwin/src/common/event.cpp,v
retrieving revision 1.1.1.2
retrieving revision 1.4
diff -u -r1.1.1.2 -r1.4
--- src/common/event.cpp	12 Mar 2002 16:36:59 -0000	1.1.1.2
+++ src/common/event.cpp	13 Aug 2002 23:04:44 -0000	1.4
@@ -154,6 +154,7 @@
 DEFINE_EVENT_TYPE(wxEVT_KILL_FOCUS)
 DEFINE_EVENT_TYPE(wxEVT_CHILD_FOCUS)
 DEFINE_EVENT_TYPE(wxEVT_MOUSEWHEEL)
+DEFINE_EVENT_TYPE(wxEVT_MOUSE_MONITOR)
 
 // Non-client mouse events
 DEFINE_EVENT_TYPE(wxEVT_NC_LEFT_DOWN)
@@ -175,6 +176,7 @@
 DEFINE_EVENT_TYPE(wxEVT_NAVIGATION_KEY)
 DEFINE_EVENT_TYPE(wxEVT_KEY_DOWN)
 DEFINE_EVENT_TYPE(wxEVT_KEY_UP)
+DEFINE_EVENT_TYPE(wxEVT_KEY_MONITOR)
 
 // Set cursor event
 DEFINE_EVENT_TYPE(wxEVT_SET_CURSOR)
Index: src/common/menucmn.cpp
===================================================================
RCS file: /spd/src/photon/wxwin/src/common/menucmn.cpp,v
retrieving revision 1.1.1.2
retrieving revision 1.3
diff -u -r1.1.1.2 -r1.3
--- src/common/menucmn.cpp	12 Mar 2002 16:37:16 -0000	1.1.1.2
+++ src/common/menucmn.cpp	23 Sep 2002 23:04:46 -0000	1.3
@@ -99,7 +99,14 @@
         else {
             if ( current.Len() == 1 ) {
                 // it's a letter
-                keyCode = wxToupper(current[0U]);
+                keyCode = current[0U];
+
+                // Only call wxToupper if control, alt, or shift is
+                // held down.  Otherwise, lower case accelerators
+                // won't work.
+                if (accelFlags != wxACCEL_NORMAL) {
+                    keyCode = wxToupper(keyCode);
+                }
             }
             else {
                 // is it a function key?
@@ -324,6 +331,9 @@
     if ( submenu )
     {
         submenu->SetParent((wxMenu *)NULL);
+        if (submenu->IsAttached()) {
+            submenu->Detach();
+        }
     }
 
     return item;
Index: src/common/wincmn.cpp
===================================================================
RCS file: /spd/src/photon/wxwin/src/common/wincmn.cpp,v
retrieving revision 1.1.1.2
retrieving revision 1.4
diff -u -r1.1.1.2 -r1.4
--- src/common/wincmn.cpp	12 Mar 2002 16:37:32 -0000	1.1.1.2
+++ src/common/wincmn.cpp	9 Sep 2002 22:57:13 -0000	1.4
@@ -114,6 +114,7 @@
     // window is created enabled but it's not visible yet
     m_isShown = FALSE;
     m_isEnabled = TRUE;
+    m_isMenuActive = FALSE;
 
     // the default event handler is just this window
     m_eventHandler = this;
Index: src/gtk/combobox.cpp
===================================================================
RCS file: /spd/src/photon/wxwin/src/gtk/combobox.cpp,v
retrieving revision 1.1.1.2
retrieving revision 1.3
diff -u -r1.1.1.2 -r1.3
--- src/gtk/combobox.cpp	12 Mar 2002 16:38:39 -0000	1.1.1.2
+++ src/gtk/combobox.cpp	20 Aug 2002 17:12:15 -0000	1.3
@@ -569,6 +569,18 @@
 
     GtkWidget *entry = GTK_COMBO(m_widget)->entry;
     gtk_editable_delete_text( GTK_EDITABLE(entry), (gint)from, (gint)to );
+}
+
+void wxComboBox::GetSelection(long* from, long* to) const
+{
+    // TODO: untested, written on Windows
+#if 1
+    GtkWidget *entry = GTK_COMBO(m_widget)->entry;
+
+    // HACK: for GTK2, could just call gtk_editable_get_selection_bounds()
+    *from = GTK_EDITABLE(entry)->selection_start_pos;
+    *to = GTK_EDITABLE(entry)->selection_end_pos;
+#endif
 }
 
 void wxComboBox::SetSelection( long from, long to )
Index: src/gtk/toplevel.cpp
===================================================================
RCS file: /spd/src/photon/wxwin/src/gtk/toplevel.cpp,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -r1.1.1.1 -r1.2
--- src/gtk/toplevel.cpp	12 Mar 2002 16:38:56 -0000	1.1.1.1
+++ src/gtk/toplevel.cpp	9 Aug 2002 17:10:43 -0000	1.2
@@ -821,7 +821,7 @@
 
 void wxTopLevelWindowGTK::Restore()
 {
-    wxFAIL_MSG( _T("not implemented") );
+    gdk_window_show(m_widget->window);
 }
 
 void wxTopLevelWindowGTK::Iconize( bool iconize )
Index: src/mac/msgdlg.cpp
===================================================================
RCS file: /spd/src/photon/wxwin/src/mac/msgdlg.cpp,v
retrieving revision 1.1.1.2
retrieving revision 1.2
diff -u -r1.1.1.2 -r1.2
--- src/mac/msgdlg.cpp	12 Mar 2002 16:39:46 -0000	1.1.1.2
+++ src/mac/msgdlg.cpp	14 Mar 2002 03:51:55 -0000	1.2
@@ -93,7 +93,7 @@
 	}
 
 	wxMacConvertNewlines( cText , cText ) ;
-	CopyCStringToPascal( cText , pascalText ) ;
+	wxMacStringToPascal(cText, pascalText, false);
 
 	wxASSERT_MSG( ( m_dialogStyle & 0x3F ) != wxYES , "this style is not supported on mac" ) ;
 
Index: src/mac/stattext.cpp
===================================================================
RCS file: /spd/src/photon/wxwin/src/mac/stattext.cpp,v
retrieving revision 1.1.1.2
retrieving revision 1.6
diff -u -r1.1.1.2 -r1.6
--- src/mac/stattext.cpp	12 Mar 2002 16:39:54 -0000	1.1.1.2
+++ src/mac/stattext.cpp	17 Sep 2002 22:24:37 -0000	1.6
@@ -52,19 +52,30 @@
     m_label = label ;
 
 	bool ret = wxControl::Create( parent, id, pos, size, style , wxDefaultValidator , name );
-	SetBestSize( size ) ;
-    
+    SetBestSize( size ) ;
+
+    /* default font to Lucida Grande - for nicer anti-aliasing with Quartz */
+    SetFont(wxFont(11, wxSWISS, wxNORMAL, wxNORMAL, FALSE, "Lucida Grande"));    
     return ret;
 }
 
 const wxString punct = " ,.-;:!?";
 
-void wxStaticText::DrawParagraph(wxDC &dc, wxString paragraph)
+void wxStaticText::DrawParagraph(wxDC &dc, wxString paragraph, int &y)
 {
+  long width, height ;
+    
+    if (paragraph.Length() == 0)
+    {
+        // empty line
+        dc.GetTextExtent( "H", &width, &height );
+        y += height;
+        
+        return;
+    }  
   int x = 0 ;
-  int y = 0 ;
+  
   int i = 0 ;
-  long width, height ;
   bool linedrawn = true;
   while( paragraph.Length() > 0 )
   {
@@ -165,20 +176,23 @@
 			} 
 		}
 	}
-	if ( doClear )
-		dc.Clear() ;
 		
+    int y = 0 ;
 	while (i < text.Length())
 	{
-	  paragraph += text[i];
-	  
   	if (text[i] == 13 || text[i] == 10)
-	    DrawParagraph(dc, paragraph);
-	    
+        {
+            DrawParagraph(dc, paragraph,y);
+            paragraph = "" ;
+        }
+        else
+        {
+            paragraph += text[i];
+        }
     ++i;
   }
   if (paragraph.Length() > 0)
-	  DrawParagraph(dc, paragraph);
+        DrawParagraph(dc, paragraph,y);
 }
 
 void wxStaticText::OnPaint( wxPaintEvent &event ) 
@@ -189,7 +203,6 @@
 
 wxSize wxStaticText::DoGetBestSize() const
 {
-	int x,y ;
     int widthTextMax = 0, widthLine,
         heightTextTotal = 0, heightLineDefault = 0, heightLine = 0;
         
@@ -249,4 +262,16 @@
 	MacUpdateImmediately() ;
 //    wxClientDC dc(this);
 //    OnDraw( dc ) ;
+}
+
+bool wxStaticText::SetFont(const wxFont& font)
+{
+    bool ret = wxControl::SetFont(font);
+
+    // adjust the size of the window to fit to the label unless autoresizing is
+    // disabled
+    if ( !(GetWindowStyle() & wxST_NO_AUTORESIZE) )
+        SetSize( GetBestSize() );
+
+    return ret;
 }
Index: src/mac/timer.cpp
===================================================================
RCS file: /spd/src/photon/wxwin/src/mac/timer.cpp,v
retrieving revision 1.1.1.2
retrieving revision 1.2
diff -u -r1.1.1.2 -r1.2
--- src/mac/timer.cpp	12 Mar 2002 16:39:56 -0000	1.1.1.2
+++ src/mac/timer.cpp	25 Sep 2002 23:55:24 -0000	1.2
@@ -68,8 +68,12 @@
 {
     (void)wxTimerBase::Start(milliseconds, mode);
 
+#if 0
     wxCHECK_MSG( m_milli > 0, FALSE, wxT("invalid value for timer timeour") );
     wxCHECK_MSG( m_info.m_task.tmAddr == NULL , FALSE, wxT("attempting to restart a timer") );
+#else
+    if (m_milli > 0 || m_info.m_task.tmAddr) Stop();
+#endif
 
     m_milli = milliseconds;
 #if defined(UNIVERSAL_INTERFACES_VERSION) && (UNIVERSAL_INTERFACES_VERSION >= 0x0340)
Index: src/msw/frame.cpp
===================================================================
RCS file: /spd/src/photon/wxwin/src/msw/frame.cpp,v
retrieving revision 1.1.1.2
retrieving revision 1.5.2.1
diff -u -r1.1.1.2 -r1.5.2.1
--- src/msw/frame.cpp	12 Mar 2002 16:40:48 -0000	1.1.1.2
+++ src/msw/frame.cpp	9 Oct 2002 16:15:57 -0000	1.5.2.1
@@ -306,6 +306,17 @@
     }
 #endif // wxUSE_STATUSBAR
 
+#if wxUSE_MENUS && wxUSE_OWNER_DRAWN
+    if ( m_frameMenuBar )
+    {
+
+        // TODO: iterate over all child menu items
+        // TODO: for any that are owner-drawn
+        // TODO: change font and color, and re-measure
+        // ALT:  just recreate each one in place?
+    }
+#endif // wxUSE_MENUS && wxUSE_OWNER_DRAWN
+
     // Propagate the event to the non-top-level children
     wxWindow::OnSysColourChanged(event);
 }
@@ -388,6 +399,27 @@
     return wxFrameBase::ShowFullScreen(show, style);
 }
 
+// Make the window appear on top of all other windows if stayOnTop is
+// true.  Update the style bits too.
+void wxFrame::StayOnTop(bool stayOnTop)
+{
+    long wxflags;
+    
+    wxflags = GetWindowStyleFlag();
+    if (stayOnTop) {
+        ::SetWindowPos(GetHwnd(), HWND_TOPMOST, 0, 0, 0, 0, 
+            SWP_NOMOVE | SWP_NOSIZE);
+        wxflags |= wxSTAY_ON_TOP;
+    }
+    else {
+        ::SetWindowPos(GetHwnd(), HWND_NOTOPMOST, 0, 0, 0, 0, 
+            SWP_NOMOVE | SWP_NOSIZE);
+        wxflags &= (~wxSTAY_ON_TOP);
+    }
+    SetWindowStyleFlag(wxflags);	
+
+}
+
 // Default activation behaviour - set the focus for the first child
 // subwindow found.
 void wxFrame::OnActivate(wxActivateEvent& event)
@@ -570,6 +602,20 @@
     if ( !menuBar )
         return FALSE;
 
+    // Don't pass ascii characters to menu accelerators if a text
+    // field has the keyboard focus.
+    MSG* msg = (MSG*)pMsg;
+    if (msg->message == WM_CHAR
+        && isascii(msg->wParam) || msg->wParam == VK_DELETE) {
+        wxWindow* focus = FindFocus();
+        if (focus) {
+            wxTextCtrl* text = wxDynamicCast(focus, wxTextCtrl);
+            if (text) {
+                return FALSE;
+            }
+        }
+    }
+
     const wxAcceleratorTable& acceleratorTable = menuBar->GetAccelTable();
     return acceleratorTable.Translate(this, pMsg);
 #else
@@ -718,6 +764,32 @@
     return FALSE;
 }
 
+bool wxFrame::HandleMenuPopup(WXHMENU hMenu)
+{
+    wxMenu *m = NULL;
+
+    if ( m_frameMenuBar )
+    {
+        int nCount = m_frameMenuBar->GetMenuCount();
+        for (int n = 0; n < nCount; n++)
+        {
+            m = m_frameMenuBar->GetMenu(n)->FindHMenu(hMenu);
+            if (m)
+                break;
+        }
+    }
+
+    if (m)
+    {
+        wxMenuEvent event(wxEVT_POPUP_MENU_INIT, -1, m);
+        event.SetEventObject( this );
+
+        return GetEventHandler()->ProcessEvent(event);
+    }
+
+    return false;
+}
+
 bool wxFrame::HandleMenuSelect(WXWORD nItem, WXWORD flags, WXHMENU hMenu)
 {
     int item;
@@ -755,6 +827,52 @@
     return GetEventHandler()->ProcessEvent(event);
 }
 
+#if wxUSE_MENUS && wxUSE_OWNER_DRAWN
+bool wxFrame::HandleMenuChar(int ch, WXWORD type, WXHMENU hMenu, WXLPARAM *result)
+{
+    if ( m_frameMenuBar )
+    {
+        bool bFound = false;
+        wxMenu *m = NULL;
+
+        int nCount = m_frameMenuBar->GetMenuCount();
+        for (int n = 0; n < nCount; n++)
+        {
+            m = m_frameMenuBar->GetMenu(n)->FindHMenu(hMenu);
+            if (m)
+                break;
+        }
+
+        if (m)
+        {
+            // does this menu have a matching access key?
+            wxMenuItemList::Node* node = m->GetMenuItems().GetFirst();
+            UINT pos = 0;
+            while (node)
+            {
+                wxMenuItem* item = node->GetData();
+                if ( !item->IsSeparator() && item->IsOwnerDrawn() )
+                {
+                    wxString s = item->GetText().Lower();
+                    wxString sub("&");
+                    sub.Append(tolower(ch));
+
+                    if (s.Contains(sub))
+                    {
+                        *result = MAKELRESULT(pos, MNC_EXECUTE);
+                        return TRUE;
+                    }
+                }
+                node = node->GetNext();
+                pos++;
+            }
+        }
+    }
+
+    return FALSE;
+}
+#endif // wxUSE_MENUS && wxUSE_OWNER_DRAWN
+
 // ---------------------------------------------------------------------------
 // the window proc for wxFrame
 // ---------------------------------------------------------------------------
@@ -784,6 +902,10 @@
             break;
 
 #ifndef __WXMICROWIN__
+        case WM_INITMENUPOPUP:
+            processed = HandleMenuPopup((WXHMENU)wParam);
+            break;
+
         case WM_MENUSELECT:
             {
                 WXWORD item, flags;
@@ -792,6 +914,12 @@
 
                 processed = HandleMenuSelect(item, flags, hmenu);
             }
+            break;
+#endif
+
+#if wxUSE_MENUS && wxUSE_OWNER_DRAWN
+        case WM_MENUCHAR:
+            processed = HandleMenuChar((int) LOWORD(wParam), HIWORD(wParam), (WXHMENU)lParam, &rc);
             break;
 #endif
 
Index: src/msw/menu.cpp
===================================================================
RCS file: /spd/src/photon/wxwin/src/msw/menu.cpp,v
retrieving revision 1.1.1.2
retrieving revision 1.3.2.2
diff -u -r1.1.1.2 -r1.3.2.2
--- src/msw/menu.cpp	12 Mar 2002 16:40:59 -0000	1.1.1.2
+++ src/msw/menu.cpp	25 Oct 2002 23:02:01 -0000	1.3.2.2
@@ -185,6 +185,29 @@
 
 #endif // wxUSE_ACCEL
 
+wxMenu *wxMenu::FindHMenu(WXHMENU hmenu)
+{
+    if (hmenu == m_hMenu)
+        return this;
+
+    // check submenus, too
+    for ( wxMenuItemList::Node *node = m_items.GetFirst();
+          node;
+          node = node->GetNext() )
+    {
+        wxMenuItem *item = node->GetData();
+        if ( item->IsSubMenu() )
+        {
+            wxMenu *m = item->GetSubMenu()->FindHMenu(hmenu);
+            if ( m )
+                return m;
+        }
+    }
+
+    // not found
+    return NULL;
+}
+
 // append a new item or submenu to the menu
 bool wxMenu::DoInsertOrAppend(wxMenuItem *pItem, size_t pos)
 {
@@ -433,6 +456,16 @@
     // NB: VC++ generates wrong assembler for `if ( id != idMenuTitle )'!!
     if ( id != (WXWORD)idMenuTitle )
     {
+        wxMenuItem * item = FindItem(id);
+        if (item) {
+            if (!item->IsEnabled())
+                return TRUE;
+
+            // Toggle any checkable item 
+            if (item->IsCheckable())
+                item->Toggle();
+        }
+
         // VZ: previosuly, the command int was set to id too which was quite
         //     useless anyhow (as it could be retrieved using GetId()) and
         //     uncompatible with wxGTK, so now we use the command int instead
Index: src/msw/menuitem.cpp
===================================================================
RCS file: /spd/src/photon/wxwin/src/msw/menuitem.cpp,v
retrieving revision 1.1.1.2
retrieving revision 1.2.2.1
diff -u -r1.1.1.2 -r1.2.2.1
--- src/msw/menuitem.cpp	12 Mar 2002 16:41:00 -0000	1.1.1.2
+++ src/msw/menuitem.cpp	25 Oct 2002 01:32:11 -0000	1.2.2.1
@@ -92,7 +92,7 @@
                        bool bCheckable,
                        wxMenu *pSubMenu)
 #if wxUSE_OWNER_DRAWN
-                       : wxOwnerDrawn(GetLabelFromText(text), bCheckable)
+                       : wxOwnerDrawn(text, bCheckable)
 #endif // owner drawn
 {
     wxASSERT_MSG( pParentMenu != NULL, wxT("a menu item should have a parent") );
Index: src/msw/ownerdrw.cpp
===================================================================
RCS file: /spd/src/photon/wxwin/src/msw/ownerdrw.cpp,v
retrieving revision 1.1.1.2
retrieving revision 1.2.2.1
diff -u -r1.1.1.2 -r1.2.2.1
--- src/msw/ownerdrw.cpp	12 Mar 2002 16:41:02 -0000	1.1.1.2
+++ src/msw/ownerdrw.cpp	9 Oct 2002 16:12:59 -0000	1.2.2.1
@@ -31,9 +31,16 @@
   #include "wx/utils.h"
 #endif
 
+// these are optional Win2K features (_WIN32_WINNT>=0x0500) 
+#ifndef DSS_HIDEPREFIX
+#define DSS_HIDEPREFIX  0x0200
+#define DSS_PREFIXONLY  0x0400
+#endif
+
 #include "wx/settings.h"
 #include "wx/ownerdrw.h"
 #include "wx/menuitem.h"
+#include "wx/fontutil.h"
 
 #if wxUSE_OWNER_DRAWN
 
@@ -48,25 +55,57 @@
                            bool bCheckable, bool WXUNUSED(bMenuItem))
             : m_strName(str)
 {
-  m_bCheckable   = bCheckable;
-  m_bOwnerDrawn  = FALSE;
-  m_nHeight      = 0;
-  m_nMarginWidth = ms_nLastMarginWidth;
-  if (wxNORMAL_FONT)
-    m_font = * wxNORMAL_FONT;
-}
-
 #if defined(__WXMSW__) && defined(__WIN32__) && defined(SM_CXMENUCHECK)
-  size_t wxOwnerDrawn::ms_nDefaultMarginWidth = GetSystemMetrics(SM_CXMENUCHECK);
-#else   // # what is the reasonable default?
-  size_t wxOwnerDrawn::ms_nDefaultMarginWidth = 15;
+    // get the default menu height and font from the system
+    NONCLIENTMETRICS nm;
+    nm.cbSize = sizeof (NONCLIENTMETRICS);
+    SystemParametersInfo (SPI_GETNONCLIENTMETRICS,0,&nm,0); 
+    m_nMinHeight = nm.iMenuHeight;
+    
+    // nm.iMenuWidth is the system default for the width of
+    // menu icons and checkmarks
+    if (ms_nDefaultMarginWidth == 0)
+    {
+       ms_nDefaultMarginWidth = nm.iMenuWidth;
+       ms_nLastMarginWidth = nm.iMenuWidth;
+    }
+
+    wxNativeFontInfo info;
+    memcpy(&info.lf, &nm.lfMenuFont, sizeof(LOGFONT));
+    m_font.Create(info);
+#else
+    // windows clean install default
+    m_nMinHeight = 18;
+    
+    if (ms_nDefaultMarginWidth == 0)
+    {
+        ms_nDefaultMarginWidth = 18;
+        ms_nLastMarginWidth = 18;
+    }
+    if (wxNORMAL_FONT)
+       m_font = *wxNORMAL_FONT;
 #endif
 
-size_t wxOwnerDrawn::ms_nLastMarginWidth = ms_nDefaultMarginWidth;
+    m_bCheckable   = bCheckable;
+    m_bOwnerDrawn  = FALSE;
+    m_nHeight      = 0;
+    m_nMarginWidth = ms_nLastMarginWidth;
+}
+
+
+// these items will be set during the first invocation of the c'tor,
+// because the values will be determined by checking the system settings,
+// which is a chunk of code  
+size_t wxOwnerDrawn::ms_nDefaultMarginWidth = 0;
+size_t wxOwnerDrawn::ms_nLastMarginWidth = 0;
+
 
 // drawing
 // -------
 
+#define RIGHT_MARGIN_PIXELS     20
+#define ACCEL_MARGIN_PIXELS     10
+
 // get size of the item
 bool wxOwnerDrawn::OnMeasureItem(size_t *pwidth, size_t *pheight)
 {
@@ -74,16 +113,28 @@
 
   wxString str = wxStripMenuCodes(m_strName);
 
-  // # without this menu items look too tightly packed (at least under Windows)
-  str += wxT('W'); // 'W' is typically the widest letter
-
   if (m_font.Ok())
       dc.SetFont(GetFont());
 
+  // width = margin + text + right margin
   dc.GetTextExtent(str, (long *)pwidth, (long *)pheight);
 
-  // JACS: items still look too tightly packed, so adding 2 pixels.
-  (*pheight) = (*pheight) + 2;
+  *pwidth += ms_nDefaultMarginWidth + RIGHT_MARGIN_PIXELS;
+
+  if (!m_strAccel.IsEmpty())
+  {
+      // measure the accelerator string, and add it's width to
+      // the total item width, plus 10 (Accelerators are right justified,
+      // with the right edge of the text rectangle 20 pixels left of
+      // the right edge of the menu)
+
+      int accel_width, accel_height;
+      dc.GetTextExtent(m_strAccel, &accel_width, &accel_height);
+      *pwidth += (accel_width + ACCEL_MARGIN_PIXELS);
+  }
+
+  // JACS: items still look too tightly packed, so adding 5 pixels.
+  (*pheight) = (*pheight) + 5;
 
   // Ray Gilbert's changes - Corrects the problem of a BMP
   // being placed next to text in a menu item, and the BMP does
@@ -100,7 +151,7 @@
 
       // Does BMP encroach on default check menu position?
       size_t adjustedWidth = m_bmpChecked.GetWidth() +
-                             (wxSystemSettings::GetSystemMetric(wxSYS_EDGE_X) * 2);
+                             (wxSystemSettings::GetSystemMetric(wxSYS_EDGE_X) * 2) + 5;
       if (ms_nDefaultMarginWidth < adjustedWidth)
           *pwidth += adjustedWidth - ms_nDefaultMarginWidth;
 
@@ -109,6 +160,11 @@
           SetMarginWidth(adjustedWidth);
   }
 
+  // make sure that this item is at least as
+  // tall as the user's system settings specify
+  if (*pheight < m_nMinHeight)
+    *pheight = m_nMinHeight;
+
   m_nHeight = *pheight;                // remember height for use in OnDrawItem
 
   return TRUE;
@@ -126,6 +182,10 @@
 #define   O_DRAW_NATIVE_API     // comments below explain why I use it
 #endif
 
+// disabled logic for the old beveled look 
+// we draw just like IE does
+#define BEVEL_LOOK  0
+
 // draw the item
 bool wxOwnerDrawn::OnDrawItem(wxDC& dc,
                               const wxRect& rc,
@@ -145,7 +205,14 @@
   DWORD colBack, colText;
   if ( st & wxODSelected ) {
     colBack = GetSysColor(COLOR_HIGHLIGHT);
-    colText = GetSysColor(COLOR_HIGHLIGHTTEXT);
+    if (!(st & wxODDisabled))
+    {
+        colText = GetSysColor(COLOR_HIGHLIGHTTEXT);
+    }
+     else
+    {
+        colText = GetSysColor(COLOR_GRAYTEXT);
+    }
   }
   else {
     // fall back to default colors if none explicitly specified
@@ -165,17 +232,31 @@
   // select the font and draw the text
   // ---------------------------------
 
+
   // determine where to draw and leave space for a check-mark.
-  int x = rc.x + GetMarginWidth();
+#if BEVEL_LOOK
+  // Add 3 pixel padding so text appears well within highlight rectangle
+  int x = rc.x + GetMarginWidth() + 3;
+#else
+  int x = rc.x + ms_nLastMarginWidth;
+#endif
 
-  // using native API because it reckognizes '&'
+  // using native API because it recognizes '&'
   #ifdef  O_DRAW_NATIVE_API
     int nPrevMode = SetBkMode(hdc, TRANSPARENT);
     HBRUSH hbr = CreateSolidBrush(colBack),
            hPrevBrush = (HBRUSH)SelectObject(hdc, hbr);
 
-    RECT rectAll = { rc.GetLeft(), rc.GetTop(), rc.GetRight(), rc.GetBottom() };
-    FillRect(hdc, &rectAll, hbr);
+    RECT rectFill = { rc.GetLeft(), rc.GetTop(), rc.GetRight()+1, rc.GetBottom() };
+
+#if BEVEL_LOOK
+    if ( st & wxODSelected && m_bmpChecked.Ok()) {
+        // only draw the highlight under the text, not under
+        // the bitmap or checkmark; leave a 1-pixel gap.
+        rectFill.left = GetMarginWidth() + 1;
+    }
+#endif
+    FillRect(hdc, &rectFill, hbr);
 
     DeleteObject(hbr);
 
@@ -190,21 +271,26 @@
     }
 
     HFONT hPrevFont = (HFONT) ::SelectObject(hdc, hfont);
-    DrawState(hdc, NULL, NULL,
-              (LPARAM)m_strName.c_str(), m_strName.length(),
-              x, rc.y, rc.GetWidth(), rc.GetHeight(),
-              DST_PREFIXTEXT | (st & wxODDisabled ? DSS_DISABLED : 0));
+
+    wxString strMenuText = m_strName.BeforeFirst('\t');
+
+    ::DrawState(hdc, NULL, NULL,
+                (LPARAM)strMenuText.c_str(), strMenuText.length(),
+                x, rc.y + 1, rc.GetWidth(), rc.GetHeight(),
+                DST_PREFIXTEXT | 
+                ((st & wxODNoAccel) ? DSS_HIDEPREFIX : 0) | 
+                (((st & wxODDisabled) && !(st & wxODSelected)) ? DSS_DISABLED : 0));
 
     if ( !m_strAccel.empty() )
     {
-        RECT r;
-        r.top = rc.GetTop();
-        r.left = rc.GetLeft();
-        r.right = rc.GetRight() - GetMarginWidth();
-        r.bottom = rc.GetBottom();
+        int accel_width, accel_height;
+        dc.GetTextExtent(m_strAccel, &accel_width, &accel_height);
 
-        DrawText(hdc, m_strAccel, m_strAccel.length(), &r,
-                 DT_SINGLELINE | DT_RIGHT | DT_VCENTER);
+        ::DrawState(hdc, NULL, NULL,
+                    (LPARAM)m_strAccel.c_str(), m_strAccel.length(),
+                    rc.GetRight() - accel_width - RIGHT_MARGIN_PIXELS, rc.y + 1, 0, 0,
+                    DST_TEXT |
+                    (((st & wxODDisabled) && !(st & wxODSelected)) ? DSS_DISABLED : 0));
     }
 
     (void)SelectObject(hdc, hPrevBrush);
@@ -212,7 +298,7 @@
     (void)SetBkMode(hdc, nPrevMode);
   #else
     dc.SetFont(GetFont());
-    dc.DrawText(m_strName, x, rc.y);
+    dc.DrawText(wxStripMenuCodes(m_strName), x, rc.y);
   #endif  //O_DRAW_NATIVE_API
 
   // draw the bitmap
@@ -233,9 +319,7 @@
       RECT rect = { 0, 0, GetMarginWidth(), m_nHeight };
       if ( m_nHeight > 0 )
       {
-#ifndef __SC__
-        DrawFrameControl(hdcMem, &rect, DFC_MENU, DFCS_MENUCHECK);
-#endif
+        ::DrawFrameControl(hdcMem, &rect, DFC_MENU, DFCS_MENUCHECK);
       }
 
         // finally copy it to screen DC and clean up
@@ -264,27 +348,29 @@
       // there should be enough place!
       wxASSERT((nBmpWidth <= rc.GetWidth()) && (nBmpHeight <= rc.GetHeight()));
 
-      int heightDiff = (m_nHeight - nBmpHeight);
-//      if (heightDiff = -1)
-//        heightDiff = -2;
-
-      //MT: blit with mask enabled.
+      int heightDiff = m_nHeight - nBmpHeight;
       dc.Blit(rc.x + (GetMarginWidth() - nBmpWidth) / 2,
               rc.y + heightDiff / 2,
               nBmpWidth, nBmpHeight,
-              &dcMem, 0, 0, wxCOPY, TRUE);
+              &dcMem, 0, 0, wxCOPY, TRUE /* use mask */);
 
+#if BEVEL_LOOK
       if ( st & wxODSelected ) {
-        #ifdef  O_DRAW_NATIVE_API
-          RECT rectBmp = { rc.GetLeft(), rc.GetTop(),
-                           rc.GetLeft() + GetMarginWidth(),
-                           rc.GetTop() + m_nHeight };
-          SetBkColor(hdc, colBack);
-          DrawEdge(hdc, &rectBmp, EDGE_RAISED, BF_SOFT | BF_RECT);
-        #else
-          // ## to write portable DrawEdge
-        #endif  //O_DRAW_NATIVE_API
+
+          int x1, y1, x2, y2;
+          x1 = rc.x;
+          y1 = rc.y;
+          x2 = x1 + GetMarginWidth() - 1;
+          y2 = y1 + m_nHeight - 1;
+
+          dc.SetPen(*wxWHITE_PEN);
+          dc.DrawLine(x1, y1, x2, y1);
+          dc.DrawLine(x1, y1, x1, y2);
+          dc.SetPen(*wxGREY_PEN);
+          dc.DrawLine(x1, y2-1, x2, y2-1);
+          dc.DrawLine(x2, y1, x2, y2);
       }
+#endif
     }
   }
 
Index: src/msw/statbr95.cpp
===================================================================
RCS file: /spd/src/photon/wxwin/src/msw/statbr95.cpp,v
retrieving revision 1.1.1.2
retrieving revision 1.2
diff -u -r1.1.1.2 -r1.2
--- src/msw/statbr95.cpp	12 Mar 2002 16:41:11 -0000	1.1.1.2
+++ src/msw/statbr95.cpp	18 Jul 2002 00:14:49 -0000	1.2
@@ -130,6 +130,12 @@
     wxStatusBarBase::SetFieldsCount(nFields, widths);
 
     SetFieldsWidth();
+    if (m_windowStyle & wxNO_BORDER) {
+        // Need to do this to prevent the borders from painting.
+        for (int ii = 0; ii < nFields; ii++) {
+            SetStatusText(wxEmptyString, ii);
+        }
+    }
 }
 
 void wxStatusBar95::SetStatusWidths(int n, const int widths[])
@@ -171,6 +177,10 @@
 {
     wxCHECK_RET( (nField >= 0) && (nField < m_nFields),
                  _T("invalid statusbar field index") );
+
+    if (m_windowStyle & wxNO_BORDER) {
+        nField |= SBT_NOBORDERS;
+    }
 
     if ( !StatusBar_SetText(GetHwnd(), nField, strText) )
     {
Index: src/msw/tooltip.cpp
===================================================================
RCS file: /spd/src/photon/wxwin/src/msw/tooltip.cpp,v
retrieving revision 1.1.1.2
retrieving revision 1.4.2.1
diff -u -r1.1.1.2 -r1.4.2.1
--- src/msw/tooltip.cpp	12 Mar 2002 16:41:09 -0000	1.1.1.2
+++ src/msw/tooltip.cpp	24 Oct 2002 18:03:39 -0000	1.4.2.1
@@ -31,6 +31,7 @@
 
 #include "wx/tooltip.h"
 #include "wx/msw/private.h"
+#include "wx/ownerdrw.h"
 
 #if defined(__WIN95__) && !((defined(__GNUWIN32_OLD__) || defined(__TWIN32__)) && !defined(__CYGWIN10__))
     #include <commctrl.h>
@@ -50,7 +51,6 @@
 //     because it would then work for all controls, not only radioboxes but for
 //     now I don't understand what's wrong with it...
 #define wxUSE_TTM_WINDOWFROMPOINT   0
-
 // ----------------------------------------------------------------------------
 // global variables
 // ----------------------------------------------------------------------------
@@ -59,7 +59,7 @@
 WXHWND wxToolTip::ms_hwndTT = (WXHWND)NULL;
 
 #if wxUSE_TTM_WINDOWFROMPOINT
-
+ 
 // the tooltip window proc
 static WNDPROC gs_wndprocToolTip = (WNDPROC)NULL;
 
@@ -132,7 +132,6 @@
 // ============================================================================
 
 #if wxUSE_TTM_WINDOWFROMPOINT
-
 // ----------------------------------------------------------------------------
 // window proc for our tooltip control
 // ----------------------------------------------------------------------------
@@ -176,10 +175,8 @@
             OutputDebugString("no window\r\n");
         }
     }
-
     return ::CallWindowProc(CASTWNDPROC gs_wndprocToolTip, hwndTT, msg, wParam, lParam);
 }
-
 #endif // wxUSE_TTM_WINDOWFROMPOINT
 
 // ----------------------------------------------------------------------------
@@ -197,6 +194,11 @@
                             TTDT_INITIAL, milliseconds);
 }
 
+void wxToolTip::Update()
+{
+    SendTooltipMessage(GetToolTipCtrl(), TTM_UPDATE, 0, 0);
+}
+
 // ---------------------------------------------------------------------------
 // implementation helpers
 // ---------------------------------------------------------------------------
@@ -246,12 +248,15 @@
          : m_text(tip)
 {
     m_window = NULL;
+    m_ownerdrawn = NULL;
 }
 
 wxToolTip::~wxToolTip()
 {
     // there is no need to Remove() this tool - it will be done automatically
     // anyhow
+    if (m_ownerdrawn)
+        delete m_ownerdrawn;
 }
 
 // ----------------------------------------------------------------------------
@@ -286,7 +291,7 @@
         wxLogDebug(_T("Failed to create the tooltip '%s'"), m_text.c_str());
     }
     else
-    {
+    {   
         // check for multiline toopltip
         int index = m_text.Find(_T('\n'));
 
@@ -400,12 +405,59 @@
 
     if ( m_window )
     {
-        // update it immediately
-        wxToolInfo ti(GetHwndOf(m_window));
-        ti.lpszText = (wxChar *)m_text.c_str();
+        if (tip.IsEmpty()) {
+            (void)SendTooltipMessage(GetToolTipCtrl(),
+                                     TTM_POP, 0, 0);
+        } else {
+            // update it immediately
+            wxToolInfo ti(GetHwndOf(m_window));
+            ti.lpszText = (wxChar *)m_text.c_str();
 
-        (void)SendTooltipMessage(GetToolTipCtrl(), TTM_UPDATETIPTEXT, 0, &ti);
+            (void)SendTooltipMessage(GetToolTipCtrl(),
+                                     TTM_UPDATETIPTEXT, 0, &ti);
+        }
     }
 }
 
+bool wxToolTip::IsShown()
+{
+	HWND hWnd = (HWND)GetToolTipCtrl();
+
+	return (IsWindowVisible(hWnd) != 0);
+}
+
+//ownerdrawn methods
+void wxToolTip::SetOwnerDrawn(wxOwnerDrawn *ownerdrawn)
+{
+    wxASSERT(ownerdrawn);
+    if (!ownerdrawn)
+        return;
+
+    if (m_ownerdrawn)
+        delete m_ownerdrawn;
+
+    m_ownerdrawn = ownerdrawn; 
+}
+
+
+bool wxToolTip::IsOwnerDrawn()
+{
+  return (m_ownerdrawn != NULL);
+}
+
+void wxToolTip::GetOwnerdrawnSize(unsigned int *width, unsigned int *height)
+{
+    wxASSERT(m_ownerdrawn);    
+    if (m_ownerdrawn)
+        m_ownerdrawn->OnMeasureItem(width, height);
+}
+ 
+void wxToolTip::Draw(wxDC &dc, const wxRect &rect)
+{
+    wxASSERT(m_ownerdrawn);
+    if (m_ownerdrawn)  
+    {
+        m_ownerdrawn->OnDrawItem(dc, rect, wxOwnerDrawn::wxODDrawAll, wxOwnerDrawn::wxODDefault);       
+    }
+}
 #endif // wxUSE_TOOLTIPS
Index: src/msw/window.cpp
===================================================================
RCS file: /spd/src/photon/wxwin/src/msw/window.cpp,v
retrieving revision 1.1.1.2
retrieving revision 1.11.6.1
diff -u -r1.1.1.2 -r1.11.6.1
--- src/msw/window.cpp	12 Mar 2002 16:41:18 -0000	1.1.1.2
+++ src/msw/window.cpp	24 Oct 2002 18:03:39 -0000	1.11.6.1
@@ -1418,7 +1418,8 @@
 
 void wxWindowMSW::DoMoveWindow(int x, int y, int width, int height)
 {
-    if ( !::MoveWindow(GetHwnd(), x, y, width, height, TRUE) )
+    if ( !::MoveWindow(GetHwnd(), x, y, width, height,
+                       !(GetWindowStyleFlag() & wxTRANSPARENT_WINDOW)) )
     {
         wxLogLastError(wxT("MoveWindow"));
     }
@@ -1699,7 +1700,13 @@
     point.y = y;
     ::ClientToScreen(hWnd, &point);
     wxCurrentPopupMenu = menu;
-    ::TrackPopupMenu(hMenu, TPM_RIGHTBUTTON, point.x, point.y, 0, hWnd, NULL);
+    UINT flags = TPM_RIGHTBUTTON;
+    // If the left button is down, TPM_LEFTBUTTON lets a release of
+    // the left button pick the menu item.
+    if (GetKeyState(VK_LBUTTON)) {
+        flags = TPM_LEFTBUTTON;
+    }
+    ::TrackPopupMenu(hMenu, flags, point.x, point.y, 0, hWnd, NULL);
 
     // we need to do it righ now as otherwise the events are never going to be
     // sent to wxCurrentPopupMenu from HandleCommand()
@@ -2589,6 +2596,14 @@
             }
             break;
 #endif // __WXUNIVERSAL__
+
+        case WM_ENTERMENULOOP:
+            m_isMenuActive = TRUE;
+            break;
+
+        case WM_EXITMENULOOP:
+            m_isMenuActive = FALSE;
+            break;
     }
 
     if ( !processed )
@@ -2881,17 +2896,73 @@
 
 bool wxWindowMSW::MSWOnNotify(int WXUNUSED(idCtrl),
                            WXLPARAM lParam,
-                           WXLPARAM* WXUNUSED(result))
+                           WXLPARAM* result)
 {
 #if wxUSE_TOOLTIPS
     NMHDR* hdr = (NMHDR *)lParam;
-    if ( (int)hdr->code == TTN_NEEDTEXT && m_tooltip )
+
+    if ((int)hdr->code == NM_CUSTOMDRAW)
     {
-        TOOLTIPTEXT *ttt = (TOOLTIPTEXT *)lParam;
-        ttt->lpszText = (wxChar *)m_tooltip->GetTip().c_str();
+        NMCUSTOMDRAW *cdraw = (NMCUSTOMDRAW *)lParam;
+        wxToolTip* tip = GetToolTip();
+        if (tip && tip->IsOwnerDrawn())
+        {
+            if (cdraw->dwDrawStage == CDDS_PREPAINT)
+            {
+                
+                if (tip && tip->IsOwnerDrawn()) {
+                    unsigned int width, height;
+                    tip->GetOwnerdrawnSize(&width, &height);
+                    
+                    int sysX = wxSystemSettings::GetSystemMetric(wxSYS_SCREEN_X);
+                    int sysY = wxSystemSettings::GetSystemMetric(wxSYS_SCREEN_Y);
+                                
+                    HWND tipHwnd = (HWND)tip->GetToolTipCtrl();
+                    RECT rect;
+                    GetWindowRect(tipHwnd, &rect);
+                    int tipX = rect.left;
+                    int tipY = rect.top;
+                    if (rect.right > sysX)
+                        tipX -= (rect.right - sysX);
+            
+                    if (rect.bottom > sysY)
+                        tipY -= (rect.bottom - sysY);
+
+                    cdraw->rc.right = width;
+                    cdraw->rc.bottom = height;
+                    SetWindowPos((HWND)tip->GetToolTipCtrl(), HWND_TOPMOST, tipX, tipY, 
+                                 width, height, SWP_NOACTIVATE|SWP_NOZORDER|SWP_DEFERERASE|SWP_NOCOPYBITS);
+
+                    *result = CDRF_NOTIFYPOSTPAINT;
+    
+                    return (TRUE);
+                }           
+            }
+            else if (cdraw->dwDrawStage == CDDS_POSTPAINT)
+            {   
+                wxDCTemp tmpDC((WXHDC)cdraw->hdc);
+                wxRect rect(cdraw->rc.top, 
+                            cdraw->rc.left,
+                            cdraw->rc.right,
+                            cdraw->rc.bottom);
+                tip->Draw(tmpDC, rect);
+                //*result = CDRF_SKIPDEFAULT;                
+                return (TRUE);
+            }
+
+            
+        }
+    }
+    else if ( (int)hdr->code == TTN_NEEDTEXT )    
+    {
+        wxToolTip* tip = GetToolTip();
+        if (tip) {
+            TOOLTIPTEXT *ttt = (TOOLTIPTEXT *)lParam;
+            ttt->lpszText = (wxChar *)tip->GetTip().c_str();
 
-        // processed
-        return TRUE;
+            // processed
+            return TRUE;
+        }
     }
 #endif // wxUSE_TOOLTIPS
 
@@ -3725,6 +3796,10 @@
     }
 #endif // wxUSE_MOUSEEVENT_HACK
 
+    wxMouseEvent event(wxEVT_MOUSE_MONITOR);
+    InitMouseEvent(event, x, y, flags);
+    (void)GetEventHandler()->ProcessEvent(event);
+
     return HandleMouseEvent(WM_MOUSEMOVE, x, y, flags);
 }
 
@@ -3872,6 +3947,9 @@
 
     if ( id != -1 ) // VZ: does this ever happen (FIXME)?
     {
+        wxKeyEvent monitorEvent(CreateKeyEvent(wxEVT_KEY_MONITOR, id, lParam));
+        GetEventHandler()->ProcessEvent(monitorEvent);
+
         wxKeyEvent event(CreateKeyEvent(wxEVT_KEY_DOWN, id, lParam));
         if ( GetEventHandler()->ProcessEvent(event) )
         {
@@ -4285,6 +4363,8 @@
     if ( hwnd )
     {
         win = wxFindWinFromHandle((WXHWND)hwnd);
+#if 0
+        // The code below is dangerous and causes crashes.
         if ( !win )
         {
             // all these hacks only work under Win32 anyhow
@@ -4312,6 +4392,7 @@
 
 #endif // Win32
         }
+#endif
     }
 
     while ( hwnd && !win )

 	  	 
