Index: include/wx/msw/listbox.h
===================================================================
--- include/wx/msw/listbox.h	(wersja 61986)
+++ include/wx/msw/listbox.h	(kopia robocza)
@@ -152,9 +152,6 @@
     bool m_updateHorizontalExtent;
     virtual void OnInternalIdle();
 
-    // free memory (common part of Clear() and dtor)
-    void Free();
-
     unsigned int m_noItems;
 
 #if wxUSE_OWNER_DRAWN
Index: include/wx/msw/menuitem.h
===================================================================
--- include/wx/msw/menuitem.h	(wersja 61986)
+++ include/wx/msw/menuitem.h	(kopia robocza)
@@ -17,7 +17,8 @@
 // ----------------------------------------------------------------------------
 
 #if wxUSE_OWNER_DRAWN
-    #include  "wx/ownerdrw.h"   // base class
+    #include "wx/ownerdrw.h"
+    #include "wx/bitmap.h"
 #endif
 
 // ----------------------------------------------------------------------------
@@ -41,7 +42,6 @@
 
     // override base class virtuals
     virtual void SetItemLabel(const wxString& strName);
-    virtual void SetCheckable(bool checkable);
 
     virtual void Enable(bool bDoEnable = true);
     virtual void Check(bool bDoCheck = true);
@@ -76,6 +76,48 @@
     );
 #endif
 
+#if wxUSE_OWNER_DRAWN
+
+    void SetBitmaps(const wxBitmap& bmpChecked,
+                    const wxBitmap& bmpUnchecked = wxNullBitmap)
+    {
+        m_bmpChecked = bmpChecked;
+        m_bmpUnchecked = bmpUnchecked;
+        SetOwnerDrawn(true);
+    }
+
+    void SetBitmap(const wxBitmap& bmp, bool bChecked = true)
+    {
+        if ( bChecked )
+            m_bmpChecked = bmp;
+        else
+            m_bmpUnchecked = bmp;
+        SetOwnerDrawn(true);
+    }
+
+    void SetDisabledBitmap(const wxBitmap& bmpDisabled)
+    {
+        m_bmpDisabled = bmpDisabled;
+        SetOwnerDrawn(true);
+    }
+
+    const wxBitmap& GetBitmap(bool bChecked = true) const
+        { return (bChecked ? m_bmpChecked : m_bmpUnchecked); }
+
+    const wxBitmap& GetDisabledBitmap() const
+        { return m_bmpDisabled; }
+
+
+    // override wxOwnerDrawn base class virtuals
+    virtual wxString GetName() const;
+    virtual bool OnMeasureItem(size_t *pwidth, size_t *pheight);
+    virtual bool OnDrawItem(wxDC& dc, const wxRect& rc, wxODAction act, wxODStatus stat);
+
+protected:
+    virtual void GetFontToUse(wxFont& font) const;
+
+#endif // wxUSE_OWNER_DRAWN
+
 private:
     // common part of all ctors
     void Init();
@@ -93,6 +135,18 @@
     // does this item start a radio group?
     bool m_isRadioGroupStart;
 
+#if wxUSE_OWNER_DRAWN
+    // item bitmaps
+    wxBitmap m_bmpChecked,     // bitmap to put near the item
+             m_bmpUnchecked,   // (checked is used also for 'uncheckable' items)
+             m_bmpDisabled;
+
+    // static variables for cache some system settings
+    static wxFont ms_systemMenuFont;
+    static size_t ms_systemMenuHeight;
+    static bool ms_alwaysShowCues;
+#endif // wxUSE_OWNER_DRAWN
+
     DECLARE_DYNAMIC_CLASS_NO_COPY(wxMenuItem)
 };
 
Index: include/wx/msw/ownerdrw.h
===================================================================
--- include/wx/msw/ownerdrw.h	(wersja 0)
+++ include/wx/msw/ownerdrw.h	(wersja 0)
@@ -0,0 +1,29 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        wx/msw/ownerdrw.h
+// Purpose:     wxOwnerDrawn class
+// Author:      Marcin Malich
+// Modified by:
+// Created:     2009-09-22
+// RCS-ID:      $Id$
+// Copyright:   (c) 2009 Marcin Malich <me@malcom.pl>
+// Licence:     wxWindows licence
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_OWNERDRW_H_
+#define _WX_OWNERDRW_H_
+
+#if wxUSE_OWNER_DRAWN
+
+class WXDLLIMPEXP_CORE wxOwnerDrawn : public wxOwnerDrawnBase
+{
+public:
+    wxOwnerDrawn() {}
+    virtual ~wxOwnerDrawn() {}
+
+    virtual bool OnDrawItem(wxDC& dc, const wxRect& rc,
+                            wxODAction act, wxODStatus stat);
+};
+
+#endif // wxUSE_OWNER_DRAWN
+
+#endif // _WX_OWNERDRW_H_

Zmiany atrybutów dla: include\wx\msw\ownerdrw.h
___________________________________________________________________
Dodane: svn:keywords
   + Date Revision Author HeadURL Id

Index: src/msw/checklst.cpp
===================================================================
--- src/msw/checklst.cpp	(wersja 61986)
+++ src/msw/checklst.cpp	(kopia robocza)
@@ -141,6 +141,8 @@
 
     void SendEvent();
 
+    virtual wxString GetName() const { return m_pParent->GetString(m_nIndex); }
+
 private:
     bool            m_bChecked;
     wxCheckListBox *m_pParent;
@@ -150,7 +152,6 @@
 };
 
 wxCheckListBoxItem::wxCheckListBoxItem(wxCheckListBox *pParent, size_t nIndex)
-                  : wxOwnerDrawn(wxEmptyString, true)   // checkable
 {
     m_bChecked = false;
     m_pParent  = pParent;
@@ -160,7 +161,7 @@
     // done in OnMeasure while they are used only in OnDraw and we
     // know that there will always be OnMeasure before OnDraw
 
-    SetMarginWidth(::GetSystemMetrics(SM_CXMENUCHECK) - 2);
+    SetMarginWidth(::GetSystemMetrics(SM_CXMENUCHECK));
 
     SetBackgroundColour(pParent->GetBackgroundColour());
 }
Index: src/msw/listbox.cpp
===================================================================
--- src/msw/listbox.cpp	(wersja 61986)
+++ src/msw/listbox.cpp	(kopia robocza)
@@ -118,18 +118,25 @@
 class wxListBoxItem : public wxOwnerDrawn
 {
 public:
-    wxListBoxItem(const wxString& str = wxEmptyString);
-};
+    wxListBoxItem(wxListBox *parent)
+        { m_parent = parent; }
 
-wxListBoxItem::wxListBoxItem(const wxString& str) : wxOwnerDrawn(str, false)
-{
-    // no bitmaps/checkmarks
-    SetMarginWidth(0);
-}
+    wxListBox *GetParent() const
+        { return m_parent; }
 
+    int GetIndex() const
+        { return m_parent->GetItemIndex(const_cast<wxListBoxItem*>(this)); }
+
+    wxString GetName() const
+        { return m_parent->GetString(GetIndex()); }
+
+private:
+    wxListBox *m_parent;
+};
+
 wxOwnerDrawn *wxListBox::CreateLboxItem(size_t WXUNUSED(n))
 {
-    return new wxListBoxItem();
+    return new wxListBoxItem(this);
 }
 
 #endif  //USE_OWNER_DRAWN
@@ -279,6 +286,11 @@
     wxCHECK_RET( IsValid(n),
                  wxT("invalid index in wxListBox::Delete") );
 
+#if wxUSE_OWNER_DRAWN
+    delete m_aItems[n];
+    m_aItems.RemoveAt(n);
+#endif // wxUSE_OWNER_DRAWN
+
     SendMessage(GetHwnd(), LB_DELETESTRING, n, 0);
     m_noItems--;
 
@@ -303,7 +315,12 @@
 
 void wxListBox::DoClear()
 {
-    Free();
+#if wxUSE_OWNER_DRAWN
+    if ( m_windowStyle & wxLB_OWNERDRAW )
+    {
+        WX_CLEAR_ARRAY(m_aItems);
+    }
+#endif // wxUSE_OWNER_DRAWN
 
     ListBox_ResetContent(GetHwnd());
 
@@ -313,16 +330,6 @@
     UpdateOldSelections();
 }
 
-void wxListBox::Free()
-{
-#if wxUSE_OWNER_DRAWN
-    if ( m_windowStyle & wxLB_OWNERDRAW )
-    {
-        WX_CLEAR_ARRAY(m_aItems);
-    }
-#endif // wxUSE_OWNER_DRAWN
-}
-
 void wxListBox::DoSetSelection(int N, bool select)
 {
     wxCHECK_RET( N == wxNOT_FOUND || IsValid(N),
@@ -469,7 +476,6 @@
         if ( HasFlag(wxLB_OWNERDRAW) )
         {
             wxOwnerDrawn *pNewItem = CreateLboxItem(n);
-            pNewItem->SetName(items[i]);
             pNewItem->SetFont(GetFont());
             m_aItems.Insert(pNewItem, n);
         }
@@ -524,14 +530,6 @@
     else if ( oldObjData )
         SetClientObject(n, oldObjData);
 
-#if wxUSE_OWNER_DRAWN
-    if ( m_windowStyle & wxLB_OWNERDRAW )
-    {
-        // update item's text
-        m_aItems[n]->SetName(s);
-    }
-#endif  //USE_OWNER_DRAWN
-
     // we may have lost the selection
     if ( wasSelected )
         Select(n);
@@ -745,7 +743,7 @@
 
     return pItem->OnDrawItem(dc, wxRectFromRECT(pStruct->rcItem),
                              (wxOwnerDrawn::wxODAction)pStruct->itemAction,
-                             (wxOwnerDrawn::wxODStatus)pStruct->itemState);
+                             (wxOwnerDrawn::wxODStatus)(pStruct->itemState | wxOwnerDrawn::wxODHidePrefix));
 }
 
 #endif // wxUSE_OWNER_DRAWN
Index: src/msw/menu.cpp
===================================================================
--- src/msw/menu.cpp	(wersja 61986)
+++ src/msw/menu.cpp	(kopia robocza)
@@ -578,7 +578,7 @@
 
                 // tell the item that it's not really owner-drawn but only
                 // needs to draw its bitmap, the rest is done by Windows
-                pItem->ResetOwnerDrawn();
+                pItem->SetOwnerDrawn(false);
             }
         }
 #endif // __DMC__
Index: src/msw/menuitem.cpp
===================================================================
--- src/msw/menuitem.cpp	(wersja 61986)
+++ src/msw/menuitem.cpp	(kopia robocza)
@@ -45,6 +45,7 @@
 #endif // wxUSE_ACCEL
 
 #include "wx/msw/private.h"
+#include "wx/msw/dc.h"
 
 #ifdef __WXWINCE__
 // Implemented in menu.cpp
@@ -58,17 +59,25 @@
 // hide the ugly cast
 #define GetHMenuOf(menu)    ((HMENU)menu->GetHMenu())
 
-// conditional compilation
-#if wxUSE_OWNER_DRAWN
-    #define OWNER_DRAWN_ONLY( code ) if ( IsOwnerDrawn() ) code
-#else // !wxUSE_OWNER_DRAWN
-    #define OWNER_DRAWN_ONLY( code )
-#endif // wxUSE_OWNER_DRAWN/!wxUSE_OWNER_DRAWN
-
 // ============================================================================
 // implementation
 // ============================================================================
 
+#if wxUSE_OWNER_DRAWN
+
+#include "wx/fontutil.h"
+#include "wx/msw/private/metrics.h"
+
+#ifndef SPI_GETKEYBOARDCUES
+#define SPI_GETKEYBOARDCUES 0x100A
+#endif
+
+#ifndef DSS_HIDEPREFIX
+#define DSS_HIDEPREFIX  0x0200
+#endif
+
+#endif // wxUSE_OWNER_DRAWN
+
 // ----------------------------------------------------------------------------
 // dynamic classes implementation
 // ----------------------------------------------------------------------------
@@ -120,6 +129,17 @@
 // wxMenuItem
 // ----------------------------------------------------------------------------
 
+#if wxUSE_OWNER_DRAWN
+
+// these static variables are from the wxMenuItem object for cache
+// system settings returned by the Win32 API's SystemParametersInfo() call
+wxFont wxMenuItem::ms_systemMenuFont;
+size_t wxMenuItem::ms_systemMenuHeight = 0;
+bool   wxMenuItem::ms_alwaysShowCues = false;
+
+#endif // wxUSE_OWNER_DRAWN
+
+
 // ctor & dtor
 // -----------
 
@@ -130,9 +150,6 @@
                        wxItemKind kind,
                        wxMenu *pSubMenu)
           : wxMenuItemBase(pParentMenu, id, text, strHelp, kind, pSubMenu)
-#if wxUSE_OWNER_DRAWN
-            , wxOwnerDrawn(text, kind == wxITEM_CHECK, true)
-#endif // owner drawn
 {
     Init();
 }
@@ -146,9 +163,6 @@
                        wxMenu *subMenu)
           : wxMenuItemBase(parentMenu, id, text, help,
                            isCheckable ? wxITEM_CHECK : wxITEM_NORMAL, subMenu)
-#if wxUSE_OWNER_DRAWN
-           , wxOwnerDrawn(text, isCheckable, true)
-#endif // owner drawn
 {
     Init();
 }
@@ -161,6 +175,24 @@
 
 #if  wxUSE_OWNER_DRAWN
 
+    // init static varaibles
+    if ( !ms_systemMenuHeight )
+    {
+        const NONCLIENTMETRICS& metrics = wxMSWImpl::GetNonClientMetrics();
+
+        ms_systemMenuFont = wxFont(wxNativeFontInfo(metrics.lfMenuFont));
+        ms_systemMenuHeight = metrics.iMenuHeight;
+
+        if ( ::SystemParametersInfo(SPI_GETKEYBOARDCUES, 0,
+                                    &ms_alwaysShowCues, 0) == 0 )
+        {
+            // if it's not supported, we must be on an old Windows version
+            // which always shows them
+            ms_alwaysShowCues = true;
+        }
+
+    }
+
     // when the color is not valid, wxOwnerDraw takes the default ones.
     // If we set the colors here and they are changed by the user during
     // the execution, then the colors are not updated until the application
@@ -169,14 +201,12 @@
     SetBackgroundColour(wxNullColour);
 
     // setting default colors switched ownerdraw on: switch it off again
-    ResetOwnerDrawn();
+    SetOwnerDrawn(false);
 
     //  switch ownerdraw back on if using a non default margin
     if ( !IsSeparator() )
         SetMarginWidth(GetMarginWidth());
 
-    // tell the owner drawing code to show the accel string as well
-    SetAccelString(m_text.AfterFirst(wxT('\t')));
 #endif // wxUSE_OWNER_DRAWN
 }
 
@@ -365,15 +395,6 @@
     // wxMenuItemBase will do stock ID checks
     wxMenuItemBase::SetItemLabel(text);
 
-    // m_text could now be different from 'text' if we are a stock menu item,
-    // so use only m_text below
-
-    OWNER_DRAWN_ONLY( wxOwnerDrawn::SetName(m_text) );
-#if wxUSE_OWNER_DRAWN
-    // tell the owner drawing code to to show the accel string as well
-    SetAccelString(m_text.AfterFirst(wxT('\t')));
-#endif
-
     // the item can be not attached to any menu yet and SetItemLabel() is still
     // valid to call in this case and should do nothing else
     if ( !m_parentMenu )
@@ -430,12 +451,318 @@
     }
 }
 
-void wxMenuItem::SetCheckable(bool checkable)
+#if wxUSE_OWNER_DRAWN
+
+wxString wxMenuItem::GetName() const
 {
-    wxMenuItemBase::SetCheckable(checkable);
-    OWNER_DRAWN_ONLY( wxOwnerDrawn::SetCheckable(checkable) );
+    return GetItemLabelText();
 }
 
+bool wxMenuItem::OnMeasureItem(size_t *width, size_t *height)
+{
+    if ( IsOwnerDrawn() )
+    {
+
+        wxString str = GetName();
+
+        // if we have a valid accel string, then pad out
+        // the menu string so that the menu and accel string are not
+        // placed on top of each other.
+        wxString accel = GetItemLabel().AfterFirst(wxT('\t'));
+        if ( !accel.empty() )
+        {
+            str.Pad(str.length()%8);
+            str += accel;
+        }
+
+        wxMemoryDC dc;
+        wxFont font;
+        GetFontToUse(font);
+        dc.SetFont(font);
+
+        wxCoord w, h;
+        dc.GetTextExtent(str, &w, &h);
+        *width = w;
+        *height = h;
+    }
+    else // don't draw the text, just the bitmap (if any)
+    {
+        *width = 0;
+        *height = 0;
+    }
+
+    // increase size to accommodate bigger bitmaps if necessary
+    if (m_bmpChecked.Ok())
+    {
+        // Is BMP height larger than text height?
+        size_t adjustedHeight = m_bmpChecked.GetHeight();
+        if ( *height < adjustedHeight )
+            *height = adjustedHeight;
+
+        const int widthBmp = m_bmpChecked.GetWidth();
+        if ( IsOwnerDrawn() )
+        {
+            // widen the margin to fit the bitmap if necessary
+            if ( GetMarginWidth() < widthBmp )
+                SetMarginWidth(widthBmp);
+
+        }
+        else // we must allocate enough space for the bitmap
+        {
+            *width += widthBmp;
+        }
+    }
+
+    // add a 4-pixel separator, otherwise menus look cluttered
+    *width += 4;
+
+    // notice that this adjustment must be done after (possibly) changing the
+    // margin width above
+    if ( IsOwnerDrawn() )
+    {
+        // add space at the end of the menu for the submenu expansion arrow
+        // this will also allow offsetting the accel string from the right edge
+        *width += GetMarginWidth() + 16;
+    }
+
+    // make sure that this item is at least as tall as the system menu height
+    if ( *height < ms_systemMenuHeight )
+      *height = ms_systemMenuHeight;
+
+    return true;
+}
+
+bool wxMenuItem::OnDrawItem(wxDC& dc, const wxRect& rc,
+                            wxODAction act, wxODStatus stat)
+{
+
+    // this flag determines whether or not an edge will
+    // be drawn around the bitmap. In most "windows classic"
+    // applications, a 1-pixel highlight edge is drawn around
+    // the bitmap of an item when it is selected.  However,
+    // with the new "luna" theme, no edge is drawn around
+    // the bitmap because the background is white (this applies
+    // only to "non-XP style" menus w/ bitmaps --
+    // see IE 6 menus for an example)
+
+    bool draw_bitmap_edge = true;
+
+    // set the colors
+    // --------------
+    wxColour colText1, colBack1;
+    GetColourToUse(stat, colText1, colBack1);
+
+DWORD colText = wxColourToPalRGB(colText1);
+DWORD colBack = wxColourToPalRGB(colBack1);
+
+    if ( IsOwnerDrawn() )
+    {
+        // don't draw an edge around the bitmap, if background is white ...
+        DWORD menu_bg_color = GetSysColor(COLOR_MENU);
+        if ( GetRValue( menu_bg_color ) >= 0xf0 &&
+             GetGValue( menu_bg_color ) >= 0xf0 &&
+             GetBValue( menu_bg_color ) >= 0xf0 )
+        {
+            draw_bitmap_edge = false;
+        }
+    }
+    else // edge doesn't look well with default Windows drawing
+    {
+        draw_bitmap_edge = false;
+    }
+
+
+    wxMSWDCImpl *impl = (wxMSWDCImpl*) dc.GetImpl();
+    HDC hdc = GetHdcOf(*impl);
+    COLORREF colOldText = ::SetTextColor(hdc, colText);
+    COLORREF colOldBack = ::SetBkColor(hdc, colBack);
+
+    // *2, as in wxSYS_EDGE_Y
+    int margin = GetMarginWidth() + 2 * wxSystemSettings::GetMetric(wxSYS_EDGE_X);
+
+    // select the font and draw the text
+    // ---------------------------------
+
+
+    // determine where to draw and leave space for a check-mark.
+    // + 1 pixel to separate the edge from the highlight rectangle
+    int xText = rc.x + margin + 1;
+
+
+    // using native API because it recognizes '&'
+    if ( IsOwnerDrawn() )
+    {
+        int prevMode = SetBkMode(hdc, TRANSPARENT);
+        AutoHBRUSH hbr(colBack);
+        SelectInHDC selBrush(hdc, hbr);
+
+        RECT rectFill;
+        wxCopyRectToRECT(rc, rectFill);
+
+        if ( (stat & wxODSelected) && m_bmpChecked.Ok() && draw_bitmap_edge )
+        {
+            // only draw the highlight under the text, not under
+            // the bitmap or checkmark
+            rectFill.left = xText;
+        }
+
+        ::FillRect(hdc, &rectFill, hbr);
+
+        // use default font if no font set
+        wxFont font;
+        GetFontToUse(font);
+        SelectInHDC selFont(hdc, GetHfontOf(font));
+
+        // item text name with menemonic
+        wxString text = GetItemLabel().BeforeFirst('\t');
+
+        xText += 3; // separate text from the highlight rectangle
+
+        SIZE textRect;
+        ::GetTextExtentPoint32(hdc, text.c_str(), text.length(), &textRect);
+
+        int flags = DST_PREFIXTEXT;
+        if ( (stat & wxODDisabled) && !(stat & wxODSelected) )
+            flags |= DSS_DISABLED;
+
+        if ( (stat & wxODHidePrefix) && !ms_alwaysShowCues )
+            flags |= DSS_HIDEPREFIX;
+
+        int x = xText;
+        int y = rc.y + (rc.GetHeight() - textRect.cy) / 2;
+        int cx = rc.GetWidth() - GetMarginWidth();
+        int cy = textRect.cy;
+
+        ::DrawState(hdc, NULL, NULL, (LPARAM)text.wx_str(),
+                    text.length(), x, y, cx, cy, flags);
+
+        // ::SetTextAlign(hdc, TA_RIGHT) doesn't work with DSS_DISABLED or DSS_MONO
+        // as the last parameter in DrawState() (at least with Windows98). So we have
+        // to take care of right alignment ourselves.
+        wxString accel = GetItemLabel().AfterFirst(wxT('\t'));
+        if ( !accel.empty() )
+        {
+            SIZE accelRect;
+            ::GetTextExtentPoint32(hdc, accel.c_str(), accel.length(), &accelRect);
+
+            int flags = DST_TEXT;
+            if ( (stat & wxODDisabled) && !(stat & wxODSelected) )
+                flags |= DSS_DISABLED;
+
+            // right align accel string with right edge of menu
+            // (offset by the margin width)
+
+            int x = rc.GetWidth() - 16 - accelRect.cx;
+            int y = rc.y + (rc.GetHeight() - accelRect.cy) / 2;
+            ::DrawState(hdc, NULL, NULL, (LPARAM)accel.wx_str(),
+                        accel.length(), x, y, 0, 0, flags);
+        }
+
+        ::SetBkMode(hdc, prevMode);
+    }
+
+
+    // draw the bitmap
+    // ---------------
+    if ( IsCheckable() && !m_bmpChecked.Ok() )
+    {
+        if ( stat & wxODChecked )
+        {
+            // what goes on: DrawFrameControl creates a b/w mask,
+            // then we copy it to screen to have right colors
+
+            // first create a monochrome bitmap in a memory DC
+            HDC hdcMem = CreateCompatibleDC(hdc);
+            HBITMAP hbmpCheck = CreateBitmap(margin, rc.GetHeight(), 1, 1, 0);
+            SelectObject(hdcMem, hbmpCheck);
+
+            // then draw a check mark into it
+            RECT rect = { 0, 0, margin, rc.GetHeight() };
+            if ( rc.GetHeight() > 0 )
+            {
+                ::DrawFrameControl(hdcMem, &rect, DFC_MENU, DFCS_MENUCHECK);
+            }
+
+            // finally copy it to screen DC and clean up
+            BitBlt(hdc, rc.x, rc.y, margin, rc.GetHeight(), hdcMem, 0, 0, SRCCOPY);
+
+            DeleteDC(hdcMem);
+            DeleteObject(hbmpCheck);
+        }
+    }
+    else
+    {
+        wxBitmap bmp;
+
+        if ( stat & wxODDisabled )
+        {
+            bmp = GetDisabledBitmap();
+        }
+
+        if ( !bmp.Ok() )
+        {
+            // for not checkable bitmaps we should always use unchecked one
+            // because their checked bitmap is not set
+            bmp = GetBitmap(!IsCheckable() || (stat & wxODChecked));
+
+#if wxUSE_IMAGE
+            if ( bmp.Ok() && stat & wxODDisabled )
+            {
+                // we need to grey out the bitmap as we don't have any specific
+                // disabled bitmap
+                wxImage imgGrey = bmp.ConvertToImage().ConvertToGreyscale();
+                if ( imgGrey.Ok() )
+                    bmp = wxBitmap(imgGrey);
+            }
+#endif // wxUSE_IMAGE
+        }
+
+        if ( bmp.Ok() )
+        {
+            wxMemoryDC dcMem(&dc);
+            dcMem.SelectObjectAsSource(bmp);
+
+            // center bitmap
+            int nBmpWidth = bmp.GetWidth(),
+                nBmpHeight = bmp.GetHeight();
+
+            // there should be enough space!
+            wxASSERT((nBmpWidth <= rc.GetWidth()) && (nBmpHeight <= rc.GetHeight()));
+
+            int heightDiff = rc.GetHeight() - nBmpHeight;
+            dc.Blit(rc.x + (margin - nBmpWidth) / 2,
+                    rc.y + heightDiff / 2,
+                    nBmpWidth, nBmpHeight,
+                    &dcMem, 0, 0, wxCOPY, true /* use mask */);
+
+            if ( ( stat & wxODSelected ) && !( stat & wxODDisabled ) && draw_bitmap_edge )
+            {
+                RECT rectBmp = { rc.GetLeft(), rc.GetTop(),
+                                 rc.GetLeft() + margin,
+                                 rc.GetTop() + rc.GetHeight() };
+                SetBkColor(hdc, colBack);
+
+                DrawEdge(hdc, &rectBmp, BDR_RAISEDINNER, BF_RECT);
+            }
+        }
+    }
+
+    ::SetTextColor(hdc, colOldText);
+    ::SetBkColor(hdc, colOldBack);
+
+    return true;
+
+}
+
+void wxMenuItem::GetFontToUse(wxFont& font) const
+{
+    font = GetFont();
+    if ( !font.IsOk() )
+        font = ms_systemMenuFont;
+}
+
+#endif // wxUSE_OWNER_DRAWN
+
 // ----------------------------------------------------------------------------
 // wxMenuItemBase
 // ----------------------------------------------------------------------------
Index: src/msw/ownerdrw.cpp
===================================================================
--- src/msw/ownerdrw.cpp	(wersja 61986)
+++ src/msw/ownerdrw.cpp	(kopia robocza)
@@ -2,7 +2,7 @@
 // Name:        src/msw/ownerdrw.cpp
 // Purpose:     implementation of wxOwnerDrawn class
 // Author:      Vadim Zeitlin
-// Modified by:
+// Modified by: Marcin Malich
 // Created:     13.11.97
 // RCS-ID:      $Id$
 // Copyright:   (c) 1998 Vadim Zeitlin <zeitlin@dptmaths.ens-cachan.fr>
@@ -18,521 +18,81 @@
 
 #if wxUSE_OWNER_DRAWN
 
-#ifndef WX_PRECOMP
-    #include "wx/window.h"
-    #include "wx/font.h"
-    #include "wx/bitmap.h"
-    #include "wx/image.h"
-    #include "wx/dcmemory.h"
-    #include "wx/menu.h"
-    #include "wx/utils.h"
-    #include "wx/settings.h"
-    #include "wx/menuitem.h"
-    #include "wx/module.h"
-    #include "wx/msw/wrapcctl.h"
-#endif
-
 #include "wx/ownerdrw.h"
-#include "wx/fontutil.h"
-
-#include "wx/msw/private.h"
-#include "wx/msw/private/metrics.h"
 #include "wx/msw/dc.h"
+#include "wx/msw/private.h"
+#include "wx/msw/private/dc.h"
 
-#ifndef SPI_GETKEYBOARDCUES
-#define SPI_GETKEYBOARDCUES 0x100A
-#endif
-
 #ifndef DSS_HIDEPREFIX
 #define DSS_HIDEPREFIX  0x0200
 #endif
 
-class wxMSWSystemMenuFontModule : public wxModule
-{
-public:
-    virtual bool OnInit()
-    {
-        return true;
-    }
+// ----------------------------------------------------------------------------
+// constants for base class
+// ----------------------------------------------------------------------------
 
-    virtual void OnExit()
-    {
-        if ( ms_systemMenuFont )
-        {
-            delete ms_systemMenuFont;
-            ms_systemMenuFont = NULL;
-        }
-    }
+int wxOwnerDrawnBase::ms_defaultMargin = 3;
 
-    static const wxFont& GetSystemMenuFont()
-    {
-        if ( !ms_systemMenuFont )
-            DoInitFont();
-
-        return *ms_systemMenuFont;
-    }
-
-    static int GetSystemMenuHeight()
-    {
-        if ( !ms_systemMenuHeight )
-            DoInitMetrics();
-
-        return ms_systemMenuHeight;
-    }
-
-    static bool AlwaysShowCues()
-    {
-        if ( !ms_systemMenuHeight )
-            DoInitMetrics();
-
-        return ms_alwaysShowCues;
-    }
-
-private:
-    static void DoInitMetrics()
-    {
-        // iMenuHeight is the menu bar height and the menu items are less tall,
-        // although I don't know by how much -- below is the value for my system
-        ms_systemMenuHeight = wxMSWImpl::GetNonClientMetrics().iMenuHeight - 4;
-
-        wxASSERT_MSG( ms_systemMenuHeight > 0,
-                        "menu height should be positive" );
-
-        if ( ::SystemParametersInfo(SPI_GETKEYBOARDCUES, 0,
-                                    &ms_alwaysShowCues, 0) == 0 )
-        {
-            // if it's not supported, we must be on an old Windows version
-            // which always shows them
-            ms_alwaysShowCues = true;
-        }
-    }
-
-    static void DoInitFont()
-    {
-        ms_systemMenuFont = new
-          wxFont(wxNativeFontInfo(wxMSWImpl::GetNonClientMetrics().lfMenuFont));
-    }
-
-    static wxFont* ms_systemMenuFont;
-    static int ms_systemMenuHeight;
-    static bool ms_alwaysShowCues;
-
-
-    DECLARE_DYNAMIC_CLASS(wxMSWSystemMenuFontModule)
-};
-
-// these static variables are from the wxMSWSystemMenuFontModule object
-// and reflect the system settings returned by the Win32 API's
-// SystemParametersInfo() call.
-
-wxFont* wxMSWSystemMenuFontModule::ms_systemMenuFont = NULL;
-int wxMSWSystemMenuFontModule::ms_systemMenuHeight = 0;
-bool wxMSWSystemMenuFontModule::ms_alwaysShowCues = false;
-
-IMPLEMENT_DYNAMIC_CLASS(wxMSWSystemMenuFontModule, wxModule)
-
-
-// VC++ 6 gives a warning here:
-//
-//      return type for 'OwnerDrawnSet_wxImplementation_HashTable::iterator::
-//      operator ->' is 'class wxOwnerDrawn ** ' (ie; not a UDT or reference to
-//      a UDT.  Will produce errors if applied using infix notation.
-//
-// shut it down
-#if defined __VISUALC__ && __VISUALC__ <= 1300
-    #if __VISUALC__ >= 1200
-        #pragma warning(push)
-        #define POP_WARNINGS
-    #endif
-    #pragma warning(disable: 4284)
-#endif
-
-#include "wx/hashset.h"
-WX_DECLARE_HASH_SET(wxOwnerDrawn*, wxPointerHash, wxPointerEqual, OwnerDrawnSet);
-
-#ifdef POP_WARNINGS
-    #pragma warning(pop)
-#endif
-
 // ============================================================================
 // implementation of wxOwnerDrawn class
 // ============================================================================
 
-// ctor
-// ----
-wxOwnerDrawn::wxOwnerDrawn(const wxString& str,
-                           bool bCheckable,
-                           bool bMenuItem)
-            : m_strName(str)
-{
-    if ( ms_nDefaultMarginWidth == 0 )
-    {
-       ms_nDefaultMarginWidth = ::GetSystemMetrics(SM_CXMENUCHECK) +
-                                wxSystemSettings::GetMetric(wxSYS_EDGE_X);
-       ms_nLastMarginWidth = ms_nDefaultMarginWidth;
-    }
-
-    m_bCheckable   = bCheckable;
-    m_bOwnerDrawn  = false;
-    m_isMenuItem   = bMenuItem;
-    m_nHeight      = 0;
-    m_nMarginWidth = ms_nLastMarginWidth;
-}
-
-wxOwnerDrawn::~wxOwnerDrawn()
-{
-}
-
-bool wxOwnerDrawn::IsMenuItem() const
-{
-    return m_isMenuItem;
-}
-
-
-// these items will be set during the first invocation of the ctor,
-// because the values will be determined by checking the system settings,
-// which is a chunk of code
-size_t wxOwnerDrawn::ms_nDefaultMarginWidth = 0;
-size_t wxOwnerDrawn::ms_nLastMarginWidth = 0;
-
-
-// drawing
-// -------
-
-wxFont wxOwnerDrawn::GetFontToUse() const
-{
-    wxFont font = m_font;
-    if ( !font.Ok() )
-    {
-        if ( IsMenuItem() )
-            font = wxMSWSystemMenuFontModule::GetSystemMenuFont();
-
-        if ( !font.Ok() )
-            font = *wxNORMAL_FONT;
-    }
-
-    return font;
-}
-
-// get size of the item
-// The item size includes the menu string, the accel string,
-// the bitmap and size for a submenu expansion arrow...
-bool wxOwnerDrawn::OnMeasureItem(size_t *pwidth, size_t *pheight)
-{
-    if ( IsOwnerDrawn() )
-    {
-        wxMemoryDC dc;
-
-        wxString str = wxStripMenuCodes(m_strName);
-
-        // if we have a valid accel string, then pad out
-        // the menu string so that the menu and accel string are not
-        // placed on top of each other.
-        if ( !m_strAccel.empty() )
-        {
-            str.Pad(str.length()%8);
-            str += m_strAccel;
-        }
-
-        dc.SetFont(GetFontToUse());
-
-        wxCoord w, h;
-        dc.GetTextExtent(str, &w, &h);
-        *pwidth = w;
-        *pheight = h;
-    }
-    else // don't draw the text, just the bitmap (if any)
-    {
-        *pwidth =
-        *pheight = 0;
-    }
-
-    // increase size to accommodate bigger bitmaps if necessary
-    if (m_bmpChecked.Ok())
-    {
-        // Is BMP height larger than text height?
-        size_t adjustedHeight = m_bmpChecked.GetHeight();
-        if ( *pheight < adjustedHeight )
-            *pheight = adjustedHeight;
-
-        const int widthBmp = m_bmpChecked.GetWidth();
-        if ( IsOwnerDrawn() )
-        {
-            // widen the margin to fit the bitmap if necessary
-            if ( GetMarginWidth() < widthBmp )
-                SetMarginWidth(widthBmp);
-        }
-        else // we must allocate enough space for the bitmap
-        {
-            *pwidth += widthBmp;
-        }
-    }
-
-    // add a 4-pixel separator, otherwise menus look cluttered
-    *pwidth += 4;
-
-    // notice that this adjustment must be done after (possibly) changing the
-    // margin width above
-    if ( IsOwnerDrawn() )
-    {
-        // add space at the end of the menu for the submenu expansion arrow
-        // this will also allow offsetting the accel string from the right edge
-        *pwidth += GetMarginWidth() + 16;
-    }
-
-    // make sure that this item is at least as tall as the system menu height
-    const size_t heightStd = wxMSWSystemMenuFontModule::GetSystemMenuHeight();
-    if ( *pheight < heightStd )
-      *pheight = heightStd;
-
-    // remember height for use in OnDrawItem
-    m_nHeight = *pheight;
-
-    return true;
-}
-
 // draw the item
-bool wxOwnerDrawn::OnDrawItem(wxDC& dc,
-                              const wxRect& rc,
-                              wxODAction,
-                              wxODStatus st)
+bool wxOwnerDrawn::OnDrawItem(wxDC& dc, const wxRect& rc,
+                              wxODAction, wxODStatus stat)
 {
-    // this flag determines whether or not an edge will
-    // be drawn around the bitmap. In most "windows classic"
-    // applications, a 1-pixel highlight edge is drawn around
-    // the bitmap of an item when it is selected.  However,
-    // with the new "luna" theme, no edge is drawn around
-    // the bitmap because the background is white (this applies
-    // only to "non-XP style" menus w/ bitmaps --
-    // see IE 6 menus for an example)
+    // we do nothing if item isn't ownerdrawn
+    if ( !IsOwnerDrawn() )
+        return true;
 
-    bool draw_bitmap_edge = true;
+    // set the font and colors
+    wxFont font;
+    GetFontToUse(font);
 
-    // set the colors
-    // --------------
-    DWORD colBack, colText;
-    if ( st & wxODSelected )
-    {
-        colBack = GetSysColor(COLOR_HIGHLIGHT);
-        if (!(st & wxODDisabled))
-        {
-            colText = GetSysColor(COLOR_HIGHLIGHTTEXT);
-        }
-        else
-        {
-            colText = GetSysColor(COLOR_GRAYTEXT);
-        }
-    }
-    else
-    {
-        // fall back to default colors if none explicitly specified
-        colBack = m_colBack.Ok() ? wxColourToPalRGB(m_colBack)
-                                 : GetSysColor(COLOR_MENU);
-        colText = m_colText.Ok() ? wxColourToPalRGB(m_colText)
-                                 : GetSysColor(COLOR_MENUTEXT);
-    }
+    wxColour colText, colBack;
+    GetColourToUse(stat, colText, colBack);
 
-    if ( IsOwnerDrawn() )
-    {
-        // don't draw an edge around the bitmap, if background is white ...
-        DWORD menu_bg_color = GetSysColor(COLOR_MENU);
-        if (    ( GetRValue( menu_bg_color ) >= 0xf0 &&
-                  GetGValue( menu_bg_color ) >= 0xf0 &&
-                  GetBValue( menu_bg_color ) >= 0xf0 )
-          )
-        {
-            draw_bitmap_edge = false;
-        }
-    }
-    else // edge doesn't look well with default Windows drawing
-    {
-        draw_bitmap_edge = false;
-    }
-
-
     wxMSWDCImpl *impl = (wxMSWDCImpl*) dc.GetImpl();
     HDC hdc = GetHdcOf(*impl);
-    COLORREF colOldText = ::SetTextColor(hdc, colText),
-             colOldBack = ::SetBkColor(hdc, colBack);
 
-    // *2, as in wxSYS_EDGE_Y
-    int margin = GetMarginWidth() + 2 * wxSystemSettings::GetMetric(wxSYS_EDGE_X);
+    SelectInHDC selFont(hdc, GetHfontOf(font));
 
-    // select the font and draw the text
-    // ---------------------------------
+    wxMSWImpl::wxTextColoursChanger textCol(hdc, colText, colBack);
+    wxMSWImpl::wxBkModeChanger bkMode(hdc, wxBRUSHSTYLE_TRANSPARENT);
 
 
-    // determine where to draw and leave space for a check-mark.
-    // + 1 pixel to separate the edge from the highlight rectangle
-    int xText = rc.x + margin + 1;
+    AutoHBRUSH hbr(wxColourToPalRGB(colBack));
+    SelectInHDC selBrush(hdc, hbr);
 
+    RECT rectFill;
+    wxCopyRectToRECT(rc, rectFill);
+    ::FillRect(hdc, &rectFill, hbr);
 
     // using native API because it recognizes '&'
-    if ( IsOwnerDrawn() )
-    {
-        int nPrevMode = SetBkMode(hdc, TRANSPARENT);
-        AutoHBRUSH hbr(colBack);
-        SelectInHDC selBrush(hdc, hbr);
 
-        RECT rectFill;
-        wxCopyRectToRECT(rc, rectFill);
+    wxString text = GetName();
 
-        if ( (st & wxODSelected) && m_bmpChecked.Ok() && draw_bitmap_edge )
-        {
-            // only draw the highlight under the text, not under
-            // the bitmap or checkmark
-            rectFill.left = xText;
-        }
+    SIZE sizeRect;
+    ::GetTextExtentPoint32(hdc, text.c_str(), text.length(), &sizeRect);
 
-        FillRect(hdc, &rectFill, hbr);
+    int flags = DST_PREFIXTEXT;
+    if ( (stat & wxODDisabled) && !(stat & wxODSelected) )
+        flags |= DSS_DISABLED;
 
-        // use default font if no font set
-        wxFont fontToUse = GetFontToUse();
-        SelectInHDC selFont(hdc, GetHfontOf(fontToUse));
+    if ( (stat & wxODHidePrefix) )
+        flags |= DSS_HIDEPREFIX;
 
-        wxString strMenuText = m_strName.BeforeFirst('\t');
+    int x = rc.x + GetMarginWidth();
+    int y = rc.y + (rc.GetHeight() - sizeRect.cy) / 2;
+    int cx = rc.GetWidth() - GetMarginWidth();
+    int cy = sizeRect.cy;
 
-        xText += 3; // separate text from the highlight rectangle
+    ::DrawState(hdc, NULL, NULL, (LPARAM)text.wx_str(),
+                text.length(), x, y, cx, cy, flags);
 
-        SIZE sizeRect;
-        ::GetTextExtentPoint32(hdc, strMenuText.c_str(), strMenuText.length(), &sizeRect);
-
-        int flags = DST_PREFIXTEXT;
-        if ( (st & wxODDisabled) && !(st & wxODSelected) )
-            flags |= DSS_DISABLED;
-
-        if ( (st & wxODHidePrefix) &&
-                !wxMSWSystemMenuFontModule::AlwaysShowCues() )
-            flags |= DSS_HIDEPREFIX;
-
-        ::DrawState
-        (
-            hdc,
-            NULL,
-            NULL,
-            (LPARAM)strMenuText.wx_str(),
-            strMenuText.length(),
-            xText,
-            rc.y + (rc.height - sizeRect.cy) / 2, // centre vertically
-            rc.GetWidth() - margin,
-            sizeRect.cy,
-            flags
-        );
-
-        // ::SetTextAlign(hdc, TA_RIGHT) doesn't work with DSS_DISABLED or DSS_MONO
-        // as the last parameter in DrawState() (at least with Windows98). So we have
-        // to take care of right alignment ourselves.
-        if ( !m_strAccel.empty() )
-        {
-            int accel_width, accel_height;
-            dc.GetTextExtent(m_strAccel, &accel_width, &accel_height);
-            // right align accel string with right edge of menu ( offset by the
-            // margin width )
-            ::DrawState(hdc, NULL, NULL,
-                    (LPARAM)m_strAccel.wx_str(),
-                    m_strAccel.length(),
-                    rc.width - 16 - accel_width, rc.y + (rc.height - sizeRect.cy) / 2,
-                    0, 0,
-                    DST_TEXT |
-                    (((st & wxODDisabled) && !(st & wxODSelected)) ? DSS_DISABLED : 0));
-        }
-
-        (void)SetBkMode(hdc, nPrevMode);
-    }
-
-
-    // draw the bitmap
-    // ---------------
-    if ( IsCheckable() && !m_bmpChecked.Ok() )
-    {
-        if ( st & wxODChecked )
-        {
-            // what goes on: DrawFrameControl creates a b/w mask,
-            // then we copy it to screen to have right colors
-
-            // first create a monochrome bitmap in a memory DC
-            HDC hdcMem = CreateCompatibleDC(hdc);
-            HBITMAP hbmpCheck = CreateBitmap(margin, m_nHeight, 1, 1, 0);
-            SelectObject(hdcMem, hbmpCheck);
-
-            // then draw a check mark into it
-            RECT rect = { 0, 0, margin, m_nHeight };
-            if ( m_nHeight > 0 )
-            {
-                ::DrawFrameControl(hdcMem, &rect, DFC_MENU, DFCS_MENUCHECK);
-            }
-
-            // finally copy it to screen DC and clean up
-            BitBlt(hdc, rc.x, rc.y, margin, m_nHeight, hdcMem, 0, 0, SRCCOPY);
-
-            DeleteDC(hdcMem);
-            DeleteObject(hbmpCheck);
-        }
-    }
-    else
-    {
-        wxBitmap bmp;
-
-        if ( st & wxODDisabled )
-        {
-            bmp = GetDisabledBitmap();
-        }
-
-        if ( !bmp.Ok() )
-        {
-            // for not checkable bitmaps we should always use unchecked one
-            // because their checked bitmap is not set
-            bmp = GetBitmap(!IsCheckable() || (st & wxODChecked));
-
-#if wxUSE_IMAGE
-            if ( bmp.Ok() && st & wxODDisabled )
-            {
-                // we need to grey out the bitmap as we don't have any specific
-                // disabled bitmap
-                wxImage imgGrey = bmp.ConvertToImage().ConvertToGreyscale();
-                if ( imgGrey.Ok() )
-                    bmp = wxBitmap(imgGrey);
-            }
-#endif // wxUSE_IMAGE
-        }
-
-        if ( bmp.Ok() )
-        {
-            wxMemoryDC dcMem(&dc);
-            dcMem.SelectObjectAsSource(bmp);
-
-            // center bitmap
-            int nBmpWidth = bmp.GetWidth(),
-                nBmpHeight = bmp.GetHeight();
-
-            // there should be enough space!
-            wxASSERT((nBmpWidth <= rc.GetWidth()) && (nBmpHeight <= rc.GetHeight()));
-
-            int heightDiff = m_nHeight - nBmpHeight;
-            dc.Blit(rc.x + (margin - nBmpWidth) / 2,
-                    rc.y + heightDiff / 2,
-                    nBmpWidth, nBmpHeight,
-                    &dcMem, 0, 0, wxCOPY, true /* use mask */);
-
-            if ( ( st & wxODSelected ) && !( st & wxODDisabled ) && draw_bitmap_edge )
-            {
-                RECT rectBmp = { rc.GetLeft(), rc.GetTop(),
-                                 rc.GetLeft() + margin,
-                                 rc.GetTop() + m_nHeight };
-                SetBkColor(hdc, colBack);
-
-                DrawEdge(hdc, &rectBmp, BDR_RAISEDINNER, BF_RECT);
-            }
-        }
-    }
-
-    ::SetTextColor(hdc, colOldText);
-    ::SetBkColor(hdc, colOldBack);
-
     return true;
 }
 
-
 // ----------------------------------------------------------------------------
 // global helper functions implemented here
 // ----------------------------------------------------------------------------
