Index: include/wx/aui/auibook.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/include/wx/aui/auibook.h,v
retrieving revision 1.36
diff -u -r1.36 auibook.h
--- include/wx/aui/auibook.h	2006/11/28 15:25:50	1.36
+++ include/wx/aui/auibook.h	2007/01/09 11:38:37
@@ -526,8 +526,10 @@
     bool SetPageBitmap(size_t page, const wxBitmap& bitmap);
     wxBitmap GetPageBitmap(size_t page_idx) const;
 
-    size_t SetSelection(size_t new_page);
+    size_t SetSelection(size_t new_page,bool force=false);
     int GetSelection() const;
+
+    wxAuiManager *GetAuiManager() { return &m_mgr; }
 
     virtual void Split(size_t page, int direction);
    
Index: include/wx/aui/floatpane.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/include/wx/aui/floatpane.h,v
retrieving revision 1.13
diff -u -r1.13 floatpane.h
--- include/wx/aui/floatpane.h	2006/11/17 13:06:56	1.13
+++ include/wx/aui/floatpane.h	2007/01/03 00:38:24
@@ -21,6 +21,7 @@
 #if wxUSE_AUI
 
 #include "wx/frame.h"
+#include "wx/aui/framemanager.h"
 
 #if defined( __WXMSW__ ) || defined( __WXMAC__ ) ||  defined( __WXGTK__ )
 #include "wx/minifram.h"
@@ -29,20 +30,16 @@
 #define wxAuiFloatingFrameBaseClass wxFrame
 #endif
 
-class WXDLLIMPEXP_AUI wxAuiFloatingFrame : public wxAuiFloatingFrameBaseClass
+
+
+class WXDLLIMPEXP_AUI wxAuiFloatingFrameHandler : public wxEvtHandler
 {
 public:
-    wxAuiFloatingFrame(wxWindow* parent,
-                   wxAuiManager* owner_mgr,
-                   const wxAuiPaneInfo& pane,
-                   wxWindowID id = wxID_ANY,
-                   long style = wxRESIZE_BORDER | wxSYSTEM_MENU | wxCAPTION |
-                                wxFRAME_NO_TASKBAR | wxFRAME_FLOAT_ON_PARENT | 
-                                wxCLIP_CHILDREN
-                   );
-    virtual ~wxAuiFloatingFrame();
+    wxAuiFloatingFrameHandler(wxFrame* frame, wxAuiManager* owner_mgr);
+    virtual ~wxAuiFloatingFrameHandler();
     void SetPaneWindow(const wxAuiPaneInfo& pane);
     wxAuiManager* GetOwnerManager() const;
+    wxFrame *GetFrame();
     
 protected:
     virtual void OnMoveStart();
@@ -55,10 +52,17 @@
     void OnMoveEvent(wxMoveEvent& event);
     void OnIdle(wxIdleEvent& event);
     void OnActivate(wxActivateEvent& event);
+    void OnFindManager(wxAuiManagerEvent& evt);
+    void OnMaximize(wxMaximizeEvent &evt);
+    void OnMinimize(wxIconizeEvent &evt);
+    void OnRemoveEventHandler(wxAuiManagerEvent &evt);
+
     static bool isMouseDown();
     
 private:
+    wxFrame*  m_frame_window;  // The frame around the pane window
     wxWindow* m_pane_window;    // pane window being managed
+    bool m_save_float_on_parent;
     bool m_solid_drag;          // true if system uses solid window drag
     bool m_moving;
     wxRect m_last_rect;
@@ -72,7 +76,7 @@
 
 #ifndef SWIG
     DECLARE_EVENT_TABLE()
-    DECLARE_CLASS(wxAuiFloatingFrame)
+    DECLARE_CLASS(wxAuiFloatingFrameHandler)
 #endif // SWIG
 };
 
Index: include/wx/aui/framemanager.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/include/wx/aui/framemanager.h,v
retrieving revision 1.44
diff -u -r1.44 framemanager.h
--- include/wx/aui/framemanager.h	2006/11/23 18:24:15	1.44
+++ include/wx/aui/framemanager.h	2007/01/09 10:36:05
@@ -26,6 +26,8 @@
 #include "wx/timer.h"
 #include "wx/sizer.h"
 
+class wxAuiNotebookEvent;
+
 enum wxAuiManagerDock
 {
     wxAUI_DOCK_NONE = 0,
@@ -34,7 +36,8 @@
     wxAUI_DOCK_BOTTOM = 3,
     wxAUI_DOCK_LEFT = 4,
     wxAUI_DOCK_CENTER = 5,
-    wxAUI_DOCK_CENTRE = wxAUI_DOCK_CENTER
+    wxAUI_DOCK_CENTRE = wxAUI_DOCK_CENTER,
+    wxAUI_DOCK_NOTEBOOK_PAGE = 6,
 };
 
 enum wxAuiManagerOption
@@ -47,6 +50,7 @@
     wxAUI_MGR_RECTANGLE_HINT           = 1 << 5,
     wxAUI_MGR_HINT_FADE                = 1 << 6,
     wxAUI_MGR_NO_VENETIAN_BLINDS_FADE  = 1 << 7,
+    wxAUI_MGR_NO_AUTO_NOTEBOOK         = 1 << 8,
 
     wxAUI_MGR_DEFAULT = wxAUI_MGR_ALLOW_FLOATING |
                         wxAUI_MGR_TRANSPARENT_HINT |
@@ -127,6 +131,8 @@
 class wxAuiDockInfo;
 class wxAuiDockArt;
 class wxAuiManagerEvent;
+class wxAuiNotebook;
+
 
 #ifndef SWIG
 WX_DECLARE_USER_EXPORTED_OBJARRAY(wxAuiDockInfo, wxAuiDockInfoArray, WXDLLIMPEXP_AUI);
@@ -135,6 +141,7 @@
 WX_DECLARE_USER_EXPORTED_OBJARRAY(wxAuiPaneInfo, wxAuiPaneInfoArray, WXDLLIMPEXP_AUI);
 WX_DEFINE_USER_EXPORTED_ARRAY_PTR(wxAuiPaneInfo*, wxAuiPaneInfoPtrArray, class WXDLLIMPEXP_AUI);
 WX_DEFINE_USER_EXPORTED_ARRAY_PTR(wxAuiDockInfo*, wxAuiDockInfoPtrArray, class WXDLLIMPEXP_AUI);
+WX_DEFINE_USER_EXPORTED_ARRAY_PTR(wxAuiNotebook*, wxAuiNotebookPtrArray, class WXDLLIMPEXP_AUI);
 #endif // SWIG
 
 extern WXDLLIMPEXP_AUI wxAuiDockInfo wxAuiNullDockInfo;
@@ -155,6 +162,7 @@
         dock_layer = 0;
         dock_row = 0;
         dock_pos = 0;
+        notebook_id = -1;
         floating_pos = wxDefaultPosition;
         floating_size = wxDefaultSize;
         best_size = wxDefaultSize;
@@ -179,6 +187,7 @@
         dock_layer = c.dock_layer;
         dock_row = c.dock_row;
         dock_pos = c.dock_pos;
+        notebook_id = c.notebook_id;
         best_size = c.best_size;
         min_size = c.min_size;
         max_size = c.max_size;
@@ -200,6 +209,7 @@
         dock_layer = c.dock_layer;
         dock_row = c.dock_row;
         dock_pos = c.dock_pos;
+        notebook_id = c.notebook_id;
         best_size = c.best_size;
         min_size = c.min_size;
         max_size = c.max_size;
@@ -224,6 +234,22 @@
         // now assign
         *this = source;
     }
+    // Copy over the members that pertain to docking position
+    wxAuiPaneInfo& SetDockPos(const wxAuiPaneInfo &source)
+    {
+       state = (state & ~optionDockingState ) |
+               (source.state & optionDockingState);
+       dock_direction = source.dock_direction;
+       dock_layer = source.dock_layer;
+       dock_row = source.dock_row;
+       dock_pos = source.dock_pos;
+       dock_proportion = source.dock_proportion;
+       floating_pos = source.floating_pos;
+       floating_size = source.floating_size;
+       rect = source.rect;
+       return *this;
+    }
+
 
     bool IsOk() const { return (window != NULL) ? true : false; }
     bool IsFixed() const { return !HasFlag(optionResizable); }
@@ -240,6 +266,11 @@
     bool IsMovable() const { return HasFlag(optionMovable); }
     bool IsDestroyOnClose() const { return HasFlag(optionDestroyOnClose); }
     bool IsMaximized() const { return HasFlag(optionMaximized); }
+    bool IsMDIChild() const { return HasFlag(optionMDIChild); }
+    bool IsFloatMaximized() const { return HasFlag(optionFloatMaximized); }
+    bool IsFloatMinimized() const { return HasFlag(optionFloatMinimized); }
+    bool IsNotebookDockable() const
+       { return HasFlag(optionNotebookDockable) && HasFlag(optionResizable); }
     bool HasCaption() const { return HasFlag(optionCaption); }
     bool HasGripper() const { return HasFlag(optionGripper); }
     bool HasBorder() const { return HasFlag(optionPaneBorder); }
@@ -248,6 +279,7 @@
     bool HasMinimizeButton() const { return HasFlag(buttonMinimize); }
     bool HasPinButton() const { return HasFlag(buttonPin); }
     bool HasGripperTop() const { return HasFlag(optionGripperTop); }
+    bool WantFullFrame() const { return HasFlag(optionFloatFullFrame); }
 
 #ifdef SWIG
     %typemap(out) wxAuiPaneInfo& { $result = $self; Py_INCREF($result); }
@@ -275,10 +307,28 @@
     wxAuiPaneInfo& FloatingPosition(int x, int y) { floating_pos.x = x; floating_pos.y = y; return *this; }
     wxAuiPaneInfo& FloatingSize(const wxSize& size) { floating_size = size; return *this; }
     wxAuiPaneInfo& FloatingSize(int x, int y) { floating_size.Set(x,y); return *this; }
+    wxAuiPaneInfo& FloatMaximized(bool maximized=true) {  return SetFlag(optionFloatMaximized, maximized); }
+    wxAuiPaneInfo& FloatMinimized(bool maximized) {  return SetFlag(optionFloatMinimized, maximized); }
     wxAuiPaneInfo& Fixed() { return SetFlag(optionResizable, false); }
     wxAuiPaneInfo& Resizable(bool resizable = true) { return SetFlag(optionResizable, resizable); }
-    wxAuiPaneInfo& Dock() { return SetFlag(optionFloating, false); }
-    wxAuiPaneInfo& Float() { return SetFlag(optionFloating, true); }
+    wxAuiPaneInfo& Dock()
+    {
+        if (IsNotebookPage())
+        {
+            notebook_id = -1;
+            dock_direction = wxAUI_DOCK_NONE;
+        }
+        return SetFlag(optionFloating, false);
+    }
+    wxAuiPaneInfo& Float()
+    {
+        if (IsNotebookPage())
+        {
+            notebook_id = -1;
+            dock_direction = wxAUI_DOCK_NONE;
+        }
+        return SetFlag(optionFloating, true);
+    }
     wxAuiPaneInfo& Hide() { return SetFlag(optionHidden, true); }
     wxAuiPaneInfo& Show(bool show = true) { return SetFlag(optionHidden, !show); }
     wxAuiPaneInfo& CaptionVisible(bool visible = true) { return SetFlag(optionCaption, visible); }
@@ -297,6 +347,15 @@
     wxAuiPaneInfo& LeftDockable(bool b = true) { return SetFlag(optionLeftDockable, b); }
     wxAuiPaneInfo& RightDockable(bool b = true) { return SetFlag(optionRightDockable, b); }
     wxAuiPaneInfo& Floatable(bool b = true) { return SetFlag(optionFloatable, b); }
+    wxAuiPaneInfo& FloatFullFrame(bool b = true)
+    {
+       if (b)
+          SetFlag(buttonMaximize|buttonMinimize,true);
+       return SetFlag(optionFloatFullFrame, b);
+    }
+    wxAuiPaneInfo& MDIChild(bool b = true) { if (b) SetFlag(optionFloating,true); return SetFlag(optionMDIChild, b); }
+    wxAuiPaneInfo& NotebookDockable(bool b = true) { return SetFlag(optionNotebookDockable, b); }
+
     wxAuiPaneInfo& Movable(bool b = true) { return SetFlag(optionMovable, b); }
 
     wxAuiPaneInfo& Dockable(bool b = true)
@@ -308,6 +367,7 @@
     {
         state |= optionTopDockable | optionBottomDockable |
                  optionLeftDockable | optionRightDockable |
+                 optionNotebookDockable |
                  optionFloatable | optionMovable | optionResizable |
                  optionCaption | optionPaneBorder | buttonClose;
         return *this;
@@ -343,6 +403,39 @@
     {
         return (state & flag) ? true:false;
     }
+    // By defaulting to 1000, the tab will get placed at the end
+    wxAuiPaneInfo& NotebookPage(int id,int tab_position=1000)
+    {
+       // Remove any floating frame
+       Dock();
+       notebook_id = id;
+       dock_pos = tab_position;
+       dock_row = 0;
+       dock_layer = 0;
+       dock_direction = wxAUI_DOCK_NOTEBOOK_PAGE;
+       return *this;
+    }
+    wxAuiPaneInfo& NotebookControl(int id)
+    {
+       notebook_id = id;
+       window = 0;
+       buttons.Empty();
+       if (dock_direction==wxAUI_DOCK_NOTEBOOK_PAGE)
+          dock_direction = wxAUI_DOCK_NONE;
+       return *this;
+    }
+    bool HasNotebook() const { return notebook_id>=0; }
+    bool IsNotebookPage() const
+      { return notebook_id>=0 && dock_direction==wxAUI_DOCK_NOTEBOOK_PAGE; }
+    bool IsNotebookControl() const
+      { return !IsNotebookPage() && HasNotebook(); }
+
+    wxAuiPaneInfo& SetNameFromNotebookId()
+    {
+       if (notebook_id>=0)
+          name.Printf(wxT("__notebook_%d"),notebook_id);
+       return *this;
+    }
 
 #ifdef SWIG
     %typemap(out) wxAuiPaneInfo& ;
@@ -375,18 +468,27 @@
         optionActive          = 1 << 14,
         optionGripperTop      = 1 << 15,
         optionMaximized       = 1 << 16,
+        optionFloatFullFrame  = 1 << 17,
+        optionMDIChild        = 1 << 18,
+        optionFloatMaximized  = 1 << 19,
+        optionFloatMinimized  = 1 << 20,
+        optionNotebookDockable= 1 << 25, // note - out of order
 
         buttonClose           = 1 << 21,
         buttonMaximize        = 1 << 22,
         buttonMinimize        = 1 << 23,
         buttonPin             = 1 << 24,
-        
+        // 25 - used above.
         buttonCustom1         = 1 << 26,
         buttonCustom2         = 1 << 27,
         buttonCustom3         = 1 << 28,
         
         savedHiddenState      = 1 << 30, // used internally
-        actionPane            = 1 << 31  // used internally
+        actionPane            = 1 << 31, // used internally
+
+        // These are the options to do with where the pane is docked
+        optionDockingState = optionFloating | optionMDIChild |
+                optionFloatMaximized | optionFloatMinimized,
     };
 
 public:
@@ -402,6 +504,8 @@
     int dock_row;         // row number on the docking bar (0 = first row)
     int dock_pos;         // position inside the row (0 = first position)
 
+    int notebook_id;      // Notebook associated with pane. -1 if none.
+
     wxSize best_size;     // size that the layout engine will prefer
     wxSize min_size;      // minimum size the pane window can tolerate
     wxSize max_size;      // maximum size the pane window can tolerate
@@ -417,16 +521,17 @@
 
 
 
-class WXDLLIMPEXP_AUI wxAuiFloatingFrame;
+class WXDLLIMPEXP_AUI wxAuiFloatingFrameHandler;
 
 class WXDLLIMPEXP_AUI wxAuiManager : public wxEvtHandler
 {
-friend class wxAuiFloatingFrame;
+friend class wxAuiFloatingFrameHandler;
 
 public:
 
     wxAuiManager(wxWindow* managed_wnd = NULL,
-                   unsigned int flags = wxAUI_MGR_DEFAULT);
+                   unsigned int flags = wxAUI_MGR_DEFAULT,
+                   wxAuiManager *master_manager=0);
     virtual ~wxAuiManager();
     void UnInit();
 
@@ -447,6 +552,7 @@
     wxAuiPaneInfo& GetPane(wxWindow* window);
     wxAuiPaneInfo& GetPane(const wxString& name);
     wxAuiPaneInfoArray& GetAllPanes();
+    void ShowPane(wxWindow *window,bool show=true);
 
     bool AddPane(wxWindow* window,
                  const wxAuiPaneInfo& pane_info);
@@ -480,9 +586,11 @@
     void RestorePane(wxAuiPaneInfo& pane_info);
     void RestoreMaximizedPane();
 
+    int AddNotebook(wxAuiPaneInfo dock_info);
+
 public:
 
-    virtual wxAuiFloatingFrame* CreateFloatingFrame(wxWindow* parent, const wxAuiPaneInfo& p);
+    virtual wxAuiFloatingFrameHandler* CreateFloatingFrame(wxWindow* parent, const wxAuiPaneInfo& p);
 
     void StartPaneDrag(
                  wxWindow* pane_window,
@@ -540,6 +648,7 @@
                 const wxPoint& pt,
                 const wxPoint& action_offset = wxPoint(0,0));
 
+
     wxAuiDockUIPart* HitTest(int x, int y);
     wxAuiDockUIPart* GetPanePart(wxWindow* pane);
     int GetDockPixelOffset(wxAuiPaneInfo& test);
@@ -549,6 +658,8 @@
     void OnFloatingPaneActivated(wxWindow* window);
     void OnFloatingPaneClosed(wxWindow* window, wxCloseEvent& evt);
     void OnFloatingPaneResized(wxWindow* window, const wxSize& size);
+    void OnFloatingPaneMaximized(wxWindow* window,bool maximized);
+    void OnFloatingPaneMinimized(wxWindow* window,bool minimized);
     void Render(wxDC* dc);
     void Repaint(wxDC* dc = NULL);
     void ProcessMgrEvent(wxAuiManagerEvent& event);
@@ -558,7 +669,20 @@
                               wxArrayInt& positions,
                               wxArrayInt& sizes);
 
+    // Snooped from notebooks
+    wxAuiPaneInfo &PaneFromTabEvent(wxAuiNotebookEvent& event);
+    void OnTabBeginDrag(wxAuiNotebookEvent& event);
+    void OnTabPageClose(wxAuiNotebookEvent& event);
+
+
+    wxAuiNotebookPtrArray &GetNotebooks()
+    {
+       if (m_master_manager)
+          return m_master_manager->GetNotebooks();
+       return m_notebooks;
+    }
 
+    void SetMasterManager(wxAuiManager *manager) { m_master_manager=manager; }
 public:
 
     // public events (which can be invoked externally)
@@ -594,6 +718,7 @@
 
 protected:
 
+    wxAuiManager *m_master_manager;
     wxWindow* m_frame;           // the window being managed
     wxAuiDockArt* m_art;            // dock art object which does all drawing
     unsigned int m_flags;        // manager flags wxAUI_MGR_*
@@ -601,6 +726,7 @@
     wxAuiPaneInfoArray m_panes;     // array of panes structures
     wxAuiDockInfoArray m_docks;     // array of docks structures
     wxAuiDockUIPartArray m_uiparts; // array of UI parts (captions, buttons, etc)
+    wxAuiNotebookPtrArray m_notebooks; // Auto notbooks - referenced by "notebook_id" in the wxAuiPaneInfo
 
     int m_action;                // current mouse action
     wxPoint m_action_start;      // position where the action click started
@@ -806,6 +932,7 @@
     DECLARE_EXPORTED_EVENT_TYPE(WXDLLIMPEXP_AUI, wxEVT_AUI_PANE_RESTORE, 0)
     DECLARE_EXPORTED_EVENT_TYPE(WXDLLIMPEXP_AUI, wxEVT_AUI_RENDER, 0)
     DECLARE_EXPORTED_EVENT_TYPE(WXDLLIMPEXP_AUI, wxEVT_AUI_FIND_MANAGER, 0)
+    DECLARE_EXPORTED_EVENT_TYPE(WXDLLIMPEXP_AUI, wxEVT_AUI_REMOVE_EVENT_HANDLER, 0)
 END_DECLARE_EVENT_TYPES()
 
 typedef void (wxEvtHandler::*wxAuiManagerEventFunction)(wxAuiManagerEvent&);
@@ -825,6 +952,8 @@
    wx__DECLARE_EVT0(wxEVT_AUI_RENDER, wxAuiManagerEventHandler(func))
 #define EVT_AUI_FIND_MANAGER(func) \
    wx__DECLARE_EVT0(wxEVT_AUI_FIND_MANAGER, wxAuiManagerEventHandler(func))
+#define EVT_AUI_REMOVE_EVENT_HANDLER(func) \
+   wx__DECLARE_EVT0(wxEVT_AUI_REMOVE_EVENT_HANDLER, wxAuiManagerEventHandler(func))
 
 #else
 
@@ -834,6 +963,7 @@
 %constant wxEventType wxEVT_AUI_PANE_RESTORE;
 %constant wxEventType wxEVT_AUI_RENDER;
 %constant wxEventType wxEVT_AUI_FIND_MANAGER;
+%constant wxEventType wxEVT_AUI_REMOVE_EVENT_HANDLER;
 
 %pythoncode {
     EVT_AUI_PANE_BUTTON = wx.PyEventBinder( wxEVT_AUI_PANE_BUTTON )
@@ -842,6 +972,7 @@
     EVT_AUI_PANE_RESTORE = wx.PyEventBinder( wxEVT_AUI_PANE_RESTORE )
     EVT_AUI_RENDER = wx.PyEventBinder( wxEVT_AUI_RENDER )
     EVT_AUI_FIND_MANAGER = wx.PyEventBinder( wxEVT_AUI_FIND_MANAGER )
+    EVT_AUI_REMOVE_EVENT_HANDLER = wx.PyEventBinder( wxEVT_AUI_REMOVE_EVENT_HANDLER )
 }
 #endif // SWIG
 
Index: src/aui/auibook.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/aui/auibook.cpp,v
retrieving revision 1.89
diff -u -r1.89 auibook.cpp
--- src/aui/auibook.cpp	2006/11/28 15:25:59	1.89
+++ src/aui/auibook.cpp	2007/01/09 11:40:52
@@ -2010,6 +2010,9 @@
     wxWindow* wnd;
     if (TabHitTest(evt.m_x, evt.m_y, &wnd))
     {
+        m_click_pt.x = evt.m_x;
+        m_click_pt.y = evt.m_y;
+
         int new_selection = GetIdxFromWindow(wnd);
 
         // wxAuiNotebooks always want to receive this event
@@ -2025,8 +2028,6 @@
             GetEventHandler()->ProcessEvent(e);
         }
 
-        m_click_pt.x = evt.m_x;
-        m_click_pt.y = evt.m_y;
         m_click_tab = wnd;
     }
 
@@ -2795,10 +2796,10 @@
 }
 
 // SetSelection() sets the currently active page
-size_t wxAuiNotebook::SetSelection(size_t new_page)
+size_t wxAuiNotebook::SetSelection(size_t new_page,bool force)
 {
     // don't change the page unless necessary
-    if ((int)new_page == m_curpage)
+    if ((int)new_page == m_curpage && !force)
         return m_curpage;
 
     wxWindow* wnd = m_tabs.GetWindowFromIdx(new_page);
Index: src/aui/floatpane.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/aui/floatpane.cpp,v
retrieving revision 1.24
diff -u -r1.24 floatpane.cpp
--- src/aui/floatpane.cpp	2006/11/23 18:24:11	1.24
+++ src/aui/floatpane.cpp	2007/01/09 11:40:52
@@ -36,27 +36,17 @@
 #include "wx/msw/private.h"
 #endif
 
-IMPLEMENT_CLASS(wxAuiFloatingFrame, wxAuiFloatingFrameBaseClass)
+IMPLEMENT_CLASS(wxAuiFloatingFrameHandler, wxEvtHandler)
 
-wxAuiFloatingFrame::wxAuiFloatingFrame(wxWindow* parent,
-                wxAuiManager* owner_mgr,
-                const wxAuiPaneInfo& pane,
-                wxWindowID id /*= wxID_ANY*/,
-                long style /*=wxRESIZE_BORDER | wxSYSTEM_MENU | wxCAPTION |
-                              wxFRAME_NO_TASKBAR | wxFRAME_FLOAT_ON_PARENT | 
-                              wxCLIP_CHILDREN
-                           */)
-                : wxAuiFloatingFrameBaseClass(parent, id, wxEmptyString,
-                        pane.floating_pos, pane.floating_size,
-                        style | 
-                        (pane.HasCloseButton()?wxCLOSE_BOX:0) |
-                        (pane.HasMaximizeButton()?wxMAXIMIZE_BOX:0) |
-                        (pane.IsFixed()?0:wxRESIZE_BORDER)
-                        )
+
+wxAuiFloatingFrameHandler::wxAuiFloatingFrameHandler(wxFrame* frame,
+                wxAuiManager* owner_mgr) : m_mgr(0,wxAUI_MGR_DEFAULT,owner_mgr)
 {
+    m_frame_window = frame;
+    m_frame_window->PushEventHandler(this);
     m_owner_mgr = owner_mgr;
     m_moving = false;
-    m_mgr.SetManagedWindow(this);
+    m_mgr.SetManagedWindow(frame);
     m_solid_drag = true;
     
     // find out if the system supports solid window drag.
@@ -66,24 +56,22 @@
     SystemParametersInfo(38 /*SPI_GETDRAGFULLWINDOWS*/, 0, &b, 0);
     m_solid_drag = b ? true : false;
 #endif
-    
-    SetExtraStyle(wxWS_EX_PROCESS_IDLE);
 }
 
-wxAuiFloatingFrame::~wxAuiFloatingFrame()
+wxAuiFloatingFrameHandler::~wxAuiFloatingFrameHandler()
 {
     // if we do not do this, then we can crash...
-    if(m_owner_mgr && m_owner_mgr->m_action_window == this)
+    if(m_owner_mgr && m_owner_mgr->m_action_window == m_frame_window)
     {
         m_owner_mgr->m_action_window = NULL;
     }
     m_mgr.UnInit();
 }
 
-void wxAuiFloatingFrame::SetPaneWindow(const wxAuiPaneInfo& pane)
+void wxAuiFloatingFrameHandler::SetPaneWindow(const wxAuiPaneInfo& pane)
 {
     m_pane_window = pane.window;
-    m_pane_window->Reparent(this);
+    m_pane_window->Reparent(m_frame_window);
 
     wxAuiPaneInfo contained_pane = pane;
     contained_pane.Dock().Center().Show().
@@ -96,16 +84,16 @@
     
     // if the frame window's max size is greater than the min size
     // then set the max size to the min size as well
-    wxSize cur_max_size = GetMaxSize();
+    wxSize cur_max_size = m_frame_window->GetMaxSize();
     if (cur_max_size.IsFullySpecified() &&
           (cur_max_size.x < pane.min_size.x ||
            cur_max_size.y < pane.min_size.y)
        )
     {
-        SetMaxSize(pane_min_size);
+        m_frame_window->SetMaxSize(pane_min_size);
     }
     
-    SetMinSize(pane.window->GetMinSize());
+    m_frame_window->SetMinSize(pane.window->GetMinSize());
 
     m_mgr.AddPane(m_pane_window, contained_pane);
     m_mgr.Update();
@@ -115,16 +103,18 @@
         // because SetSizeHints() calls Fit() too (which sets the window
         // size to its minimum allowed), we keep the size before calling
         // SetSizeHints() and reset it afterwards...
-        wxSize tmp = GetSize();
-        GetSizer()->SetSizeHints(this);
-        SetSize(tmp);
+        wxSize tmp = m_frame_window->GetSize();
+        wxSizer *sizer = m_frame_window->GetSizer();
+        if (sizer)
+           sizer->SetSizeHints(m_frame_window);
+        m_frame_window->SetSize(tmp);
     }
 
-    SetTitle(pane.caption);
+    m_frame_window->SetTitle(pane.caption);
 
     if (pane.floating_size != wxDefaultSize)
     {
-        SetSize(pane.floating_size);
+        m_frame_window->SetSize(pane.floating_size);
     }
         else
     {
@@ -141,29 +131,44 @@
                 size.x += m_owner_mgr->m_art->GetMetric(wxAUI_DOCKART_GRIPPER_SIZE);
         }
 
-        SetClientSize(size);
+        m_frame_window->SetClientSize(size);
+        // Make sure that SetClientSize generates a frame-size event.
+        m_owner_mgr->OnFloatingPaneResized(m_pane_window,
+           m_frame_window->GetSize());
     }
 }
 
-wxAuiManager* wxAuiFloatingFrame::GetOwnerManager() const
+wxAuiManager* wxAuiFloatingFrameHandler::GetOwnerManager() const
 {
     return m_owner_mgr;
 }
 
+wxFrame *wxAuiFloatingFrameHandler::GetFrame()
+{
+   return m_frame_window;
+}
 
-void wxAuiFloatingFrame::OnSize(wxSizeEvent& event)
+
+
+void wxAuiFloatingFrameHandler::OnSize(wxSizeEvent& event)
 {
+    // Don't get an event on "Restore" so poll here ...
+    if (!m_frame_window->IsMaximized())
+       m_owner_mgr->OnFloatingPaneMaximized(m_pane_window, false);
+    if (!m_frame_window->IsIconized())
+       m_owner_mgr->OnFloatingPaneMinimized(m_pane_window, false);
+       
     m_owner_mgr->OnFloatingPaneResized(m_pane_window, event.GetSize());
 }
 
-void wxAuiFloatingFrame::OnClose(wxCloseEvent& evt)
+void wxAuiFloatingFrameHandler::OnClose(wxCloseEvent& evt)
 {
     m_owner_mgr->OnFloatingPaneClosed(m_pane_window, evt);
     if (!evt.GetVeto())
-        Destroy();
+        m_frame_window->Destroy();
 }
 
-void wxAuiFloatingFrame::OnMoveEvent(wxMoveEvent& event)
+void wxAuiFloatingFrameHandler::OnMoveEvent(wxMoveEvent& event)
 {
     if (!m_solid_drag)
     {
@@ -179,7 +184,7 @@
     }
     
     
-    wxRect win_rect = GetRect();
+    wxRect win_rect = m_frame_window->GetRect();
 
     if (win_rect == m_last_rect)
         return;
@@ -250,7 +255,7 @@
     OnMoving(event.GetRect(), dir);
 }
 
-void wxAuiFloatingFrame::OnIdle(wxIdleEvent& event)
+void wxAuiFloatingFrameHandler::OnIdle(wxIdleEvent& event)
 {
     if (m_moving)
     {
@@ -266,26 +271,39 @@
     }
 }
 
-void wxAuiFloatingFrame::OnMoveStart()
+void wxAuiFloatingFrameHandler::OnMoveStart()
 {
+    // Stop the main window gaining focus and drawing over the top of us...
+    m_save_float_on_parent = 0!= (m_frame_window->GetWindowStyle() &
+        (wxSTAY_ON_TOP | wxFRAME_FLOAT_ON_PARENT) );
+    if (!m_save_float_on_parent)
+    {
+       m_frame_window->SetWindowStyle( m_frame_window->GetWindowStyle() | wxSTAY_ON_TOP);
+    }
     // notify the owner manager that the pane has started to move
     m_owner_mgr->OnFloatingPaneMoveStart(m_pane_window);
 }
 
-void wxAuiFloatingFrame::OnMoving(const wxRect& WXUNUSED(window_rect), wxDirection dir)
+void wxAuiFloatingFrameHandler::OnMoving(const wxRect& WXUNUSED(window_rect), wxDirection dir)
 {
     // notify the owner manager that the pane is moving
     m_owner_mgr->OnFloatingPaneMoving(m_pane_window, dir);
     m_lastDirection = dir;
 }
 
-void wxAuiFloatingFrame::OnMoveFinished()
+void wxAuiFloatingFrameHandler::OnMoveFinished()
 {
+    // Restore falg if required ...
+    if (!m_save_float_on_parent)
+    {
+       m_frame_window->SetWindowStyle( m_frame_window->GetWindowStyle() & ~wxSTAY_ON_TOP);
+    }
+
     // notify the owner manager that the pane has finished moving
     m_owner_mgr->OnFloatingPaneMoved(m_pane_window, m_lastDirection);
 }
 
-void wxAuiFloatingFrame::OnActivate(wxActivateEvent& event)
+void wxAuiFloatingFrameHandler::OnActivate(wxActivateEvent& event)
 {
     if (event.GetActive())
     {
@@ -293,23 +311,58 @@
     }
 }
 
+void wxAuiFloatingFrameHandler::OnFindManager(wxAuiManagerEvent& evt)
+{
+    evt.SetManager(&m_mgr);
+}
+
+void wxAuiFloatingFrameHandler::OnMaximize(wxMaximizeEvent &WXUNUSED(evt))
+{
+   // Maximized removes minimized ...
+   m_owner_mgr->OnFloatingPaneMinimized(m_pane_window, false);
+
+   m_owner_mgr->OnFloatingPaneMaximized(m_pane_window,
+                    m_frame_window->IsMaximized());
+}
+
+void wxAuiFloatingFrameHandler::OnMinimize(wxIconizeEvent &WXUNUSED(evt))
+{
+   m_owner_mgr->OnFloatingPaneMaximized(m_pane_window, false);
+
+   m_owner_mgr->OnFloatingPaneMinimized(m_pane_window,
+                    m_frame_window->IsIconized());
+}
+
+void wxAuiFloatingFrameHandler::OnRemoveEventHandler(wxAuiManagerEvent &WXUNUSED(evt))
+{
+   m_frame_window->RemoveEventHandler(this);
+   m_mgr.UnInit();
+   delete this;
+}
+
+
+
 // utility function which determines the state of the mouse button
 // (independant of having a wxMouseEvent handy) - utimately a better
 // mechanism for this should be found (possibly by adding the
 // functionality to wxWidgets itself)
-bool wxAuiFloatingFrame::isMouseDown()
+bool wxAuiFloatingFrameHandler::isMouseDown()
 {
     return wxGetMouseState().LeftDown();
 }
 
 
-BEGIN_EVENT_TABLE(wxAuiFloatingFrame, wxAuiFloatingFrameBaseClass)
-    EVT_SIZE(wxAuiFloatingFrame::OnSize)
-    EVT_MOVE(wxAuiFloatingFrame::OnMoveEvent)
-    EVT_MOVING(wxAuiFloatingFrame::OnMoveEvent)
-    EVT_CLOSE(wxAuiFloatingFrame::OnClose)
-    EVT_IDLE(wxAuiFloatingFrame::OnIdle)
-    EVT_ACTIVATE(wxAuiFloatingFrame::OnActivate)
+BEGIN_EVENT_TABLE(wxAuiFloatingFrameHandler, wxEvtHandler)
+    EVT_SIZE(wxAuiFloatingFrameHandler::OnSize)
+    EVT_MOVE(wxAuiFloatingFrameHandler::OnMoveEvent)
+    EVT_MOVING(wxAuiFloatingFrameHandler::OnMoveEvent)
+    EVT_CLOSE(wxAuiFloatingFrameHandler::OnClose)
+    EVT_IDLE(wxAuiFloatingFrameHandler::OnIdle)
+    EVT_ACTIVATE(wxAuiFloatingFrameHandler::OnActivate)
+    EVT_AUI_FIND_MANAGER(wxAuiFloatingFrameHandler::OnFindManager)
+    EVT_MAXIMIZE(wxAuiFloatingFrameHandler::OnMaximize)
+    EVT_ICONIZE(wxAuiFloatingFrameHandler::OnMinimize)
+    EVT_AUI_REMOVE_EVENT_HANDLER(wxAuiFloatingFrameHandler::OnRemoveEventHandler)
 END_EVENT_TABLE()
 
 
Index: src/aui/framemanager.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/aui/framemanager.cpp,v
retrieving revision 1.102
diff -u -r1.102 framemanager.cpp
--- src/aui/framemanager.cpp	2006/12/24 12:16:28	1.102
+++ src/aui/framemanager.cpp	2007/01/09 12:54:16
@@ -4,7 +4,7 @@
 // Author:      Benjamin I. Williams
 // Modified by:
 // Created:     2005-05-17
-// RCS-ID:      $Id: framemanager.cpp,v 1.102 2006/12/24 12:16:28 VZ Exp $
+// RCS-ID:      $Id: framemanager.cpp,v 1.101 2006/11/23 18:24:11 BIW Exp $
 // Copyright:   (C) Copyright 2005-2006, Kirix Corporation, All Rights Reserved
 // Licence:     wxWindows Library Licence, Version 3.1
 ///////////////////////////////////////////////////////////////////////////////
@@ -28,6 +28,7 @@
 #include "wx/aui/framemanager.h"
 #include "wx/aui/dockart.h"
 #include "wx/aui/floatpane.h"
+#include "wx/aui/auibook.h"
 
 #ifndef WX_PRECOMP
     #include "wx/panel.h"
@@ -58,6 +59,7 @@
 DEFINE_EVENT_TYPE(wxEVT_AUI_PANE_RESTORE)
 DEFINE_EVENT_TYPE(wxEVT_AUI_RENDER)
 DEFINE_EVENT_TYPE(wxEVT_AUI_FIND_MANAGER)
+DEFINE_EVENT_TYPE(wxEVT_AUI_REMOVE_EVENT_HANDLER)
 
 #ifdef __WXMAC__
     // a few defines to avoid nameclashes
@@ -485,10 +487,14 @@
     EVT_CHILD_FOCUS(wxAuiManager::OnChildFocus)
     EVT_AUI_FIND_MANAGER(wxAuiManager::OnFindManager)
     EVT_TIMER(101, wxAuiManager::OnHintFadeTimer)
+    EVT_AUINOTEBOOK_BEGIN_DRAG(-1, wxAuiManager::OnTabBeginDrag)
+    EVT_AUINOTEBOOK_PAGE_CLOSE(-1,wxAuiManager::OnTabPageClose)
+
 END_EVENT_TABLE()
 
 
-wxAuiManager::wxAuiManager(wxWindow* managed_wnd, unsigned int flags)
+wxAuiManager::wxAuiManager(wxWindow* managed_wnd, unsigned int flags,
+     wxAuiManager *master_manager)
 {
     m_action = actionNone;
     m_last_mouse_move = wxPoint();
@@ -502,6 +508,7 @@
     m_dock_constraint_x = 0.3;
     m_dock_constraint_y = 0.3;
     m_reserved = NULL;
+    m_master_manager = master_manager;
     
     if (managed_wnd)
     {
@@ -515,10 +522,56 @@
 }
 
 // creates a floating frame for the windows
-wxAuiFloatingFrame* wxAuiManager::CreateFloatingFrame(wxWindow* parent,
-                                                      const wxAuiPaneInfo& pane_info)
+wxAuiFloatingFrameHandler* wxAuiManager::CreateFloatingFrame(wxWindow* parent,
+                                          const wxAuiPaneInfo& pane_info)
 {
-    return new wxAuiFloatingFrame(parent, this, pane_info);
+
+   long style = wxRESIZE_BORDER | wxSYSTEM_MENU | wxCAPTION |
+                wxFRAME_NO_TASKBAR |
+                wxCLIP_CHILDREN |
+                (pane_info.HasCloseButton()?wxCLOSE_BOX:0) |
+                (pane_info.HasMaximizeButton()?wxMAXIMIZE_BOX:0) |
+                (pane_info.HasMinimizeButton()?wxMINIMIZE_BOX:0) |
+                (pane_info.IsFixed()?0:wxRESIZE_BORDER);
+
+   wxFrame *frame = 0;
+
+   if (pane_info.WantFullFrame())
+   {
+       if (pane_info.IsFloatMaximized())
+          style |= wxMAXIMIZE;
+       else if (pane_info.IsFloatMinimized())
+          style |= wxICONIZE;
+
+
+#if wxUSE_MDI
+        if (parent->IsKindOf(CLASSINFO(wxMDIParentFrame)) &&
+              pane_info.IsMDIChild() )
+        {
+            frame = new wxMDIChildFrame(static_cast<wxMDIParentFrame*>(parent),
+              wxID_ANY, wxEmptyString, pane_info.floating_pos,
+              pane_info.floating_size, style);
+        }
+        else
+#endif
+         frame = new wxFrame(parent, wxID_ANY, wxEmptyString,
+              pane_info.floating_pos, pane_info.floating_size, style);
+
+       if (pane_info.IsFloatMaximized())
+          frame->Maximize();
+       else if (pane_info.IsFloatMinimized())
+          frame->Iconize();
+   }
+   else
+   {
+       style |= wxFRAME_FLOAT_ON_PARENT;
+       frame = new wxAuiFloatingFrameBaseClass(parent, wxID_ANY, wxEmptyString,
+              pane_info.floating_pos, pane_info.floating_size, style);
+   }
+
+   frame->SetExtraStyle(wxWS_EX_PROCESS_IDLE);
+
+   return new wxAuiFloatingFrameHandler(frame, this);
 }
 
 // GetPane() looks up a wxAuiPaneInfo structure based
@@ -562,6 +615,31 @@
     return m_panes;
 }
 
+void wxAuiManager::ShowPane(wxWindow *window,bool show)
+{
+   wxAuiPaneInfo &p = GetPane(window);
+   if (p.IsOk())
+   {
+      if (p.IsNotebookPage())
+      {
+         if (show)
+         {
+            wxAuiNotebook *notebook = m_notebooks[p.notebook_id];
+            int id = notebook->GetPageIndex(p.window);
+            if (id>=0)
+               notebook->SetSelection(id);
+            ShowPane(notebook,true);
+         }
+      }
+      else
+         p.Show(show);
+      if (p.frame)
+         p.frame->Raise();
+      Update();
+   }
+}
+
+
 // HitTest() is an internal function which determines
 // which UI item the specified coordinates are over
 // (x,y) specify a position in client coordinates
@@ -776,7 +854,22 @@
     if (m_frame)
     {
         m_frame->RemoveEventHandler(this);
+
+
+        int i, pane_count;
+        for (i = 0, pane_count = m_panes.GetCount(); i < pane_count; ++i)
+        {
+            wxAuiPaneInfo& p = m_panes.Item(i);
+            if (p.frame)
+            {
+               wxAuiManagerEvent evt(wxEVT_AUI_REMOVE_EVENT_HANDLER);
+               p.frame->GetEventHandler()->ProcessEvent(evt);
+            }
+        }
+
+       m_frame = NULL;
     }
+
 }
 
 // GetManagedWindow() returns the window pointer being managed
@@ -1095,20 +1188,38 @@
         pane_info.frame = NULL;
     }
 
+
     // now we need to either destroy or hide the pane
+    wxWindow *to_destroy = 0;
     if (pane_info.IsDestroyOnClose()) 
     {
-        wxWindow * window = pane_info.window;
-        DetachPane(window);
-        if (window)
-        {
-            window->Destroy();
-        }
+        to_destroy = pane_info.window;
+        DetachPane(to_destroy);
     } 
     else 
     {
-        pane_info.Hide();
+        pane_info.Dock().Hide();
     }
+
+
+    if (pane_info.IsNotebookControl())
+    {
+       wxAuiNotebook *notebook = m_notebooks[pane_info.notebook_id];
+       while(notebook->GetPageCount())
+       {
+          wxWindow *window = notebook->GetPage(0);
+          notebook->RemovePage(0);
+          wxAuiPaneInfo &info = GetPane(window);
+          if (info.IsOk())
+          {
+             // Note: this could change out pane_info reference ...
+             ClosePane(info);
+          }
+       }
+    }
+
+    if (to_destroy)
+       to_destroy->Destroy();
 }
 
 void wxAuiManager::MaximizePane(wxAuiPaneInfo& pane_info)
@@ -1230,7 +1341,8 @@
     result += wxString::Format(wxT("floatx=%d;"), pane.floating_pos.x);
     result += wxString::Format(wxT("floaty=%d;"), pane.floating_pos.y);
     result += wxString::Format(wxT("floatw=%d;"), pane.floating_size.x);
-    result += wxString::Format(wxT("floath=%d"), pane.floating_size.y);
+    result += wxString::Format(wxT("floath=%d;"), pane.floating_size.y);
+    result += wxString::Format(wxT("notebookid=%d"), pane.notebook_id);
 
     return result;
 }
@@ -1294,6 +1406,8 @@
             pane.floating_size.x = wxAtoi(value.c_str());
         else if (val_name == wxT("floath"))
             pane.floating_size.y = wxAtoi(value.c_str());
+        else if (val_name == wxT("notebookid"))
+            pane.notebook_id = wxAtoi(value.c_str());
         else {
             wxFAIL_MSG(wxT("Bad Perspective String"));
         }
@@ -1419,12 +1533,20 @@
         wxAuiPaneInfo& p = GetPane(pane.name);
         if (!p.IsOk())
         {
-            // the pane window couldn't be found
-            // in the existing layout
-            return false;
+            if (pane.IsNotebookControl())
+            {
+               // notebook controls - auto add...
+               m_panes.Add(pane);
+            }
+            else
+            {
+               // the pane window couldn't be found
+               // in the existing layout
+               return false;
+            }
         }
-
-        p.SafeSet(pane);
+        else
+           p.SafeSet(pane);
 
     }
 
@@ -2226,7 +2348,98 @@
     return container;
 }
 
+wxAuiPaneInfo &wxAuiManager::PaneFromTabEvent(wxAuiNotebookEvent& event)
+{
+    wxObject *obj = event.GetEventObject();
+    if (obj &&  obj->IsKindOf(CLASSINFO(wxAuiTabCtrl)))
+    {
+       wxAuiTabCtrl *tab = (wxAuiTabCtrl *)obj;
+       int page_idx =  tab->GetActivePage();
+       if (page_idx>=0)
+       {
+           wxAuiNotebookPage& page = tab->GetPage(page_idx);
+           wxWindow *window = page.window;
+           if (window)
+               return GetPane(window);
+       }
+    }
+
+    return wxAuiNullPaneInfo;
+}
+
+
+void wxAuiManager::OnTabPageClose(wxAuiNotebookEvent& event)
+{
+   if (m_master_manager)
+       m_master_manager->OnTabPageClose(event);
+   else
+   {
+       wxAuiPaneInfo &p= PaneFromTabEvent(event);
+       if (p.IsOk())
+       {
+           if (p.IsDestroyOnClose())
+           {
+              // This will be destroyed by the auibook
+              DetachPane(p.window);
+           }
+           else
+           {
+              // veto it and destroy ourselves...
+              event.Veto();
+              event.wxNotifyEvent::Veto();
+              wxWindow *window = p.window;
+              DetachPane(window);
+              window->Destroy();
+           }
+       }
+   }
+}
+
+
+
+void wxAuiManager::OnTabBeginDrag(wxAuiNotebookEvent& event)
+{
+   if (m_master_manager)
+      m_master_manager->OnTabBeginDrag(event);
+   else
+   {
+      wxAuiPaneInfo &p= PaneFromTabEvent(event);
+      if (p.IsOk())
+      {
+          // It's one of ours!
+          m_action = actionDragFloatingPane;
+
+          wxPoint mouse = ::wxGetMousePosition();
+
+          // set initial float position - may have to think about this
+          //  offset a bit ore later ...
+          m_action_offset = wxPoint(20,10);
+          p.floating_pos = mouse - m_action_offset;
+          p.dock_pos = wxAUI_DOCK_NONE;
+          p.notebook_id = -1;
+
+          // float the window
+          if (p.IsMaximized())
+             RestorePane(p);
+          p.Float();
+          Update();
+
+          m_action_window = p.frame;
+
+          wxWindow *tab = (wxWindow *)event.GetEventObject();
+          if (wxWindow::GetCapture() == tab)
+             tab->ReleaseMouse();
+         m_frame->CaptureMouse();
+      }
+      else
+      {
+         // not our window
+         event.Skip();
+      }
+   }
+}
 
+
 // SetDockSizeConstraint() allows the dock constraints to be set.  For example,
 // specifying values of 0.5, 0.5 will mean that upon dock creation, a dock may
 // not be larger than half of the window's size
@@ -2246,6 +2459,18 @@
         *height_pct = m_dock_constraint_y;
 }
 
+int wxAuiManager::AddNotebook(wxAuiPaneInfo dock_info)
+{
+    int id = m_notebooks.size();
+    wxAuiNotebook *notebook = new wxAuiNotebook(m_frame);
+    // This is so we can get the tab-drag event.
+    notebook->GetAuiManager()->SetMasterManager(this);
+    m_notebooks.Add( notebook );
+    dock_info.NotebookControl(id);
+    dock_info.SetNameFromNotebookId();
+    AddPane(notebook,dock_info);
+    return id;
+}
 
 
 // Update() updates the layout.  Whenever changes are made to
@@ -2257,15 +2482,33 @@
     wxSizer* sizer;
     int i, pane_count = m_panes.GetCount();
 
-
     // destroy floating panes which have been
     // redocked or are becoming non-floating
+    // Workout how many notebooks we need.
+    int max_notebook = -1;
     for (i = 0; i < pane_count; ++i)
     {
         wxAuiPaneInfo& p = m_panes.Item(i);
+
+        max_notebook = wxMax(max_notebook,p.notebook_id);
 
-        if (!p.IsFloating() && p.frame)
+        // Should we delete the old frame?
+        if (!p.frame)
+           continue;
+
+        bool delete_frame = !p.IsFloating();
+#if wxUSE_MDI
+        // Look for change of state between MDI Child and normal floating
+        delete_frame = delete_frame ||
+           (p.frame->IsKindOf(CLASSINFO(wxMDIChildFrame)))!=p.IsMDIChild();
+#endif
+
+        if (delete_frame)
         {
+            // Clear any stray floating frame flags on a dock operation
+            if (!p.IsFloating())
+               p.MDIChild(false).FloatMaximized(false).FloatMinimized(false);
+
             // because the pane is no longer in a floating, we need to
             // reparent it to m_frame and destroy the floating frame
 
@@ -2304,6 +2547,173 @@
         }
     }
 
+    // Only the master manager should create/destroy notebooks...
+    if (m_master_manager==0)
+    {
+        // We are the master of our domain
+        int extra_notebook = m_notebooks.GetCount();
+        max_notebook++;
+        for(; extra_notebook<max_notebook; ++ extra_notebook)
+        {
+           wxAuiNotebook *notebook = new wxAuiNotebook(m_frame);
+           // This is so we can get the tab-drag event.
+           notebook->GetAuiManager()->SetMasterManager(this);
+           m_notebooks.Add( notebook );
+        }
+    
+        // Remove pages from notebooks that no-longer belong there ...
+        int nb,nb_count = m_notebooks.GetCount();
+        for(nb=0;nb<nb_count;nb++)
+        {
+           wxAuiNotebook *notebook = m_notebooks.Item(nb);
+           // Check each tab ...
+           int pages = notebook->GetPageCount();
+           for(int page=0;page<pages;page++)
+           {
+              wxWindow *window = notebook->GetPage(page);
+              wxAuiPaneInfo& pane = GetPane(window);
+              if (pane.IsOk())
+              {
+                 if (pane.notebook_id != nb)
+                 {
+                    notebook->RemovePage(page);
+                    pages--;
+                    page--;
+                    window->Reparent(m_frame);
+                 }
+              }
+           }
+        }
+    
+        // Add notebook pages that aren't there already...
+        for (i = 0; i < pane_count; ++i)
+        {
+            wxAuiPaneInfo& p = m_panes.Item(i);
+            if (p.IsNotebookPage())
+            {
+                wxAuiNotebook *notebook = m_notebooks.Item(p.notebook_id);
+                if (notebook->GetPageIndex(p.window)<0)
+                {
+                   p.window->Reparent(notebook);
+    
+                   wxString title(p.caption.IsEmpty()?p.name:p.caption);
+                   notebook->AddPage(p.window,title,true);
+                }
+            }
+            // Wire-up newly created notebooks
+            else if (p.IsNotebookControl() && !p.window)
+            {
+                p.window = m_notebooks.Item(p.notebook_id);
+            }
+        }
+    
+        // Delete empty notebooks, and convert notebooks with 1 page to
+        //  normal panes...
+        wxArrayInt remap_ids;
+        remap_ids.Add(-1,nb_count);
+        int nb_idx = 0;
+
+        for(nb=0;nb<nb_count;nb++)
+        {
+           wxAuiNotebook *notebook = m_notebooks.Item(nb);
+           if (notebook->GetPageCount()==1)
+           {
+              // Convert notebook page to pane...
+              wxWindow *window = notebook->GetPage(0);
+              wxAuiPaneInfo& child_pane = GetPane(window);
+              wxAuiPaneInfo& notebook_pane = GetPane(notebook);
+              if (child_pane.IsOk() && notebook_pane.IsOk())
+              {
+                 child_pane.SetDockPos(notebook_pane);
+                 child_pane.window->Reparent(m_frame);
+                 child_pane.frame = 0;
+                 child_pane.notebook_id = -1;
+
+                 DetachPane(notebook);
+                 notebook->Destroy();
+              }
+              else
+              {
+                  wxASSERT_MSG(false, wxT("Odd notebook docking"));
+              }
+           }
+           else if (notebook->GetPageCount()==0)
+           {
+              DetachPane(notebook);
+              notebook->Destroy();
+           }
+           else
+           {
+              // Check page-ordering...
+              m_notebooks[nb_idx] = notebook;
+              int pages = notebook->GetPageCount();
+              wxWindow *selected = notebook->GetPage(notebook->GetSelection());
+              bool reordered = false;
+              for(int page=0;page<pages;page++)
+              {
+                 wxWindow *win = notebook->GetPage(page);
+                 wxAuiPaneInfo *pane = &GetPane(win);
+                 if (pane->IsOk())
+                 {
+                    int lowest = pane->dock_pos;
+                    int where = -1;
+                    // Now look for panes with lower dock_poss
+                    for(int look=page+1;look<pages;look++)
+                    {
+                       wxWindow *w = notebook->GetPage(look);
+                       wxAuiPaneInfo *other = &GetPane(w);
+                       if (other->IsOk())
+                       {
+                          if (other->dock_pos < lowest)
+                          {
+                             where = look;
+                             lowest = other->dock_pos;
+                             pane = other;
+                          }
+                       }
+                    }
+                    if (where>0)
+                    {
+                       // We need to move a new pane into slot "page"
+                       notebook->RemovePage(where);
+                       wxString title(pane->caption.IsEmpty()?
+                          pane->name:pane->caption);
+                       notebook->InsertPage(page,pane->window,title);
+                       reordered = true;
+                    }
+                    // Now that we've move it, we can "normalise" the value.
+                    pane->dock_pos = page;
+                 }
+              }
+
+              if (reordered && 0)
+                 notebook->SetSelection( notebook->GetPageIndex(selected),true);
+
+              // It's a keeper.
+              remap_ids[nb] = nb_idx++;
+           }
+        }
+
+        // pane_count may have changed
+        pane_count = m_panes.GetCount();
+
+        // Apply remap...
+        if (nb_count != nb_idx)
+        {
+           m_notebooks.RemoveAt(nb_idx, nb_count-nb_idx);
+           for(i=0;i<pane_count;i++)
+           {
+              wxAuiPaneInfo& p = m_panes.Item(i);
+              if (p.notebook_id>=0)
+              {
+                 p.notebook_id = remap_ids[ p.notebook_id ];
+                 if (p.IsNotebookControl())
+                    p.SetNameFromNotebookId();
+              }
+           }
+        }
+    }
+
 
     // delete old sizer first
     m_frame->SetSizer(NULL);
@@ -2323,26 +2733,26 @@
             {
                 // we need to create a frame for this
                 // pane, which has recently been floated
-                wxAuiFloatingFrame* frame = CreateFloatingFrame(m_frame, p);
-
+                wxAuiFloatingFrameHandler* frame = CreateFloatingFrame(m_frame, p);
                 // on MSW and Mac, if the owner desires transparent dragging, and
                 // the dragging is happening right now, then the floating
                 // window should have this style by default
                 if (m_action == actionDragFloatingPane &&
                     (m_flags & wxAUI_MGR_TRANSPARENT_DRAG))
-                        frame->SetTransparent(150);
+                        frame->GetFrame()->SetTransparent(150);
 
                 frame->SetPaneWindow(p);
-                p.frame = frame;
+                p.frame = frame->GetFrame();
 
-                if (p.IsShown() && !frame->IsShown())
-                    frame->Show();
+                if (p.IsShown() && !frame->GetFrame()->IsShown())
+                    frame->GetFrame()->Show();
             }
              else
             {
                 // frame already exists, make sure it's position
                 // and size reflect the information in wxAuiPaneInfo
-                if (p.frame->GetPosition() != p.floating_pos)
+                if (p.frame->GetPosition() != p.floating_pos &&
+                      !p.frame->IsMaximized() && !p.frame->IsIconized() )
                 {
                     p.frame->SetSize(p.floating_pos.x, p.floating_pos.y,
                                      p.floating_size.x, p.floating_size.y,
@@ -2354,6 +2764,15 @@
                     //p.frame->Move(p.floating_pos.x, p.floating_pos.y);
                 */
                 }
+                // do it last so that we "remember" our restore position
+                if (p.IsFloatMaximized() != p.frame->IsMaximized())
+                {
+                   p.frame->Maximize(p.IsFloatMaximized());
+                }
+                if (p.IsFloatMinimized() != p.frame->IsIconized())
+                {
+                   p.frame->Iconize(p.IsFloatMinimized());
+                }
 
                 if (p.frame->IsShown() != p.IsShown())
                     p.frame->Show(p.IsShown());
@@ -2361,7 +2780,7 @@
         }
          else
         {
-            if (p.window->IsShown() != p.IsShown())
+            if (p.window->IsShown() != p.IsShown() && !p.IsNotebookPage())
                 p.window->Show(p.IsShown());
         }
 
@@ -2389,8 +2808,6 @@
     }
 
 
-
-
     // apply the new sizer
     m_frame->SetSizer(sizer);
     m_frame->SetAutoLayout(false);
@@ -2607,6 +3024,7 @@
 const int auiNewRowPixels = 40;
 const int auiLayerInsertPixels = 40;
 const int auiLayerInsertOffset = 5;
+const int auiMDIDragOutPixels = 5;
 
 bool wxAuiManager::DoDrop(wxAuiDockInfoArray& docks,
                           wxAuiPaneInfoArray& panes,
@@ -2623,15 +3041,56 @@
     drop.Show();
 
 
+#if wxUSE_MDI
+    if (drop.WantFullFrame() && m_frame->IsKindOf(CLASSINFO(wxMDIParentFrame)))
+    {
+        wxMDIParentFrame *mdi_frame = static_cast<wxMDIParentFrame *>(m_frame);
+        wxWindow* client_window = mdi_frame->GetClientWindow();
+
+        // pt and rect are W.R.T. mdi_frame
+        wxRect rect = client_window->GetRect();
+
+       if (rect.Contains(pt) )
+       {
+          // The MSW client window has a client area offset becuase it has a
+          //  border. We can't easily get this offset directly...
+          int cli_x=0,cli_y=0;
+          client_window->ClientToScreen(&cli_x,&cli_y);
+
+          int rect_x=rect.x,rect_y=rect.y;
+          mdi_frame->ClientToScreen(&rect_x,&rect_y);
+
+          wxPoint client_area_offset = wxPoint(cli_x-rect_x,cli_y-rect_y);
+
+
+          // Drag-out case
+          wxRect inner_rect(rect);
+          inner_rect.Deflate(auiMDIDragOutPixels,auiMDIDragOutPixels);
+          if (!inner_rect.Contains(pt) )
+          {
+             target.MDIChild(0).FloatingPosition(
+                mdi_frame->ClientToScreen(pt)-offset );
+             return true;
+          }
+
+
+          // Convert pt to offset client-area coordinates ...
+          wxPoint mdi_pt = pt-wxPoint(rect.x,rect.y) - client_area_offset;
+
+          target.MDIChild().FloatingPosition(mdi_pt-offset);
+          return true;
+       }
+    }
+#endif
+
+
     // Check to see if the pane has been dragged outside of the window
     // (or near to the outside of the window), if so, dock it along the edge
 
-
     int layer_insert_offset = auiLayerInsertOffset;
     if (drop.IsToolbar())
         layer_insert_offset = 0;
 
-
     if (pt.x < layer_insert_offset &&
         pt.x > layer_insert_offset-auiLayerInsertPixels)
     {
@@ -2697,10 +3156,10 @@
         return ProcessDockResult(target, drop);
     }
 
+    // Ok, can't drop on edge - check internals ...
 
     wxAuiDockUIPart* part = HitTest(pt.x, pt.y);
 
-
     if (drop.IsToolbar())
     {
         if (!part || !part->dock)
@@ -2809,8 +3268,45 @@
         return ProcessDockResult(target, drop);
     }
 
-
-
+    // Look to docking on floating toolbars...
+    if (!part && target.IsNotebookDockable())
+    {
+       int i, pane_count = panes.GetCount();
+       for(i=0;i<pane_count;++i)
+       {
+           wxAuiPaneInfo& p = panes.Item(i);
+           if (p.IsFloating() && p.IsShown() && p.frame &&
+                (p.IsNotebookDockable() || p.IsNotebookControl()) &&
+                !p.IsFloatMinimized() &&
+                p.frame != target.frame )
+           {
+              wxRect rect =  p.frame->GetScreenRect();
+              wxPoint screen = m_frame->ClientToScreen(pt);
+              if (rect.Contains(screen))
+              {
+                 if (!p.HasNotebook())
+                 {
+                    // Add a new notebook pane ...
+                    int id = m_notebooks.GetCount();
+ 
+                    wxAuiPaneInfo info;
+                    info.SetDockPos(p).NotebookControl(id).
+                      SetNameFromNotebookId().NotebookDockable(false);
+                    info.best_size = p.best_size;
+                    panes.Add(info);
+
+                    // add original pane as tab ...
+                    p.NotebookPage(id);
+                 }
+
+                 // Add new item to notebook
+                 drop.NotebookPage(p.notebook_id);
+                 target = drop;
+                 return true;
+              }
+           }
+       }
+    }
 
     if (!part)
         return false;
@@ -2888,6 +3384,50 @@
         int insert_dir = part->pane->dock_direction;
         int insert_layer = part->pane->dock_layer;
 
+        // Check for middle-third = create tabbed entry.
+        wxRect centre(part->rect);
+        centre.Deflate( centre.GetWidth()/3, centre.GetHeight()/3 );
+        if (target.IsNotebookDockable() &&
+            centre.Contains(pt) &&
+            !(m_flags & wxAUI_MGR_NO_AUTO_NOTEBOOK) &&
+          (part->pane->IsNotebookDockable() || part->pane->IsNotebookControl()))
+        {
+            wxAuiPaneInfo *pane = part->pane;
+            // The part->pane may still point to original values, not copies.
+            // Find the pointer to copy, if required.
+            if (&panes !=  &m_panes)
+            {
+                wxWindow *win = pane->window;
+                unsigned int idx = 0;
+                for(idx=0;idx<panes.GetCount();idx++)
+                    if (panes.Item(idx).window == win)
+                       break;
+
+                 pane = &panes.Item(idx);
+            }
+
+            if (!pane->HasNotebook())
+            {
+               // Add a new notebook pane ...
+               int id = m_notebooks.GetCount();
+
+               wxAuiPaneInfo info;
+               info.SetDockPos(*pane).NotebookControl(id).
+                  SetNameFromNotebookId().NotebookDockable(false);
+
+               info.best_size = pane->best_size;
+               panes.Add(info);
+
+               // add original pane as tab ...
+               pane->NotebookPage(id);
+            }
+
+            // Add new item to notebook
+            drop.NotebookPage(pane->notebook_id);
+            target = drop;
+            return true;
+        }
+
         switch (part->pane->dock_direction)
         {
             case wxAUI_DOCK_TOP:
@@ -3035,6 +3575,7 @@
         // if the hint rect is the same as last time, don't do anything
         if (m_last_hint == rect)
             return;
+
         m_last_hint = rect;
 
         m_hint_fadeamt = m_hint_fademax;
@@ -3219,6 +3760,12 @@
         return rect;
     }
 
+    // Special case of dragging out of MDI ...
+    if (GetPane(pane_window).IsMDIChild() && !hint.IsMDIChild())
+    {
+       return wxRect(hint.floating_pos,hint.floating_size);
+    }
+
     panes.Add(hint);
 
     wxSizer* sizer = LayoutAll(panes, docks, uiparts, true);
@@ -3226,13 +3773,29 @@
     sizer->SetDimension(0, 0, client_size.x, client_size.y);
     sizer->Layout();
 
+    wxString sought = wxT("__HINT__");
+
+    // For a notebook page, actually look for the noteboot itself.
+    if (hint.IsNotebookPage())
+    {
+       int id = hint.notebook_id;
+       for(unsigned int i=0;i<panes.GetCount();i++)
+       {
+          if (panes[i].IsNotebookControl() && panes[i].notebook_id==id)
+          {
+             sought = panes[i].name;
+             break;
+          }
+       }
+    }
+
     for (i = 0, part_count = uiparts.GetCount();
          i < part_count; ++i)
     {
         wxAuiDockUIPart& part = uiparts.Item(i);
 
         if (part.type == wxAuiDockUIPart::typePaneBorder &&
-            part.pane && part.pane->name == wxT("__HINT__"))
+            part.pane && part.pane->name == sought)
         {
             rect = wxRect(part.sizer_item->GetPosition(),
                           part.sizer_item->GetSize());
@@ -3242,8 +3805,20 @@
 
     delete sizer;
 
+    // check for floating frame ...
     if (rect.IsEmpty())
     {
+        int pane_count = panes.GetCount();
+        for(i=0;i<pane_count;i++)
+        {
+           wxAuiPaneInfo &p = panes[i];
+           if (p.name==sought && p.IsFloating() && !p.IsMDIChild() )
+               return wxRect(p.floating_pos,p.floating_size);
+        }
+    }
+
+    if (rect.IsEmpty())
+    {
         return rect;
     }
 
@@ -3337,7 +3912,7 @@
 
     // calculate the offset from the upper left-hand corner
     // of the frame to the mouse pointer
-    wxPoint frame_pos = pane.frame->GetPosition();
+    wxPoint frame_pos = pane.frame->GetScreenPosition();
     wxPoint action_offset(pt.x-frame_pos.x, pt.y-frame_pos.y);
 
     // no hint for toolbar floating windows
@@ -3440,10 +4015,11 @@
 
     // calculate the offset from the upper left-hand corner
     // of the frame to the mouse pointer
-    wxPoint frame_pos = pane.frame->GetPosition();
-    wxPoint action_offset(pt.x-frame_pos.x, pt.y-frame_pos.y);
+    wxPoint frame_pos = pane.frame->GetScreenPosition();
+    wxPoint action_offset = pt - pane.frame->GetScreenPosition();
 
 
+    bool was_mdi = pane.IsMDIChild();
     // if a key modifier is pressed while dragging the frame,
     // don't dock the window
     if (!wxGetKeyState(WXK_CONTROL) && !wxGetKeyState(WXK_ALT))
@@ -3456,7 +4032,12 @@
     // position (that we store)
     if (pane.IsFloating())
     {
-        pane.floating_pos = pane.frame->GetPosition();
+        // If we do not change our MDI status, then we can simply read the
+        //  new position as the result of the move.  Otherwise, we must look
+        //  at the drop results because there is a change in reference frame
+        //  when swapping in and out of MDI mode.
+        if (pane.IsMDIChild() == was_mdi)
+           pane.floating_pos = pane.frame->GetPosition();
 
         if (m_flags & wxAUI_MGR_TRANSPARENT_DRAG)
             pane.frame->SetTransparent(255);
@@ -3477,10 +4058,32 @@
     wxAuiPaneInfo& pane = GetPane(wnd);
     wxASSERT_MSG(pane.IsOk(), wxT("Pane window not found"));
 
-    pane.floating_size = size;
+    if (!pane.IsFloatMaximized() && !pane.IsFloatMinimized())
+       pane.floating_size = size;
 }
 
+void wxAuiManager::OnFloatingPaneMaximized(wxWindow* window,bool maximized)
+{
+    // try to find the pane
+    wxAuiPaneInfo& pane = GetPane(window);
+    wxASSERT_MSG(pane.IsOk(), wxT("Pane window not found"));
+
+    pane.FloatMaximized(maximized);
+}
 
+void wxAuiManager::OnFloatingPaneMinimized(wxWindow* window,bool minimized)
+{
+    // try to find the pane
+    wxAuiPaneInfo& pane = GetPane(window);
+    wxASSERT_MSG(pane.IsOk(), wxT("Pane window not found"));
+
+    pane.FloatMinimized(minimized);
+}
+
+
+
+
+
 void wxAuiManager::OnFloatingPaneClosed(wxWindow* wnd, wxCloseEvent& evt)
 {
     // try to find the pane
@@ -3656,24 +4259,22 @@
 
 void wxAuiManager::OnFindManager(wxAuiManagerEvent& evt)
 {
+    // Initialise to 0 ...
+    evt.SetManager(NULL);
+
     // get the window we are managing, if none, return NULL
     wxWindow* window = GetManagedWindow();
     if (!window)
     {
-        evt.SetManager(NULL);
-        return;
-    }
-    
-    // if we are managing a child frame, get the 'real' manager
-    if (window->IsKindOf(CLASSINFO(wxAuiFloatingFrame)))
-    {
-        wxAuiFloatingFrame* float_frame = static_cast<wxAuiFloatingFrame*>(window);
-        evt.SetManager(float_frame->GetOwnerManager());
         return;
     }
-        
-    // return pointer to ourself
-    evt.SetManager(this);
+
+    // See it this window wants to overwrite ...
+    window->ProcessEvent(evt);
+
+    // No? ok, it must be us..
+    if (!evt.GetManager())
+       evt.SetManager(this);
 }
 
 void wxAuiManager::OnSetCursor(wxSetCursorEvent& event)
@@ -3798,17 +4399,26 @@
                   part->type == wxAuiDockUIPart::typeGripper)
         {
             // if we are managing a wxAuiFloatingFrame window, then
-            // we are an embedded wxAuiManager inside the wxAuiFloatingFrame.
+            // we are an embedded wxAuiManager - our "root" manager should
+            //  do all the work.
             // We want to initiate a toolbar drag in our owner manager
             wxWindow* managed_wnd = GetManagedWindow();
+            wxAuiManager* owner_mgr = 0;
+
+            // Find the "root" manager ...
+            if (managed_wnd)
+            {
+               wxAuiManagerEvent evt(wxEVT_AUI_FIND_MANAGER);
+               managed_wnd->ProcessEvent(evt);
+               owner_mgr = evt.GetManager();
+            }
             
+            // Are we managed by someone else?
             if (part->pane && 
                 part->pane->window &&
                 managed_wnd &&
-                managed_wnd->IsKindOf(CLASSINFO(wxAuiFloatingFrame)))
+                owner_mgr != this && owner_mgr!=0 )
             {
-                wxAuiFloatingFrame* floating_frame = (wxAuiFloatingFrame*)managed_wnd;
-                wxAuiManager* owner_mgr = floating_frame->GetOwnerManager();
                 owner_mgr->StartPaneDrag(part->pane->window,
                                              wxPoint(event.m_x - part->rect.x,
                                                      event.m_y - part->rect.y));
@@ -4201,6 +4811,7 @@
         pane.state |= wxAuiPaneInfo::actionPane;
 
         wxPoint pt = event.GetPosition();
+
         DoDrop(m_docks, m_panes, pane, pt, m_action_offset);
 
         // if DoDrop() decided to float the pane, set up

 	  	 
