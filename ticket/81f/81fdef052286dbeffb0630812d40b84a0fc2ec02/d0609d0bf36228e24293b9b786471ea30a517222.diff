Index: configure.in
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/configure.in,v
retrieving revision 1.679
diff -u -2 -r1.679 configure.in
--- configure.in	2003/06/19 22:22:15	1.679
+++ configure.in	2003/06/20 21:25:51
@@ -312,4 +312,6 @@
 if test $DEBUG_CONFIGURE = 1; then
   DEFAULT_wxUSE_UNIVERSAL=no
+  DEFAULT_wxUSE_STL=no
+  DEFAULT_wxUSE_STL_ONLY=no
 
   DEFAULT_wxUSE_NANOX=no
@@ -485,4 +487,6 @@
 else
   DEFAULT_wxUSE_UNIVERSAL=no
+  DEFAULT_wxUSE_STL=no
+  DEFAULT_wxUSE_STL_ONLY=no
 
   DEFAULT_wxUSE_NANOX=no
@@ -724,4 +728,6 @@
 WX_ARG_ENABLE(optimise,    [  --enable-optimise       create optimised code], wxUSE_OPTIMISE)
 WX_ARG_ENABLE(debug,       [  --enable-debug          same as debug_flag and debug_info], wxUSE_DEBUG)
+WX_ARG_ENABLE(stl,         [  --enable-stl            use STL for containers], wxUSE_STL)
+WX_ARG_ENABLE(stl_only,    [  --enable-stl_only       use only STL for containers], wxUSE_STL_ONLY)
 
 dnl allow the precompiled header option to be disabled under Mac OS X/Darwin
@@ -4182,4 +4188,12 @@
 dnl Register non-GUI class options for makefiles and setup.h
 dnl ---------------------------------------------------------------------------
+
+if test "$wxUSE_STL" = "yes"; then
+  AC_DEFINE(wxUSE_STL)
+fi
+
+if test "$wxUSE_STL_ONLY" = "yes"; then
+  AC_DEFINE(wxUSE_STL_ONLY)
+fi
 
 if test "$wxUSE_APPLE_IEEE" = "yes"; then
Index: setup.h.in
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/setup.h.in,v
retrieving revision 1.113
diff -u -2 -r1.113 setup.h.in
--- setup.h.in	2003/05/24 20:06:37	1.113
+++ setup.h.in	2003/06/20 21:25:54
@@ -159,4 +159,12 @@
 
 /*
+ * use STL for containers and wxString
+ */
+#define wxUSE_STL 0
+/*
+ * use STL for containers and wxString, without backward compatibility methods
+ */
+#define wxUSE_STL_ONLY 0
+/*
  * Use regex support
  */
Index: include/wx/dynarray.h
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/include/wx/dynarray.h,v
retrieving revision 1.51
diff -u -2 -r1.51 dynarray.h
--- include/wx/dynarray.h	2003/03/17 10:33:30	1.51
+++ include/wx/dynarray.h	2003/06/20 21:26:11
@@ -19,4 +19,11 @@
 #include "wx/defs.h"
 
+#if wxUSE_STL
+#include <vector>
+#ifdef __WXMSW__
+#include "wx/msw/winundef.h"
+#endif
+#endif
+
 /*
   This header defines the dynamic arrays and object arrays (i.e. arrays which
Index: include/wx/filefn.h
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/include/wx/filefn.h,v
retrieving revision 1.71
diff -u -2 -r1.71 filefn.h
--- include/wx/filefn.h	2003/05/02 11:21:03	1.71
+++ include/wx/filefn.h	2003/06/20 21:26:13
@@ -363,10 +363,11 @@
 {
 public:
+    // avoid GCC warning about virtual functions w/o virtual dtor
+    virtual ~wxPathList() {}
+
     // Adds all paths in environment variable
     void AddEnvList(const wxString& envVariable);
 
     void Add(const wxString& path);
-    // Avoid compiler warning
-    wxNode *Add(const wxChar *s) { return wxStringList::Add(s); }
     // Find the first full path for which the file exists
     wxString FindValidPath(const wxString& filename);
@@ -380,5 +381,5 @@
 
 private:
-    DECLARE_DYNAMIC_CLASS(wxPathList)
+    // DECLARE_DYNAMIC_CLASS(wxPathList)
 };
 
Index: include/wx/filesys.h
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/include/wx/filesys.h,v
retrieving revision 1.17
diff -u -2 -r1.17 filesys.h
--- include/wx/filesys.h	2003/04/02 11:10:29	1.17
+++ include/wx/filesys.h	2003/06/20 21:26:14
@@ -161,5 +161,6 @@
 {
 public:
-    wxFileSystem() : wxObject() {m_Path = m_LastName = wxEmptyString; m_Handlers.DeleteContents(TRUE); m_FindFileHandler = NULL;}
+    wxFileSystem() : wxObject() {m_Path = m_LastName = wxEmptyString; m_FindFileHandler = NULL;}
+    ~wxFileSystem() { WX_CLEAR_LIST(wxList, m_Handlers); }
 
     // sets the current location. Every call to OpenFile is
Index: include/wx/fs_zip.h
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/include/wx/fs_zip.h,v
retrieving revision 1.13
diff -u -2 -r1.13 fs_zip.h
--- include/wx/fs_zip.h	2003/01/02 23:37:27	1.13
+++ include/wx/fs_zip.h	2003/06/20 21:26:14
@@ -25,5 +25,5 @@
 #include "wx/filesys.h"
 
-class WXDLLEXPORT wxHashTableLong;
+class WXDLLEXPORT wxLongToLongHashMap;
 
 //--------------------------------------------------------------------------------
@@ -46,5 +46,5 @@
         wxString m_Pattern, m_BaseDir, m_ZipFile;
         bool m_AllowDirs, m_AllowFiles;
-        wxHashTableLong *m_DirsFound;
+        wxLongToLongHashMap *m_DirsFound;
 
         wxString DoFind();
Index: include/wx/hash.h
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/include/wx/hash.h,v
retrieving revision 1.20
diff -u -2 -r1.20 hash.h
--- include/wx/hash.h	2002/08/31 11:29:10	1.20
+++ include/wx/hash.h	2003/06/20 21:26:17
@@ -23,4 +23,7 @@
 #define wxHASH_SIZE_DEFAULT     (1000)
 
+// Make a copy of this string using 'new'
+WXDLLEXPORT wxChar* copystring(const wxChar *s);
+
 /*
  * A hash table is an array of user-definable size with lists
@@ -35,4 +38,6 @@
 // ----------------------------------------------------------------------------
 
+#if !wxUSE_STL
+
 class WXDLLEXPORT wxHashTableBase : public wxObject
 {
@@ -73,4 +78,146 @@
 };
 
+#else
+
+#include "wx/hashmap.h"
+
+union wxHashKeyValue
+{
+    long integer;
+    wxChar *string;
+};
+
+struct WXDLLEXPORT wxHashTableHash
+{
+    wxHashTableHash() { }
+    wxHashTableHash( wxKeyType keyType ) : m_keyType( keyType ) { }
+
+    wxKeyType m_keyType;
+
+    unsigned long operator ()( const wxHashKeyValue& k ) const
+    {
+        if( m_keyType == wxKEY_STRING )
+            return wxStringHash::wxCharStringHash( k.string );
+        else
+            return (unsigned long)k.integer;
+    }
+};
+
+struct WXDLLEXPORT wxHashTableEqual
+{
+    wxHashTableEqual() { }
+    wxHashTableEqual( wxKeyType keyType ) : m_keyType( keyType ) { }
+
+    wxKeyType m_keyType;
+
+    bool operator ()( const wxHashKeyValue& k1, const wxHashKeyValue& k2 ) const
+    {
+        if( m_keyType == wxKEY_STRING )
+            return wxStrcmp( k1.string, k2.string ) == 0;
+        else
+            return k1.integer == k2.integer;
+    }
+};
+
+WX_DECLARE_EXPORTED_HASH_MAP( wxHashKeyValue, 
+                              void*,
+                              wxHashTableHash,
+                              wxHashTableEqual,
+                              wxHashTableBaseBase );
+
+class WXDLLEXPORT wxHashTableBase
+{
+public:
+    wxHashTableBase( wxKeyType keyType = wxKEY_INTEGER,
+                     size_t size = wxHASH_SIZE_DEFAULT )
+        : m_map( size, wxHashTableHash( keyType ),
+                 wxHashTableEqual( keyType ) ),
+          m_keyType( keyType ) { }
+
+    ~wxHashTableBase()
+    {
+        if( m_keyType == wxKEY_STRING )
+        {
+            for( wxHashTableBaseBase::iterator it = m_map.begin(),
+                                               en = m_map.end();
+                 it != en; )
+            {
+                wxChar* tmp = it->first.string;
+                ++it;
+                delete[] tmp; // used in operator++
+            }
+        }
+    }
+
+    size_t GetCount() const { return m_map.size(); }
+protected:
+    void DoPut( long key, void* data )
+    {
+        wxHashKeyValue k; k.integer = key;
+        m_map[k] = data;
+    }
+
+    void DoPut( const wxChar* key, void* data )
+    {
+        wxHashKeyValue k; k.string = copystring( key );
+        m_map[k] = data;
+    }
+
+    void* DoGet( long key ) const
+    {
+        wxHashKeyValue k; k.integer = key;
+        wxHashTableBaseBase::const_iterator it = m_map.find( k );
+
+        return it != m_map.end() ? it->second : NULL;
+    }
+
+    void* DoGet( const wxChar* key ) const
+    {
+        wxHashKeyValue k; k.string = (wxChar*)key;
+        wxHashTableBaseBase::const_iterator it = m_map.find( k );
+
+        return it != m_map.end() ? it->second : NULL;
+    }
+
+    void* DoDelete( long key )
+    {
+        wxHashKeyValue k; k.integer = key;
+        wxHashTableBaseBase::iterator it = m_map.find( k );
+        
+        if( it != m_map.end() )
+        {
+            void* data = it->second;
+
+            m_map.erase( it );
+            return data;
+        }
+
+        return NULL;
+    }
+
+    void* DoDelete( const wxChar* key )
+    {
+        wxHashKeyValue k; k.string = (wxChar*)key;
+        wxHashTableBaseBase::iterator it = m_map.find( k );
+        
+        if( it != m_map.end() )
+        {
+            void* data = it->second;
+
+            m_map.erase( it );
+            return data;
+        }
+
+        return NULL;
+    }
+
+    wxHashTableBaseBase m_map;
+    wxKeyType m_keyType;
+};
+
+#endif // !wxUSE_STL
+
+#if !wxUSE_STL
+
 // ----------------------------------------------------------------------------
 // a hash table which stores longs
@@ -144,8 +291,106 @@
 };
 
+#endif
+
 // ----------------------------------------------------------------------------
 // for compatibility only
 // ----------------------------------------------------------------------------
 
+#if wxUSE_STL
+
+class WXDLLEXPORT wxHashTable : protected wxHashTableBase
+{
+    typedef wxHashTableBaseBase hash;
+public:
+    class dummy;
+
+    struct compatibility_iterator
+    {
+        hash::iterator m_iter;
+        hash* m_hash;
+
+        operator bool() const { return m_iter != m_hash->end(); }
+        bool operator !() const { return m_iter == m_hash->end(); }
+        compatibility_iterator( hash* li, hash::iterator it )
+            : m_iter( it ), m_hash( li ) {}
+        compatibility_iterator() { }
+
+        dummy* operator->() { return (dummy*)this; }
+    };
+    typedef class compatibility_iterator citer;
+
+    class dummy
+    {
+        typedef hash::iterator it;
+        typedef wxHashTable::citer citer;
+    public:
+        wxObject* GetData() const
+        {
+            citer* i = (citer*)this;
+            return (wxObject*)i->m_iter->second;
+        }
+        citer GetNext() const
+        {
+            citer* i = (citer*)this;
+            it lit = i->m_iter;
+            return citer( i->m_hash, ++lit );
+        }
+        citer GetPrevious() const
+        {
+            citer* i = (citer*)this;
+            it lit = i->m_iter;
+            return citer( i->m_hash, ++lit );
+        }
+        void SetData( wxObject* e )
+        {
+            citer* i = (citer*)this;
+            i->m_iter->second = e;
+        }
+    private:
+        dummy();
+    };
+public:
+    wxHashTable( wxKeyType keyType = wxKEY_INTEGER,
+                 size_t size = wxHASH_SIZE_DEFAULT )
+        : wxHashTableBase( keyType, size ) { }
+
+    void Destroy() { Clear(); }
+
+    // key and value are the same
+    void Put(long value, wxObject *object) { DoPut( value, object ); }
+    void Put(const wxChar *value, wxObject *object) { DoPut( value, object ); }
+
+    // key and value are the same
+    wxObject *Get(long value) const { return (wxObject*)DoGet( value ); }
+    wxObject *Get(const wxChar *value) const { return (wxObject*)DoGet( value ); }
+
+    // Deletes entry and returns data if found
+    wxObject *Delete(long key) { return (wxObject*)DoGet( key ); }
+    wxObject *Delete(const wxChar *key) { return (wxObject*)DoGet( key ); }
+
+#if 0
+    // Construct your own integer key from a string, e.g. in case
+    // you need to combine it with something
+    long MakeKey(const wxChar *string) const;
+#endif
+    // Way of iterating through whole hash table (e.g. to delete everything)
+    // Not necessary, of course, if you're only storing pointers to
+    // objects maintained separately
+    void BeginFind() { m_iter = citer( &this->m_map, this->m_map.begin() ); }
+    compatibility_iterator Next()
+    {
+        compatibility_iterator it = m_iter;
+        if( m_iter )
+            m_iter = m_iter->GetNext();
+        return it;
+    }
+
+    void Clear() { m_map.clear(); }
+private:
+    compatibility_iterator m_iter;
+};
+
+#else // if !wxUSE_STL
+
 class WXDLLEXPORT wxHashTable : public wxObject
 {
@@ -227,4 +472,5 @@
     size_t GetCount() const { return m_count; }
 
+    typedef wxNode* compatibility_iterator;
 private:
     size_t m_count;             // number of elements in the hashtable
@@ -234,6 +480,28 @@
 };
 
+#endif
+
+#if wxUSE_STL
+
 // defines a new type safe hash table which stores the elements of type eltype
 // in lists of class listclass
+#define _WX_DECLARE_HASH(eltype, dummy, hashclass, classexp)                  \
+    classexp hashclass : public wxHashTableBase                               \
+    {                                                                         \
+    public:                                                                   \
+        hashclass(wxKeyType keyType = wxKEY_INTEGER,                          \
+                  size_t size = wxHASH_SIZE_DEFAULT)                          \
+            : wxHashTableBase(keyType, size) { }                              \
+                                                                              \
+        ~hashclass() { Destroy(); }                                           \
+                                                                              \
+        void Destroy() { m_map.clear(); }                                     \
+        void Put(long key, eltype *data) { DoPut(key, (void*)data); }         \
+        eltype *Get(long key) const { return (eltype*)DoGet(key); }           \
+        eltype *Delete(long key) { return (eltype*)DoDelete(key); }           \
+    }
+
+#else // if !wxUSE_STL
+
 #define _WX_DECLARE_HASH(eltype, listclass, hashclass, classexp)               \
     classexp hashclass : public wxHashTableBase                                \
@@ -294,4 +562,6 @@
     }
 
+#endif
+
 // this macro is to be used in the user code
 #define WX_DECLARE_HASH(el, list, hash) \
@@ -305,4 +575,21 @@
 #define WX_DECLARE_USER_EXPORTED_HASH(el, list, hash, usergoo)  \
     _WX_DECLARE_HASH(el, list, hash, class usergoo)
+
+// delete all hash elements
+//
+// NB: the class declaration of the hash elements must be visible from the
+//     place where you use this macro, otherwise the proper destructor may not
+//     be called (a decent compiler should give a warning about it, but don't
+//     count on it)!
+#define WX_CLEAR_HASH_TABLE(array)                                           \
+    {                                                                        \
+        (array).BeginFind();                                                 \
+        wxHashTable::compatibility_iterator it = (array).Next();             \
+        while( it )                                                          \
+        {                                                                    \
+            delete it->GetData();                                            \
+            it = (array).Next();                                             \
+        }                                                                    \
+    }
 
 #endif
Index: include/wx/hashmap.h
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/include/wx/hashmap.h,v
retrieving revision 1.19
diff -u -2 -r1.19 hashmap.h
--- include/wx/hashmap.h	2003/05/01 19:47:16	1.19
+++ include/wx/hashmap.h	2003/06/20 21:26:19
@@ -557,4 +557,18 @@
                           CLASSNAME, class WXDLLEXPORT )
 
+// delete all hash elements
+//
+// NB: the class declaration of the hash elements must be visible from the
+//     place where you use this macro, otherwise the proper destructor may not
+//     be called (a decent compiler should give a warning about it, but don't
+//     count on it)!
+#define WX_CLEAR_HASH_MAP(type, array)                                       \
+    {                                                                        \
+        type##::iterator it, en;                                             \
+        for( it = (array).begin(), en = (array).end(); it != en; ++it )      \
+            delete it->second;                                               \
+        (array).clear();                                                     \
+    }
+
 #endif // _WX_HASHMAP_H_
 
Index: include/wx/list.h
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/include/wx/list.h,v
retrieving revision 1.56
diff -u -2 -r1.56 list.h
--- include/wx/list.h	2003/03/17 10:33:31	1.56
+++ include/wx/list.h	2003/06/20 21:26:25
@@ -38,27 +38,14 @@
 #include "wx/string.h"
 
-// due to circular header dependencies this function has to be declared here
-// (normally it's found in utils.h which includes itself list.h...)
-extern WXDLLEXPORT wxChar* copystring(const wxChar *s);
-
-class WXDLLEXPORT wxObjectListNode;
-typedef wxObjectListNode wxNode;
-
-// undef it to get rid of old, deprecated functions
-#define wxLIST_COMPATIBILITY
-
-// -----------------------------------------------------------------------------
-// constants
-// -----------------------------------------------------------------------------
-enum wxKeyType
-{
-    wxKEY_NONE,
-    wxKEY_INTEGER,
-    wxKEY_STRING
-};
+#if wxUSE_STL
+#include <list>
+#ifdef __WXMSW__
+#include "wx/msw/winundef.h"
+#endif
+#endif
 
-// -----------------------------------------------------------------------------
+// ----------------------------------------------------------------------------
 // types
-// -----------------------------------------------------------------------------
+// ----------------------------------------------------------------------------
 
 // type of compare function for list sort operation (as in 'qsort'): it should
@@ -73,4 +60,200 @@
 typedef int (* LINKAGEMODE wxListIterateFunction)(void *current);
 
+// ----------------------------------------------------------------------------
+// constants
+// ----------------------------------------------------------------------------
+enum wxKeyType
+{
+    wxKEY_NONE,
+    wxKEY_INTEGER,
+    wxKEY_STRING
+};
+
+#if wxUSE_STL_ONLY
+
+#define wxLIST_COMPATIBILITY
+
+#define WX_DECLARE_LIST_3(elT, dummy1, liT, dummy2, decl) \
+    WX_DECLARE_LIST_X(elT, liT, decl)
+
+#define WX_DECLARE_LIST_2(elT, liT, dummy, decl) \
+    WX_DECLARE_LIST_X(elT, liT, decl)
+
+#define WX_DECLARE_LIST_X(elT, liT, decl) \
+    WX_DECLARE_LIST_XO(elT*, liT, decl)
+
+#define WX_DECLARE_LIST_XO(elT, liT, decl) \
+    typedef std::list<elT> liT;
+
+#define WX_DECLARE_LIST(elementtype, listname)                              \
+    WX_DECLARE_LIST_X(elementtype, listname, class)
+
+#define WX_DECLARE_EXPORTED_LIST(elementtype, listname)                     \
+    WX_DECLARE_LIST_X(elementtype, listname, class WXDLLEXPORT)
+
+#define WX_DECLARE_USER_EXPORTED_LIST(elementtype, listname, usergoo)       \
+    WX_DECLARE_LIST_X(elementtype, listname, class usergoo)
+
+// this macro must be inserted in your program after
+//      #include <wx/listimpl.cpp>
+#define WX_DEFINE_LIST(name)    "don't forget to include listimpl.cpp!"
+
+#define WX_DEFINE_EXPORTED_LIST(name)      WX_DEFINE_LIST(name)
+#define WX_DEFINE_USER_EXPORTED_LIST(name) WX_DEFINE_LIST(name)
+
+#elif wxUSE_STL
+
+#define wxLIST_COMPATIBILITY
+
+#define WX_DECLARE_LIST_3(elT, dummy1, liT, dummy2, decl) \
+    WX_DECLARE_LIST_X(elT, liT, decl)
+
+#define WX_DECLARE_LIST_2(elT, liT, dummy, decl) \
+    WX_DECLARE_LIST_X(elT, liT, decl)
+
+#define WX_DECLARE_LIST_X(elT, liT, decl) \
+    WX_DECLARE_LIST_XO(elT*, liT, decl)
+
+#define WX_DECLARE_LIST_XO(elT, liT, decl) \
+    decl liT : public std::list<elT>                                          \
+    {                                                                         \
+    public:                                                                   \
+        class dummy;                                                          \
+                                                                              \
+        struct compatibility_iterator                                         \
+        {                                                                     \
+            liT::iterator m_iter;                                             \
+            liT * m_list;                                                     \
+        public:                                                               \
+            operator bool() const                                             \
+                { return m_list && m_iter != m_list->end(); }                 \
+            bool operator !() const                                           \
+                { return !m_list || m_iter == m_list->end(); }                \
+            compatibility_iterator( const liT* li, liT::iterator it )         \
+                : m_iter( it ), m_list( (liT*)li ) {}                         \
+            compatibility_iterator( liT* li, liT::iterator it )               \
+                : m_iter( it ), m_list( li ) {}                               \
+            compatibility_iterator() : m_list( NULL ) { }                     \
+            dummy* operator->() { return (dummy*)this; }                      \
+            const dummy* operator->() const { return (const dummy*)this; }    \
+        };                                                                    \
+        typedef class compatibility_iterator citer;                           \
+                                                                              \
+        class dummy                                                           \
+        {                                                                     \
+            typedef liT::iterator it;                                         \
+            typedef liT::citer citer;                                         \
+        public:                                                               \
+            elT GetData() const                                               \
+            {                                                                 \
+                citer* i = (citer*)this;                                      \
+                return *(i->m_iter);                                          \
+            }                                                                 \
+            citer GetNext() const                                             \
+            {                                                                 \
+                citer* i = (citer*)this;                                      \
+                it lit = i->m_iter;                                           \
+                return citer( i->m_list, ++lit );                             \
+            }                                                                 \
+            citer GetPrevious() const                                         \
+            {                                                                 \
+                citer* i = (citer*)this;                                      \
+                it lit = i->m_iter;                                           \
+                return citer( i->m_list, ++lit );                             \
+            }                                                                 \
+            void SetData( elT e )                                             \
+            {                                                                 \
+                citer* i = (citer*)this;                                      \
+                *(i->m_iter) = e;                                             \
+            }                                                                 \
+        private:                                                              \
+            dummy();                                                          \
+        };                                                                    \
+    protected:                                                                \
+        iterator find( elT e )                                                \
+        {                                                                     \
+            iterator it, en;                                                  \
+            for( it = begin(), en = end(); it != en; ++it )                   \
+                if( *it == e )                                                \
+                    return it;                                                \
+            return it;                                                        \
+        }                                                                     \
+    public:                                                                   \
+        liT() {};                                                             \
+                                                                              \
+        citer Append( elT e ) { push_back( e ); return GetLast(); }           \
+        void Clear() { clear(); }                                             \
+        size_t GetCount() const { return size(); }                            \
+        citer GetFirst() const { return citer( this, ((liT*)this)->begin() ); } \
+        citer GetLast() const { return citer( this, --(((liT*)this)->end()) ); } \
+        bool IsEmpty() const { return empty(); }                              \
+        bool DeleteObject( elT e )                                            \
+        {                                                                     \
+            iterator it = find( e );                                          \
+            if( it != end() )                                                 \
+            {                                                                 \
+                erase( it );                                                  \
+                return true;                                                  \
+            }                                                                 \
+            return false;                                                     \
+        }                                                                     \
+        void Erase( const compatibility_iterator& it )                        \
+        {                                                                     \
+            erase( it.m_iter );                                               \
+        }                                                                     \
+        citer Find( elT e ) const { return citer( this, ((liT*)this)->find( e ) ); } \
+        citer Member( elT e ) const { return Find( e ); }                     \
+        citer Insert( elT e )                                                 \
+            { push_front( e ); return citer( this, begin() ); }               \
+        citer Insert( size_t idx, elT e )                                     \
+            { return Insert( Item( idx ), e ); }                              \
+        citer Insert( citer idx, elT e )                                      \
+            { return citer( this, insert( idx.m_iter, e ) ); }                \
+        citer Item( size_t idx ) const                                        \
+        {                                                                     \
+            iterator it;                                                      \
+            for( it = ((liT*)this)->begin(); idx; --idx )                     \
+                ++it;                                                         \
+            return citer( this, it );                                         \
+        }                                                                     \
+        int IndexOf( elT e ) const                                            \
+        {                                                                     \
+            const_iterator it, en;                                            \
+            int idx;                                                          \
+            for( idx = 0, it = begin(), en = end(); it != en; ++it, ++idx )   \
+                if( *it == e )                                                \
+                    return idx;                                               \
+            return wxNOT_FOUND;                                               \
+        }                                                                     \
+    }
+
+#define WX_DECLARE_LIST(elementtype, listname)                              \
+    WX_DECLARE_LIST_X(elementtype, listname, class)
+
+#define WX_DECLARE_EXPORTED_LIST(elementtype, listname)                     \
+    WX_DECLARE_LIST_X(elementtype, listname, class WXDLLEXPORT)
+
+#define WX_DECLARE_USER_EXPORTED_LIST(elementtype, listname, usergoo)       \
+    WX_DECLARE_LIST_X(elementtype, listname, class usergoo)
+
+// this macro must be inserted in your program after
+//      #include <wx/listimpl.cpp>
+#define WX_DEFINE_LIST(name)    "don't forget to include listimpl.cpp!"
+
+#define WX_DEFINE_EXPORTED_LIST(name)      WX_DEFINE_LIST(name)
+#define WX_DEFINE_USER_EXPORTED_LIST(name) WX_DEFINE_LIST(name)
+
+#else // if !wxUSE_STL
+
+// due to circular header dependencies this function has to be declared here
+// (normally it's found in utils.h which includes itself list.h...)
+extern WXDLLEXPORT wxChar* copystring(const wxChar *s);
+
+class WXDLLEXPORT wxObjectListNode;
+typedef wxObjectListNode wxNode;
+
+// undef it to get rid of old, deprecated functions
+#define wxLIST_COMPATIBILITY
+
 // -----------------------------------------------------------------------------
 // key stuff: a list may be optionally keyed on integer or string key
@@ -175,4 +358,7 @@
     virtual void DeleteData() { }
 
+public:
+    // for wxList::iterator
+    void** GetDataPtr() const { return &(((wxNodeBase*)this)->m_data); }
 private:
     // optional key stuff
@@ -409,4 +595,5 @@
     public:                                                                 \
         typedef nodetype Node;                                              \
+        typedef Node* compatibility_iterator;                               \
                                                                             \
         name(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType)          \
@@ -452,4 +639,6 @@
         bool DeleteObject(Tbase *object)                                    \
             { return wxListBase::DeleteObject(object); }                    \
+        void Erase(compatibility_iterator it)                               \
+            { DeleteNode(it); }                                             \
                                                                             \
         nodetype *Find(Tbase *object) const                                 \
@@ -474,4 +663,270 @@
                                     (T *)data, key);                        \
             }                                                               \
+        /* STL interface */                                                 \
+    public:                                                                 \
+        typedef size_t size_type;                                           \
+        typedef int difference_type;                                        \
+        typedef T* value_type;                                              \
+        typedef Tbase* base_value_type;                                     \
+        typedef value_type& reference;                                      \
+        typedef const value_type& const_reference;                          \
+        typedef base_value_type& base_reference;                            \
+        typedef const base_value_type& const_base_reference;                \
+                                                                            \
+        class iterator                                                      \
+        {                                                                   \
+            typedef name list;                                              \
+        public:                                                             \
+            typedef list::Node Node;                                        \
+            typedef iterator itor;                                          \
+            typedef list::value_type* ptr_type;                             \
+                                                                            \
+            Node* m_node;                                                   \
+            Node* m_init;                                                   \
+        public:                                                             \
+            typedef list::reference reference_type;                         \
+            typedef ptr_type pointer_type;                                  \
+                                                                            \
+            iterator(Node* node, Node* init) : m_node(node), m_init(init) {}\
+            iterator() : m_node(NULL), m_init(NULL) { }                     \
+            reference_type operator*() const                                \
+                { return *(pointer_type)m_node->GetDataPtr(); }             \
+            pointer_type operator->() const                                 \
+                { return (pointer_type)m_node->GetDataPtr(); }              \
+            itor& operator++() { m_node = m_node->GetNext(); return *this; }\
+            itor operator++(int) { return itor(m_node->GetNext(), m_init); }\
+            itor& operator--()                                              \
+            {                                                               \
+                m_node = m_node ? m_node->GetPrevious() : m_init;           \
+                return *this;                                               \
+            }                                                               \
+            itor operator--(int)                                            \
+            {                                                               \
+                return itor(m_node ? m_node->GetPrevious() : m_init,        \
+                            m_init);                                        \
+            }                                                               \
+            bool operator!=(const itor& it) const                           \
+                { return it.m_node != m_node; }                             \
+            bool operator==(const itor& it) const                           \
+                { return it.m_node == m_node; }                             \
+        };                                                                  \
+        class const_iterator                                                \
+        {                                                                   \
+            typedef name list;                                              \
+        public:                                                             \
+            typedef list::Node Node;                                        \
+            typedef const_iterator itor;                                    \
+            typedef list::value_type* ptr_type;                             \
+                                                                            \
+            Node* m_node;                                                   \
+            Node* m_init;                                                   \
+        public:                                                             \
+            typedef list::const_reference reference_type;                   \
+            typedef const ptr_type pointer_type;                            \
+                                                                            \
+            const_iterator(Node* node, Node* init)                          \
+                : m_node(node), m_init(init) { }                            \
+            const_iterator() : m_node(NULL), m_init(NULL) { }               \
+            const_iterator(const iterator& it)                              \
+                : m_node(it.m_node), m_init(it.m_init) { }                  \
+            reference_type operator*() const                                \
+                { return *(pointer_type)m_node->GetDataPtr(); }             \
+            pointer_type operator->() const                                 \
+                { return (pointer_type)m_node->GetDataPtr(); }              \
+            itor& operator++() { m_node = m_node->GetNext(); return *this; }\
+            itor operator++(int) { return itor(m_node->GetNext(), m_init); }\
+            itor& operator--()                                              \
+            {                                                               \
+                m_node = m_node ? m_node->GetPrevious() : m_init;           \
+                return *this;                                               \
+            }                                                               \
+            itor operator--(int)                                            \
+            {                                                               \
+                return itor(m_node ? m_node->GetPrevious() : m_init,        \
+                            m_init);                                        \
+            }                                                               \
+            bool operator!=(const itor& it) const                           \
+                { return it.m_node != m_node; }                             \
+            bool operator==(const itor& it) const                           \
+                { return it.m_node == m_node; }                             \
+        };                                                                  \
+        class reverse_iterator                                              \
+        {                                                                   \
+            typedef name list;                                              \
+        public:                                                             \
+            typedef list::Node Node;                                        \
+            typedef reverse_iterator itor;                                  \
+            typedef list::value_type* ptr_type;                             \
+                                                                            \
+            Node* m_node;                                                   \
+            Node* m_init;                                                   \
+        public:                                                             \
+            typedef list::reference reference_type;                         \
+            typedef ptr_type pointer_type;                                  \
+                                                                            \
+            reverse_iterator(Node* node, Node* init)                        \
+                : m_node(node), m_init(init) { }                            \
+            reverse_iterator() : m_node(NULL), m_init(NULL) { }             \
+            reference_type operator*() const                                \
+                { return *(pointer_type)m_node->GetDataPtr(); }             \
+            pointer_type operator->() const                                 \
+                { return (pointer_type)m_node->GetDataPtr(); }              \
+            itor& operator++()                                              \
+                { m_node = m_node->GetPrevious(); return *this; }           \
+            itor operator++(int)                                            \
+                { return itor(m_node->GetPrevious(), m_init); }             \
+            itor& operator--()                                              \
+            { m_node = m_node ? m_node->GetNext() : m_init; return *this; } \
+            itor operator--(int)                                            \
+            { return itor(m_node ? m_node->GetNext() : m_init, m_init); }   \
+            bool operator!=(const itor& it) const                           \
+                { return it.m_node != m_node; }                             \
+            bool operator==(const itor& it) const                           \
+                { return it.m_node == m_node; }                             \
+        };                                                                  \
+        class const_reverse_iterator                                        \
+        {                                                                   \
+            typedef name list;                                              \
+        public:                                                             \
+            typedef list::Node Node;                                        \
+            typedef const_reverse_iterator itor;                            \
+            typedef list::value_type* ptr_type;                             \
+                                                                            \
+            Node* m_node;                                                   \
+            Node* m_init;                                                   \
+        public:                                                             \
+            typedef list::const_reference reference_type;                   \
+            typedef const ptr_type pointer_type;                            \
+                                                                            \
+            const_reverse_iterator(Node* node, Node* init)                  \
+                : m_node(node), m_init(init) { }                            \
+            const_reverse_iterator() : m_node(NULL), m_init(NULL) { }       \
+            const_reverse_iterator(const reverse_iterator& it)              \
+                : m_node(it.m_node), m_init(it.m_init) { }                  \
+            reference_type operator*() const                                \
+                { return *(pointer_type)m_node->GetDataPtr(); }             \
+            pointer_type operator->() const                                 \
+                { return (pointer_type)m_node->GetDataPtr(); }              \
+            itor& operator++()                                              \
+                { m_node = m_node->GetPrevious(); return *this; }           \
+            itor operator++(int)                                            \
+                { return itor(m_node->GetPrevious(), m_init); }             \
+            itor& operator--()                                              \
+                { m_node = m_node ? m_node->GetNext() : m_init; return *this;}\
+            itor operator--(int)                                            \
+            { return itor(m_node ? m_node->GetNext() : m_init, m_init); }   \
+            bool operator!=(const itor& it) const                           \
+                { return it.m_node != m_node; }                             \
+            bool operator==(const itor& it) const                           \
+                { return it.m_node == m_node; }                             \
+        };                                                                  \
+                                                                            \
+        wxEXPLICIT name(size_type n, const_reference v = value_type())      \
+            { assign(n, v); }                                               \
+        name(const_iterator first, const_iterator last)                     \
+            { assign(first, last); }                                        \
+        iterator begin() { return iterator(GetFirst(), GetLast()); }        \
+        const_iterator begin() const                                        \
+            { return const_iterator(GetFirst(), GetLast()); }               \
+        iterator end() { return iterator(NULL, GetLast()); }                \
+        const_iterator end() const { return const_iterator(NULL, GetLast()); }\
+        reverse_iterator rbegin()                                           \
+            { return reverse_iterator(GetLast(), GetFirst()); }             \
+        const_reverse_iterator rbegin() const                               \
+            { return const_reverse_iterator(GetLast(), GetFirst()); }       \
+        reverse_iterator rend() { return reverse_iterator(NULL, GetFirst()); }\
+        const_reverse_iterator rend() const                                 \
+            { return const_reverse_iterator(NULL, GetFirst()); }            \
+        void resize(size_type n, value_type v = value_type())               \
+        {                                                                   \
+            if(n < size())                                                  \
+                for(; n < size(); pop_back());                              \
+            else if(n > size())                                             \
+                for(; n > size(); push_back(v));                            \
+        }                                                                   \
+        size_type size() const { return GetCount(); }                       \
+        size_type max_size() const { return INT_MAX; }                      \
+        bool empty() const { return IsEmpty(); }                            \
+        reference front() { return *begin(); }                              \
+        const_reference front() const { return *begin(); }                  \
+        reference back() { return *--end(); }                               \
+        const_reference back() const { return *--end(); }                   \
+        void push_front(const_reference v = value_type())                   \
+            { Insert(GetFirst(), (const_base_reference)v); }                \
+        void pop_front() { DeleteNode(GetFirst()); }                        \
+        void push_back(const_reference v = value_type())                    \
+            { Append((const_base_reference)v); }                            \
+        void pop_back() { DeleteNode(GetLast()); }                          \
+        void assign(const_iterator first, const_iterator last)              \
+        {                                                                   \
+            clear();                                                        \
+            for(; first != last; ++first)                                   \
+                Append((const_base_reference)*first);                       \
+        }                                                                   \
+        void assign(size_type n, const_reference v = value_type())          \
+        {                                                                   \
+            clear();                                                        \
+            for(size_type i = 0; i < n; ++i)                                \
+                Append((const_base_reference)v);                            \
+        }                                                                   \
+        iterator insert(iterator it, const_reference v = value_type())      \
+        {                                                                   \
+            Insert(it.m_node, (const_base_reference)v);                     \
+            return iterator(it.m_node->GetPrevious(), GetLast());           \
+        }                                                                   \
+        void insert(iterator it, size_type n, const_reference v = value_type())\
+        {                                                                   \
+            for(size_type i = 0; i < n; ++i)                                \
+                Insert(it.m_node, (const_base_reference)v);                 \
+        }                                                                   \
+        void insert(iterator it, const_iterator first, const_iterator last) \
+        {                                                                   \
+            for(; first != last; ++first)                                   \
+                Insert(it.m_node, (const_base_reference)*first);            \
+        }                                                                   \
+        iterator erase(iterator it)                                         \
+        {                                                                   \
+            iterator next = iterator(it.m_node->GetNext(), GetLast());      \
+            DeleteNode(it.m_node); return next;                             \
+        }                                                                   \
+        iterator erase(iterator first, iterator last)                       \
+        {                                                                   \
+            iterator next = iterator(last.m_node->GetNext(), GetLast());    \
+            Node* node = first.m_node;                                      \
+            for(; node != last.m_node; )                                    \
+            {                                                               \
+                Node* tmp = node->GetNext();                                \
+                DeleteNode(node);                                           \
+                node = tmp;                                                 \
+            }                                                               \
+            return next;                                                    \
+        }                                                                   \
+        void clear() { Clear(); }                                           \
+        void splice(iterator it, name& l, iterator first, iterator last)    \
+            { insert(it, first, last); l.erase(first, last); }              \
+        void splice(iterator it, name& l)                                   \
+            { splice(it, l, l.begin(), l.end() ); }                         \
+        void splice(iterator it, name& l, iterator first)                   \
+        {                                                                   \
+            iterator tmp = first; ++tmp;                                    \
+            if(it == first || it == tmp) return;                            \
+            insert(it, *first);                                             \
+            l.erase(first);                                                 \
+        }                                                                   \
+        void remove(const_reference v)                                      \
+            { DeleteObject((const_base_reference)v); }                      \
+        void reverse()                                                      \
+        {                                                                   \
+            for(size_type i = 0; i < size(); ++i)                           \
+                { push_front(back()); pop_back(); }                         \
+        }                                                                   \
+     /* void swap(name& l)                                                  \
+        {                                                                   \
+            { size_t t = m_count; m_count = l.m_count; l.m_count = t; }     \
+            { bool t = m_destroy; m_destroy = l.m_destroy; l.m_destroy = t; }\
+            { wxNodeBase* t = m_nodeFirst; m_nodeFirst = l.m_nodeFirst; l.m_nodeFirst = t; }\
+            { wxNodeBase* t = m_nodeLast; m_nodeLast = l.m_nodeLast; l.m_nodeLast = t; }\
+            { wxKeyType t = m_keyType; m_keyType = l.m_keyType; l.m_keyType = t; }\
+        } */                                                                \
     }
 
@@ -498,4 +953,5 @@
 #define WX_DEFINE_USER_EXPORTED_LIST(name) WX_DEFINE_LIST(name)
 
+#endif // !wxUSE_STL
 
 // =============================================================================
@@ -521,7 +977,7 @@
 {
 public:
-#ifdef wxWARN_COMPAT_LIST_USE
+#if defined(wxWARN_COMPAT_LIST_USE) && !wxUSE_STL
     wxDEPRECATED( wxList(int key_type = wxKEY_NONE) );
-#else
+#elif !wxUSE_STL
     wxList(int key_type = wxKEY_NONE);
 #endif
@@ -530,4 +986,5 @@
    ~wxList() { }
 
+#if !wxUSE_STL
     wxList& operator=(const wxList& list)
         { (void) wxListBase::operator=(list); return *this; }
@@ -535,15 +992,22 @@
     // compatibility methods
     void Sort(wxSortCompareFunction compfunc) { wxListBase::Sort(compfunc); }
+#endif
 
+#if wxUSE_STL
+#else
     wxNode *Member(wxObject *object) const { return (wxNode *)Find(object); }
+#endif
 
 private:
+#if !wxUSE_STL
     DECLARE_DYNAMIC_CLASS(wxList)
+#endif
 };
 
+#if !wxUSE_STL
+
 // -----------------------------------------------------------------------------
 // wxStringList class for compatibility with the old code
 // -----------------------------------------------------------------------------
-
 WX_DECLARE_LIST_2(wxChar, wxStringListBase, wxStringListNode, class WXDLLEXPORT);
 
@@ -590,5 +1054,30 @@
 };
 
+#else // if wxUSE_STL
+
+WX_DECLARE_LIST_XO(wxString, wxStringListBase, class WXDLLEXPORT);
+
+class WXDLLEXPORT wxStringList : public wxStringListBase
+{
+public:
+};
+
+#endif // wxUSE_STL
+
 #endif // wxLIST_COMPATIBILITY
+
+// delete all list elements
+//
+// NB: the class declaration of the list elements must be visible from the
+//     place where you use this macro, otherwise the proper destructor may not
+//     be called (a decent compiler should give a warning about it, but don't
+//     count on it)!
+#define WX_CLEAR_LIST(type, array)                                           \
+    {                                                                        \
+        type::iterator it, en;                                               \
+        for( it = (array).begin(), en = (array).end(); it != en; ++it )      \
+            delete *it;                                                      \
+        (array).clear();                                                     \
+    }
 
 #endif
Index: include/wx/listimpl.cpp
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/include/wx/listimpl.cpp,v
retrieving revision 1.4
diff -u -2 -r1.4 listimpl.cpp
--- include/wx/listimpl.cpp	2000/07/15 19:49:56	1.4
+++ include/wx/listimpl.cpp	2003/06/20 21:26:25
@@ -10,4 +10,11 @@
 /////////////////////////////////////////////////////////////////////////////
 
+#if wxUSE_STL
+
+#undef WX_DEFINE_LIST
+#define WX_DEFINE_LIST(name)
+
+#else // if !wxUSE_STL
+
 #define _DEFINE_LIST(T, name)                   \
     void wx##name##Node::DeleteData()    \
@@ -23,2 +30,4 @@
 // don't pollute preprocessor's name space
 //#undef  _DEFINE_LIST
+
+#endif
Index: include/wx/msw/setup0.h
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/include/wx/msw/setup0.h,v
retrieving revision 1.147
diff -u -2 -r1.147 setup0.h
--- include/wx/msw/setup0.h	2003/06/16 12:31:39	1.147
+++ include/wx/msw/setup0.h	2003/06/20 21:26:32
@@ -200,4 +200,18 @@
 // ----------------------------------------------------------------------------
 
+// Set wxUSE_STL to 1 to derive wxList(Foo) and wxArray(Foo) from
+// std::list<Foo*> and std::vector<Foo*>, with a compatibility interface,
+// and for wxHashMap to be implemented with templates.
+//
+// Set wxUSE_STL_ONLY to 1 for wxList(Foo) and wxArrya(Foo) to be a
+// typedef for std::list<Foo*> and std::vector<Foo*>, _without_
+// any compatibility interface.
+//
+// Default is 0
+//
+// Recommended setting: YMMV
+#define wxUSE_STL 0
+#define wxUSE_STL_ONLY 0
+
 // Support for message/error logging. This includes wxLogXXX() functions and
 // wxLog and derived classes. Don't set this to 0 unless you really know what
Index: include/wx/protocol/http.h
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/include/wx/protocol/http.h,v
retrieving revision 1.8
diff -u -2 -r1.8 http.h
--- include/wx/protocol/http.h	2003/03/17 10:33:56	1.8
+++ include/wx/protocol/http.h	2003/06/20 21:26:33
@@ -16,7 +16,9 @@
 #if wxUSE_PROTOCOL_HTTP
 
-#include "wx/list.h"
+#include "wx/hashmap.h"
 #include "wx/protocol/protocol.h"
 
+WX_DECLARE_STRING_HASH_MAP( wxString, wxStringToStringHashMap );
+
 class WXDLLEXPORT wxHTTP : public wxProtocol {
   DECLARE_DYNAMIC_CLASS(wxHTTP)
@@ -24,5 +26,5 @@
 protected:
   wxProtocolError m_perr;
-  wxList m_headers;
+  wxStringToStringHashMap m_headers;
   bool m_read, m_proxy_mode;
   wxSockAddress *m_addr;
Index: samples/console/console.cpp
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/samples/console/console.cpp,v
retrieving revision 1.147
diff -u -2 -r1.147 console.cpp
--- samples/console/console.cpp	2003/03/28 15:28:57	1.147
+++ samples/console/console.cpp	2003/06/20 21:26:56
@@ -96,5 +96,7 @@
     static const bool TEST_ALL = true;
 #else
-    #define TEST_FILECONF
+    #define TEST_ARRAYS
+    #define TEST_HASH
+    #define TEST_LIST
 
     static const bool TEST_ALL = false;
@@ -1150,4 +1152,29 @@
 
     {
+        wxHashTable hash(wxKEY_INTEGER), hash2(wxKEY_STRING);
+        int i;
+
+        for ( i = 0; i < 100; ++i )
+            hash.Put(i, (wxObject*)&i);
+
+        hash.BeginFind();
+        wxHashTable::compatibility_iterator it = hash.Next();
+        i = 0;
+
+        while (it)
+        {
+            ++i;
+            it = hash.Next();
+        }
+
+        if (i != 100)
+            wxPuts(_T("Error in wxHashTable::compatibility_iterator\n"));
+
+        hash2.Put("foo", NULL);
+        hash2.Put("bar", NULL);
+        hash2.Put("baz", NULL);
+    }
+#if !wxUSE_STL
+    {
         wxHashFoos hash;
         hash.DeleteContents(true);
@@ -1198,6 +1225,8 @@
         }
     }
+#endif
 
     wxPrintf(_T("Hash destroyed: %u foos left\n"), Foo::count);
+    wxPuts(_T("*** Testing wxHashTable finished ***\n"));
 }
 
@@ -1362,4 +1391,102 @@
 WX_DEFINE_LIST(wxListBars);
 
+WX_DECLARE_LIST(int, wxListInt);
+WX_DEFINE_LIST(wxListInt);
+
+static void TestList()
+{
+    wxPuts(_T("*** Testing wxList operations ***\n"));
+    {
+        wxListInt list1;
+        int dummy[5];
+        int i;
+
+        for ( i = 0; i < 5; ++i )
+            list1.Append(dummy + i);
+
+        if ( list1.GetCount() != 5 )
+            wxPuts(_T("Wrong number of items in list\n"));
+
+        if ( list1.Item(3)->GetData() != dummy + 3 )
+            wxPuts(_T("Error in Item()\n"));
+
+        if ( !list1.Find(dummy + 4) )
+            wxPuts(_T("Error in Find()\n"));
+
+        wxListInt::compatibility_iterator node = list1.GetFirst();
+        i = 0;
+
+        while (node)
+        {
+            if ( node->GetData() != dummy + i )
+                wxPuts(_T("Error in compatibility_iterator\n"));
+            node = node->GetNext();
+            ++i;
+        }
+
+        if ( size_t(i) != list1.GetCount() )
+            wxPuts(_T("Error in compatibility_iterator\n"));
+
+        list1.Insert(dummy + 0);
+        list1.Insert(1, dummy + 1);
+        list1.Insert(list1.GetFirst()->GetNext()->GetNext(), dummy + 2);
+
+        node = list1.GetFirst();
+        i = 0;
+
+        while (i < 3)
+        {
+            int* t = node->GetData();
+            if ( t != dummy + i )
+                wxPuts(_T("Error in Insert\n"));
+            node = node->GetNext();
+            ++i;
+        }
+    }
+
+    wxPuts(_T("*** Testing wxList operations finished ***\n"));
+
+    wxPuts(_T("*** Testing std::list operations ***\n"));
+
+    {
+        wxListInt list1;
+        wxListInt::iterator it, en;
+        wxListInt::reverse_iterator rit, ren;
+        int i;
+        for ( i = 0; i < 5; ++i )
+            list1.push_back(i + &i);
+
+        for ( it = list1.begin(), en = list1.end(), i = 0;
+              it != en; ++it, ++i )
+            if ( *it != i + &i )
+                wxPuts(_T("Error in iterator\n"));
+
+        for ( rit = list1.rbegin(), ren = list1.rend(), i = 4;
+              rit != ren; ++rit, --i )
+            if ( *rit != i + &i )
+                wxPuts(_T("Error in reverse_iterator\n"));
+
+        if ( *list1.rbegin() != *--list1.end() ||
+             *list1.begin() != *--list1.rend() )
+            wxPuts(_T("Error in iterator/reverse_iterator\n"));
+        if ( *list1.begin() != *--++list1.begin() ||
+             *list1.rbegin() != *--++list1.rbegin() )
+            wxPuts(_T("Error in iterator/reverse_iterator\n"));
+
+        if ( list1.front() != &i || list1.back() != &i + 4 )
+            wxPuts(_T("Error in front()/back()\n"));
+
+        list1.erase(list1.begin());
+        list1.erase(--list1.end());
+
+        for ( it = list1.begin(), en = list1.end(), i = 1;
+              it != en; ++it, ++i )
+            if ( *it != i + &i )
+                wxPuts(_T("Error in erase()\n"));
+    }
+    
+    wxPuts(_T("*** Testing std::list operations finished ***\n"));
+}
+
 static void TestListCtor()
 {
@@ -1380,5 +1507,9 @@
                list1.GetCount(), list2.GetCount(), Bar::GetNumber());
 
+#if !wxUSE_STL
         list1.DeleteContents(true);
+#else
+        WX_CLEAR_LIST(wxListBars, list1);
+#endif
     }
 
@@ -6387,4 +6518,5 @@
 #ifdef TEST_LIST
     TestListCtor();
+    TestList();
 #endif // TEST_LIST
 
Index: src/files.lst
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/src/files.lst,v
retrieving revision 1.51
diff -u -2 -r1.51 files.lst
--- src/files.lst	2003/04/10 21:07:54	1.51
+++ src/files.lst	2003/06/20 21:27:05
@@ -7,5 +7,4 @@
 		common/cmdline.cpp \
 		common/config.cpp \
-		common/datacmn.cpp \
 		common/datetime.cpp \
 		common/datstrm.cpp \
@@ -197,5 +196,4 @@
 		cmdline.o \
 		config.o \
-		datacmn.o \
 		datetime.o \
 		datstrm.o \
Index: src/common/appcmn.cpp
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/src/common/appcmn.cpp,v
retrieving revision 1.50
diff -u -2 -r1.50 appcmn.cpp
--- src/common/appcmn.cpp	2003/04/09 20:30:33	1.50
+++ src/common/appcmn.cpp	2003/06/20 21:27:08
@@ -213,9 +213,10 @@
 
     // iterate until the list becomes empty
-    wxNode *node = wxPendingEvents->GetFirst();
-    while (node)
+    wxList::iterator it = wxPendingEvents->begin(),
+                     en = wxPendingEvents->end();
+    while (it != en)
     {
-        wxEvtHandler *handler = (wxEvtHandler *)node->GetData();
-        delete node;
+        wxEvtHandler *handler = (wxEvtHandler *)*it;
+        wxPendingEvents->erase( it );
 
         // In ProcessPendingEvents(), new handlers might be add
@@ -225,5 +226,5 @@
         wxENTER_CRIT_SECT( *wxPendingEventsLocker );
 
-        node = wxPendingEvents->GetFirst();
+        it = wxPendingEvents->begin();
     }
 
Index: src/common/dynload.cpp
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/src/common/dynload.cpp,v
retrieving revision 1.25
diff -u -2 -r1.25 dynload.cpp
--- src/common/dynload.cpp	2003/06/01 12:57:45	1.25
+++ src/common/dynload.cpp	2003/06/20 21:27:10
@@ -476,5 +476,5 @@
             wxASSERT_MSG( m, _T("wxDynamicCast of wxModule failed") );
 
-            m_wxmodules.Append(m);
+            m_wxmodules.push_back(m);
             wxModule::RegisterModule(m);
         }
@@ -483,9 +483,9 @@
     // FIXME: Likewise this is (well was) very similar to InitializeModules()
 
-    for ( wxModuleList::Node *node = m_wxmodules.GetFirst();
-          node;
-          node = node->GetNext())
+    for ( wxModuleList::iterator it = m_wxmodules.begin();
+          it != m_wxmodules.end();
+          ++it)
     {
-        if( !node->GetData()->Init() )
+        if( !(*it)->Init() )
         {
             wxLogDebug(_T("wxModule::Init() failed for wxPluginLibrary"));
@@ -498,11 +498,12 @@
             // shortly).
 
-            wxModuleList::Node *oldNode = 0;
+            wxModuleList::iterator oldNode = m_wxmodules.end();
             do {
-                node = node->GetNext();
-                delete oldNode;
-                wxModule::UnregisterModule( node->GetData() );
-                oldNode = node;
-            } while( node );
+                ++it;
+                if( oldNode != m_wxmodules.end() )
+                    m_wxmodules.erase(oldNode);
+                wxModule::UnregisterModule( *it );
+                oldNode = it;
+            } while( it != m_wxmodules.end() );
 
             --m_linkcount;     // Flag us for deletion
@@ -514,13 +515,13 @@
 void wxPluginLibrary::UnregisterModules()
 {
-    wxModuleList::Node  *node;
+    wxModuleList::iterator it;
 
-    for ( node = m_wxmodules.GetFirst(); node; node = node->GetNext() )
-        node->GetData()->Exit();
+    for ( it = m_wxmodules.begin(); it != m_wxmodules.end(); ++it )
+        (*it)->Exit();
 
-    for ( node = m_wxmodules.GetFirst(); node; node = node->GetNext() )
-        wxModule::UnregisterModule( node->GetData() );
+    for ( it = m_wxmodules.begin(); it != m_wxmodules.end(); ++it )
+        wxModule::UnregisterModule( *it );
 
-    m_wxmodules.DeleteContents(TRUE);
+    WX_CLEAR_LIST(wxModuleList, m_wxmodules);
 }
 
Index: src/common/event.cpp
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/src/common/event.cpp,v
retrieving revision 1.117
diff -u -2 -r1.117 event.cpp
--- src/common/event.cpp	2003/06/01 14:37:25	1.117
+++ src/common/event.cpp	2003/06/20 21:27:14
@@ -636,5 +636,5 @@
     if (m_dynamicEvents)
     {
-        wxNode *node = m_dynamicEvents->GetFirst();
+        wxList::compatibility_iterator node = m_dynamicEvents->GetFirst();
         while (node)
         {
@@ -742,9 +742,9 @@
 #endif
 
-    wxNode *node = m_pendingEvents->GetFirst();
+    wxList::compatibility_iterator node = m_pendingEvents->GetFirst();
     while ( node )
     {
         wxEvent *event = (wxEvent *)node->GetData();
-        delete node;
+        m_pendingEvents->Erase(node);
 
         // In ProcessEvent, new events might get added and
@@ -1009,5 +1009,5 @@
         return FALSE;
 
-    wxNode *node = m_dynamicEvents->GetFirst();
+    wxList::compatibility_iterator node = m_dynamicEvents->GetFirst();
     while (node)
     {
@@ -1026,5 +1026,5 @@
             if (entry->m_callbackUserData)
                 delete entry->m_callbackUserData;
-            m_dynamicEvents->DeleteNode( node );
+            m_dynamicEvents->Erase( node );
             delete entry;
             return TRUE;
@@ -1042,5 +1042,5 @@
     int commandId = event.GetId();
 
-    wxNode *node = m_dynamicEvents->GetFirst();
+    wxList::compatibility_iterator node = m_dynamicEvents->GetFirst();
     while (node)
     {
Index: src/common/filefn.cpp
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/src/common/filefn.cpp,v
retrieving revision 1.176
diff -u -2 -r1.176 filefn.cpp
--- src/common/filefn.cpp	2003/06/11 18:17:56	1.176
+++ src/common/filefn.cpp	2003/06/20 21:27:21
@@ -214,9 +214,9 @@
 // ----------------------------------------------------------------------------
 
-IMPLEMENT_DYNAMIC_CLASS(wxPathList, wxStringList)
+// IMPLEMENT_DYNAMIC_CLASS(wxPathList, wxStringList)
 
 void wxPathList::Add (const wxString& path)
 {
-    wxStringList::Add (WXSTRINGCAST path);
+    wxStringList::Append (WXSTRINGCAST path);
 }
 
@@ -279,5 +279,5 @@
 bool wxPathList::Member (const wxString& path)
 {
-  for (wxStringList::Node *node = GetFirst(); node; node = node->GetNext())
+  for (wxStringList::compatibility_iterator node = GetFirst(); node; node = node->GetNext())
   {
       wxString path2( node->GetData() );
@@ -307,7 +307,7 @@
   filename = wxIsAbsolutePath (buf) ? wxFileNameFromPath (buf) : (wxChar *)buf;
 
-  for (wxStringList::Node *node = GetFirst(); node; node = node->GetNext())
+  for (wxStringList::compatibility_iterator node = GetFirst(); node; node = node->GetNext())
     {
-      wxChar *path = node->GetData();
+      const wxChar *path = node->GetData();
       wxStrcpy (wxFileFunctionsBuffer, path);
       wxChar ch = wxFileFunctionsBuffer[wxStrlen(wxFileFunctionsBuffer)-1];
Index: src/common/filesys.cpp
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/src/common/filesys.cpp,v
retrieving revision 1.46
diff -u -2 -r1.46 filesys.cpp
--- src/common/filesys.cpp	2003/02/06 00:53:35	1.46
+++ src/common/filesys.cpp	2003/06/20 21:27:23
@@ -29,5 +29,4 @@
 
 
-
 //--------------------------------------------------------------------------------
 // wxFileSystemHandler
@@ -324,5 +323,5 @@
     char meta;
     wxFSFile *s = NULL;
-    wxNode *node;
+    wxList::compatibility_iterator node;
 
     ln = loc.Length();
@@ -378,5 +377,5 @@
 wxString wxFileSystem::FindFirst(const wxString& spec, int flags)
 {
-    wxNode *node;
+    wxList::compatibility_iterator node;
     wxString spec2(spec);
 
@@ -425,6 +424,5 @@
 void wxFileSystem::CleanUpHandlers()
 {
-    m_Handlers.DeleteContents(TRUE);
-    m_Handlers.Clear();
+    WX_CLEAR_LIST(wxList, m_Handlers);
 }
 
Index: src/common/fs_inet.cpp
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/src/common/fs_inet.cpp,v
retrieving revision 1.26
diff -u -2 -r1.26 fs_inet.cpp
--- src/common/fs_inet.cpp	2003/02/06 00:53:35	1.26
+++ src/common/fs_inet.cpp	2003/06/20 21:27:23
@@ -157,9 +157,9 @@
 wxInternetFSHandler::~wxInternetFSHandler()
 {
-    wxNode *n;
+    wxHashTable::compatibility_iterator n;
     wxInetCacheNode *n2;
 
     m_Cache.BeginFind();
-    while ((n = m_Cache.Next()) != NULL)
+    while ((n = m_Cache.Next()))
     {
         n2 = (wxInetCacheNode*) n->GetData();
Index: src/common/fs_mem.cpp
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/src/common/fs_mem.cpp,v
retrieving revision 1.15
diff -u -2 -r1.15 fs_mem.cpp
--- src/common/fs_mem.cpp	2003/02/06 00:53:35	1.15
+++ src/common/fs_mem.cpp	2003/06/20 21:27:24
@@ -93,6 +93,10 @@
     // wxFileSystem other than releasing _all_ handlers.)
 
-    if (m_Hash) delete m_Hash;
-    m_Hash = NULL;
+    if (m_Hash) 
+    { 
+        WX_CLEAR_HASH_TABLE(*m_Hash);
+        delete m_Hash;
+        m_Hash = NULL;
+    }
 }
 
@@ -151,5 +155,4 @@
     {
         m_Hash = new wxHashTable(wxKEY_STRING);
-        m_Hash -> DeleteContents(TRUE);
     }
 
Index: src/common/fs_zip.cpp
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/src/common/fs_zip.cpp,v
retrieving revision 1.22
diff -u -2 -r1.22 fs_zip.cpp
--- src/common/fs_zip.cpp	2003/04/12 22:28:51	1.22
+++ src/common/fs_zip.cpp	2003/06/20 21:27:25
@@ -27,5 +27,5 @@
 #endif
 
-#include "wx/hash.h"
+#include "wx/hashmap.h"
 #include "wx/filesys.h"
 #include "wx/zipstrm.h"
@@ -39,4 +39,6 @@
 #endif
 
+WX_DECLARE_HASH_MAP( long, long, wxIntegerHash, wxIntegerEqual,
+                     wxLongToLongHashMap );
 
 //----------------------------------------------------------------------------
@@ -166,5 +168,5 @@
             {
                 delete m_DirsFound;
-                m_DirsFound = new wxHashTableLong();
+                m_DirsFound = new wxLongToLongHashMap();
             }
             return DoFind();
@@ -204,7 +206,8 @@
                 long key = 0;
                 for (size_t i = 0; i < dir.Length(); i++) key += (wxUChar)dir[i];
-                if (m_DirsFound->Get(key) == wxNOT_FOUND)
+                wxLongToLongHashMap::iterator it = m_DirsFound->find(key);
+                if (it == m_DirsFound->end())
                 {
-                    m_DirsFound->Put(key, 1);
+                    m_DirsFound[key] = 1;
                     filename = dir.AfterLast(wxT('/'));
                     dir = dir.BeforeLast(wxT('/'));
Index: src/common/hash.cpp
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/src/common/hash.cpp,v
retrieving revision 1.26
diff -u -2 -r1.26 hash.cpp
--- src/common/hash.cpp	2003/03/17 11:28:30	1.26
+++ src/common/hash.cpp	2003/06/20 21:27:26
@@ -35,4 +35,6 @@
 #include "wx/hash.h"
 
+#if !wxUSE_STL
+
 #include <string.h>
 #include <stdarg.h>
@@ -719,2 +721,3 @@
 }
 
+#endif // !wxUSE_STL
Index: src/common/http.cpp
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/src/common/http.cpp,v
retrieving revision 1.53
diff -u -2 -r1.53 http.cpp
--- src/common/http.cpp	2003/06/18 22:09:09	1.53
+++ src/common/http.cpp	2003/06/20 21:27:27
@@ -39,6 +39,5 @@
 
 wxHTTP::wxHTTP()
-  : wxProtocol(),
-    m_headers(wxKEY_STRING)
+  : wxProtocol()
 {
   m_addr = NULL;
@@ -58,15 +57,5 @@
 void wxHTTP::ClearHeaders()
 {
-  // wxString isn't a wxObject
-  wxNode *node = m_headers.GetFirst();
-  wxString *string;
-
-  while (node) {
-    string = (wxString *)node->GetData();
-    delete string;
-    node = node->GetNext();
-  }
-
-  m_headers.Clear();
+  m_headers.clear();
 }
 
@@ -88,43 +77,28 @@
   }
 
-  wxNode *node = m_headers.Find(header);
-
-  if (!node)
-    m_headers.Append(header, (wxObject *)(new wxString(h_data)));
-  else {
-    wxString *str = (wxString *)node->GetData();
-    (*str) = h_data;
-  }
+  m_headers[header] = h_data;
 }
 
 wxString wxHTTP::GetHeader(const wxString& header)
 {
-  wxNode *node;
-  wxString upper_header;
+  wxStringToStringHashMap::iterator it = m_headers.find(header.Upper());
 
-  upper_header = header.Upper();
-
-  node = m_headers.Find(upper_header);
-  if (!node)
+  if (it == m_headers.end())
     return wxEmptyString;
 
-  return *((wxString *)node->GetData());
+  return it->second;
 }
 
 void wxHTTP::SendHeaders()
 {
-  wxNode *head = m_headers.GetFirst();
+  typedef wxStringToStringHashMap::iterator iterator;
+  wxString buf;
 
-  while (head)
+  for (iterator it = m_headers.begin(), en = m_headers.end(); it != en; ++it )
   {
-    wxString *str = (wxString *)head->GetData();
-
-    wxString buf;
-    buf.Printf(wxT("%s: %s\r\n"), head->GetKeyString(), str->GetData());
+    buf.Printf(wxT("%s: %s\r\n"), it->first.c_str(), it->second.c_str());
 
     const wxWX2MBbuf cbuf = buf.mb_str();
     Write(cbuf, strlen(cbuf));
-
-    head = head->GetNext();
   }
 }
@@ -153,8 +127,7 @@
 
     wxString left_str = line.BeforeFirst(':');
-    wxString *str = new wxString(line.AfterFirst(':').Strip(wxString::both));
     left_str.MakeUpper();
 
-    m_headers.Append(left_str, (wxObject *) str);
+    m_headers[left_str] = line.AfterFirst(':').Strip(wxString::both);
   }
   return TRUE;
Index: src/common/list.cpp
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/src/common/list.cpp,v
retrieving revision 1.42
diff -u -2 -r1.42 list.cpp
--- src/common/list.cpp	2003/03/17 11:28:30	1.42
+++ src/common/list.cpp	2003/06/20 21:27:29
@@ -39,4 +39,6 @@
 #endif
 
+#if !wxUSE_STL
+
 // =============================================================================
 // implementation
@@ -46,5 +48,4 @@
 // wxListKey
 // -----------------------------------------------------------------------------
-
 wxListKey wxDefaultListKey;
 
@@ -712,2 +713,3 @@
 #endif // wxLIST_COMPATIBILITY
 
+#endif // !wxUSE_STL
Index: src/common/module.cpp
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/src/common/module.cpp,v
retrieving revision 1.9
diff -u -2 -r1.9 module.cpp
--- src/common/module.cpp	2003/03/29 13:53:39	1.9
+++ src/common/module.cpp	2003/06/20 21:27:30
@@ -45,5 +45,5 @@
 void wxModule::RegisterModules()
 {
-    wxNode *node;
+    wxHashTable::compatibility_iterator node;
     wxClassInfo* classInfo;
 
@@ -66,5 +66,5 @@
 {
     // Initialize user-defined modules
-    wxModuleList::Node *node;
+    wxModuleList::compatibility_iterator node;
     for ( node = m_modules.GetFirst(); node; node = node->GetNext() )
     {
@@ -72,5 +72,5 @@
         {
             // clean up already initialized modules - process in reverse order
-            wxModuleList::Node *n;
+            wxModuleList::compatibility_iterator n;
             for ( n = node->GetPrevious(); n; n = n->GetPrevious() )
             {
@@ -88,5 +88,5 @@
 {
     // Cleanup user-defined modules
-    wxModuleList::Node *node;
+    wxModuleList::compatibility_iterator node;
     for ( node = m_modules.GetFirst(); node; node = node->GetNext() )
     {
@@ -94,6 +94,5 @@
     }
 
-    m_modules.DeleteContents(TRUE);
-    m_modules.Clear();
+    WX_CLEAR_LIST(wxModuleList, m_modules);
 }
 
Index: src/common/socket.cpp
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/src/common/socket.cpp,v
retrieving revision 1.108
diff -u -2 -r1.108 socket.cpp
--- src/common/socket.cpp	2003/03/17 11:28:32	1.108
+++ src/common/socket.cpp	2003/06/20 21:27:34
@@ -832,5 +832,5 @@
 void wxSocketBase::RestoreState()
 {
-  wxNode *node;
+  wxList::compatibility_iterator node;
   wxSocketState *state;
 
@@ -850,5 +850,5 @@
 #endif // WXWIN_COMPATIBILITY
 
-  delete node;
+  m_states.Erase(node);
   delete state;
 }
Index: src/common/utilscmn.cpp
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/src/common/utilscmn.cpp,v
retrieving revision 1.102
diff -u -2 -r1.102 utilscmn.cpp
--- src/common/utilscmn.cpp	2003/04/10 13:08:13	1.102
+++ src/common/utilscmn.cpp	2003/06/20 21:27:38
@@ -455,5 +455,5 @@
     */
 
-    wxWindowList::Node  *node = win->GetChildren().GetLast();
+    wxWindowList::compatibility_iterator node = win->GetChildren().GetLast();
     while (node)
     {
@@ -484,5 +484,5 @@
     // on top are likely to have been appended most
     // recently.
-    wxWindowList::Node  *node = wxTopLevelWindows.GetLast();
+    wxWindowList::compatibility_iterator node = wxTopLevelWindows.GetLast();
     while (node)
     {
@@ -830,5 +830,5 @@
 void wxEnableTopLevelWindows(bool enable)
 {
-    wxWindowList::Node *node;
+    wxWindowList::compatibility_iterator node;
     for ( node = wxTopLevelWindows.GetFirst(); node; node = node->GetNext() )
         node->GetData()->Enable(enable);
@@ -841,5 +841,5 @@
     m_winDisabled = NULL;
 
-    wxWindowList::Node *node;
+    wxWindowList::compatibility_iterator node;
     for ( node = wxTopLevelWindows.GetFirst(); node; node = node->GetNext() )
     {
@@ -866,5 +866,5 @@
 wxWindowDisabler::~wxWindowDisabler()
 {
-    wxWindowList::Node *node;
+    wxWindowList::compatibility_iterator node;
     for ( node = wxTopLevelWindows.GetFirst(); node; node = node->GetNext() )
     {
Index: src/common/variant.cpp
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/src/common/variant.cpp,v
retrieving revision 1.49
diff -u -2 -r1.49 variant.cpp
--- src/common/variant.cpp	2003/06/03 10:51:52	1.49
+++ src/common/variant.cpp	2003/06/20 21:27:42
@@ -95,5 +95,5 @@
 {
     Clear();
-    wxNode* node = value.GetFirst();
+    wxList::compatibility_iterator node = value.GetFirst();
     while (node)
     {
@@ -106,5 +106,5 @@
 void wxVariantDataList::Clear()
 {
-    wxNode* node = m_value.GetFirst();
+    wxList::compatibility_iterator node = m_value.GetFirst();
     while (node)
     {
@@ -123,5 +123,5 @@
 
     listData.Clear();
-    wxNode* node = m_value.GetFirst();
+    wxList::compatibility_iterator node = m_value.GetFirst();
     while (node)
     {
@@ -137,6 +137,6 @@
 
     wxVariantDataList& listData = (wxVariantDataList&) data;
-    wxNode* node1 = m_value.GetFirst();
-    wxNode* node2 = listData.GetValue().GetFirst();
+    wxList::compatibility_iterator node1 = m_value.GetFirst();
+    wxList::compatibility_iterator node2 = listData.GetValue().GetFirst();
     while (node1 && node2)
     {
@@ -165,5 +165,5 @@
 {
     str = wxT("");
-    wxNode* node = m_value.GetFirst();
+    wxList::compatibility_iterator node = m_value.GetFirst();
     while (node)
     {
@@ -246,6 +246,6 @@
 
     wxVariantDataStringList& listData = (wxVariantDataStringList&) data;
-    wxStringList::Node  *node1 = m_value.GetFirst();
-    wxStringList::Node  *node2 = listData.GetValue().GetFirst();
+    wxStringList::compatibility_iterator node1 = m_value.GetFirst();
+    wxStringList::compatibility_iterator node2 = listData.GetValue().GetFirst();
     while (node1 && node2)
     {
@@ -274,8 +274,8 @@
 {
     str.Empty();
-    wxStringList::Node  *node = m_value.GetFirst();
+    wxStringList::compatibility_iterator node = m_value.GetFirst();
     while (node)
     {
-        wxChar* s = node->GetData();
+        const wxChar* s = node->GetData();
         if (node != m_value.GetFirst())
           str += wxT(" ");
@@ -1736,5 +1736,5 @@
         wxASSERT_MSG( (idx < (size_t) data->GetValue().GetCount()), wxT("Invalid index for array") );
 
-        wxVariant variant( wxString( (wxChar*) (data->GetValue().Item(idx)->GetData()) ));
+        wxVariant variant( wxString( (const wxChar*) (data->GetValue().Item(idx)->GetData()) ));
         return variant;
     }
@@ -1943,5 +1943,5 @@
     wxList& list = GetList();
 
-    wxNode* node = list.GetFirst();
+    wxList::compatibility_iterator node = list.GetFirst();
     while (node)
     {
@@ -1960,8 +1960,8 @@
 
     wxASSERT_MSG( (item < (int) list.GetCount()), wxT("Invalid index to Delete") );
-    wxNode* node = list.Item(item);
+    wxList::compatibility_iterator node = list.Item(item);
     wxVariant* variant = (wxVariant*) node->GetData();
     delete variant;
-    delete node;
+    list.Erase(node);
     return TRUE;
 }
Index: src/msw/dde.cpp
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/src/msw/dde.cpp,v
retrieving revision 1.32
diff -u -2 -r1.32 dde.cpp
--- src/msw/dde.cpp	2003/05/23 19:16:44	1.32
+++ src/msw/dde.cpp	2003/06/20 21:27:54
@@ -39,6 +39,6 @@
 #include "wx/dde.h"
 #include "wx/intl.h"
+#include "wx/hashmap.h"
 
-
 #include "wx/msw/private.h"
 
@@ -123,7 +123,9 @@
 // ----------------------------------------------------------------------------
 
+WX_DECLARE_STRING_HASH_MAP( HSZ, wxAtomMap );
+
 static DWORD DDEIdInst = 0L;
 static wxDDEConnection *DDECurrentlyConnecting = NULL;
-static wxList wxAtomTable(wxKEY_STRING);
+static wxAtomMap wxAtomTable;
 
 #include "wx/listimpl.cpp"
@@ -194,13 +196,8 @@
 void wxDDECleanUp()
 {
-    wxDDEClientObjects.DeleteContents(true);
-    wxDDEClientObjects.Clear();
-    wxDDEClientObjects.DeleteContents(false);
-
-    wxDDEServerObjects.DeleteContents(true);
-    wxDDEServerObjects.Clear();
-    wxDDEServerObjects.DeleteContents(false);
+    WX_CLEAR_LIST(wxDDEClientList, wxDDEClientObjects);
+    WX_CLEAR_LIST(wxDDEServerList, wxDDEServerObjects);
 
-    wxAtomTable.Clear();
+    wxAtomTable.clear();
 
     if ( DDEIdInst != 0 )
@@ -218,5 +215,5 @@
 static wxDDEConnection *DDEFindConnection(HCONV hConv)
 {
-    wxDDEServerList::Node *serverNode = wxDDEServerObjects.GetFirst();
+    wxDDEServerList::compatibility_iterator serverNode = wxDDEServerObjects.GetFirst();
     wxDDEConnection *found = NULL;
     while (serverNode && !found)
@@ -232,5 +229,5 @@
     }
 
-    wxDDEClientList::Node *clientNode = wxDDEClientObjects.GetFirst();
+    wxDDEClientList::compatibility_iterator clientNode = wxDDEClientObjects.GetFirst();
     while (clientNode && !found)
     {
@@ -245,5 +242,5 @@
 static void DDEDeleteConnection(HCONV hConv)
 {
-    wxDDEServerList::Node *serverNode = wxDDEServerObjects.GetFirst();
+    wxDDEServerList::compatibility_iterator serverNode = wxDDEServerObjects.GetFirst();
     bool found = false;
     while (serverNode && !found)
@@ -258,5 +255,5 @@
     }
 
-    wxDDEClientList::Node *clientNode = wxDDEClientObjects.GetFirst();
+    wxDDEClientList::compatibility_iterator clientNode = wxDDEClientObjects.GetFirst();
     while (clientNode && !found)
     {
@@ -270,5 +267,5 @@
 static wxDDEServer *DDEFindServer(const wxString& s)
 {
-    wxDDEServerList::Node *node = wxDDEServerObjects.GetFirst();
+    wxDDEServerList::compatibility_iterator node = wxDDEServerObjects.GetFirst();
     wxDDEServer *found = NULL;
     while (node && !found)
@@ -329,9 +326,9 @@
     wxDDEServerObjects.DeleteObject(this);
 
-    wxDDEConnectionList::Node *node = m_connections.GetFirst();
+    wxDDEConnectionList::compatibility_iterator node = m_connections.GetFirst();
     while (node)
     {
         wxDDEConnection *connection = node->GetData();
-        wxDDEConnectionList::Node *next = node->GetNext();
+        wxDDEConnectionList::compatibility_iterator next = node->GetNext();
         connection->SetConnected(false);
         connection->OnDisconnect(); // May delete the node implicitly
@@ -344,5 +341,5 @@
     {
         wxDDEConnection *connection = node->GetData();
-        wxDDEConnectionList::Node *next = node->GetNext();
+        wxDDEConnectionList::compatibility_iterator next = node->GetNext();
         delete connection;
         node = next;
@@ -357,5 +354,5 @@
 wxDDEConnection *wxDDEServer::FindConnection(WXHCONV conv)
 {
-    wxDDEConnectionList::Node *node = m_connections.GetFirst();
+    wxDDEConnectionList::compatibility_iterator node = m_connections.GetFirst();
     wxDDEConnection *found = NULL;
     while (node && !found)
@@ -372,13 +369,12 @@
 bool wxDDEServer::DeleteConnection(WXHCONV conv)
 {
-    wxDDEConnectionList::Node *node = m_connections.GetFirst();
-    bool found = false;
-    while (node && !found)
+    wxDDEConnectionList::compatibility_iterator node = m_connections.GetFirst();
+    while (node)
     {
         wxDDEConnection *connection = node->GetData();
         if (connection->m_hConv == conv)
         {
-            found = true;
-            delete node;
+            m_connections.Erase(node);
+            return true;
         }
         else
@@ -387,5 +383,5 @@
         }
     }
-    return found;
+    return false;
 }
 
@@ -404,5 +400,5 @@
 {
     wxDDEClientObjects.DeleteObject(this);
-    wxDDEConnectionList::Node *node = m_connections.GetFirst();
+    wxDDEConnectionList::compatibility_iterator node = m_connections.GetFirst();
     while (node)
     {
@@ -452,5 +448,5 @@
 wxDDEConnection *wxDDEClient::FindConnection(WXHCONV conv)
 {
-    wxDDEConnectionList::Node *node = m_connections.GetFirst();
+    wxDDEConnectionList::compatibility_iterator node = m_connections.GetFirst();
     wxDDEConnection *found = NULL;
     while (node && !found)
@@ -467,17 +463,16 @@
 bool wxDDEClient::DeleteConnection(WXHCONV conv)
 {
-    wxDDEConnectionList::Node *node = m_connections.GetFirst();
-    bool found = false;
-    while (node && !found)
+    wxDDEConnectionList::compatibility_iterator node = m_connections.GetFirst();
+    while (node)
     {
         wxDDEConnection *connection = node->GetData();
         if (connection->m_hConv == conv)
         {
-            found = true;
-            delete node;
+            m_connections.Erase(node);
+            return true;
         }
         else node = node->GetNext();
     }
-    return found;
+    return false;
 }
 
@@ -935,21 +930,19 @@
 
 // Atom table stuff
-static HSZ DDEAddAtom(const wxString& string)
+static HSZ DDEAddAtom(const wxString& str)
 {
-    HSZ atom = DDEAtomFromString(string);
-    wxAtomTable.Append(string, (wxObject *)atom);
+    HSZ atom = DDEAtomFromString(str);
+    wxAtomTable[str] = atom;
     return atom;
 }
 
-static HSZ DDEGetAtom(const wxString& string)
+static HSZ DDEGetAtom(const wxString& str)
 {
-    wxNode *node = wxAtomTable.Find(string);
-    if (node)
-        return (HSZ)node->GetData();
-    else
-    {
-        DDEAddAtom(string);
-        return (HSZ)(wxAtomTable.Find(string)->GetData());
-    }
+    wxAtomMap::iterator it = wxAtomTable.find(str);
+
+    if (it != wxAtomTable.end())
+        return it->second;
+
+    return DDEAddAtom(str);
 }
 
Index: src/msw/volume.cpp
===================================================================
RCS file: /pack/cvsroots/wxwindows/wxWindows/src/msw/volume.cpp,v
retrieving revision 1.15
diff -u -2 -r1.15 volume.cpp
--- src/msw/volume.cpp	2003/03/17 11:21:55	1.15
+++ src/msw/volume.cpp	2003/06/20 21:27:56
@@ -31,5 +31,7 @@
 
 #ifndef WX_PRECOMP
-    #include "wx/icon.h"
+    #if wxUSE_GUI
+        #include "wx/icon.h"
+    #endif
     #include "wx/intl.h"
 #endif // WX_PRECOMP

 	  	 
