Index: src/gtk/files.lst
===================================================================
--- src/gtk/files.lst	(revision 18)
+++ src/gtk/files.lst	(revision 18)
@@ -9,6 +9,7 @@
 		generic/colrdlgg.cpp \
 		generic/dcbuffer.cpp \
 		generic/dcpsg.cpp \
+		generic/dcrawg.cpp \
 		generic/dirctrlg.cpp \
 		generic/dirdlgg.cpp \
 		generic/dragimgg.cpp \
@@ -34,6 +35,7 @@
 		generic/prop.cpp \
 		generic/propform.cpp \
 		generic/proplist.cpp \
+		generic/rawbtmpg.cpp \
 		generic/sashwin.cpp \
 		generic/scrlwing.cpp \
 		generic/spinctlg.cpp \
@@ -320,6 +322,7 @@
 		dcmemory.h \
 		dcprint.h \
 		dcps.h \
+		dcraw.h \
 		dcscreen.h \
 		dde.h \
 		debug.h \
@@ -436,6 +439,7 @@
 		proplist.h \
 		radiobox.h \
 		radiobut.h \
+		rawbtmp.h \
 		regex.h \
 		region.h \
 		resource.h \
@@ -580,6 +584,7 @@
 		generic/choicdgg.h \
 		generic/colrdlgg.h \
 		generic/dcpsg.h \
+		generic/dcrawg.h \
 		generic/dirctrlg.h \
 		generic/dirdlgg.h \
 		generic/dragimgg.h \
@@ -601,6 +606,7 @@
 		generic/printps.h \
 		generic/prntdlgg.h \
 		generic/progdlgg.h \
+		generic/rawbtmpg.h \
 		generic/sashwin.h \
 		generic/scrolwin.h \
 		generic/spinctlg.h \
@@ -776,6 +782,7 @@
 		colrdlgg.o \
 		dcbuffer.o \
 		dcpsg.o \
+		dcrawg.o \
 		dirctrlg.o \
 		dirdlgg.o \
 		dragimgg.o \
@@ -801,6 +808,7 @@
 		prop.o \
 		propform.o \
 		proplist.o \
+		rawbtmpg.o \
 		sashwin.o \
 		scrlwing.o \
 		spinctlg.o \
@@ -887,6 +895,7 @@
 		colrdlgg.o \
 		dcbuffer.o \
 		dcpsg.o \
+		dcrawg.o \
 		dirctrlg.o \
 		dirdlgg.o \
 		dragimgg.o \
@@ -912,6 +921,7 @@
 		prop.o \
 		propform.o \
 		proplist.o \
+		rawbtmpg.o \
 		sashwin.o \
 		scrlwing.o \
 		spinctlg.o \
Index: src/generic/dcrawg.cpp
===================================================================
--- src/generic/dcrawg.cpp	(revision 18)
+++ src/generic/dcrawg.cpp	(revision 18)
@@ -0,0 +1,282 @@
+// -*- Mode: C++; tab-width: 4; c-basic-offset: 4; -*-
+/////////////////////////////////////////////////////////////////////////////
+// Name:        dcrawg.cpp
+// Purpose:     wxRawBitmapDC class
+// Author:      Eric Kidd
+// Modified by:
+// RCS-ID:      $Id: dcpsg.h,v 1.21 2002/09/13 22:00:44 RR Exp $
+// Copyright:   Copyright 2002 Trustees of Dartmouth College
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifdef __GNUG__
+#pragma implementation "dcrawg.h"
+#endif
+
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#if wxUSE_RAWBITMAP
+
+#ifndef WX_PRECOMP
+#include "wx/log.h"
+#endif // WX_PRECOMP
+
+#include "wx/generic/dcrawg.h"
+
+//-------------------------------------------------------------------------
+// wxRawBitmapDC
+//-------------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(wxRawBitmapDC, wxDC)
+
+#define WX_RBDC_UNIMPLEMENTED(FUNC) \
+    wxLogError("wxRawBitmapDC::%s is unimplemented.  Code may be " \
+			   "added at %s line %d and submitted to the wxWindows " \
+			   "project.", FUNC, __FILE__, __LINE__); \
+
+wxRawBitmapDC::wxRawBitmapDC()
+{
+	// TODO - Implement.
+}
+	
+void wxRawBitmapDC::SelectObject(const wxRawBitmap& bitmap)
+{
+	// TODO - Implement.
+}
+
+void wxRawBitmapDC::Clear()
+{
+    WX_RBDC_UNIMPLEMENTED("Clear");
+}
+
+void wxRawBitmapDC::SetFont(const wxFont& WXUNUSED(font))
+{
+    WX_RBDC_UNIMPLEMENTED("SetFont");
+}
+
+void wxRawBitmapDC::SetPen(const wxPen& WXUNUSED(pen))
+{
+    WX_RBDC_UNIMPLEMENTED("SetPen");
+}
+
+void wxRawBitmapDC::SetBrush(const wxBrush& WXUNUSED(brush))
+{
+    WX_RBDC_UNIMPLEMENTED("SetBrush");
+}
+
+void wxRawBitmapDC::SetBackground(const wxBrush& WXUNUSED(brush))
+{
+    WX_RBDC_UNIMPLEMENTED("SetBackground");
+}
+
+void wxRawBitmapDC::SetBackgroundMode(int WXUNUSED(mode))
+{
+    WX_RBDC_UNIMPLEMENTED("SetBackgroundMode");
+}
+
+#if wxUSE_PALETTE
+void wxRawBitmapDC::SetPalette(const wxPalette& WXUNUSED(palette))
+{
+    WX_RBDC_UNIMPLEMENTED("SetPalette");
+}
+#endif // wxUSE_PALETTE
+
+wxCoord wxRawBitmapDC::GetCharHeight() const
+{
+    WX_RBDC_UNIMPLEMENTED("GetCharHeight");
+	return 0;
+}
+
+wxCoord wxRawBitmapDC::GetCharWidth() const
+{
+    WX_RBDC_UNIMPLEMENTED("GetCharWidth");
+	return 0;
+}
+
+bool wxRawBitmapDC::CanDrawBitmap() const
+{
+    WX_RBDC_UNIMPLEMENTED("CanDrawBitmap");
+	return false;
+}
+
+bool wxRawBitmapDC::CanGetTextExtent() const
+{
+    WX_RBDC_UNIMPLEMENTED("CanGetTextExtent");
+	return false;
+}
+
+int wxRawBitmapDC::GetDepth() const
+{
+    WX_RBDC_UNIMPLEMENTED("GetDepth");
+	return 0;
+}
+
+void wxRawBitmapDC::SetLogicalFunction(int WXUNUSED(function))
+{
+    WX_RBDC_UNIMPLEMENTED("SetLogicalFunction");
+}
+
+bool wxRawBitmapDC::DoFloodFill(wxCoord WXUNUSED(x), wxCoord WXUNUSED(y),
+								const wxColour& WXUNUSED(col),
+								int WXUNUSED(style))
+{
+    WX_RBDC_UNIMPLEMENTED("DoFloodFill");
+	return false;
+}
+	
+bool wxRawBitmapDC::DoGetPixel(wxCoord WXUNUSED(x), wxCoord WXUNUSED(y),
+							   wxColour *WXUNUSED(col)) const
+{
+    WX_RBDC_UNIMPLEMENTED("DoGetPixel");
+	return false;
+}
+	
+void wxRawBitmapDC::DoDrawPoint(wxCoord WXUNUSED(x), wxCoord WXUNUSED(y))
+{
+    WX_RBDC_UNIMPLEMENTED("DoDrawPoint");
+}
+
+void wxRawBitmapDC::DoDrawLine(wxCoord WXUNUSED(x1), wxCoord WXUNUSED(y1),
+							   wxCoord WXUNUSED(x2), wxCoord WXUNUSED(y2))
+{
+    WX_RBDC_UNIMPLEMENTED("DoDrawLine");
+}
+	
+void wxRawBitmapDC::DoDrawArc(wxCoord WXUNUSED(x1), wxCoord WXUNUSED(y1),
+							  wxCoord WXUNUSED(x2), wxCoord WXUNUSED(y2),
+							  wxCoord WXUNUSED(xc), wxCoord WXUNUSED(yc))
+{
+    WX_RBDC_UNIMPLEMENTED("DoDrawArc");
+}
+
+void wxRawBitmapDC::DoDrawCheckMark(wxCoord WXUNUSED(x), wxCoord WXUNUSED(y),
+									wxCoord WXUNUSED(width),
+									wxCoord WXUNUSED(height))
+{
+    WX_RBDC_UNIMPLEMENTED("DoDrawCheckMark");
+}
+
+void wxRawBitmapDC::DoDrawEllipticArc(wxCoord WXUNUSED(x), wxCoord WXUNUSED(y),
+									  wxCoord WXUNUSED(w), wxCoord WXUNUSED(h),
+									  double WXUNUSED(sa), double WXUNUSED(ea))
+{
+    WX_RBDC_UNIMPLEMENTED("DoDrawEllipticArc");
+}
+
+void wxRawBitmapDC::DoDrawRectangle(wxCoord WXUNUSED(x), wxCoord WXUNUSED(y),
+									wxCoord WXUNUSED(width),
+									wxCoord WXUNUSED(height))
+{
+    WX_RBDC_UNIMPLEMENTED("DoDrawRectangle");
+}
+
+void wxRawBitmapDC::DoDrawRoundedRectangle(wxCoord WXUNUSED(x),
+										   wxCoord WXUNUSED(y),
+										   wxCoord WXUNUSED(width),
+										   wxCoord WXUNUSED(height),
+										   double WXUNUSED(radius))
+{
+    WX_RBDC_UNIMPLEMENTED("DoDrawRoundedRectangle");
+}
+
+void wxRawBitmapDC::DoDrawEllipse(wxCoord WXUNUSED(x), wxCoord WXUNUSED(y),
+								  wxCoord WXUNUSED(width),
+								  wxCoord WXUNUSED(height))
+{
+    WX_RBDC_UNIMPLEMENTED("DoDrawEllipse");
+}
+
+void wxRawBitmapDC::DoCrossHair(wxCoord WXUNUSED(x), wxCoord WXUNUSED(y))
+{
+    WX_RBDC_UNIMPLEMENTED("DoCrossHair");
+}
+	
+void wxRawBitmapDC::DoDrawIcon(const wxIcon& WXUNUSED(icon),
+							   wxCoord WXUNUSED(x),
+							   wxCoord WXUNUSED(y))
+{
+    WX_RBDC_UNIMPLEMENTED("DoDrawIcon");
+}
+
+void wxRawBitmapDC::DoDrawBitmap(const wxBitmap &WXUNUSED(bmp),
+								 wxCoord WXUNUSED(x), wxCoord WXUNUSED(y),
+								 bool WXUNUSED(useMask))
+{
+    WX_RBDC_UNIMPLEMENTED("DoDrawBitmap");
+}
+	
+void wxRawBitmapDC::DoDrawText(const wxString& WXUNUSED(text),
+							   wxCoord WXUNUSED(x), wxCoord WXUNUSED(y))
+{
+    WX_RBDC_UNIMPLEMENTED("DoDrawText");
+}
+
+void wxRawBitmapDC::DoDrawRotatedText(const wxString& WXUNUSED(text),
+									  wxCoord WXUNUSED(x),
+									  wxCoord WXUNUSED(y),
+									  double WXUNUSED(angle))
+{
+    WX_RBDC_UNIMPLEMENTED("DoDrawRotatedText");
+}
+	
+bool wxRawBitmapDC::DoBlit(wxCoord WXUNUSED(xdest), wxCoord WXUNUSED(ydest),
+						   wxCoord WXUNUSED(width), wxCoord WXUNUSED(height),
+						   wxDC *WXUNUSED(source),
+						   wxCoord WXUNUSED(xsrc), wxCoord WXUNUSED(ysrc),
+						   int WXUNUSED(rop), bool WXUNUSED(useMask),
+						   wxCoord WXUNUSED(xsrcMask),
+						   wxCoord WXUNUSED(ysrcMask))
+{
+    WX_RBDC_UNIMPLEMENTED("DoBlit");
+	return false;
+}
+
+void wxRawBitmapDC::DoGetSize(int *WXUNUSED(width),
+							  int *WXUNUSED(height)) const
+{
+    WX_RBDC_UNIMPLEMENTED("DoGetSize");
+}
+	
+void wxRawBitmapDC::DoDrawLines(int WXUNUSED(n), wxPoint WXUNUSED(points)[],
+								wxCoord WXUNUSED(xoffset),
+								wxCoord WXUNUSED(yoffset))
+{
+    WX_RBDC_UNIMPLEMENTED("DoDrawLines");
+}
+
+void wxRawBitmapDC::DoDrawPolygon(int WXUNUSED(n), wxPoint WXUNUSED(points)[],
+								  wxCoord WXUNUSED(xoffset),
+								  wxCoord WXUNUSED(yoffset),
+								  int WXUNUSED(fillStyle))
+{
+    WX_RBDC_UNIMPLEMENTED("DoDrawPolygon");
+}
+	
+void wxRawBitmapDC::DoSetClippingRegionAsRegion(
+	const wxRegion& WXUNUSED(region))
+{
+    WX_RBDC_UNIMPLEMENTED("DoSetClippingRegionAsRegion");
+}
+
+void wxRawBitmapDC::DoSetClippingRegion(wxCoord WXUNUSED(x),
+										wxCoord WXUNUSED(y),
+										wxCoord WXUNUSED(width),
+										wxCoord WXUNUSED(height))
+{
+    WX_RBDC_UNIMPLEMENTED("DoSetClippingRegion");
+}
+
+void wxRawBitmapDC::DoGetTextExtent(const wxString& WXUNUSED(string),
+									wxCoord *WXUNUSED(x), wxCoord *WXUNUSED(y),
+									wxCoord *WXUNUSED(descent),
+									wxCoord *WXUNUSED(externalLeading),
+									wxFont *WXUNUSED(theFont)) const
+{
+    WX_RBDC_UNIMPLEMENTED("DoGetTextExtent");
+}
+
+#endif // wxUSE_RAWBITMAP
Index: src/generic/rawbtmpg.cpp
===================================================================
--- src/generic/rawbtmpg.cpp	(revision 18)
+++ src/generic/rawbtmpg.cpp	(revision 18)
@@ -0,0 +1,139 @@
+// -*- Mode: C++; tab-width: 4; c-basic-offset: 4; -*-
+/////////////////////////////////////////////////////////////////////////////
+// Name:        rawbtmpg.cpp
+// Purpose:     wxRawBitmapDC class
+// Author:      Eric Kidd
+// Modified by:
+// RCS-ID:      $Id: dcpsg.h,v 1.21 2002/09/13 22:00:44 RR Exp $
+// Copyright:   Copyright 2002 Trustees of Dartmouth College
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifdef __GNUG__
+#pragma implementation "rawbtmpg.h"
+#endif
+
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#if wxUSE_RAWBITMAP
+
+#ifndef WX_PRECOMP
+#include "wx/dc.h"
+#endif // WX_PRECOMP
+
+#include "wx/generic/rawbtmpg.h"
+
+//-------------------------------------------------------------------------
+// wxRawBitmapRefData
+//-------------------------------------------------------------------------
+
+wxRawBitmapRefData::wxRawBitmapRefData(wxCoord width, wxCoord height,
+									   wxRawBitmapType type)
+	: m_Type(type), m_Image(width, height)
+{
+	// If you want another color depth, feel free to implement it.
+	wxASSERT(type == wxRAWBITMAP_24BIT);
+}
+
+//-------------------------------------------------------------------------
+// wxRawBitmap
+//-------------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(wxRawBitmap, wxObject)
+
+wxRawBitmap::wxRawBitmap()
+{
+	UnRef();
+}
+
+wxRawBitmap::wxRawBitmap(wxCoord width, wxCoord height,
+						 wxRawBitmapType type)
+{
+	SetRefData(new wxRawBitmapRefData(width, height, type));
+}
+
+bool wxRawBitmap::Ok()
+{
+	return (GetRefData() != NULL);
+}
+
+wxCoord wxRawBitmap::GetWidth()
+{
+	return GetImage()->GetWidth();
+}
+
+wxCoord wxRawBitmap::GetHeight()
+{
+	return GetImage()->GetHeight();
+}
+
+int wxRawBitmap::GetDepth()
+{
+	return 24;
+}
+
+wxRawBitmapType wxRawBitmap::GetType()
+{
+	return GetRawBitmapRefData()->m_Type;
+}
+
+wxRawBitmapPixelRef24 wxRawBitmap::GetData24()
+{
+	return GetImage()->GetData();
+}
+
+wxRawBitmapStride24 wxRawBitmap::GetStride24()
+{
+	return GetWidth() * 3;
+}
+
+wxRawBitmapLimits24 wxRawBitmap::GetLimits24()
+{
+	wxRawBitmapLimits24 limits;
+	limits.begin_ = GetData24();
+	limits.end_ = limits.begin_ + GetHeight() * GetStride24();
+	return limits;
+}
+
+bool wxRawBitmap::BlitTo(wxDC *dest, wxCoord xdest, wxCoord ydest,
+						 wxCoord width, wxCoord height,
+						 wxCoord xsrc, wxCoord ysrc)
+{
+	// FIXME - Check that the source rectangle is actually valid.
+	if (xsrc == 0 && ysrc == 0 &&
+		width == GetWidth() && height == GetHeight())
+	{
+		// Draw the whole image to the specified wxDC.
+		wxBitmap bitmap(*GetImage());
+		dest->DrawBitmap(bitmap, xdest, ydest);
+		return true;
+	}
+	else
+	{
+		// Extract a portion of the image, and draw it to
+		// the DC.  Painfully slow...
+		wxRect rect(xsrc, ysrc, width, height);
+		wxImage subimage = GetImage()->GetSubImage(rect);
+		wxBitmap bitmap(subimage);
+		dest->DrawBitmap(bitmap, xdest, ydest);
+		return true;
+	}
+}
+
+wxRawBitmapRefData *wxRawBitmap::GetRawBitmapRefData()
+{
+	wxRawBitmapRefData *rawBitmapRefData = (wxRawBitmapRefData *) GetRefData();
+	wxASSERT(rawBitmapRefData != NULL);
+	return rawBitmapRefData;
+}
+
+wxImage *wxRawBitmap::GetImage()
+{
+	return &(GetRawBitmapRefData()->m_Image);
+}
+
+#endif // wxUSE_RAWBITMAP
Index: setup.h.in
===================================================================
--- setup.h.in	(revision 18)
+++ setup.h.in	(revision 18)
@@ -399,6 +399,10 @@
  */
 #define wxUSE_RADIOBTN 0
 /*
+ * Use wxRawBitmap and wxRawBitmapDC
+ */
+#define wxUSE_RAWBITMAP 0
+/*
  * Use this control
  */
 #define wxUSE_SASH 0
Index: include/wx/dcraw.h
===================================================================
--- include/wx/dcraw.h	(revision 18)
+++ include/wx/dcraw.h	(revision 18)
@@ -0,0 +1,6 @@
+#ifndef _WX_DCRAW_H_BASE_
+#define _WX_DCRAW_H_BASE_
+
+#include "wx/generic/dcrawg.h"
+
+#endif
Index: include/wx/rawbtmp.h
===================================================================
--- include/wx/rawbtmp.h	(revision 18)
+++ include/wx/rawbtmp.h	(revision 18)
@@ -0,0 +1,6 @@
+#ifndef _WX_RAWBITMAP_H_BASE_
+#define _WX_RAWBITMAP_H_BASE_
+
+#include "wx/generic/rawbtmpg.h"
+
+#endif
Index: include/wx/generic/rawbtmpg.h
===================================================================
--- include/wx/generic/rawbtmpg.h	(revision 18)
+++ include/wx/generic/rawbtmpg.h	(revision 18)
@@ -0,0 +1,177 @@
+// -*- Mode: C++; tab-width: 4; c-basic-offset: 4; -*-
+/////////////////////////////////////////////////////////////////////////////
+// Name:        rawbtmpg.h
+// Purpose:     wxRawBitmap class
+// Author:      Eric Kidd
+// Modified by:
+// RCS-ID:      $Id: dcpsg.h,v 1.21 2002/09/13 22:00:44 RR Exp $
+// Copyright:   Copyright 2002 Trustees of Dartmouth College
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_RAWBITMAP_H_
+#define _WX_RAWBITMAP_H_
+
+#if defined(__GNUG__) && !defined(__APPLE__)
+#pragma interface "rawbtmpg.h"
+#endif
+
+#if wxUSE_RAWBITMAP
+
+#include "wx/object.h"
+#include "wx/image.h"
+
+//-----------------------------------------------------------------------------
+// Classes
+//-----------------------------------------------------------------------------
+
+class wxRawBitmapRefData;
+class wxRawBitmap;
+
+//-----------------------------------------------------------------------------
+// Bitmap Types
+//
+// For now, we only support raw-accessible, 24-bit data.  Since wxWindows
+// already has way too many bitmap-like classes, however, I'm making the
+// bitmap type a parameter so other bitmap types may be added without
+// breaking the general API.
+//-----------------------------------------------------------------------------
+
+typedef unsigned long wxRawBitmapType;
+
+enum /* wxRawBitmapType */ {
+	wxRAWBITMAP_24BIT = 0x01
+};
+
+//-----------------------------------------------------------------------------
+// Abstract Pixel API
+//
+// We need to access our raw bitmap data (1) portably and (2) efficiently.
+// We do this using a two-dimensional "iteration" interface.  Performance
+// is extremely important here: these functions will be called hundreds
+// of thousands of times in a row, and even small inefficiencies will
+// make applications seem slow.
+//
+// We can't rely on inline functions, because not all compilers actually
+// bother to inline them unless we crank the optimization levels way up.
+// Therefore, we use processor macros to wring maximum speed out of stupid
+// compilers.
+//
+// Several macros take a 'stride' parameter.  This is the distance
+// (in abstract units) between the point (x,y) and (x,y+1).  Do not assume
+// that rows are laid out consecutively in memory--this is often not the
+// case.  The are often gaps between rows, and on some platforms, the
+// stride is actually negative.
+//
+// Handy tip: Because of L1 cache, L2 cache and TLBs, it's much more
+// efficient to move in short horizontal hops than in big vertical hops.
+// Try to call WX_RAW24_OFFSET_X from your inner loop and WX_RAW24_OFFSET_Y
+// from your outer loop when possible.
+//-----------------------------------------------------------------------------
+
+typedef long wxRawBitmapStride24;
+typedef unsigned char *wxRawBitmapPixelRef24;
+
+typedef struct {
+	// These members are only for use by the macros below.
+	wxRawBitmapPixelRef24 begin_;
+	wxRawBitmapPixelRef24 end_;
+} wxRawBitmapLimits24;
+
+// You can use these as lvalues or rvalues.
+#define WX_RAW24_RED(ref)   (ref[0])
+#define WX_RAW24_GREEN(ref) (ref[1])
+#define WX_RAW24_BLUE(ref)  (ref[2])
+
+// Use these to move around.
+#define WX_RAW24_OFFSET(ref,stride,x,y) (ref += 3 * x + stride * y)
+#define WX_RAW24_OFFSET_X(ref,x)        (ref += 3 * x)
+#define WX_RAW24_OFFSET_Y(ref,stride,y) (ref += stride * y)
+
+// Assert (in debug builds only) that a given pixel ref is in bounds.
+// This will slow down your graphics code considerably, but it's a
+// big help in detecting out-of-bounds access in highly optimized
+// drawing routines.
+#ifdef __WXDEBUG__
+#	define WX_RAW24_DECLARE_LIMITS(name,rawbitmap) \
+		wxRawBitmap24Bounds name = (rawbitmap).GetLimits24()
+#	define WX_RAW24_ASSERT_WITHIN_LIMITS(name,ref) \
+		wxASSERT((name).begin_ <= (ref) && (ref) < (name).end_)
+#else
+#	define WX_RAW24_DECLARE_LIMITS(name,rawbitmap) ((void) 0)
+#	define WX_RAW24_ASSERT_WITHIN_LIMITS(name,ref) ((void) 0)
+#endif
+
+//-----------------------------------------------------------------------------
+// wxRawBitmapRefData
+//
+// NB: This class is a private, reference-counted data structure used to
+// implement wxRawBitmap.
+//-----------------------------------------------------------------------------
+
+class WXDLLEXPORT wxRawBitmapRefData : public wxObjectRefData
+{
+public:
+	wxRawBitmapRefData(wxCoord width, wxCoord height,
+					   wxRawBitmapType type);
+
+	wxRawBitmapType m_Type;
+	wxImage m_Image;
+
+private:
+    DECLARE_NO_COPY_CLASS(wxRawBitmapRefData)
+};
+
+//-----------------------------------------------------------------------------
+// wxRawBitmap
+//
+// A portable implementation of wxRawBitmap using wxImage to store the
+// actual bits.  Raw drawing performance is fine, but blitting performance
+// is poor.  The generic implementation of wxRawBitmapDC does not support
+// a full set of wxDC methods.
+//-----------------------------------------------------------------------------
+
+class WXDLLEXPORT wxRawBitmap : public wxObject
+{
+public:
+	wxRawBitmap(); // TODO - Construct a null bitmap.  But do we want one?
+	wxRawBitmap(wxCoord width, wxCoord height,
+				wxRawBitmapType type = wxRAWBITMAP_24BIT);
+
+	// Methods similar to wxBitmap.  These may be moved into an
+	// abstract superclass.
+	virtual bool Ok();
+	virtual wxCoord GetWidth();
+	virtual wxCoord GetHeight();
+	virtual int GetDepth();
+
+	// Raw access methods.
+	virtual wxRawBitmapType GetType();
+	virtual void Lock() {}
+	virtual void Unlock() {}
+
+	// These functions are only callable if GetType returns
+	// wxRAWBITMAP_24BIT.
+	virtual wxRawBitmapPixelRef24 GetData24();
+	virtual wxRawBitmapStride24 GetStride24();
+	virtual wxRawBitmapLimits24 GetLimits24();
+
+	// This isn't guaranteed to be here in the future--we
+	// need to decide how to handle blitting between
+	// wxBitmap and wxRawBitmap objects.
+    virtual bool BlitTo(wxDC *dest, wxCoord xdest, wxCoord ydest,
+						wxCoord width, wxCoord height,
+						wxCoord xsrc, wxCoord ysrc);
+
+private:
+	wxRawBitmapRefData *GetRawBitmapRefData();
+	wxImage *GetImage();
+
+    DECLARE_DYNAMIC_CLASS(wxRawBitmap)
+};
+
+// TODO - Do we want one of these, and if so, where should it live?
+//WXDLLEXPORT_DATA(extern wxRawBitmap) wxNullRawBitmap;
+
+#endif // wxUSE_RAWBITMAP
+#endif // _WX_RAWBITMAP_H_
Index: include/wx/generic/dcrawg.h
===================================================================
--- include/wx/generic/dcrawg.h	(revision 18)
+++ include/wx/generic/dcrawg.h	(revision 18)
@@ -0,0 +1,130 @@
+// -*- Mode: C++; tab-width: 4; c-basic-offset: 4; -*-
+/////////////////////////////////////////////////////////////////////////////
+// Name:        dcrawg.h
+// Purpose:     wxRawBitmapDC class
+// Author:      Eric Kidd
+// Modified by:
+// RCS-ID:      $Id: dcpsg.h,v 1.21 2002/09/13 22:00:44 RR Exp $
+// Copyright:   Copyright 2002 Trustees of Dartmouth College
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_DCRAW_H_
+#define _WX_DCRAW_H_
+
+#if defined(__GNUG__) && !defined(__APPLE__)
+#pragma interface "dcrawg.h"
+#endif
+
+#if wxUSE_RAWBITMAP
+
+// Note that we're implemented in terms of wx/rawbtmp.h, not in terms
+// of wx/generic/rawbtmpg.h.  This allows the generic wxRawBitmapDC to
+// be used with non-generic wxRawBitmap classes.  This could be very
+// useful under wxGTK and the other X11 ports--they can supply much faster
+// wxRawBitmap classes, but they still need the generic DC.
+#include "wx/rawbtmp.h"
+#include "wx/dc.h"
+
+//-----------------------------------------------------------------------------
+// classes
+//-----------------------------------------------------------------------------
+
+class wxRawBitmapDC;
+
+//-----------------------------------------------------------------------------
+// wxRawBitmapDC
+//-----------------------------------------------------------------------------
+
+class WXDLLEXPORT wxRawBitmapDC : public wxDC
+{
+public:
+	wxRawBitmapDC();
+	
+    void SelectObject(const wxRawBitmap& bitmap);
+
+    virtual void Clear();
+
+    virtual void SetFont(const wxFont& font);
+    virtual void SetPen(const wxPen& pen);
+    virtual void SetBrush(const wxBrush& brush);
+    virtual void SetBackground(const wxBrush& brush);
+    virtual void SetBackgroundMode(int mode);
+#if wxUSE_PALETTE
+    virtual void SetPalette(const wxPalette& palette);
+#endif // wxUSE_PALETTE
+
+    virtual wxCoord GetCharHeight() const;
+    virtual wxCoord GetCharWidth() const;
+
+    virtual bool CanDrawBitmap() const;
+    virtual bool CanGetTextExtent() const;
+    virtual int GetDepth() const;
+
+    virtual void SetLogicalFunction(int function);
+
+protected:
+    virtual bool DoFloodFill(wxCoord x, wxCoord y, const wxColour& col,
+							 int style = wxFLOOD_SURFACE);
+	
+    virtual bool DoGetPixel(wxCoord x, wxCoord y, wxColour *col) const;
+	
+    virtual void DoDrawPoint(wxCoord x, wxCoord y);
+    virtual void DoDrawLine(wxCoord x1, wxCoord y1, wxCoord x2, wxCoord y2);
+	
+    virtual void DoDrawArc(wxCoord x1, wxCoord y1,
+						   wxCoord x2, wxCoord y2,
+						   wxCoord xc, wxCoord yc);
+    virtual void DoDrawCheckMark(wxCoord x, wxCoord y,
+								 wxCoord width, wxCoord height);
+    virtual void DoDrawEllipticArc(wxCoord x, wxCoord y, wxCoord w, wxCoord h,
+								   double sa, double ea);
+	
+    virtual void DoDrawRectangle(wxCoord x, wxCoord y, wxCoord width,
+								 wxCoord height);
+    virtual void DoDrawRoundedRectangle(wxCoord x, wxCoord y,
+										wxCoord width, wxCoord height,
+										double radius);
+    virtual void DoDrawEllipse(wxCoord x, wxCoord y,
+							   wxCoord width, wxCoord height);
+	
+    virtual void DoCrossHair(wxCoord x, wxCoord y);
+	
+    virtual void DoDrawIcon(const wxIcon& icon, wxCoord x, wxCoord y);
+    virtual void DoDrawBitmap(const wxBitmap &bmp, wxCoord x, wxCoord y,
+							  bool useMask = FALSE);
+	
+    virtual void DoDrawText(const wxString& text, wxCoord x, wxCoord y);
+    virtual void DoDrawRotatedText(const wxString& text,
+								   wxCoord x, wxCoord y, double angle);
+	
+    virtual bool DoBlit(wxCoord xdest, wxCoord ydest,
+						wxCoord width, wxCoord height,
+						wxDC *source, wxCoord xsrc, wxCoord ysrc,
+						int rop = wxCOPY, bool useMask = FALSE,
+						wxCoord xsrcMask = -1, wxCoord ysrcMask = -1);
+	
+    virtual void DoGetSize(int *width, int *height) const;
+	
+    virtual void DoDrawLines(int n, wxPoint points[],
+							 wxCoord xoffset, wxCoord yoffset);
+    virtual void DoDrawPolygon(int n, wxPoint points[],
+							   wxCoord xoffset, wxCoord yoffset,
+							   int fillStyle = wxODDEVEN_RULE);
+	
+    virtual void DoSetClippingRegionAsRegion(const wxRegion& region);
+    virtual void DoSetClippingRegion(wxCoord x, wxCoord y,
+									 wxCoord width, wxCoord height);
+	
+    virtual void DoGetTextExtent(const wxString& string,
+								 wxCoord *x, wxCoord *y,
+								 wxCoord *descent = NULL,
+								 wxCoord *externalLeading = NULL,
+								 wxFont *theFont = NULL) const;
+	
+private:
+    DECLARE_DYNAMIC_CLASS(wxRawBitmapDC)
+};
+
+#endif // wxUSE_RAWBITMAP
+#endif // _WX_DCRAW_H_
Index: configure.in
===================================================================
--- configure.in	(revision 18)
+++ configure.in	(revision 18)
@@ -415,6 +415,7 @@
   DEFAULT_wxUSE_FILESYSTEM=no
   DEFAULT_wxUSE_FS_INET=no
   DEFAULT_wxUSE_FS_ZIP=no
+  DEFAULT_wxUSE_RAWBITMAP=no
   DEFAULT_wxUSE_BUSYINFO=no
   DEFAULT_wxUSE_ZIPSTREAM=no
   DEFAULT_wxUSE_VALIDATORS=no
@@ -590,6 +591,7 @@
   DEFAULT_wxUSE_FILESYSTEM=yes
   DEFAULT_wxUSE_FS_INET=yes
   DEFAULT_wxUSE_FS_ZIP=yes
+  DEFAULT_wxUSE_RAWBITMAP=yes
   DEFAULT_wxUSE_BUSYINFO=yes
   DEFAULT_wxUSE_ZIPSTREAM=yes
   DEFAULT_wxUSE_VALIDATORS=yes
@@ -1019,6 +1021,7 @@
 WX_ARG_ENABLE(joystick,    [  --enable-joystick       use wxJoystick (Linux only)], wxUSE_JOYSTICK)
 WX_ARG_ENABLE(metafile,    [  --enable-metafiles      use wxMetaFile (Windows only)], wxUSE_METAFILE)
 WX_ARG_ENABLE(dragimage,   [  --enable-dragimage      use wxDragImage], wxUSE_DRAGIMAGE)
+WX_ARG_ENABLE(rawbitmap,   [  --enable-rawbitmap      use wxRawBitmap], wxUSE_RAWBITMAP)
 
 dnl ---------------------------------------------------------------------------
 dnl support for image formats that do not rely on external library
@@ -4810,6 +4813,11 @@
     SAMPLES_SUBDIRS="$SAMPLES_SUBDIRS minifram"
 fi
 
+if test "$wxUSE_RAWBITMAP" = "yes"; then
+    AC_DEFINE(wxUSE_RAWBITMAP)
+    SAMPLES_SUBDIRS="$SAMPLES_SUBDIRS rawbitmap"
+fi
+
 if test "$wxUSE_HTML" = "yes"; then
     AC_DEFINE(wxUSE_HTML)
     SAMPLES_SUBDIRS="$SAMPLES_SUBDIRS html"
Index: distrib/msw/tmake/filelist.txt
===================================================================
--- distrib/msw/tmake/filelist.txt	(revision 18)
+++ distrib/msw/tmake/filelist.txt	(revision 18)
@@ -75,6 +75,7 @@
 colrdlgg.cpp	Generic	Generic
 dcbuffer.cpp	Generic
 dcpsg.cpp	Generic
+dcrawg.cpp	Generic
 dirctrlg.cpp	Generic
 dirdlgg.cpp	Generic	NotWin32
 dragimgg.cpp	Generic	NotOS2
@@ -102,6 +103,7 @@
 prop.cpp	Generic
 propform.cpp	Generic
 proplist.cpp	Generic
+rawbtmpg.cpp    Generic
 sashwin.cpp	Generic
 scrlwing.cpp	Generic
 spinctlg.cpp	Generic
@@ -797,6 +799,7 @@
 dcmemory.h	WXH
 dcprint.h	WXH
 dcps.h	WXH
+dcraw.h	WXH
 dcscreen.h	WXH
 dde.h	WXH	Base
 debug.h	WXH	Base
@@ -917,6 +920,7 @@
 proplist.h	WXH
 radiobox.h	WXH
 radiobut.h	WXH
+rawbtmp.h	WXH
 regex.h	WXH	Base
 region.h	WXH
 resource.h	WXH
@@ -1465,6 +1469,7 @@
 choicdgg.h	GenericH
 colrdlgg.h	GenericH
 dcpsg.h	GenericH
+dcrawg.h	GenericH
 dirctrlg.h	GenericH
 dirdlgg.h	GenericH	NotWin32
 dragimgg.h	GenericH	NotWin32
@@ -1487,6 +1492,7 @@
 printps.h	GenericH
 prntdlgg.h	GenericH
 progdlgg.h	GenericH
+rawbtmpg.h	GenericH
 sashwin.h	GenericH
 scrolwin.h	GenericH
 spinctlg.h	GenericH
Index: samples/rawbitmap/Makefile.in
===================================================================
--- samples/rawbitmap/Makefile.in	(revision 18)
+++ samples/rawbitmap/Makefile.in	(revision 18)
@@ -0,0 +1,23 @@
+#
+# File:		Makefile.in
+# Author:	Julian Smart
+# Created:	1998
+# Updated:	
+# Copyright:	(c) 1998 Julian Smart
+#
+# "%W% %G%"
+#
+# Makefile for rawbitmap example (UNIX).
+
+top_srcdir = @top_srcdir@/..
+top_builddir = ../..
+program_dir = samples/rawbitmap
+
+PROGRAM=rawbitmap-test
+
+OBJECTS =$(PROGRAM).o
+DEPFILES=$(PROGRAM).d
+
+include ../../src/makeprog.env
+
+@IF_GNU_MAKE@-include $(DEPFILES)
Index: samples/rawbitmap/rawbitmap-test.cpp
===================================================================
--- samples/rawbitmap/rawbitmap-test.cpp	(revision 18)
+++ samples/rawbitmap/rawbitmap-test.cpp	(revision 18)
@@ -0,0 +1,509 @@
+// -*- Mode: C++; tab-width: 4; c-basic-offset: 4; -*-
+
+// TODO - Fill in standard cruft from artprov.cpp.
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+// For compilers that don't support precompilation, include only
+// those headers we actually need, to keep things fast.
+#ifndef WX_PRECOMP
+#include "wx/app.h"
+#include "wx/frame.h"
+#include "wx/menu.h"
+#include "wx/dcmemory.h"
+#include "wx/image.h"
+#include "wx/bitmap.h"
+#endif
+
+// These headers are not included in the precompiled headers on
+// any platform.
+#include "wx/rawbtmp.h"
+
+
+//=========================================================================
+//  Constants
+//=========================================================================
+
+// The different image representations this program supports.
+// See below for more information.
+enum {
+	REP_RAWBITMAP,
+	REP_BITMAP,
+	REP_IMAGE,
+	REP_COUNT,
+	REP_DEFAULT = REP_RAWBITMAP
+};
+
+// The different tests this program supports.
+enum {
+	TEST_FULLSCREEN,
+	TEST_RECTS,
+	TEST_COUNT,
+	TEST_DEFAULT = TEST_FULLSCREEN
+};
+
+// The size of our drawing "stage".
+static const int STAGE_WIDTH = 640;
+static const int STAGE_HEIGHT = 480;
+
+// Menu commands.
+enum {
+	CMD_EXIT,
+	CMD_REP_RAWBITMAP,
+	CMD_REP_BITMAP,
+	CMD_REP_IMAGE,
+	CMD_TEST_FULLSCREEN,
+	CMD_TEST_RECTS
+};
+
+
+//=========================================================================
+//  Class Declarations
+//=========================================================================
+
+class Stage;
+class Representation;
+
+class MyApp : public wxApp
+{
+public:
+	virtual bool OnInit();
+};
+
+class MyFrame : public wxFrame
+{
+	Stage *m_Stage;
+
+    DECLARE_EVENT_TABLE();
+
+	void OnExit(wxMenuEvent &inEvent);
+	void OnRepRawBitmap(wxMenuEvent &inEvent);
+	void OnRepBitmap(wxMenuEvent &inEvent);
+	void OnRepImage(wxMenuEvent &inEvent);
+	void OnTestFullScreen(wxMenuEvent &inEvent);
+	void OnTestRectangles(wxMenuEvent &inEvent);
+
+public:
+    MyFrame();
+};
+
+class Stage : public wxWindow
+{
+	int mRepID;
+	int mTestID;
+	Representation *mRepresentations[REP_COUNT];
+
+    DECLARE_EVENT_TABLE();
+
+	void OnPaint(wxPaintEvent &inEvent);
+
+public:
+    Stage(wxWindow *inParent, const wxSize &inSize);
+	~Stage();
+
+	void SetRepID(int inRepID);
+	void SetTestID(int inTestID);
+};
+
+
+//=========================================================================
+//  Representation Declarations
+//=========================================================================
+//  We can run our tests using various image representations.  Each
+//  representation is based on a different bitmap-like class: wxBitmap,
+//  wxImage, etc.
+
+class Representation
+{
+public:
+	virtual ~Representation() {}
+
+	// Clear the offscreen representation to the
+	// specified color.
+	virtual void Clear(const wxColour &inColor) = 0;
+
+	// Paint the specified DC with the offscreen data.
+	virtual void Paint(wxDC &inDC) = 0;
+
+	// Paint the specified DC with the offscreen data, copying
+	// only the specified rectangle.
+	virtual void PaintRect(wxDC &inDC, const wxRect &inRect) = 0;
+};
+
+class RawBitmapRepresentation : public Representation
+{
+	wxRawBitmap *m_RawBitmap;
+	
+public:
+	RawBitmapRepresentation(const wxSize &inStageSize);
+	~RawBitmapRepresentation();
+
+	void Clear(const wxColour &inColor);
+	void Paint(wxDC &inDC);
+	void PaintRect(wxDC &inDC, const wxRect &inRect);
+};
+
+class BitmapRepresentation : public Representation
+{
+	wxBitmap *m_Bitmap;
+	
+public:
+	BitmapRepresentation(const wxSize &inStageSize);
+	~BitmapRepresentation();
+
+	void Clear(const wxColour &inColor);
+	void Paint(wxDC &inDC);
+	void PaintRect(wxDC &inDC, const wxRect &inRect);
+};
+
+class ImageRepresentation : public Representation
+{
+	wxImage *m_Image;
+
+public:
+	ImageRepresentation(const wxSize &inStageSize);
+	~ImageRepresentation();
+
+	void Clear(const wxColour &inColor);
+	void Paint(wxDC &inDC);
+	void PaintRect(wxDC &inDC, const wxRect &inRect);
+};
+
+
+//=========================================================================
+//  MyApp Implementation
+//=========================================================================
+
+IMPLEMENT_APP(MyApp)
+
+bool MyApp::OnInit()
+{
+    wxFrame *frame = new MyFrame();
+    frame->Show();
+    SetTopWindow(frame);
+    return TRUE;
+}
+
+
+//=========================================================================
+//  MyFrame Implementation
+//=========================================================================
+
+BEGIN_EVENT_TABLE(MyFrame, wxFrame)
+	EVT_MENU(CMD_EXIT, MyFrame::OnExit)
+	EVT_MENU(CMD_REP_RAWBITMAP, MyFrame::OnRepRawBitmap)
+	EVT_MENU(CMD_REP_BITMAP, MyFrame::OnRepBitmap)
+	EVT_MENU(CMD_REP_IMAGE, MyFrame::OnRepImage)
+	EVT_MENU(CMD_TEST_FULLSCREEN, MyFrame::OnTestFullScreen)
+	EVT_MENU(CMD_TEST_RECTS, MyFrame::OnTestRectangles)
+END_EVENT_TABLE()
+
+MyFrame::MyFrame()
+    : wxFrame(NULL, -1, "rawbitmap-test", wxDefaultPosition, wxDefaultSize,
+              wxMINIMIZE_BOX|wxSYSTEM_MENU|wxCAPTION)
+{
+    // Make a stage for drawing.
+    wxSize stage_size(STAGE_WIDTH, STAGE_HEIGHT);
+    m_Stage = new Stage(this, stage_size);
+
+	// Set up our File menu.
+    wxMenu *file_menu = new wxMenu();
+    file_menu->Append(CMD_EXIT, "E&xit\tCtrl+Q", "Exit the application.");
+
+	// Set up our Options menu.
+	// TODO - Test wxHAS_RADIO_MENU_ITEMS.
+    wxMenu *opt_menu = new wxMenu();
+    opt_menu->AppendRadioItem(CMD_REP_RAWBITMAP,
+							  "wx&RawBitmap Representation\tCtrl+R",
+							  "Store data in a wxBitmap.");
+    opt_menu->AppendRadioItem(CMD_REP_BITMAP,
+							  "wx&Bitmap Representation\tCtrl+B",
+							  "Store data in a wxBitmap.");
+    opt_menu->AppendRadioItem(CMD_REP_IMAGE,
+							  "wx&Image Representation\tCtrl+I",
+							  "Store data in a wxImage.");
+	
+	// Set up our Tests menu.
+    wxMenu *tests_menu = new wxMenu();
+	tests_menu->AppendRadioItem(CMD_TEST_FULLSCREEN, "&Full Screen",
+								"Display a full-screen test pattern.");
+	tests_menu->AppendRadioItem(CMD_TEST_RECTS, "&Rectangles",
+								"Display a test pattern with rectangles.");
+
+	// Set up our menu bar.
+    wxMenuBar *menu_bar = new wxMenuBar();
+    menu_bar->Append(file_menu, "&File");
+    menu_bar->Append(opt_menu, "&Options");
+    menu_bar->Append(tests_menu, "&Tests");
+    SetMenuBar(menu_bar);	
+
+    // Force our window to be exactly large enough for the stage.
+	// There are better ways to do this, but they require work.
+    SetClientSize(stage_size);
+}
+
+void MyFrame::OnExit(wxMenuEvent &WXUNUSED(inEvent))
+{
+	// Force the frame to close.
+	Close(TRUE);
+}
+
+void MyFrame::OnRepRawBitmap(wxMenuEvent &WXUNUSED(inEvent))
+{
+	m_Stage->SetRepID(REP_RAWBITMAP);
+}
+
+void MyFrame::OnRepBitmap(wxMenuEvent &WXUNUSED(inEvent))
+{
+	m_Stage->SetRepID(REP_BITMAP);
+}
+
+void MyFrame::OnRepImage(wxMenuEvent &WXUNUSED(inEvent))
+{
+	m_Stage->SetRepID(REP_IMAGE);
+}
+
+void MyFrame::OnTestFullScreen(wxMenuEvent &inEvent)
+{
+	m_Stage->SetTestID(TEST_FULLSCREEN);
+
+}
+
+void MyFrame::OnTestRectangles(wxMenuEvent &inEvent)
+{
+	m_Stage->SetTestID(TEST_RECTS);
+}
+
+
+//=========================================================================
+//  Stage Implementation
+//=========================================================================
+
+BEGIN_EVENT_TABLE(Stage, wxWindow)
+	EVT_PAINT(Stage::OnPaint)
+END_EVENT_TABLE()
+
+Stage::Stage(wxWindow *inParent, const wxSize &inSize)
+	: wxWindow(inParent, -1, wxDefaultPosition, inSize)
+{
+	// Set a reasonable background color.
+	SetBackgroundColour(*wxWHITE);
+
+	// Allocate some offscreen drawing frobs.
+	int i = 0;
+	mRepresentations[i++] = new RawBitmapRepresentation(inSize);
+	mRepresentations[i++] = new BitmapRepresentation(inSize);
+	mRepresentations[i++] = new ImageRepresentation(inSize);
+	wxASSERT(i == REP_COUNT);
+
+	// Prepare our offscreen drawing frobs.
+	mTestID = TEST_DEFAULT;
+	mRepID = REP_DEFAULT;
+	for (i = 0; i < REP_COUNT; i++)
+		mRepresentations[i]->Clear(wxColour(255, 128, 0));
+}
+
+Stage::~Stage()
+{
+	int i;
+	for (i = 0; i < REP_COUNT; i++)
+		delete mRepresentations[i];
+}
+
+void Stage::OnPaint(wxPaintEvent &WXUNUSED(inEvent))
+{
+    wxPaintDC screen_dc(this);
+	Representation *rep = mRepresentations[mRepID];
+
+	switch (mTestID)
+	{
+		case TEST_FULLSCREEN:
+			rep->Paint(screen_dc);
+			break;
+
+		case TEST_RECTS:
+			int x, x_step, y, y_step;
+			x_step = STAGE_WIDTH / 10;
+			y_step = STAGE_HEIGHT / 10;
+			for (y = 0; y < STAGE_HEIGHT; y += y_step)
+				for (x = 0; x < STAGE_WIDTH; x += x_step)
+					rep->PaintRect(screen_dc,
+								   wxRect(wxPoint(x, y),
+										  wxSize(x_step - 10, y_step - 10)));
+			break;
+		
+		default:
+			wxFAIL_MSG("Unknown test");
+	}
+}
+
+
+void Stage::SetRepID(int inRepID)
+{
+	mRepID = inRepID;
+	Refresh(TRUE);
+}
+
+void Stage::SetTestID(int inTestID)
+{
+	mTestID = inTestID;
+	Refresh(TRUE);
+}
+
+
+//=========================================================================
+//  RawBitmapRepresentation Implementation
+//=========================================================================
+
+RawBitmapRepresentation::RawBitmapRepresentation(const wxSize &inStageSize)
+{
+	m_RawBitmap =
+		new wxRawBitmap(inStageSize.GetWidth(), inStageSize.GetHeight(),
+						wxRAWBITMAP_24BIT);
+}
+
+RawBitmapRepresentation::~RawBitmapRepresentation()
+{
+	delete m_RawBitmap;
+}
+
+void RawBitmapRepresentation::Clear(const wxColour &inColor)
+{
+	unsigned char red, green, blue;
+	int x, width, y, height;
+	
+	// Cache our screen size.
+	height = m_RawBitmap->GetHeight();
+	width = m_RawBitmap->GetWidth();
+
+	// Cache our colors.
+	red = inColor.Red();
+	green = inColor.Green();
+	blue = inColor.Blue();
+
+	// Actually clear the screen.
+	wxRawBitmapPixelRef24 row_start = m_RawBitmap->GetData24();
+	wxRawBitmapStride24 stride = m_RawBitmap->GetStride24();
+	WX_RAW24_DECLARE_LIMITS(limits, *m_RawBitmap);
+	for (y = height; y; y--)
+	{
+		wxRawBitmapPixelRef24 cursor = row_start;
+		for (x = width; x; x--)
+		{
+			WX_RAW24_ASSERT_WITHIN_LIMITS(limits, cursor);
+			WX_RAW24_RED(cursor) = red;
+			WX_RAW24_GREEN(cursor) = green;
+			WX_RAW24_BLUE(cursor) = blue;
+			WX_RAW24_OFFSET_X(cursor, 1);
+		}
+		WX_RAW24_OFFSET_Y(row_start, stride, 1);
+	}
+}
+
+void RawBitmapRepresentation::Paint(wxDC &inDC)
+{
+	m_RawBitmap->BlitTo(&inDC, 0, 0,
+						m_RawBitmap->GetWidth(), m_RawBitmap->GetHeight(),
+						0, 0);
+}
+
+void RawBitmapRepresentation::PaintRect(wxDC &inDC, const wxRect &inRect)
+{
+	m_RawBitmap->BlitTo(&inDC, inRect.GetX(), inRect.GetY(),
+						inRect.GetWidth(), inRect.GetHeight(),
+						inRect.GetX(), inRect.GetY());
+}
+
+
+//=========================================================================
+//  BitmapRepresentation Implementation
+//=========================================================================
+
+BitmapRepresentation::BitmapRepresentation(const wxSize &inStageSize)
+{
+	m_Bitmap = new wxBitmap(inStageSize.GetWidth(), inStageSize.GetHeight());
+}
+
+BitmapRepresentation::~BitmapRepresentation()
+{
+	delete m_Bitmap;
+}
+
+void BitmapRepresentation::Clear(const wxColour &inColor)
+{
+	wxMemoryDC dc;
+	dc.SelectObject(*m_Bitmap);
+
+    wxBrush brush(inColor, wxSOLID);
+	dc.SetBackground(brush);
+	dc.Clear();
+}
+
+void BitmapRepresentation::Paint(wxDC &inDC)
+{
+	inDC.DrawBitmap(*m_Bitmap, 0, 0);
+}
+
+void BitmapRepresentation::PaintRect(wxDC &inDC, const wxRect &inRect)
+{
+	wxMemoryDC dc;
+	dc.SelectObject(*m_Bitmap);
+	inDC.Blit(inRect.GetPosition(), inRect.GetSize(), &dc,
+			  inRect.GetPosition());
+}
+
+
+//=========================================================================
+//  ImageRepresentation Implementation
+//=========================================================================
+
+ImageRepresentation::ImageRepresentation(const wxSize &inStageSize)
+{
+	m_Image = new wxImage(inStageSize.GetWidth(), inStageSize.GetHeight());
+}
+
+ImageRepresentation::~ImageRepresentation()
+{
+	delete m_Image;
+}
+
+void ImageRepresentation::Clear(const wxColour &inColor)
+{
+	unsigned char red, green, blue;
+	int x, width, y, height;
+	
+	// Cache our screen size.
+	height = m_Image->GetHeight();
+	width = m_Image->GetWidth();
+
+	// Cache our colors.
+	red = inColor.Red();
+	green = inColor.Green();
+	blue = inColor.Blue();
+
+	// Actually clear the screen.
+	unsigned char *cursor = m_Image->GetData();
+	for (y = 0; y < height; y++)
+	{		
+		for (x = 0; x < width; x++)
+		{
+			*cursor++ = red;
+			*cursor++ = green;
+			*cursor++ = blue;
+		}
+	}
+}
+
+void ImageRepresentation::Paint(wxDC &inDC)
+{
+	wxBitmap bitmap(m_Image);
+	inDC.DrawBitmap(bitmap, 0, 0);
+}
+
+void ImageRepresentation::PaintRect(wxDC &inDC, const wxRect &inRect)
+{
+	wxImage subimage = m_Image->GetSubImage(inRect);
+	wxBitmap bitmap(subimage);
+	inDC.DrawBitmap(bitmap, inRect.GetPosition());
+}
Index: samples/configure.in
===================================================================
--- samples/configure.in	(revision 18)
+++ samples/configure.in	(revision 18)
@@ -69,6 +69,7 @@
             printing/Makefile
             proplist/Makefile
             propsize/Makefile
+	    rawbitmap/Makefile
             resource/Makefile
             rotate/Makefile
             sashtest/Makefile
Index: setup.h_vms
===================================================================
--- setup.h_vms	(revision 18)
+++ setup.h_vms	(revision 18)
@@ -417,6 +417,10 @@
  */
 #define wxUSE_RADIOBTN 1
 /*
+ * Use wxRawBitmap and wxRawBitmapDC
+ */
+#define wxUSE_RAWBITMAP 1
+/*
  * Use this control
  */
 #define wxUSE_SASH 1

 	  	 
