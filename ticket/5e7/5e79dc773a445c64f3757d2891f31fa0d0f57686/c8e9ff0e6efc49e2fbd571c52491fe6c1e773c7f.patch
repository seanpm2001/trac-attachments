Index: include/wx/ribbon/accel.h
===================================================================
--- include/wx/ribbon/accel.h	(revision 0)
+++ include/wx/ribbon/accel.h	(revision 0)
@@ -0,0 +1,42 @@
+#ifndef _WX_RIBBON_ACCEL_H_
+#define _WX_RIBBON_ACCEL_H_
+
+#include "wx/defs.h"
+
+#if wxUSE_RIBBON
+
+#ifdef wxUSE_ACCEL
+
+#include <wx/accel.h>
+#include <wx/hashmap.h>
+
+WX_DECLARE_HASH_MAP( 
+    wxWindowID, wxAcceleratorEntry*,
+    wxIntegerHash, wxIntegerEqual,
+    iAccelArray );
+
+WX_DECLARE_HASH_MAP( 
+    wxWindow*, iAccelArray*,
+    wxPointerHash, wxPointerEqual,
+    iAccelTable );
+
+class wxRibbonAccelerators
+{
+private:
+    //protect from creating
+    wxRibbonAccelerators();
+    static iAccelTable AccelTable;
+protected:
+    static void UpdateWndHotKeys( wxWindow* topWindow );
+    static void OnWindowDestroy( wxWindowDestroyEvent& evt );
+public:
+    static wxString AddHotKey( wxWindow* control, wxWindowID command, const wxString& help_string, wxTypeIdentifier tid );
+    static void ClearWndHotKeys( wxWindow* topWindow );
+    static void RemoveHotKey( wxWindow* control, wxTypeIdentifier tid, wxWindowID command );
+};
+
+#endif // wxUSE_ACCEL
+
+#endif // wxUSE_RIBBON
+
+#endif // _WX_RIBBON_ACCEL_H_
Index: include/wx/ribbon/art.h
===================================================================
--- include/wx/ribbon/art.h	(revision 63959)
+++ include/wx/ribbon/art.h	(working copy)
@@ -227,6 +227,12 @@
                         const wxRect& rect,
                         double visibility) = 0;
 
+    virtual void DrawPanelSeparator( 
+                        wxDC& dc, 
+                        wxWindow* wnd, 
+                        wxOrientation direction = wxHORIZONTAL,
+                        double visibility = 0.5) = 0;
+
     virtual void DrawPageBackground(
                         wxDC& dc,
                         wxWindow* wnd,
@@ -432,6 +438,12 @@
                         wxRibbonPanel* wnd,
                         const wxRect& rect);
 
+    void DrawPanelSeparator( 
+                        wxDC& dc, 
+                        wxWindow* wnd, 
+                        wxOrientation direction = wxHORIZONTAL,
+                        double visibility = 0.5);
+
     void DrawGalleryBackground(
                         wxDC& dc,
                         wxRibbonGallery* wnd,
@@ -756,8 +768,8 @@
                         int* minimum);
 
     void DrawTab(wxDC& dc,
-                 wxWindow* wnd,
-                 const wxRibbonPageTabInfo& tab);
+                        wxWindow* wnd,
+                        const wxRibbonPageTabInfo& tab);
 
     void DrawTabSeparator(
                         wxDC& dc,
@@ -765,6 +777,12 @@
                         const wxRect& rect,
                         double visibility);
 
+    void DrawPanelSeparator( 
+                        wxDC& dc, 
+                        wxWindow* wnd, 
+                        wxOrientation direction = wxHORIZONTAL,
+                        double visibility = 0.5);
+
     void DrawPageBackground(
                         wxDC& dc,
                         wxWindow* wnd,
Index: include/wx/ribbon/buttonbar.h
===================================================================
--- include/wx/ribbon/buttonbar.h	(revision 63959)
+++ include/wx/ribbon/buttonbar.h	(working copy)
@@ -19,6 +19,11 @@
 #include "wx/ribbon/control.h"
 #include "wx/dynarray.h"
 
+#ifdef wxUSE_ACCEL
+#include "wx/ribbon/accel.h"
+#include "wx/ribbon/bar.h"
+#endif
+
 class wxRibbonButtonBarButtonBase;
 class wxRibbonButtonBarLayout;
 class wxRibbonButtonBarButtonInstance;
@@ -67,6 +72,13 @@
                 const wxBitmap& bitmap,
                 const wxString& help_string = wxEmptyString);
     
+    virtual wxRibbonButtonBarButtonBase* AddRadioButton(
+                int button_id,
+                const wxString& label,
+                const wxBitmap& bitmap,
+                const wxString& help_string,
+                int group_id);
+
     virtual wxRibbonButtonBarButtonBase* AddButton(
                 int button_id,
                 const wxString& label,
@@ -87,6 +99,7 @@
     virtual bool IsSizingContinuous() const;
 
     virtual wxSize GetMinSize() const;
+    virtual void EnableBar( bool enable = true );
 protected:
     friend class wxRibbonButtonBarEvent;
     virtual wxSize DoGetBestSize() const;
@@ -100,6 +113,7 @@
     void OnMouseLeave(wxMouseEvent& evt);
     void OnMouseDown(wxMouseEvent& evt);
     void OnMouseUp(wxMouseEvent& evt);
+    void OnHotKey(wxCommandEvent&evt);
 
     virtual wxSize DoGetNextSmallerSize(wxOrientation direction,
                                       wxSize relative_to) const;
@@ -125,6 +139,7 @@
     int m_current_layout;
     bool m_layouts_valid;
     bool m_lock_active_state;
+    bool enabled;
 
 #ifndef SWIG
     DECLARE_CLASS(wxRibbonButtonBar)
@@ -189,6 +204,48 @@
 }
 #endif
 
+//////////////////////////////////////////////////////////////////////////
+class wxRibbonButtonBarButtonSizeInfo
+{
+public:
+    bool is_supported;
+    wxSize size;
+    wxRect normal_region;
+    wxRect dropdown_region;
+};
+
+class wxRibbonButtonBarButtonInstance
+{
+public:
+    wxPoint position;
+    wxRibbonButtonBarButtonBase* base;
+    wxRibbonButtonBarButtonState size;
+};
+
+class wxRibbonButtonBarButtonBase : public wxRibbonToggleable
+{
+    friend class wxRibbonButtonBar;
+public:
+    wxRibbonButtonBarButtonInstance NewInstance();
+
+    wxRibbonButtonBarButtonState GetLargestSize();
+
+    bool GetSmallerSize( wxRibbonButtonBarButtonState* size, int n = 1);
+    wxRibbonButtonBarButtonBase* AssignMenu( wxMenu* menu );
+    wxRibbonButtonBarButtonBase* Enable( bool enable = true, wxWindow* parent = NULL );
+
+    wxString label;
+    wxString help_string;
+    wxBitmap bitmap_large;
+    wxBitmap bitmap_large_disabled;
+    wxBitmap bitmap_small;
+    wxBitmap bitmap_small_disabled;
+    wxRibbonButtonBarButtonSizeInfo sizes[3];
+    wxObject* client_data;
+    wxRibbonButtonKind kind;
+    long state;
+};
+
 #endif // wxUSE_RIBBON
 
 #endif // _WX_RIBBON_BUTTON_BAR_H_
Index: include/wx/ribbon/control.h
===================================================================
--- include/wx/ribbon/control.h	(revision 63959)
+++ include/wx/ribbon/control.h	(working copy)
@@ -21,6 +21,35 @@
 
 class wxRibbonArtProvider;
 
+//////////////////////////////////////////////////////////////////////////
+class wxArrayRibbonToggleable;
+
+class WXDLLIMPEXP_RIBBON wxRibbonToggleable
+{
+public:
+    wxRibbonToggleable();
+    void SetGroup( int group_id );
+    int GetGroup( );
+    bool GetState();
+    void Activate();
+    static int GetActiveCommand( int group_id );
+    static bool SetActiveCommand( int group_id, int command );
+    virtual ~wxRibbonToggleable();
+protected:
+    static wxArrayRibbonToggleable grouped_list; 
+    int id;
+    int m_group_id;
+    wxObject* m_subCtrl;
+    bool b_state;
+    void Remove();
+    void Add();
+    void UpdateStats();
+};
+
+WX_DEFINE_USER_EXPORTED_ARRAY(wxRibbonToggleable*, wxArrayRibbonToggleable, class WXDLLIMPEXP_RIBBON);
+
+//////////////////////////////////////////////////////////////////////////
+
 class WXDLLIMPEXP_RIBBON wxRibbonControl : public wxControl
 {
 public:
@@ -59,6 +88,8 @@
 
 WX_DEFINE_USER_EXPORTED_ARRAY(wxRibbonControl*, wxArrayRibbonControl, class WXDLLIMPEXP_RIBBON);
 
+wxWindow* wxGetBestParent( wxWindow* control, wxTypeIdentifier tid );
+
 #endif // wxUSE_RIBBON
 
 #endif // _WX_RIBBON_CONTROL_H_
Index: include/wx/ribbon/panel.h
===================================================================
--- include/wx/ribbon/panel.h	(revision 63959)
+++ include/wx/ribbon/panel.h	(working copy)
@@ -15,9 +15,12 @@
 
 #if wxUSE_RIBBON
 
+#include <wx/dynarray.h>
 #include "wx/bitmap.h"
 #include "wx/ribbon/control.h"
 
+WX_DECLARE_OBJARRAY(wxSize,      wxArraySize);
+
 enum wxRibbonPanelOption
 {
     wxRIBBON_PANEL_NO_AUTO_MINIMISE    = 1 << 0,
@@ -74,6 +77,8 @@
     wxRibbonPanel* GetExpandedDummy();
     wxRibbonPanel* GetExpandedPanel();
 
+    void AddSeparator();
+
 protected:
     virtual wxSize DoGetBestSize() const;
     wxBorder GetDefaultBorder() const { return wxBORDER_NONE; }
@@ -117,6 +122,10 @@
     bool m_minimised;
     bool m_hovered;
 
+    wxSize CalcNextSize( wxArraySize& stack, wxSize relative_to, wxOrientation direction, int diff = 0, bool minimal_size = false ) const;
+    wxOrientation GetMajorAxis() const;
+    wxSize prev_size;
+
 #ifndef SWIG
     DECLARE_CLASS(wxRibbonPanel)
     DECLARE_EVENT_TABLE()
Index: include/wx/ribbon/toolbar.h
===================================================================
--- include/wx/ribbon/toolbar.h	(revision 63959)
+++ include/wx/ribbon/toolbar.h	(working copy)
@@ -18,6 +18,11 @@
 #include "wx/ribbon/control.h"
 #include "wx/ribbon/art.h"
 
+#ifdef wxUSE_ACCEL
+#include "wx/ribbon/accel.h"
+#include "wx/ribbon/bar.h"
+#endif
+
 class wxRibbonToolBarToolBase;
 class wxRibbonToolBarToolGroup;
 WX_DEFINE_USER_EXPORTED_ARRAY(wxRibbonToolBarToolGroup*, wxArrayRibbonToolBarToolGroup, class WXDLLIMPEXP_RIBBON);
@@ -74,6 +79,12 @@
                 const wxBitmap& bitmap,
                 const wxString& help_string = wxEmptyString);
 
+    virtual wxRibbonToolBarToolBase* AddRadioTool(
+                int tool_id,
+                const wxBitmap& bitmap,
+                const wxString& help_string,
+                int group_id);
+
     virtual wxRibbonToolBarToolBase* AddTool(
                 int tool_id,
                 const wxBitmap& bitmap,
@@ -84,6 +95,9 @@
 
     virtual wxRibbonToolBarToolBase* AddSeparator();
 
+    virtual void EnableTool(int tool_id, bool enable = true);
+    virtual void EnableBar( bool enable = true );
+
     virtual bool Realize();
     virtual void SetRows(int nMin, int nMax = -1);
 
@@ -102,6 +116,7 @@
     void OnMouseUp(wxMouseEvent& evt);
     void OnPaint(wxPaintEvent& evt);
     void OnSize(wxSizeEvent& evt);
+    void OnHotKey(wxCommandEvent&evt);
 
     virtual wxSize DoGetNextSmallerSize(wxOrientation direction,
                                       wxSize relative_to) const;
@@ -119,6 +134,7 @@
     wxSize* m_sizes;
     int m_nrows_min;
     int m_nrows_max;
+    bool enabled;
 
 #ifndef SWIG
     DECLARE_CLASS(wxRibbonToolBar)
@@ -184,6 +200,25 @@
 }
 #endif
 
+//////////////////////////////////////////////////////////////////////////
+class wxRibbonToolBarToolBase : public wxRibbonToggleable
+{
+    friend class wxRibbonToolBar;
+public:
+    wxString help_string;
+    wxBitmap bitmap;
+    wxBitmap bitmap_disabled;
+    wxRect dropdown;
+    wxPoint position;
+    wxSize size;
+    wxObject* client_data;
+    wxRibbonButtonKind kind;
+    long state;
+
+    wxRibbonToolBarToolBase* AssignMenu( wxMenu* menu );
+    wxRibbonToolBarToolBase* Enable( bool enable = true, wxWindow* parent = NULL );
+};
+
 #endif // wxUSE_RIBBON
 
 #endif // _WX_RIBBON_TOOLBAR_H_
Index: interface/wx/ribbon/buttonbar.h
===================================================================
--- interface/wx/ribbon/buttonbar.h	(revision 63959)
+++ interface/wx/ribbon/buttonbar.h	(working copy)
@@ -190,7 +190,25 @@
                 const wxBitmap& bitmap,
                 const wxString& help_string = wxEmptyString);
     
+    
     /**
+       Add a toggleable/radio button to the button bar
+
+       @see AddTool(), wxRibbonToolBAr::AddRadioTool()
+
+       @param int group_id
+           The application-wide ID != 0 which allows group buttons even on 
+           different ribbon panels/pages. Allow to group buttons also with 
+           wxRibbonToolBar tools
+     */
+    virtual wxRibbonButtonBarButtonBase* AddRadioButton(
+                int button_id,
+                const wxString& label,
+                const wxBitmap& bitmap,
+                const wxString& help_string,
+                int group_id);
+
+    /**
         Add a button to the button bar.
         
         @param button_id
Index: interface/wx/ribbon/control.h
===================================================================
--- interface/wx/ribbon/control.h	(revision 63959)
+++ interface/wx/ribbon/control.h	(working copy)
@@ -165,3 +165,56 @@
     virtual wxSize DoGetNextLargerSize(wxOrientation direction,
                                        wxSize relative_to) const;
 };
+
+//////////////////////////////////////////////////////////////////////////
+
+/**
+    @class wxRibbonToggleable
+
+    wxRibbonToggleable serves as a base class for all tools/button on ribbon 
+    bars (wxRibbonToolbar and wxRibbonButtonBar) which allows grouping of them 
+    into application-wide groups. Allows to add/remove tools/buttons to groups;
+    get info which 'command' (tool/button with given ID) in group currently set.
+    Zero-group means that tool/button is non grouped/toggled
+
+    @library{wxribbon}
+    @category{ribbon}
+*/
+class wxRibbonToggleable
+{
+public:
+    /**
+       Move tool/button to group
+       
+       @param int group_id
+     */
+    void SetGroup( int group_id );
+    /**
+       Get tool's/button's current group
+       
+       @return int
+     */
+    int GetGroup( );
+    /**
+       @return @true if button/tool currently toggled (active)
+     */
+    bool GetState();
+    /**
+       Set button/tool as active in it's group
+     */
+    void Activate();
+    /**
+       @return ID of currently active tool/button in group
+     */
+    static int GetActiveCommand( int group_id );
+    /**
+       Sets active button/tool in group
+       
+       @param int group_id
+            Group ID
+       @param int command
+            Tool/button with this ID will be set active if exists
+       @return @true if tool/button exists and successfully set
+     */
+    static bool SetActiveCommand( int group_id, int command );
+};
Index: interface/wx/ribbon/panel.h
===================================================================
--- interface/wx/ribbon/panel.h	(revision 63959)
+++ interface/wx/ribbon/panel.h	(working copy)
@@ -173,6 +173,11 @@
         Realize all children of the panel.
     */
     bool Realize();
+
+    /**
+       Adds separator after sub-control (button- and toolbar)
+     */
+    void AddSeparator();
     
     /**
         Get the dummy panel of an expanded panel.
Index: interface/wx/ribbon/toolbar.h
===================================================================
--- interface/wx/ribbon/toolbar.h	(revision 63959)
+++ interface/wx/ribbon/toolbar.h	(working copy)
@@ -102,7 +102,24 @@
                 const wxBitmap& bitmap,
                 const wxString& help_string = wxEmptyString);
 
+
     /**
+        Add a toggleable/radio tool to the tool bar
+
+        @see AddTool(), wxRibbonButtonBAr::AddRadioButton()
+
+        @param int group_id
+            The application-wide ID != 0 which allows group tools even on 
+            different ribbon panels/pages. Allow to group tools also with 
+            wxRibbonButtonBar buttons
+     */
+    virtual wxRibbonToolBarToolBase* AddRadioTool(
+                int tool_id,
+                const wxBitmap& bitmap,
+                const wxString& help_string,
+                int group_id);
+
+    /**
         Add a tool to the tool bar.
         
         @param tool_id
@@ -124,7 +141,7 @@
         @return An opaque pointer which can be used only with other tool bar
             methods.
             
-        @see AddDropdownTool(), AddHybridTool(), AddSeparator()
+        @see AddDropdownTool(), AddHybridTool(), AddSeparator(), AddRadioTool()
     */
     virtual wxRibbonToolBarToolBase* AddTool(
                 int tool_id,
@@ -144,6 +161,16 @@
     virtual wxRibbonToolBarToolBase* AddSeparator();
 
     /**
+        Enable or disable a single tool on the bar.
+        
+        @param tool_id
+            ID of the tool to enable or disable.
+        @param enable
+            @true to enable the button, @false to disable it.
+    */
+    virtual void EnableTool(int tool_id, bool enable = true);
+
+    /**
         Set the number of rows to distribute tool groups over.
         
         Tool groups can be distributed over a variable number of rows. The way
Index: samples/ribbon/ribbondemo.cpp
===================================================================
--- samples/ribbon/ribbondemo.cpp	(revision 63959)
+++ samples/ribbon/ribbondemo.cpp	(working copy)
@@ -209,14 +209,16 @@
     m_ribbon = new wxRibbonBar(this, wxID_ANY);
 
     {
+        wxRibbonToggleable* tool; 
+
         wxRibbonPage* home = new wxRibbonPage(m_ribbon, wxID_ANY, wxT("Examples"), ribbon_xpm);
-        wxRibbonPanel *toolbar_panel = new wxRibbonPanel(home, wxID_ANY, wxT("Toolbar"), wxNullBitmap, wxDefaultPosition, wxDefaultSize, wxRIBBON_PANEL_NO_AUTO_MINIMISE);
+        wxRibbonPanel *toolbar_panel = new wxRibbonPanel(home, wxID_ANY, wxT("Toolbar"), wxNullBitmap, wxDefaultPosition, wxDefaultSize);
         wxRibbonToolBar *toolbar = new wxRibbonToolBar(toolbar_panel, ID_MAIN_TOOLBAR);
         toolbar->AddTool(wxID_ANY, align_left_xpm);
         toolbar->AddTool(wxID_ANY, align_center_xpm);
         toolbar->AddTool(wxID_ANY, align_right_xpm);
         toolbar->AddSeparator();
-        toolbar->AddHybridTool(wxID_NEW, wxArtProvider::GetBitmap(wxART_NEW, wxART_OTHER, wxSize(16, 15)));
+        toolbar->AddHybridTool(wxID_NEW, wxArtProvider::GetBitmap(wxART_NEW, wxART_OTHER, wxSize(16, 15)));//->Enable(false);
         toolbar->AddTool(wxID_ANY, wxArtProvider::GetBitmap(wxART_FILE_OPEN, wxART_OTHER, wxSize(16, 15)));
         toolbar->AddTool(wxID_ANY, wxArtProvider::GetBitmap(wxART_FILE_SAVE, wxART_OTHER, wxSize(16, 15)));
         toolbar->AddTool(wxID_ANY, wxArtProvider::GetBitmap(wxART_FILE_SAVE_AS, wxART_OTHER, wxSize(16, 15)));
@@ -230,24 +232,53 @@
         toolbar->AddHybridTool(ID_POSITION_LEFT, position_left_xpm);
         toolbar->AddHybridTool(ID_POSITION_TOP, position_top_xpm);
         toolbar->AddSeparator();
-        toolbar->AddHybridTool(wxID_PRINT, wxArtProvider::GetBitmap(wxART_PRINT, wxART_OTHER, wxSize(16, 15)));
+        //toolbar->EnableBar(false);
+
+        // new wxRibbonToolBar method example
+        toolbar->AddRadioTool(wxID_PRINT, wxArtProvider::GetBitmap(wxART_PRINT, wxART_OTHER, wxSize(16, 15)), " \t~", 1);
+
+        // enabling/disabling tool by it's id
+        //toolbar->EnableTool(wxID_NEW,false);
+
         toolbar->SetRows(2, 3);
 
-        wxRibbonPanel *selection_panel = new wxRibbonPanel(home, wxID_ANY, wxT("Selection"), wxBitmap(selection_panel_xpm));
-        wxRibbonButtonBar *selection = new wxRibbonButtonBar(selection_panel);
-        selection->AddButton(ID_SELECTION_EXPAND_V, wxT("Expand Vertically"), wxBitmap(expand_selection_v_xpm), wxEmptyString);
-        selection->AddButton(ID_SELECTION_EXPAND_H, wxT("Expand Horizontally"), wxBitmap(expand_selection_h_xpm), wxEmptyString);
-        selection->AddButton(ID_SELECTION_CONTRACT, wxT("Contract"), wxBitmap(auto_crop_selection_xpm), wxBitmap(auto_crop_selection_small_xpm));
+        toolbar_panel->AddSeparator();
 
-        wxRibbonPanel *shapes_panel = new wxRibbonPanel(home, wxID_ANY, wxT("Shapes"), wxBitmap(circle_small_xpm));
-        wxRibbonButtonBar *shapes = new wxRibbonButtonBar(shapes_panel);
-        shapes->AddButton(ID_CIRCLE, wxT("Circle"), wxBitmap(circle_xpm), wxBitmap(circle_small_xpm));
+        //wxRibbonPanel *selection_panel = new wxRibbonPanel(home, wxID_ANY, wxT("Selection"), wxBitmap(selection_panel_xpm));
+        wxRibbonButtonBar *selection = new wxRibbonButtonBar(toolbar_panel);
+
+        // new wxRibbonButtonBar method example
+        selection->AddRadioButton(ID_SELECTION_EXPAND_V, wxT("Expand Vertically"), wxBitmap(expand_selection_v_xpm), " \t1", 1);
+
+        //implicit casting
+        tool = selection->AddButton(ID_SELECTION_EXPAND_H, wxT("Expand Horizontally"), wxBitmap(expand_selection_h_xpm), " \t2");
+        //grouping via wxRibbonToggleable
+        tool->SetGroup(1);
+        //make tool pressed
+        tool->Activate();
+
+        tool = selection->AddButton(ID_SELECTION_CONTRACT, wxT("Contract"), wxBitmap(auto_crop_selection_xpm), " \t3");
+        tool->SetGroup(1);
+        tool = selection->AddButton(wxID_ANY, wxT("Contract"), wxBitmap(auto_crop_selection_xpm));
+
+        toolbar_panel->AddSeparator();
+
+        //use static method to set selection. It does not refresh layout, but Realize() do
+        wxRibbonToggleable::SetActiveCommand( 1, ID_SELECTION_CONTRACT );
+
+        //wxRibbonPanel *shapes_panel = new wxRibbonPanel(home, wxID_ANY, wxT("Shapes"), wxBitmap(circle_small_xpm));
+        wxRibbonButtonBar *shapes = new wxRibbonButtonBar(toolbar_panel);
+        shapes->AddButton(ID_CIRCLE, wxT("Circle"), wxBitmap(circle_xpm), "Circle\t4");//->Enable(false);
         shapes->AddButton(ID_CROSS, wxT("Cross"), wxBitmap(cross_xpm), wxEmptyString);
         shapes->AddHybridButton(ID_TRIANGLE, wxT("Triangle"), wxBitmap(triangle_xpm));
         shapes->AddButton(ID_SQUARE, wxT("Square"), wxBitmap(square_xpm), wxEmptyString);
         shapes->AddDropdownButton(ID_POLYGON, wxT("Other Polygon"), wxBitmap(hexagon_xpm), wxEmptyString);
+        //shapes->EnableBar(false);
 
-        new wxRibbonPanel(home, wxID_ANY, wxT("Another Panel"), wxNullBitmap, wxDefaultPosition, wxDefaultSize, wxRIBBON_PANEL_EXT_BUTTON);
+        // enabling/disabling button by it's id
+        //shapes->EnableButton(ID_CIRCLE,false);
+
+        //new wxRibbonPanel(home, wxID_ANY, wxT("Another Panel"), wxNullBitmap, wxDefaultPosition, wxDefaultSize, wxRIBBON_PANEL_EXT_BUTTON);
     }
     {
         wxFont label_font(8, wxFONTFAMILY_DEFAULT, wxFONTSTYLE_NORMAL, wxFONTWEIGHT_LIGHT);
@@ -287,6 +318,8 @@
     s->Add(m_logwindow, 1, wxEXPAND);
 
     SetSizer(s);
+
+    SetStatusBar(CreateStatusBar());
 }
 
 void MyFrame::SetBarStyle(long style)
Index: src/ribbon/accel.cpp
===================================================================
--- src/ribbon/accel.cpp	(revision 0)
+++ src/ribbon/accel.cpp	(revision 0)
@@ -0,0 +1,127 @@
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+
+#ifdef wxUSE_ACCEL
+
+#include <wx/ribbon/control.h>
+#include <wx/ribbon/accel.h>
+
+wxString wxRibbonAccelerators::AddHotKey( wxWindow* control, wxWindowID command, const wxString& help_string, wxTypeIdentifier tid )
+{
+    wxAcceleratorEntry* accel = wxAcceleratorEntry::Create(help_string);
+    wxString new_help_string = wxStripMenuCodes(help_string);
+    if(accel)
+    {
+        wxWindow* topWindow = wxGetBestParent(control,tid);
+
+        if(topWindow)
+        {
+            //find accelerators for this top window
+            iAccelTable::iterator it = AccelTable.find(topWindow);
+            if(it==AccelTable.end())
+            {
+                it = AccelTable.insert(iAccelTable::value_type(topWindow,new iAccelArray())).first;
+            }
+
+            accel->Set(accel->GetFlags(),accel->GetKeyCode(),command);
+
+            //find if command is already here
+            iAccelArray::iterator sit = it->second->find(command);
+            if(sit!=it->second->end())
+            {
+                delete sit->second;
+                sit->second = accel;
+            }
+            else
+            {
+                it->second->insert(iAccelArray::value_type(command,accel));
+                topWindow->Bind(wxEVT_DESTROY, &wxRibbonAccelerators::OnWindowDestroy);
+            }
+
+            //refresh accel table
+            UpdateWndHotKeys(topWindow);
+
+            //modify string
+            new_help_string += " (" + (help_string.SubString( new_help_string.Len()+1 , help_string.Len() )) + ")";
+        }
+    }
+    return new_help_string;
+}
+
+void wxRibbonAccelerators::RemoveHotKey( wxWindow* control, wxTypeIdentifier tid, wxWindowID command )
+{
+    wxWindow* topWindow = wxGetBestParent(control,tid);
+    if(topWindow)
+    {
+        //find accelerators for this top window
+        iAccelTable::iterator it = AccelTable.find(topWindow);
+        if(it==AccelTable.end())
+        {
+            return;
+        }
+
+        //find if command is here
+        iAccelArray::iterator sit = it->second->find(command);
+        if(sit==it->second->end())
+        {
+            return;
+        }
+
+        //remove
+        delete sit->second;
+        it->second->erase(sit);
+
+        //refresh accel table
+        UpdateWndHotKeys(topWindow);
+    }
+}
+
+void wxRibbonAccelerators::OnWindowDestroy( wxWindowDestroyEvent& evt )
+{
+    wxRibbonAccelerators::ClearWndHotKeys(evt.GetWindow());
+}
+
+void wxRibbonAccelerators::ClearWndHotKeys( wxWindow* topWindow )
+{
+    iAccelTable::iterator it = AccelTable.find(topWindow);
+    if(it!=AccelTable.end())
+    {
+        iAccelArray::iterator sit = it->second->begin();
+        for( ; sit != it->second->end(); sit++ )
+        {
+            delete sit->second;
+        }
+        delete it->second;
+        AccelTable.erase(it);
+    }
+}
+
+void wxRibbonAccelerators::UpdateWndHotKeys( wxWindow* topWindow )
+{
+    iAccelTable::iterator it = AccelTable.find(topWindow);
+    if(it!=AccelTable.end())
+    {
+        size_t n = 0, count = it->second->size();
+        if(count)
+        {
+            wxAcceleratorEntry *accelEntries = new wxAcceleratorEntry[count];
+
+            iAccelArray::iterator sit = it->second->begin();
+            for( ; n < count; sit++,n++ )
+            {
+                accelEntries[n] = *(sit->second);
+            }
+
+            topWindow->SetAcceleratorTable(wxAcceleratorTable(count, accelEntries));
+
+            delete [] accelEntries;
+        }
+    }
+}
+
+iAccelTable wxRibbonAccelerators::AccelTable;
+
+#endif
Index: src/ribbon/art_aui.cpp
===================================================================
--- src/ribbon/art_aui.cpp	(revision 63959)
+++ src/ribbon/art_aui.cpp	(working copy)
@@ -497,6 +497,47 @@
     // No explicit separators between tabs
 }
 
+void wxRibbonAUIArtProvider::DrawPanelSeparator(
+                    wxDC& dc,
+                    wxWindow* wnd,
+                    wxOrientation direction,
+                    double visibility)
+{
+    wxRect rect = wnd->GetSize();
+
+    dc.SetPen(*wxTRANSPARENT_PEN);
+    dc.SetBrush(m_background_brush);
+    dc.DrawRectangle(rect.x, rect.y, rect.width, rect.height);
+
+    //DrawPartialPageBackground(dc, wnd, rect, true);
+
+    if( ( (wxRibbonPanel*)wnd->GetParent() )->IsHovered() )
+    {
+#ifdef __WXMAC__
+        wxColour colour = m_page_hover_background_gradient_colour;
+        wxColour gradient = m_page_hover_background_colour;
+#else
+        wxColour colour = m_page_hover_background_colour;
+        wxColour gradient = m_page_hover_background_gradient_colour;
+#endif
+        dc.GradientFillLinear(rect, colour, gradient, wxSOUTH);
+    }
+
+    dc.SetPen(m_tab_border_pen);
+    dc.SetBrush(m_background_brush);
+
+    if(direction == wxHORIZONTAL)
+    {
+        dc.DrawLine( rect.width / 2, 1, rect.width / 2,
+            rect.height - 1);
+    }
+    else
+    {
+        dc.DrawLine( 1, rect.width / 2, rect.height - 1,
+            rect.width / 2);
+    }
+}
+
 void wxRibbonAUIArtProvider::DrawPageBackground(
                         wxDC& dc,
                         wxWindow* WXUNUSED(wnd),
Index: src/ribbon/art_msw.cpp
===================================================================
--- src/ribbon/art_msw.cpp	(revision 63959)
+++ src/ribbon/art_msw.cpp	(working copy)
@@ -1058,6 +1058,50 @@
     }
 }
 
+void wxRibbonMSWArtProvider::DrawPanelSeparator( wxDC& dc, wxWindow* wnd, wxOrientation direction, double visibility /*= 0.5*/ )
+{
+    wxRect rect = wnd->GetSize();
+    DrawPartialPageBackground(dc, wnd, rect, true);
+
+    if(direction == wxVERTICAL)
+    {
+        rect.SetSize( wxSize(rect.GetSize().GetHeight(), rect.GetSize().GetWidth()) );
+    }
+
+    wxCoord x = rect.x + rect.width / 2;
+    double h = (double)(rect.height - 1);
+
+    double r1 = m_tab_ctrl_background_brush.GetColour().Red() * (1.0 - visibility) + 0.5;
+    double g1 = m_tab_ctrl_background_brush.GetColour().Green() * (1.0 - visibility) + 0.5;
+    double b1 = m_tab_ctrl_background_brush.GetColour().Blue() * (1.0 - visibility) + 0.5;
+    double r2 = m_tab_separator_colour.Red();
+    double g2 = m_tab_separator_colour.Green();
+    double b2 = m_tab_separator_colour.Blue();
+    double r3 = m_tab_separator_gradient_colour.Red();
+    double g3 = m_tab_separator_gradient_colour.Green();
+    double b3 = m_tab_separator_gradient_colour.Blue();
+
+    for(int i = 0; i < rect.height - 1; ++i)
+    {
+        double p = ((double)i)/h;
+
+        double r = (p * r3 + (1.0 - p) * r2) * visibility + r1;
+        double g = (p * g3 + (1.0 - p) * g2) * visibility + g1;
+        double b = (p * b3 + (1.0 - p) * b2) * visibility + b1;
+
+        wxPen P(wxColour((unsigned char)r, (unsigned char)g, (unsigned char)b));
+        dc.SetPen(P);
+        if(direction == wxVERTICAL)
+        {
+            dc.DrawPoint(rect.y + rect.height - i, x);
+        }
+        else
+        {
+            dc.DrawPoint(x, rect.y + i);
+        }
+    }
+}
+
 void wxRibbonMSWArtProvider::DrawTabSeparator(
                         wxDC& dc,
                         wxWindow* wnd,
Index: src/ribbon/buttonbar.cpp
===================================================================
--- src/ribbon/buttonbar.cpp	(revision 63959)
+++ src/ribbon/buttonbar.cpp	(working copy)
@@ -17,6 +17,7 @@
 
 #if wxUSE_RIBBON
 
+#include "wx/ribbon/panel.h"
 #include "wx/ribbon/buttonbar.h"
 #include "wx/ribbon/art.h"
 #include "wx/dcbuffer.h"
@@ -43,36 +44,19 @@
     EVT_SIZE(wxRibbonButtonBar::OnSize)
     EVT_LEFT_DOWN(wxRibbonButtonBar::OnMouseDown)
     EVT_LEFT_UP(wxRibbonButtonBar::OnMouseUp)
+    EVT_MENU(wxID_ANY,wxRibbonButtonBar::OnHotKey)
 END_EVENT_TABLE()
 
-class wxRibbonButtonBarButtonSizeInfo
-{
-public:
-    bool is_supported;
-    wxSize size;
-    wxRect normal_region;
-    wxRect dropdown_region;
-};
 
-class wxRibbonButtonBarButtonInstance
-{
-public:
-    wxPoint position;
-    wxRibbonButtonBarButtonBase* base;
-    wxRibbonButtonBarButtonState size;
-};
-
-class wxRibbonButtonBarButtonBase
-{
-public:
-    wxRibbonButtonBarButtonInstance NewInstance()
+//////////////////////////////////////////////////////////////////////////
+    wxRibbonButtonBarButtonInstance wxRibbonButtonBarButtonBase::NewInstance()
     {
         wxRibbonButtonBarButtonInstance i;
         i.base = this;
         return i;
     }
 
-    wxRibbonButtonBarButtonState GetLargestSize()
+    wxRibbonButtonBarButtonState wxRibbonButtonBarButtonBase::GetLargestSize()
     {
         if(sizes[wxRIBBON_BUTTONBAR_BUTTON_LARGE].is_supported)
             return wxRIBBON_BUTTONBAR_BUTTON_LARGE;
@@ -82,8 +66,8 @@
         return wxRIBBON_BUTTONBAR_BUTTON_SMALL;
     }
 
-    bool GetSmallerSize(
-        wxRibbonButtonBarButtonState* size, int n = 1)
+    bool wxRibbonButtonBarButtonBase::GetSmallerSize(
+        wxRibbonButtonBarButtonState* size, int n /*= 1*/)
     {
         for(; n > 0; --n)
         {
@@ -109,19 +93,37 @@
         return true;
     }
 
-    wxString label;
-    wxString help_string;
-    wxBitmap bitmap_large;
-    wxBitmap bitmap_large_disabled;
-    wxBitmap bitmap_small;
-    wxBitmap bitmap_small_disabled;
-    wxRibbonButtonBarButtonSizeInfo sizes[3];
-    wxObject* client_data;
-    int id;
-    wxRibbonButtonKind kind;
-    long state;
-};
+    wxRibbonButtonBarButtonBase* wxRibbonButtonBarButtonBase::AssignMenu( wxMenu* menu )
+    {
+        if( this->kind == wxRIBBON_BUTTON_HYBRID || this->kind == wxRIBBON_BUTTON_DROPDOWN )
+        {
+            m_subCtrl = menu;
+        }
+        return this;
+    }
 
+    wxRibbonButtonBarButtonBase* wxRibbonButtonBarButtonBase::Enable( bool enable /*= true*/, wxWindow* parent /*= NULL*/ )
+    {
+        if(enable)
+        {
+            if(state & wxRIBBON_BUTTONBAR_BUTTON_DISABLED)
+            {
+                state &= ~wxRIBBON_BUTTONBAR_BUTTON_DISABLED;
+                if(parent) parent->Refresh();
+            }
+        }
+        else
+        {
+            if((state & wxRIBBON_BUTTONBAR_BUTTON_DISABLED) == 0)
+            {
+                state |= wxRIBBON_BUTTONBAR_BUTTON_DISABLED;
+                if(parent) parent->Refresh();
+            }
+        }
+        return this;
+    }
+//////////////////////////////////////////////////////////////////////////
+
 WX_DECLARE_OBJARRAY(wxRibbonButtonBarButtonInstance, wxArrayRibbonButtonBarButtonInstance);
 #include "wx/arrimpl.cpp"
 WX_DEFINE_OBJARRAY(wxArrayRibbonButtonBarButtonInstance)
@@ -178,6 +180,7 @@
 wxRibbonButtonBar::wxRibbonButtonBar()
 {
     m_layouts_valid = false;
+    enabled = true;
 }
 
 wxRibbonButtonBar::wxRibbonButtonBar(wxWindow* parent,
@@ -188,6 +191,7 @@
     : wxRibbonControl(parent, id, pos, size, wxBORDER_NONE)
 {
     m_layouts_valid = false;
+    enabled = true;
 
     CommonInit(style);
 }
@@ -227,6 +231,20 @@
     return true;
 }
 
+wxRibbonButtonBarButtonBase* wxRibbonButtonBar::AddRadioButton(
+                int button_id,
+                const wxString& label,
+                const wxBitmap& bitmap,
+                const wxString& help_string,
+                int group_id)
+{
+    wxASSERT_MSG( group_id!=0, "Zero-group is not allowed for AddRadioButton. Use AddButton instead" );
+    wxRibbonButtonBarButtonBase* button = AddButton(button_id, label, bitmap, wxNullBitmap, wxNullBitmap,
+        wxNullBitmap, wxRIBBON_BUTTON_NORMAL, help_string);
+    button->SetGroup(group_id);
+    return button;
+}
+
 wxRibbonButtonBarButtonBase* wxRibbonButtonBar::AddButton(
                 int button_id,
                 const wxString& label,
@@ -328,7 +346,11 @@
         base->bitmap_small_disabled = MakeDisabledBitmap(base->bitmap_small);
     }
     base->kind = kind;
+#ifdef wxUSE_ACCEL
+    base->help_string = wxRibbonAccelerators::AddHotKey(this,button_id,help_string,wxTypeId(this));
+#else
     base->help_string = help_string;
+#endif
     base->client_data = client_data;
     base->state = 0;
 
@@ -381,6 +403,12 @@
     return true;
 }
 
+void wxRibbonButtonBar::EnableBar( bool enable /* = true */ )
+{
+    enabled = enable;
+    Refresh();
+}
+
 void wxRibbonButtonBar::ClearButtons()
 {
     m_layouts_valid = false;
@@ -389,6 +417,9 @@
     for(i = 0; i < count; ++i)
     {
         wxRibbonButtonBarButtonBase* button = m_buttons.Item(i);
+#ifdef wxUSE_ACCEL
+        wxRibbonAccelerators::RemoveHotKey(this,wxTypeId(this),button->id);
+#endif
         delete button;
     }
     m_buttons.Clear();
@@ -404,6 +435,9 @@
         wxRibbonButtonBarButtonBase* button = m_buttons.Item(i);
         if(button->id == button_id)
         {
+#ifdef wxUSE_ACCEL
+            wxRibbonAccelerators::RemoveHotKey(this,wxTypeId(this),button->id);
+#endif
             m_layouts_valid = false;
             m_buttons.RemoveAt(i);
             Realize();
@@ -423,22 +457,7 @@
         wxRibbonButtonBarButtonBase* button = m_buttons.Item(i);
         if(button->id == button_id)
         {
-            if(enable)
-            {
-                if(button->state & wxRIBBON_BUTTONBAR_BUTTON_DISABLED)
-                {
-                    button->state &= ~wxRIBBON_BUTTONBAR_BUTTON_DISABLED;
-                    Refresh();
-                }
-            }
-            else
-            {
-                if((button->state & wxRIBBON_BUTTONBAR_BUTTON_DISABLED) == 0)
-                {
-                    button->state |= wxRIBBON_BUTTONBAR_BUTTON_DISABLED;
-                    Refresh();
-                }
-            }
+            button->Enable(enable,this);
             return;
         }
     }
@@ -578,15 +597,17 @@
 
         wxBitmap* bitmap = &base->bitmap_large;
         wxBitmap* bitmap_small = &base->bitmap_small;
-        if(base->state & wxRIBBON_BUTTONBAR_BUTTON_DISABLED)
+        if(base->state & wxRIBBON_BUTTONBAR_BUTTON_DISABLED  || !enabled)
         {
             bitmap = &base->bitmap_large_disabled;
             bitmap_small = &base->bitmap_small_disabled;
         }
         wxRect rect(button.position + m_layout_offset, base->sizes[button.size].size);
         
-        m_art->DrawButtonBarButton(dc, this, rect, base->kind,
-            base->state | button.size, base->label, *bitmap, *bitmap_small);
+        int style = base->state | button.size | (base->GetState()?wxRIBBON_BUTTONBAR_BUTTON_ACTIVE_MASK:0);
+        if(!enabled) style = style & ~wxRIBBON_BUTTONBAR_BUTTON_ACTIVE_MASK & ~wxRIBBON_BUTTONBAR_BUTTON_HOVER_MASK;
+
+        m_art->DrawButtonBarButton(dc, this, rect, base->kind, style, base->label, *bitmap, *bitmap_small);
     }
 }
 
@@ -626,8 +647,49 @@
     m_lock_active_state = false;
 
     SetBackgroundStyle(wxBG_STYLE_CUSTOM);
+#ifdef wxUSE_ACCEL
+   wxWindow* bestParent = wxGetTopLevelParent(this);
+   if(bestParent)
+   {
+       bestParent->Connect(wxEVT_COMMAND_MENU_SELECTED, (wxObjectEventFunction)&wxRibbonButtonBar::OnHotKey, NULL, this);
+   }
+#endif
 }
 
+void wxRibbonButtonBar::OnHotKey(wxCommandEvent& evt)
+{
+    evt.Skip();
+#ifdef wxUSE_ACCEL
+    wxRibbonButtonBarLayout* layout = m_layouts.Item(m_current_layout);
+    size_t btn_count = layout->buttons.Count();
+    size_t btn_i;
+    for(btn_i = 0; btn_i < btn_count; ++btn_i)
+    {
+        wxRibbonButtonBarButtonInstance& instance = layout->buttons.Item(btn_i);
+        if(evt.GetId()==instance.base->id)
+        {
+            if( !(instance.base->state & wxRIBBON_BUTTONBAR_BUTTON_DISABLED) && enabled )
+            {
+                instance.base->Activate();
+                wxGetBestParent(this,wxTypeId(wxRibbonPage))->Refresh();
+
+                wxRibbonButtonBarEvent notification(wxEVT_COMMAND_RIBBONBUTTON_CLICKED, instance.base->id);
+                notification.SetEventObject(this);
+                notification.SetBar(this);
+                notification.SetExtraLong(instance.base->GetState());
+                m_lock_active_state = true;
+                ProcessWindowEvent(notification);
+                m_lock_active_state = false;
+            }
+
+            //if not .Skip event then GUI does not refresh (why?)
+            evt.SetId(wxID_ANY);
+            return;
+        }
+    }
+#endif
+}
+
 wxSize wxRibbonButtonBar::GetMinSize() const
 {
     return m_layouts.Last()->overall_size;
@@ -816,9 +878,13 @@
         btn_rect.SetTopLeft(m_layout_offset + instance.position);
         btn_rect.SetSize(size.size);
         if(btn_rect.Contains(cursor))
-        {
+        {            
+            //disabled buttons does not reacts
+            if(instance.base->state & wxRIBBON_BUTTONBAR_BUTTON_DISABLED) break;
+
             new_hovered = &instance;
             new_hovered_state = instance.base->state;
+
             new_hovered_state &= ~wxRIBBON_BUTTONBAR_BUTTON_HOVER_MASK;
             wxPoint offset(cursor);
             offset -= btn_rect.GetTopLeft();
@@ -834,6 +900,14 @@
         }
     }
 
+    if(new_hovered != m_hovered_button)
+    {
+        if(new_hovered)
+            ((wxWindow*)this)->SetToolTip(new_hovered->base->help_string);
+        else
+            ((wxWindow*)this)->SetToolTip("");
+    }
+
     if(new_hovered != m_hovered_button || (m_hovered_button != NULL &&
         new_hovered_state != m_hovered_button->base->state))
     {
@@ -896,6 +970,9 @@
         btn_rect.SetSize(size.size);
         if(btn_rect.Contains(cursor))
         {
+            //disabled buttons are not reacts
+            if(instance.base->state & wxRIBBON_BUTTONBAR_BUTTON_DISABLED) break;
+
             m_active_button = &instance;
             cursor -= btn_rect.GetTopLeft();
             long state = 0;
@@ -914,7 +991,7 @@
 {
     wxPoint cursor(evt.GetPosition());
 
-    if(m_active_button)
+    if(m_active_button && enabled)
     {
         wxRibbonButtonBarButtonSizeInfo& size =
             m_active_button->base->sizes[m_active_button->size];
@@ -934,19 +1011,39 @@
                     event_type = wxEVT_COMMAND_RIBBONBUTTON_DROPDOWN_CLICKED;
                 else
                     break;
+                m_active_button->base->Activate();
                 wxRibbonButtonBarEvent notification(event_type, id);
                 notification.SetEventObject(this);
                 notification.SetBar(this);
+                notification.SetExtraLong(m_active_button->base->GetState());
+
                 m_lock_active_state = true;
-                ProcessWindowEvent(notification);
+                if(event_type == wxEVT_COMMAND_RIBBONBUTTON_DROPDOWN_CLICKED 
+                    && m_active_button->base->m_subCtrl 
+                    && wxTypeId( *m_active_button->base->m_subCtrl ) == wxTypeId(wxMenu) )
+                {
+                    notification.PopupMenu((wxMenu*)m_active_button->base->m_subCtrl);
+                }
+                else
+                {
+                    ProcessWindowEvent(notification);
+                }
                 m_lock_active_state = false;
+
             } while(false);
+
+            wxWindow* wnd = this;
+
             if(m_active_button) // may have been NULLed by event handler
             {
                 m_active_button->base->state &= ~wxRIBBON_BUTTONBAR_BUTTON_ACTIVE_MASK;
+
+                wnd = wxGetBestParent(this,wxTypeId(wxRibbonPage));
+
                 m_active_button = NULL;
             }
-            Refresh(false);
+
+            wnd->Refresh(false);
         }
     }
 }
@@ -991,7 +1088,13 @@
         pos = btn_rect.GetBottomLeft();
         pos.y++;
     }
-    return m_bar->PopupMenu(menu, pos);
+    bool menu_result = m_bar->PopupMenu(menu, pos);
+
+    //collapse expanded panel if it was...
+    wxWindow* expanded = wxGetBestParent( m_bar, wxTypeId(wxRibbonPanel) );
+    if(expanded && wxTypeId(*expanded)==wxTypeId(wxRibbonPanel)) ((wxRibbonPanel*)expanded)->HideExpanded();
+
+    return menu_result;
 }
 
 #endif // wxUSE_RIBBON
Index: src/ribbon/control.cpp
===================================================================
--- src/ribbon/control.cpp	(revision 63959)
+++ src/ribbon/control.cpp	(working copy)
@@ -107,4 +107,138 @@
     return true;
 }
 
+//////////////////////////////////////////////////////////////////////////
+
+wxRibbonToggleable::wxRibbonToggleable() : m_group_id(0), b_state(false), id(wxID_ANY),m_subCtrl(NULL) {}
+
+void wxRibbonToggleable::Remove()
+{
+    for( unsigned int k=0; k < grouped_list.GetCount(); k++)
+    {
+        if(grouped_list[k] == this)
+        {
+            grouped_list.RemoveAt(k);
+        }
+    }
+}
+
+void wxRibbonToggleable::Add()
+{
+    for( unsigned int k=0; k < grouped_list.GetCount(); k++)
+    {
+        if(grouped_list[k] == this)
+        {
+            return;
+        }
+    }
+    grouped_list.Add(this);
+}
+
+void wxRibbonToggleable::SetGroup( int group_id )
+{
+    if(group_id==m_group_id) 
+        return;
+
+    m_group_id = group_id;
+    if(group_id==0)
+    {
+        Remove();
+    }
+    else if(m_group_id!=0)
+    {
+        Add();
+    }
+}
+
+int wxRibbonToggleable::GetGroup()
+{
+    return m_group_id;
+}
+
+bool wxRibbonToggleable::GetState()
+{
+    return b_state;
+}
+
+void wxRibbonToggleable::Activate()
+{
+    if(m_group_id==0)
+    {
+        b_state = false;
+        return;
+    }
+    b_state = !b_state;
+    UpdateStats();
+}
+
+void wxRibbonToggleable::UpdateStats()
+{
+    int group_count = 0;
+    for( unsigned int k=0; k < grouped_list.GetCount(); k++)
+    {
+        if(grouped_list[k]!=this && grouped_list[k]->m_group_id == m_group_id)
+        {
+            grouped_list[k]->b_state = false;
+            group_count++;
+        }
+    }
+    if(group_count>0)
+    {
+        b_state = true;
+    }
+}
+
+wxRibbonToggleable::~wxRibbonToggleable()
+{
+    if(m_subCtrl) delete m_subCtrl;
+    Remove();
+}
+
+int wxRibbonToggleable::GetActiveCommand( int group_id )
+{
+    for( unsigned int k=0; k < grouped_list.GetCount(); k++)
+    {
+        if(grouped_list[k]->m_group_id == group_id && grouped_list[k]->b_state)
+        {
+            return grouped_list[k]->id;
+        }
+    }
+    return wxID_ANY;
+}
+
+bool wxRibbonToggleable::SetActiveCommand( int group_id, int command )
+{
+    for( unsigned int k=0; k < grouped_list.GetCount(); k++)
+    {
+        int cgr = grouped_list[k]->m_group_id;
+        int cid = grouped_list[k]->id;
+        if( cgr == group_id && cid == command)
+        {
+            grouped_list[k]->Activate();
+            return true;
+        }
+    }
+    return false;
+}
+
+wxArrayRibbonToggleable wxRibbonToggleable::grouped_list;
+
+//////////////////////////////////////////////////////////////////////////
+wxWindow* wxGetBestParent( wxWindow* control, wxTypeIdentifier tid )
+{
+    wxWindow* topWindow = wxGetTopLevelParent(control);
+
+    wxWindow* prt = control->GetParent();
+    while(prt)
+    {
+        if(wxTypeId(*prt)==tid)
+        {
+            topWindow = prt;
+            break;
+        }
+        prt = prt->GetParent();
+    }
+    return topWindow;
+}
+
 #endif // wxUSE_RIBBON
Index: src/ribbon/panel.cpp
===================================================================
--- src/ribbon/panel.cpp	(revision 63959)
+++ src/ribbon/panel.cpp	(working copy)
@@ -31,6 +31,98 @@
 #include "wx/msw/private.h"
 #endif
 
+#include <wx/arrimpl.cpp> // This is a magic incantation which must be done!
+WX_DEFINE_OBJARRAY(wxArraySize);
+
+static int GetSizeInOrientation(wxSize size, wxOrientation orientation)
+{
+    switch(orientation)
+    {
+    case wxHORIZONTAL: return size.GetWidth();
+    case wxVERTICAL: return size.GetHeight();
+    case wxBOTH: return size.GetWidth() * size.GetHeight();
+    default: return 0;
+    }
+}
+
+//////////////////////////////////////////////////////////////////////////
+
+class wxRibbonPanelSeparator : public wxRibbonControl
+{
+public:
+    wxRibbonPanelSeparator(wxWindow* parent);
+    virtual ~wxRibbonPanelSeparator();
+    virtual wxSize GetMinSize() const;
+protected:
+    wxBorder GetDefaultBorder() const { return wxBORDER_NONE; }
+    wxSize GetMinNotMinimisedSize() const;
+
+    virtual wxSize DoGetNextSmallerSize(wxOrientation direction,
+        wxSize relative_to) const;
+    virtual wxSize DoGetNextLargerSize(wxOrientation direction,
+        wxSize relative_to) const;
+
+    void OnEraseBackground(wxEraseEvent& evt);
+    void OnPaint(wxPaintEvent& evt);
+
+#ifndef SWIG
+    DECLARE_CLASS(wxRibbonPanelSeparator)
+    DECLARE_EVENT_TABLE()
+#endif
+};
+
+IMPLEMENT_CLASS(wxRibbonPanelSeparator, wxRibbonControl)
+
+BEGIN_EVENT_TABLE(wxRibbonPanelSeparator, wxRibbonControl)
+    EVT_ERASE_BACKGROUND(wxRibbonPanelSeparator::OnEraseBackground)
+    EVT_PAINT(wxRibbonPanelSeparator::OnPaint)
+END_EVENT_TABLE()
+
+wxSize wxRibbonPanelSeparator::GetMinSize() const
+{
+    return wxSize(5,5);
+}
+
+void wxRibbonPanelSeparator::OnEraseBackground( wxEraseEvent& evt )
+{
+    // do nothing
+}
+
+void wxRibbonPanelSeparator::OnPaint( wxPaintEvent& evt )
+{
+    wxAutoBufferedPaintDC dc(this);
+    if(m_art != NULL)
+    {
+        m_art->DrawPanelSeparator(dc,this, (m_art->GetFlags() & wxRIBBON_BAR_FLOW_VERTICAL) ? wxVERTICAL : wxHORIZONTAL );
+    }
+}
+
+wxSize wxRibbonPanelSeparator::DoGetNextSmallerSize( wxOrientation direction, wxSize relative_to ) const
+{
+    return GetMinSize();
+}
+
+wxSize wxRibbonPanelSeparator::DoGetNextLargerSize( wxOrientation direction, wxSize relative_to ) const
+{
+    return GetMinSize();
+}
+
+wxSize wxRibbonPanelSeparator::GetMinNotMinimisedSize() const
+{
+    return GetMinSize();
+}
+
+wxRibbonPanelSeparator::wxRibbonPanelSeparator( wxWindow* parent )
+    : wxRibbonControl( parent, wxID_ANY )
+{
+    SetBackgroundStyle(wxBG_STYLE_CUSTOM);
+}
+
+wxRibbonPanelSeparator::~wxRibbonPanelSeparator()
+{
+
+}
+//////////////////////////////////////////////////////////////////////////
 IMPLEMENT_CLASS(wxRibbonPanel, wxRibbonControl)
 
 BEGIN_EVENT_TABLE(wxRibbonPanel, wxRibbonControl)
@@ -343,6 +435,43 @@
         }
     }
 
+    if(GetChildren().GetCount() > 1)
+    {
+        wxClientDC dc((wxRibbonPanel*) this);
+        wxSize child_relative = m_art->GetPanelClientSize(dc, this, relative_to, NULL);
+
+        wxArraySize dummy;
+        wxSize smaller = CalcNextSize(dummy,child_relative,direction,-1);
+        if(smaller == child_relative)
+        {
+            if(CanAutoMinimise())
+            {
+                wxSize minimised = m_minimised_size;
+                switch(direction)
+                {
+                case wxHORIZONTAL:
+                    minimised.SetHeight(relative_to.GetHeight());
+                    break;
+                case wxVERTICAL:
+                    minimised.SetWidth(relative_to.GetWidth());
+                    break;
+                default:
+                    break;
+                }
+                return minimised;
+            }
+            else
+            {
+                return relative_to;
+            }
+        }
+        else
+        {
+            wxClientDC dc((wxRibbonPanel*) this);
+            return m_art->GetPanelSize(dc, this, smaller, NULL);
+        }
+    }
+
     // Fallback: Decrease by 20% (or minimum size, whichever larger)
     wxSize current(relative_to);
     wxSize minimum(GetMinSize());
@@ -422,6 +551,24 @@
         }
     }
 
+    if(GetChildren().GetCount() > 1)
+    {
+        wxClientDC dc((wxRibbonPanel*) this);
+        wxSize child_relative = m_art->GetPanelClientSize(dc, this, relative_to, NULL);
+
+        wxArraySize dummy;
+        wxSize larger = CalcNextSize(dummy,child_relative,direction,1);
+        if(larger == child_relative)
+        {
+            return relative_to;
+        }
+        else
+        {
+            wxClientDC dc((wxRibbonPanel*) this);
+            return m_art->GetPanelSize(dc, this, larger, NULL);
+        }
+    }
+
     // Fallback: Increase by 25% (equal to a prior or subsequent 20% decrease)
     // Note that due to rounding errors, this increase may not exactly equal a
     // matching decrease - an ideal solution would not have these errors, but
@@ -477,6 +624,33 @@
         return m_art->GetPanelSize(dc, this, child->GetMinSize(), NULL);
     }
 
+    if(GetChildren().GetCount() > 1)
+    {
+        wxOrientation direction = GetMajorAxis();
+        wxSize min(0,0);
+
+        size_t k=0;
+        for ( wxWindowList::compatibility_iterator node = GetChildren().GetFirst();
+            node;
+            node = node->GetNext(), k++ )
+        {
+            wxRibbonControl* control = wxDynamicCast(node->GetData(), wxRibbonControl);
+            if(direction == wxHORIZONTAL)
+            {
+                min.x += control->GetMinSize().x;
+                min.y = wxMax(min.y,control->GetMinSize().y);
+            }
+            else
+            {
+                min.y += control->GetMinSize().y;
+                min.x = wxMax(min.x,control->GetMinSize().x);
+            }
+        }
+
+        wxClientDC dc((wxRibbonPanel*) this);
+        return m_art->GetPanelSize(dc, this, min, NULL);
+    }
+
     return wxRibbonControl::GetMinSize();
 }
 
@@ -492,6 +666,24 @@
         return m_art->GetPanelSize(dc, this, child->GetBestSize(), NULL);
     }
 
+    if(GetChildren().GetCount() > 1)
+    {
+        wxArraySize dummy;
+        wxSize best = CalcNextSize(dummy,wxSize(INT_MAX,INT_MAX),GetMajorAxis(),1);
+
+        if(GetMajorAxis()==wxHORIZONTAL)
+        {
+            best.y = 80;
+        }
+        else
+        {
+            best.x = 100;
+        }
+
+        wxClientDC dc((wxRibbonPanel*) this);
+        return m_art->GetPanelSize(dc, this, best, NULL);
+    }
+
     return wxRibbonControl::DoGetBestSize();
 }
 
@@ -521,6 +713,15 @@
         minimum_children_size = GetChildren().GetFirst()->GetData()->GetMinSize();
     }
 
+    wxArraySize dummy;
+
+    if(GetChildren().GetCount()>1)
+    {
+        minimum_children_size = CalcNextSize(dummy,wxSize(0,0),GetMajorAxis(),1);
+    }
+
+    prev_size = GetBestSize();
+
     if(m_art != NULL)
     {
         wxClientDC temp_dc(this);
@@ -588,6 +789,49 @@
         wxSize size = m_art->GetPanelClientSize(dc, this, GetSize(), &position);
         child->SetSize(position.x, position.y, size.GetWidth(), size.GetHeight());
     }
+
+    if(GetChildren().GetCount() > 1 )
+    {
+        wxClientDC dc(this);
+        wxPoint position, position1;
+        wxSize size = m_art->GetPanelClientSize(dc, this, GetSize(), &position);
+        wxSize size1 = m_art->GetPanelClientSize(dc, this, prev_size, &position1);
+
+        wxOrientation direction = GetMajorAxis();
+
+        int diff = GetSizeInOrientation( size - size1, direction );
+
+        if(diff==0)
+        {
+            wxArraySize stack;
+            CalcNextSize(stack, size,  direction,  0);
+            size_t k=0;
+            for ( wxWindowList::compatibility_iterator node = GetChildren().GetFirst();
+                node;
+                node = node->GetNext(), k++ )
+            {
+                wxRibbonControl* control = wxDynamicCast(node->GetData(), wxRibbonControl);
+                if(control == NULL)
+                {
+                    continue;
+                }
+
+                wxSize ChildSize = stack[k];
+                control->SetSize(position.x,position.y,ChildSize.GetWidth(),ChildSize.GetHeight());
+
+                if(direction == wxHORIZONTAL)
+                {
+                    position.x+=ChildSize.x;
+                }
+                else
+                {
+                    position.y+=ChildSize.y;
+                }
+            }
+        }
+    }
+    prev_size = GetSize();
+
     return true;
 }
 
@@ -902,4 +1146,126 @@
     return best;
 }
 
+wxOrientation wxRibbonPanel::GetMajorAxis() const
+{
+    if(m_art && (m_art->GetFlags() & wxRIBBON_BAR_FLOW_VERTICAL))
+    {
+        return wxVERTICAL;
+    }
+    else
+    {
+        return wxHORIZONTAL;
+    }
+}
+
+wxSize wxRibbonPanel::CalcNextSize( wxArraySize& stack, wxSize relative_to, wxOrientation direction, int diff /*= 0*/, bool minimal_size /*= false */ ) const
+{
+    wxSize best(0,0);
+    wxSize dummy;
+    wxWindowList::compatibility_iterator node;
+
+    int full_amount    = GetSizeInOrientation(relative_to,direction);
+    int curr_amount    = 0;
+    int sz_in_dir      = 0;
+    int pr_sz_in_dir   = 0;
+    int delta          = 0;
+    int best_delta, best_idx;
+    wxSize best_size;
+
+    stack.Clear();
+
+    for ( node = GetChildren().GetFirst(); node; node = node->GetNext())
+    {
+        wxRibbonControl* control = wxDynamicCast(node->GetData(), wxRibbonControl);
+        if(control == NULL)
+        {
+            continue;
+        }
+
+        dummy = control->GetMinSize();
+        if(direction==wxHORIZONTAL)
+        {
+            dummy.y = relative_to.y;
+        }
+        else
+        {
+            dummy.x = relative_to.x;
+        }
+
+        stack.Add(dummy);
+        sz_in_dir = GetSizeInOrientation(dummy,direction);
+
+        curr_amount+=sz_in_dir;
+    }
+
+    if(!minimal_size)
+    {
+        while(true)
+        {
+            best_delta = 0;
+            best_idx = -1;
+            int k = 0;
+
+            if( (diff>0 && curr_amount > full_amount) ||
+                (diff==0 && curr_amount == full_amount) )
+            {
+                break;
+            }
+
+            for ( node = GetChildren().GetFirst(); node; node = node->GetNext())
+            {
+
+                wxRibbonControl* control = wxDynamicCast(node->GetData(), wxRibbonControl);
+                if(control == NULL)
+                {
+                    continue;
+                }
+
+                dummy = control->GetNextLargerSize(direction, stack[k]);
+
+                pr_sz_in_dir = GetSizeInOrientation(stack[k],direction);
+                sz_in_dir = GetSizeInOrientation(dummy,direction);
+                delta = sz_in_dir - pr_sz_in_dir;
+
+                if( delta>0 && (delta<=best_delta || best_delta==0) )
+                {
+                    best_delta = delta;
+                    best_idx = k;
+                    best_size = dummy;
+                }
+
+                k++;
+            }
+
+            if(diff<0 && curr_amount+best_delta >= full_amount) 
+            {
+                break;
+            }
+
+            if(best_idx>-1)
+            {
+                curr_amount+=best_delta;
+                stack[best_idx] = best_size;
+            }
+            else
+            {
+               break;
+            }
+        }
+    }
+    if(direction==wxHORIZONTAL)
+    {
+        best = wxSize(curr_amount,relative_to.y);
+    }
+    else
+    {
+        best = wxSize(relative_to.x,curr_amount);
+    }
+    return best;
+}
+
+void wxRibbonPanel::AddSeparator()
+{
+    new wxRibbonPanelSeparator(this);
+}
 #endif // wxUSE_RIBBON
Index: src/ribbon/toolbar.cpp
===================================================================
--- src/ribbon/toolbar.cpp	(revision 63959)
+++ src/ribbon/toolbar.cpp	(working copy)
@@ -29,21 +29,6 @@
 #include "wx/msw/private.h"
 #endif
 
-class wxRibbonToolBarToolBase
-{
-public:
-    wxString help_string;
-    wxBitmap bitmap;
-    wxBitmap bitmap_disabled;
-    wxRect dropdown;
-    wxPoint position;
-    wxSize size;
-    wxObject* client_data;
-    int id;
-    wxRibbonButtonKind kind;
-    long state;
-};
-
 WX_DEFINE_ARRAY(wxRibbonToolBarToolBase*, wxArrayRibbonToolBarToolBase);
 
 class wxRibbonToolBarToolGroup
@@ -72,10 +57,12 @@
     EVT_MOTION(wxRibbonToolBar::OnMouseMove)
     EVT_PAINT(wxRibbonToolBar::OnPaint)
     EVT_SIZE(wxRibbonToolBar::OnSize)
+    EVT_MENU(wxID_ANY,wxRibbonToolBar::OnHotKey)
 END_EVENT_TABLE()
 
 wxRibbonToolBar::wxRibbonToolBar()
 {
+    enabled = true;
 }
 
 wxRibbonToolBar::wxRibbonToolBar(wxWindow* parent,
@@ -85,6 +72,7 @@
                   long style)
     : wxRibbonControl(parent, id, pos, size, wxBORDER_NONE)
 {
+    enabled = true;
     CommonInit(style);
 }
 
@@ -113,8 +101,51 @@
     m_sizes = new wxSize[1];
     m_sizes[0] = wxSize(0, 0);
     SetBackgroundStyle(wxBG_STYLE_CUSTOM);
+#ifdef wxUSE_ACCEL
+    wxWindow* bestParent = wxGetTopLevelParent(this);
+    if(bestParent)
+    {
+        bestParent->Connect(wxEVT_COMMAND_MENU_SELECTED, (wxObjectEventFunction)&wxRibbonToolBar::OnHotKey, NULL, this);
+    }
+#endif
 }
+void wxRibbonToolBar::OnHotKey(wxCommandEvent& evt)
+{
+    evt.Skip();
+#ifdef wxUSE_ACCEL
+    size_t group_count = m_groups.GetCount();
+    size_t g, t;
+    for(g = 0; g < group_count; ++g)
+    {
+        wxRibbonToolBarToolGroup* group = m_groups.Item(g);
+        size_t tool_count = group->tools.GetCount();
+        for(t = 0; t < tool_count; ++t)
+        {
+            wxRibbonToolBarToolBase* tool = group->tools.Item(t);
+            if(tool->id == evt.GetId()  )
+            {
+                if( enabled && !(tool->state & wxRIBBON_TOOLBAR_TOOL_DISABLED) )
+                {
+                    tool->Activate();
+                    wxGetBestParent(this,wxTypeId(wxRibbonPage))->Refresh();
 
+                    wxEventType evt_type = wxEVT_COMMAND_RIBBONTOOL_CLICKED;
+                    wxRibbonToolBarEvent notification(evt_type, tool->id);
+                    notification.SetEventObject(this);
+                    notification.SetBar(this);
+                    notification.SetExtraLong(tool->GetState());
+                    ProcessEvent(notification);
+                }
+
+                //if not .Skip event then GUI does not refresh (why?)
+                evt.SetId(wxID_ANY);
+                return;
+            }
+        }
+    }
+#endif
+}
+
 wxRibbonToolBar::~wxRibbonToolBar()
 {
     size_t count = m_groups.GetCount();
@@ -135,10 +166,10 @@
 }
 
 wxRibbonToolBarToolBase* wxRibbonToolBar::AddTool(
-                int tool_id,
-                const wxBitmap& bitmap,
-                const wxString& help_string,
-                wxRibbonButtonKind kind)
+            int tool_id,
+            const wxBitmap& bitmap,
+            const wxString& help_string,
+            wxRibbonButtonKind kind)
 {
     return AddTool(tool_id, bitmap, wxNullBitmap, help_string, kind, NULL);
 }
@@ -161,6 +192,19 @@
         wxRIBBON_BUTTON_HYBRID, NULL);
 }
 
+wxRibbonToolBarToolBase* wxRibbonToolBar::AddRadioTool(
+            int tool_id,
+            const wxBitmap& bitmap,
+            const wxString& help_string,
+            int group_id)
+{
+    wxASSERT_MSG( group_id!=0, "Zero-group is not allowed for AddRadioTool. Use AddTool instead" );
+    wxRibbonToolBarToolBase* tool = AddTool(tool_id, bitmap, wxNullBitmap, help_string,
+        wxRIBBON_BUTTON_NORMAL, NULL);
+    tool->SetGroup(group_id);
+    return tool;
+}
+
 wxRibbonToolBarToolBase* wxRibbonToolBar::AddTool(
             int tool_id,
             const wxBitmap& bitmap,
@@ -181,7 +225,11 @@
     }
     else
         tool->bitmap_disabled = MakeDisabledBitmap(bitmap);
+#ifdef wxUSE_ACCEL
+    tool->help_string = wxRibbonAccelerators::AddHotKey(this,tool_id,help_string,wxTypeId(this));
+#else
     tool->help_string = help_string;
+#endif
     tool->kind = kind;
     tool->client_data = client_data;
     tool->position = wxPoint(0, 0);
@@ -323,6 +371,32 @@
     return result;
 }
 
+void wxRibbonToolBar::EnableTool( int tool_id, bool enable /*= true*/ )
+{
+    size_t group_count = m_groups.GetCount();
+    size_t g, t;
+    for(g = 0; g < group_count; ++g)
+    {
+        wxRibbonToolBarToolGroup* group = m_groups.Item(g);
+        size_t tool_count = group->tools.GetCount();
+        for(t = 0; t < tool_count; ++t)
+        {
+            wxRibbonToolBarToolBase* tool = group->tools.Item(t);
+            if( tool->id == tool_id )
+            {
+                if(enable)
+                {
+                    tool->state = tool->state & ~wxRIBBON_TOOLBAR_TOOL_DISABLED;
+                }
+                else
+                {
+                    tool->state = tool->state | wxRIBBON_TOOLBAR_TOOL_DISABLED;
+                }
+            }
+        }
+    }
+}
+
 void wxRibbonToolBar::SetRows(int nMin, int nMax)
 {
     if(nMax == -1)
@@ -342,6 +416,12 @@
     Realize();
 }
 
+void wxRibbonToolBar::EnableBar( bool enable /* = true */ )
+{
+    enabled = enable;
+    Refresh();
+}
+
 bool wxRibbonToolBar::Realize()
 {
     if(m_art == NULL)
@@ -363,7 +443,7 @@
             tool->size = m_art->GetToolSize(temp_dc, this,
                 tool->bitmap.GetSize(), tool->kind, t == 0,
                 t == (tool_count - 1), &tool->dropdown);
-            tool->state = tool->state & ~wxRIBBON_TOOLBAR_TOOL_DISABLED;
+            //tool->state = tool->state & ~wxRIBBON_TOOLBAR_TOOL_DISABLED;
             if(t == 0)
                 tool->state |= wxRIBBON_TOOLBAR_TOOL_FIRST;
             if(t == tool_count - 1)
@@ -543,9 +623,17 @@
             for(t = 0; t < tool_count; ++t)
             {
                 wxRibbonToolBarToolBase* tool = group->tools.Item(t);
+                wxBitmap bitmap = tool->bitmap;
+                if(tool->state & wxRIBBON_TOOLBAR_TOOL_DISABLED || !enabled)
+                {
+                    bitmap = tool->bitmap_disabled;
+                }
                 wxRect rect(group->position + tool->position, tool->size);
-                m_art->DrawTool(dc, this, rect, tool->bitmap, tool->kind,
-                    tool->state);
+
+                int style = tool->state | (tool->GetState()?wxRIBBON_TOOLBAR_TOOL_ACTIVE_MASK:0);
+                if(!enabled) style = style & ~wxRIBBON_TOOLBAR_TOOL_ACTIVE_MASK & ~wxRIBBON_TOOLBAR_TOOL_HOVER_MASK;
+
+                m_art->DrawTool(dc, this, rect, bitmap, tool->kind, style);
             }
         }
     }
@@ -573,7 +661,9 @@
                     && tool->position.y <= pos.y && pos.y < tool->position.y + tool->size.y)
                 {
                     pos -= tool->position;
-                    new_hover = tool;
+                    //disabled tools does not reacts
+                    if(! (tool->state & wxRIBBON_TOOLBAR_TOOL_DISABLED) )
+                        new_hover = tool;
                     break;
                 }
             }
@@ -602,7 +692,12 @@
                 new_hover->state &= ~wxRIBBON_TOOLBAR_TOOL_ACTIVE_MASK;
                 new_hover->state |= (what << 2);
             }
+            if(enabled)((wxWindow*)this)->SetToolTip(new_hover->help_string);
         }
+        else
+        {
+            ((wxWindow*)this)->SetToolTip("");
+        }
         Refresh(false);
     }
     else if(m_hover_tool && m_hover_tool->kind == wxRIBBON_BUTTON_HYBRID)
@@ -649,21 +744,43 @@
 
 void wxRibbonToolBar::OnMouseUp(wxMouseEvent& WXUNUSED(evt))
 {
-    if(m_active_tool)
+    if(m_active_tool && enabled)
     {
+        m_active_tool->Activate();
         if(m_active_tool->state & wxRIBBON_TOOLBAR_TOOL_ACTIVE_MASK)
         {
             wxEventType evt_type = wxEVT_COMMAND_RIBBONTOOL_CLICKED;
             if(m_active_tool->state & wxRIBBON_TOOLBAR_TOOL_DROPDOWN_ACTIVE)
                 evt_type = wxEVT_COMMAND_RIBBONTOOL_DROPDOWN_CLICKED;
+
             wxRibbonToolBarEvent notification(evt_type, m_active_tool->id);
             notification.SetEventObject(this);
             notification.SetBar(this);
-            ProcessEvent(notification);
+            notification.SetExtraLong(m_active_tool->GetState());
+
+            if(evt_type == wxEVT_COMMAND_RIBBONTOOL_DROPDOWN_CLICKED 
+                && m_active_tool->m_subCtrl 
+                && wxTypeId( *m_active_tool->m_subCtrl ) == wxTypeId(wxMenu) )
+            {
+                notification.PopupMenu((wxMenu*)m_active_tool->m_subCtrl);
+            }
+            else
+            {
+                ProcessWindowEvent(notification);
+            }
         }
         m_active_tool->state &= ~wxRIBBON_TOOLBAR_TOOL_ACTIVE_MASK;
+
+        //if grouped buttons/tools then update ribbon page instead current control - may be somewhere on it we have same group's buttons/tools?
+        wxWindow* wnd = this;
+        if(m_active_tool->GetState())
+        {
+            wnd = wxGetBestParent(this,wxTypeId(wxRibbonPage));
+        }
+
         m_active_tool = NULL;
-        Refresh(false);
+
+        wnd->Refresh(false);
     }
 }
 
@@ -704,4 +821,26 @@
     return m_bar->PopupMenu(menu, pos);
 }
 
+wxRibbonToolBarToolBase* wxRibbonToolBarToolBase::AssignMenu( wxMenu* menu )
+{
+    if( this->kind == wxRIBBON_BUTTON_HYBRID || this->kind == wxRIBBON_BUTTON_DROPDOWN )
+    {
+        m_subCtrl = menu;
+    }
+    return this;
+}
+
+wxRibbonToolBarToolBase* wxRibbonToolBarToolBase::Enable( bool enable /*= true*/, wxWindow* parent /*= NULL*/ )
+{
+    if(enable)
+    {
+        state = state & ~wxRIBBON_TOOLBAR_TOOL_DISABLED;
+    }
+    else
+    {
+        state = state | wxRIBBON_TOOLBAR_TOOL_DISABLED;
+    }
+    if(parent) parent->Refresh();
+    return this;
+}
 #endif // wxUSE_RIBBON
