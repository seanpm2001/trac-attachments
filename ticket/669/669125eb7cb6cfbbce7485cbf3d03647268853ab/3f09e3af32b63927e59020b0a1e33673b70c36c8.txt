? .DSIndex: include/wx/mac/control.h
===================================================================
RCS file: /home/wxcvs/wxWindows/include/wx/mac/control.h,v
retrieving revision 1.8
diff -r1.8 control.h
55c55
<    
---
> 
72c72
<    virtual ControlHandle MacGetContainerForEmbedding() ;
---
>    virtual ControlHandle MacGetContainerForEmbedding() const;
78c78,79
<    virtual void  	 DoSetSize(int x, int y,int width, int height,int sizeFlags ) ;
---
>     virtual void DoMoveWindow(int x, int y, int width, int height);
> 
81c82
<    virtual void 	 OnPaint(wxPaintEvent& event) ;
---
>    void              OnRefreshWindow(wxMacRefreshEvent &event);
Index: include/wx/mac/dialog.h
===================================================================
RCS file: /home/wxcvs/wxWindows/include/wx/mac/dialog.h,v
retrieving revision 1.6
diff -r1.6 dialog.h
106a107
>     virtual void DoSetSize(int x, int y, int w, int h, int sizeFlags);
Index: include/wx/mac/frame.h
===================================================================
RCS file: /home/wxcvs/wxWindows/include/wx/mac/frame.h,v
retrieving revision 1.9
diff -r1.9 frame.h
73a74
>     virtual bool Show(bool show);
119a121
>     virtual void DoSetSize(int x, int y, int w, int h, int sizeFlags);
Index: include/wx/mac/region.h
===================================================================
RCS file: /home/wxcvs/wxWindows/include/wx/mac/region.h,v
retrieving revision 1.4
diff -r1.4 region.h
104a105
>     void Offset(wxCoord dx, wxCoord dy);
Index: include/wx/mac/window.h
===================================================================
RCS file: /home/wxcvs/wxWindows/include/wx/mac/window.h,v
retrieving revision 1.14
diff -r1.14 window.h
25c25
< 
---
> class WXDLLEXPORT wxMacRefreshEvent;
75a76,78
>     bool DestroyChildren();
> 
>     bool SetBackgroundColour(const wxColour &colour);
162c165
< 	void MacClientToRootWindow( int *x , int *y ) const ;
---
> 	void MacClientToRootWindow( int *x , int *y, bool clientObject ) const ;
166a170,201
>     // The following added by Mark Newsam
>   public:
>     // Sends areas to be updated to the OS which return as an update event
>     void MacSendUpdateForAreas(int oldx, int oldy, int oldw, int oldh,
>                                int newx, int newy, int neww, int newh);
> 
>     // Mac background themes
>     ThemeBrush MacGetTheme() const { return m_themeBackground; }
>     void MacSetTheme(ThemeBrush theme);
>     void MacSetupBackground() const;
> 
>     // Sets the update region ready for OnPaint events which use IsExposed
>     // it converts the region from mac coordinates to WX ones.
>     void SetUpdateRegion(const wxRegion &region);
> 
>     // The following obtain the region that the wxWindow occupies in
>     // Mac coordinates.
>     wxRegion wxWindow::GetMacWindowRegion() const;
>     wxRegion wxWindow::GetMacClientWindowRegion() const;
>     wxRegion wxWindow::GetMacClippedWindowRegion() const;
>     wxRegion wxWindow::GetMacClippedClientWindowRegion(bool clientObject) const;
> 
>     // Use this to set wxWindows that appear outside the client region eg.
>     // wxStatusBar and frame handled wxToolBar's
>     void SetThisToBorderObject() { m_inClientRegion = false; }
> 
>     // Setting up the port for drawing (used by wxMacPortDrawingHelper and DC)
>     void MacSetupPortForWX(const Rect &clipRect, WindowRef macWin);
>     void MacGetPortParamsForWX(Rect *clipRect, WindowRef *macWin, bool clientRegionOnly);
>     void MacGetPortParamsForDC(Point *origin, Rect *clip, WindowRef *macWin,
>                                bool clientRegionOnly);
>   public:
180a216
>     void OnRefreshWindow(wxMacRefreshEvent &event);
242c278
< 	virtual bool						MacDispatchMouseEvent(wxMouseEvent& event ) ;
---
> 	virtual bool						MacDispatchMouseEvent(wxMouseEvent& event, int x, int y);
249c285
< 	virtual ControlHandle 				MacGetContainerForEmbedding() ;
---
> 	virtual ControlHandle 				MacGetContainerForEmbedding() const;
278c314
< protected:
---
>   protected:
288a325,342
>     // The following variables added by Mark Newsam
>   protected:
>     // Real position of wxWindow from top left of the visible window
>     int  m_macx;
>     int  m_macy;
>   private:
>     // Is this window in the client region or the border eg. Frame handled
>     // toolbars
>     bool m_inClientRegion:1;
> 
>     ControlHandle  m_macPanel;
> 
>     // Use the appearance manager theme.  If the user wishes for a different
>     // background colour then this will be false.
>     bool m_useAppearanceTheme:1;
>     ThemeBrush m_themeBackground;
> 
>   protected:
344,357d397
< /*
< class wxMacFocusHelper
< {
< public :
< 	wxMacFocusHelper( wxWindow * theWindow ) ;
< 	~wxMacFocusHelper() ;
< 	bool Ok() { return m_ok ; }
< 
< private :
< 	GrafPtr 	m_formerPort ;
< 	GrafPtr		m_currentPort ;
< 	bool			m_ok ;
< } ;
< */
369c409
< 	PenState 	m_savedPenState ;
---
>     ThemeDrawingState  m_formerTheme;
372,378d411
< /*
< class wxMacFocusClientHelper
< {
< public :
< 	wxMacFocusClientHelper( wxWindow * theWindow ) ;
< 	~wxMacFocusClientHelper() ;
< 	bool Ok() { return m_ok ; }
380,385d412
< private :
< 	GrafPtr 	m_formerPort ;
< 	GrafPtr		m_currentPort ;
< 	bool			m_ok ;
< } ;
< */
396c423
< 	PenState 	m_savedPenState ;
---
>     ThemeDrawingState  m_formerTheme;
398a426,453
> 
> // Special event for updating windows on the Mac
> BEGIN_DECLARE_EVENT_TYPES()
>     DECLARE_EVENT_TYPE(wxEVT_MACREFRESH, 470)
>     END_DECLARE_EVENT_TYPES();
> 
> 
> class WXDLLEXPORT wxMacRefreshEvent: public wxEvent
> {
>     DECLARE_DYNAMIC_CLASS(wxMacRefreshEvent);
> 
>   public:
>     wxMacRefreshEvent(int Id = 0, wxRegion updatergn = NULL)
>     {
>         m_eventType = wxEVT_MACREFRESH;
>         m_id = Id;
>         m_updatergn = updatergn;
>     }
>     wxRegion m_updatergn;
> };
> 
> typedef void (wxEvtHandler::*wxMacRefreshEventFunction)(wxMacRefreshEvent&);
> 
> #define EVT_MACREFRESH(func)                                             \
>  DECLARE_EVENT_TABLE_ENTRY( wxEVT_MACREFRESH, -1, -1,                    \
>                             (wxObjectEventFunction) (wxEventFunction)    \
>                             (wxMacRefreshEventFunction) & func,          \
>                             (wxObject *) NULL ),
Index: src/mac/app.cpp
===================================================================
RCS file: /home/wxcvs/wxWindows/src/mac/app.cpp,v
retrieving revision 1.24
diff -r1.24 app.cpp
127a128
> 
1497,1511c1498,1526
< 	WindowRef window = (WindowRef) ev->message ;
< 	wxWindow * win = wxFindWinFromMacWindow( window ) ;
< 	if ( win )
< 	{
<         if ( !wxPendingDelete.Member(win) )
< 			win->MacUpdate( ev ) ;
< 	}
< 	else
< 	{
< 		// since there is no way of telling this foreign window to update itself
< 		// we have to invalidate the update region otherwise we keep getting the same
< 		// event over and over again
< 		BeginUpdate( window ) ;
< 		EndUpdate( window ) ;
< 	}
---
>     WindowRef window = (WindowRef) ev->message ;
>     wxWindow * win = wxFindWinFromMacWindow( window ) ;
> 
>     BeginUpdate( window );
>     if ( win )
>     {
>         RgnHandle region = NewRgn();
> 
>         if(region)
>         {
>             GetPortVisibleRegion(GetWindowPort( window ), region);
> 
>             // if windowshade gives incompatibility , take the follwing out
>             if ( !EmptyRgn( region ) )
>             {
> #ifndef TARGET_CARBON
>                 AGAPortHelper help( (window) ) ;
> #endif
>                 SetOrigin( 0 , 0 ) ;
>                 wxMacRefreshEvent event(win->GetId(), region);
>                 win->GetEventHandler()->ProcessEvent(event);
>             }
>         }
>         DisposeRgn(region);
>     }
>     /* If there is a foreign window that needs updating we invalidate the
>      * update region, otherwise this same event will keep repeating.
>      */
>     EndUpdate( window );
Index: src/mac/control.cpp
===================================================================
RCS file: /home/wxcvs/wxWindows/src/mac/control.cpp,v
retrieving revision 1.18
diff -r1.18 control.cpp
34a35
>     EVT_MACREFRESH(wxControl::OnRefreshWindow)
37d37
< 	EVT_PAINT( wxControl::OnPaint ) 
203c203
<   parent->AddChild((wxButton *)this);
---
>   parent->AddChild(this);
213,226c213,217
< 	m_width = size.x ;
< 	m_height = size.y ;
< 	int x = pos.x ;
< 	int y = pos.y ;
< 	AdjustForParentClientOrigin(x, y, wxSIZE_USE_EXISTING);
< 	m_x = x ;
< 	m_y = y ;
< 		
< 
< 	parent->MacClientToRootWindow( &x , &y ) ;
< 	outBounds->top = y + m_macVerticalBorder ;
< 	outBounds->left = x + m_macHorizontalBorder ;
< 	outBounds->bottom = outBounds->top + m_height - 2 * m_macVerticalBorder;
< 	outBounds->right = outBounds->left + m_width - 2 * m_macHorizontalBorder ;
---
>     // Temporary size for control, proper sizes set in MacPostControlCreate
>     outBounds->top  = 0;
>     outBounds->left = 0;
>     outBounds->bottom = 10;
>     outBounds->right = 10;
240a232,237
> 
>     // Store user position and size for mac post control create
>     m_x = pos.x;
>     m_y = pos.y;
>     m_width  = size.x;
>     m_height = size.y;
246c243,244
< 	
---
> 
> 	// Set up the controls font.  (This I think should be done in the controls ctor)
266a265
> 
271d269
< 	MacAdjustControlRect() ;
272a271,289
> 
>     // Adjust the controls size and position
>     AdjustForParentClientOrigin(m_x, m_y, wxSIZE_USE_EXISTING);
>     m_macx = m_x;
>     m_macy = m_y;
>     GetParent()->MacClientToRootWindow(&m_macx, &m_macy, true);
> 
>     wxSize best_size = DoGetBestSize();
> 
>     if (m_width == -1) {
>         m_width = best_size.x;
>     }
>     if (m_height == -1) {
>         m_height = best_size.y;
>     }
> 
>     UMAMoveControl(m_macControl, m_macx + m_macHorizontalBorder, m_macy + m_macVerticalBorder);
>     UMASizeControl(m_macControl,
>                    m_width - 2 * m_macHorizontalBorder, m_height - 2 * m_macVerticalBorder);
334c351
< ControlHandle wxControl::MacGetContainerForEmbedding() 
---
> ControlHandle wxControl::MacGetContainerForEmbedding() const
343a361
>     printf("wxControl::MacSuperChangedPosition  --  removed\n");
352c370
< 		GetParent()->MacClientToRootWindow( & mac_x , & mac_y ) ;
---
> 		GetParent()->MacClientToRootWindow( & mac_x , & mac_y, true ) ;
442,444c460
< void  wxControl::DoSetSize(int x, int y,
<             int width, int height,
<             int sizeFlags )
---
> void wxControl::DoMoveWindow(int x, int y, int w, int h)
446,545c462,479
< 	if ( m_macControl == NULL )
< 	{
< 		wxWindow::DoSetSize( x , y ,width , height ,sizeFlags ) ;
< 		return ;
< 	}
< 
< 	WindowRef rootwindow = GetMacRootWindow() ;
< 	wxWindow* wxrootwindow = wxFindWinFromMacWindow( rootwindow ) ;
< 	UMASetThemeWindowBackground( rootwindow , kThemeBrushDialogBackgroundActive , false ) ;
< 		
< 	int former_x = m_x ;
< 	int former_y = m_y ;
< 	int former_w = m_width ;
< 	int former_h = m_height ;
< 	
< 	Rect contrlRect ;		
< 	GetControlBounds( m_macControl , &contrlRect ) ; 
< 	int former_mac_x = contrlRect.left ;
< 	int former_mac_y = contrlRect.top ;
< 	
<   int currentX, currentY;
<   GetPosition(&currentX, &currentY);
<   int currentW,currentH;
<   GetSize(&currentW, &currentH);
< 
<   int actualWidth = width;
<   int actualHeight = height;
<   int actualX = x;
<   int actualY = y;
<   if (x == -1 && !(sizeFlags & wxSIZE_ALLOW_MINUS_ONE))
<       actualX = currentX;
<   if (y == -1 && !(sizeFlags & wxSIZE_ALLOW_MINUS_ONE))
<       actualY = currentY;
<   if (width == -1)
<       actualWidth = currentW ;
<   if (height == -1)
<       actualHeight = currentH ;
< 
< 	if ( actualX == currentX && actualY == currentY && actualWidth == currentW && actualHeight == currentH)
< 		return ;
< 		
< 	AdjustForParentClientOrigin(actualX, actualY, sizeFlags);
< 	WindowRef macrootwindow = GetMacRootWindow() ;
< 	wxMacDrawingHelper focus( wxFindWinFromMacWindow( macrootwindow ) ) ;
< 
< 	int mac_x = actualX ;
< 	int mac_y = actualY ;
< 	GetParent()->MacClientToRootWindow( & mac_x , & mac_y ) ;
< 	
< 	if ( mac_x != former_mac_x || mac_y != former_mac_y )
< 	{
< 		{
< 			Rect inval = { former_mac_y , former_mac_x , former_mac_y + m_height , former_mac_x + m_width } ;
< 			InvalWindowRect( macrootwindow, &inval ) ;
< 		}
<   		UMAMoveControl( m_macControl , mac_x + m_macHorizontalBorder , mac_y  + m_macVerticalBorder ) ;
< 		{
< 			Rect inval = { mac_y , mac_x , mac_y + m_height , mac_x + m_width } ;
< 			InvalWindowRect(macrootwindow, &inval ) ;
< 		}
< 	}
< 
< 	if ( actualX != former_x || actualY != former_y )
< 	{
< 		m_x = actualX ;
< 		m_y = actualY ;
< 
< 		MacRepositionScrollBars() ;
< 		// To consider -> should the parameters be the effective or the virtual coordinates (AdjustForParent..)
<     wxMoveEvent event(wxPoint(m_x, m_y), m_windowId);
<     event.SetEventObject(this);
<     GetEventHandler()->ProcessEvent(event);
< 	}		
< 	if ( actualWidth != former_w || actualHeight != former_h )
< 	{
< 		{
< 			Rect inval = { mac_y , mac_x , mac_y + former_h , mac_x + former_w } ;
< 			InvalWindowRect( macrootwindow, &inval ) ;
< 		}
< 		m_width = actualWidth ;
< 		m_height = actualHeight ;
< 
<    		UMASizeControl( m_macControl ,  m_width - 2 * m_macHorizontalBorder, m_height -  2 * m_macVerticalBorder ) ;
< 		{
< 			Rect inval = { mac_y , mac_x , mac_y + m_height , mac_x + m_width } ;
< 			InvalWindowRect( macrootwindow , &inval ) ;
< 		}
< 
< 		MacRepositionScrollBars() ;
<     wxSizeEvent event(wxSize(m_width, m_height), m_windowId);
<     event.SetEventObject(this);
<     GetEventHandler()->ProcessEvent(event);
< 	}
< 	if ( wxrootwindow->IsKindOf( CLASSINFO( wxDialog ) ) )
< 	{
< 	}
< 	else
< 	{
< 		UMASetThemeWindowBackground( rootwindow , kThemeBrushDocumentWindowBackground , false ) ;
< 	}
---
>     if(m_macControl == NULL) {
>         wxWindow::DoMoveWindow(x,y, w,h);
>         return;
>     }
>     m_x = x;
>     m_y = y;
>     m_width  = w;
>     m_height = h;
> 
>     /* My Apologies:  m_macx, m_macy is set in wxWindow::DoSetSize, as mac controls
>      * always use 0,0 of the root window m_macx, m_macy are already set
>      * to the correct values so I use them here.
>      */
>     UMAMoveControl(m_macControl,
>                    m_macx + m_macHorizontalBorder,
>                    m_macy + m_macVerticalBorder);
>     UMASizeControl( m_macControl, m_width - 2 * m_macHorizontalBorder,
>                     m_height - 2 * m_macVerticalBorder );
653a588,619
> /* The refresh event handler for a control.  This should only be called from
>  * the wxWindow::OnRefreshWindow and not called directly (For now).
>  */
> void wxControl::OnRefreshWindow(wxMacRefreshEvent &event)
> {
>     if( m_macControl )
>     {
>         UMADrawControl( m_macControl );
>     }
>     else
>     {
>         wxPaintEvent paint( GetId() );
>         GetEventHandler()->ProcessEvent(paint);
>     }
> 
>     wxNode   *node;
>     wxWindow *child;
>     for(node = GetChildren().First(); node; node = node->Next())
>     {
>         child = (wxWindow *) node->GetData();
> 
>         if(child->IsShown())
>         {
>             // Set the childs update region
>             //wxMacRefreshEvent(child->GetId(), winrgn);
>             child->SetUpdateRegion(child->GetMacWindowRegion());
>             child->GetEventHandler()->ProcessEvent(event);
>         }
>     }
> }
> 
> #if 0
698a665,666
> #endif
> 
736c704
< 		MacClientToRootWindow( &x , &y ) ;
---
> 		MacClientToRootWindow( &x , &y, true ) ;
Index: src/mac/dcclient.cpp
===================================================================
RCS file: /home/wxcvs/wxWindows/src/mac/dcclient.cpp,v
retrieving revision 1.9
diff -r1.9 dcclient.cpp
55c55
< 	the_canvas->MacGetPortParams(&m_macLocalOrigin, &m_macClipRect , &windowref , &rootwindow );
---
> 	the_canvas->MacGetPortParamsForDC(&m_macLocalOrigin, &m_macClipRect, &windowref, false );
83c83
< 	window->MacGetPortClientParams(&m_macLocalOrigin, &m_macClipRect , &windowref , &rootwindow );
---
> 	window->MacGetPortParamsForDC(&m_macLocalOrigin, &m_macClipRect, &windowref, true );
109d108
< 	wxWindow* rootwindow ;
111c110
< 	window->MacGetPortClientParams(&m_macLocalOrigin, &m_macClipRect , &windowref , &rootwindow );
---
> 	window->MacGetPortParamsForDC(&m_macLocalOrigin, &m_macClipRect, &windowref, true);
115c114
< 	/*
---
> #if 0
123c122
<   	*/
---
> #endif
IndexIndex: src/mac/dialog.cpp
===================================================================
RCS file: /home/wxcvs/wxWindows/src/mac/dialog.cpp,v
retrieving revision 1.10
diff -r1.10 dialog.cpp
142a143,217
> void wxDialog::DoSetSize( int x, int y, int width, int height, int sizeFlags )
> {
>     wxASSERT_MSG( (m_macWindowData != NULL), wxT("invalid dialog") );
> 
>     int old_x = m_x;
>     int old_y = m_y;
> 
>     int old_width = m_width;
>     int old_height = m_height;
> 
>     if (sizeFlags & wxSIZE_ALLOW_MINUS_ONE)
>     {
>         m_x      = x;
>         m_y      = y;
>         m_width  = width;
>         m_height = height;
>     }
>     else
>     {
>         if (x != -1)      m_x      = x;
>         if (y != -1)      m_y      = y;
>         if (width != -1)  m_width  = width;
>         if (height != -1) m_height = height;
>     }
> 
>     if(sizeFlags & wxSIZE_AUTO)
>     {
>         wxSize size = DoGetBestSize();
>         if (sizeFlags & wxSIZE_AUTO_WIDTH)
>         {
>             if (width == -1)   m_width = size.x;
>         }
>         if (sizeFlags & wxSIZE_AUTO_HEIGHT)
>         {
>             if (height == -1)   m_height = size.y;
>         }
>     }
> 
>     if((m_minWidth != -1) && (m_width < m_minWidth)) {
>         m_width = m_minWidth;
>     }
>     if((m_minHeight != -1) && (m_height < m_minHeight)) {
>         m_height = m_minHeight;
>     }
>     if((m_maxWidth != -1) && (m_width > m_maxWidth)) {
>         m_width = m_maxWidth;
>     }
>     if((m_maxHeight != -1) && (m_height > m_maxHeight)) {
>         m_height = m_maxHeight;
>     }
> 
>     if ((m_x != old_x) || (m_y != old_y))
>     {
>         ::MoveWindow(m_macWindowData->m_macWindow, m_x, m_y, false);
>         // (false) don't make frontmost on move
>     }
> 
>     if ((m_width != old_width) || (m_height != old_height))
>     {
>         ::SizeWindow(m_macWindowData->m_macWindow, m_width, m_height, true);
> 
>         // Need to refresh the dialog window
>         wxMacDrawingClientHelper focus( this );
>         wxCHECK_RET(focus.Ok(), wxT("Unable to set up mac drawing wxDialog"));
> 
>         MacSendUpdateForAreas(0,0, old_width, old_height,
>                               0,0, m_width, m_height);
> 
>         // Send resize event
>         wxSizeEvent event(wxSize(m_width, m_height), m_windowId);
>         event.SetEventObject(this);
>         GetEventHandler()->ProcessEvent(event);
>     }
> }
> 
178a254,264
> 
>         UMAShowWindow( m_macWindowData->m_macWindow ) ;
>         UMASelectWindow( m_macWindowData->m_macWindow ) ;
>         // no need to generate events here, they will get them triggered by
>         // macos actually they should be , but apparently they are not
>         wxSizeEvent event(wxSize(m_width, m_height), m_windowId);
>         event.SetEventObject(this);
>         GetEventHandler()->ProcessEvent(event);
>     }
>     else {
>         UMAHideWindow( m_macWindowData->m_macWindow );
Index: src/mac/frame.cpp
===================================================================
RCS file: /home/wxcvs/wxWindows/src/mac/frame.cpp,v
retrieving revision 1.16
diff -r1.16 frame.cpp
43a44,45
> #if wxUSE_STATUSBAR
> 
50c52,55
< #define WX_MAC_STATUSBAR_HEIGHT 15 
---
> #define WX_MAC_STATUSBAR_HEIGHT 15
> 
> #endif  // wxUSE_STATUSBAR
> 
61a67
> #if wxUSE_STATUSBAR
62a69
> #endif
147a155,177
> bool wxFrame::Show(bool show)
> {
>     wxCHECK_MSG(m_macWindowData, false, wxT("wxFrame::Show  Invalid frame"));
> 
>     if( !wxWindowBase::Show(show) ) {
>         return false;
>     }
> 
>     if(show)
>     {
>         UMAShowWindow( m_macWindowData->m_macWindow ) ;
>         UMASelectWindow( m_macWindowData->m_macWindow ) ;
>         // no need to generate events here, they will get them triggered by
>         // macos actually they should be , but apparently they are not
>         wxSizeEvent event(wxSize(m_width, m_height), m_windowId);
>         event.SetEventObject(this);
>         GetEventHandler()->ProcessEvent(event);
>     }
>     else {
>         UMAHideWindow( m_macWindowData->m_macWindow );
>     }
>     return true;
> }
197a228
> #if wxUSE_STATUSBAR
203,204c234
<     statusBar = new wxStatusBar(this, id,
<         style, name);
---
>     statusBar = new wxStatusBar(this, id, style, name);
213a244,245
>     m_frameStatusBar->SetThisToBorderObject();
> 
217a250,253
> #if wxUSE_TOOLBAR
>     if(GetToolBar())
>     {
>         int tw, th;
218a255,258
>         GetToolBar()->GetSize(&tw, &th);
>         h += th;
>     }
> #endif // wxUSE_TOOLBAR
223a264
> #endif  // wxUSE_STATUSBAR
243a285
> #if wxUSE_STATUSBAR
249a292
> #endif
309a353,434
> void wxFrame::DoSetSize(int x, int y, int width, int height, int sizeFlags)
> {
>     wxASSERT_MSG( (m_macWindowData != NULL), wxT("invalid frame") );
> 
>     int old_x = m_x;
>     int old_y = m_y;
> 
>     int old_width = m_width;
>     int old_height = m_height;
> 
>     if (sizeFlags & wxSIZE_ALLOW_MINUS_ONE)
>     {
>         m_x      = x;
>         m_y      = y;
>         m_width  = width;
>         m_height = height;
>     }
>     else
>     {
>         if (x != -1)      m_x      = x;
>         if (y != -1)      m_y      = y;
>         if (width != -1)  m_width  = width;
>         if (height != -1) m_height = height;
>     }
> 
>     if(sizeFlags & wxSIZE_AUTO)
>     {
>         wxSize size = DoGetBestSize();
>         if (sizeFlags & wxSIZE_AUTO_WIDTH)
>         {
>             if (width == -1)   m_width = size.x;
>         }
>         if (sizeFlags & wxSIZE_AUTO_HEIGHT)
>         {
>             if (height == -1)   m_height = size.y;
>         }
>     }
> 
>     if((m_minWidth != -1) && (m_width < m_minWidth)) {
>         m_width = m_minWidth;
>     }
>     if((m_minHeight != -1) && (m_height < m_minHeight)) {
>         m_height = m_minHeight;
>     }
>     if((m_maxWidth != -1) && (m_width > m_maxWidth)) {
>         m_width = m_maxWidth;
>     }
>     if((m_maxHeight != -1) && (m_height > m_maxHeight)) {
>         m_height = m_maxHeight;
>     }
> 
>     if ((m_x != old_x) || (m_y != old_y))
>     {
>         ::MoveWindow(m_macWindowData->m_macWindow, m_x, m_y, false);
>         // (false) don't make frontmost on move
>     }
> 
>     if ((m_width != old_width) || (m_height != old_height))
>     {
>         ::SizeWindow(m_macWindowData->m_macWindow, m_width, m_height, true);
> 
>         // Need to refresh this frame
>         wxMacDrawingClientHelper focus( this );
>         wxCHECK_RET(focus.Ok(), wxT("Unable to set up mac drawing wxFrame"));
> 
>         MacSendUpdateForAreas(0,0, old_width, old_height,
>                               0,0, m_width, m_height);
> 
>         // Send a resize event
>         wxSizeEvent event(wxSize(m_width, m_height), m_windowId);
>         event.SetEventObject(this);
>         GetEventHandler()->ProcessEvent(event);
> 
> #if wxUSE_STATUSBAR
>         PositionStatusBar();
> #endif
> #if wxUSE_TOOLBAR
>         PositionToolBar();
> #endif
>     }
> }
> 
364a490
> #if wxUSE_STATUSBAR
370a497
> #endif
373a501,502
>         GetToolBar()->SetThisToBorderObject();
> 
382c511
<             GetToolBar()->SetSize(-1, -1, tw, ch + 2 , wxSIZE_NO_ADJUSTMENTS | wxSIZE_ALLOW_MINUS_ONE );
---
>             GetToolBar()->SetSize(0, 0, tw, ch+2, wxSIZE_NO_ADJUSTMENTS | wxSIZE_ALLOW_MINUS_ONE);
387c516
<             GetToolBar()->SetSize(-1, -1, cw + 2, th, wxSIZE_NO_ADJUSTMENTS | wxSIZE_ALLOW_MINUS_ONE );
---
>             GetToolBar()->SetSize(0, 0, cw+2, th, wxSIZE_NO_ADJUSTMENTS | wxSIZE_ALLOW_MINUS_ONE);
Index: src/mac/region.cpp
===================================================================
RCS file: /home/wxcvs/wxWindows/src/mac/region.cpp,v
retrieving revision 1.5
diff -r1.5 region.cpp
231a232,239
> void wxRegion::Offset(wxCoord dx, wxCoord dy)
> {
>     if (m_refData)
>     {
>         ::OffsetRgn( M_REGION, dx, dy ) ;
>     }
> }
> 
Index: src/mac/toolbar.cpp
===================================================================
RCS file: /home/wxcvs/wxWindows/src/mac/toolbar.cpp,v
retrieving revision 1.15
diff -r1.15 toolbar.cpp
430c430
<     MacClientToRootWindow( &x , &y ) ;
---
>     MacClientToRootWindow( &x , &y, true ) ;
566c566
< 		MacClientToRootWindow( &x , &y ) ;
---
> 		MacClientToRootWindow( &x , &y, true ) ;
Index: src/mac/tooltip.cpp
===================================================================
RCS file: /home/wxcvs/wxWindows/src/mac/tooltip.cpp,v
retrieving revision 1.5
diff -r1.5 tooltip.cpp
155c155
< 				win->MacClientToRootWindow( &x, &y ) ;
---
> 				win->MacClientToRootWindow( &x, &y, true ) ;
Index: src/mac/window.cpp
===================================================================
RCS file: /home/wxcvs/wxWindows/src/mac/window.cpp,v
retrieving revision 1.35
diff -r1.35 window.cpp
60a61,62
> IMPLEMENT_DYNAMIC_CLASS(wxMacRefreshEvent, wxEvent)
> 
61a64
>   EVT_MACREFRESH(wxWindow::OnRefreshWindow)
71a75,76
> DEFINE_EVENT_TYPE(wxEVT_MACREFRESH)
> 
80a86,91
> 
> // Mac Pane callback routines
> static void DrawPaneBackground(ControlHandle pane, SInt16 part);
> static void PaneBackgroundCallback(ControlRef pane, ControlBackgroundPtr info);
> 
> 
106a118,148
> 
> // Find the wxWindow given the Macintosh ControlHandle Pane Reference
> 
> static wxList wxWinMacPaneList(wxKEY_INTEGER);
> 
> wxWindow *wxFindWXWindowFromMacPane(ControlHandle paneRef)
> {
>     wxNode *node = wxWinMacPaneList.Find((long)paneRef);
>     if (!node) {
>         return NULL;
>     }
>     return (wxWindow *)node->Data();
> }
> 
> void wxAssociateWXWindowWithMacPane(ControlHandle paneRef, wxWindow *win)
> {
>     // adding NULL Control surely a result of an error
>     wxCHECK_RET( paneRef != NULL,
>                  wxT("attempt to add a NULL WindowRef to window list") );
> 
>     if ( !wxWinMacPaneList.Find((long)paneRef) ) {
>         wxWinMacPaneList.Append((long)paneRef, win);
>     }
> }
> 
> void wxRemoveMacPaneAssociation(wxWindow *win)
> {
>     wxWinMacPaneList.DeleteObject(win);
> }
> 
> 
131a174,175
>     m_useAppearanceTheme = true;
>     m_themeBackground = kThemeBrushDialogBackgroundActive;
135a180
>     m_macPanel = NULL;
136a182
>     m_macUpdateRgn = NULL;
143a190,193
>     m_macx = m_macy = 0;
> 
>     m_inClientRegion = true;
> 
178a229,273
>     if(m_macPanel) {
>         wxRemoveMacPaneAssociation( this );
>         UMADisposeControl(m_macPanel);
>         m_macPanel = NULL;
>     }
> }
> 
> /* Modified to stop Destroy children from removing the ScrollBars unless called from the
>  * destructor */
> bool wxWindow::DestroyChildren()
> {
>     if(m_isBeingDeleted || (!m_hScrollBar && !m_vScrollBar)) {
>         return wxWindowBase::DestroyChildren();
>     }
> 
>     wxWindowList::Node *node;
>     size_t objectsToLeave = 0;
> 
>     if(m_hScrollBar) {
>         objectsToLeave++;
>     }
>     if(m_vScrollBar) {
>         objectsToLeave++;
>     }
> 
>     for(node = GetChildren().GetFirst(); node;  )
>     {
>         if(GetChildren().GetCount() == objectsToLeave) {
>             break;
>         }
>         wxWindow *child = node->GetData();
>         wxASSERT_MSG( child, wxT("children list contains empty nodes") );
> 
>         if(child == m_hScrollBar || child == m_vScrollBar) {
>             node = node->GetNext();
>             continue;
>         }
> 
>         delete child;
>         node = GetChildren().GetFirst();
> 
>         wxASSERT_MSG( !GetChildren().Find(child),
>                       wxT("child didn't remove itself using RemoveChild()") );
>     }
>     return true;
201,204c296,333
< 	if ( ! IsKindOf( CLASSINFO ( wxControl ) ) && ! IsKindOf( CLASSINFO( wxStatusBar ) ) )
< 	{
<     	MacCreateScrollBars( style ) ;
< 	}
---
>     // Set up the Mac x,y coords of this wxWindow
>     m_macx = m_x;
>     m_macy = m_y;
>     MacClientToRootWindow(&m_macx, &m_macy, m_inClientRegion);
> 
>     // Setup for the mac Pane, used to handle the background for all
>     // generic controls and panels
>     Rect bounds;
>     SetRect(&bounds, m_macy, m_macx, m_macy + m_height, m_macx + m_width);
>     m_macPanel = NewControl(parent->GetMacRootWindow(), &bounds, "\p", true,
>                             kControlSupportsEmbedding |
>                             kControlHasSpecialBackground,
>                             0, 0, kControlUserPaneProc, 0);
>     // Set up background callbacks to the panel
>     ControlUserPaneBackgroundUPP callback;
>     ControlUserPaneDrawUPP drawCallback;
>     Size callbackDataSize;
> 
>     // Get background colour callback
>     GetControlDataSize(m_macPanel, kControlEntireControl,
>                        kControlUserPaneBackgroundProcTag,
>                        &callbackDataSize);
>     callback = NewControlUserPaneBackgroundUPP(PaneBackgroundCallback);
>     SetControlData(m_macPanel, kControlEntireControl,
>                    kControlUserPaneBackgroundProcTag,
>                    callbackDataSize, &callback);
>     // Draw user pane background
>     GetControlDataSize(m_macPanel, kControlEntireControl,
>                        kControlUserPaneDrawProcTag, &callbackDataSize);
>     drawCallback = NewControlUserPaneDrawUPP(DrawPaneBackground);
>     SetControlData(m_macPanel, kControlEntireControl,
>                    kControlUserPaneDrawProcTag, callbackDataSize,
>                    &drawCallback);
> 
>     ControlHandle container = GetParent()->MacGetContainerForEmbedding() ;
>     wxASSERT_MSG( container != NULL , "No valid mac container control" ) ;
>     ::UMAEmbedControl( m_macPanel , container ) ;
>     wxAssociateWXWindowWithMacPane( m_macPanel, this );
316,317c445,446
<     *x = m_width ;
<     *y = m_height ;
---
>     if(x)  *x = m_width ;
>     if(y)  *y = m_height ;
322,323c451,453
<     *x = m_x ;
<     *y = m_y ;
---
>     if(x)  *x = m_x ;
>     if(y)  *y = m_y ;
> #if 0
329a460
> #endif
372c503
< 	MacClientToRootWindow( x , y ) ;
---
> 	MacClientToRootWindow( x , y, m_inClientRegion ) ;
388c519
< void wxWindow::MacClientToRootWindow( int *x , int *y ) const
---
> void wxWindow::MacClientToRootWindow( int *x , int *y, bool clientObject ) const
390,398c521,538
< 	if ( m_macWindowData )
< 	{
< 	}
< 	else
< 	{
< 		*x += m_x ;
< 		*y += m_y ;
< 		GetParent()->MacClientToRootWindow( x , y ) ;
< 	}
---
>     if ( m_macWindowData )
>     {
>         if(clientObject) {
>             wxPoint origin = GetClientAreaOrigin();
>             *x += origin.x;
>             *y += origin.y;
>         }
>     }
>     else
>     {
>         wxPoint origin;
>         if(clientObject) {
>             origin = GetClientAreaOrigin();
>         }
>         *x += m_x + origin.x;
>         *y += m_y + origin.y;
>         GetParent()->MacClientToRootWindow( x, y, m_inClientRegion ) ;
>     }
454,492c594,608
<     *x = m_width ;
<     *y = m_height ;
< 
< 	*x -= MacGetLeftBorderSize(  )  + MacGetRightBorderSize(  ) ;
< 	*y -= MacGetTopBorderSize(  ) + MacGetBottomBorderSize( );
< 	
<   if ( (m_vScrollBar && m_vScrollBar->IsShown()) || (m_hScrollBar  && m_hScrollBar->IsShown()) )
<   {
< 	int x1 = 0 ; 
< 	int y1 = 0 ;
< 	int w = m_width ;
< 	int h = m_height ;
< 	
< 	MacClientToRootWindow( &x1 , &y1 ) ;
< 	MacClientToRootWindow( &w , &h ) ;
< 	
< 	WindowRef window = NULL ;
< 	wxWindow *iter = (wxWindow*)this ;
< 	
< 	int totW = 10000 , totH = 10000;
< 	while( iter )
< 	{
< 		if ( iter->m_macWindowData )
< 		{
< 			totW = iter->m_width ;
< 			totH = iter->m_height ;
< 			break ;
< 		}
< 
< 		iter = iter->GetParent() ;
< 	} 
< 	
<   	if (m_hScrollBar  && m_hScrollBar->IsShown() )
<   	{
<   		(*y) -= MAC_SCROLLBAR_SIZE;
< 		if ( h-y1 >= totH )
< 		{
< 			(*y)+= 1 ;
< 		}
---
>     if(x)
>     {
>         *x = m_width;
>         *x -= MacGetLeftBorderSize() + MacGetRightBorderSize();
>         if( (m_vScrollBar && m_vScrollBar->IsShown()) ) {
>             *x -= MAC_SCROLLBAR_SIZE;
>         }
>     }
>     if(y)
>     {
>         *y = m_height ;
>         *y -= MacGetTopBorderSize()  + MacGetBottomBorderSize();
>         if( (m_hScrollBar && m_hScrollBar->IsShown()) ) {
>             *y -= MAC_SCROLLBAR_SIZE;
>         }
494,502d609
<   	if (m_vScrollBar  && m_vScrollBar->IsShown() )
<   	{
<     	(*x) -= MAC_SCROLLBAR_SIZE;
< 		if ( w-x1 >= totW )
< 		{
<     		(*x) += 1 ;
<     	}
<   	}
<   }
524c631,656
< 	DoSetSize( x,y, width, height ) ;
---
>     m_x = x;
>     m_y = y;
>     m_width = width;
>     m_height = height;
> 
>     if(m_macPanel)
>     {
>         UMAMoveControl(m_macPanel, m_macx, m_macy);
>         UMASizeControl(m_macPanel, width, height);
>         wxRegion winrgn = GetMacClippedWindowRegion();
> 
>         // Set up the internal update region (Mac use)
>         if(m_macUpdateRgn) {
>             DisposeRgn(m_macUpdateRgn);
>         }
>         m_macUpdateRgn = NewRgn();
>         CopyRgn(winrgn.GetWXHRGN(), m_macUpdateRgn);
>     }
> 
>     wxNode *node = GetChildren().First();
>     while ( node )
>     {
>         wxWindow *child = (wxWindow *)node->Data();
>         child->DoSetSize(-1,-1,-1,-1, wxSIZE_USE_EXISTING) ;
>         node = node->Next();
>     }
536a669,693
>     int new_x, new_y, new_width, new_height;
>     int old_x, old_y, old_width, old_height;
>     int mac_x, mac_y;
> 
>     old_x = m_macx;
>     old_y = m_macy;
>     new_x = m_x;
>     new_y = m_y;
>     new_width  = old_width  = m_width;
>     new_height = old_height = m_height;
> 
>     if (sizeFlags & wxSIZE_ALLOW_MINUS_ONE)
>     {
>         new_x      = x;
>         new_y      = y;
>         new_width  = width;
>         new_height = height;
>     }
>     else
>     {
>         if (x != -1)      new_x      = x;
>         if (y != -1)      new_y      = y;
>         if (width != -1)  new_width  = width;
>         if (height != -1) new_height = height;
>     }
538,566c695
< 	int former_x = m_x ;
< 	int former_y = m_y ;
< 	int former_w = m_width ;
< 	int former_h = m_height ;
< 	
<   int currentX, currentY;
<   GetPosition(&currentX, &currentY);
<   int currentW,currentH;
<   GetSize(&currentW, &currentH);
< 
<   int actualWidth = width;
<   int actualHeight = height;
<   int actualX = x;
<   int actualY = y;
<   if (x == -1 && !(sizeFlags & wxSIZE_ALLOW_MINUS_ONE))
<       actualX = currentX;
<   if (y == -1 && !(sizeFlags & wxSIZE_ALLOW_MINUS_ONE))
<       actualY = currentY;
<   
<   wxSize size( -1 , -1 ) ;
<   
<   if (width == -1 || height == -1 )
<   {
<   	size = DoGetBestSize() ;
<   }
<   
<   if ( width == -1 )
<   {
<   	if ( sizeFlags & wxSIZE_AUTO_WIDTH )
---
>     if(sizeFlags & wxSIZE_AUTO)
568,570c697,705
<       actualWidth = size.x ;	
<       if ( actualWidth == -1 )
<       	actualWidth = 80 ;
---
>         wxSize size = DoGetBestSize();
>         if (sizeFlags & wxSIZE_AUTO_WIDTH)
>         {
>             if (width == -1)   new_width = size.x;
>         }
>         if (sizeFlags & wxSIZE_AUTO_HEIGHT)
>         {
>             if (height == -1)   new_height = size.y;
>         }
572c707,717
<     else
---
> 
>     mac_x = new_x;
>     mac_y = new_y;
>     if(GetParent() && !m_macWindowData) {
>         GetParent()->MacClientToRootWindow(&mac_x, &mac_y, m_inClientRegion);
>     }
> 
>     bool doMove = false ;
>     bool doResize = false ;
> 
>     if ( mac_x != m_macx || mac_y != m_macy )
574c719,721
<       actualWidth = currentW ;
---
>         m_macx = mac_x;
>         m_macy = mac_y;
>         doMove = true ;
576,587c723,725
<   }
<   if (height == -1)
<   {
<   	if ( sizeFlags & wxSIZE_AUTO_HEIGHT )
<   	{
<   		actualHeight = size.y ;
<   		if ( actualHeight == -1 )
<   			actualHeight = 26 ;
<   	}
<   	else 
<   	{
<       actualHeight = currentH ;
---
>     if ( new_width != old_width || new_height != old_height )
>     {
>         doResize = true ;
589d726
<   }
591,603c728,742
<     if ((m_minWidth != -1) && (actualWidth < m_minWidth)) 
<     	actualWidth = m_minWidth;
<     if ((m_minHeight != -1) && (actualHeight < m_minHeight)) 
<     	actualHeight = m_minHeight;
<     if ((m_maxWidth != -1) && (actualWidth > m_maxWidth)) 
<     	actualWidth = m_maxWidth;
<     if ((m_maxHeight != -1) && (actualHeight > m_maxHeight)) 
<     	actualHeight = m_maxHeight;
< 	if ( actualX == currentX && actualY == currentY && actualWidth == currentW && actualHeight == currentH)
< 	{
< 		MacRepositionScrollBars() ; // we might have a real position shift
< 		return ;
< 	}
---
>     if ( doMove || doResize )
>     {
>         // Ensure resize is within constraints
>         if ((m_minWidth != -1) && (new_width < m_minWidth)) {
>             new_width = m_minWidth;
>         }
>         if ((m_minHeight != -1) && (new_height < m_minHeight)) {
>             new_height = m_minHeight;
>         }
>         if ((m_maxWidth != -1) && (new_width > m_maxWidth)) {
>             new_width = m_maxWidth;
>         }
>         if ((m_maxHeight != -1) && (new_height > m_maxHeight)) {
>             new_height = m_maxHeight;
>         }
605,618c744,745
< 	AdjustForParentClientOrigin(actualX, actualY, sizeFlags);
< 	
< 	
< 	bool doMove = false ;
< 	bool doResize = false ;
< 	
< 	if ( actualX != former_x || actualY != former_y )
< 	{
< 		doMove = true ;
< 	}
< 	if ( actualWidth != former_w || actualHeight != former_h )
< 	{
< 		doResize = true ;
< 	}
---
>         DoMoveWindow(new_x, new_y, new_width, new_height);
>         // DoMoveWindow sets m_x, m_y, m_width and m_height
620,689c747,766
< 	if ( doMove || doResize )
< 	{
< 		if ( m_macWindowData )
< 		{
< 		}
< 		else
< 		{
< 			// erase former position
< 			wxMacDrawingHelper focus( this ) ;
< 			if ( focus.Ok() )
< 			{
< 		  		Rect clientrect = { 0 , 0 , m_height , m_width } ;
< 				ClipRect( &clientrect ) ;
< 		    	InvalWindowRect( GetMacRootWindow() , &clientrect ) ;
< 			}
< 		}
< 		m_x = actualX ;
< 		m_y = actualY ;
< 		m_width = actualWidth ;
< 		m_height = actualHeight ;
< 		if ( m_macWindowData )
< 		{
< 			if ( doMove )
< 				::MoveWindow(m_macWindowData->m_macWindow, m_x, m_y  , false); // don't make frontmost
< 			
< 			if ( doResize )
< 				::SizeWindow(m_macWindowData->m_macWindow, m_width, m_height  , true); 
< 			
< 			// the OS takes care of invalidating and erasing the new area
< 			// we have erased the old one	
< 			
< 			if ( IsKindOf( CLASSINFO( wxFrame ) ) )
< 			{
< 				wxFrame* frame = (wxFrame*) this ;
< 			  	frame->PositionStatusBar();
<   				frame->PositionToolBar();
< 			}
< 		}
< 		else
< 		{
< 			// erase new position
< 			
< 			{
< 				wxMacDrawingHelper focus( this ) ;
< 				if ( focus.Ok() )
< 				{
< 			  		Rect clientrect = { 0 , 0 , m_height , m_width } ;
<   					ClipRect( &clientrect ) ;
< 			    	InvalWindowRect( GetMacRootWindow() , &clientrect ) ;
< 				}
< 			}
< 			
< 			if ( doMove )
< 				wxWindow::MacSuperChangedPosition() ; // like this only children will be notified
< 		}
< 		MacRepositionScrollBars() ;
< 		if ( doMove )
< 		{
<     		wxMoveEvent event(wxPoint(m_x, m_y), m_windowId);
<     		event.SetEventObject(this);
<     		GetEventHandler()->ProcessEvent(event) ;
<     	}
<     	if ( doResize )
<     	{
< 			MacRepositionScrollBars() ;
< 	    	wxSizeEvent event(wxSize(m_width, m_height), m_windowId);
< 	    	event.SetEventObject(this);
< 	    	GetEventHandler()->ProcessEvent(event);
<     	}
< 	}
---
>         // Update window at old and new positions
>         MacSendUpdateForAreas(old_x, old_y, old_height, old_width,
>                               m_macx, m_macy, m_width, m_height);
> 
>         if ( doMove )
>         {
>             wxMoveEvent event(wxPoint(m_x, m_y), m_windowId);
>             event.SetEventObject(this);
>             GetEventHandler()->ProcessEvent(event) ;
>         }
>         if ( doResize )
>         {
>             wxSizeEvent event(wxSize(m_width, m_height), m_windowId);
>             event.SetEventObject(this);
>             GetEventHandler()->ProcessEvent(event);
>         }
>     }
> 
>     // We might have a real position shift
>     MacRepositionScrollBars();
690a768,833
> 
> void wxWindow::MacSendUpdateForAreas(int oldx, int oldy, int oldw, int oldh,
>                                      int newx, int newy, int neww, int newh)
> {
>     wxMacDrawingClientHelper focus( this ) ;
>     if ( focus.Ok() )
>     {
>         WindowRef window = GetMacRootWindow();
>         Rect oldrefresh = { oldy, oldx, oldy + oldh, oldx + oldw };
>         Rect newrefresh = { newy, newx, newy + newh, newx + neww };
>         InvalWindowRect( window , &oldrefresh ) ;
>         InvalWindowRect( window , &newrefresh ) ;
>     }
> }
> 
> wxRegion wxWindow::GetMacWindowRegion() const
> {
>     return wxRegion(m_macx, m_macy, m_width, m_height);
> }
> 
> wxRegion wxWindow::GetMacClientWindowRegion() const
> {
>     int width, height;
>     wxPoint clientorigin = GetClientAreaOrigin();
> 
>     GetClientSize(&width, &height);
> 
>     return wxRegion(clientorigin.x + m_macx, clientorigin.y + m_macy, width, height);
> }
> 
> wxRegion wxWindow::GetMacClippedWindowRegion() const
> {
>     wxRegion region(m_macx, m_macy, m_width, m_height);
> 
>     if(GetParent() && !m_macWindowData) {
>         wxRegion parentrgn = GetParent()->GetMacClippedClientWindowRegion(m_inClientRegion);
>         region.Intersect(parentrgn);
>     }
>     return region;
> }
> 
> wxRegion wxWindow::GetMacClippedClientWindowRegion(bool clientObject) const
> {
>     wxRegion region;
>     if(clientObject) {
>         region = GetMacClientWindowRegion();
>     }
>     else {
>         region = GetMacWindowRegion();
>     }
> 
>     if(GetParent() && !m_macWindowData) {
>         wxRegion parentrgn = GetParent()->GetMacClippedClientWindowRegion(m_inClientRegion);
>         region.Intersect(parentrgn);
>     }
>     return region;
> }
> 
> // Sets the wx specific update region, also converts from Mac coordinates to wx
> void wxWindow::SetUpdateRegion(const wxRegion &region)
> {
>     wxRegion update(region.GetWXHRGN());
>     m_updateRegion = update;
>     m_updateRegion.Offset(-m_macx, -m_macy);
> }
> 
693d835
< 
735,736c877,879
<     if ( !wxWindowBase::Show(show) )
<         return FALSE;
---
>     if ( !wxWindowBase::Show(show) ) {
>         return false;
>     }
738,758c881,889
< 	if ( m_macWindowData )
< 	{
< 	  if (show)
< 	  {
< 	  	UMAShowWindow( m_macWindowData->m_macWindow ) ;
< 	  	UMASelectWindow( m_macWindowData->m_macWindow ) ;
< 		// no need to generate events here, they will get them triggered by macos
< 		// actually they should be , but apparently they are not
< 	    wxSizeEvent event(wxSize(m_width, m_height), m_windowId);
< 	    event.SetEventObject(this);
< 	    GetEventHandler()->ProcessEvent(event);
< 	  }
< 	  else
< 	  {
< 	  	UMAHideWindow( m_macWindowData->m_macWindow ) ;
< 	  }
< 	}
< 	MacSuperShown( show ) ;
< 	Refresh() ;
< 	if(m_macWindowData)
< 		MacUpdateImmediately() ;
---
>     if(m_macPanel)
>     {
>         if(show) {
>             UMAShowControl(m_macPanel);
>         }
>         else {
>             UMAHideControl(m_macPanel);
>         }
>     }
760c891,896
<     return TRUE;
---
>     // Refresh this window
>     wxRegion region = GetMacWindowRegion();
>     wxMacRefreshEvent refresh( GetId(), region);
>     GetEventHandler()->ProcessEvent(refresh);
> 
>     return true;
764a901
>     printf("wxWindow::MacSuperShown  --  removed\n");
900,904c1037,1038
< 	wxMacDrawingHelper focus( this ) ;
< 	if ( focus.Ok() )
< 	{
< 	  	Rect clientrect = { 0 , 0 , m_height , m_width } ;
<   		ClipRect( &clientrect ) ;
---
>     wxMacDrawingHelper focus(this);
>     wxCHECK_RET(focus.Ok(), wxT("wxWindow::Refresh drawing port problem"));
906,916c1040,1052
<     	if ( rect )
<     	{
<     		Rect r = { rect->y , rect->x , rect->y + rect->height , rect->x + rect->width } ;
< 			SectRect( &clientrect , &r , &clientrect ) ;    	
<     	}
<     	InvalWindowRect( GetMacRootWindow() , &clientrect ) ;
< 	}
< 	if ( !eraseBack )
< 		m_macEraseOnRedraw = false ;
< 	else
< 		m_macEraseOnRedraw = true ;
---
>     wxRegion refresh = GetMacWindowRegion();
> 
>     if(rect)
>     {
>         // Must convert from WX coords into mac coords.
>         wxRect temp = *rect;
>         temp.x += m_macx;
>         temp.y += m_macy;
> 
>         refresh.Intersect(temp);
>     }
>     wxMacRefreshEvent event( GetId(), refresh );
>     GetEventHandler()->ProcessEvent(event);
991a1128,1197
> void wxWindow::OnRefreshWindow(wxMacRefreshEvent &event)
> {
>     wxRegion winrgn = GetMacClippedWindowRegion();
> 
>     // If the updatergn is not NULL then test to see if this window
>     // overlaps before redrawing, otherwise redraw regardless
>     if(event.m_updatergn.IsEmpty() == false)
>     {
>         winrgn.Intersect(event.m_updatergn);
>         if(winrgn.IsEmpty()) {
>             return;
>         }
>     }
> 
>     // Set up for drawing in this window
>     wxMacDrawingHelper focus(this);
>     wxCHECK_RET(focus.Ok(), wxT("wxWindow::OnRefreshWindow port error\n"));
>     MacSetupBackground();
>     SetClip(winrgn.GetWXHRGN());
> 
>     // Send an erase event to clear the background
>     wxEraseEvent eraseevent( GetId() );
>     GetEventHandler()->ProcessEvent(eraseevent);
> 
>     if(IsShown() == false) {
>         return;
>     }
> 
>     // Update the window region eg. borders and scroll bars which are outside
>     // the client area
>     MacPaintBorders();
>     if(m_hScrollBar) {
>         m_hScrollBar->OnRefreshWindow(event);
>     }
>     if(m_vScrollBar) {
>         m_vScrollBar->OnRefreshWindow(event);
>     }
> 
>     // Now update the client region
>     wxRegion clientrgn = GetMacClippedClientWindowRegion(m_inClientRegion);
>     winrgn.Intersect(clientrgn);
> 
>     // Set the wxWindow update region
>     SetUpdateRegion(winrgn);
>     if(winrgn.IsEmpty()) {
>         return;
>     }
>     SetClip(winrgn.GetWXHRGN());
> 
>     wxNode   *node;
>     wxWindow *child;
> 
>     // Send a paint event to this wxWindow
>     wxPaintEvent paintevent( GetId() );
>     GetEventHandler()->ProcessEvent(paintevent);
> 
>     for(node = GetChildren().First(); node; node = node->Next())
>     {
>         child = (wxWindow *) node->GetData();
> 
>         if(child->IsShown())
>         {
>             // Set the childs update region
>             wxMacRefreshEvent(child->GetId(), winrgn);
>             child->SetUpdateRegion(child->GetMacWindowRegion());
>             child->GetEventHandler()->ProcessEvent(event);
>         }
>     }
> }
> 
994c1200,1202
<     // TODO : probably we would adopt the EraseEvent structure
---
>     wxRegion erase = GetMacWindowRegion();
> 
>     EraseRgn( erase.GetWXHRGN() ) ;
1171c1379
< 			Rect rect = { 0 , 0 , m_height , m_width } ;
---
> 			Rect rect = { m_macy, m_macx, m_macy + m_height, m_macx + m_width } ;
1176c1384
< 			Rect rect = { 1 , 1 , m_height -1 , m_width -1} ;
---
>             Rect rect = { m_macy + 1, m_macx + 1, m_macy + m_height - 1, m_macx + m_width - 1} ;
1181c1389
< 			Rect rect = { 0 , 0 , m_height -2 , m_width -2} ;
---
>             Rect rect = { m_macy, m_macx, m_macy + m_height - 2, m_macx + m_width - 2 } ;
1186,1189c1394,1397
<     		MoveTo( 0 , 0 ) ;
<     		LineTo( m_width - 3 , 0 ) ;
<     		MoveTo( 0 , 0 ) ;
<     		LineTo( 0 , m_height - 3 ) ;
---
>     		MoveTo( m_macx , m_macy ) ;
>     		LineTo( m_macx + m_width - 3 , m_macy ) ;
>     		MoveTo( m_macx , m_macy ) ;
>     		LineTo( m_macx , m_macy + m_height - 3 ) ;
1194c1402
< 		Rect rect = { 0 , 0 , m_height , m_width } ;
---
>         Rect rect = { m_macy, m_macx, m_macy + m_height, m_macx + m_width } ;
1198c1406
< /*
---
> #if 0
1260c1468
<  */
---
> #endif
1264,1265c1472
< void wxWindow::SetScrollbar(int orient, int pos, int thumbVisible,
<     int range, bool refresh)
---
> void wxWindow::SetScrollbar(int orient, int pos, int thumbVisible, int range, bool refresh)
1268a1476,1481
>             if ( m_hScrollBar == NULL )
>             {
>                 m_hScrollBar = new wxScrollBar(this, wxWINDOW_HSCROLL,
>                                                wxDefaultPosition, wxDefaultSize,
>                                                wxHORIZONTAL);
>             }
1286c1499,1505
< 			if ( m_vScrollBar )
---
>             if ( m_vScrollBar == NULL)
>             {
>                 m_vScrollBar = new wxScrollBar(this, wxWINDOW_VSCROLL,
>                                                wxDefaultPosition, wxDefaultSize,
>                                                wxVERTICAL);
>             }
>             if ( m_vScrollBar )
1307,1311c1526,1529
< 	wxMacDrawingClientHelper focus( this ) ;
< 	if ( focus.Ok() )
< 	{
<   		int width , height ;
<   		GetClientSize( &width , &height ) ;
---
>     wxMacDrawingClientHelper focus( this ) ;
>     if ( focus.Ok() )
>     {
>         int width, height;
1313,1339c1531,1560
< 		Rect scrollrect = { 0 , 0 , height , width } ;
<   	
<   		RgnHandle updateRgn = NewRgn() ;
<   		ClipRect( &scrollrect ) ;
<     	if ( rect )
<     	{
<     		Rect r = { rect->y , rect->x , rect->y + rect->height , rect->x + rect->width } ;
< 			SectRect( &scrollrect , &r , &scrollrect ) ;    	
<     	}
<    		ScrollRect( &scrollrect , dx , dy , updateRgn ) ;
<     	InvalWindowRgn( GetMacRootWindow() ,  updateRgn ) ;
<     	DisposeRgn( updateRgn ) ;
< 	}
< 	
< 	for (wxNode *node = GetChildren().First(); node; node = node->Next())
< 	{
< 		wxWindow *child = (wxWindow*)node->Data();
< 		if (child == m_vScrollBar) continue;
< 		if (child == m_hScrollBar) continue;
< 		if (child->IsTopLevel()) continue;
< 		int x,y;
< 		child->GetPosition( &x, &y );
< 		int w,h;
< 		child->GetSize( &w, &h );
< 		child->SetSize( x+dx, y+dy, w, h );
< 	}
< 	
---
>         GetClientSize( &width , &height ) ;
>         Rect scrollrect = { 0, 0, height, width };
> 
>         if ( rect )
>         {
>             Rect r = { rect->y, rect->x, rect->y + rect->height, rect->x + rect->width } ;
>             SectRect( &scrollrect , &r , &scrollrect ) ;
>         }
>         OffsetRect(&scrollrect, m_macx, m_macy);
> 
>         wxRegion updateRgn;
>         ScrollRect( &scrollrect , dx , dy , updateRgn.GetWXHRGN() ) ;
> 
>         for (wxNode *node = GetChildren().First(); node; node = node->Next())
>         {
>             wxWindow *child = (wxWindow*)node->Data();
>             if (child == m_vScrollBar) continue;
>             if (child == m_hScrollBar) continue;
>             if (child->IsTopLevel()) continue;
>             int x,y;
>             child->GetPosition( &x, &y );
>             int w,h;
>             child->GetSize( &w, &h );
>             child->SetSize( x+dx, y+dy, w, h );
>         }
>         wxRegion updateregion = GetMacClippedClientWindowRegion(m_inClientRegion);
>         wxMacRefreshEvent refresh(GetId(), updateregion);
>         GetEventHandler()->ProcessEvent(refresh);
>         wxMacDrawingClientHelper focus( this ) ;
>     }
1533,1534c1754,1755
< 	if ((point.x < m_x) || (point.y < m_y) ||
< 		(point.x > (m_x + m_width)) || (point.y > (m_y + m_height)))
---
> 	if ((point.x < m_macx) || (point.y < m_macy) ||
> 		(point.x > (m_macx + m_width)) || (point.y > (m_macy + m_height)))
1539,1543d1759
< 	wxPoint newPoint( point ) ;
< 
< 	newPoint.x -= m_x;
< 	newPoint.y -= m_y;
< 	
1548c1764
< 		if ( child->GetMacRootWindow() == window && child->m_isShown )
---
> 		if ( child->GetMacRootWindow() == window && child->IsShown() )
1550c1766
< 			if (child->MacGetWindowFromPointSub(newPoint , outWin ))
---
> 			if (child->MacGetWindowFromPointSub(point, outWin ))
1578c1794
< bool wxWindow::MacDispatchMouseEvent(wxMouseEvent& event)
---
> bool wxWindow::MacDispatchMouseEvent(wxMouseEvent &event, int x, int y)
1580,1581c1796
< 	if ((event.m_x < m_x) || (event.m_y < m_y) ||
< 		(event.m_x > (m_x + m_width)) || (event.m_y > (m_y + m_height)))
---
> 	if ((x < m_macx) || (y < m_macy) || (x > (m_macx + m_width)) || (y > (m_macy + m_height)))
1583d1797
< 	
1590,1595d1803
< 	event.m_x -= m_x;
< 	event.m_y -= m_y;
< 	
< 	int x = event.m_x ;
< 	int y = event.m_y ;
< 
1601c1809
< 			if (child->MacDispatchMouseEvent(event))
---
> 			if (child->MacDispatchMouseEvent(event, x, y)) {
1602a1811
>             }
1606,1607c1815,1816
< 	event.m_x = x ;
< 	event.m_y = y ;
---
>     event.m_x = x - m_macx;
>     event.m_y = y - m_macy;
1626a1836
> 
1628c1838,1839
< 	return TRUE;
---
> 
>     return TRUE;
1641a1853
> 
1702,1712c1914
< 	event.m_x += m_x;
< 	event.m_y += m_y;
< 
< /*
< 	wxPoint origin = GetClientAreaOrigin() ;
< 
< 	event.m_x += origin.x ;
< 	event.m_y += origin.y ;
< */
< 	
< 	event.m_timeStamp = ev->when;
---
>     event.m_timeStamp = ev->when;
1713a1916
> 
1733c1936
< 		MacDispatchMouseEvent( event ) ;
---
> 		MacDispatchMouseEvent( event, localwhere.h, localwhere.v ) ;
1766a1970
> 
1779a1984,1986
>     printf("wxWindow::MacRedraw  --  remove\n");
>     return;
> 
1920a2128,2130
>     printf("wxWindow::MacUpdateImmediately  -- remove\n");
>     return;
> 
2000,2034c2210
< 	wxASSERT_MSG( m_vScrollBar == NULL && m_hScrollBar == NULL , "attempt to create window twice" ) ;
< 	
< 	bool hasBoth = ( style & wxVSCROLL ) && ( style & wxHSCROLL ) ;
< 	int adjust = hasBoth ? MAC_SCROLLBAR_SIZE - 1: 0 ;
< 	int width, height ;
< 	GetClientSize( &width , &height ) ;
< 	
< 	wxPoint vPoint(width-MAC_SCROLLBAR_SIZE, 0) ;
< 	wxSize vSize(MAC_SCROLLBAR_SIZE, height - adjust) ;
< 	wxPoint hPoint(0 , height-MAC_SCROLLBAR_SIZE ) ;
< 	wxSize hSize( width - adjust, MAC_SCROLLBAR_SIZE) ;
< 	
< 	m_vScrollBar = new wxScrollBar(this, wxWINDOW_VSCROLL, vPoint, 
< 		vSize , wxVERTICAL);
< 
< 	if ( style & wxVSCROLL )
< 	{
< 		
< 	}
< 	else
< 	{
< 		m_vScrollBar->Show(false) ;
< 	}
< 	m_hScrollBar = new wxScrollBar(this, wxWINDOW_HSCROLL, hPoint, 
< 		hSize , wxHORIZONTAL);
< 	if ( style  & wxHSCROLL )
< 	{
< 	}
< 	else
< 	{
< 		m_hScrollBar->Show(false) ;
< 	}
< 	
< 	// because the create does not take into account the client area origin
< 	MacRepositionScrollBars() ; // we might have a real position shift
---
>     printf("wxWindow::MacCreateScrollBars  --  removed  min\n");
2060,2061c2236,2237
< 	MacClientToRootWindow( &x , &y ) ;
< 	MacClientToRootWindow( &w , &h ) ;
---
> 	MacClientToRootWindow( &x , &y, m_inClientRegion ) ;
> 	MacClientToRootWindow( &w , &h, m_inClientRegion ) ;
2123c2299
< ControlHandle wxWindow::MacGetContainerForEmbedding() 
---
> ControlHandle wxWindow::MacGetContainerForEmbedding() const
2125,2128c2301,2309
< 	if ( m_macWindowData )
< 		return m_macWindowData->m_macRootControl ;
< 	else
< 		return GetParent()->MacGetContainerForEmbedding() ;
---
>     if ( m_macWindowData ) {
>         return m_macWindowData->m_macRootControl ;
>     }
>     else if( m_macPanel ) {
>         return m_macPanel;
>     }
>     else {
>         return GetParent()->MacGetContainerForEmbedding() ;
>     }
2132a2314
>     printf("wxWindow::MacSuperChangedPosition  --  remove\n");
2143a2326,2435
> void wxWindow::MacSetupPortForWX(const Rect &clipRect, WindowRef macWin)
> {
>     wxCHECK_RET(macWin, wxT("MacSetPortForWX  Error NULL WindowRef used to set port"));
> 
>     GrafPtr currPort;
>     GrafPtr port ;
> 
>     ::GetPort(&currPort);
>     port = UMAGetWindowPort(macWin);
>     if( currPort != port ) {
>         ::SetPort(port);
>     }
> 
>     SetOrigin(0,0);
>     ClipRect(&clipRect);
> 
>     MacSetupBackground();
> }
> 
> void wxWindow::MacGetPortParamsForWX(Rect *clipRect, WindowRef *macWin, bool clientRegionOnly)
> {
>     Rect clipping;
>     wxWindow *parent;
>     int width, height;
>     wxPoint clientOrigin;
> 
>     if(clientRegionOnly) {
>         GetClientSize(&width, &height);
>         clientOrigin = GetClientAreaOrigin();
>     }
>     else {
>         width = m_width;
>         height = m_height;
>     }
>     if(!m_macWindowData) {
>         clientOrigin.x += m_macx;
>         clientOrigin.y += m_macy;
>     }
> 
>     *macWin = GetMacRootWindow();
> 
>     clipRect->left   = clientOrigin.x;
>     clipRect->top    = clientOrigin.y;
>     clipRect->right  = clientOrigin.x + width;
>     clipRect->bottom = clientOrigin.y + height;
> 
>     // Now clip to ensure within parent region
>     for(parent = GetParent(); parent && !parent->m_macWindowData; parent = parent->GetParent())
>     {
>         parent->GetClientSize(&width, &height);
>         clientOrigin = parent->GetClientAreaOrigin();
> 
>         clipping.left   = clientOrigin.x + parent->m_macx;
>         clipping.top    = clientOrigin.y + parent->m_macy;
>         clipping.right  = clientOrigin.x + parent->m_macx + width;
>         clipping.bottom = clientOrigin.y + parent->m_macy + height;
> 
>         SectRect(&clipping, clipRect, clipRect);
>     }
> }
> 
> void wxWindow::MacGetPortParamsForDC(Point *origin, Rect *clip, WindowRef *macWin,
>                                      bool clientRegionOnly)
> {
>     Rect clipping;
>     wxWindow *parent;
>     int width, height;
>     wxPoint clientOrigin;
> 
>     if(clientRegionOnly) {
>         GetClientSize(&width, &height);
>         clientOrigin = GetClientAreaOrigin();
>     }
>     else {
>         width = m_width;
>         height = m_height;
>     }
>     if(!m_macWindowData) {
>         clientOrigin.x += m_macx;
>         clientOrigin.y += m_macy;
>     }
> 
>     *macWin = GetMacRootWindow();
> 
>     origin->h = clientOrigin.x;
>     origin->v = clientOrigin.y;
> 
>     clip->left   = clientOrigin.x;
>     clip->top    = clientOrigin.y;
>     clip->right  = clientOrigin.x + width;
>     clip->bottom = clientOrigin.y + height;
> 
>     // Now clip to ensure within parent region
>     for(parent = GetParent(); parent && !parent->m_macWindowData; parent = parent->GetParent())
>     {
>         parent->GetClientSize(&width, &height);
>         clientOrigin = parent->GetClientAreaOrigin();
> 
>         clipping.left   = clientOrigin.x + parent->m_macx;
>         clipping.top    = clientOrigin.y + parent->m_macy;
>         clipping.right  = clientOrigin.x + parent->m_macx + width;
>         clipping.bottom = clientOrigin.y + parent->m_macy + height;
> 
>         SectRect(&clipping, clip, clip);
>     }
> 
>     // Off set clipping region to match new origin
>     OffsetRect(clip, -origin->h, -origin->v);
> }
> 
2163a2456
>     printf("wxWindow::MacSetPortDrawingParams  --  remove\n");
2188a2482
>     printf("wxWindow::MacGetPortParams  --  remove\n");
2218a2513
>     printf("wxWindow::MacDoGetPortClientParams  --  remove\n");
2253a2549
>     printf("wxWindow::MacGetPortClientParams  --  remove\n");
2358a2655,2747
> /* NB!  The following routine for obtaining the wxWindow from a ControlHandle
>  * will only work with Panes which have there own seperate list.
>  */
> 
> static ControlRef s_previousMAC = NULL;
> static wxWindow *s_previousWX = NULL;
> 
> static wxWindow *GetWXWindowFromControlHandle(ControlHandle control)
> {
>     if(control == s_previousMAC) {
>         return s_previousWX;
>     }
>     else
>     {
>         wxWindow *pane = wxFindWXWindowFromMacPane(control);
>         if(pane) {
>             s_previousMAC = control;
>             s_previousWX  = pane;
> 
>             return pane;
>         }
>         else {
>             printf("Can't find wxWindow for ControlHandle\n");
>             return NULL;
>         }
>     }
> }
> 
> static void PaneBackgroundCallback(ControlRef pane, ControlBackgroundPtr info)
> {
>     wxWindow *control = GetWXWindowFromControlHandle(pane);
> 
>     if(control) {
>         control->MacSetupBackground();
>     }
> }
> 
> static void DrawPaneBackground(ControlHandle pane, SInt16 part)
> {
>     wxWindow *panel = GetWXWindowFromControlHandle(pane);
> 
>     if(panel)
>     {
>         panel->MacSetupBackground();
> 
>         // Set the update region for the paint event
>         panel->SetUpdateRegion(panel->GetMacClippedWindowRegion());
> 
>         // First send erase event to clear background
>         wxEraseEvent erase( panel->GetId() );
>         panel->GetEventHandler()->ProcessEvent(erase);
> 
>         // Now send a paint event NB.  Mac controls are handled by the Mac
>         wxPaintEvent paint( panel->GetId() );
>         panel->GetEventHandler()->ProcessEvent(paint);
> 
>         panel->MacPaintBorders();
>     }
> }
> 
> bool wxWindow::SetBackgroundColour(const wxColour &colour)
> {
>     if(wxWindowBase::SetBackgroundColour(colour))
>     {
>         m_useAppearanceTheme = false;
>         return true;
>     }
>     return false;
> }
> 
> void wxWindow::MacSetupBackground() const
> {
>     if(m_useAppearanceTheme) {
>         ::UMASetThemeWindowBackground(GetMacRootWindow(), MacGetTheme(), false);
>     }
>     else
>     {
>         Pattern whiteColor;
>         RGBColor fore = GetForegroundColour().GetPixel();
>         RGBColor back = GetBackgroundColour().GetPixel();
> 
>         ::PenNormal() ;
>         ::RGBBackColor( &back );
>         ::RGBForeColor( &fore );
>         ::BackPat( GetQDGlobalsWhite( &whiteColor) ) ;
>     }
>     if(m_macUpdateRgn) {
>         SetOrigin(0,0);
>         SetClip(m_macUpdateRgn);
>     }
> }
> 
> 
2362d2750
< 	Point localOrigin ;
2365d2752
< 	wxWindow *rootwin ;
2371,2377c2758,2763
< 		theWindow->MacGetPortParams( &localOrigin , &clipRect , &window , &rootwin) ;
< 		m_currentPort = UMAGetWindowPort( window ) ;
< 		if ( m_formerPort != m_currentPort )
< 			SetPort( m_currentPort ) ;
< 		GetPenState( &m_savedPenState ) ;
< 		theWindow->MacSetPortDrawingParams( localOrigin, clipRect, window , rootwin ) ; 
< 		m_ok = true ;
---
>         theWindow->MacGetPortParamsForWX(&clipRect, &window, false);
>         m_currentPort = UMAGetWindowPort( window ) ;
>         GetThemeDrawingState( &m_formerTheme );
> 
>         theWindow->MacSetupPortForWX(clipRect, window);
>         m_ok = true ;
2386c2772
< 		SetPenState( &m_savedPenState ) ;
---
>         SetThemeDrawingState( m_formerTheme, true );
2392,2393c2778,2779
< 		
< 	if ( m_formerPort != m_currentPort )
---
> 
> 	if ( m_formerPort != m_currentPort ) {
2394a2781
>     }
2400d2786
< 	Point localOrigin ;
2403d2788
< 	wxWindow *rootwin ;
2407d2791
< 
2410,2416c2794,2799
< 		theWindow->MacGetPortClientParams( &localOrigin , &clipRect , &window , &rootwin) ;
< 		m_currentPort = UMAGetWindowPort( window ) ;
< 		if ( m_formerPort != m_currentPort )
< 			SetPort( m_currentPort ) ;
< 		GetPenState( &m_savedPenState ) ;
< 		theWindow->MacSetPortDrawingParams( localOrigin, clipRect, window , rootwin ) ; 
< 		m_ok = true ;
---
>         theWindow->MacGetPortParamsForWX(&clipRect, &window, true);
>         m_currentPort = UMAGetWindowPort( window ) ;
>         GetThemeDrawingState( &m_formerTheme );
> 
>         theWindow->MacSetupPortForWX(clipRect, window);
>         m_ok = true ;
2425c2808
< 		SetPenState( &m_savedPenState ) ;
---
>         SetThemeDrawingState( m_formerTheme, true );
2431,2432c2814,2815
< 		
< 	if ( m_formerPort != m_currentPort )
---
> 
> 	if ( m_formerPort != m_currentPort ) {
2433a2817
>     }

 	  	 
