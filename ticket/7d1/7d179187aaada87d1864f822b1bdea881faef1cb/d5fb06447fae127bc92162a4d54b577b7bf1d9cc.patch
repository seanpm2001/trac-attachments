Index: include/wx/vscroll.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/include/wx/vscroll.h,v
retrieving revision 1.22
diff -u -r1.22 vscroll.h
--- include/wx/vscroll.h	2006/04/26 00:17:49	1.22
+++ include/wx/vscroll.h	2006/05/15 21:36:52
@@ -1,10 +1,10 @@
 /////////////////////////////////////////////////////////////////////////////
 // Name:        include/wx/vscroll.h
-// Purpose:     wxVScrolledWindow: generalization of wxScrolledWindow
+// Purpose:     Variable scrolled windows (wx[V/H/HV]ScrolledWindow
 // Author:      Vadim Zeitlin
-// Modified by:
+// Modified by: Brad Anderson
 // Created:     30.05.03
-// RCS-ID:      $Id: vscroll.h,v 1.22 2006/04/26 00:17:49 VZ Exp $
+// RCS-ID:      $Id: vscroll.h,v 1.19 2006/02/15 09:59:32 RR Exp $
 // Copyright:   (c) 2003 Vadim Zeitlin <vadim@wxwidgets.org>
 // Licence:     wxWindows licence
 /////////////////////////////////////////////////////////////////////////////
@@ -14,71 +14,32 @@
 
 #include "wx/panel.h"           // base class
 
-// ----------------------------------------------------------------------------
-// wxVScrolledWindow
-// ----------------------------------------------------------------------------
+class WXDLLEXPORT wxVarScrollHelperEvtHandler;
 
-/*
-   In the name of this class, "V" may stand for "variable" because it can be
-   used for scrolling lines of variable heights; "virtual" because it is not
-   necessary to know the heights of all lines in advance -- only those which
-   are shown on the screen need to be measured; or, even, "vertical" because
-   this class only supports scrolling in one direction currently (this could
-   and probably will change in the future however).
 
-   In any case, this is a generalization of the wxScrolledWindow class which
-   can be only used when all lines have the same height. It lacks some other
-   wxScrolledWindow features however, notably it currently lacks support for
-   horizontal scrolling; it can't scroll another window nor only a rectangle
-   of the window and not its entire client area.
- */
-class WXDLLEXPORT wxVScrolledWindow : public wxPanel
+class WXDLLEXPORT wxVarScrollHelperBase
 {
 public:
     // constructors and such
     // ---------------------
-
-    // default ctor, you must call Create() later
-    wxVScrolledWindow() { Init(); }
-
-    // normal ctor, no need to call Create() after this one
-    //
-    // note that wxVSCROLL is always automatically added to our style, there is
-    // no need to specify it explicitly
-    wxVScrolledWindow(wxWindow *parent,
-                      wxWindowID id = wxID_ANY,
-                      const wxPoint& pos = wxDefaultPosition,
-                      const wxSize& size = wxDefaultSize,
-                      long style = 0,
-                      const wxString& name = wxPanelNameStr)
-    {
-        Init();
 
-        (void)Create(parent, id, pos, size, style, name);
-    }
+    wxVarScrollHelperBase(wxWindow *winToScroll);
+    virtual ~wxVarScrollHelperBase();
 
-    // same as the previous ctor but returns status code: true if ok
-    //
-    // just as with the ctor above, wxVSCROLL style is always used, there is no
-    // need to specify it
-    bool Create(wxWindow *parent,
-                wxWindowID id = wxID_ANY,
-                const wxPoint& pos = wxDefaultPosition,
-                const wxSize& size = wxDefaultSize,
-                long style = 0,
-                const wxString& name = wxPanelNameStr)
-    {
-        return wxPanel::Create(parent, id, pos, size, style | wxVSCROLL, name);
-    }
-
 
     // operations
     // ----------
 
-    // set the number of lines the window contains: the derived class must
-    // provide the heights for all lines with indices up to the one given here
-    // in its OnGetLineHeight()
-    void SetLineCount(size_t count);
+    // set the number of lines the helper contains: the derived class must
+    // provide the sizes for all lines with indices up to the one given here
+    // in its OnGetLineSize()
+    void SetLineCount(size_t lineCount);
+
+    // with physical scrolling on, the device origin is changed properly when
+    // a wxPaintDC is prepared, children are actually moved and layed out
+    // properly, and the contents of the window (pixels) are actually moved
+    void EnablePhysicalScrolling(bool scrolling = true)
+        { m_physicalScrolling = scrolling; }
 
     // scroll to the specified line: it will become the first visible line in
     // the window
@@ -87,8 +48,8 @@
     bool ScrollToLine(size_t line);
 
     // scroll by the specified number of lines/pages
-    virtual bool ScrollLines(int lines);
-    virtual bool ScrollPages(int pages);
+    virtual bool ScrollLines(int rows);
+    virtual bool ScrollLinePages(int pages);
 
     // redraw the specified line
     virtual void RefreshLine(size_t line);
@@ -96,59 +57,102 @@
     // redraw all lines in the specified range (inclusive)
     virtual void RefreshLines(size_t from, size_t to);
 
-    // return the item at the specified (in physical coordinates) position or.
-
     // wxNOT_FOUND if none, i.e. if it is below the last item
-    int HitTest(wxCoord x, wxCoord y) const;
-    int HitTest(const wxPoint& pt) const { return HitTest(pt.x, pt.y); }
+    virtual int HitTest(wxCoord coord) const;
 
     // recalculate all our parameters and redisplay all lines
     virtual void RefreshAll();
 
-
     // accessors
     // ---------
 
     // get the number of lines this window contains (previously set by
     // SetLineCount())
     size_t GetLineCount() const { return m_lineMax; }
-
+    
     // get the first currently visible line
     size_t GetVisibleBegin() const { return m_lineFirst; }
 
-    // get the first currently visible line
-    size_t GetVisibleEnd() const { return m_lineFirst + m_nVisible; }
+    // get the last currently visible line
+    size_t GetVisibleEnd() const
+        { return m_lineFirst + m_nLinesVisible; }
 
     // is this line currently visible?
     bool IsVisible(size_t line) const
-        { return line >= GetVisibleBegin() && line < GetVisibleEnd(); }
+        { return line >= m_lineFirst &&
+                 line < GetVisibleEnd(); }
 
+    // translate between scrolled and unscrolled coordinates
+    int CalcScrolledPosition(int coord) const
+        {  return DoCalcScrolledPosition(coord); }
+    int CalcUnscrolledPosition(int coord) const
+        {  return DoCalcUnscrolledPosition(coord); }
 
-    // this is the same as GetVisibleBegin(), exists to match
-    // GetLastVisibleLine() and for backwards compatibility only
-    size_t GetFirstVisibleLine() const { return m_lineFirst; }
+    virtual int DoCalcScrolledPosition(int coord) const;
+    virtual int DoCalcUnscrolledPosition(int coord) const;
 
-    // get the last currently visible line
+    // update the thumb size shown by the scrollbar
+    virtual void UpdateScrollbar();
+    void RemoveScrollbar();
+
+    // Normally the wxScrolledWindow will scroll itself, but in some rare
+    // occasions you might want it to scroll [part of] another window (e.g. a
+    // child of it in order to scroll only a portion the area between the
+    // scrollbars (spreadsheet: only cell area will move).
+    virtual void SetTargetWindow(wxWindow *target);
+    virtual wxWindow *GetTargetWindow() const { return m_targetWindow; }
+
+    // Override this function to draw the graphic (or just process EVT_PAINT)
+    //virtual void OnDraw(wxDC& WXUNUSED(dc)) { }
+
+    // change the DC origin according to the scroll position. To properly
+    // forward calls to wxWindow::Layout use WX_FORWARD_TO_SCROLL_HELPER()
+    // derived class
+    virtual void DoPrepareDC(wxDC& dc);
+
+
+    // are we generating the autoscroll events?
+    bool IsAutoScrolling() const { return m_timerAutoScroll != NULL; }
+
+    // stop generating the scroll events when mouse is held outside the window
+    void StopAutoScrolling();
+
+    // this method can be overridden in a derived class to forbid sending the
+    // auto scroll events - note that unlike StopAutoScrolling() it doesn't
+    // stop the timer, so it will be called repeatedly and will typically
+    // return different values depending on the current mouse position
     //
-    // this function is unsafe as it returns (size_t)-1 (i.e. a huge positive
-    // number) if the control is empty, use GetVisibleEnd() instead, this one
-    // is kept for backwards compatibility
-    size_t GetLastVisibleLine() const { return GetVisibleEnd() - 1; }
+    // the base class version just returns true
+    virtual bool SendAutoScrollEvents(wxScrollWinEvent& event) const;
+
+    // the methods to be called from the window event handlers
+    void HandleOnScroll(wxScrollWinEvent& event);
+    void HandleOnSize(wxSizeEvent& event);
+#if wxUSE_MOUSEWHEEL
+    void HandleOnMouseWheel(wxMouseEvent& event);
+#endif // wxUSE_MOUSEWHEEL
+    void HandleOnMouseEnter(wxMouseEvent& event);
+    void HandleOnMouseLeave(wxMouseEvent& event);
+
+    // these functions must be overidden in the derived class to return
+    // orientation specific data (e.g. the width for vertically scrolling
+    // derivatives in the case of GetOrientationTargetSize())
+    virtual int GetOrientationTargetSize() const = 0;
+    virtual int GetNonOrientationTargetSize() const = 0;
+    virtual wxOrientation GetOrientation() const = 0;
 
-    // layout the children (including the sizer if needed)
-    virtual bool Layout();
 
 protected:
     // this function must be overridden in the derived class and it should
-    // return the height of the given line in pixels
-    virtual wxCoord OnGetLineHeight(size_t n) const = 0;
+    // return the size of the given line in pixels
+    virtual wxCoord OnGetLineSize(size_t n) const = 0;
 
     // this function doesn't have to be overridden but it may be useful to do
-    // it if calculating the lines heights is a relatively expensive operation
+    // it if calculating the lines' sizes is a relatively expensive operation
     // as it gives the user code a possibility to calculate several of them at
     // once
     //
-    // OnGetLinesHint() is normally called just before OnGetLineHeight() but you
+    // OnGetLinesSizeHint() is normally called just before OnGetLineSize() but you
     // shouldn't rely on the latter being called for all lines in the interval
     // specified here. It is also possible that OnGetLineHeight() will be
     // called for the lines outside of this interval, so this is really just a
@@ -156,67 +160,609 @@
     //
     // finally note that lineMin is inclusive, while lineMax is exclusive, as
     // usual
-    virtual void OnGetLinesHint(size_t WXUNUSED(lineMin),
-                                size_t WXUNUSED(lineMax)) const { }
+    virtual void OnGetLinesSizeHint(size_t WXUNUSED(lineMin),
+                                    size_t WXUNUSED(lineMax)) const { }
 
-    // when the number of lines changes, we try to estimate the total height
+    // when the number of lines changes, we try to estimate the total size
     // of all lines which is a rather expensive operation in terms of lines
-    // access, so if the user code may estimate the average height
+    // access, so if the user code may estimate the average size
     // better/faster than we do, it should override this function to implement
     // its own logic
     //
-    // this function should return the best guess for the total height it may
+    // this function should return the best guess for the total size it may
     // make
-    virtual wxCoord EstimateTotalHeight() const;
+    virtual wxCoord EstimateTotalSize() const;
 
+    // find the index of the line we need to show to fit the specified line on
+    // the opposite side either fully or partially (depending on fullyVisible)
+    size_t FindFirstVisibleFromLast(size_t last, bool fullyVisible = false);
 
-    // the event handlers
-    void OnSize(wxSizeEvent& event);
-    void OnScroll(wxScrollWinEvent& event);
-#if wxUSE_MOUSEWHEEL
-    void OnMouseWheel(wxMouseEvent& event);
-#endif
+    // get the total size of the lines between lineMin (inclusive) and
+    // lineMax (exclusive)
+    wxCoord GetLinesSize(size_t lineMin, size_t lineMax) const;
 
-    // find the index of the line we need to show at the top of the window such
-    // that the last (fully or partially) visible line is the given one
-    size_t FindFirstFromBottom(size_t lineLast, bool fullyVisible = false);
+    // get the size of the target window
+    wxSize GetTargetSize() const { return m_targetWindow->GetClientSize(); }
 
-    // get the total height of the lines between lineMin (inclusive) and
-    // lineMax (exclusive)
-    wxCoord GetLinesHeight(size_t lineMin, size_t lineMax) const;
+    void GetTargetSize(int *w, int *h)
+    {
+        wxSize size = GetTargetSize();
+        if ( w )
+            *w = size.x;
+        if ( h )
+            *h = size.y;
+    }
 
-    // update the thumb size shown by the scrollbar
-    void UpdateScrollbar();
+    // replacement implementation of wxWindow::Layout virtual method.  To
+    // properly forward calls to wxWindow::Layout use
+    // WX_FORWARD_TO_SCROLL_HELPER() derived class
+    bool ScrollLayout();
 
-    // remove the scrollbar completely because we don't need it
-    void RemoveScrollbar();
+    // change the target window
+    void DoSetTargetWindow(wxWindow *target);
 
+    // delete the event handler we installed
+    void DeleteEvtHandler();
+
 private:
-    // common part of all ctors
-    void Init();
 
+    // the window that recieves the scroll events and the window to actually
+    // scroll, respectively
+    wxWindow    *m_win,
+                *m_targetWindow;
 
     // the total number of (logical) lines
     size_t m_lineMax;
 
-    // the total (estimated) height
-    wxCoord m_heightTotal;
+    // the total (estimated) size
+    wxCoord m_sizeTotal;
 
     // the first currently visible line
     size_t m_lineFirst;
 
     // the number of currently visible lines (including the last, possibly only
     // partly, visible one)
-    size_t m_nVisible;
+    size_t m_nLinesVisible;
 
     // accumulated mouse wheel rotation
 #if wxUSE_MOUSEWHEEL
     int m_sumWheelRotation;
 #endif
+private:
+
+    // do child scrolling (used in DoPrepareDC())
+    bool m_physicalScrolling;
+
+    // handler injected into target widnow to forward some useful events to us
+    wxVarScrollHelperEvtHandler *m_handler;
+    
+    wxTimer *m_timerAutoScroll;
+};
+
+
+
+
+
+
+class WXDLLEXPORT wxVarVScrollHelper : public wxVarScrollHelperBase
+{
+public:
+    // constructors and such
+    // ---------------------
+
+    // ctor must be given the associated window
+    wxVarVScrollHelper(wxWindow *winToScroll) : wxVarScrollHelperBase(winToScroll) { }
+
+
+    // operators
+    // ---------
+
+    void SetRowCount(size_t rowCount)           { SetLineCount(rowCount); }
+    bool ScrollToRow(size_t row)                { return ScrollToLine(row); }
+    virtual bool ScrollRows(int rows)           { return ScrollLines(rows); }
+    virtual bool ScrollRowPages(int pages)      { return ScrollLinePages(pages); }
+    virtual void RefreshRow(size_t row)         { RefreshLine(row); }
+    virtual void RefreshRows(size_t from, size_t to)
+                                                { RefreshLines(from, to); }
+    virtual int HitTest(wxCoord y) const        { return HitTest(y); }
+
+
+    // accessors
+    // ---------
+
+    size_t GetRowCount() const                  { return GetLineCount(); }
+    size_t GetVisibleRowsBegin() const          { return GetVisibleBegin(); }
+    size_t GetVisibleRowsEnd() const            { return GetVisibleEnd(); }
+    bool IsRowVisible(size_t row) const         { return IsVisible(row); }
+
+
+    virtual int GetOrientationTargetSize() const
+        { return GetTargetWindow()->GetClientSize().y; }
+    virtual int GetNonOrientationTargetSize() const
+        { return GetTargetWindow()->GetClientSize().x; }
+    virtual wxOrientation GetOrientation() const { return wxVERTICAL; }
+
+
+protected:
+    // this function must be overridden in the derived class and it should
+    // return the size of the given row in pixels
+    virtual wxCoord OnGetRowHeight(size_t n) const = 0;
+    wxCoord OnGetLineSize(size_t n) const       { return OnGetRowHeight(n); }
+
+    virtual void OnGetRowsHeightHint(size_t WXUNUSED(rowMin),
+                                     size_t WXUNUSED(rowMax)) const { }
+
+    void OnGetLinesSizeHint(size_t lineMin, size_t lineMax) const
+        { return OnGetRowsHeightHint(lineMin, lineMax); }
+
+    virtual wxCoord EstimateTotalHeight() const { return EstimateTotalSize(); }
+
+
+    wxCoord GetRowsHeight(size_t rowMin, size_t rowMax) const
+        { return GetLinesSize(rowMin, rowMax); }
+};
+
+
+
+
+
+class WXDLLEXPORT wxVarHScrollHelper : public wxVarScrollHelperBase
+{
+public:
+    // constructors and such
+    // ---------------------
+
+    // ctor must be given the associated window
+    wxVarHScrollHelper(wxWindow *winToScroll) : wxVarScrollHelperBase(winToScroll) { }
+
+
+    // operators
+    // ---------
+
+    void SetColumnCount(size_t columnCount)         { SetLineCount(columnCount); }
+    bool ScrollToColumn(size_t column)              { return ScrollToLine(column); }
+    virtual bool ScrollColumns(int columns)         { return ScrollLines(columns); }
+    virtual bool ScrollColumnPages(int pages)       { return ScrollLinePages(pages); }
+    virtual void RefreshColumn(size_t column)       { RefreshLine(column); }
+    virtual void RefreshColumns(size_t from, size_t to)
+                                                    { RefreshLines(from, to); }
+    virtual int HitTest(wxCoord x) const            { return HitTest(x); }
+
+
+    // accessors
+    // ---------
+
+    size_t GetColumnCount() const                   { return GetLineCount(); }
+    size_t GetVisibleColumnsBegin() const           { return GetVisibleBegin(); }
+    size_t GetVisibleColumnsEnd() const             { return GetVisibleEnd(); }
+    bool IsColumnVisible(size_t column) const       { return IsVisible(column); }
+
+
+    virtual int GetOrientationTargetSize() const
+        { return GetTargetWindow()->GetClientSize().x; }
+    virtual int GetNonOrientationTargetSize() const
+        { return GetTargetWindow()->GetClientSize().y; }
+    virtual wxOrientation GetOrientation() const   { return wxHORIZONTAL; }
+
+
+protected:
+    // this function must be overridden in the derived class and it should
+    // return the size of the given column in pixels
+    virtual wxCoord OnGetColumnWidth(size_t n) const = 0;
+    wxCoord OnGetLineSize(size_t n) const        { return OnGetColumnWidth(n); }
+
+    virtual void OnGetColumnsWidthHint(size_t WXUNUSED(columnMin),
+                                        size_t WXUNUSED(columnMax)) const { }
+
+    void OnGetLinesSizeHint(size_t lineMin, size_t lineMax) const
+        { return OnGetColumnsWidthHint(lineMin, lineMax); }
+
+    virtual wxCoord EstimateTotalWidth() const     { return EstimateTotalSize(); }
+
+
+    wxCoord GetColumnsWidth(size_t columnMin, size_t columnMax) const
+        { return GetLinesSize(columnMin, columnMax); }
+};
+
+
+class WXDLLEXPORT wxVSPosition
+{
+public:
+    wxVSPosition() : m_row(0), m_column(0) {}
+    wxVSPosition(int row, int col) : m_row(row), m_column(col) {}
+
+    // default copy ctor and assignment operator are okay.
+
+    int GetRow() const { return m_row; }
+    int GetColumn() const { return m_column; }
+    void SetRow(int row) { m_row = row; }
+    void SetColumn(int column) { m_column = column; }
+
+    bool operator==(const wxVSPosition& p) const { return m_row == p.m_row && m_column == p.m_column; }
+    bool operator!=(const wxVSPosition& p) const { return !(*this == p); }
+
+private:
+    int m_row;
+    int m_column;
+};
+
+
+
+
+// We can't easily multiply inherit because of the shared base class so we'll use composition and write
+// and adaptor interface
+class WXDLLEXPORT wxVarHVScrollHelper : public wxVarVScrollHelper,
+                                        public wxVarHScrollHelper
+{
+public:
+    // constructors and such
+    // ---------------------
+
+
+    // ctor must be given the associated window
+    wxVarHVScrollHelper(wxWindow *winToScroll)
+        : wxVarVScrollHelper(winToScroll), wxVarHScrollHelper(winToScroll) { }
+
+
+    // operators
+    // ---------
+
+    // set the number of lines the window contains for each axis: the derived
+    // class must provide the widths and heights for all lines with indices up
+    // to each of the one given here in its OnGetColumnWidth() and
+    // OnGetRowHeight()
+    void SetRowColumnCount(size_t rowCount, size_t columnCount);
+
+
+    // with physical scrolling on, the device origin is changed properly when
+    // a wxPaintDC is prepared, children are actually moved and layed out
+    // properly, and the contents of the window (pixels) are actually moved
+    void EnablePhysicalScrolling(bool vscrolling = true, bool hscrolling = true)
+    {
+        wxVarVScrollHelper::EnablePhysicalScrolling(vscrolling);
+        wxVarHScrollHelper::EnablePhysicalScrolling(hscrolling);
+    }
+
+    // scroll to the specified row/column: it will become the first visible cell in
+    // the window
+    //
+    // return true if we scrolled the window, false if nothing was done
+    bool ScrollToRowColumn(size_t row, size_t column);
+    bool ScrollToRowColumn(const wxVSPosition &pos)
+        { return ScrollToRowColumn(pos.GetRow(), pos.GetColumn()); }
+
+    // redraw the specified cell
+    virtual void RefreshRowColumn(size_t row, size_t column);
+    virtual void RefreshRowColumn(const wxVSPosition &pos)
+        { RefreshRowColumn(pos.GetRow(), pos.GetColumn()); }
+
+    // redraw the specified regions (inclusive).  If the target window for
+    // both orientations is the same the rectangle of cells is refreshed; if
+    // the target windows differ the entire client size opposite the
+    // orientation direction is refreshed between the specified limits
+    virtual void RefreshRowsColumns(size_t fromRow, size_t toRow,
+                                    size_t fromColumn, size_t toColumn);
+    virtual void RefreshRowsColumns(const wxVSPosition &from, const wxVSPosition &to)
+        { RefreshRowsColumns(from.GetRow(), to.GetRow(), from.GetColumn(), to.GetColumn()); }
+
+    // Override wxPanel::HitTest to use our version
+    virtual wxVSPosition HitTest(wxCoord x, wxCoord y) const;
+    virtual wxVSPosition HitTest(const wxPoint &pos) const
+        { return HitTest(pos.x, pos.y); }
+
+    // change the DC origin according to the scroll position. To properly
+    // forward calls to wxWindow::Layout use WX_FORWARD_TO_SCROLL_HELPER()
+    // derived class. We use this version to call both base classes' DoPrepareDC()
+    virtual void DoPrepareDC(wxDC& dc);
+
+    // replacement implementation of wxWindow::Layout virtual method.  To
+    // properly forward calls to wxWindow::Layout use
+    // WX_FORWARD_TO_SCROLL_HELPER() derived class. We use this version to
+    // call both base classes' ScrollLayout()
+    bool ScrollLayout();
+
+
+    // accessors
+    // ---------
+
+    // get the number of lines this window contains (previously set by
+    // SetLineCount())
+    wxSize GetRowColumnCount() const;
+
+    // get the first currently visible lines
+    wxVSPosition GetVisibleBegin() const;
+    wxVSPosition GetVisibleEnd() const;
+
+    // is this cell currently visible?
+    bool IsVisible(size_t row, size_t column) const;
+    bool IsVisible(const wxVSPosition &pos) const
+        { return IsVisible(pos.GetRow(), pos.GetColumn()); }
+};
+
+
+
+
+class WXDLLEXPORT wxVarVScrollLegacyAdaptor : public wxVarVScrollHelper
+{
+public:
+    // constructors and such
+    // ---------------------
+    wxVarVScrollLegacyAdaptor(wxWindow *winToScroll) : wxVarVScrollHelper(winToScroll) { }
+
+
+    // accessors
+    // ---------
+
+    // this is the same as GetVisibleRowsBegin(), exists to match
+    // GetLastVisibleLine() and for backwards compatibility only
+    size_t GetFirstVisibleLine() const { return GetVisibleRowsBegin(); }
+
+    // get the last currently visible line
+    //
+    // this function is unsafe as it returns (size_t)-1 (i.e. a huge positive
+    // number) if the control is empty, use GetVisibleRowsEnd() instead, this one
+    // is kept for backwards compatibility
+    size_t GetLastVisibleLine() const { return GetVisibleRowsEnd() - 1; }
+
+protected:
+    // this function must be overridden in the derived class and it should
+    // return the height of the given row in pixels
+    virtual wxCoord OnGetLineHeight(size_t n) const = 0;
+
+    // forwards the calls from base class pure virtual function to pure virtual
+    // OnGetLineHeight instead (backwards compatible name)
+    virtual wxCoord OnGetRowHeight(size_t n) const { return OnGetLineHeight(n); }
+
+    // this function doesn't have to be overridden but it may be useful to do
+    // it if calculating the lines heights is a relatively expensive operation
+    // as it gives the user code a possibility to calculate several of them at
+    // once
+    //
+    // OnGetLinesHint() is normally called just before OnGetLineHeight() but you
+    // shouldn't rely on the latter being called for all lines in the interval
+    // specified here. It is also possible that OnGetLineHeight() will be
+    // called for the lines outside of this interval, so this is really just a
+    // hint, not a promise.
+    //
+    // finally note that lineMin is inclusive, while lineMax is exclusive, as
+    // usual
+    virtual void OnGetLinesHint(size_t WXUNUSED(lineMin),
+                                size_t WXUNUSED(lineMax)) const { }
+
+    // forwards the calls from base class pure virtual function to pure virtual
+    // OnGetLinesHint instead (backwards compatible name)
+    void OnGetRowsHeightHint(size_t rowMin, size_t rowMax) const
+        { return OnGetLinesHint(rowMin, rowMax); }
+
+
+    // get the total height of the lines between lineMin (inclusive) and
+    // lineMax (exclusive)
+    wxCoord GetLinesHeight(size_t lineMin, size_t lineMax) const
+        { return GetRowsHeight(lineMin, lineMax); }
+};
 
+
+#define WX_FORWARD_TO_VAR_SCROLL_HELPER()                                     \
+public:                                                                       \
+    virtual void PrepareDC(wxDC& dc) { DoPrepareDC(dc); }                     \
+    virtual bool Layout() { return ScrollLayout(); }
+
+// ----------------------------------------------------------------------------
+// wxVScrolledWindow
+// ----------------------------------------------------------------------------
+
+/*
+   In the name of this class, "V" may stand for "variable" because it can be
+   used for scrolling lines of variable heights; "virtual" because it is not
+   necessary to know the heights of all lines in advance -- only those which
+   are shown on the screen need to be measured; or, even, "vertical" because
+   this class only supports scrolling in one direction currently (this could
+   and probably will change in the future however).
+
+   In any case, this is a generalization of the wxScrolledWindow class which
+   can be only used when all lines have the same heights. It lacks some other
+   wxScrolledWindow features however, notably it can't scroll only a rectangle
+   of the window and not its entire client area.
+ */
+class WXDLLEXPORT wxVScrolledWindow : public wxPanel,
+                                      public wxVarVScrollLegacyAdaptor
+{
+public:
+    // constructors and such
+    // ---------------------
+
+    // default ctor, you must call Create() later
+    wxVScrolledWindow() : wxVarVScrollLegacyAdaptor(this) { }
+
+    // normal ctor, no need to call Create() after this one
+    //
+    // note that wxVSCROLL is always automatically added to our style, there is
+    // no need to specify it explicitly
+    wxVScrolledWindow(wxWindow *parent,
+                      wxWindowID id = wxID_ANY,
+                      const wxPoint& pos = wxDefaultPosition,
+                      const wxSize& size = wxDefaultSize,
+                      long style = 0,
+                      const wxString& name = wxPanelNameStr)
+    : wxVarVScrollLegacyAdaptor(this)
+    {
+        (void)Create(parent, id, pos, size, style, name);
+    }
+
+    // same as the previous ctor but returns status code: true if ok
+    //
+    // just as with the ctor above, wxVSCROLL style is always used, there is no
+    // need to specify it
+    bool Create(wxWindow *parent,
+                wxWindowID id = wxID_ANY,
+                const wxPoint& pos = wxDefaultPosition,
+                const wxSize& size = wxDefaultSize,
+                long style = 0,
+                const wxString& name = wxPanelNameStr)
+    {
+        return wxPanel::Create(parent, id, pos, size, style | wxVSCROLL, name);
+    }
+
+    // Make sure we prefer our version of HitTest rather than wxPanel's
+    int HitTest(wxCoord WXUNUSED(x), wxCoord y) const { return wxVarVScrollHelper::HitTest(y); }
+    int HitTest(const wxPoint& pt) const { return HitTest(pt.x, pt.y); }
+
+    WX_FORWARD_TO_VAR_SCROLL_HELPER()
+
+private:
     DECLARE_EVENT_TABLE()
     DECLARE_NO_COPY_CLASS(wxVScrolledWindow)
     DECLARE_ABSTRACT_CLASS(wxVScrolledWindow)
+};
+
+// ----------------------------------------------------------------------------
+// wxHScrolledWindow
+// ----------------------------------------------------------------------------
+
+/*
+   In the name of this class, "V" may stand for "variable" because it can be
+   used for scrolling lines of variable heights; "virtual" because it is not
+   necessary to know the heights of all lines in advance -- only those which
+   are shown on the screen need to be measured
+
+   In any case, this is a generalization of the wxScrolledWindow class which
+   can be only used when all lines have the same widths. It lacks some other
+   wxScrolledWindow features however, notably it can't scroll only a rectangle
+   of the window and not its entire client area.
+ */
+class WXDLLEXPORT wxHScrolledWindow : public wxPanel,
+                                      public wxVarHScrollHelper
+{
+public:
+    // constructors and such
+    // ---------------------
+
+    // default ctor, you must call Create() later
+    wxHScrolledWindow() : wxVarHScrollHelper(this) { }
+
+    // normal ctor, no need to call Create() after this one
+    //
+    // note that wxVSCROLL is always automatically added to our style, there is
+    // no need to specify it explicitly
+    wxHScrolledWindow(wxWindow *parent,
+                      wxWindowID id = wxID_ANY,
+                      const wxPoint& pos = wxDefaultPosition,
+                      const wxSize& size = wxDefaultSize,
+                      long style = 0,
+                      const wxString& name = wxPanelNameStr)
+    : wxVarHScrollHelper(this)
+    {
+        (void)Create(parent, id, pos, size, style, name);
+    }
+
+    // same as the previous ctor but returns status code: true if ok
+    //
+    // just as with the ctor above, wxVSCROLL style is always used, there is no
+    // need to specify it
+    bool Create(wxWindow *parent,
+                wxWindowID id = wxID_ANY,
+                const wxPoint& pos = wxDefaultPosition,
+                const wxSize& size = wxDefaultSize,
+                long style = 0,
+                const wxString& name = wxPanelNameStr)
+    {
+        return wxPanel::Create(parent, id, pos, size, style | wxHSCROLL, name);
+    }
+
+    // Make sure we prefer our version of HitTest rather than wxPanel's
+    int HitTest(wxCoord x, wxCoord WXUNUSED(y)) const { return wxVarHScrollHelper::HitTest(x); }
+    int HitTest(const wxPoint& pt) const { return HitTest(pt.x, pt.y); }
+
+    WX_FORWARD_TO_VAR_SCROLL_HELPER()
+
+private:
+    DECLARE_EVENT_TABLE()
+    DECLARE_NO_COPY_CLASS(wxHScrolledWindow)
+    DECLARE_ABSTRACT_CLASS(wxHScrolledWindow)
+};
+
+// ----------------------------------------------------------------------------
+// wxHVScrolledWindow
+// ----------------------------------------------------------------------------
+
+/*
+   This class is strongly influenced by wxVScrolledWindow. In fact, much of
+   code is line for line the same except it explicitly states which axis is
+   being worked on.  Like wxVScrolledWindow, this class is here to provide
+   an easy way to implement variable line sizes.  The difference is that
+   wxVScrolledWindow only works with vertical scrolling.  This class extends
+   the behavior of wxVScrolledWindow to the horizontal axis in addition to the
+   vertical axis.
+
+   The scrolling is also "virtual" in the sense that line widths and heights
+   only need to be known for lines that are currently visible.
+
+   Like wxVScrolledWindow, this is a generalization of the wxScrolledWindow
+   class which can be only used when all horizontal lines have the same width
+   and all of the vertical lines have the same height. Like wxVScrolledWinow
+   it lacks some of wxScrolledWindow features such as scrolling another window
+   or only scrolling a rectangle of the window and not its entire client area.
+
+   If only vertical scrolling is needed, wxVScrolledWindow is recommended
+   because it is simpler to use (and you get to type less).
+   
+   There is no wxHScrolledWindow but horizontal only scrolling is implemented
+   easily enough with this class.  If someone feels the need for such a class,
+   implementing it is trivial.
+ */
+class WXDLLEXPORT wxHVScrolledWindow : public wxPanel,
+                                       public wxVarHVScrollHelper
+{
+public:
+    // constructors and such
+    // ---------------------
+
+    // default ctor, you must call Create() later
+    wxHVScrolledWindow()
+        : wxPanel(),
+          wxVarHVScrollHelper(this) { }
+
+    // normal ctor, no need to call Create() after this one
+    //
+    // note that wxVSCROLL and wxHSCROLL are always automatically added to our
+    // style, there is no need to specify them explicitly
+    wxHVScrolledWindow(wxWindow *parent,
+                       wxWindowID id = wxID_ANY,
+                       const wxPoint& pos = wxDefaultPosition,
+                       const wxSize& size = wxDefaultSize,
+                       long style = 0,
+                       const wxString& name = wxPanelNameStr)
+        : wxPanel(),
+          wxVarHVScrollHelper(this) 
+    {
+        (void)Create(parent, id, pos, size, style, name);
+    }
+
+    // same as the previous ctor but returns status code: true if ok
+    //
+    // just as with the ctor above, wxVSCROLL and wxHSCROLL styles are always
+    // used, there is no need to specify them
+    bool Create(wxWindow *parent,
+                wxWindowID id = wxID_ANY,
+                const wxPoint& pos = wxDefaultPosition,
+                const wxSize& size = wxDefaultSize,
+                long style = 0,
+                const wxString& name = wxPanelNameStr)
+    {
+        return wxPanel::Create(parent, id, pos, size,
+                style | wxVSCROLL | wxHSCROLL, name);
+    }
+
+    // Make sure we prefer our version of HitTest rather than wxPanel's
+    wxVSPosition HitTest(wxCoord x, wxCoord y) const { return wxVarHVScrollHelper::HitTest(x, y); }
+    wxVSPosition HitTest(const wxPoint &pt) const { return HitTest(pt.x, pt.y); }
+
+    WX_FORWARD_TO_VAR_SCROLL_HELPER()
+
+private:
+    DECLARE_EVENT_TABLE()
+    DECLARE_NO_COPY_CLASS(wxHVScrolledWindow)
+    DECLARE_ABSTRACT_CLASS(wxHVScrolledWindow)
 };
 
 #endif // _WX_VSCROLL_H_
Index: samples/vscroll/vstest.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/samples/vscroll/vstest.cpp,v
retrieving revision 1.12
diff -u -r1.12 vstest.cpp
--- samples/vscroll/vstest.cpp	2006/04/14 22:03:07	1.12
+++ samples/vscroll/vstest.cpp	2006/05/15 21:04:48
@@ -2,9 +2,9 @@
 // Name:        samples/vscroll/vstest.cpp
 // Purpose:     VScroll wxWidgets sample
 // Author:      Vadim Zeitlin
-// Modified by:
+// Modified by: Brad Anderson
 // Created:     04/01/98
-// RCS-ID:      $Id: vstest.cpp,v 1.12 2006/04/14 22:03:07 VZ Exp $
+// RCS-ID:      $Id: vstest.cpp,v 1.11 2006/02/15 09:59:39 RR Exp $
 // Copyright:   (c) 2003 Vadim Zeitlin <vadim@wxwidgets.org>
 // Licence:     wxWindows licence
 /////////////////////////////////////////////////////////////////////////////
@@ -45,11 +45,17 @@
 #endif
 
 // ----------------------------------------------------------------------------
+// definitions
+// ----------------------------------------------------------------------------
+
+#define MAX_LINES 10000
+
+// ----------------------------------------------------------------------------
 // private classes
 // ----------------------------------------------------------------------------
 
 // Define a new application type, each program should derive a class from wxApp
-class VScrollApp : public wxApp
+class VarScrollApp : public wxApp
 {
 public:
     // create our main window
@@ -57,14 +63,17 @@
 };
 
 // Define a new frame type: this is going to be our main frame
-class VScrollFrame : public wxFrame
+class VarScrollFrame : public wxFrame
 {
 public:
     // ctor
-    VScrollFrame();
+    VarScrollFrame();
 
     // event handlers (these functions should _not_ be virtual)
     void OnQuit(wxCommandEvent& event);
+    void OnModeVScroll(wxCommandEvent& event);
+    void OnModeHScroll(wxCommandEvent& event);
+    void OnModeHVScroll(wxCommandEvent& event);
     void OnAbout(wxCommandEvent& event);
 
     void OnSize(wxSizeEvent& event)
@@ -84,6 +93,9 @@
 private:
     // any class wishing to process wxWidgets events must use this macro
     DECLARE_EVENT_TABLE()
+
+    // either a wxVScrolledWindow or a wxHVScrolled window, depending on current mode
+    wxPanel *m_scrollWindow;
 };
 
 class VScrollWindow : public wxVScrolledWindow
@@ -93,8 +105,12 @@
     {
         m_frame = frame;
 
-        SetLineCount(200);
+        SetLineCount(MAX_LINES);
 
+        int i;
+        for ( i = 0; i < MAX_LINES; ++i )
+            m_heights[i] = rand()%25+16; // low: 15; high: 40
+    
         m_changed = true;
     }
 
@@ -116,21 +132,23 @@
     {
         wxPaintDC dc(this);
 
-        dc.SetPen(*wxBLACK_DASHED_PEN);
+        dc.SetPen(*wxBLACK_PEN);
 
-        const size_t lineFirst = GetFirstVisibleLine(),
-                     lineLast = GetLastVisibleLine();
+        const size_t lineFirst = GetVisibleBegin(),
+                     lineLast = GetVisibleEnd();
 
         const wxCoord hText = dc.GetCharHeight();
 
+        wxSize clientSize = GetClientSize();
+
         wxCoord y = 0;
-        for ( size_t line = lineFirst; line <= lineLast; line++ )
+        for ( size_t line = lineFirst; line < lineLast; line++ )
         {
-            dc.DrawLine(0, y, 1000, y);
+            dc.DrawLine(0, y, clientSize.GetWidth(), y);
 
             wxCoord hLine = OnGetLineHeight(line);
             dc.DrawText(wxString::Format(_T("Line %lu"), (unsigned long)line),
-                        0, y + (hLine - hText) / 2);
+                        2, y + (hLine - hText) / 2);
 
             y += hLine;
             dc.DrawLine(0, y, 1000, y);
@@ -144,17 +162,27 @@
         event.Skip();
     }
 
+    void OnMouse(wxMouseEvent& event)
+    {
+        if(event.LeftDown())
+            CaptureMouse();
+        else if(event.LeftUp())
+            ReleaseMouse();
+        event.Skip();
+    }
 
     virtual wxCoord OnGetLineHeight(size_t n) const
     {
         wxASSERT( n < GetLineCount() );
 
-        return n % 2 ? 15 : 30; // 15 + 2*n
+        return m_heights[n];
     }
 
 private:
     wxFrame *m_frame;
 
+    int m_heights[MAX_LINES];
+
     bool m_changed;
 
     DECLARE_EVENT_TABLE()
@@ -164,8 +192,235 @@
     EVT_IDLE(VScrollWindow::OnIdle)
     EVT_PAINT(VScrollWindow::OnPaint)
     EVT_SCROLLWIN(VScrollWindow::OnScroll)
+    EVT_MOUSE_EVENTS(VScrollWindow::OnMouse)
 END_EVENT_TABLE()
 
+class HScrollWindow : public wxHScrolledWindow
+{
+public:
+    HScrollWindow(wxFrame *frame) : wxHScrolledWindow(frame, wxID_ANY)
+    {
+        m_frame = frame;
+
+        SetLineCount(MAX_LINES);
+
+        int i;
+        for ( i = 0; i < MAX_LINES; ++i )
+            m_heights[i] = rand()%25+16; // low: 15; high: 40
+    
+        m_changed = true;
+    }
+
+    void OnIdle(wxIdleEvent&)
+    {
+#if wxUSE_STATUSBAR
+        m_frame->SetStatusText(wxString::Format
+                               (
+                                    _T("Page size = %d, pos = %d, max = %d"),
+                                    GetScrollThumb(wxVERTICAL),
+                                    GetScrollPos(wxVERTICAL),
+                                    GetScrollRange(wxVERTICAL)
+                               ));
+#endif // wxUSE_STATUSBAR
+        m_changed = false;
+    }
+
+    void OnPaint(wxPaintEvent&)
+    {
+        wxPaintDC dc(this);
+
+        dc.SetPen(*wxBLACK_PEN);
+
+        const size_t lineFirst = GetVisibleBegin(),
+                     lineLast = GetVisibleEnd();
+
+        const wxCoord hText = dc.GetCharHeight();
+
+        wxSize clientSize = GetClientSize();
+
+        wxCoord x = 0;
+        for ( size_t line = lineFirst; line < lineLast; line++ )
+        {
+            dc.DrawLine(x, 0, x, clientSize.GetHeight());
+
+            wxCoord wLine = OnGetColumnWidth(line);
+            dc.DrawRotatedText(wxString::Format(_T("Line %lu"), (unsigned long)line),
+                               x + (wLine - hText) / 2, clientSize.GetHeight() - 5, 90);
+
+            x += wLine;
+            dc.DrawLine(x, 0, x, 1000);
+        }
+    }
+
+    void OnScroll(wxScrollWinEvent& event)
+    {
+        m_changed = true;
+
+        event.Skip();
+    }
+
+    void OnMouse(wxMouseEvent& event)
+    {
+        if(event.LeftDown())
+            CaptureMouse();
+        else if(event.LeftUp())
+            ReleaseMouse();
+        event.Skip();
+    }
+
+    virtual wxCoord OnGetColumnWidth(size_t n) const
+    {
+        wxASSERT( n < GetLineCount() );
+
+        return m_heights[n];
+    }
+
+private:
+    wxFrame *m_frame;
+
+    int m_heights[MAX_LINES];
+
+    bool m_changed;
+
+    DECLARE_EVENT_TABLE()
+};
+
+BEGIN_EVENT_TABLE(HScrollWindow, wxHScrolledWindow)
+    EVT_IDLE(HScrollWindow::OnIdle)
+    EVT_PAINT(HScrollWindow::OnPaint)
+    EVT_SCROLLWIN(HScrollWindow::OnScroll)
+    EVT_MOUSE_EVENTS(HScrollWindow::OnMouse)
+END_EVENT_TABLE()
+
+class HVScrollWindow : public wxHVScrolledWindow
+{
+public:
+    HVScrollWindow(wxFrame *frame) : wxHVScrolledWindow(frame, wxID_ANY)
+    {
+        m_frame = frame;
+
+        SetRowColumnCount(MAX_LINES, MAX_LINES);
+        
+        int i;
+        for ( i = 0; i < MAX_LINES; ++i )
+        {
+            m_heights[i] = rand()%30+31; // low: 30; high: 60
+            m_widths[i] = rand()%30+61;  // low: 60; high: 90
+        }
+
+        m_changed = true;
+    }
+
+    void OnIdle(wxIdleEvent&)
+    {
+#if wxUSE_STATUSBAR
+        m_frame->SetStatusText(wxString::Format
+                               (
+                                    _T("Page size = %d rows %d columns; pos = row: %d, column: %d; max = %d rows, %d columns"),
+                                    GetScrollThumb(wxVERTICAL),
+                                    GetScrollThumb(wxHORIZONTAL),
+                                    GetScrollPos(wxVERTICAL),
+                                    GetScrollPos(wxHORIZONTAL),
+                                    GetScrollRange(wxVERTICAL),
+                                    GetScrollRange(wxHORIZONTAL)
+                               ));
+#endif // wxUSE_STATUSBAR
+        m_changed = false;
+    }
+
+    void OnPaint(wxPaintEvent&)
+    {
+        wxPaintDC dc(this);
+
+        dc.SetPen(*wxBLACK_PEN);
+
+        const size_t rowFirst = GetVisibleRowsBegin(),
+                     rowLast = GetVisibleRowsEnd();
+        const size_t columnFirst = GetVisibleColumnsBegin(),
+                     columnLast = GetVisibleColumnsEnd();
+        
+        const wxCoord hText = dc.GetCharHeight();
+
+        wxSize clientSize = GetClientSize();
+
+        wxCoord y = 0;
+        wxCoord x = 0;
+        for ( size_t row = rowFirst; row < rowLast; row++ )
+        {
+            wxCoord rowHeight = OnGetRowHeight(row);
+            dc.DrawLine(0, y, clientSize.GetWidth(), y);
+
+            x = 0;
+            for ( size_t col = columnFirst; col < columnLast; col++ )
+            {
+                wxCoord colWidth = OnGetColumnWidth(col);
+
+                if ( row == rowFirst )
+                    dc.DrawLine(x, 0, x, clientSize.GetHeight());
+
+                dc.DrawText(wxString::Format(_T("Row %lu"), (unsigned long)row),
+                            x + 2, y + rowHeight / 2 - hText);
+                dc.DrawText(wxString::Format(_T("Col %lu"), (unsigned long)col),
+                            x + 2, y + rowHeight / 2);
+                
+                x += colWidth;
+                if ( row == rowFirst)
+                    dc.DrawLine(x, 0, x, clientSize.GetHeight());
+            }
+            
+            y += rowHeight;
+            dc.DrawLine(0, y, clientSize.GetWidth(), y);
+        }
+    }
+
+    void OnScroll(wxScrollWinEvent& event)
+    {
+        m_changed = true;
+
+        event.Skip();
+    }
+
+    void OnMouse(wxMouseEvent& event)
+    {
+        if(event.LeftDown())
+            CaptureMouse();
+        else if(event.LeftUp())
+            ReleaseMouse();
+        event.Skip();
+    }
+
+    virtual wxCoord OnGetRowHeight(size_t n) const
+    {
+        wxASSERT( n < GetRowCount() );
+
+        return m_heights[n];
+    }
+
+    virtual wxCoord OnGetColumnWidth(size_t n) const
+    {
+        wxASSERT( n < GetColumnCount() );
+
+        return m_widths[n];
+    }
+
+private:
+    wxFrame *m_frame;
+
+    int m_heights[MAX_LINES];
+    int m_widths[MAX_LINES];
+
+    bool m_changed;
+
+    DECLARE_EVENT_TABLE()
+};
+
+BEGIN_EVENT_TABLE(HVScrollWindow, wxHVScrolledWindow)
+    EVT_IDLE(HVScrollWindow::OnIdle)
+    EVT_PAINT(HVScrollWindow::OnPaint)
+    EVT_SCROLLWIN(HVScrollWindow::OnScroll)
+    EVT_MOUSE_EVENTS(HVScrollWindow::OnMouse)
+END_EVENT_TABLE()
+
 // ----------------------------------------------------------------------------
 // constants
 // ----------------------------------------------------------------------------
@@ -179,7 +434,11 @@
     // it is important for the id corresponding to the "About" command to have
     // this standard value as otherwise it won't be handled properly under Mac
     // (where it is special and put into the "Apple" menu)
-    VScroll_About = wxID_ABOUT
+    VScroll_About = wxID_ABOUT,
+
+    VScroll_VScrollMode = wxID_HIGHEST + 1,
+    VScroll_HScrollMode,
+    VScroll_HVScrollMode
 };
 
 // ----------------------------------------------------------------------------
@@ -189,18 +448,21 @@
 // the event tables connect the wxWidgets events with the functions (event
 // handlers) which process them. It can be also done at run-time, but for the
 // simple menu events like this the static method is much simpler.
-BEGIN_EVENT_TABLE(VScrollFrame, wxFrame)
-    EVT_MENU(VScroll_Quit,  VScrollFrame::OnQuit)
-    EVT_MENU(VScroll_About, VScrollFrame::OnAbout)
-    EVT_SIZE(VScrollFrame::OnSize)
+BEGIN_EVENT_TABLE(VarScrollFrame, wxFrame)
+    EVT_MENU(VScroll_Quit,  VarScrollFrame::OnQuit)
+    EVT_MENU(VScroll_VScrollMode, VarScrollFrame::OnModeVScroll)
+    EVT_MENU(VScroll_HScrollMode, VarScrollFrame::OnModeHScroll)
+    EVT_MENU(VScroll_HVScrollMode, VarScrollFrame::OnModeHVScroll)
+    EVT_MENU(VScroll_About, VarScrollFrame::OnAbout)
+    EVT_SIZE(VarScrollFrame::OnSize)
 END_EVENT_TABLE()
 
 // Create a new application object: this macro will allow wxWidgets to create
 // the application object during program execution (it's better than using a
 // static object for many reasons) and also declares the accessor function
-// wxGetApp() which will return the reference of the right type (i.e. VScrollApp and
+// wxGetApp() which will return the reference of the right type (i.e. VarScrollApp and
 // not wxApp)
-IMPLEMENT_APP(VScrollApp)
+IMPLEMENT_APP(VarScrollApp)
 
 // ============================================================================
 // implementation
@@ -211,10 +473,10 @@
 // ----------------------------------------------------------------------------
 
 // 'Main program' equivalent: the program execution "starts" here
-bool VScrollApp::OnInit()
+bool VarScrollApp::OnInit()
 {
     // create the main application window
-    VScrollFrame *frame = new VScrollFrame;
+    VarScrollFrame *frame = new VarScrollFrame;
 
     // and show it (the frames, unlike simple controls, are not shown when
     // created initially)
@@ -229,12 +491,13 @@
 // ----------------------------------------------------------------------------
 
 // frame constructor
-VScrollFrame::VScrollFrame()
-            : wxFrame(NULL,
-                      wxID_ANY,
-                      _T("VScroll wxWidgets Sample"),
-                      wxDefaultPosition,
-                      wxSize(400, 350))
+VarScrollFrame::VarScrollFrame()
+               : wxFrame(NULL,
+                         wxID_ANY,
+                         _T("VScroll wxWidgets Sample"),
+                         wxDefaultPosition,
+                         wxSize(400, 350)),
+                 m_scrollWindow(NULL)
 {
     // set the frame icon
     SetIcon(wxICON(sample));
@@ -243,15 +506,36 @@
     // create a menu bar
     wxMenu *menuFile = new wxMenu;
 
+    wxMenu *menuMode = new wxMenu;
+
     // the "About" item should be in the help menu
     wxMenu *menuHelp = new wxMenu;
     menuHelp->Append(VScroll_About, _T("&About...\tF1"), _T("Show about dialog"));
 
+#ifdef wxHAS_RADIO_MENU_ITEMS
+    menuMode->AppendRadioItem(VScroll_VScrollMode, _T("&Vertical\tAlt-V"),
+                              _T("Vertical scrolling only"));
+    menuMode->AppendRadioItem(VScroll_HScrollMode, _T("&Horizontal\tAlt-H"),
+                              _T("Horizontal scrolling only"));
+    menuMode->AppendRadioItem(VScroll_HVScrollMode,
+                              _T("Hori&zontal/Vertical\tAlt-Z"),
+                              _T("Horizontal and vertical scrolling"));
+    menuMode->Check(VScroll_VScrollMode, true);
+#else
+    menuMode->Append(VScroll_VScrollMode, _T("&Vertical\tAlt-V"),
+                     _T("Vertical scrolling only"));
+    menuMode->Append(VScroll_HScrollMode, _T("&Horizontal\tAlt-H"),
+                     _T("Horizontal scrolling only"));
+    menuMode->Append(VScroll_HVScrollMode, _T("Hori&zontal/Vertical\tAlt-Z"),
+                     _T("Horizontal and vertical scrolling"));
+#endif
+
     menuFile->Append(VScroll_Quit, _T("E&xit\tAlt-X"), _T("Quit this program"));
 
     // now append the freshly created menu to the menu bar...
     wxMenuBar *menuBar = new wxMenuBar;
     menuBar->Append(menuFile, _T("&File"));
+    menuBar->Append(menuMode, _T("&Mode"));
     menuBar->Append(menuHelp, _T("&Help"));
 
     // ... and attach this menu bar to the frame
@@ -262,26 +546,62 @@
     // create a status bar just for fun (by default with 1 pane only)
     CreateStatusBar(2);
     SetStatusText(_T("Welcome to wxWidgets!"));
+    int widths[2];
+    widths[0] = -1;
+    widths[1] = 100;
+    SetStatusWidths(2, widths);
 #endif // wxUSE_STATUSBAR
 
     // create our one and only child -- it will take our entire client area
-    new VScrollWindow(this);
+    if ( menuMode->IsChecked(VScroll_VScrollMode) )
+        m_scrollWindow = new VScrollWindow(this);
+    else if ( menuMode->IsChecked(VScroll_HScrollMode) )
+        m_scrollWindow = new HScrollWindow(this);
+    else if ( menuMode->IsChecked(VScroll_HVScrollMode) )
+        m_scrollWindow = new HVScrollWindow(this);
 }
 
 // ----------------------------------------------------------------------------
 // event handlers
 // ----------------------------------------------------------------------------
 
-void VScrollFrame::OnQuit(wxCommandEvent& WXUNUSED(event))
+void VarScrollFrame::OnQuit(wxCommandEvent& WXUNUSED(event))
 {
     // true is to force the frame to close
     Close(true);
 }
+
+void VarScrollFrame::OnModeVScroll(wxCommandEvent& WXUNUSED(event))
+{
+    if ( m_scrollWindow )
+        m_scrollWindow->Destroy();
+    
+    m_scrollWindow = new VScrollWindow(this);
+    SendSizeEvent();
+}
+
+void VarScrollFrame::OnModeHScroll(wxCommandEvent& WXUNUSED(event))
+{
+    if ( m_scrollWindow )
+        m_scrollWindow->Destroy();
+    
+    m_scrollWindow = new HScrollWindow(this);
+    SendSizeEvent();
+}
+
+void VarScrollFrame::OnModeHVScroll(wxCommandEvent& WXUNUSED(event))
+{
+    if ( m_scrollWindow )
+        m_scrollWindow->Destroy();
+
+    m_scrollWindow = new HVScrollWindow(this);
+    SendSizeEvent();
+}
 
-void VScrollFrame::OnAbout(wxCommandEvent& WXUNUSED(event))
+void VarScrollFrame::OnAbout(wxCommandEvent& WXUNUSED(event))
 {
     wxMessageBox(_T("VScroll shows how to implement scrolling with\n")
-                 _T("variable line heights.\n")
+                 _T("variable line widths and heights.\n")
                  _T("(c) 2003 Vadim Zeitlin"),
                  _T("About VScroll"),
                  wxOK | wxICON_INFORMATION,
Index: src/generic/vscroll.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/generic/vscroll.cpp,v
retrieving revision 1.29
diff -u -r1.29 vscroll.cpp
--- src/generic/vscroll.cpp	2006/04/26 00:17:52	1.29
+++ src/generic/vscroll.cpp	2006/05/15 21:42:22
@@ -2,9 +2,9 @@
 // Name:        src/generic/vscroll.cpp
 // Purpose:     wxVScrolledWindow implementation
 // Author:      Vadim Zeitlin
-// Modified by:
+// Modified by: Brad Anderson
 // Created:     30.05.03
-// RCS-ID:      $Id: vscroll.cpp,v 1.29 2006/04/26 00:17:52 VZ Exp $
+// RCS-ID:      $Id: vscroll.cpp,v 1.24 2006/03/24 07:19:45 ABX Exp $
 // Copyright:   (c) 2003 Vadim Zeitlin <vadim@wxwindows.org>
 // Licence:     wxWindows licence
 /////////////////////////////////////////////////////////////////////////////
@@ -30,50 +30,241 @@
 
 #include "wx/vscroll.h"
 
+
+// ============================================================================
+// wxVarAutoScrollTimer declaration
+// ============================================================================
+
+#if wxUSE_TIMER
 // ----------------------------------------------------------------------------
-// event tables
+// wxAutoScrollTimer: the timer used to generate a stream of scroll events when
+// a captured mouse is held outside the window
 // ----------------------------------------------------------------------------
 
-BEGIN_EVENT_TABLE(wxVScrolledWindow, wxPanel)
-    EVT_SIZE(wxVScrolledWindow::OnSize)
-    EVT_SCROLLWIN(wxVScrolledWindow::OnScroll)
-#if wxUSE_MOUSEWHEEL
-    EVT_MOUSEWHEEL(wxVScrolledWindow::OnMouseWheel)
-#endif
-END_EVENT_TABLE()
+class wxVarAutoScrollTimer : public wxTimer
+{
+public:
+    wxVarAutoScrollTimer(wxWindow *scrollWindow,
+                         wxVarScrollHelperBase *helper,
+                         wxEventType eventTypeToSend,
+                         int pos, int orient);
+
+    virtual void Notify();
+
+private:
+    wxWindow *m_win;
+    wxVarScrollHelperBase *m_autoScrollHelper;
+    wxEventType m_eventType;
+    int m_pos,
+        m_orient;
 
+    DECLARE_NO_COPY_CLASS(wxVarAutoScrollTimer)
+};
 
 // ============================================================================
-// implementation
+// wxVarAutoScrollTimer implementation
 // ============================================================================
 
-IMPLEMENT_ABSTRACT_CLASS(wxVScrolledWindow, wxPanel)
+// ----------------------------------------------------------------------------
+// wxVarAutoScrollTimer initialization
+// ----------------------------------------------------------------------------
 
+wxVarAutoScrollTimer::wxVarAutoScrollTimer(wxWindow *scrollWindow,
+                                           wxVarScrollHelperBase *helper,
+                                           wxEventType eventTypeToSend,
+                                           int pos, int orient)
+{
+    m_win = scrollWindow;
+    m_autoScrollHelper = helper;
+    m_eventType = eventTypeToSend;
+    m_pos = pos;
+    m_orient = orient;
+}
+
 // ----------------------------------------------------------------------------
-// initialization
+// wxVarAutoScrollTimer operations
 // ----------------------------------------------------------------------------
 
-void wxVScrolledWindow::Init()
+void wxVarAutoScrollTimer::Notify()
 {
-    // we're initially empty
-    m_lineMax =
-    m_lineFirst = 0;
+    // only do all this as long as the window is capturing the mouse
+    if ( wxWindow::GetCapture() != m_win )
+    {
+        Stop();
+    }
+    else // we still capture the mouse, continue generating events
+    {
+        // first scroll the window if we are allowed to do it
+        wxScrollWinEvent event1(m_eventType, m_pos, m_orient);
+        event1.SetEventObject(m_win);
+        if ( m_autoScrollHelper->SendAutoScrollEvents(event1) &&
+                m_win->GetEventHandler()->ProcessEvent(event1) )
+        {
+            // and then send a pseudo mouse-move event to refresh the selection
+            wxMouseEvent event2(wxEVT_MOTION);
+            wxGetMousePosition(&event2.m_x, &event2.m_y);
+
+            // the mouse event coordinates should be client, not screen as
+            // returned by wxGetMousePosition
+            wxWindow *parentTop = m_win;
+            while ( parentTop->GetParent() )
+                parentTop = parentTop->GetParent();
+            wxPoint ptOrig = parentTop->GetPosition();
+            event2.m_x -= ptOrig.x;
+            event2.m_y -= ptOrig.y;
+
+            event2.SetEventObject(m_win);
+
+            // FIXME: we don't fill in the other members - ok?
+
+            m_win->GetEventHandler()->ProcessEvent(event2);
+        }
+        else // can't scroll further, stop
+        {
+            Stop();
+        }
+    }
+}
+#endif
+
+
+// ============================================================================
+// wxVarScrollHelperEvtHandler declaration
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// wxScrollHelperEvtHandler: intercept the events from the window and forward
+// them to wxVarScrollHelperBase
+// ----------------------------------------------------------------------------
+
+class WXDLLEXPORT wxVarScrollHelperEvtHandler : public wxEvtHandler
+{
+public:
+    wxVarScrollHelperEvtHandler(wxVarScrollHelperBase *scrollHelper)
+    {
+        m_scrollHelper = scrollHelper;
+    }
+
+    virtual bool ProcessEvent(wxEvent& event);
 
-    // this one should always be strictly positive
-    m_nVisible = 1;
+private:
+    wxVarScrollHelperBase *m_scrollHelper;
 
-    m_heightTotal = 0;
+    DECLARE_NO_COPY_CLASS(wxVarScrollHelperEvtHandler)
+};
 
+// ============================================================================
+// wxVarScrollHelperEvtHandler implementation
+// ============================================================================
+
+bool wxVarScrollHelperEvtHandler::ProcessEvent(wxEvent& event)
+{
+    wxEventType evType = event.GetEventType();
+
+    // pass it on to the real handler
+    bool processed = wxEvtHandler::ProcessEvent(event);
+
+    // always process the size events ourselves, even if the user code handles
+    // them as well, as we need to AdjustScrollbars()
+    //
+    // NB: it is important to do it after processing the event in the normal
+    //     way as HandleOnSize() may generate a wxEVT_SIZE itself if the
+    //     scrollbar[s] (dis)appear and it should be seen by the user code
+    //     after this one
+    if ( evType == wxEVT_SIZE )
+    {
+        m_scrollHelper->HandleOnSize((wxSizeEvent &)event);
+
+        return !event.GetSkipped();
+    }
+
+    if ( processed )
+    {
+        // normally, nothing more to do here - except if we have a command
+        // event
+        if ( event.IsCommandEvent() )
+        {
+            return true;
+        }
+    }
+
+    // reset the skipped flag to false as it might have been set to true in
+    // ProcessEvent() above
+    event.Skip(false);
+
+    if ( evType == wxEVT_SCROLLWIN_TOP ||
+         evType == wxEVT_SCROLLWIN_BOTTOM ||
+         evType == wxEVT_SCROLLWIN_LINEUP ||
+         evType == wxEVT_SCROLLWIN_LINEDOWN ||
+         evType == wxEVT_SCROLLWIN_PAGEUP ||
+         evType == wxEVT_SCROLLWIN_PAGEDOWN ||
+         evType == wxEVT_SCROLLWIN_THUMBTRACK ||
+         evType == wxEVT_SCROLLWIN_THUMBRELEASE )
+    {
+         m_scrollHelper->HandleOnScroll((wxScrollWinEvent &)event);
+         return !event.GetSkipped();
+    }
+
+    if ( evType == wxEVT_ENTER_WINDOW )
+    {
+        m_scrollHelper->HandleOnMouseEnter((wxMouseEvent &)event);
+    }
+    else if ( evType == wxEVT_LEAVE_WINDOW )
+    {
+        m_scrollHelper->HandleOnMouseLeave((wxMouseEvent &)event);
+    }
+#if wxUSE_MOUSEWHEEL
+    else if ( evType == wxEVT_MOUSEWHEEL )
+    {
+        m_scrollHelper->HandleOnMouseWheel((wxMouseEvent &)event);
+    }
+#endif // wxUSE_MOUSEWHEEL
+
+    return false;
+}
+
+
+// ============================================================================
+// wxVarScrollHelperBase implementation
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// wxVarScrollHelperBase initialization
+// ----------------------------------------------------------------------------
+
+wxVarScrollHelperBase::wxVarScrollHelperBase(wxWindow *win)
+{
+    wxASSERT_MSG( win, _T("associated window can't be NULL in wxVarScrollHelperBase") );
+
 #if wxUSE_MOUSEWHEEL
     m_sumWheelRotation = 0;
 #endif
+
+    m_win =
+    m_targetWindow = (wxWindow *)NULL;
+
+    m_handler = NULL;
+
+    m_win = win;
+
+    m_timerAutoScroll = NULL;
+
+    // by default, the associated window is also the target window
+    DoSetTargetWindow(win);
+
 }
 
+wxVarScrollHelperBase::~wxVarScrollHelperBase()
+{
+    DeleteEvtHandler();
+    StopAutoScrolling();
+}
+
 // ----------------------------------------------------------------------------
-// various helpers
+// wxVarScrollHelperBase various helpers
 // ----------------------------------------------------------------------------
 
-wxCoord wxVScrolledWindow::EstimateTotalHeight() const
+wxCoord wxVarScrollHelperBase::EstimateTotalSize() const
 {
     // estimate the total height: it is impossible to call
     // OnGetLineHeight() for every line because there may be too many of
@@ -81,71 +272,72 @@
     // some in the end and some in the middle
     static const size_t NUM_LINES_TO_SAMPLE = 10;
 
-    wxCoord heightTotal;
+    wxCoord sizeTotal;
     if ( m_lineMax < 3*NUM_LINES_TO_SAMPLE )
     {
         // in this case calculating exactly is faster and more correct than
         // guessing
-        heightTotal = GetLinesHeight(0, m_lineMax);
+        sizeTotal = GetLinesSize(0, m_lineMax);
     }
     else // too many lines to calculate exactly
     {
         // look at some lines in the beginning/middle/end
-        heightTotal =
-            GetLinesHeight(0, NUM_LINES_TO_SAMPLE) +
-                GetLinesHeight(m_lineMax - NUM_LINES_TO_SAMPLE, m_lineMax) +
-                    GetLinesHeight(m_lineMax/2 - NUM_LINES_TO_SAMPLE/2,
-                                   m_lineMax/2 + NUM_LINES_TO_SAMPLE/2);
+        sizeTotal =
+            GetLinesSize(0, NUM_LINES_TO_SAMPLE) +
+                GetLinesSize(m_lineMax - NUM_LINES_TO_SAMPLE,
+                             m_lineMax) +
+                    GetLinesSize(m_lineMax/2 - NUM_LINES_TO_SAMPLE/2,
+                                 m_lineMax/2 + NUM_LINES_TO_SAMPLE/2);
 
         // use the height of the lines we looked as the average
-        heightTotal = (wxCoord)
-                (((float)heightTotal / (3*NUM_LINES_TO_SAMPLE)) * m_lineMax);
+        sizeTotal = (wxCoord)
+                (((float)sizeTotal / (3*NUM_LINES_TO_SAMPLE)) * m_lineMax);
     }
 
-    return heightTotal;
+    return sizeTotal;
 }
 
-wxCoord wxVScrolledWindow::GetLinesHeight(size_t lineMin, size_t lineMax) const
+wxCoord wxVarScrollHelperBase::GetLinesSize(size_t lineMin, size_t lineMax) const
 {
     if ( lineMin == lineMax )
         return 0;
     else if ( lineMin > lineMax )
-        return -GetLinesHeight(lineMax, lineMin);
+        return -GetLinesSize(lineMax, lineMin);
     //else: lineMin < lineMax
 
     // let the user code know that we're going to need all these lines
-    OnGetLinesHint(lineMin, lineMax);
+    OnGetLinesSizeHint(lineMin, lineMax);
 
-    // do sum up their heights
-    wxCoord height = 0;
-    for ( size_t line = lineMin; line < lineMax; line++ )
+    // do sum up their sizes
+    wxCoord size = 0;
+    for ( size_t line = lineMin; line < lineMax; ++line )
     {
-        height += OnGetLineHeight(line);
+        size += OnGetLineSize(line);
     }
 
-    return height;
+    return size;
 }
 
-size_t wxVScrolledWindow::FindFirstFromBottom(size_t lineLast, bool full)
+size_t wxVarScrollHelperBase::FindFirstVisibleFromLast(size_t lineLast, bool full)
 {
-    const wxCoord hWindow = GetClientSize().y;
+    const wxCoord sWindow = GetOrientationTargetSize();
 
     // go upwards until we arrive at a line such that lineLast is not visible
     // any more when it is shown
     size_t lineFirst = lineLast;
-    wxCoord h = 0;
+    wxCoord s = 0;
     for ( ;; )
     {
-        h += OnGetLineHeight(lineFirst);
+        s += OnGetLineSize(lineFirst);
 
-        if ( h > hWindow )
+        if ( s > sWindow )
         {
             // for this line to be fully visible we need to go one line
             // down, but if it is enough for it to be only partly visible then
             // this line will do as well
             if ( full )
             {
-                lineFirst++;
+                ++lineFirst;
             }
 
             break;
@@ -154,79 +346,107 @@
         if ( !lineFirst )
             break;
 
-        lineFirst--;
+        --lineFirst;
     }
 
     return lineFirst;
 }
-
-void wxVScrolledWindow::RemoveScrollbar()
-{
-    m_lineFirst = 0;
-    m_nVisible = m_lineMax;
-    SetScrollbar(wxVERTICAL, 0, 0, 0);
-}
 
-void wxVScrolledWindow::UpdateScrollbar()
+void wxVarScrollHelperBase::UpdateScrollbar()
 {
     // see how many lines can we fit on screen
-    const wxCoord hWindow = GetClientSize().y;
+    const wxCoord sWindow = GetOrientationTargetSize();
 
-    wxCoord h = 0;
+    // do vertical calculations
+    wxCoord s = 0;
     size_t line;
-    for ( line = m_lineFirst; line < m_lineMax; line++ )
+    for ( line = m_lineFirst; line < m_lineMax; ++line )
     {
-        if ( h > hWindow )
+        if ( s > sWindow )
             break;
 
-        h += OnGetLineHeight(line);
+        s += OnGetLineSize(line);
     }
+
+    m_nLinesVisible = line - m_lineFirst;
 
-    // if we still have remaining space below, maybe we can fit everything?
-    if ( h < hWindow )
+    int linesPageSize = m_nLinesVisible;
+    if ( s > sWindow )
     {
-        wxCoord hAll = h;
-        for ( size_t lineFirst = m_lineFirst; lineFirst > 0; lineFirst-- )
-        {
-            hAll += OnGetLineHeight(m_lineFirst - 1);
-            if ( hAll > hWindow )
-                break;
-        }
+        // last line is only partially visible, we still need the scrollbar and
+        // so we have to "fix" pageSize because if it is equal to m_vertLineMax
+        // the scrollbar is not shown at all under MSW
+        --linesPageSize;
+    }
+
+    // set the scrollbar parameters to reflect this
+    m_win->SetScrollbar(GetOrientation(), m_lineFirst, linesPageSize, m_lineMax);
+}
 
-        if ( hAll < hWindow )
+void wxVarScrollHelperBase::RemoveScrollbar()
+{
+    m_lineFirst = 0;
+    m_nLinesVisible = m_lineMax;
+    m_win->SetScrollbar(GetOrientation(), 0, 0, 0);
+}
+
+void wxVarScrollHelperBase::DeleteEvtHandler()
+{
+    // search for m_handler in the handler list
+    if ( m_win && m_handler )
+    {
+        if ( m_win->RemoveEventHandler(m_handler) )
         {
-            // we don't need scrollbar at all
-            RemoveScrollbar();
-            return;
+            delete m_handler;
         }
+        //else: something is very wrong, so better [maybe] leak memory than
+        //      risk a crash because of double deletion
+
+        m_handler = NULL;
     }
+}
 
-    m_nVisible = line - m_lineFirst;
+void wxVarScrollHelperBase::DoSetTargetWindow(wxWindow *target)
+{
+    m_targetWindow = target;
+#ifdef __WXMAC__
+    target->MacSetClipChildren( true ) ;
+#endif
 
-    int pageSize = m_nVisible;
-    if ( h > hWindow )
+    // install the event handler which will intercept the events we're
+    // interested in (but only do it for our real window, not the target window
+    // which we scroll - we don't need to hijack its events)
+    if ( m_targetWindow == m_win )
     {
-        // last line is only partially visible, we still need the scrollbar and
-        // so we have to "fix" pageSize because if it is equal to m_lineMax the
-        // scrollbar is not shown at all under MSW
-        pageSize--;
-    }
+        // if we already have a handler, delete it first
+        DeleteEvtHandler();
 
-    // set the scrollbar parameters to reflect this
-    SetScrollbar(wxVERTICAL, m_lineFirst, pageSize, m_lineMax);
+        m_handler = new wxVarScrollHelperEvtHandler(this);
+        m_targetWindow->PushEventHandler(m_handler);
+    }
 }
 
 // ----------------------------------------------------------------------------
-// operations
+// wxVarScrollHelperBase operations
 // ----------------------------------------------------------------------------
+
+void wxVarScrollHelperBase::SetTargetWindow(wxWindow *target)
+{
+    wxCHECK_RET( target, wxT("target window must not be NULL") );
+
+    if ( target == m_targetWindow )
+        return;
 
-void wxVScrolledWindow::SetLineCount(size_t count)
+    DoSetTargetWindow(target);
+}
+
+void wxVarScrollHelperBase::SetLineCount(size_t count)
 {
     // save the number of lines
     m_lineMax = count;
 
     // and our estimate for their total height
-    m_heightTotal = EstimateTotalHeight();
+    m_sizeTotal = EstimateTotalSize();
 
     // recalculate the scrollbars parameters
     if ( count )
@@ -240,7 +460,7 @@
     }
 }
 
-void wxVScrolledWindow::RefreshLine(size_t line)
+void wxVarScrollHelperBase::RefreshLine(size_t line)
 {
     // is this line visible?
     if ( !IsVisible(line) )
@@ -251,18 +471,30 @@
 
     // calculate the rect occupied by this line on screen
     wxRect rect;
-    rect.width = GetClientSize().x;
-    rect.height = OnGetLineHeight(line);
-    for ( size_t n = GetVisibleBegin(); n < line; n++ )
+    if( GetOrientation() == wxVERTICAL )
+    {
+        rect.width    = GetNonOrientationTargetSize();
+        rect.height    = OnGetLineSize(line);
+    }
+    else if( GetOrientation() == wxHORIZONTAL )
+    {
+        rect.width    = OnGetLineSize(line);
+        rect.height    = GetNonOrientationTargetSize();
+    }
+
+    for ( size_t n = GetVisibleBegin(); n < line; ++n )
     {
-        rect.y += OnGetLineHeight(n);
+        if( GetOrientation() == wxVERTICAL )
+            rect.y += OnGetLineSize(n);
+        else if( GetOrientation() == wxHORIZONTAL )
+            rect.x += OnGetLineSize(n);
     }
 
     // do refresh it
-    RefreshRect(rect);
+    m_targetWindow->RefreshRect(rect);
 }
 
-void wxVScrolledWindow::RefreshLines(size_t from, size_t to)
+void wxVarScrollHelperBase::RefreshLines(size_t from, size_t to)
 {
     wxASSERT_MSG( from <= to, _T("RefreshLines(): empty range") );
 
@@ -271,63 +503,85 @@
     if ( from < GetVisibleBegin() )
         from = GetVisibleBegin();
 
-    if ( to >= GetVisibleEnd() )
+    if ( to > GetVisibleEnd() )
         to = GetVisibleEnd();
-    else
-        to++;
 
     // calculate the rect occupied by these lines on screen
-    wxRect rect;
-    rect.width = GetClientSize().x;
-    for ( size_t nBefore = GetVisibleBegin(); nBefore < from; nBefore++ )
+    int orient_size, nonorient_size, orient_pos;
+    orient_size = nonorient_size = orient_pos = 0;
+
+    nonorient_size = GetNonOrientationTargetSize();
+
+    for ( size_t nBefore = GetVisibleBegin();
+          nBefore < from;
+          nBefore++ )
     {
-        rect.y += OnGetLineHeight(nBefore);
+        orient_pos += OnGetLineSize(nBefore);
     }
 
-    for ( size_t nBetween = from; nBetween < to; nBetween++ )
+    for ( size_t nBetween = from; nBetween <= to; nBetween++ )
+    {
+        orient_size += OnGetLineSize(nBetween);
+    }
+
+    wxRect rect;
+    if(GetOrientation() == wxVERTICAL)
     {
-        rect.height += OnGetLineHeight(nBetween);
+        rect.width    = nonorient_size;
+        rect.height    = orient_size;
+        rect.x        = 0;
+        rect.y        = orient_pos;
+    }
+    else if(GetOrientation() == wxHORIZONTAL)
+    {
+        rect.width    = orient_size;
+        rect.height    = nonorient_size;
+        rect.x        = orient_pos;
+        rect.y        = 0;
     }
 
     // do refresh it
-    RefreshRect(rect);
+    m_targetWindow->RefreshRect(rect);
 }
 
-void wxVScrolledWindow::RefreshAll()
+void wxVarScrollHelperBase::RefreshAll()
 {
     UpdateScrollbar();
 
-    Refresh();
+    m_targetWindow->Refresh();
 }
 
-bool wxVScrolledWindow::Layout()
+bool wxVarScrollHelperBase::ScrollLayout()
 {
-    if ( GetSizer() )
+    if(m_targetWindow->GetSizer() && m_physicalScrolling)
     {
         // adjust the sizer dimensions/position taking into account the
         // virtual size and scrolled position of the window.
 
-        int w, h;
-        GetVirtualSize(&w, &h);
+        int x, y, w, h;
+        x = y = 0;
 
-        // x is always 0 so no variable needed
-        int y = -GetLinesHeight(0, GetFirstVisibleLine());
+        if(GetOrientation() == wxVERTICAL)
+            y = -GetLinesSize(0, GetVisibleBegin());
+        else if(GetOrientation() == wxHORIZONTAL)
+            x = -GetLinesSize(0, GetVisibleBegin());
 
-        GetSizer()->SetDimension(0, y, w, h);
+        m_targetWindow->GetVirtualSize(&w, &h);
+        m_targetWindow->GetSizer()->SetDimension(x, y, w, h);
         return true;
     }
 
     // fall back to default for LayoutConstraints
-    return wxPanel::Layout();
+    return m_targetWindow->wxWindow::Layout();
 }
 
-int wxVScrolledWindow::HitTest(wxCoord WXUNUSED(x), wxCoord y) const
+int wxVarScrollHelperBase::HitTest(wxCoord coord) const
 {
     const size_t lineMax = GetVisibleEnd();
-    for ( size_t line = GetVisibleBegin(); line < lineMax; line++ )
+    for ( size_t line = GetVisibleBegin(); line < lineMax; ++line )
     {
-        y -= OnGetLineHeight(line);
-        if ( y < 0 )
+        coord -= OnGetLineSize(line);
+        if ( coord < 0 )
             return line;
     }
 
@@ -335,10 +589,10 @@
 }
 
 // ----------------------------------------------------------------------------
-// scrolling
+// wxVarScrollHelperBase scrolling
 // ----------------------------------------------------------------------------
 
-bool wxVScrolledWindow::ScrollToLine(size_t line)
+bool wxVarScrollHelperBase::ScrollToLine(size_t line)
 {
     if ( !m_lineMax )
     {
@@ -348,7 +602,7 @@
 
     // determine the real first line to scroll to: we shouldn't scroll beyond
     // the end
-    size_t lineFirstLast = FindFirstFromBottom(m_lineMax - 1, true);
+    size_t lineFirstLast = FindFirstVisibleFromLast(m_lineMax - 1, true);
     if ( line > lineFirstLast )
         line = lineFirstLast;
 
@@ -370,25 +624,43 @@
     // the size of scrollbar thumb could have changed
     UpdateScrollbar();
 
-
     // finally refresh the display -- but only redraw as few lines as possible
-    // to avoid flicker
-    if ( GetVisibleBegin() >= lineLastOld ||
-            GetVisibleEnd() <= lineFirstOld )
+    // to avoid flicker.  We can't do this if we have children because they
+    // won't be scrolled
+    if ( m_targetWindow->GetChildren().GetCount() == 0 &&
+         GetVisibleBegin() >= lineLastOld ||
+         GetVisibleEnd() <= lineFirstOld )
     {
         // the simplest case: we don't have any old lines left, just redraw
         // everything
-        Refresh();
+        m_targetWindow->Refresh();
     }
-    else // overlap between the lines we showed before and should show now
+    else
     {
-        ScrollWindow(0, GetLinesHeight(GetVisibleBegin(), lineFirstOld));
+        // finally, scroll the actual window contents vertically
+        if(m_physicalScrolling)
+        {
+            if(GetOrientation() == wxVERTICAL)
+                m_targetWindow->ScrollWindow(0, GetLinesSize(GetVisibleBegin(),
+                                                             lineFirstOld));
+            else if(GetOrientation() == wxHORIZONTAL)
+                m_targetWindow->ScrollWindow(GetLinesSize(GetVisibleBegin(),
+                                                          lineFirstOld), 0);
+        }
+        else
+        {
+            // we still need to invalidate but we can't use ScrollWindow
+            // because physical scrolling is disabled (the user either didn't
+            // want children scrolled and/or doesn't want pixels to be
+            // physically scrolled).
+            m_targetWindow->Refresh();
+        }
     }
 
     return true;
 }
 
-bool wxVScrolledWindow::ScrollLines(int lines)
+bool wxVarScrollHelperBase::ScrollLines(int lines)
 {
     lines += m_lineFirst;
     if ( lines < 0 )
@@ -397,7 +669,7 @@
     return ScrollToLine(lines);
 }
 
-bool wxVScrolledWindow::ScrollPages(int pages)
+bool wxVarScrollHelperBase::ScrollLinePages(int pages)
 {
     bool didSomething = false;
 
@@ -408,13 +680,13 @@
         {
             line = GetVisibleEnd();
             if ( line )
-                line--;
-            pages--;
+                --line;
+            --pages;
         }
         else // pages < 0
         {
-            line = FindFirstFromBottom(GetVisibleBegin());
-            pages++;
+            line = FindFirstVisibleFromLast(GetVisibleEnd());
+            ++pages;
         }
 
         didSomething = ScrollToLine(line);
@@ -427,52 +699,57 @@
 // event handling
 // ----------------------------------------------------------------------------
 
-void wxVScrolledWindow::OnSize(wxSizeEvent& event)
+void wxVarScrollHelperBase::HandleOnSize(wxSizeEvent& event)
 {
     UpdateScrollbar();
 
     event.Skip();
 }
 
-void wxVScrolledWindow::OnScroll(wxScrollWinEvent& event)
+void wxVarScrollHelperBase::HandleOnScroll(wxScrollWinEvent& event)
 {
-    size_t lineFirstNew;
+    if(GetOrientation() != event.GetOrientation())
+    {
+        event.Skip();
+        return;
+    }
 
+    size_t linesFirstNew;
     const wxEventType evtType = event.GetEventType();
 
     if ( evtType == wxEVT_SCROLLWIN_TOP )
     {
-        lineFirstNew = 0;
+        linesFirstNew = 0;
     }
     else if ( evtType == wxEVT_SCROLLWIN_BOTTOM )
     {
-        lineFirstNew = m_lineMax;
+        linesFirstNew = m_lineMax;
     }
     else if ( evtType == wxEVT_SCROLLWIN_LINEUP )
     {
-        lineFirstNew = m_lineFirst ? m_lineFirst - 1 : 0;
+        linesFirstNew = m_lineFirst ? m_lineFirst - 1 : 0;
     }
     else if ( evtType == wxEVT_SCROLLWIN_LINEDOWN )
     {
-        lineFirstNew = m_lineFirst + 1;
+        linesFirstNew = m_lineFirst + 1;
     }
     else if ( evtType == wxEVT_SCROLLWIN_PAGEUP )
     {
-        lineFirstNew = FindFirstFromBottom(m_lineFirst);
+        linesFirstNew = FindFirstVisibleFromLast(m_lineFirst);
     }
     else if ( evtType == wxEVT_SCROLLWIN_PAGEDOWN )
     {
-        lineFirstNew = GetVisibleEnd();
-        if ( lineFirstNew )
-            lineFirstNew--;
+        linesFirstNew = GetVisibleEnd();
+        if ( linesFirstNew )
+            --linesFirstNew;
     }
     else if ( evtType == wxEVT_SCROLLWIN_THUMBRELEASE )
     {
-        lineFirstNew = event.GetPosition();
+        linesFirstNew = event.GetPosition();
     }
     else if ( evtType == wxEVT_SCROLLWIN_THUMBTRACK )
     {
-        lineFirstNew = event.GetPosition();
+        linesFirstNew = event.GetPosition();
     }
 
     else // unknown scroll event?
@@ -481,17 +758,74 @@
         return;
     }
 
-    ScrollToLine(lineFirstNew);
+    ScrollToLine(linesFirstNew);
 
 #ifdef __WXMAC__
     Update();
 #endif // __WXMAC__
 }
 
+void wxVarScrollHelperBase::DoPrepareDC(wxDC& dc)
+{
+    if(m_physicalScrolling)
+    {
+        wxPoint pt = dc.GetDeviceOrigin();
+        if( GetOrientation() == wxVERTICAL )
+        {
+            dc.SetDeviceOrigin( pt.x,
+                                pt.y - GetLinesSize(0, GetVisibleBegin()) );
+        }
+        else if( GetOrientation() == wxHORIZONTAL )
+        {
+            dc.SetDeviceOrigin( pt.x - GetLinesSize(0, GetVisibleBegin()),
+                                pt.y );
+        }
+    }
+}
+
+void wxVarScrollHelperBase::StopAutoScrolling()
+{
+#if wxUSE_TIMER
+    if ( m_timerAutoScroll )
+    {
+        delete m_timerAutoScroll;
+        m_timerAutoScroll = (wxTimer *)NULL;
+    }
+#endif
+}
+
+bool wxVarScrollHelperBase::SendAutoScrollEvents(wxScrollWinEvent& event) const
+{
+    // only send the event if the window is scrollable in this direction
+    wxWindow *win = (wxWindow *)event.GetEventObject();
+    return win->HasScrollbar(event.GetOrientation());
+}
+
+int wxVarScrollHelperBase::DoCalcScrolledPosition(int coord) const
+{
+    if ( coord )
+        return coord - GetLinesSize(0, GetVisibleBegin());
+    return 0;
+}
+
+int wxVarScrollHelperBase::DoCalcUnscrolledPosition(int coord) const
+{
+    if ( coord )
+        return coord + GetLinesSize(0, GetVisibleBegin());
+    return 0;
+}
+
 #if wxUSE_MOUSEWHEEL
 
-void wxVScrolledWindow::OnMouseWheel(wxMouseEvent& event)
+void wxVarScrollHelperBase::HandleOnMouseWheel(wxMouseEvent& event)
 {
+    // we only want to process wheel events for vertical implementations.
+    // There is no way to determine wheel orientation (and on MSW horizontal
+    // wheel rotation just fakes scroll events, rather than sending a MOUSEWHEEL
+    // event).
+    if(GetOrientation() != wxVERTICAL)
+        return;
+
     m_sumWheelRotation += event.GetWheelRotation();
     int delta = event.GetWheelDelta();
 
@@ -506,8 +840,300 @@
         ScrollLines( units_to_scroll*event.GetLinesPerAction() );
     else
         // scroll pages instead of lines
-        ScrollPages( units_to_scroll );
+        ScrollLinePages( units_to_scroll );
 }
 
-#endif // wxUSE_MOUSEWHEEL
+#endif
+
+void wxVarScrollHelperBase::HandleOnMouseEnter(wxMouseEvent& event)
+{
+    StopAutoScrolling();
+
+    event.Skip();
+}
+
+void wxVarScrollHelperBase::HandleOnMouseLeave(wxMouseEvent& event)
+{
+    // don't prevent the usual processing of the event from taking place
+    event.Skip();
+
+    // when a captured mouse leave a scrolled window we start generate
+    // scrolling events to allow, for example, extending selection beyond the
+    // visible area in some controls
+    if ( wxWindow::GetCapture() == m_targetWindow )
+    {
+        // where is the mouse leaving?
+        int pos, orient;
+        wxPoint pt = event.GetPosition();
+        if ( pt.x < 0 )
+        {
+            orient = wxHORIZONTAL;
+            pos = -1;
+        }
+        else if ( pt.y < 0 )
+        {
+            orient = wxVERTICAL;
+            pos = -1;
+        }
+        else // we're lower or to the right of the window
+        {
+            wxSize size = m_targetWindow->GetClientSize();
+            if ( pt.x > size.x )
+            {
+                orient = wxHORIZONTAL;
+            }
+            else if ( pt.y > size.y )
+            {
+                orient = wxVERTICAL;
+            }
+            else // this should be impossible
+            {
+                // but seems to happen sometimes under wxMSW - maybe it's a bug
+                // there but for now just ignore it
+
+                //wxFAIL_MSG( _T("can't understand where has mouse gone") );
+
+                return;
+            }
+            pos = GetVisibleBegin();
+        }
+
+        // only start the auto scroll timer if the window can be scrolled in
+        // this direction
+        if ( !m_targetWindow->HasScrollbar(orient) )
+            return;
+
+#if wxUSE_TIMER
+        delete m_timerAutoScroll;
+        m_timerAutoScroll = new wxVarAutoScrollTimer
+                                (
+                                    m_targetWindow, this,
+                                    pos == -1 ? wxEVT_SCROLLWIN_LINEUP
+                                              : wxEVT_SCROLLWIN_LINEDOWN,
+                                    pos > 0 ? pos : 0,
+                                    orient
+                                );
+        m_timerAutoScroll->Start(50); // FIXME: make configurable
+#else
+        wxUnusedVar(pos);
+#endif
+    }
+}
+
+
+// ============================================================================
+// wxVarHVScrollHelper implementation
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// wxVarHVScrollHelper operations
+// ----------------------------------------------------------------------------
+
+void wxVarHVScrollHelper::SetRowColumnCount(size_t rowCount, size_t columnCount)
+{
+    SetRowCount(rowCount);
+    SetColumnCount(columnCount);
+}
+
+bool wxVarHVScrollHelper::ScrollToRowColumn(size_t row, size_t column)
+{
+    bool result = false;
+    result |= ScrollToRow(row);
+    result |= ScrollToColumn(column);
+    return result;
+}
+
+void wxVarHVScrollHelper::RefreshRowColumn(size_t row, size_t column)
+{
+    // is this line visible?
+    if ( !IsRowVisible(row) || !IsColumnVisible(column) )
+    {
+        // no, it is useless to do anything
+        return;
+    }
+
+    // calculate the rect occupied by this cell on screen
+    wxRect v_rect, h_rect;
+    v_rect.height = OnGetRowHeight(row);
+    h_rect.width = OnGetColumnWidth(column);
+
+    size_t n;
+
+    for ( n = GetVisibleRowsBegin(); n < row; n++ )
+    {
+        v_rect.y += OnGetRowHeight(n);
+    }
+
+    for ( n = GetVisibleColumnsBegin(); n < column; n++ )
+    {
+        h_rect.x += OnGetColumnWidth(n);
+    }
+
+    // refresh but specialize the behavior if we have a single target window
+    if ( wxVarVScrollHelper::GetTargetWindow() == wxVarHScrollHelper::GetTargetWindow() )
+    {
+        v_rect.x = h_rect.x;
+        v_rect.width = h_rect.width;
+        wxVarVScrollHelper::GetTargetWindow()->RefreshRect(v_rect);
+    }
+    else
+    {
+        v_rect.x = 0;
+        v_rect.width = wxVarVScrollHelper::GetNonOrientationTargetSize();
+        h_rect.y = 0;
+        h_rect.width = wxVarHScrollHelper::GetNonOrientationTargetSize();
+
+        wxVarVScrollHelper::GetTargetWindow()->RefreshRect(v_rect);
+        wxVarHScrollHelper::GetTargetWindow()->RefreshRect(h_rect);
+    }
+}
+
+void wxVarHVScrollHelper::RefreshRowsColumns(size_t fromRow, size_t toRow,
+                                             size_t fromColumn, size_t toColumn)
+{
+    wxASSERT_MSG( fromRow <= toRow || fromColumn <= toColumn,
+        _T("RefreshRowsColumns(): empty range") );
+
+    // clump the range to just the visible lines -- it is useless to refresh
+    // the other ones
+    if ( fromRow < GetVisibleRowsBegin() )
+        fromRow = GetVisibleRowsBegin();
+
+    if ( toRow > GetVisibleRowsEnd() )
+        toRow = GetVisibleRowsEnd();
+
+    if ( fromColumn < GetVisibleColumnsBegin() )
+        fromColumn = GetVisibleColumnsBegin();
+
+    if ( toColumn > GetVisibleColumnsEnd() )
+        toColumn = GetVisibleColumnsEnd();
+
+    // calculate the rect occupied by these lines on screen
+    wxRect v_rect, h_rect;
+    size_t nBefore, nBetween;
+
+    for ( nBefore = GetVisibleRowsBegin();
+          nBefore < fromRow;
+          nBefore++ )
+    {
+        v_rect.y += OnGetRowHeight(nBefore);
+    }
+
+    for ( nBetween = fromRow; nBetween <= toRow; nBetween++ )
+    {
+        v_rect.height += OnGetRowHeight(nBetween);
+    }
+
+    for ( nBefore = GetVisibleColumnsBegin();
+          nBefore < fromColumn;
+          nBefore++ )
+    {
+        h_rect.x += OnGetColumnWidth(nBefore);
+    }
+
+    for ( nBetween = fromColumn; nBetween <= toColumn; nBetween++ )
+    {
+        h_rect.width += OnGetColumnWidth(nBetween);
+    }
+
+    // refresh but specialize the behavior if we have a single target window
+    if ( wxVarVScrollHelper::GetTargetWindow() == wxVarHScrollHelper::GetTargetWindow() )
+    {
+        v_rect.x = h_rect.x;
+        v_rect.width = h_rect.width;
+        wxVarVScrollHelper::GetTargetWindow()->RefreshRect(v_rect);
+    }
+    else
+    {
+        v_rect.x = 0;
+        v_rect.width = wxVarVScrollHelper::GetNonOrientationTargetSize();
+        h_rect.y = 0;
+        h_rect.width = wxVarHScrollHelper::GetNonOrientationTargetSize();
+
+        wxVarVScrollHelper::GetTargetWindow()->RefreshRect(v_rect);
+        wxVarHScrollHelper::GetTargetWindow()->RefreshRect(h_rect);
+    }
+}
+
+wxVSPosition wxVarHVScrollHelper::HitTest(wxCoord x, wxCoord y) const
+{
+    return wxVSPosition(wxVarVScrollHelper::HitTest(y),
+                        wxVarHScrollHelper::HitTest(x));
+}
+
+void wxVarHVScrollHelper::DoPrepareDC(wxDC& dc)
+{
+    wxVarVScrollHelper::DoPrepareDC(dc);
+    wxVarHScrollHelper::DoPrepareDC(dc);
+}
+
+bool wxVarHVScrollHelper::ScrollLayout()
+{
+    bool layout_result = false;
+    layout_result |= wxVarVScrollHelper::ScrollLayout();
+    layout_result |= wxVarHScrollHelper::ScrollLayout();
+    return layout_result;
+}
+
+wxSize wxVarHVScrollHelper::GetRowColumnCount() const
+{
+    return wxSize(GetColumnCount(), GetRowCount());
+}
+
+wxVSPosition wxVarHVScrollHelper::GetVisibleBegin() const
+{
+    return wxVSPosition(GetVisibleRowsBegin(), GetVisibleColumnsBegin());
+}
+
+wxVSPosition wxVarHVScrollHelper::GetVisibleEnd() const
+{
+    return wxVSPosition(GetVisibleRowsEnd(), GetVisibleColumnsEnd());
+}
+
+bool wxVarHVScrollHelper::IsVisible(size_t row, size_t column) const
+{
+    return IsRowVisible(row) && IsColumnVisible(column);
+}
+
+
+// ============================================================================
+// wxVScrolledWindow implementation
+// ============================================================================
+
+IMPLEMENT_ABSTRACT_CLASS(wxVScrolledWindow, wxPanel)
+
+// ----------------------------------------------------------------------------
+// wxHVScrolled Window event tables
+// ----------------------------------------------------------------------------
+
+BEGIN_EVENT_TABLE(wxVScrolledWindow, wxPanel)
+END_EVENT_TABLE()
+
+
+// ============================================================================
+// wxHScrolledWindow implementation
+// ============================================================================
+
+IMPLEMENT_ABSTRACT_CLASS(wxHScrolledWindow, wxPanel)
+
+// ----------------------------------------------------------------------------
+// wxHScrolled Window event tables
+// ----------------------------------------------------------------------------
+
+BEGIN_EVENT_TABLE(wxHScrolledWindow, wxPanel)
+END_EVENT_TABLE()
+
+
+// ============================================================================
+// wxHVScrolled implementation
+// ============================================================================
+
+IMPLEMENT_ABSTRACT_CLASS(wxHVScrolledWindow, wxPanel)
+
+// ----------------------------------------------------------------------------
+// wxHVScrolled Window event tables
+// ----------------------------------------------------------------------------
+
+BEGIN_EVENT_TABLE(wxHVScrolledWindow, wxPanel)
+END_EVENT_TABLE()
 


 	  	 
