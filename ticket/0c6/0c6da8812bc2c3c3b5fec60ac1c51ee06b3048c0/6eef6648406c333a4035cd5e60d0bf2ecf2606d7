? build
? samples
? wxmac-config
? lib/libwx_mac-2.3.so.0
? lib/libwx_mac-2.3.so.0.0.0
? lib/libwx_mac.dylib
? lib/wx
? src/common/lex_yy.c
? src/mac/dirmac.cpp
? src/mac/files.lst
? src/mac/mimetmac.cpp
? src/mac/xpm_hack.c
? src/mac/xpm/imagexpm.c
? src/mac/xpm/miscxpm.c
Index: include/wx/app.h
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/include/wx/app.h,v
retrieving revision 1.38
diff -r1.38 app.h
375c375
< #if !wxUSE_GUI || defined(__WXMOTIF__) || defined(__WXGTK__) || defined(__WXPM__) || (defined(__WXMAC__) && defined(__UNIX__))
---
> #if !wxUSE_GUI || defined(__WXMOTIF__) || defined(__WXGTK__) || defined(__WXPM__)
377a378,380
>         int main(int argc, char *argv[]) { return wxEntry(argc, argv); }
> #elif defined(__WXMAC__) && defined(__UNIX__)
>     #define IMPLEMENT_WXWIN_MAIN \
Index: include/wx/defs.h
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/include/wx/defs.h,v
retrieving revision 1.234
diff -r1.234 defs.h
67,68d66
< #elif defined(applec) || defined(THINK_C) || (defined(__MWERKS__) && !defined(__INTEL__))
<         // MacOS
114a113,116
> 
> #ifdef __WXMAC_X__
> #include <Carbon/Carbon.h>
> #endif
Index: include/wx/spinbutt.h
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/include/wx/spinbutt.h,v
retrieving revision 1.15
diff -r1.15 spinbutt.h
16c16
<     #ifndef __WXMOTIF__ // because there is no matching .cpp for Motif
---
>     #if !defined(__WXMOTIF__) && !defined(__WXMAC__) // because there is no matching .cpp for Motif
Index: include/wx/mac/bitmap.h
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/include/wx/mac/bitmap.h,v
retrieving revision 1.4
diff -r1.4 bitmap.h
36a37
> 
65a67
>   bool PointMasked(int x, int y);
70c72
< enum { kMacBitmapTypeUnknownType , kMacBitmapTypeGrafWorld, kMacBitmapTypePict } ;
---
> enum { kMacBitmapTypeUnknownType , kMacBitmapTypeGrafWorld, kMacBitmapTypePict};
90,93c92,95
< 	int						m_bitmapType ;
< 	PicHandle			m_hPict ;
< 	WXHBITMAP     m_hBitmap;
<   wxMask *      m_bitmapMask; // Optional mask
---
> 	int			m_bitmapType ;
> 	PicHandle	m_hPict ;
> 	WXHBITMAP   m_hBitmap;
>     wxMask *    m_bitmapMask; // Optional mask
155a158,160
>    // get the given part of bitmap
>    wxBitmap GetSubBitmap( const wxRect& rect ) const;
> 
161,165c166,171
<   inline bool Ok() const { return (M_BITMAPDATA && M_BITMAPDATA->m_ok); }
<   inline int GetWidth() const { return (M_BITMAPDATA ? M_BITMAPDATA->m_width : 0); }
<   inline int GetHeight() const { return (M_BITMAPDATA ? M_BITMAPDATA->m_height : 0); }
<   inline int GetDepth() const { return (M_BITMAPDATA ? M_BITMAPDATA->m_depth : 0); }
<   inline int GetQuality() const { return (M_BITMAPDATA ? M_BITMAPDATA->m_quality : 0); }
---
>   bool Ok() const;
>   int GetWidth() const;
>   int GetHeight() const;
>   int GetDepth() const;
>   int GetQuality() const;
> 
172c178
<   inline wxPalette* GetPalette() const { return (M_BITMAPDATA ? (& M_BITMAPDATA->m_bitmapPalette) : (wxPalette*) NULL); }
---
>   wxPalette *GetPalette() const;
175c181
<   inline wxMask *GetMask() const { return (M_BITMAPDATA ? M_BITMAPDATA->m_bitmapMask : (wxMask*) NULL); }
---
>   wxMask *GetMask() const;
178,180c184,189
<   inline wxBitmap& operator = (const wxBitmap& bitmap) { if (*this == bitmap) return (*this); Ref(bitmap); return *this; }
<   inline bool operator == (const wxBitmap& bitmap) { return m_refData == bitmap.m_refData; }
<   inline bool operator != (const wxBitmap& bitmap) { return m_refData != bitmap.m_refData; }
---
>   inline wxBitmap& operator = (const wxBitmap& bitmap)
>     { if (*this == bitmap) return (*this); Ref(bitmap); return *this; }
>   inline bool operator == (const wxBitmap& bitmap)
>     { return m_refData == bitmap.m_refData; }
>   inline bool operator != (const wxBitmap& bitmap)
>     { return m_refData != bitmap.m_refData; }
197a207
>   int GetBitmapType() const;
199,200c209,212
<   inline WXHBITMAP GetHBITMAP() const { return (M_BITMAPDATA ? M_BITMAPDATA->m_hBitmap : 0); }
<   
---
>   WXHBITMAP GetHBITMAP() const;
> 
>   PicHandle GetPict() const;
> 
202a215
> 
Index: include/wx/mac/setup.h
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/include/wx/mac/setup.h,v
retrieving revision 1.13
diff -r1.13 setup.h
1,10c1,5
< /////////////////////////////////////////////////////////////////////////////
< // Name:        setup.h
< // Purpose:     Configuration for the library
< // Author:      Stefan Csomor
< // Modified by: Stefan Csomor
< // Created:     ??/??/98
< // RCS-ID:      $Id: setup.h,v 1.13 2001/01/26 20:16:12 depeyrot Exp $
< // Copyright:   (c) AUTHOR
< // Licence:   	wxWindows licence
< /////////////////////////////////////////////////////////////////////////////
---
> /* setup.h.  Generated automatically by configure.  */
> /* This define (__WX_SETUP_H__) is used both to insure setup.h is included
>  * only once and to indicate that we are building using configure. */
> #ifndef __WX_SETUP_H__
> #define __WX_SETUP_H__
12,21c7,9
< #ifndef _WX_SETUP_H_
< #define _WX_SETUP_H_
< 
< /*
<  * General features
<  *
<  */
<  
< #define wxUSE_GEOMETRY 1
< #define WORDS_BIGENDIAN 1
---
> #ifdef __GNUG__
> #pragma interface
> #endif
23,24c11,12
< #define wxUSE_CONFIG           1
<                                 // Use wxConfig, with CreateConfig in wxApp
---
> /* never undefine inline or const keywords for C++ compilation */
> #ifndef __cplusplus
26,46c14,15
< #define WXWIN_COMPATIBILITY  0
<                                 // Compatibility with 1.66 API.
<                                 // Level 0: no backward compatibility, all new features
<                                 // Level 1: wxDC, OnSize (etc.) compatibility, but
<                                 //          some new features such as event tables
< #define wxUSE_POSTSCRIPT  0
<                         	// 0 for no PostScript device context
< #define wxUSE_AFM_FOR_POSTSCRIPT 0
<                                 // 1 to use font metric files in GetTextExtent
< #define wxUSE_METAFILE    1
<                                 // 0 for no Metafile and metafile device context
< #define wxUSE_IPC         0
<                                 // 0 for no interprocess comms
< #define wxUSE_HELP        1
<                                 // 0 for no help facility
< #define wxUSE_RESOURCES   1
<                         	// 0 for no wxGetResource/wxWriteResource
< #define wxUSE_CONSTRAINTS       1
<                                 // Use constraints mechanism
< #define wxUSE_TIMEDATE    1
<                                 // 0 for no wxTime/wxDate classes
---
> /* Define to empty if the keyword does not work.  */
> /* #undef const */
48,49c17,18
< #define wxUSE_CLIPBOARD   1
<                                 // 0 for no clipboard functions
---
> /* Define as __inline if that's what the C compiler calls it.  */
> /* #undef inline */
51,52c20
< #define wxUSE_SPLINES     1
<                                     // 0 for no splines
---
> #endif /* __cplusplus */
54,55c22,23
< #define wxUSE_DRAG_AND_DROP 0
<                                 // 0 for no drag and drop
---
> /* fill in with the string wxGetOsDescription() will return */
> #define WXWIN_OS_DESCRIPTION "Darwin 1.2 Power Macintosh"
57,75c25,26
< #define wxUSE_TOOLBAR       1
< #define wxUSE_TOOLBAR_NATIVE       1
<                                     // Define 1 to use toolbar classes
< #define wxUSE_BUTTONBAR     1
<                                     // Define 1 to use buttonbar classes (enhanced toolbar
<                                     // for MS Windows)
< #define wxUSE_GAUGE         1
<                                     // Define 1 to use Microsoft's gauge (Windows)
<                                     // or Bull's gauge (Motif) library (both in contrib).
< #define wxUSE_COMBOBOX      1
<                                     // Define 1 to use COMBOXBOX control (Windows)
<                                     // or FWW's ComboBox widget (Motif).
< #define wxUSE_CHOICE      1
<                                     // Define 1 to use CHOICE
< 
< #define wxUSE_RADIOBUTTON   1
<                                     // Define 1 to use radio button control
< #define wxUSE_RADIOBTN   1
<                                     // Unfortunately someone introduced this one, too
---
> /* Define to `int' if <sys/types.h> doesn't define.  */
> /* #undef gid_t */
77,78c28,29
< #define wxUSE_SCROLLBAR   1
<                                     // Define 1 to compile contributed wxScrollBar class
---
> /* Define if you don't have vprintf but do have _doprnt.  */
> /* #undef HAVE_DOPRNT */
80,84c31,32
< #define wxUSE_CHECKBOX 1
<                                     // Define 1 to compile checkbox
< 
< #define wxUSE_LISTBOX 1
<                                     // Define 1 to compile listbox
---
> /* Define if you have the vprintf function.  */
> #define HAVE_VPRINTF 1
86,87c34,35
< #define wxUSE_SPINBTN 1
<                                     // Define 1 to compile spin button
---
> /* Define to `int' if <sys/types.h> doesn't define.  */
> /* #undef mode_t */
89,90c37,38
< // use wxStaticLine class (separator line in the dialog)?
< #define wxUSE_STATLINE 1
---
> /* Define to `long' if <sys/types.h> doesn't define.  */
> /* #undef off_t */
92,93c40,41
< #define wxUSE_CHECKLISTBOX 1
<                                     // Define 1 to compile check listbox
---
> /* Define to `int' if <sys/types.h> doesn't define.  */
> /* #undef pid_t */
95,96c43,44
< #define wxUSE_CHOICE 1
<                                     // Define 1 to compile choice
---
> /* Define to `unsigned' if <sys/types.h> doesn't define.  */
> /* #undef size_t */
98,117c46,47
< #define wxUSE_CARET       1
<                                     // Define 1 to use wxCaret class
< #define wxUSE_XPM_IN_MSW  1
<                                     // Define 1 to support the XPM package in wxBitmap.
< #define wxUSE_IMAGE_LOADING_IN_MSW        1
<                                   // Use dynamic DIB loading/saving code in utils/dib under MSW.
< #define wxUSE_RESOURCE_LOADING_IN_MSW     1
<                                   // Use dynamic icon/cursor loading/saving code
<                                   // under MSW.
< #define wxUSE_WX_RESOURCES        1
<                                   // Use .wxr resource mechanism (requires PrologIO library)
< 
< // support for startup tips (wxShowTip &c)
< #define wxUSE_STARTUP_TIPS       1
< 
< // BC++/Win16 can't cope with the amount of data in resource.cpp
< #if defined(__WIN16__) && defined(__BORLANDC__)
< #undef wxUSE_WX_RESOURCES
< #define wxUSE_WX_RESOURCES        0
< #endif
---
> /* Define if you have the ANSI C header files.  */
> #define STDC_HEADERS 1
119,151c49,50
< #define wxUSE_DOC_VIEW_ARCHITECTURE 1
<                                   // Set to 0 to disable document/view architecture
< #define wxUSE_MDI_ARCHITECTURE  1
<                                   // Set to 0 to disable MDI document/view architecture
< #define wxUSE_PRINTING_ARCHITECTURE  1
<                                     // Set to 0 to disable print/preview architecture code
< #define wxUSE_POSTSCRIPT_ARCHITECTURE_IN_MSW 1
<                                     // Set to 0 to disable PostScript print/preview architecture code
<                                     // under Windows (just use Windows printing).
< #define wxUSE_DYNAMIC_CLASSES     1
<                                   // If 1, enables provision of run-time type information.
<                                   // NOW MANDATORY: don't change.
< #define wxUSE_MEMORY_TRACING      1
<                                   // If 1, enables debugging versions of wxObject::new and
<                                   // wxObject::delete *IF* __WXDEBUG__ is also defined.
<                                   // WARNING: this code may not work with all architectures, especially
<                                   // if alignment is an issue.
< #ifndef __MWERKS__
< #define wxUSE_DEBUG_CONTEXT       0
< #else
< #define wxUSE_DEBUG_CONTEXT       1
< #endif
<                                   // If 1, enables wxDebugContext, for
<                                   // writing error messages to file, etc. 
<                                   // If __WXDEBUG__ is not defined, will still use
<                                   // normal memory operators.
<                                   // It's recommended to set this to 1,
<                                   // since you may well need to output
<                                   // an error log in a production
<                                   // version (or non-debugging beta)
< #define wxUSE_GLOBAL_MEMORY_OPERATORS 0
<                                   // In debug mode, cause new and delete to be redefined globally.
<                                   // If this causes problems (e.g. link errors), set this to 0.
---
> /* Define to `int' if <sys/types.h> doesn't define.  */
> /* #undef uid_t */
153,158c52,54
< #define wxUSE_DEBUG_NEW_ALWAYS 1
<                                   // In debug mode, causes new to be defined to
<                                   // be WXDEBUG_NEW (see object.h).
<                                   // If this causes problems (e.g. link errors), set this to 0.
<                                   // You may need to set this to 0 if using templates (at least
<                                   // for VC++).
---
> /* Define if your processor stores words with the most significant
>    byte first (like Motorola and SPARC, unlike Intel and VAX).  */
> #define WORDS_BIGENDIAN 1
160,162c56,57
< #define REMOVE_UNUSED_ARG 1
<                                   // Set this to 0 if your compiler can't cope
<                                   // with omission of prototype parameters.
---
> /* Define if the X Window System is missing or not being used.  */
> #define X_DISPLAY_MISSING 1
164,165c59,60
< #define wxUSE_ODBC                   1
<                                     // Define 1 to use ODBC classes
---
> /* Define if lex declares yytext as a char * by default, not a char[].  */
> /* #undef YYTEXT_POINTER */
166a62,63
> /* Define this if your version of GTK+ is greater than 1.2 */
> /* #undef __WXGTK12__ */
168,174c65,66
< #define wxODBC_FWD_ONLY_CURSORS   1
<                                   // Some databases/ODBC drivers only allow forward scrolling cursors.
<                                   // Unless you specifically want to use backward scrolling
<                                   // cursors, and you know that all of the databases/ODBC drivers
<                                   // that you will use these odbc classes with allow backward 
<                                   // scrolling cursors, this setting should remain set to 1
<                                   // for maximum database/driver compatibilty
---
> /* Define this if your version of GTK+ is greater than 1.2.7 */
> /* #undef __WXGTK127__ */
175a68,69
> /* Define this if your version of GTK+ is greater than 1.3 */
> /* #undef __WXGTK20__ */
176a71,74
> /*
>  * Define to 1 for Unix[-like] system
>  */
> #define wxUSE_UNIX 1
178,181c76,99
< #ifndef __MWERKS__
< #define wxUSE_IOSTREAMH     0
< #else
< #define wxUSE_IOSTREAMH     1
---
> #define __UNIX__ 1
> /* #undef __LINUX__ */
> /* #undef __SGI__ */
> /* #undef __HPUX__ */
> /* #undef __SYSV__ */
> /* #undef __SVR4__ */
> /* #undef __AIX__ */
> /* #undef __SUN__ */
> /* #undef __SOLARIS__ */
> /* #undef __SUNOS__ */
> /* #undef __ALPHA__ */
> /* #undef __OSF__ */
> #define __BSD__ 1
> /* #undef __FREEBSD__ */
> /* #undef __NETBSD__ */
> /* #undef __VMS__ */
> /* #undef __ULTRIX__ */
> /* #undef __DATA_GENERAL__ */
> /* #undef __EMX__ */
> /* #undef _GNU_SOURCE */
> 
> /* Stupid hack; __WINDOWS__ clashes with wx/defs.h */
> #ifndef __WINDOWS__
> /* #undef __WINDOWS__ */
183,185d100
<                                   // VC++ 4.2 and above allows <iostream> and <iostream.h>
<                                   // but you can't mix them. Set to 1 for <iostream.h>,
<                                   // 0 for <iostream>
187,188c102,111
< #define wxUSE_STREAMS       1
<                                   // If enabled (1), compiles wxWindows streams classes
---
> /* #undef __WIN95__ */
> /* #undef __WIN32__ */
> /* #undef __GNUWIN32__ */
> /* #undef STRICT */
> /* #undef WINVER */
> 
> /* enable native status bar under Win32 */
> #ifdef __WIN95__
> #define wxUSE_NATIVE_STATUSBAR 1
> #endif
190,191c113,115
< #ifndef __MWERKS__
< #define wxUSE_STD_IOSTREAM     0
---
> /* enable rich edit under Win32 */
> #if defined(__WIN95__) && !defined(__TWIN32__) && !defined(__GNUWIN32_OLD__)
> #define wxUSE_RICHEDIT 1
193,195c117
< #define wxUSE_STD_IOSTREAM  1
<                                   // Use standard C++ streams if 1. If 0, use wxWin
<                                   // streams implementation.
---
> #define wxUSE_RICHEDIT 0
198,240d119
< #define wxUSE_WXCONFIG      1
<                                   // if enabled, compiles built-in OS independent wxConfig
<                                   // class and it's file (any platform) and registry (Win)
<                                   // based implementations
< #define wxUSE_THREADS       1
<                                   // support for multithreaded applications: if
<                                   // 1, compile in thread classes (thread.h)
<                                   // and make the library thread safe
< #define wxUSE_ZLIB          1
<                                   // Use zlib for compression in streams and PNG code
< #define wxUSE_LIBPNG        1
<                                   // Use PNG bitmap code
< #define wxUSE_LIBJPEG       1
<                                   // Use JPEG bitmap code
< #define wxUSE_LIBTIFF		1                                  
<                                   // Use TIFF bitmap code
< #define wxUSE_GIF			1
< 									// Use GIF bitmap code
<                                   
< #define wxUSE_SERIAL        0
<                                   // Use serialization (requires utils/serialize)
< #define wxUSE_DYNLIB_CLASS  0
<                                   // Compile in wxLibrary class for run-time
<                                   // DLL loading and function calling
< #define wxUSE_TOOLTIPS      1
<                                   // Define to use wxToolTip class and
<                                   // wxWindow::SetToolTip() method
< #define wxUSE_SOCKETS       1 // 0
<                                   // Set to 1 to use socket classes
< #define wxUSE_HTML          1 // 0
<                                   // Set to 1 to use wxHTML sub-library
< #define wxUSE_FILESYSTEM    1 
<                                  
< #define wxUSE_FS_ZIP        1 // 0
< #define wxUSE_FS_INET       1 // 0     // Set to 1 to enable virtual file systems
< 
< #define wxUSE_BUSYINFO      1 // 0
<                                   // wxBusyInfo displays window with message
<                                   // when app is busy. Works in same way as
<                                   // wxBusyCursor
< #define wxUSE_ZIPSTREAM     1 // 0
<                                   // input stream for reading from zip archives
< 
242,243c121
<  * Finer detail
<  *
---
>  * Supports bool type
244a123
> #define HAVE_BOOL 1
246,252c125,167
< #define wxUSE_APPLE_IEEE          1
<                                 // if enabled, the float codec written by Apple
<                                 // will be used to write, in a portable way,
<                                 // float on the disk
< 
< // use wxFile class - required by i18n code, wxConfig and others - recommended
< #define wxUSE_FILE                1
---
> /*
>  * Use zlib
>  */
> #define wxUSE_ZLIB 1
> /*
>  * Use libpng
>  */
> #define wxUSE_LIBPNG 1
> /*
>  * Use libjpeg
>  */
> #define wxUSE_LIBJPEG 1
> /*
>  * Use libtiff
>  */
> #define wxUSE_LIBTIFF 1
> /*
>  * Use iODBC
>  */
> #define wxUSE_ODBC 0
> #define wxODBC_FWD_ONLY_CURSORS 1
> #define wxODBC_BACKWARD_COMPATABILITY 0
> /*
>  * Use freetype
>  */
> #define wxUSE_FREETYPE 0
> /*
>  * Use Threads
>  */
> #define wxUSE_THREADS 1
> /*
>  * Have glibc2
>  */
> #define wxHAVE_GLIBC2 0
> /*
>  * Use libXpm
>  */
> #define wxHAVE_LIB_XPM 0
> /*
>  * Use OpenGL
>  */
> #define wxUSE_OPENGL 0
> #define wxUSE_GLCANVAS 0
254,255c169,176
< // use wxTextFile class: requires wxFile, required by wxConfig
< #define wxUSE_TEXTFILE            1
---
> /*
>  * Use GUI
>  */
> #define wxUSE_GUI 1
> /*
>  * Don't use GUI (defined to 1 when compiling/using base only)
>  */
> #define wxUSE_NOGUI 0
257,258c178,181
< // i18n support: _() macro, wxLocale class. Requires wxTextFile.
< #define wxUSE_INTL                1
---
> /*
>  * Catch fatal program exceptions
>  */
> #define wxUSE_ON_FATAL_EXCEPTION 1
260,261c183,186
< // wxLogXXX functions - highly recommended
< #define wxUSE_LOG                   1
---
> /*
>  * Use constraints mechanism
>  */
> #define wxUSE_CONSTRAINTS 1
263c188,190
< // wxValidator class
---
> /*
>  * Use validators
>  */
266c193,195
< // wxAcceleratorTable/Entry classes and support for them in wxMenu(Bar)
---
> /*
>  * Use accelerators
>  */
269,272c198,200
< // wxSashWindow class
< #define wxUSE_SASH 1
< 
< // text entry dialog and wxGetTextFromUser function
---
> /*
>  * Use wxTextEntryDialog
>  */
275,276c203,206
< // wxStatusBar class
< #define wxUSE_STATUSBAR 1
---
> /*
>  * Use startup tips
>  */
> #define wxUSE_STARTUP_TIPS 1
278c208,210
< // progress dialog class for lengthy operations
---
> /*
>  * Use progress dialog
>  */
281c213,215
< // wxDirDlg class for getting a directory name from user
---
> /*
>  * Use directory chooser dialog
>  */
285,286c219,321
<  * MS Windows/Windows NT
<  *
---
>  * Joystick support (Linux/GTK only)
>  */
> #define wxUSE_JOYSTICK 0
> 
> /*
>  * Use this control
>  */
> #define wxUSE_CARET 1
> /*
>  * Use this control
>  */
> #define wxUSE_BMPBUTTON 1
> /*
>  * Use this control
>  */
> #define wxUSE_CHECKBOX 1
> /*
>  * Use this control
>  */
> #define wxUSE_CHECKLISTBOX 1
> /*
>  * Use this control
>  */
> #define wxUSE_COMBOBOX 1
> /*
>  * Use this control
>  */
> #define wxUSE_CHOICE 1
> /*
>  * Use this control
>  */
> #define wxUSE_GAUGE 1
> /*
>  * Use this control
>  */
> #define wxUSE_GRID 1
> /*
>  * Use this control
>  */
> #define wxUSE_NEW_GRID 1
> /*
>  * Use the new prototype wxGrid classes
>  * (wxUSE_GRID must also be defined)
>  */
> #define wxUSE_IMAGLIST 1
> /*
>  * Use this control
>  */
> #define wxUSE_LISTBOX 1
> /*
>  * Use this control
>  */
> #define wxUSE_LISTCTRL 1
> /*
>  * Use this control
>  */
> #define wxUSE_NOTEBOOK 1
> /*
>  * Use this control
>  */
> #define wxUSE_RADIOBOX 1
> /*
>  * Use this control
>  */
> #define wxUSE_RADIOBTN 1
> /*
>  * Use this control
>  */
> #define wxUSE_SASH 1
> /*
>  * Use this control
>  */
> #define wxUSE_SCROLLBAR 1
> /*
>  * Use this control
>  */
> #define wxUSE_SLIDER 1
> /*
>  * Use this control
>  */
> #define wxUSE_SPINBTN 1
> /*
>  * Use this control
>  */
> #define wxUSE_SPINCTRL 0
> /*
>  * Use this control
>  */
> #define wxUSE_SPLITTER 1
> /*
>  * Use this control
>  */
> #define wxUSE_STATBMP 1
> /*
>  * Use this control
>  */
> #define wxUSE_STATBOX 1
> /*
>  * Use this control
>  */
> #define wxUSE_STATLINE 1
> /*
>  * Use this control
287a323,333
> #define wxUSE_STATUSBAR 1
> /*
>  * Use this control
>  */
> #define wxUSE_TOGGLEBTN 1
> /*
>  * Use Tab dialog class - obsolete, use wxNotebook instead
>  */
> #define wxUSE_TAB_DIALOG 0
> /* compatibility */
> #define wxUSE_TABDIALOG wxUSE_TAB_DIALOG
289,290c335,338
< #define wxUSE_OLE           1
<                                 // drag-and-drop, clipboard, OLE Automation
---
> /*
>  * Use wxToollBar
>  */
> #define wxUSE_TOOLBAR 1
292,297c340,355
< #if defined(__WIN95__)
< #define wxUSE_CTL3D                      0
< #else
< #define wxUSE_CTL3D                      1
<                                     // Define 1 to use Microsoft CTL3D library.
<                                     // See note above about using FAFA and CTL3D.
---
> /*
>  * If 1, use the native toolbar, otherwise use the generic version
>  * (wxToolBarSimple) which may also be use together with the native one.
>  */
> #define wxUSE_TOOLBAR_NATIVE 1
> 
> /*
>  * Use generic wxToolBar instead of/together with the native one?
>  */
> #define wxUSE_TOOLBAR_SIMPLE 1
> 
> #if defined(__WXWINE__) || defined(__GNUWIN32__) || defined(__WXPM__)
> #define wxUSE_OWNER_DRAWN 1
>   #if wxUSE_TOOLBAR
>     #define wxUSE_BUTTONBAR 1
>   #endif
300,332c358,361
< #define wxUSE_COMMON_DIALOGS         1
<                                     // On rare occasions (e.g. using DJGPP) may want
<                                     // to omit common dialogs
<                                     // (e.g. file selector, printer dialog).
<                                     // Switching this off also switches off
<                                     // the printing architecture and interactive
<                                     // wxPrinterDC.
< #define wxUSE_ITSY_BITSY             1
<                                     // Define 1 to use Microsoft's ItsyBitsy
<                                     // small title bar library, for wxMiniFrame
< #define wxUSE_BITMAP_MESSAGE         1
<                                     // Define 1 to use bitmap messages.
< #define wxUSE_PORTABLE_FONTS_IN_MSW  0
<                                     // Define 1 to use new portable font scheme in Windows
<                                     // (used by default under X)
< #define wxFONT_SIZE_COMPATIBILITY    0
<                                     // Define 1 for font size to be backward compatible
<                                     // to 1.63 and earlier. 1.64 and later define point
<                                     // sizes to be compatible with Windows.
< #define wxUSE_GENERIC_DIALOGS_IN_MSW 1
<                                     // Define 1 to use generic dialogs in Windows, even though
<                                     // they duplicate native common dialog (e.g. wxColourDialog)
< #define wxUSE_PENWINDOWS 0
<                                     // Set to 1 to use PenWindows
< 
< #define wxUSE_OWNER_DRAWN             0
<                                     // Owner-drawn menus and listboxes
< 
< #define wxUSE_NATIVE_STATUSBAR        1
<                                     // Set to 0 to use cross-platform wxStatusBar
< #define wxUSE_DBWIN32                 1
<                                     // Use Andrew Tucker's OutputDebugString implementation
<                                     // (required on Win95 only). See utils.cpp.
---
> /*
>  * Use this control
>  */
> #define wxUSE_TREECTRL 1
335c364,455
<  * Any platform
---
>  * Use wxLongLong (a.k.a. int64) class
>  */
> #define wxUSE_LONGLONG 1
> 
> /*
>  * Use geometry classes
>  */
> #define wxUSE_GEOMETRY 1
> 
> /*
>  * Use wxFile class
>  */
> #define wxUSE_FILE 1
> 
> /*
>  * Use wxTextFile class
>  */
> #define wxUSE_TEXTFILE 1
> 
> /*
>  * Use log classes and logging functions
>  */
> #define wxUSE_LOG 1
> /*
>  * Use time and date classes
>  */
> #define wxUSE_TIMEDATE 1
> /*
>  * Use wave class
>  */
> #define wxUSE_WAVE 0
> /*
>  * Use config system
>  */
> #define wxUSE_CONFIG 1
> /*
>  * Use intl system
>  */
> #define wxUSE_INTL 1
> /*
>  * Use streams
>  */
> #define wxUSE_STREAMS 1
> /*
>  * Use class serialization
>  */
> #define wxUSE_SERIAL 0
> /*
>  * Use sockets
>  */
> #define wxUSE_SOCKETS 1
> /*
>  * Use dialup manager
>  */
> #define wxUSE_DIALUP_MANAGER 1
> /*
>  * Use standard C++ streams if 1. If 0, use wxWin
>  * streams implementation.
>  */
> #define wxUSE_STD_IOSTREAM  0
> /*
>  * wxLibrary class
>  */
> #define wxUSE_DYNLIB_CLASS 0
> 
> /*
>  * Use font metric files in GetTextExtent for wxPostScriptDC
>  * Use consistent PostScript fonts for AFM and printing (!)
>  */
> #define wxUSE_AFM_FOR_POSTSCRIPT 1
> #define wxUSE_NORMALIZED_PS_FONTS 1
> 
> /* compatibility */
> #define WX_NORMALIZED_PS_FONTS wxUSE_NORMALIZED_PS_FONTS
> 
> /*
>  * Use PostScript device context
>  */
> #define wxUSE_POSTSCRIPT 1
> 
> /*
>  * Compile wxString with some Unicode (wide character) support?
>  */
> #define wxUSE_WCHAR_T 0
> 
> /*
>  * Compile wxWindows in Unicode mode (Win32 only for now)?
>  */
> #define wxUSE_UNICODE 0
> 
> /*
>  * Work around a bug in GNU libc 5.x wcstombs() implementation.
336a457,459
>  * Note that you must link your programs with libc.a if you enable this and you
>  * have libc 5 (you should enable this for libc6 where wcsrtombs() is
>  * thread-safe version of wcstombs()).
337a461
> #define wxUSE_WCSRTOMBS 0
339,344c463,468
< #define wxUSE_TYPEDEFS               1
<                                     // Use typedefs not classes for wxPoint
<                                     // and others, to reduce overhead and avoid
<                                     // MS C7 memory bug. Bounds checker
<                                     // complains about deallocating
<                                     // arrays of wxPoints if wxPoint is a class.
---
> /*
>  * Use the new experimental implementation of wxString::Printf()?
>  *
>  * Warning: enabling this may cause internal compiler errors with gcc!
>  */
> #define wxUSE_EXPERIMENTAL_PRINTF 0
345a470,497
> /*
>  * Use Interprocess communication
>  */
> #define wxUSE_IPC 1
> /*
>  * Use wxGetResource & wxWriteResource (change .Xdefaults)
>  */
> #define wxUSE_X_RESOURCES 0
> /*
>  * Use clipboard
>  */
> #define wxUSE_CLIPBOARD 1
> /*
>  * Use tooltips
>  */
> #define wxUSE_TOOLTIPS 1
> /*
>  * Use dnd
>  */
> #define wxUSE_DRAG_AND_DROP 0
> /*
>  * Use spline
>  */
> #define wxUSE_SPLINES 1
> /*
>  * Use wxLibrary class
>  */
> #define wxUSE_DYNLIB_CLASS 0
347,348c499,820
< #endif
<     // _WX_SETUP_H_
---
> /*
>  * Use the mdi architecture
>  */
> #define wxUSE_MDI_ARCHITECTURE 1
> /*
>  * Use the document/view architecture
>  */
> #define wxUSE_DOC_VIEW_ARCHITECTURE 1
> /*
>  * Use the print/preview architecture
>  */
> #define wxUSE_PRINTING_ARCHITECTURE 1
> 
> #define wxCOMPATIBILITY_WITH_PRINTSETUPDATA 1
> 
> /*
>  * Use Prolog IO
>  */
> #define wxUSE_PROLOGIO 1
> /*
>  * Use wxWindows resource loading (.wxr-files) (Needs wxUSE_PROLOGIO 1)
>  */
> #define wxUSE_RESOURCES 1
> 
> /* for compatibility */
> #define wxUSE_WX_RESOURCES wxUSE_RESOURCES
> 
> /*
>  * Use wxWindows help facility (needs wxUSE_IPC 1)
>  */
> #define wxUSE_HELP 1
> /*
>  * Use iostream.h rather than iostream
>  */
> #define wxUSE_IOSTREAMH 1
> /*
>  * Use Apple Ieee-double converter
>  */
> #define wxUSE_APPLE_IEEE 1
> /*
>  * Compatibility with 2.0 API.
>  */
> #define WXWIN_COMPATIBILITY_2 1
> /*
>  * Enables debugging: memory tracing, assert, etc., contains debug level
>  */
> #define WXDEBUG 0
> /*
>  * Enables debugging version of wxObject::new and wxObject::delete (IF WXDEBUG)
>  * WARNING: this code may not work with all architectures, especially
>  * if alignment is an issue.
>  */
> #define wxUSE_MEMORY_TRACING 0
> /*
>  * Enable debugging version of global memory operators new and delete
>  * Disable it, If this causes problems (e.g. link errors)
>  */
> #define wxUSE_DEBUG_NEW_ALWAYS 0
> /*
>  * VZ: What does this one do? (FIXME)
>  */
> #define wxUSE_DEBUG_CONTEXT 0
> /*
>  * In debug mode, causes new to be defined to
>  * be WXDEBUG_NEW (see object.h). If this causes
>  * problems (e.g. link errors), set this to 0.
>  */
> #define wxUSE_GLOBAL_MEMORY_OPERATORS 0
> /*
>  * Matthews garbage collection (used for MrEd?)
>  */
> #define WXGARBAGE_COLLECTION_ON 0
> /*
>  * Use splines
>  */
> #define wxUSE_SPLINES 1
> /*
>  * wxUSE_DYNAMIC_CLASSES is TRUE for the Xt port
>  */
> #define wxUSE_DYNAMIC_CLASSES 1
> 
> /*
>  * Support for metafiles
>  */
> #define wxUSE_METAFILE 0
> #define wxUSE_ENH_METAFILE 0
> 
> /*
>  * wxMiniFrame
>  */
> #define wxUSE_MINIFRAME 1
> 
> /*
>  * wxHTML
>  */
> #define wxUSE_HTML 1
> 
> /*
>  * (virtual) filesystems code
>  */
> #define wxUSE_FILESYSTEM 1
> #define wxUSE_FS_INET 1
> #define wxUSE_FS_ZIP 1
> 
> /*
>  * A class that shows info window when app is busy
>  * (works exactly like wxBusyCursor)
>  */
> #define wxUSE_BUSYINFO 1
> 
> /*
>  * Zip stream for accessing files stored inside .zip archives
>  */
> #define wxUSE_ZIPSTREAM 1
> 
> /*
>  * GIF image format support
>  */
> #define wxUSE_GIF 1
> 
> /*
>  * PCX image format support
>  */
> #define wxUSE_PCX 1
> 
> /*
>  * PNM image format support
>  */
> #define wxUSE_PNM 1
> 
> /*
>  * Disable this if your compiler can't cope
>  * with omission of prototype parameters.
>  */
> #define REMOVE_UNUSED_ARG 1
> /*
>  * The const keyword is being introduced more in wxWindows.
>  * You can use this setting to maintain backward compatibility.
>  * If 0: will use const wherever possible.
>  * If 1: will use const only where necessary
>  *       for precompiled headers to work.
>  * If 2: will be totally backward compatible, but precompiled
>  *       headers may not work and program size will be larger.
>  */
> #define CONST_COMPATIBILITY 0
> 
> /* define with the name of timezone variable */
> #define WX_TIMEZONE timezone
> 
> /* The type of 3rd argument to getsockname() - usually size_t or int */
> #define SOCKLEN_T int
> 
> /* The signal handler prototype */
> #define wxTYPE_SA_HANDLER void
> 
> /* gettimeofday() usually takes 2 arguments, but some really old systems might
>  * have only one, in which case define WX_GETTIMEOFDAY_NO_TZ */
> /* #undef WX_GETTIMEOFDAY_NO_TZ */
> 
> /* struct tm doesn't always have the tm_gmtoff field, define this if it does */
> /* #undef WX_GMTOFF_IN_TM */
> 
> /* Define if you have pw_gecos field in struct passwd */
> #define HAVE_PW_GECOS 1
> 
> /* Define if you have dlopen() */
> /* #undef HAVE_DLOPEN */
> 
> /* Define if you have gettimeofday() */
> #define HAVE_GETTIMEOFDAY 1
> 
> /* Define if you have ftime() */
> /* #undef HAVE_FTIME */
> 
> /* Define if you have localtime() */
> #define HAVE_LOCALTIME 1
> 
> /* Define if you have nanosleep() */
> /* #undef HAVE_NANOSLEEP */
> 
> /* Define if you have sched_yield */
> #define HAVE_SCHED_YIELD 1
> 
> /* Define if you have pthread_cancel */
> #define HAVE_PTHREAD_CANCEL 1
> 
> /* Define if you have sigaction() */
> #define HAVE_SIGACTION 1
> 
> /* Define if you have sigemptyset() */
> /* #undef HAVE_SIGEMPTYSET */
> 
> /* Define if you have shl_load() */
> /* #undef HAVE_SHL_LOAD */
> 
> /* Define if you have strptime() */
> /* #undef HAVE_STRPTIME */
> 
> /* Define if you have all functions to set thread priority */
> /* #undef HAVE_THREAD_PRIORITY_FUNCTIONS */
> 
> /* Define if you can specify exit functions to a thread */
> /* #undef HAVE_THREAD_CLEANUP_FUNCTIONS */
> 
> /* Define if you have timegm() function */
> /* #undef HAVE_TIMEGM */
> 
> /* Define if you have vsnprintf() */
> /* #undef HAVE_VSNPRINTF */
> 
> /* Define if you have usleep() */
> #define HAVE_USLEEP 1
> 
> /* Define if you have wcslen function  */
> /* #undef HAVE_WCSLEN */
> 
> /* define if you have vsscanf function */
> /* #undef HAVE_VSSCANF */
> 
> /* The number of bytes in a char.  */
> #define SIZEOF_CHAR 1
> 
> /* The number of bytes in a wchar_t.  */
> #define SIZEOF_WCHAR_T 0
> 
> /* The number of bytes in a int.  */
> #define SIZEOF_INT 4
> 
> /* The number of bytes in a int *.  */
> #define SIZEOF_INT_P 4
> 
> /* The number of bytes in a long.  */
> #define SIZEOF_LONG 4
> 
> /* The number of bytes in a long long.  */
> #define SIZEOF_LONG_LONG 8
> 
> /* The number of bytes in a short.  */
> #define SIZEOF_SHORT 2
> 
> /* Define if you have the dlopen function.  */
> /* #undef HAVE_DLOPEN */
> 
> /* Define if you have the dlerror function.  */
> /* #undef HAVE_DLERROR */
> 
> /* Define if you have the gethostname function.  */
> /* #undef HAVE_GETHOSTNAME */
> 
> /* Define if you have the inet_addr function.  */
> #define HAVE_INET_ADDR 1
> 
> /* Define if you have the inet_aton function.  */
> #define HAVE_INET_ATON 1
> 
> /* Define if you have the nanosleep function.  */
> /* #undef HAVE_NANOSLEEP */
> 
> /* Define if you have the putenv function.  */
> #define HAVE_PUTENV 1
> 
> /* Define if you have the setenv function.  */
> /* #undef HAVE_SETENV */
> 
> /* Define if you have the shl_load function.  */
> /* #undef HAVE_SHL_LOAD */
> 
> /* Define if you have strtok_r function. */
> /* #undef HAVE_STRTOK_R */
> 
> /* Define if you have thr_setconcurrency function */
> /* #undef HAVE_THR_SETCONCURRENCY */
> 
> /* Define if you have the uname function.  */
> #define HAVE_UNAME 1
> 
> /* Define if you have the usleep function.  */
> #define HAVE_USLEEP 1
> 
> /* Define if you have the vfork function.  */
> #define HAVE_VFORK 1
> 
> /* Define if you have the <X11/XKBlib.h> header file.  */
> /* #undef HAVE_X11_XKBLIB_H */
> 
> /* Define if you have the <fnmatch.h> header file.  */
> #define HAVE_FNMATCH_H 1
> 
> /* Define if you have the <iostream> header file.  */
> #define HAVE_IOSTREAM 1
> 
> /* Define if you have the <linux/joystick.h> header file.  */
> /* #undef HAVE_LINUX_JOYSTICK_H */
> 
> /* Define if you have the <sched.h> header file.  */
> #define HAVE_SCHED_H 1
> 
> /* Define if you have the <strings.h> header file.  */
> #define HAVE_STRINGS_H 1
> 
> /* Define if you have the <unistd.h> header file.  */
> #define HAVE_UNISTD_H 1
> 
> /* Define if you have the <fcntl.h> header file.  */
> #define HAVE_FCNTL_H 1
> 
> /* Define if you have the <wchar.h> header file.  */
> /* #undef HAVE_WCHAR_H */
> 
> /* Define if you have the <wcstr.h> header file.  */
> /* #undef HAVE_WCSTR_H */
> 
> /* Define if you have the <iconv.h> header file.  */
> /* #undef HAVE_ICONV_H */
> 
> /* Define if you have the <langinfo.h> header file.  */
> /* #undef HAVE_LANGINFO_H */
> 
> /* Define this if you are using gtk and gdk contains support for X11R6 XIM */
> /* #undef HAVE_XIM */
> 
> #endif /* __WX_SETUP_H__ */
Index: include/wx/mac/window.h
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/include/wx/mac/window.h,v
retrieving revision 1.10
diff -r1.10 window.h
271c271
< 	static WindowRef					MacGetWindowInUpdate() { return s_macWindowInUpdate ; }
---
> 	static WindowRef					MacGetWindowInUpdate();
Index: src/common/ffile.cpp
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/src/common/ffile.cpp,v
retrieving revision 1.8
diff -r1.8 ffile.cpp
67c67
< #ifdef __WXMAC__
---
> #if defined( __WXMAC__ ) && !defined(__UNIX__)
75c75
< #ifdef __WXMAC__
---
> #if defined( __WXMAC__ ) && !defined(__UNIX__)
Index: src/common/file.cpp
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/src/common/file.cpp,v
retrieving revision 1.48
diff -r1.48 file.cpp
139c139
< #ifdef __WXMAC__
---
> #if defined( __WXMAC__ ) && !defined(__UNIX__)
147c147
< #ifdef __WXMAC__
---
> #if defined( __WXMAC__ ) && !defined(__UNIX__)
195c195
< #ifdef __WXMAC__
---
> #if defined( __WXMAC__ ) && !defined(__UNIX__)
243c243
< #ifdef __WXMAC__
---
> #if defined( __WXMAC__ ) && !defined(__UNIX__)
558c558
< #ifndef __WXMAC__
---
> #if !(defined( __WXMAC__ ) && !defined(__UNIX__))
586c586
< #ifndef __WXMAC__
---
> #if !(defined( __WXMAC__ ) && !defined(__UNIX__))
596d595
< 
Index: src/common/fileconf.cpp
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/src/common/fileconf.cpp,v
retrieving revision 1.71
diff -r1.71 fileconf.cpp
800c800
< #ifdef __WXMAC__
---
> #if defined( __WXMAC__ ) && !defined(__UNIX__)
Index: src/common/filefn.cpp
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/src/common/filefn.cpp,v
retrieving revision 1.91
diff -r1.91 filefn.cpp
213c213
< #if defined(__WINDOWS__) || defined(__VMS__) || defined (__WXMAC__)
---
> #if defined(__WINDOWS__) || defined(__VMS__) || (defined (__WXMAC__) && !defined(__UNIX__))
1102c1102
< #if defined( __WXMAC__ )
---
> #if defined( __WXMAC__ ) && !defined(__UNIX__)
1667c1667
< #elif defined( __WXMAC__)
---
> #elif defined( __WXMAC__) && !defined(__UNIX__)
1685c1685
< #elif defined( __WXMAC__)
---
> #elif defined( __WXMAC__) && !defined(__UNIX__)
Index: src/common/image.cpp
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/src/common/image.cpp,v
retrieving revision 1.115
diff -r1.115 image.cpp
1407,1411d1406
< extern CTabHandle wxMacCreateColorTable( int numColors ) ;
< extern void wxMacDestroyColorTable( CTabHandle colors ) ;
< extern void wxMacSetColorTableEntry( CTabHandle newColors , int index , int red , int green ,  int blue ) ;
< extern GWorldPtr wxMacCreateGWorld( int width , int height , int depth ) ;
< extern void wxMacDestroyGWorld( GWorldPtr gw ) ;
1414a1410,1413
>     wxBitmap bitmap;
> 
>     wxCHECK_MSG( Ok(), bitmap, wxT("invalid image") );
> 
1420,1443c1419,1420
< 
<     wxBitmap bitmap( width , height , wxDisplayDepth() ) ;
< 
<     // Create mask
< 
<     if (HasMask())
<     {
<             /*
<         unsigned char *mask_data = (unsigned char*)malloc( ((width >> 3)+8) * height );
< 
<         mask_image =  gdk_image_new_bitmap( gdk_visual_get_system(), mask_data, width, height );
< 
<         wxMask *mask = new wxMask();
<         mask->m_bitmap = gdk_pixmap_new( (GdkWindow*)&gdk_root_parent, width, height, 1 );
< 
<         bitmap.SetMask( mask );
<        */
<     }
< 
<     // Render
< 
<     int r_mask = GetMaskRed();
<     int g_mask = GetMaskGreen();
<     int b_mask = GetMaskBlue();
---
>     bitmap.Create( width , height , wxDisplayDepth() ) ;
>     wxBitmap maskBitmap( width, height, 1);
1450a1428,1430
>     LockPixels( GetGWorldPixMap(bitmap.GetHBITMAP()) );
>     LockPixels( GetGWorldPixMap(maskBitmap.GetHBITMAP()) );
> 
1452a1433,1438
>     // Render image
>     wxColour rgb, maskcolor(GetMaskRed(), GetMaskGreen(), GetMaskBlue());
>     RGBColor color;
>     RGBColor white = { 0xffff, 0xffff, 0xffff };
>     RGBColor black = { 0     , 0     , 0      };
> 
1458,1464c1444,1445
<             unsigned char r = data[index++];
<             unsigned char g = data[index++];
<             unsigned char b = data[index++];
<             RGBColor color ;
<             color.red = ( r  << 8 ) + r ;
<             color.green = ( g << 8 ) + g ;
<             color.blue = ( b << 8 ) + b ;
---
>             rgb.Set(data[index++], data[index++], data[index++]);
>             color = rgb.GetPixel();
1465a1447,1457
>             if(HasMask())
>             {
>                 SetGWorld(maskBitmap.GetHBITMAP(), NULL);
>                 if(rgb == maskcolor) {
>                     SetCPixel(x,y, &white);
>                 }
>                 else {
>                     SetCPixel(x,y, &black);
>                 }
>                 SetGWorld(bitmap.GetHBITMAP(), NULL);
>             }
1469,1474c1461,1463
<            SetGWorld( origPort , origDevice ) ;
< 
<     if ( HasMask() )
<     {
<         wxColour colour( GetMaskRed(), GetMaskGreen(), GetMaskBlue());
<         wxMask *mask = new wxMask( bitmap, colour );
---
>     // Create mask
>     if ( HasMask() ) {
>         wxMask *mask = new wxMask( maskBitmap );
1477d1465
<     return bitmap;
1478a1467,1471
>     UnlockPixels( GetGWorldPixMap(bitmap.GetHBITMAP()) );
>     UnlockPixels( GetGWorldPixMap(maskBitmap.GetHBITMAP()) );
>     SetGWorld( origPort, origDevice );
> 
>     return bitmap;
1484,1488c1477
<     if( !bitmap.Ok() )
<     {
<         wxFAIL_MSG( "invalid bitmap" );
<         return;
<     }
---
>     wxCHECK_RET( bitmap.Ok(), wxT("Invalid bitmap") );
1494,1511d1482
<     /*
<     unsigned char *data = GetData();
<     if( !data )
<     {
<         wxFAIL_MSG( "could not allocate data for image" );
<         return;
<     }
< 
<     // calc the number of bytes per scanline and padding in the DIB
<     int bytePerLine = width*3;
<     int sizeDWORD = sizeof( DWORD );
<     div_t lineBoundary = div( bytePerLine, sizeDWORD );
<     int padding = 0;
<     if( lineBoundary.rem > 0 )
<     {
<         padding = sizeDWORD - lineBoundary.rem;
<         bytePerLine += padding;
<     }
1513,1544c1484
<     // create a DIB header
<     int headersize = sizeof(BITMAPINFOHEADER);
<     LPBITMAPINFO lpDIBh = (BITMAPINFO *) malloc( headersize );
<     if( !lpDIBh )
<     {
<         wxFAIL_MSG( "could not allocate data for DIB header" );
<         free( data );
<         return;
<     }
<     // Fill in the DIB header
<     lpDIBh->bmiHeader.biSize = headersize;
<     lpDIBh->bmiHeader.biWidth = width;
<     lpDIBh->bmiHeader.biHeight = -height;
<     lpDIBh->bmiHeader.biSizeImage = bytePerLine * height;
<     lpDIBh->bmiHeader.biPlanes = 1;
<     lpDIBh->bmiHeader.biBitCount = 24;
<     lpDIBh->bmiHeader.biCompression = BI_RGB;
<     lpDIBh->bmiHeader.biClrUsed = 0;
<     // These seem not really needed for our purpose here.
<     lpDIBh->bmiHeader.biClrImportant = 0;
<     lpDIBh->bmiHeader.biXPelsPerMeter = 0;
<     lpDIBh->bmiHeader.biYPelsPerMeter = 0;
<     // memory for DIB data
<     unsigned char *lpBits;
<     lpBits = (unsigned char *) malloc( lpDIBh->bmiHeader.biSizeImage );
<     if( !lpBits )
<     {
<         wxFAIL_MSG( "could not allocate data for DIB" );
<         free( data );
<         free( lpDIBh );
<         return;
<     }
---
>     unsigned char *data = GetData();
1546,1566c1486
<     // copy data from the device-dependent bitmap to the DIB
<     HDC hdc = ::GetDC(NULL);
<     HBITMAP hbitmap;
<     hbitmap = (HBITMAP) bitmap.GetHBITMAP();
<     ::GetDIBits( hdc, hbitmap, 0, height, lpBits, lpDIBh, DIB_RGB_COLORS );
< 
<     // copy DIB data into the wxImage object
<     int i, j;
<     unsigned char *ptdata = data;
<     unsigned char *ptbits = lpBits;
<     for( i=0; i<height; i++ )
<     {
<         for( j=0; j<width; j++ )
<         {
<             *(ptdata++) = *(ptbits+2);
<             *(ptdata++) = *(ptbits+1);
<             *(ptdata++) = *(ptbits  );
<             ptbits += 3;
<         }
<         ptbits += padding;
<     }
---
>     wxCHECK_RET( data, wxT("Could not allocate data for image") );
1568,1569c1488,1503
<     // similarly, set data according to the possible mask bitmap
<     if( bitmap.GetMask() && bitmap.GetMask()->GetMaskBitmap() )
---
>     WXHBITMAP origPort;
>     GDHandle  origDevice;
>     int      index;
>     RGBColor color;
>     // background color set to RGB(16,16,16) in consistent with wxGTK
>     unsigned char mask_r=16, mask_g=16, mask_b=16;
>     SInt16   r,g,b;
>     wxMask  *mask = bitmap.GetMask();
> 
>     GetGWorld( &origPort, &origDevice );
>     LockPixels(GetGWorldPixMap(bitmap.GetHBITMAP()));
>     SetGWorld( bitmap.GetHBITMAP(), NULL);
> 
>     // Copy data into image
>     index = 0;
>     for(int yy = 0; yy < height; yy++)
1571,1582c1505
<         hbitmap = (HBITMAP) bitmap.GetMask()->GetMaskBitmap();
<         // memory DC created, color set, data copied, and memory DC deleted
<         HDC memdc = ::CreateCompatibleDC( hdc );
<         ::SetTextColor( memdc, RGB( 0, 0, 0 ) );
<         ::SetBkColor( memdc, RGB( 255, 255, 255 ) );
<         ::GetDIBits( memdc, hbitmap, 0, height, lpBits, lpDIBh, DIB_RGB_COLORS );
<         ::DeleteDC( memdc );
<         // background color set to RGB(16,16,16) in consistent with wxGTK
<         unsigned char r=16, g=16, b=16;
<         ptdata = data;
<         ptbits = lpBits;
<         for( i=0; i<height; i++ )
---
>         for(int xx = 0; xx < width; xx++)
1584c1507,1514
<             for( j=0; j<width; j++ )
---
>             GetCPixel(xx,yy, &color);
>             r = ((color.red ) >> 8);
>             g = ((color.green ) >> 8);
>             b = ((color.blue ) >> 8);
>             data[index    ] = r;
>             data[index + 1] = g;
>             data[index + 2] = b;
>             if(mask)
1586,1592c1516,1519
<                 if( *ptbits != 0 )
<                     ptdata += 3;
<                 else
<                 {
<                     *(ptdata++)  = r;
<                     *(ptdata++)  = g;
<                     *(ptdata++)  = b;
---
>                 if(mask->PointMasked(xx,yy)) {
>                     data[index    ] = mask_r;
>                     data[index + 1] = mask_g;
>                     data[index + 2] = mask_b;
1594d1520
<                 ptbits += 3;
1596c1522
<             ptbits += padding;
---
>             index += 3;
1598,1599d1523
<         SetMaskColour( r, g, b );
<         SetMask( TRUE );
1601,1603c1525,1527
<     else
<     {
<         SetMask( FALSE );
---
>     if(mask) {
>         SetMaskColour( mask_r, mask_g, mask_b );
>         SetMask( true );
1605,1609c1529,1532
<     // free allocated resources
<     ::ReleaseDC(NULL, hdc);
<     free(lpDIBh);
<     free(lpBits);
<     */
---
> 
>     // Free resources
>     UnlockPixels(GetGWorldPixMap(bitmap.GetHBITMAP()));
>     SetGWorld(origPort, origDevice);
Index: src/common/matrix.cpp
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/src/common/matrix.cpp,v
retrieving revision 1.4
diff -r1.4 matrix.cpp
31a32
> #ifndef __WXMAC__
32a34
> #endif
Index: src/common/mimecmn.cpp
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/src/common/mimecmn.cpp,v
retrieving revision 1.10
diff -r1.10 mimecmn.cpp
58c58
< #elif defined (__WXMAC__)
---
> #elif defined (__WXMAC__) && !defined(__UNIX__)
Index: src/common/resource.cpp
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/src/common/resource.cpp,v
retrieving revision 1.67
diff -r1.67 resource.cpp
230c230
< #ifdef __WXMAC__
---
> #if defined( __WXMAC__ ) && !defined(__UNIX__)
Index: src/common/unzip.c
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/src/common/unzip.c,v
retrieving revision 1.15
diff -r1.15 unzip.c
361c361
< #ifdef __WXMAC__
---
> #if defined( __WXMAC__ ) && !defined(__UNIX__)
433c433
< #ifdef __WXMAC__
---
> #if defined( __WXMAC__ ) && !defined(__UNIX__)
Index: src/mac/app.cpp
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/src/mac/app.cpp,v
retrieving revision 1.15
diff -r1.15 app.cpp
24a25
> #include "wx/intl.h"
360c361
< 
---
> #ifndef __UNIX__
395c396
< 
---
> #endif
Index: src/mac/bitmap.cpp
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/src/mac/bitmap.cpp,v
retrieving revision 1.7
diff -r1.7 bitmap.cpp
43a44
> 
47c48
< 	
---
> 
99a101,191
> PicHandle wxMacCreatePict(GWorldPtr wp, GWorldPtr mask)
> {
>    CGrafPtr    origPort ;
>    GDHandle    origDev ;
> 
>    PicHandle      pict;          // this is the Picture we give back
> 
>    RGBColor    gray = { 0xCCCC ,0xCCCC , 0xCCCC } ;
>    RGBColor    white = { 0xffff ,0xffff , 0xffff } ;
>    RGBColor    black = { 0x0000 ,0x0000 , 0x0000 } ;
> 
>    unsigned char *maskimage = NULL ;
>    Rect portRect ;
>    GetPortBounds( wp , &portRect ) ;
>    int width = portRect.right - portRect.left ;
>    int height = portRect.bottom - portRect.top ;
> 
>    LockPixels( GetGWorldPixMap( wp ) ) ;
>    GetGWorld( &origPort , &origDev ) ;
> 
>    if ( mask )
>    {
>       maskimage = (unsigned char*) malloc( width * height ) ;
>       SetGWorld( mask , NULL ) ;
>       LockPixels( GetGWorldPixMap( mask ) ) ;
>       for ( int y = 0 ; y < height ; y++ )
>       {
>          for( int x = 0 ; x < width ; x++ )
>          {
>             RGBColor col ;
> 
>             GetCPixel( x + portRect.left , y + portRect.top , &col ) ;
>             maskimage[y*width + x] = ( col.red == 0 ) ; // for monochrome masks
>          }
>       }
>       UnlockPixels( GetGWorldPixMap( mask ) ) ;
>    }
> 
>    SetGWorld( wp , NULL ) ;
> 
>    pict = OpenPicture(&portRect);   // open a picture, this disables drawing
>    if(!pict)
>       return NULL;
> 
>    if ( maskimage )
>    {
>       RGBForeColor( &black ) ;
>       RGBBackColor( &white ) ;
>       PenMode(transparent);
> 
>       for ( int y = 0 ; y < height ; ++y )
>       {
>          for( int x = 0 ; x < width ; ++x )
>          {
>             if ( maskimage[y*width + x] )
>             {
>                RGBColor col ;
> 
>                GetCPixel( x + portRect.left , y + portRect.top , &col ) ;
>                SetCPixel( x + portRect.left , y + portRect.top , &col ) ;
>             }
>             else {
>                 // With transparency set this sets a blank pixel not a white one
>                 SetCPixel( x + portRect.left , y + portRect.top , &white);
>             }
>          }
>       }
>       free( maskimage ) ;
>       maskimage = NULL ;
>    }
>    else
>    {
>       RGBBackColor( &gray ) ;
>       EraseRect(&portRect);
>       RGBForeColor( &black ) ;
>       RGBBackColor( &white ) ;
> 
>       CopyBits(GetPortBitMapForCopyBits(wp), /* src PixMap - we copy image over
>                                               * itself - */
>                GetPortBitMapForCopyBits(wp), //  dst PixMap - no drawing occurs
>                &portRect,    // srcRect - it will be recorded and compressed -
>                &portRect,    // dstRect - into the picture that is open -
>                srcCopy,NULL); // copyMode and no clip region
>    }
>    ClosePicture();                  // We are done recording the picture
>    UnlockPixels( GetGWorldPixMap( wp ) ) ;
>    SetGWorld( origPort , origDev ) ;
> 
>    return pict;                  // return our groovy pict handle
> }
> 
172,218c264,308
< 		if ( no_bits == 1 )
< 		{
< 	    	M_BITMAPDATA->m_bitmapType = kMacBitmapTypeGrafWorld ;
< 	    	M_BITMAPDATA->m_hBitmap = wxMacCreateGWorld( the_width , the_height , no_bits ) ;
< 			M_BITMAPDATA->m_ok = (M_BITMAPDATA->m_hBitmap != NULL ) ;
< 	
< 			CGrafPtr 	origPort ;
< 			GDHandle	origDevice ;
< 			
< 			GetGWorld( &origPort , &origDevice ) ;
< 			SetGWorld( M_BITMAPDATA->m_hBitmap , NULL ) ;
< 			LockPixels( GetGWorldPixMap( (CGrafPtr) M_BITMAPDATA->m_hBitmap ) ) ;
< 			
< 			// bits is a word aligned array
< 			
< 			unsigned char* linestart = (unsigned char*) bits ;
< 			int linesize = ( the_width / 16 ) * 2  ;
< 			if ( the_width % 16 )
< 			{
< 				linesize += 2 ;
< 			}
< 			
< 			RGBColor colors[2] = { 
< 				{ 0xFFFF , 0xFFFF , 0xFFFF } ,
< 				{ 0, 0 , 0 } 
< 				} ;
< 			
< 			for ( int y = 0 ; y < the_height ; ++y , linestart += linesize )
< 			{
< 				for ( int x = 0 ; x < the_width ; ++x )
< 				{
< 					int index = x / 8 ;
< 					int bit = x % 8 ;
< 					int mask = 1 << bit ;
< 					if ( linestart[index] & mask )
< 					{
< 						SetCPixel( x , y , &colors[1] ) ;
< 					}
< 					else
< 					{
< 						SetCPixel( x , y , &colors[0] ) ;
< 					}
< 				}
< 				
< 			}
< 		UnlockPixels( GetGWorldPixMap( (CGrafPtr) M_BITMAPDATA->m_hBitmap ) ) ;
< 	
---
> 
>     if ( no_bits == 1 )
>     {
> 	    M_BITMAPDATA->m_bitmapType = kMacBitmapTypeGrafWorld ;
> 	    M_BITMAPDATA->m_hBitmap = wxMacCreateGWorld( the_width , the_height , no_bits ) ;
> 
>         M_BITMAPDATA->m_ok = (M_BITMAPDATA->m_hBitmap != NULL ) ;
> 
>         CGrafPtr 	origPort ;
>         GDHandle	origDevice ;
> 
>         GetGWorld( &origPort , &origDevice ) ;
>         SetGWorld( M_BITMAPDATA->m_hBitmap , NULL ) ;
>         LockPixels( GetGWorldPixMap( M_BITMAPDATA->m_hBitmap ) );
> 
>         // bits is a word aligned array?? Don't think so
>         // bits is a char array on MAC X however using the benefit of the
>         // doubt I replaced references to 16 with sizeof(unsigned char)*8
>         unsigned char* linestart = (unsigned char*) bits ;
>         int linesize = ( the_width / (sizeof(unsigned char) * 8)) ;
>         if ( the_width % (sizeof(unsigned char) * 8) ) {
>             linesize += sizeof(unsigned char);
>         }
> 
>         RGBColor colors[2] = { 
>             { 0xFFFF , 0xFFFF , 0xFFFF } ,
>             { 0, 0 , 0 } };
> 
>         for( int y = 0 ; y < the_height ; ++y , linestart += linesize )
>         {
>             for( int x = 0 ; x < the_width ; ++x )
>             {
>                 int index = x / 8 ;
>                 int bit = x % 8 ;
>                 int mask = 1 << bit ;
>                 if ( linestart[index] & mask ) {
>                     SetCPixel( x , y , &colors[1] ) ;
>                 }
>                 else {
>                     SetCPixel( x , y , &colors[0] ) ;
>                 }
>             }
>         }
> 		UnlockPixels( GetGWorldPixMap( M_BITMAPDATA->m_hBitmap ) ) ;
> 
220,224c310,314
< 	   }
< 	   else
< 	   {
<          wxFAIL_MSG(wxT("multicolor BITMAPs not yet implemented"));
< 	   }
---
>     }
>     else
>     {
>         wxFAIL_MSG(wxT("multicolor BITMAPs not yet implemented"));
>     }
261c351,440
<     (void) Create((void *)data, wxBITMAP_TYPE_XPM_DATA, 0, 0, 0);
---
>    Create((void *)data, wxBITMAP_TYPE_XPM_DATA, 0, 0, 0);
> }
> 
> wxBitmap wxBitmap::GetSubBitmap(const wxRect &rect) const
> {
>    wxCHECK_MSG( Ok() &&
>                 (rect.x >= 0) && (rect.y >= 0) &&
>                 (rect.x+rect.width <= GetWidth()) &&
>                 (rect.y+rect.height <= GetHeight()),
>                 wxNullBitmap, wxT("invalid bitmap or bitmap region") );
> 
>    
>    wxBitmap ret( rect.width, rect.height, GetDepth() );
>    wxASSERT_MSG( ret.Ok(), wxT("GetSubBitmap error") );
> 
>    WXHBITMAP origPort;
>    GDHandle  origDevice;
> 
>    GetGWorld( &origPort, &origDevice );
> 
>    // Update the subbitmaps reference data
>    wxBitmapRefData *ref = (wxBitmapRefData *)ret.GetRefData();
> 
>    ref->m_numColors     = M_BITMAPDATA->m_numColors;
>    ref->m_bitmapPalette = M_BITMAPDATA->m_bitmapPalette;
>    ref->m_bitmapType    = M_BITMAPDATA->m_bitmapType;
> 
>    // Copy sub region of this bitmap
>    if(M_BITMAPDATA->m_bitmapType == kMacBitmapTypePict)
>    {
>        printf("GetSubBitmap:  Copy a region of a Pict structure - TODO\n");
>    }
>    else if(M_BITMAPDATA->m_bitmapType == kMacBitmapTypeGrafWorld)
>    {
>        // Copy mask
>        if(GetMask())
>        {
>            WXHBITMAP submask, mask;
>            RGBColor  color;
> 
>            mask = GetMask()->GetMaskBitmap();
>            submask = wxMacCreateGWorld(rect.width, rect.height, 1);
>            LockPixels(GetGWorldPixMap(mask));
>            LockPixels(GetGWorldPixMap(submask));
> 
>            for(int yy = 0; yy < rect.height; yy++)
>            {
>                for(int xx = 0; xx < rect.width; xx++)
>                {
>                    SetGWorld(mask, NULL);
>                    GetCPixel(rect.x + xx, rect.y + yy, &color);
>                    SetGWorld(submask, NULL);
>                    SetCPixel(xx,yy, &color);
>                }
>            }
>            UnlockPixels(GetGWorldPixMap(mask));
>            UnlockPixels(GetGWorldPixMap(submask));
>            ref->m_bitmapMask = new wxMask;
>            ref->m_bitmapMask->SetMaskBitmap(submask);
>        }
> 
>        // Copy bitmap
>        if(GetHBITMAP())
>        {
>            WXHBITMAP subbitmap, bitmap;
>            RGBColor  color;
> 
>            bitmap = GetHBITMAP();
>            subbitmap = wxMacCreateGWorld(rect.width, rect.height, GetDepth());
>            LockPixels(GetGWorldPixMap(bitmap));
>            LockPixels(GetGWorldPixMap(subbitmap));
> 
>            for(int yy = 0; yy < rect.height; yy++)
>            {
>                for(int xx = 0; xx < rect.width; xx++)
>                {
>                    SetGWorld(bitmap, NULL);
>                    GetCPixel(rect.x + xx, rect.y + yy, &color);
>                    SetGWorld(subbitmap, NULL);
>                    SetCPixel(xx, yy, &color);
>                }
>            }
>            UnlockPixels(GetGWorldPixMap(bitmap));
>            UnlockPixels(GetGWorldPixMap(subbitmap));
>            ret.SetHBITMAP(subbitmap);
>        }
>    }
>    SetGWorld( origPort, origDevice );
> 
>    return ret;
279a459,465
> int wxBitmap::GetBitmapType() const
> {
>    wxCHECK_MSG( Ok(), kMacBitmapTypeUnknownType, wxT("invalid bitmap") );
> 
>    return M_BITMAPDATA->m_bitmapType;
> }
> 
284c470
< 		M_BITMAPDATA->m_ok = (M_BITMAPDATA->m_hBitmap != NULL ) ;
---
>     M_BITMAPDATA->m_ok = (M_BITMAPDATA->m_hBitmap != NULL ) ;
333a520,559
> bool wxBitmap::Ok() const
> {
>    return (M_BITMAPDATA && M_BITMAPDATA->m_ok);
> }
> 
> int wxBitmap::GetHeight() const
> {
>    wxCHECK_MSG( Ok(), -1, wxT("invalid bitmap") );
> 
>    return M_BITMAPDATA->m_height;
> }
> 
> int wxBitmap::GetWidth() const
> {
>    wxCHECK_MSG( Ok(), -1, wxT("invalid bitmap") );
> 
>    return M_BITMAPDATA->m_width;
> }
> 
> int wxBitmap::GetDepth() const
> {
>    wxCHECK_MSG( Ok(), -1, wxT("invalid bitmap") );
> 
>    return M_BITMAPDATA->m_depth;
> }
> 
> int wxBitmap::GetQuality() const
> {
>    wxCHECK_MSG( Ok(), -1, wxT("invalid bitmap") );
> 
>    return M_BITMAPDATA->m_quality;
> }
> 
> wxMask *wxBitmap::GetMask() const
> {
>    wxCHECK_MSG( Ok(), (wxMask *) NULL, wxT("invalid bitmap") );
> 
>    return M_BITMAPDATA->m_bitmapMask;
> }
> 
373a600,606
> wxPalette *wxBitmap::GetPalette() const
> {
>    wxCHECK_MSG( Ok(), NULL, wxT("Invalid bitmap  GetPalette()") );
> 
>    return &M_BITMAPDATA->m_bitmapPalette;
> }
> 
389a623,721
> WXHBITMAP wxBitmap::GetHBITMAP() const
> {
>    wxCHECK_MSG( Ok(), NULL, wxT("invalid bitmap") );
> 
>    return M_BITMAPDATA->m_hBitmap;
> }
> 
> PicHandle wxBitmap::GetPict() const
> {
>    wxCHECK_MSG( Ok(), NULL, wxT("invalid bitmap") );
>    
>    PicHandle picture;       // This is the returned picture
> 
>    // If bitmap already in Pict format return pointer
>    if(M_BITMAPDATA->m_bitmapType == kMacBitmapTypePict) {
>        return M_BITMAPDATA->m_hPict;
>    }
>    else if(M_BITMAPDATA->m_bitmapType != kMacBitmapTypeGrafWorld) {
>        // Invalid bitmap
>        return NULL;
>    }
> 
>    RGBColor  gray = { 0xCCCC ,0xCCCC , 0xCCCC } ;
>    RGBColor  white = { 0xffff ,0xffff , 0xffff } ;
>    RGBColor  black = { 0x0000 ,0x0000 , 0x0000 } ;
>    CGrafPtr  origPort;
>    GDHandle  origDev ;
>    wxMask   *mask;
>    Rect      portRect ;
> 
>    GetPortBounds( GetHBITMAP() , &portRect ) ;
>    int width = portRect.right - portRect.left ;
>    int height = portRect.bottom - portRect.top ;
> 
>    LockPixels( GetGWorldPixMap( GetHBITMAP() ) ) ;
>    GetGWorld( &origPort , &origDev ) ;
> 
>    mask = GetMask();
> 
>    SetGWorld( GetHBITMAP() , NULL ) ;
> 
>    picture = OpenPicture(&portRect);   // open a picture, this disables drawing
>    if(!picture) {
>        return NULL;
>    }
> 
>    if( mask )
>    {
> #ifndef __WXMAC_X__
>        RGBBackcolor( &gray );
>        EraseRect( &portrect );
>        RGBColor trans = gray;
> #else
>        RGBColor trans = white;
> #endif
>        RGBForeColor( &black ) ;
>        RGBBackColor( &white ) ;
>        PenMode(transparent);
> 
>        for ( int y = 0 ; y < height ; ++y )
>        {
>            for( int x = 0 ; x < width ; ++x )
>            {
>                if ( !mask->PointMasked(x,y) )
>                {
>                    RGBColor col ;
> 
>                    GetCPixel( x + portRect.left , y + portRect.top , &col ) ;
>                    SetCPixel( x + portRect.left , y + portRect.top , &col ) ;
>                }
>                else {
>                    // With transparency this sets a blank pixel
>                    SetCPixel( x + portRect.left , y + portRect.top , &trans);
>                }
>            }
>        }
>    }
>    else
>    {
>        RGBBackColor( &gray ) ;
>        EraseRect(&portRect);
>        RGBForeColor( &black ) ;
>        RGBBackColor( &white ) ;
> 
>        CopyBits(GetPortBitMapForCopyBits(GetHBITMAP()), 
>                 // src PixMap - we copy image over itself -
>                 GetPortBitMapForCopyBits(GetHBITMAP()),
>                 //  dst PixMap - no drawing occurs
>                 &portRect,    // srcRect - it will be recorded and compressed -
>                 &portRect,    // dstRect - into the picture that is open -
>                 srcCopy,NULL); // copyMode and no clip region
>    }
>    ClosePicture();                  // We are done recording the picture
>    UnlockPixels( GetGWorldPixMap( GetHBITMAP() ) ) ;
>    SetGWorld( origPort , origDev ) ;
> 
>    return picture;                  // return our groovy pict handle
> }
> 
496,497c828,853
< // TODO
<     return FALSE;
---
>    if ( m_maskBitmap )
>    {
>        wxMacDestroyGWorld( m_maskBitmap ) ;
>        m_maskBitmap = NULL ;
>    }
>    wxCHECK_MSG( bitmap.GetBitmapType() == kMacBitmapTypeGrafWorld, false,
>                 wxT("Cannot create mask from this bitmap type (TODO)"));
>    // other types would require a temporary bitmap. not yet implemented
> 
>    wxCHECK_MSG( bitmap.Ok(), false, wxT("Invalid bitmap"));
> 
>    wxCHECK_MSG(bitmap.GetDepth() == 1, false,
>                wxT("Cannot create mask from colour bitmap"));
> 
>    m_maskBitmap = wxMacCreateGWorld(bitmap.GetWidth(), bitmap.GetHeight(), 1);
>    Rect rect = { 0,0, bitmap.GetHeight(), bitmap.GetWidth() };
> 
>    LockPixels( GetGWorldPixMap(m_maskBitmap) );
>    LockPixels( GetGWorldPixMap(bitmap.GetHBITMAP()) );
>    CopyBits(GetPortBitMapForCopyBits(bitmap.GetHBITMAP()),
>             GetPortBitMapForCopyBits(m_maskBitmap),
>             &rect, &rect, srcCopy, 0);
>    UnlockPixels( GetGWorldPixMap(m_maskBitmap) );
>    UnlockPixels( GetGWorldPixMap(bitmap.GetHBITMAP()) );
> 
>    return FALSE;
504a861
>    wxCHECK_MSG( 0, false, wxT("Not implemented"));
517c874,875
< 	wxASSERT( ((wxBitmapRefData*) bitmap.GetRefData())->m_bitmapType == kMacBitmapTypeGrafWorld ) ;
---
> 	wxCHECK_MSG( bitmap.GetBitmapType() == kMacBitmapTypeGrafWorld, false,
>                  wxT("Cannot create mask from this bitmap type (TODO)"));
519,523d876
< 	
<     if (!bitmap.Ok())
<     {
<         return FALSE;
<     }
525,527c878,882
< 	m_maskBitmap = wxMacCreateGWorld( bitmap.GetWidth() , bitmap.GetHeight() , 1 ) ;	
< 	LockPixels( GetGWorldPixMap( (CGrafPtr) m_maskBitmap ) ) ;
< 	LockPixels( GetGWorldPixMap( (CGrafPtr) ((wxBitmapRefData*) bitmap.GetRefData())->m_hBitmap ) ) ;
---
>     wxCHECK_MSG( bitmap.Ok(), false, wxT("Illigal bitmap"));
> 
> 	m_maskBitmap = wxMacCreateGWorld(bitmap.GetWidth(), bitmap.GetHeight(), 1);
> 	LockPixels( GetGWorldPixMap( m_maskBitmap ) ) ;
> 	LockPixels( GetGWorldPixMap( bitmap.GetHBITMAP() ) );
532,534c887,893
< 	CGrafPtr 	origPort ;
< 	GDHandle	origDevice ;
< 			
---
> 	CGrafPtr  origPort ;
> 	GDHandle  origDevice ;
>     RGBColor  col;
>     RGBColor  colors[2] = {
>         { 0xFFFF, 0xFFFF, 0xFFFF },
>         { 0,      0,      0 }};
> 
536c895
< 	for (int w = 0; w < bitmap.GetWidth(); w++)
---
> 	for (int yy = 0; yy < bitmap.GetHeight(); yy++)
538,549c897,903
<         for (int h = 0; h < bitmap.GetHeight(); h++)
<         {		
< 			RGBColor colors[2] = { 
< 				{ 0xFFFF , 0xFFFF , 0xFFFF } ,
< 				{ 0, 0 , 0 } 
< 				} ;
< 				
< 			SetGWorld( ((wxBitmapRefData*) bitmap.GetRefData())->m_hBitmap , NULL ) ;
< 			RGBColor col ;
< 			GetCPixel( w , h , &col ) ;
< 			SetGWorld( m_maskBitmap , NULL ) ;
<             if (col.red == maskColor.red && col.blue == maskColor.blue && col.green == maskColor.green)
---
>         for (int xx = 0; xx < bitmap.GetWidth(); xx++)
>         {
> 			SetGWorld( bitmap.GetHBITMAP(), NULL );
> 			GetCPixel( xx , yy , &col ) ;
>             SetGWorld( m_maskBitmap , NULL ) ;
>             if (col.red == maskColor.red && col.green == maskColor.green &&
>                 col.blue == maskColor.blue)
551c905
< 				SetCPixel( w , h , &colors[0] ) ;
---
> 				SetCPixel( xx , yy , &colors[0] ) ;
553,555c907,908
<             else
<             {
< 				SetCPixel( w , h , &colors[1] ) ;
---
>             else {
> 				SetCPixel( xx , yy , &colors[1] ) ;
560c913
< 	UnlockPixels( GetGWorldPixMap( ((wxBitmapRefData*) bitmap.GetRefData())->m_hBitmap ) ) ;
---
> 	UnlockPixels( GetGWorldPixMap( bitmap.GetHBITMAP() ) );
565a919,939
> bool wxMask::PointMasked(int x, int y)
> {
>    WXHBITMAP origPort;
>    GDHandle  origDevice;
>    RGBColor  color;
>    bool masked = true;
> 
>    GetGWorld( &origPort, &origDevice);
> 
>    //Set port to mask and see if it masked (1) or not ( 0 )
>    SetGWorld(m_maskBitmap, NULL);
>    LockPixels(GetGWorldPixMap(m_maskBitmap));
>    GetCPixel(x,y, &color);
>    masked = !(color.red == 0 && color.green == 0 && color.blue == 0);
>    UnlockPixels(GetGWorldPixMap(m_maskBitmap));
> 
>    SetGWorld( origPort, origDevice);
> 
>    return masked;
> }
> 
577,578c951,953
< bool wxBitmapHandler::LoadFile(wxBitmap *bitmap, const wxString& name, long type,
<         int desiredWidth, int desiredHeight)
---
> bool wxBitmapHandler::LoadFile(wxBitmap *bitmap, const wxString& name,
>                                long type,
>                                int desiredWidth, int desiredHeight)
580c955
<     return FALSE;
---
>    return FALSE;
583c958,959
< bool wxBitmapHandler::SaveFile(wxBitmap *bitmap, const wxString& name, int type, const wxPalette *palette)
---
> bool wxBitmapHandler::SaveFile(wxBitmap *bitmap, const wxString& name, int type,
>                                const wxPalette *palette)
585c961
<     return FALSE;
---
>    return FALSE;
604c980
<           int desiredWidth, int desiredHeight);
---
>                           int desiredWidth, int desiredHeight);
608,609c984,986
< bool  wxPICTResourceHandler::LoadFile(wxBitmap *bitmap, const wxString& name, long flags,
<           int desiredWidth, int desiredHeight)
---
> bool wxPICTResourceHandler::LoadFile(wxBitmap *bitmap, const wxString& name,
>                                      long flags,
>                                      int desiredWidth, int desiredHeight)
631c1008
< 		
---
> 
672,673c1049,1051
<     int desiredWidth = -1, int desiredHeight = -1);
<   virtual bool SaveFile(wxBitmap *bitmap, const wxString& name, int type, const wxPalette *palette = NULL);
---
>                         int desiredWidth = -1, int desiredHeight = -1);
>   virtual bool SaveFile(wxBitmap *bitmap, const wxString& name, int type, 
>                         const wxPalette *palette = NULL);
677,678c1055,1057
< bool wxXPMFileHandler::LoadFile(wxBitmap *bitmap, const wxString& name, long flags,
<     int desiredWidth, int desiredHeight)
---
> bool wxXPMFileHandler::LoadFile(wxBitmap *bitmap, const wxString& name,
>                                 long flags,
>                                 int desiredWidth, int desiredHeight)
771c1150,1151
< bool wxXPMDataHandler::Create(wxBitmap *bitmap, void *data, long flags, int width, int height, int depth)
---
> bool wxXPMDataHandler::Create(wxBitmap *bitmap, void *data, long flags,
>                               int width, int height, int depth)
831,832c1211,1213
< bool wxBMPResourceHandler::LoadFile(wxBitmap *bitmap, const wxString& name, long flags,
<     int desiredWidth, int desiredHeight)
---
> bool wxBMPResourceHandler::LoadFile(wxBitmap *bitmap, const wxString& name,
>                                     long flags, 
>                                     int desiredWidth, int desiredHeight)
Index: src/mac/clipbrd.cpp
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/src/mac/clipbrd.cpp,v
retrieving revision 1.5
diff -r1.5 clipbrd.cpp
22a23
> #include "wx/intl.h"
Index: src/mac/pnghand.cpp
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/src/mac/pnghand.cpp,v
retrieving revision 1.4
diff -r1.4 pnghand.cpp
416a417
> #ifndef __UNIX__
417a419,421
> #else
>   fp = fopen( ImageFileName , "rb" );
> #endif
Index: src/mac/utils.cpp
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/src/mac/utils.cpp,v
retrieving revision 1.6
diff -r1.6 utils.cpp
52c52
< 
---
> #ifndef __UNIX__
58c58
< 
---
> #endif
261c261
< }    
---
> }
262a263
> #ifndef __UNIX__
281c282
< 
---
> #endif __UNIX__
343a345,349
> }
> 
> void wxDisplaySizeMM(int *width, int *height)
> {
>    wxDisplaySize(width, height);
Index: src/mac/utilsexc.cpp
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/src/mac/utilsexc.cpp,v
retrieving revision 1.3
diff -r1.3 utilsexc.cpp
16a17,19
> #ifdef __UNIX__
> #include "wx/unix/execute.h"
> #endif
23a27
> #ifndef __UNIX__
28a33,41
> #endif
> 
> #ifdef __UNIX__
> int wxAddProcessCallback(wxEndProcessData *proc_data, int fd)
> {
>    wxFAIL_MSG(wxT("wxAddProcessCallback() function not ready"));
>    return 0;
> }
> #endif
Index: src/mac/wave.cpp
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/src/mac/wave.cpp,v
retrieving revision 1.5
diff -r1.5 wave.cpp
128a129,137
> #ifdef TARGET_CARBON
>         Str255 lpSnd;
>         SndListHandle hSnd;
> 
>         c2pstrcpy(lpSnd, m_sndname);
>         hSnd = (SndListHandle) GetNamedResource('snd', lpSnd);
> #else
>         char lpSnd[32];
> 
134c143
< 
---
> #endif // TARGET_CARBON
Index: src/mac/window.cpp
===================================================================
RCS file: /cvsroot/wxwindows/wxWindows/src/mac/window.cpp,v
retrieving revision 1.19
diff -r1.19 window.cpp
16a17,18
> 
> #include "wx/window.h"
35,37d36
< // TODO remove the line below, just for lookup-up convenience CS
< #include "wx/window.h"
< 
726,728c725,732
<     const wxFont *fontToUse = theFont;
<     if ( !fontToUse )
<         fontToUse = &m_font;
---
>     wxFont fontToUse;
> 
>     if ( !theFont ) {
>         fontToUse = m_font;
>     }
>     else {
>         fontToUse = *theFont;
>     }
732c736
<     dc.GetTextExtent( string , &lx , &ly , &ld, &le, fontToUse ) ;
---
>     dc.GetTextExtent( string , &lx , &ly , &ld, &le, &fontToUse ) ;
2187a2192,2196
> }
> 
> WindowRef wxWindow::MacGetWindowInUpdate()
> {
>    return 0;//s_macWindowInUpdate;

 	  	 
