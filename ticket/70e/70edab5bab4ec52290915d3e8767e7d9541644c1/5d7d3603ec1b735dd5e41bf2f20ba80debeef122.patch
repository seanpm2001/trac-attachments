diff --git a/src/stc/ScintillaWX.cpp b/src/stc/ScintillaWX.cpp
index 9144d9b..03d2c83 100644
--- a/src/stc/ScintillaWX.cpp
+++ b/src/stc/ScintillaWX.cpp
@@ -991,6 +991,15 @@ void ScintillaWX::DoLeftButtonDown(Point pt, unsigned int curTime, bool shift, b
     ButtonDown(pt, curTime, shift, ctrl, alt);
 }
 
+void ScintillaWX::DoRightButtonDown(Point pt, unsigned int curTime, bool shift, bool ctrl, bool alt) {
+    if (!PointInSelection(pt)) {
+        CancelModes();
+        SetEmptySelection(PositionFromLocation(pt));
+    }
+    
+    RightButtonDownWithModifiers(pt, curTime, ModifierFlags(shift, ctrl, alt));
+}
+
 void ScintillaWX::DoLeftButtonUp(Point pt, unsigned int curTime, bool ctrl) {
     ButtonUp(pt, curTime, ctrl);
 }
@@ -1135,7 +1144,7 @@ void ScintillaWX::DoCommand(int ID) {
 
 
 void ScintillaWX::DoContextMenu(Point pt) {
-    if (displayPopupMenu)
+    if (ShouldDisplayPopup(pt))
         ContextMenu(pt);
 }
 
diff --git a/src/stc/ScintillaWX.h b/src/stc/ScintillaWX.h
index 1afb3be..41c39b4 100644
--- a/src/stc/ScintillaWX.h
+++ b/src/stc/ScintillaWX.h
@@ -159,6 +159,7 @@ public:
     void DoGainFocus();
     void DoSysColourChange();
     void DoLeftButtonDown(Point pt, unsigned int curTime, bool shift, bool ctrl, bool alt);
+    void DoRightButtonDown(Point pt, unsigned int curTime, bool shift, bool ctrl, bool alt);
     void DoLeftButtonUp(Point pt, unsigned int curTime, bool ctrl);
     void DoLeftButtonMove(Point pt);
     void DoMiddleButtonUp(Point pt);
diff --git a/src/stc/gen_iface.py b/src/stc/gen_iface.py
index ef4440d..b75af98 100755
--- a/src/stc/gen_iface.py
+++ b/src/stc/gen_iface.py
@@ -140,7 +140,7 @@ methodOverrideMap = {
         }
         int len = endPos - startPos;
         if (!len) return buf;
-        TextRange tr;
+        Sci_TextRange tr;
         tr.lpstrText = (char*)buf.GetWriteBuf(len*2+1);
         tr.chrg.cpMin = startPos;
         tr.chrg.cpMax = endPos;
@@ -181,8 +181,6 @@ methodOverrideMap = {
 
      0),
 
-    'SetUsePalette' : (None, 0,0,0),
-
     'MarkerSetFore' : ('MarkerSetForeground', 0, 0, 0),
     'MarkerSetBack' : ('MarkerSetBackground', 0, 0, 0),
     'MarkerSetBackSelected' : ('MarkerSetBackgroundSelected', 0,0,0),
@@ -228,7 +226,10 @@ methodOverrideMap = {
         ''',
      ('Define a marker from a bitmap',)),
 
-
+    'GetMargins' : ('GetMarginCount', 0, 0, 0),
+    'SetMargins' : ('SetMarginCount', 0, 0, 0),
+    'GetMarginBackN' : ('GetMarginBackground', 0, 0, 0),
+    'SetMarginBackN' : ('SetMarginBackground', 0, 0, 0),
     'SetMarginTypeN' : ('SetMarginType', 0, 0, 0),
     'GetMarginTypeN' : ('GetMarginType', 0, 0, 0),
     'SetMarginWidthN' : ('SetMarginWidth', 0, 0, 0),
@@ -351,6 +352,16 @@ methodOverrideMap = {
 
     'ClearAllCmdKeys' : ('CmdKeyClearAll', 0, 0, 0),
 
+    'StartStyling' : 
+    (0,
+     'void %s(int start, int unused=0);',
+
+     '''void %s(int start, int unused) {
+        wxASSERT_MSG(unused==0, 
+                     "The second argument passed to StartStyling should be 0");
+        
+        SendMsg(%s, start, unused);''',
+     0),
 
     'SetStylingEx' :
     ('SetStyleBytes',
@@ -449,8 +460,6 @@ methodOverrideMap = {
 
     'GetCaretFore' : ('GetCaretForeground', 0, 0, 0),
 
-    'GetUsePalette' : (None, 0, 0, 0),
-
     'FindText' :
     (0,
      '''int %s(int minPos, int maxPos, const wxString& text, int flags=0);''',
@@ -458,7 +467,7 @@ methodOverrideMap = {
      '''int %s(int minPos, int maxPos,
                const wxString& text,
                int flags) {
-            TextToFind  ft;
+            Sci_TextToFind  ft;
             ft.chrg.cpMin = minPos;
             ft.chrg.cpMax = maxPos;
             const wxWX2MBbuf buf = wx2stc(text);
@@ -483,7 +492,7 @@ methodOverrideMap = {
                 wxDC*  target,
                 wxRect renderRect,
                 wxRect pageRect) {
-             RangeToFormat fr;
+             Sci_RangeToFormat fr;
 
              if (endPos < startPos) {
                  int temp = startPos;
@@ -558,7 +567,7 @@ methodOverrideMap = {
          if (!len) return wxEmptyString;
          wxMemoryBuffer mbuf(len+1);
          char* buf = (char*)mbuf.GetWriteBuf(len);
-         TextRange tr;
+         Sci_TextRange tr;
          tr.lpstrText = buf;
          tr.chrg.cpMin = startPos;
          tr.chrg.cpMax = endPos;
@@ -710,10 +719,20 @@ methodOverrideMap = {
      ("Retrieve a 'property' value previously set with SetProperty,",
       "with '$()' variable replacement on returned buffer.")),
 
-    'GetPropertyInt'   : (0, 0, 0,
+    'GetPropertyInt' : 
+    (0, 
+    'int %s(const wxString &key, int defaultValue=0) const;', 
+    '''int %s(const wxString &key, int defaultValue) const {
+        return SendMsg(%s, (uptr_t)(const char*)wx2stc(key), defaultValue);''',
        ("Retrieve a 'property' value previously set with SetProperty,",
         "interpreted as an int AFTER any '$()' variable replacement.")),
 
+    'BraceMatch' : 
+    (0, 
+    'int %s(int pos, int maxReStyle=0);', 
+    '''int %s(int pos, int maxReStyle){
+        return SendMsg(%s, pos, maxReStyle);''',
+     0),
 
     'GetDocPointer' :
     (0,
diff --git a/src/stc/scintilla/README.txt b/src/stc/scintilla/README.txt
index f5498d4..071178d 100644
--- a/src/stc/scintilla/README.txt
+++ b/src/stc/scintilla/README.txt
@@ -3,7 +3,7 @@ directories from the Scintilla source distribution. All other code
 needed to implement Scintilla on top of wxWidgets is located in the
 directory above this one.
 
-The current version of the Scintilla code is 3.6.6
+The current version of the Scintilla code is 3.7.2
 
 These are the basic steps needed to update the version of Scintilla used by wxSTC.  
 
diff --git a/src/stc/scintilla/include/Platform.h b/src/stc/scintilla/include/Platform.h
index 63269d0..1ff48ec 100644
--- a/src/stc/scintilla/include/Platform.h
+++ b/src/stc/scintilla/include/Platform.h
@@ -526,8 +526,4 @@ public:
 }
 #endif
 
-#if defined(__GNUC__) && defined(SCINTILLA_QT)
-#pragma GCC diagnostic ignored "-Wmissing-field-initializers"
-#endif
-
 #endif
diff --git a/src/stc/scintilla/include/SciLexer.h b/src/stc/scintilla/include/SciLexer.h
index 6b98b09..44c02a8 100644
--- a/src/stc/scintilla/include/SciLexer.h
+++ b/src/stc/scintilla/include/SciLexer.h
@@ -133,6 +133,7 @@
 #define SCLEX_IHEX 118
 #define SCLEX_TEHEX 119
 #define SCLEX_JSON 120
+#define SCLEX_EDIFACT 121
 #define SCLEX_AUTOMATIC 1000
 #define SCE_P_DEFAULT 0
 #define SCE_P_COMMENTLINE 1
@@ -599,6 +600,20 @@
 #define SCE_BAAN_IDENTIFIER 8
 #define SCE_BAAN_STRINGEOL 9
 #define SCE_BAAN_WORD2 10
+#define SCE_BAAN_WORD3 11
+#define SCE_BAAN_WORD4 12
+#define SCE_BAAN_WORD5 13
+#define SCE_BAAN_WORD6 14
+#define SCE_BAAN_WORD7 15
+#define SCE_BAAN_WORD8 16
+#define SCE_BAAN_WORD9 17
+#define SCE_BAAN_TABLEDEF 18
+#define SCE_BAAN_TABLESQL 19
+#define SCE_BAAN_FUNCTION 20
+#define SCE_BAAN_DOMDEF 21
+#define SCE_BAAN_FUNCDEF 22
+#define SCE_BAAN_OBJECTDEF 23
+#define SCE_BAAN_DEFINEDEF 24
 #define SCE_LISP_DEFAULT 0
 #define SCE_LISP_COMMENT 1
 #define SCE_LISP_NUMBER 2
@@ -1277,38 +1292,19 @@
 #define SCE_PLM_OPERATOR 5
 #define SCE_PLM_CONTROL 6
 #define SCE_PLM_KEYWORD 7
-#define SCE_4GL_DEFAULT 0
-#define SCE_4GL_NUMBER 1
-#define SCE_4GL_WORD 2
-#define SCE_4GL_STRING 3
-#define SCE_4GL_CHARACTER 4
-#define SCE_4GL_PREPROCESSOR 5
-#define SCE_4GL_OPERATOR 6
-#define SCE_4GL_IDENTIFIER 7
-#define SCE_4GL_BLOCK 8
-#define SCE_4GL_END 9
-#define SCE_4GL_COMMENT1 10
-#define SCE_4GL_COMMENT2 11
-#define SCE_4GL_COMMENT3 12
-#define SCE_4GL_COMMENT4 13
-#define SCE_4GL_COMMENT5 14
-#define SCE_4GL_COMMENT6 15
-#define SCE_4GL_DEFAULT_ 16
-#define SCE_4GL_NUMBER_ 17
-#define SCE_4GL_WORD_ 18
-#define SCE_4GL_STRING_ 19
-#define SCE_4GL_CHARACTER_ 20
-#define SCE_4GL_PREPROCESSOR_ 21
-#define SCE_4GL_OPERATOR_ 22
-#define SCE_4GL_IDENTIFIER_ 23
-#define SCE_4GL_BLOCK_ 24
-#define SCE_4GL_END_ 25
-#define SCE_4GL_COMMENT1_ 26
-#define SCE_4GL_COMMENT2_ 27
-#define SCE_4GL_COMMENT3_ 28
-#define SCE_4GL_COMMENT4_ 29
-#define SCE_4GL_COMMENT5_ 30
-#define SCE_4GL_COMMENT6_ 31
+#define SCE_ABL_DEFAULT 0
+#define SCE_ABL_NUMBER 1
+#define SCE_ABL_WORD 2
+#define SCE_ABL_STRING 3
+#define SCE_ABL_CHARACTER 4
+#define SCE_ABL_PREPROCESSOR 5
+#define SCE_ABL_OPERATOR 6
+#define SCE_ABL_IDENTIFIER 7
+#define SCE_ABL_BLOCK 8
+#define SCE_ABL_END 9
+#define SCE_ABL_COMMENT 10
+#define SCE_ABL_TASKMARKER 11
+#define SCE_ABL_LINECOMMENT 12
 #define SCE_ABAQUS_DEFAULT 0
 #define SCE_ABAQUS_COMMENT 1
 #define SCE_ABAQUS_COMMENTBLOCK 2
@@ -1802,6 +1798,15 @@
 #define SCE_JSON_KEYWORD 11
 #define SCE_JSON_LDKEYWORD 12
 #define SCE_JSON_ERROR 13
+#define SCE_EDI_DEFAULT 0
+#define SCE_EDI_SEGMENTSTART 1
+#define SCE_EDI_SEGMENTEND 2
+#define SCE_EDI_SEP_ELEMENT 3
+#define SCE_EDI_SEP_COMPOSITE 4
+#define SCE_EDI_SEP_RELEASE 5
+#define SCE_EDI_UNA 6
+#define SCE_EDI_UNH 7
+#define SCE_EDI_BADSEGMENT 8
 /* --Autogenerated -- end of section automatically generated from Scintilla.iface */
 
 #endif
diff --git a/src/stc/scintilla/include/Scintilla.h b/src/stc/scintilla/include/Scintilla.h
index 99bc6e7..6a36d24 100644
--- a/src/stc/scintilla/include/Scintilla.h
+++ b/src/stc/scintilla/include/Scintilla.h
@@ -11,8 +11,6 @@
 #ifndef SCINTILLA_H
 #define SCINTILLA_H
 
-#include "Sci_Position.h"
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -28,20 +26,21 @@ int Scintilla_LinkLexers(void);
 }
 #endif
 
-/* Here should be placed typedefs for uptr_t, an unsigned integer type large enough to
- * hold a pointer and sptr_t, a signed integer large enough to hold a pointer.
- * May need to be changed for 64 bit platforms. */
-#if defined(_WIN32)
-#include <basetsd.h>
-#endif
-#ifdef MAXULONG_PTR
-typedef ULONG_PTR uptr_t;
-typedef LONG_PTR sptr_t;
+// Include header that defines basic numeric types.
+#if defined(_MSC_VER)
+// Older releases of MSVC did not have stdint.h.
+#include <stddef.h>
 #else
-typedef unsigned long uptr_t;
-typedef long sptr_t;
+#include <stdint.h>
 #endif
 
+// Define uptr_t, an unsigned integer type large enough to hold a pointer.
+typedef uintptr_t uptr_t;
+// Define sptr_t, a signed integer large enough to hold a pointer.
+typedef intptr_t sptr_t;
+
+#include "Sci_Position.h"
+
 typedef sptr_t (*SciFnDirect)(sptr_t ptr, unsigned int iMessage, uptr_t wParam, sptr_t lParam);
 
 /* ++Autogenerated -- start of section automatically generated from Scintilla.iface */
@@ -76,6 +75,10 @@ typedef sptr_t (*SciFnDirect)(sptr_t ptr, unsigned int iMessage, uptr_t wParam,
 #define SCWS_VISIBLEONLYININDENT 3
 #define SCI_GETVIEWWS 2020
 #define SCI_SETVIEWWS 2021
+#define SCTD_LONGARROW 0
+#define SCTD_STRIKEOUT 1
+#define SCI_GETTABDRAWMODE 2698
+#define SCI_SETTABDRAWMODE 2699
 #define SCI_POSITIONFROMPOINT 2022
 #define SCI_POSITIONFROMPOINTCLOSE 2023
 #define SCI_GOTOLINE 2024
@@ -167,6 +170,7 @@ typedef sptr_t (*SciFnDirect)(sptr_t ptr, unsigned int iMessage, uptr_t wParam,
 #define SC_MARGIN_FORE 3
 #define SC_MARGIN_TEXT 4
 #define SC_MARGIN_RTEXT 5
+#define SC_MARGIN_COLOUR 6
 #define SCI_SETMARGINTYPEN 2240
 #define SCI_GETMARGINTYPEN 2241
 #define SCI_SETMARGINWIDTHN 2242
@@ -177,6 +181,10 @@ typedef sptr_t (*SciFnDirect)(sptr_t ptr, unsigned int iMessage, uptr_t wParam,
 #define SCI_GETMARGINSENSITIVEN 2247
 #define SCI_SETMARGINCURSORN 2248
 #define SCI_GETMARGINCURSORN 2249
+#define SCI_SETMARGINBACKN 2250
+#define SCI_GETMARGINBACKN 2251
+#define SCI_SETMARGINS 2252
+#define SCI_GETMARGINS 2253
 #define STYLE_DEFAULT 32
 #define STYLE_LINENUMBER 33
 #define STYLE_BRACELIGHT 34
@@ -184,6 +192,7 @@ typedef sptr_t (*SciFnDirect)(sptr_t ptr, unsigned int iMessage, uptr_t wParam,
 #define STYLE_CONTROLCHAR 36
 #define STYLE_INDENTGUIDE 37
 #define STYLE_CALLTIP 38
+#define STYLE_FOLDDISPLAYTEXT 39
 #define STYLE_LASTPREDEFINED 39
 #define STYLE_MAX 255
 #define SC_CHARSET_ANSI 0
@@ -282,6 +291,8 @@ typedef sptr_t (*SciFnDirect)(sptr_t ptr, unsigned int iMessage, uptr_t wParam,
 #define INDIC_COMPOSITIONTHIN 15
 #define INDIC_FULLBOX 16
 #define INDIC_TEXTFORE 17
+#define INDIC_POINT 18
+#define INDIC_POINTCHARACTER 19
 #define INDIC_IME 32
 #define INDIC_IME_MAX 35
 #define INDIC_MAX 35
@@ -475,6 +486,11 @@ typedef sptr_t (*SciFnDirect)(sptr_t ptr, unsigned int iMessage, uptr_t wParam,
 #define SCI_SETFOLDEXPANDED 2229
 #define SCI_GETFOLDEXPANDED 2230
 #define SCI_TOGGLEFOLD 2231
+#define SCI_TOGGLEFOLDSHOWTEXT 2700
+#define SC_FOLDDISPLAYTEXT_HIDDEN 0
+#define SC_FOLDDISPLAYTEXT_STANDARD 1
+#define SC_FOLDDISPLAYTEXT_BOXED 2
+#define SCI_FOLDDISPLAYTEXTSETSTYLE 2701
 #define SC_FOLDACTION_CONTRACT 0
 #define SC_FOLDACTION_EXPAND 1
 #define SC_FOLDACTION_TOGGLE 2
@@ -650,16 +666,22 @@ typedef sptr_t (*SciFnDirect)(sptr_t ptr, unsigned int iMessage, uptr_t wParam,
 #define EDGE_NONE 0
 #define EDGE_LINE 1
 #define EDGE_BACKGROUND 2
+#define EDGE_MULTILINE 3
 #define SCI_GETEDGECOLUMN 2360
 #define SCI_SETEDGECOLUMN 2361
 #define SCI_GETEDGEMODE 2362
 #define SCI_SETEDGEMODE 2363
 #define SCI_GETEDGECOLOUR 2364
 #define SCI_SETEDGECOLOUR 2365
+#define SCI_MULTIEDGEADDLINE 2694
+#define SCI_MULTIEDGECLEARALL 2695
 #define SCI_SEARCHANCHOR 2366
 #define SCI_SEARCHNEXT 2367
 #define SCI_SEARCHPREV 2368
 #define SCI_LINESONSCREEN 2370
+#define SC_POPUP_NEVER 0
+#define SC_POPUP_ALL 1
+#define SC_POPUP_TEXT 2
 #define SCI_USEPOPUP 2371
 #define SCI_SELECTIONISRECTANGLE 2372
 #define SCI_SETZOOM 2373
@@ -679,6 +701,8 @@ typedef sptr_t (*SciFnDirect)(sptr_t ptr, unsigned int iMessage, uptr_t wParam,
 #define SCI_GETSTATUS 2383
 #define SCI_SETMOUSEDOWNCAPTURES 2384
 #define SCI_GETMOUSEDOWNCAPTURES 2385
+#define SCI_SETMOUSEWHEELCAPTURES 2696
+#define SCI_GETMOUSEWHEELCAPTURES 2697
 #define SC_CURSORNORMAL -1
 #define SC_CURSORARROW 2
 #define SC_CURSORWAIT 4
@@ -895,6 +919,7 @@ typedef sptr_t (*SciFnDirect)(sptr_t ptr, unsigned int iMessage, uptr_t wParam,
 #define SCVS_NONE 0
 #define SCVS_RECTANGULARSELECTION 1
 #define SCVS_USERACCESSIBLE 2
+#define SCVS_NOWRAPLINESTART 4
 #define SCI_SETVIRTUALSPACEOPTIONS 2596
 #define SCI_GETVIRTUALSPACEOPTIONS 2597
 #define SCI_SETRECTANGULARSELECTIONMODIFIER 2598
@@ -1069,16 +1094,13 @@ typedef sptr_t (*SciFnDirect)(sptr_t ptr, unsigned int iMessage, uptr_t wParam,
 #define SCN_FOCUSIN 2028
 #define SCN_FOCUSOUT 2029
 #define SCN_AUTOCCOMPLETED 2030
+#define SCN_MARGINRIGHTCLICK 2031
 /* --Autogenerated -- end of section automatically generated from Scintilla.iface */
 
 /* These structures are defined to be exactly the same shape as the Win32
  * CHARRANGE, TEXTRANGE, FINDTEXTEX, FORMATRANGE, and NMHDR structs.
  * So older code that treats Scintilla as a RichEdit will work. */
 
-#if defined(__cplusplus) && defined(SCI_NAMESPACE)
-namespace Scintilla {
-#endif
-
 struct Sci_CharacterRange {
 	Sci_PositionCR cpMin;
 	Sci_PositionCR cpMax;
@@ -1095,10 +1117,6 @@ struct Sci_TextToFind {
 	struct Sci_CharacterRange chrgText;
 };
 
-#define CharacterRange Sci_CharacterRange
-#define TextRange Sci_TextRange
-#define TextToFind Sci_TextToFind
-
 typedef void *Sci_SurfaceID;
 
 struct Sci_Rectangle {
@@ -1119,8 +1137,6 @@ struct Sci_RangeToFormat {
 	struct Sci_CharacterRange chrg;
 };
 
-#define RangeToFormat Sci_RangeToFormat
-
 #ifndef __cplusplus
 /* For the GTK+ platform, g-ir-scanner needs to have these typedefs. This
  * is not required in C++ code and actually seems to break ScintillaEditPy */
@@ -1137,8 +1153,6 @@ struct Sci_NotifyHeader {
 	unsigned int code;
 };
 
-#define NotifyHeader Sci_NotifyHeader
-
 struct SCNotification {
 	Sci_NotifyHeader nmhdr;
 	Sci_Position position;
@@ -1178,18 +1192,17 @@ struct SCNotification {
 	/* SCN_AUTOCSELECTION, SCN_AUTOCCOMPLETED, SCN_USERLISTSELECTION, */
 };
 
-#if defined(__cplusplus) && defined(SCI_NAMESPACE)
-}
-#endif
-
 #ifdef INCLUDE_DEPRECATED_FEATURES
 
-#define SC_CP_DBCS 1
-#define SCI_SETUSEPALETTE 2039
-#define SCI_GETUSEPALETTE 2139
 #define SCI_SETKEYSUNICODE 2521
 #define SCI_GETKEYSUNICODE 2522
 
+#define CharacterRange Sci_CharacterRange
+#define TextRange Sci_TextRange
+#define TextToFind Sci_TextToFind
+#define RangeToFormat Sci_RangeToFormat
+#define NotifyHeader Sci_NotifyHeader
+
 #endif
 
 #endif
diff --git a/src/stc/scintilla/include/Scintilla.iface b/src/stc/scintilla/include/Scintilla.iface
index 310d877..6b9a77f 100644
--- a/src/stc/scintilla/include/Scintilla.iface
+++ b/src/stc/scintilla/include/Scintilla.iface
@@ -105,7 +105,7 @@ fun void ChangeInsertion=2672(int length, string text)
 fun void ClearAll=2004(,)
 
 # Delete a range of text in the document.
-fun void DeleteRange=2645(position pos, int deleteLength)
+fun void DeleteRange=2645(position start, int lengthDelete)
 
 # Set all style bytes to 0, remove all folding information.
 fun void ClearDocumentStyle=2005(,)
@@ -147,10 +147,10 @@ fun int GetStyledText=2015(, textrange tr)
 fun bool CanRedo=2016(,)
 
 # Retrieve the line number at which a particular marker is located.
-fun int MarkerLineFromHandle=2017(int handle,)
+fun int MarkerLineFromHandle=2017(int markerHandle,)
 
 # Delete a marker.
-fun void MarkerDeleteHandle=2018(int handle,)
+fun void MarkerDeleteHandle=2018(int markerHandle,)
 
 # Is undo history being collected?
 get bool GetUndoCollection=2019(,)
@@ -168,6 +168,17 @@ get int GetViewWS=2020(,)
 # Make white space characters invisible, always visible or visible outside indentation.
 set void SetViewWS=2021(int viewWS,)
 
+enu TabDrawMode=SCTD_
+val SCTD_LONGARROW=0
+val SCTD_STRIKEOUT=1
+
+# Retrieve the current tab draw mode.
+# Returns one of SCTD_* constants.
+get int GetTabDrawMode=2698(,)
+
+# Set how tabs are drawn when visible.
+set void SetTabDrawMode=2699(int tabDrawMode,)
+
 # Find the position from a point within the window.
 fun position PositionFromPoint=2022(int x, int y)
 
@@ -179,11 +190,11 @@ fun position PositionFromPointClose=2023(int x, int y)
 fun void GotoLine=2024(int line,)
 
 # Set caret to a position and ensure it is visible.
-fun void GotoPos=2025(position pos,)
+fun void GotoPos=2025(position caret,)
 
 # Set the selection anchor to a position. The anchor is the opposite
 # end of the selection from the caret.
-set void SetAnchor=2026(position posAnchor,)
+set void SetAnchor=2026(position anchor,)
 
 # Retrieve the text of the line containing the caret.
 # Returns the index of the caret on the line.
@@ -207,9 +218,9 @@ get int GetEOLMode=2030(,)
 # Set the current end of line mode.
 set void SetEOLMode=2031(int eolMode,)
 
-# Set the current styling position to pos and the styling mask to mask.
-# The styling mask can be used to protect some bits in each styling byte from modification.
-fun void StartStyling=2032(position pos, int mask)
+# Set the current styling position to start.
+# The unused parameter is no longer used and should be set to 0.
+fun void StartStyling=2032(position start, int unused)
 
 # Change style from current styling position for length characters to a style
 # and move the current styling position to after this newly styled segment.
@@ -346,7 +357,7 @@ fun int MarkerPrevious=2048(int lineStart, int markerMask)
 fun void MarkerDefinePixmap=2049(int markerNumber, string pixmap)
 
 # Add a set of markers to a line.
-fun void MarkerAddSet=2466(int line, int set)
+fun void MarkerAddSet=2466(int line, int markerSet)
 
 # Set the alpha used for a marker that is drawn in the text area, not the margin.
 set void MarkerSetAlpha=2476(int markerNumber, int alpha)
@@ -360,6 +371,7 @@ val SC_MARGIN_BACK=2
 val SC_MARGIN_FORE=3
 val SC_MARGIN_TEXT=4
 val SC_MARGIN_RTEXT=5
+val SC_MARGIN_COLOUR=6
 
 # Set a margin to be either numeric or symbolic.
 set void SetMarginTypeN=2240(int margin, int marginType)
@@ -391,6 +403,18 @@ set void SetMarginCursorN=2248(int margin, int cursor)
 # Retrieve the cursor shown in a margin.
 get int GetMarginCursorN=2249(int margin,)
 
+# Set the background colour of a margin. Only visible for SC_MARGIN_COLOUR.
+set void SetMarginBackN=2250(int margin, colour back)
+
+# Retrieve the background colour of a margin
+get colour GetMarginBackN=2251(int margin,)
+
+# Allocate a non-standard number of margins.
+set void SetMargins=2252(int margins,)
+
+# How many margins are there?.
+get int GetMargins=2253(,)
+
 # Styles in range 32..38 are predefined for parts of the UI and are not used as normal styles.
 # Style 39 is for future use.
 enu StylesCommon=STYLE_
@@ -401,6 +425,7 @@ val STYLE_BRACEBAD=35
 val STYLE_CONTROLCHAR=36
 val STYLE_INDENTGUIDE=37
 val STYLE_CALLTIP=38
+val STYLE_FOLDDISPLAYTEXT=39
 val STYLE_LASTPREDEFINED=39
 val STYLE_MAX=255
 
@@ -452,7 +477,7 @@ set void StyleSetSize=2055(int style, int sizePoints)
 set void StyleSetFont=2056(int style, string fontName)
 
 # Set a style to have its end of line filled or not.
-set void StyleSetEOLFilled=2057(int style, bool filled)
+set void StyleSetEOLFilled=2057(int style, bool eolFilled)
 
 # Reset the default style to its state at startup
 fun void StyleResetDefault=2058(,)
@@ -509,12 +534,12 @@ get bool StyleGetChangeable=2492(int style,)
 get bool StyleGetHotSpot=2493(int style,)
 
 # Set a style to be mixed case, or to force upper or lower case.
-set void StyleSetCase=2060(int style, int caseForce)
+set void StyleSetCase=2060(int style, int caseVisible)
 
 val SC_FONT_SIZE_MULTIPLIER=100
 
 # Set the size of characters of a style. Size is in points multiplied by 100.
-set void StyleSetSizeFractional=2061(int style, int caseForce)
+set void StyleSetSizeFractional=2061(int style, int sizeHundredthPoints)
 
 # Get the size of characters of a style in points multiplied by 100
 get int StyleGetSizeFractional=2062(int style,)
@@ -557,11 +582,11 @@ set void SetSelEOLFilled=2480(bool filled,)
 # Set the foreground colour of the caret.
 set void SetCaretFore=2069(colour fore,)
 
-# When key+modifier combination km is pressed perform msg.
-fun void AssignCmdKey=2070(keymod km, int msg)
+# When key+modifier combination keyDefinition is pressed perform sciCommand.
+fun void AssignCmdKey=2070(keymod keyDefinition, int sciCommand)
 
-# When key+modifier combination km is pressed do nothing.
-fun void ClearCmdKey=2071(keymod km,)
+# When key+modifier combination keyDefinition is pressed do nothing.
+fun void ClearCmdKey=2071(keymod keyDefinition,)
 
 # Drop all key mappings.
 fun void ClearAllCmdKeys=2072(,)
@@ -613,6 +638,8 @@ val INDIC_COMPOSITIONTHICK=14
 val INDIC_COMPOSITIONTHIN=15
 val INDIC_FULLBOX=16
 val INDIC_TEXTFORE=17
+val INDIC_POINT=18
+val INDIC_POINTCHARACTER=19
 val INDIC_IME=32
 val INDIC_IME_MAX=35
 val INDIC_MAX=35
@@ -623,34 +650,34 @@ val INDIC2_MASK=0x80
 val INDICS_MASK=0xE0
 
 # Set an indicator to plain, squiggle or TT.
-set void IndicSetStyle=2080(int indic, int style)
+set void IndicSetStyle=2080(int indicator, int indicatorStyle)
 
 # Retrieve the style of an indicator.
-get int IndicGetStyle=2081(int indic,)
+get int IndicGetStyle=2081(int indicator,)
 
 # Set the foreground colour of an indicator.
-set void IndicSetFore=2082(int indic, colour fore)
+set void IndicSetFore=2082(int indicator, colour fore)
 
 # Retrieve the foreground colour of an indicator.
-get colour IndicGetFore=2083(int indic,)
+get colour IndicGetFore=2083(int indicator,)
 
 # Set an indicator to draw under text or over(default).
-set void IndicSetUnder=2510(int indic, bool under)
+set void IndicSetUnder=2510(int indicator, bool under)
 
 # Retrieve whether indicator drawn under or over text.
-get bool IndicGetUnder=2511(int indic,)
+get bool IndicGetUnder=2511(int indicator,)
 
 # Set a hover indicator to plain, squiggle or TT.
-set void IndicSetHoverStyle=2680(int indic, int style)
+set void IndicSetHoverStyle=2680(int indicator, int indicatorStyle)
 
 # Retrieve the hover style of an indicator.
-get int IndicGetHoverStyle=2681(int indic,)
+get int IndicGetHoverStyle=2681(int indicator,)
 
 # Set the foreground hover colour of an indicator.
-set void IndicSetHoverFore=2682(int indic, colour fore)
+set void IndicSetHoverFore=2682(int indicator, colour fore)
 
 # Retrieve the foreground hover colour of an indicator.
-get colour IndicGetHoverFore=2683(int indic,)
+get colour IndicGetHoverFore=2683(int indicator,)
 
 val SC_INDICVALUEBIT=0x1000000
 val SC_INDICVALUEMASK=0xFFFFFF
@@ -659,10 +686,10 @@ enu IndicFlag=SC_INDICFLAG_
 val SC_INDICFLAG_VALUEFORE=1
 
 # Set the attributes of an indicator.
-set void IndicSetFlags=2684(int indic, int flags)
+set void IndicSetFlags=2684(int indicator, int flags)
 
 # Retrieve the attributes of an indicator.
-get int IndicGetFlags=2685(int indic,)
+get int IndicGetFlags=2685(int indicator,)
 
 # Set the foreground colour of all whitespace and whether to use this setting.
 fun void SetWhitespaceFore=2084(bool useSetting, colour fore)
@@ -710,9 +737,9 @@ set void SetCaretLineBack=2098(colour back,)
 set void StyleSetChangeable=2099(int style, bool changeable)
 
 # Display a auto-completion list.
-# The lenEntered parameter indicates how many characters before
+# The lengthEntered parameter indicates how many characters before
 # the caret should be used to provide context.
-fun void AutoCShow=2100(int lenEntered, string itemList)
+fun void AutoCShow=2100(int lengthEntered, string itemList)
 
 # Remove the auto-completion list from the screen.
 fun void AutoCCancel=2101(,)
@@ -737,7 +764,7 @@ set void AutoCSetSeparator=2106(int separatorCharacter,)
 get int AutoCGetSeparator=2107(,)
 
 # Select the item in the auto-completion list that starts with a string.
-fun void AutoCSelect=2108(, string text)
+fun void AutoCSelect=2108(, string select)
 
 # Should the auto-completion list be cancelled if the user backspaces to a
 # position before where the box was created.
@@ -820,7 +847,7 @@ set void SetUseTabs=2124(bool useTabs,)
 get bool GetUseTabs=2125(,)
 
 # Change the indentation of a line to a number of columns.
-set void SetLineIndentation=2126(int line, int indentSize)
+set void SetLineIndentation=2126(int line, int indentation)
 
 # Retrieve the number of columns that a line is indented.
 get int GetLineIndentation=2127(int line,)
@@ -832,10 +859,10 @@ get position GetLineIndentPosition=2128(int line,)
 get int GetColumn=2129(position pos,)
 
 # Count characters between two positions.
-fun int CountCharacters=2633(int startPos, int endPos)
+fun int CountCharacters=2633(position start, position end)
 
 # Show or hide the horizontal scroll bar.
-set void SetHScrollBar=2130(bool show,)
+set void SetHScrollBar=2130(bool visible,)
 # Is the horizontal scroll bar visible?
 get bool GetHScrollBar=2131(,)
 
@@ -871,22 +898,22 @@ get colour GetCaretFore=2138(,)
 get bool GetReadOnly=2140(,)
 
 # Sets the position of the caret.
-set void SetCurrentPos=2141(position pos,)
+set void SetCurrentPos=2141(position caret,)
 
 # Sets the position that starts the selection - this becomes the anchor.
-set void SetSelectionStart=2142(position pos,)
+set void SetSelectionStart=2142(position anchor,)
 
 # Returns the position at the start of the selection.
 get position GetSelectionStart=2143(,)
 
-# Sets the position that ends the selection - this becomes the currentPosition.
-set void SetSelectionEnd=2144(position pos,)
+# Sets the position that ends the selection - this becomes the caret.
+set void SetSelectionEnd=2144(position caret,)
 
 # Returns the position at the end of the selection.
 get position GetSelectionEnd=2145(,)
 
 # Set caret to a position, while removing any existing selection.
-fun void SetEmptySelection=2556(position pos,)
+fun void SetEmptySelection=2556(position caret,)
 
 # Sets the print magnification added to the point size of each style for printing.
 set void SetPrintMagnification=2146(int magnification,)
@@ -921,7 +948,7 @@ val SCFIND_POSIX=0x00400000
 val SCFIND_CXX11REGEX=0x00800000
 
 # Find some text in the document.
-fun position FindText=2150(int flags, findtext ft)
+fun position FindText=2150(int searchFlags, findtext ft)
 
 # On Windows, will draw the document into a display context such as a printer.
 fun position FormatRange=2151(bool draw, formatrange fr)
@@ -952,7 +979,7 @@ get int GetMarginRight=2158(,)
 get bool GetModify=2159(,)
 
 # Select a range of text.
-fun void SetSel=2160(position start, position end)
+fun void SetSel=2160(position anchor, position caret)
 
 # Retrieve the selected text.
 # Return the length of the text.
@@ -964,7 +991,7 @@ fun int GetSelText=2161(, stringresult text)
 fun int GetTextRange=2162(, textrange tr)
 
 # Draw the selection in normal style or with selection highlighted.
-fun void HideSelection=2163(bool normal,)
+fun void HideSelection=2163(bool hide,)
 
 # Retrieve the x value of the point in the window where a position is displayed.
 fun int PointXFromPosition=2164(, position pos)
@@ -1041,7 +1068,7 @@ get int GetDirectFunction=2184(,)
 get int GetDirectPointer=2185(,)
 
 # Set to overtype (true) or insert mode.
-set void SetOvertype=2186(bool overtype,)
+set void SetOvertype=2186(bool overType,)
 
 # Returns true if overtype mode is active otherwise false is returned.
 get bool GetOvertype=2187(,)
@@ -1054,14 +1081,14 @@ get int GetCaretWidth=2189(,)
 
 # Sets the position that starts the target which is used for updating the
 # document without affecting the scroll position.
-set void SetTargetStart=2190(position pos,)
+set void SetTargetStart=2190(position start,)
 
 # Get the position that starts the target.
 get position GetTargetStart=2191(,)
 
 # Sets the position that ends the target which is used for updating the
 # document without affecting the scroll position.
-set void SetTargetEnd=2192(position pos,)
+set void SetTargetEnd=2192(position end,)
 
 # Get the position that ends the target.
 get position GetTargetEnd=2193(,)
@@ -1070,7 +1097,7 @@ get position GetTargetEnd=2193(,)
 fun void SetTargetRange=2686(position start, position end)
 
 # Retrieve the text in the target.
-get int GetTargetText=2687(, stringresult characters)
+get int GetTargetText=2687(, stringresult text)
 
 # Make the target range start and end be the same as the selection range start and end.
 fun void TargetFromSelection=2287(,)
@@ -1097,7 +1124,7 @@ fun int ReplaceTargetRE=2195(int length, string text)
 fun int SearchInTarget=2197(int length, string text)
 
 # Set the search flags used by SearchInTarget.
-set void SetSearchFlags=2198(int flags,)
+set void SetSearchFlags=2198(int searchFlags,)
 
 # Get the search flags used by SearchInTarget.
 get int GetSearchFlags=2199(,)
@@ -1118,7 +1145,7 @@ fun position CallTipPosStart=2203(,)
 set void CallTipSetPosStart=2214(int posStart,)
 
 # Highlight a segment of the definition.
-fun void CallTipSetHlt=2204(int start, int end)
+fun void CallTipSetHlt=2204(int highlightStart, int highlightEnd)
 
 # Set the background colour for the call tip.
 set void CallTipSetBack=2205(colour back,)
@@ -1136,13 +1163,13 @@ set void CallTipUseStyle=2212(int tabSize,)
 set void CallTipSetPosition=2213(bool above,)
 
 # Find the display line of a document line taking hidden lines into account.
-fun int VisibleFromDocLine=2220(int line,)
+fun int VisibleFromDocLine=2220(int docLine,)
 
 # Find the document line of a display line taking hidden lines into account.
-fun int DocLineFromVisible=2221(int lineDisplay,)
+fun int DocLineFromVisible=2221(int displayLine,)
 
 # The number of display lines needed to wrap a document line
-fun int WrapCount=2235(int line,)
+fun int WrapCount=2235(int docLine,)
 
 enu FoldLevel=SC_FOLDLEVEL
 val SC_FOLDLEVELBASE=0x400
@@ -1185,7 +1212,18 @@ get bool GetFoldExpanded=2230(int line,)
 # Switch a header line between expanded and contracted.
 fun void ToggleFold=2231(int line,)
 
-enu FoldAction=SC_FOLDACTION
+# Switch a header line between expanded and contracted and show some text after the line.
+fun void ToggleFoldShowText=2700(int line, string text)
+
+enu foldDisplayTextStyle=SC_FOLDDISPLAYTEXTSTYLE_
+val SC_FOLDDISPLAYTEXT_HIDDEN=0
+val SC_FOLDDISPLAYTEXT_STANDARD=1
+val SC_FOLDDISPLAYTEXT_BOXED=2
+
+# Set the style of fold display text
+set void FoldDisplayTextSetStyle=2701(int style,)
+
+enu FoldAction=SC_FOLDACTION_
 val SC_FOLDACTION_CONTRACT=0
 val SC_FOLDACTION_EXPAND=1
 val SC_FOLDACTION_TOGGLE=2
@@ -1279,7 +1317,7 @@ val SC_WRAP_CHAR=2
 val SC_WRAP_WHITESPACE=3
 
 # Sets whether text is word wrapped.
-set void SetWrapMode=2268(int mode,)
+set void SetWrapMode=2268(int wrapMode,)
 
 # Retrieve whether text is word wrapped.
 get int GetWrapMode=2269(,)
@@ -1319,7 +1357,7 @@ val SC_WRAPINDENT_SAME=1
 val SC_WRAPINDENT_INDENT=2
 
 # Sets how wrapped sublines are placed. Default is fixed.
-set void SetWrapIndentMode=2472(int mode,)
+set void SetWrapIndentMode=2472(int wrapIndentMode,)
 
 # Retrieve how wrapped sublines are placed. Default is fixed.
 get int GetWrapIndentMode=2473(,)
@@ -1331,7 +1369,7 @@ val SC_CACHE_PAGE=2
 val SC_CACHE_DOCUMENT=3
 
 # Sets the degree of caching of layout information.
-set void SetLayoutCache=2272(int mode,)
+set void SetLayoutCache=2272(int cacheMode,)
 
 # Retrieve the degree of caching of layout information.
 get int GetLayoutCache=2273(,)
@@ -1366,7 +1404,7 @@ get bool GetEndAtLastLine=2278(,)
 fun int TextHeight=2279(int line,)
 
 # Show or hide the vertical scroll bar.
-set void SetVScrollBar=2280(bool show,)
+set void SetVScrollBar=2280(bool visible,)
 
 # Is the vertical scroll bar visible?
 get bool GetVScrollBar=2281(,)
@@ -1381,7 +1419,7 @@ get bool GetTwoPhaseDraw=2283(,)
 # and then the foreground. This avoids chopping off characters that overlap the next run.
 set void SetTwoPhaseDraw=2284(bool twoPhase,)
 
-enu FontQuality=SC_PHASES_
+enu PhasesDraw=SC_PHASES_
 val SC_PHASES_ONE=0
 val SC_PHASES_TWO=1
 val SC_PHASES_MULTIPLE=2
@@ -1411,7 +1449,7 @@ set void SetFontQuality=2611(int fontQuality,)
 get int GetFontQuality=2612(,)
 
 # Scroll so that a display line is at the top of the display.
-set void SetFirstVisibleLine=2613(int lineDisplay,)
+set void SetFirstVisibleLine=2613(int displayLine,)
 
 enu MultiPaste=SC_MULTIPASTE_
 val SC_MULTIPASTE_ONCE=0
@@ -1434,8 +1472,9 @@ fun void LinesJoin=2288(,)
 # where possible.
 fun void LinesSplit=2289(int pixelWidth,)
 
-# Set the colours used as a chequerboard pattern in the fold margin
+# Set one of the colours used as a chequerboard pattern in the fold margin
 fun void SetFoldMarginColour=2290(bool useSetting, colour back)
+# Set the other colour used as a chequerboard pattern in the fold margin
 fun void SetFoldMarginHiColour=2291(bool useSetting, colour fore)
 
 ## New messages go here
@@ -1599,17 +1638,28 @@ fun void LineEndDisplay=2347(,)
 # caret position.
 fun void LineEndDisplayExtend=2348(,)
 
-# These are like their namesakes Home(Extend)?, LineEnd(Extend)?, VCHome(Extend)?
-# except they behave differently when word-wrap is enabled:
-# They go first to the start / end of the display line, like (Home|LineEnd)Display
-# The difference is that, the cursor is already at the point, it goes on to the start
-# or end of the document line, as appropriate for (Home|LineEnd|VCHome)(Extend)?.
-
+# Like Home but when word-wrap is enabled goes first to start of display line
+# HomeDisplay, then to start of document line Home.
 fun void HomeWrap=2349(,)
+
+# Like HomeExtend but when word-wrap is enabled extends first to start of display line
+# HomeDisplayExtend, then to start of document line HomeExtend.
 fun void HomeWrapExtend=2450(,)
+
+# Like LineEnd but when word-wrap is enabled goes first to end of display line
+# LineEndDisplay, then to start of document line LineEnd.
 fun void LineEndWrap=2451(,)
+
+# Like LineEndExtend but when word-wrap is enabled extends first to end of display line
+# LineEndDisplayExtend, then to start of document line LineEndExtend.
 fun void LineEndWrapExtend=2452(,)
+
+# Like VCHome but when word-wrap is enabled goes first to start of display line
+# VCHomeDisplay, then behaves like VCHome.
 fun void VCHomeWrap=2453(,)
+
+# Like VCHomeExtend but when word-wrap is enabled extends first to start of display line
+# VCHomeDisplayExtend, then behaves like VCHomeExtend.
 fun void VCHomeWrapExtend=2454(,)
 
 # Copy the line containing the caret.
@@ -1622,19 +1672,20 @@ fun void MoveCaretInsideView=2401(,)
 fun int LineLength=2350(int line,)
 
 # Highlight the characters at two positions.
-fun void BraceHighlight=2351(position pos1, position pos2)
+fun void BraceHighlight=2351(position posA, position posB)
 
 # Use specified indicator to highlight matching braces instead of changing their style.
-fun void BraceHighlightIndicator=2498(bool useBraceHighlightIndicator, int indicator)
+fun void BraceHighlightIndicator=2498(bool useSetting, int indicator)
 
 # Highlight the character at a position indicating there is no matching brace.
 fun void BraceBadLight=2352(position pos,)
 
 # Use specified indicator to highlight non matching brace instead of changing its style.
-fun void BraceBadLightIndicator=2499(bool useBraceBadLightIndicator, int indicator)
+fun void BraceBadLightIndicator=2499(bool useSetting, int indicator)
 
 # Find the position of a matching brace or INVALID_POSITION if no match.
-fun position BraceMatch=2353(position pos,)
+# The maxReStyle must be 0 for now. It may be defined in a future release.
+fun position BraceMatch=2353(position pos, int maxReStyle)
 
 # Are the end of line characters visible?
 get bool GetViewEOL=2355(,)
@@ -1646,15 +1697,16 @@ set void SetViewEOL=2356(bool visible,)
 get int GetDocPointer=2357(,)
 
 # Change the document object used.
-set void SetDocPointer=2358(, int pointer)
+set void SetDocPointer=2358(, int doc)
 
 # Set which document modification events are sent to the container.
-set void SetModEventMask=2359(int mask,)
+set void SetModEventMask=2359(int eventMask,)
 
 enu EdgeVisualStyle=EDGE_
 val EDGE_NONE=0
 val EDGE_LINE=1
 val EDGE_BACKGROUND=2
+val EDGE_MULTILINE=3
 
 # Retrieve the column number which text should be kept within.
 get int GetEdgeColumn=2360(,)
@@ -1666,9 +1718,9 @@ set void SetEdgeColumn=2361(int column,)
 # Retrieve the edge highlight mode.
 get int GetEdgeMode=2362(,)
 
-# The edge may be displayed by a line (EDGE_LINE) or by highlighting text that
+# The edge may be displayed by a line (EDGE_LINE/EDGE_MULTILINE) or by highlighting text that
 # goes beyond it (EDGE_BACKGROUND) or not displayed at all (EDGE_NONE).
-set void SetEdgeMode=2363(int mode,)
+set void SetEdgeMode=2363(int edgeMode,)
 
 # Retrieve the colour used in edge indication.
 get colour GetEdgeColour=2364(,)
@@ -1676,30 +1728,41 @@ get colour GetEdgeColour=2364(,)
 # Change the colour used in edge indication.
 set void SetEdgeColour=2365(colour edgeColour,)
 
+# Add a new vertical edge to the view.
+fun void MultiEdgeAddLine=2694(int column, colour edgeColour)
+
+# Clear all vertical edges.
+fun void MultiEdgeClearAll=2695(,)
+
 # Sets the current caret position to be the search anchor.
 fun void SearchAnchor=2366(,)
 
 # Find some text starting at the search anchor.
 # Does not ensure the selection is visible.
-fun int SearchNext=2367(int flags, string text)
+fun int SearchNext=2367(int searchFlags, string text)
 
 # Find some text starting at the search anchor and moving backwards.
 # Does not ensure the selection is visible.
-fun int SearchPrev=2368(int flags, string text)
+fun int SearchPrev=2368(int searchFlags, string text)
 
 # Retrieves the number of lines completely visible.
 get int LinesOnScreen=2370(,)
 
+enu PopUp=SC_POPUP_
+val SC_POPUP_NEVER=0
+val SC_POPUP_ALL=1
+val SC_POPUP_TEXT=2
+
 # Set whether a pop up menu is displayed automatically when the user presses
-# the wrong mouse button.
-fun void UsePopUp=2371(bool allowPopUp,)
+# the wrong mouse button on certain areas.
+fun void UsePopUp=2371(int popUpMode,)
 
 # Is the selection rectangular? The alternative is the more common stream selection.
 get bool SelectionIsRectangle=2372(,)
 
 # Set the zoom level. This number of points is added to the size of all fonts.
 # It may be positive to magnify or negative to reduce.
-set void SetZoom=2373(int zoom,)
+set void SetZoom=2373(int zoomInPoints,)
 # Retrieve the zoom level.
 get int GetZoom=2374(,)
 
@@ -1727,7 +1790,7 @@ val SC_STATUS_WARN_START=1000
 val SC_STATUS_WARN_REGEX=1001
 
 # Change error status - 0 = OK.
-set void SetStatus=2382(int statusCode,)
+set void SetStatus=2382(int status,)
 # Get error status.
 get int GetStatus=2383(,)
 
@@ -1736,6 +1799,11 @@ set void SetMouseDownCaptures=2384(bool captures,)
 # Get whether mouse gets captured.
 get bool GetMouseDownCaptures=2385(,)
 
+# Set whether the mouse wheel can be active outside the window.
+set void SetMouseWheelCaptures=2696(bool captures,)
+# Get whether mouse wheel can be active outside the window.
+get bool GetMouseWheelCaptures=2697(,)
+
 enu CursorShape=SC_CURSOR
 val SC_CURSORNORMAL=-1
 val SC_CURSORARROW=2
@@ -1777,7 +1845,7 @@ fun void DelLineLeft=2395(,)
 fun void DelLineRight=2396(,)
 
 # Get and Set the xOffset (ie, horizontal scroll position).
-set void SetXOffset=2397(int newOffset,)
+set void SetXOffset=2397(int xOffset,)
 get int GetXOffset=2398(,)
 
 # Set the last x chosen value to be the caret x position.
@@ -1819,7 +1887,7 @@ fun void SetXCaretPolicy=2402(int caretPolicy, int caretSlop)
 fun void SetYCaretPolicy=2403(int caretPolicy, int caretSlop)
 
 # Set printing to line wrapped (SC_WRAP_WORD) or not line wrapped (SC_WRAP_NONE).
-set void SetPrintWrapMode=2406(int mode,)
+set void SetPrintWrapMode=2406(int wrapMode,)
 
 # Is printing line wrapped?
 get int GetPrintWrapMode=2407(,)
@@ -1848,10 +1916,13 @@ set void SetHotspotSingleLine=2421(bool singleLine,)
 # Get the HotspotSingleLine property
 get bool GetHotspotSingleLine=2497(,)
 
-# Move caret between paragraphs (delimited by empty lines).
+# Move caret down one paragraph (delimited by empty lines).
 fun void ParaDown=2413(,)
+# Extend selection down one paragraph (delimited by empty lines).
 fun void ParaDownExtend=2414(,)
+# Move caret up one paragraph (delimited by empty lines).
 fun void ParaUp=2415(,)
+# Extend selection up one paragraph (delimited by empty lines).
 fun void ParaUpExtend=2416(,)
 
 # Given a valid document position, return the previous position taking code
@@ -1880,7 +1951,7 @@ val SC_SEL_THIN=3
 
 # Set the selection mode to stream (SC_SEL_STREAM) or rectangular (SC_SEL_RECTANGLE/SC_SEL_THIN) or
 # by lines (SC_SEL_LINES).
-set void SetSelectionMode=2422(int mode,)
+set void SetSelectionMode=2422(int selectionMode,)
 
 # Get the mode of the current selection.
 get int GetSelectionMode=2423(,)
@@ -1970,7 +2041,7 @@ get int AutoCGetCurrent=2445(,)
 # Get currently selected item text in the auto-completion list
 # Returns the length of the item text
 # Result is NUL-terminated.
-get int AutoCGetCurrentText=2610(, stringresult s)
+get int AutoCGetCurrentText=2610(, stringresult text)
 
 enu CaseInsensitiveBehaviour=SC_CASEINSENSITIVEBEHAVIOUR_
 val SC_CASEINSENSITIVEBEHAVIOUR_RESPECTCASE=0
@@ -2080,22 +2151,22 @@ set void SetIndicatorValue=2502(int value,)
 get int GetIndicatorValue=2503(,)
 
 # Turn a indicator on over a range.
-fun void IndicatorFillRange=2504(int position, int fillLength)
+fun void IndicatorFillRange=2504(position start, int lengthFill)
 
 # Turn a indicator off over a range.
-fun void IndicatorClearRange=2505(int position, int clearLength)
+fun void IndicatorClearRange=2505(position start, int lengthClear)
 
-# Are any indicators present at position?
-fun int IndicatorAllOnFor=2506(int position,)
+# Are any indicators present at pos?
+fun int IndicatorAllOnFor=2506(position pos,)
 
-# What value does a particular indicator have at at a position?
-fun int IndicatorValueAt=2507(int indicator, int position)
+# What value does a particular indicator have at a position?
+fun int IndicatorValueAt=2507(int indicator, position pos)
 
 # Where does a particular indicator start?
-fun int IndicatorStart=2508(int indicator, int position)
+fun int IndicatorStart=2508(int indicator, position pos)
 
 # Where does a particular indicator end?
-fun int IndicatorEnd=2509(int indicator, int position)
+fun int IndicatorEnd=2509(int indicator, position pos)
 
 # Set number of entries in position cache
 set void SetPositionCache=2514(int size,)
@@ -2112,8 +2183,8 @@ get int GetCharacterPointer=2520(,)
 
 # Return a read-only pointer to a range of characters in the document.
 # May move the gap so that the range is contiguous, but will only move up
-# to rangeLength bytes.
-get int GetRangePointer=2643(int position, int rangeLength)
+# to lengthRange bytes.
+get int GetRangePointer=2643(position start, int lengthRange)
 
 # Return a position which, to avoid performance costs, should not be within
 # the range of a call to GetRangePointer.
@@ -2268,7 +2339,7 @@ set void SetAdditionalCaretsBlink=2567(bool additionalCaretsBlink,)
 get bool GetAdditionalCaretsBlink=2568(,)
 
 # Set whether additional carets are visible
-set void SetAdditionalCaretsVisible=2608(bool additionalCaretsBlink,)
+set void SetAdditionalCaretsVisible=2608(bool additionalCaretsVisible,)
 
 # Whether additional carets are visible
 get bool GetAdditionalCaretsVisible=2609(,)
@@ -2283,10 +2354,10 @@ get bool GetSelectionEmpty=2650(,)
 fun void ClearSelections=2571(,)
 
 # Set a simple selection
-fun int SetSelection=2572(int caret, int anchor)
+fun int SetSelection=2572(position caret, position anchor)
 
 # Add a selection
-fun int AddSelection=2573(int caret, int anchor)
+fun int AddSelection=2573(position caret, position anchor)
 
 # Drop one selection
 fun void DropSelectionN=2671(int selection,)
@@ -2297,42 +2368,61 @@ set void SetMainSelection=2574(int selection,)
 # Which selection is the main selection
 get int GetMainSelection=2575(,)
 
-set void SetSelectionNCaret=2576(int selection, position pos)
+# Set the caret position of the nth selection.
+set void SetSelectionNCaret=2576(int selection, position caret)
+# Return the caret position of the nth selection.
 get position GetSelectionNCaret=2577(int selection,)
-set void SetSelectionNAnchor=2578(int selection, position posAnchor)
+# Set the anchor position of the nth selection.
+set void SetSelectionNAnchor=2578(int selection, position anchor)
+# Return the anchor position of the nth selection.
 get position GetSelectionNAnchor=2579(int selection,)
+# Set the virtual space of the caret of the nth selection.
 set void SetSelectionNCaretVirtualSpace=2580(int selection, int space)
+# Return the virtual space of the caret of the nth selection.
 get int GetSelectionNCaretVirtualSpace=2581(int selection,)
+# Set the virtual space of the anchor of the nth selection.
 set void SetSelectionNAnchorVirtualSpace=2582(int selection, int space)
+# Return the virtual space of the anchor of the nth selection.
 get int GetSelectionNAnchorVirtualSpace=2583(int selection,)
 
 # Sets the position that starts the selection - this becomes the anchor.
-set void SetSelectionNStart=2584(int selection, position pos)
+set void SetSelectionNStart=2584(int selection, position anchor)
 
 # Returns the position at the start of the selection.
 get position GetSelectionNStart=2585(int selection,)
 
 # Sets the position that ends the selection - this becomes the currentPosition.
-set void SetSelectionNEnd=2586(int selection, position pos)
+set void SetSelectionNEnd=2586(int selection, position caret)
 
 # Returns the position at the end of the selection.
 get position GetSelectionNEnd=2587(int selection,)
 
-set void SetRectangularSelectionCaret=2588(position pos,)
+# Set the caret position of the rectangular selection.
+set void SetRectangularSelectionCaret=2588(position caret,)
+# Return the caret position of the rectangular selection.
 get position GetRectangularSelectionCaret=2589(,)
-set void SetRectangularSelectionAnchor=2590(position posAnchor,)
+# Set the anchor position of the rectangular selection.
+set void SetRectangularSelectionAnchor=2590(position anchor,)
+# Return the anchor position of the rectangular selection.
 get position GetRectangularSelectionAnchor=2591(,)
+# Set the virtual space of the caret of the rectangular selection.
 set void SetRectangularSelectionCaretVirtualSpace=2592(int space,)
+# Return the virtual space of the caret of the rectangular selection.
 get int GetRectangularSelectionCaretVirtualSpace=2593(,)
+# Set the virtual space of the anchor of the rectangular selection.
 set void SetRectangularSelectionAnchorVirtualSpace=2594(int space,)
+# Return the virtual space of the anchor of the rectangular selection.
 get int GetRectangularSelectionAnchorVirtualSpace=2595(,)
 
 enu VirtualSpace=SCVS_
 val SCVS_NONE=0
 val SCVS_RECTANGULARSELECTION=1
 val SCVS_USERACCESSIBLE=2
+val SCVS_NOWRAPLINESTART=4
 
+# Set options for virtual space behaviour.
 set void SetVirtualSpaceOptions=2596(int virtualSpaceOptions,)
+# Return options for virtual space behaviour.
 get int GetVirtualSpaceOptions=2597(,)
 
 # On GTK+, allow selecting the modifier key to use for mouse-based
@@ -2509,7 +2599,7 @@ set void SetProperty=4004(string key, string value)
 val KEYWORDSET_MAX=8
 
 # Set up the key words used by the lexer.
-set void SetKeyWords=4005(int keywordSet, string keyWords)
+set void SetKeyWords=4005(int keyWordSet, string keyWords)
 
 # Set the lexing language of the document based on string name.
 set void SetLexerLanguage=4006(, string language)
@@ -2519,16 +2609,16 @@ fun void LoadLexerLibrary=4007(, string path)
 
 # Retrieve a "property" value previously set with SetProperty.
 # Result is NUL-terminated.
-get int GetProperty=4008(string key, stringresult buf)
+get int GetProperty=4008(string key, stringresult value)
 
 # Retrieve a "property" value previously set with SetProperty,
 # with "$()" variable replacement on returned buffer.
 # Result is NUL-terminated.
-get int GetPropertyExpanded=4009(string key, stringresult buf)
+get int GetPropertyExpanded=4009(string key, stringresult value)
 
 # Retrieve a "property" value previously set with SetProperty,
 # interpreted as an int AFTER any "$()" variable replacement.
-get int GetPropertyInt=4010(string key,)
+get int GetPropertyInt=4010(string key, int defaultValue)
 
 # Retrieve the number of bits the current lexer needs for styling.
 get int GetStyleBitsNeeded=4011(,)
@@ -2536,7 +2626,7 @@ get int GetStyleBitsNeeded=4011(,)
 # Retrieve the name of the lexer.
 # Return the length of the text.
 # Result is NUL-terminated.
-get int GetLexerLanguage=4012(, stringresult text)
+get int GetLexerLanguage=4012(, stringresult language)
 
 # For private communication between an application and a known lexer.
 fun int PrivateLexerCall=4013(int operation, int pointer)
@@ -2800,6 +2890,7 @@ val SCLEX_SREC=117
 val SCLEX_IHEX=118
 val SCLEX_TEHEX=119
 val SCLEX_JSON=120
+val SCLEX_EDIFACT=121
 
 # When a lexer specifies its language as SCLEX_AUTOMATIC it receives a
 # value assigned in sequence from SCLEX_AUTOMATIC+1.
@@ -3332,6 +3423,20 @@ val SCE_BAAN_OPERATOR=7
 val SCE_BAAN_IDENTIFIER=8
 val SCE_BAAN_STRINGEOL=9
 val SCE_BAAN_WORD2=10
+val SCE_BAAN_WORD3=11
+val SCE_BAAN_WORD4=12
+val SCE_BAAN_WORD5=13
+val SCE_BAAN_WORD6=14
+val SCE_BAAN_WORD7=15
+val SCE_BAAN_WORD8=16
+val SCE_BAAN_WORD9=17
+val SCE_BAAN_TABLEDEF=18
+val SCE_BAAN_TABLESQL=19
+val SCE_BAAN_FUNCTION=20
+val SCE_BAAN_DOMDEF=21
+val SCE_BAAN_FUNCDEF=22
+val SCE_BAAN_OBJECTDEF=23
+val SCE_BAAN_DEFINEDEF=24
 # Lexical states for SCLEX_LISP
 lex Lisp=SCLEX_LISP SCE_LISP_
 val SCE_LISP_DEFAULT=0
@@ -4106,39 +4211,20 @@ val SCE_PLM_OPERATOR=5
 val SCE_PLM_CONTROL=6
 val SCE_PLM_KEYWORD=7
 # Lexical state for SCLEX_PROGRESS
-lex Progress=SCLEX_PROGRESS SCE_4GL_
-val SCE_4GL_DEFAULT=0
-val SCE_4GL_NUMBER=1
-val SCE_4GL_WORD=2
-val SCE_4GL_STRING=3
-val SCE_4GL_CHARACTER=4
-val SCE_4GL_PREPROCESSOR=5
-val SCE_4GL_OPERATOR=6
-val SCE_4GL_IDENTIFIER=7
-val SCE_4GL_BLOCK=8
-val SCE_4GL_END=9
-val SCE_4GL_COMMENT1=10
-val SCE_4GL_COMMENT2=11
-val SCE_4GL_COMMENT3=12
-val SCE_4GL_COMMENT4=13
-val SCE_4GL_COMMENT5=14
-val SCE_4GL_COMMENT6=15
-val SCE_4GL_DEFAULT_=16
-val SCE_4GL_NUMBER_=17
-val SCE_4GL_WORD_=18
-val SCE_4GL_STRING_=19
-val SCE_4GL_CHARACTER_=20
-val SCE_4GL_PREPROCESSOR_=21
-val SCE_4GL_OPERATOR_=22
-val SCE_4GL_IDENTIFIER_=23
-val SCE_4GL_BLOCK_=24
-val SCE_4GL_END_=25
-val SCE_4GL_COMMENT1_=26
-val SCE_4GL_COMMENT2_=27
-val SCE_4GL_COMMENT3_=28
-val SCE_4GL_COMMENT4_=29
-val SCE_4GL_COMMENT5_=30
-val SCE_4GL_COMMENT6_=31
+lex Progress=SCLEX_PROGRESS SCE_ABL_
+val SCE_ABL_DEFAULT=0
+val SCE_ABL_NUMBER=1
+val SCE_ABL_WORD=2
+val SCE_ABL_STRING=3
+val SCE_ABL_CHARACTER=4
+val SCE_ABL_PREPROCESSOR=5
+val SCE_ABL_OPERATOR=6
+val SCE_ABL_IDENTIFIER=7
+val SCE_ABL_BLOCK=8
+val SCE_ABL_END=9
+val SCE_ABL_COMMENT=10
+val SCE_ABL_TASKMARKER=11
+val SCE_ABL_LINECOMMENT=12
 # Lexical states for SCLEX_ABAQUS
 lex ABAQUS=SCLEX_ABAQUS SCE_ABAQUS_
 val SCE_ABAQUS_DEFAULT=0
@@ -4694,6 +4780,16 @@ val SCE_JSON_COMPACTIRI=10
 val SCE_JSON_KEYWORD=11
 val SCE_JSON_LDKEYWORD=12
 val SCE_JSON_ERROR=13
+lex EDIFACT=SCLEX_EDIFACT SCE_EDI_
+val SCE_EDI_DEFAULT=0
+val SCE_EDI_SEGMENTSTART=1
+val SCE_EDI_SEGMENTEND=2
+val SCE_EDI_SEP_ELEMENT=3
+val SCE_EDI_SEP_COMPOSITE=4
+val SCE_EDI_SEP_RELEASE=5
+val SCE_EDI_UNA=6
+val SCE_EDI_UNH=7
+val SCE_EDI_BADSEGMENT=8
 
 # Events
 
@@ -4728,6 +4824,7 @@ evt void HotSpotReleaseClick=2027(int modifiers, int position)
 evt void FocusIn=2028(void)
 evt void FocusOut=2029(void)
 evt void AutoCCompleted=2030(string text, int position, int ch, CompletionMethods listCompletionMethod)
+evt void MarginRightClick=2031(int modifiers, int position, int margin)
 
 # There are no provisional APIs currently, but some arguments to SCI_SETTECHNOLOGY are provisional.
 
@@ -4735,19 +4832,6 @@ cat Provisional
 
 cat Deprecated
 
-# Deprecated in 2.21
-# The SC_CP_DBCS value can be used to indicate a DBCS mode for GTK+.
-val SC_CP_DBCS=1
-
-# Deprecated in 2.30
-
-# In palette mode?
-get bool GetUsePalette=2139(,)
-
-# In palette mode, Scintilla uses the environment's palette calls to display
-# more colours. This may lead to ugly displays.
-set void SetUsePalette=2039(bool usePalette,)
-
 # Deprecated in 3.5.5
 
 # Always interpret keyboard input as Unicode
diff --git a/src/stc/scintilla/lexers/LexAbaqus.cxx b/src/stc/scintilla/lexers/LexAbaqus.cxx
index 509d89a..5f265c7 100644
--- a/src/stc/scintilla/lexers/LexAbaqus.cxx
+++ b/src/stc/scintilla/lexers/LexAbaqus.cxx
@@ -581,14 +581,14 @@ WordList *[], Accessor &styler) {
     for ( Sci_Position ll = beginData; ll < beginComment; ll++ )
         SafeSetLevel(ll, datLevel, styler) ;
 
-	if ( prvKeyLineTp == 5 ) {
-		level += 1 ;
-	}
+    if ( prvKeyLineTp == 5 ) {
+        level += 1 ;
+    }
 
-	if ( prvKeyLineTp == 6 ) {
-		level -= 1 ;
-	}
-	for ( Sci_Position m = beginComment; m <= endLine; m++ )
+    if ( prvKeyLineTp == 6 ) {
+        level -= 1 ;
+    }
+    for ( Sci_Position m = beginComment; m <= endLine; m++ )
         SafeSetLevel(m, level, styler) ;
 }
 
diff --git a/src/stc/scintilla/lexers/LexBaan.cxx b/src/stc/scintilla/lexers/LexBaan.cxx
index 8da2f3a..e941956 100644
--- a/src/stc/scintilla/lexers/LexBaan.cxx
+++ b/src/stc/scintilla/lexers/LexBaan.cxx
@@ -1,134 +1,702 @@
 // Scintilla source code edit control
 /** @file LexBaan.cxx
- ** Lexer for Baan.
- ** Based heavily on LexCPP.cxx
- **/
+** Lexer for Baan.
+** Based heavily on LexCPP.cxx
+**/
 // Copyright 2001- by Vamsi Potluru <vamsi@who.net> & Praveen Ambekar <ambekarpraveen@yahoo.com>
 // The License.txt file describes the conditions under which this software may be distributed.
 
+// C standard library
 #include <stdlib.h>
 #include <string.h>
-#include <stdio.h>
-#include <stdarg.h>
-#include <assert.h>
-#include <ctype.h>
 
+// C++ wrappers of C standard library
+#include <cassert>
+
+// C++ standard library
+#include <string>
+#include <map>
+
+// Scintilla headers
+
+// Non-platform-specific headers
+
+// include
 #include "ILexer.h"
 #include "Scintilla.h"
 #include "SciLexer.h"
 
+// lexlib
 #include "WordList.h"
 #include "LexAccessor.h"
-#include "Accessor.h"
 #include "StyleContext.h"
 #include "CharacterSet.h"
 #include "LexerModule.h"
+#include "OptionSet.h"
 
-#ifdef SCI_NAMESPACE
+# ifdef SCI_NAMESPACE
 using namespace Scintilla;
-#endif
+# endif
+
+namespace {
+// Use an unnamed namespace to protect the functions and classes from name conflicts
+
+// Options used for LexerBaan
+struct OptionsBaan {
+	bool fold;
+	bool foldComment;
+	bool foldPreprocessor;
+	bool foldCompact;
+	bool baanFoldSyntaxBased;
+	bool baanFoldKeywordsBased;
+	bool baanFoldSections;
+	bool baanFoldInnerLevel;
+	bool baanStylingWithinPreprocessor;
+	OptionsBaan() {
+		fold = false;
+		foldComment = false;
+		foldPreprocessor = false;
+		foldCompact = false;
+		baanFoldSyntaxBased = false;
+		baanFoldKeywordsBased = false;
+		baanFoldSections = false;
+		baanFoldInnerLevel = false;
+		baanStylingWithinPreprocessor = false;
+	}
+};
+
+const char *const baanWordLists[] = {
+	"Baan & BaanSQL Reserved Keywords ",
+	"Baan Standard functions",
+	"Baan Functions Abridged",
+	"Baan Main Sections ",
+	"Baan Sub Sections",
+	"PreDefined Variables",
+	"PreDefined Attributes",
+	"Enumerates",
+	0,
+};
+
+struct OptionSetBaan : public OptionSet<OptionsBaan> {
+	OptionSetBaan() {
+		DefineProperty("fold", &OptionsBaan::fold);
+
+		DefineProperty("fold.comment", &OptionsBaan::foldComment);
+
+		DefineProperty("fold.preprocessor", &OptionsBaan::foldPreprocessor);
+
+		DefineProperty("fold.compact", &OptionsBaan::foldCompact);
+
+		DefineProperty("fold.baan.syntax.based", &OptionsBaan::baanFoldSyntaxBased,
+			"Set this property to 0 to disable syntax based folding, which is folding based on '{' & '('.");
+
+		DefineProperty("fold.baan.keywords.based", &OptionsBaan::baanFoldKeywordsBased,
+			"Set this property to 0 to disable keywords based folding, which is folding based on "
+			" for, if, on (case), repeat, select, while and fold ends based on endfor, endif, endcase, until, endselect, endwhile respectively."
+			"Also folds declarations which are grouped together.");
+
+		DefineProperty("fold.baan.sections", &OptionsBaan::baanFoldSections,
+			"Set this property to 0 to disable folding of Main Sections as well as Sub Sections.");
+
+		DefineProperty("fold.baan.inner.level", &OptionsBaan::baanFoldInnerLevel,
+			"Set this property to 1 to enable folding of inner levels of select statements."
+			"Disabled by default. case and if statements are also eligible" );
+
+		DefineProperty("lexer.baan.styling.within.preprocessor", &OptionsBaan::baanStylingWithinPreprocessor,
+			"For Baan code, determines whether all preprocessor code is styled in the "
+			"preprocessor style (0, the default) or only from the initial # to the end "
+			"of the command word(1).");
+
+		DefineWordListSets(baanWordLists);
+	}
+};
 
 static inline bool IsAWordChar(const int  ch) {
-	return (ch < 0x80) && (isalnum(ch) || ch == '.' || ch == '_' || ch == '$' || ch == ':');
+	return (ch < 0x80) && (isalnum(ch) || ch == '.' || ch == '_' || ch == '$');
+}
+
+static inline bool IsAnOperator(int ch) {
+	if (IsAlphaNumeric(ch))
+		return false;
+	if (ch == '#' || ch == '^' || ch == '&' || ch == '*' ||
+		ch == '(' || ch == ')' || ch == '-' || ch == '+' ||
+		ch == '=' || ch == '|' || ch == '{' || ch == '}' ||
+		ch == '[' || ch == ']' || ch == ':' || ch == ';' ||
+		ch == '<' || ch == '>' || ch == ',' || ch == '/' ||
+		ch == '?' || ch == '!' || ch == '"' || ch == '~' ||
+		ch == '\\')
+		return true;
+	return false;
+}
+
+static inline int IsAnyOtherIdentifier(char *s, int sLength) {
+
+	/*	IsAnyOtherIdentifier uses standard templates used in baan.
+	The matching template is shown as comments just above the return condition.
+	^ - refers to any character [a-z].
+	# - refers to any number [0-9].
+	Other characters shown are compared as is.
+	Tried implementing with Regex... it was too complicated for me.
+	Any other implementation suggestion welcome.
+	*/
+	switch (sLength) {
+	case 8:
+		if (isalpha(s[0]) && isalpha(s[1]) && isalpha(s[2]) && isalpha(s[3]) && isalpha(s[4]) && IsADigit(s[5]) && IsADigit(s[6]) && IsADigit(s[7])) {
+			//^^^^^### 
+			return(SCE_BAAN_TABLEDEF);
+		}
+		break;
+	case 9:
+		if (s[0] == 't' && isalpha(s[1]) && isalpha(s[2]) && isalpha(s[3]) && isalpha(s[4]) && isalpha(s[5]) && IsADigit(s[6]) && IsADigit(s[7]) && IsADigit(s[8])) {
+			//t^^^^^###
+			return(SCE_BAAN_TABLEDEF);
+		}
+		else if (s[8] == '.' && isalpha(s[0]) && isalpha(s[1]) && isalpha(s[2]) && isalpha(s[3]) && isalpha(s[4]) && IsADigit(s[5]) && IsADigit(s[6]) && IsADigit(s[7])) {
+			//^^^^^###.
+			return(SCE_BAAN_TABLESQL);
+		}
+		break;
+	case 13:
+		if (s[8] == '.' && isalpha(s[0]) && isalpha(s[1]) && isalpha(s[2]) && isalpha(s[3]) && isalpha(s[4]) && IsADigit(s[5]) && IsADigit(s[6]) && IsADigit(s[7])) {
+			//^^^^^###.****
+			return(SCE_BAAN_TABLESQL);
+		}
+		else if (s[0] == 'r' && s[1] == 'c' && s[2] == 'd' && s[3] == '.' && s[4] == 't' && isalpha(s[5]) && isalpha(s[6]) && isalpha(s[7]) && isalpha(s[8]) && isalpha(s[9]) && IsADigit(s[10]) && IsADigit(s[11]) && IsADigit(s[12])) {
+			//rcd.t^^^^^###
+			return(SCE_BAAN_TABLEDEF);
+		}
+		break;
+	case 14:
+	case 15:
+		if (s[8] == '.' && isalpha(s[0]) && isalpha(s[1]) && isalpha(s[2]) && isalpha(s[3]) && isalpha(s[4]) && IsADigit(s[5]) && IsADigit(s[6]) && IsADigit(s[7])) {
+			if (s[13] != ':') {
+				//^^^^^###.******
+				return(SCE_BAAN_TABLESQL);
+			}
+		}
+		break;
+	case 16:
+	case 17:
+		if (s[8] == '.' && s[9] == '_' && s[10] == 'i' && s[11] == 'n' && s[12] == 'd' && s[13] == 'e' && s[14] == 'x' && IsADigit(s[15]) && isalpha(s[0]) && isalpha(s[1]) && isalpha(s[2]) && isalpha(s[3]) && isalpha(s[4]) && IsADigit(s[5]) && IsADigit(s[6]) && IsADigit(s[7])) {
+			//^^^^^###._index##
+			return(SCE_BAAN_TABLEDEF);
+		}
+		else if (s[8] == '.' && s[9] == '_' && s[10] == 'c' && s[11] == 'o' && s[12] == 'm' && s[13] == 'p' && s[14] == 'n' && s[15] == 'r' && isalpha(s[0]) && isalpha(s[1]) && isalpha(s[2]) && isalpha(s[3]) && isalpha(s[4]) && IsADigit(s[5]) && IsADigit(s[6]) && IsADigit(s[7])) {
+			//^^^^^###._compnr
+			return(SCE_BAAN_TABLEDEF);
+		}
+		break;
+	default:
+		break;
+	}
+	if (sLength > 14 && s[5] == '.' && s[6] == 'd' && s[7] == 'l' && s[8] == 'l' && s[13] == '.' && isalpha(s[0]) && isalpha(s[1]) && isalpha(s[2]) && isalpha(s[3]) && isalpha(s[4]) && IsADigit(s[9]) && IsADigit(s[10]) && IsADigit(s[11]) && IsADigit(s[12])) {
+		//^^^^^.dll####.
+		return(SCE_BAAN_FUNCTION);
+	}
+	else if (sLength > 15 && s[2] == 'i' && s[3] == 'n' && s[4] == 't' && s[5] == '.' && s[6] == 'd' && s[7] == 'l' && s[8] == 'l' && isalpha(s[0]) && isalpha(s[1]) && isalpha(s[9]) && isalpha(s[10]) && isalpha(s[11]) && isalpha(s[12]) && isalpha(s[13])) {
+		//^^int.dll^^^^^.
+		return(SCE_BAAN_FUNCTION);
+	}
+	else if (sLength > 11 && s[0] == 'i' && s[10] == '.' && isalpha(s[1]) && isalpha(s[2]) && isalpha(s[3]) && isalpha(s[4]) && isalpha(s[5]) && IsADigit(s[6]) && IsADigit(s[7]) && IsADigit(s[8]) && IsADigit(s[9])) {
+		//i^^^^^####.
+		return(SCE_BAAN_FUNCTION);
+	}
+
+	return(SCE_BAAN_DEFAULT);
 }
 
-static inline bool IsAWordStart(const int ch) {
-	return (ch < 0x80) && (isalnum(ch) || ch == '_');
+static bool IsCommentLine(Sci_Position line, LexAccessor &styler) {
+	Sci_Position pos = styler.LineStart(line);
+	Sci_Position eol_pos = styler.LineStart(line + 1) - 1;
+	for (Sci_Position i = pos; i < eol_pos; i++) {
+		char ch = styler[i];
+		int style = styler.StyleAt(i);
+		if (ch == '|' && style == SCE_BAAN_COMMENT)
+			return true;
+		else if (!IsASpaceOrTab(ch))
+			return false;
+	}
+	return false;
+}
+
+static bool IsPreProcLine(Sci_Position line, LexAccessor &styler) {
+	Sci_Position pos = styler.LineStart(line);
+	Sci_Position eol_pos = styler.LineStart(line + 1) - 1;
+	for (Sci_Position i = pos; i < eol_pos; i++) {
+		char ch = styler[i];
+		int style = styler.StyleAt(i);
+		if (ch == '#' && style == SCE_BAAN_PREPROCESSOR) {
+			if (styler.Match(i, "#elif") || styler.Match(i, "#else") || styler.Match(i, "#endif")
+				|| styler.Match(i, "#if") || styler.Match(i, "#ifdef") || styler.Match(i, "#ifndef"))
+				// Above PreProcessors has a seperate fold mechanism.
+				return false;
+			else
+				return true;
+		}
+		else if (ch == '^')
+			return true;
+		else if (!IsASpaceOrTab(ch))
+			return false;
+	}
+	return false;
+}
+
+static int mainOrSubSectionLine(Sci_Position line, LexAccessor &styler) {
+	Sci_Position pos = styler.LineStart(line);
+	Sci_Position eol_pos = styler.LineStart(line + 1) - 1;
+	for (Sci_Position i = pos; i < eol_pos; i++) {
+		char ch = styler[i];
+		int style = styler.StyleAt(i);
+		if (style == SCE_BAAN_WORD5 || style == SCE_BAAN_WORD4)
+			return style;
+		else if (IsASpaceOrTab(ch))
+			continue;
+		else
+			break;
+	}
+	return 0;
+}
+
+static bool priorSectionIsSubSection(Sci_Position line, LexAccessor &styler){
+	while (line > 0) {
+		Sci_Position pos = styler.LineStart(line);
+		Sci_Position eol_pos = styler.LineStart(line + 1) - 1;
+		for (Sci_Position i = pos; i < eol_pos; i++) {
+			char ch = styler[i];
+			int style = styler.StyleAt(i);
+			if (style == SCE_BAAN_WORD4)
+				return true;
+			else if (style == SCE_BAAN_WORD5)
+				return false;
+			else if (IsASpaceOrTab(ch))
+				continue;
+			else
+				break;
+		}
+		line--;
+	}
+	return false;
+}
+
+static bool nextSectionIsSubSection(Sci_Position line, LexAccessor &styler) {
+	while (line > 0) {
+		Sci_Position pos = styler.LineStart(line);
+		Sci_Position eol_pos = styler.LineStart(line + 1) - 1;
+		for (Sci_Position i = pos; i < eol_pos; i++) {
+			char ch = styler[i];
+			int style = styler.StyleAt(i);
+			if (style == SCE_BAAN_WORD4)
+				return true;
+			else if (style == SCE_BAAN_WORD5)
+				return false;
+			else if (IsASpaceOrTab(ch))
+				continue;
+			else
+				break;
+		}
+		line++;
+	}
+	return false;
+}
+
+static bool IsDeclarationLine(Sci_Position line, LexAccessor &styler) {
+	Sci_Position pos = styler.LineStart(line);
+	Sci_Position eol_pos = styler.LineStart(line + 1) - 1;
+	for (Sci_Position i = pos; i < eol_pos; i++) {
+		char ch = styler[i];
+		int style = styler.StyleAt(i);
+		if (style == SCE_BAAN_WORD) {
+			if (styler.Match(i, "table") || styler.Match(i, "extern") || styler.Match(i, "long")
+				|| styler.Match(i, "double") || styler.Match(i, "boolean") || styler.Match(i, "string")
+				|| styler.Match(i, "domain")) {
+				for (Sci_Position j = eol_pos; j > pos; j--) {
+					int styleFromEnd = styler.StyleAt(j);
+					if (styleFromEnd == SCE_BAAN_COMMENT)
+						continue;
+					else if (IsASpace(styler[j]))
+						continue;
+					else if (styler[j] != ',')
+						//Above conditions ensures, Declaration is not part of any function parameters.
+						return true;
+					else
+						return false;
+				}
+			}
+			else
+				return false;
+		}
+		else if (!IsASpaceOrTab(ch))
+			return false;
+	}
+	return false;
+}
+
+static bool IsInnerLevelFold(Sci_Position line, LexAccessor &styler) {
+	Sci_Position pos = styler.LineStart(line);
+	Sci_Position eol_pos = styler.LineStart(line + 1) - 1;
+	for (Sci_Position i = pos; i < eol_pos; i++) {
+		char ch = styler[i];
+		int style = styler.StyleAt(i);
+		if (style == SCE_BAAN_WORD && (styler.Match(i, "else" ) || styler.Match(i, "case")
+			|| styler.Match(i, "default") || styler.Match(i, "selectdo") || styler.Match(i, "selecteos")
+			|| styler.Match(i, "selectempty") || styler.Match(i, "selecterror")))
+			return true;
+		else if (IsASpaceOrTab(ch))
+			continue;
+		else
+			return false;
+	}
+	return false;
+}
+
+static inline bool wordInArray(const std::string& value, std::string *array, int length)
+{
+	for (int i = 0; i < length; i++)
+	{
+		if (value == array[i])
+		{
+			return true;
+		}
+	}
+
+	return false;
+}
+
+class WordListAbridged : public WordList {
+public:
+	WordListAbridged() {
+		kwAbridged = false;
+		kwHasSection = false;
+	};
+	~WordListAbridged() {
+		Clear();
+	};
+	bool kwAbridged;
+	bool kwHasSection;
+	bool Contains(const char *s) {
+		return kwAbridged ? InListAbridged(s, '~') : InList(s);
+	};
+};
+
+}
+
+class LexerBaan : public ILexer {
+	WordListAbridged keywords;
+	WordListAbridged keywords2;
+	WordListAbridged keywords3;
+	WordListAbridged keywords4;
+	WordListAbridged keywords5;
+	WordListAbridged keywords6;
+	WordListAbridged keywords7;
+	WordListAbridged keywords8;
+	WordListAbridged keywords9;
+	OptionsBaan options;
+	OptionSetBaan osBaan;
+public:
+	LexerBaan() {
+	}
+
+	virtual ~LexerBaan() {
+	}
+
+	int SCI_METHOD Version() const {
+		return lvOriginal;
+	}
+
+	void SCI_METHOD Release() {
+		delete this;
+	}
+
+	const char * SCI_METHOD PropertyNames() {
+		return osBaan.PropertyNames();
+	}
+
+	int SCI_METHOD PropertyType(const char * name) {
+		return osBaan.PropertyType(name);
+	}
+
+	const char * SCI_METHOD DescribeProperty(const char * name) {
+		return osBaan.DescribeProperty(name);
+	}
+
+	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val);
+
+	const char * SCI_METHOD DescribeWordListSets() {
+		return osBaan.DescribeWordListSets();
+	}
+
+	Sci_Position SCI_METHOD WordListSet(int n, const char *wl);
+
+	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess);
+
+	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess);
+
+	void * SCI_METHOD PrivateCall(int, void *) {
+		return NULL;
+	}
+
+	static ILexer * LexerFactoryBaan() {
+		return new LexerBaan();
+	}
+};
+
+Sci_Position SCI_METHOD LexerBaan::PropertySet(const char *key, const char *val) {
+	if (osBaan.PropertySet(&options, key, val)) {
+		return 0;
+	}
+	return -1;
 }
 
-static void ColouriseBaanDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *keywordlists[],
-                            Accessor &styler) {
+Sci_Position SCI_METHOD LexerBaan::WordListSet(int n, const char *wl) {
+	WordListAbridged *WordListAbridgedN = 0;
+	switch (n) {
+	case 0:
+		WordListAbridgedN = &keywords;
+		break;
+	case 1:
+		WordListAbridgedN = &keywords2;
+		break;
+	case 2:
+		WordListAbridgedN = &keywords3;
+		break;
+	case 3:
+		WordListAbridgedN = &keywords4;
+		break;
+	case 4:
+		WordListAbridgedN = &keywords5;
+		break;
+	case 5:
+		WordListAbridgedN = &keywords6;
+		break;
+	case 6:
+		WordListAbridgedN = &keywords7;
+		break;
+	case 7:
+		WordListAbridgedN = &keywords8;
+		break;
+	case 8:
+		WordListAbridgedN = &keywords9;
+		break;
+	}
+	Sci_Position firstModification = -1;
+	if (WordListAbridgedN) {
+		WordListAbridged wlNew;
+		wlNew.Set(wl);
+		if (*WordListAbridgedN != wlNew) {
+			WordListAbridgedN->Set(wl);
+			WordListAbridgedN->kwAbridged = strchr(wl, '~') != NULL;
+			WordListAbridgedN->kwHasSection = strchr(wl, ':') != NULL;
+
+			firstModification = 0;
+		}
+	}
+	return firstModification;
+}
 
-	WordList &keywords = *keywordlists[0];
-	WordList &keywords2 = *keywordlists[1];
-	bool stylingWithinPreprocessor = styler.GetPropertyInt("styling.within.preprocessor") != 0;
+void SCI_METHOD LexerBaan::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
 
 	if (initStyle == SCE_BAAN_STRINGEOL)	// Does not leak onto next line
 		initStyle = SCE_BAAN_DEFAULT;
 
 	int visibleChars = 0;
+	bool lineHasDomain = false;
+	bool lineHasFunction = false;
+	bool lineHasPreProc = false;
+	bool lineIgnoreString = false;
+	bool lineHasDefines = false;
+	char word[1000];
+	int wordlen = 0;
 
+	std::string preProcessorTags[11] = { "#define", "#elif", "#else", "#endif",
+		"#ident", "#if", "#ifdef", "#ifndef",
+		"#include", "#pragma", "#undef" };
+	LexAccessor styler(pAccess);
 	StyleContext sc(startPos, length, initStyle, styler);
 
 	for (; sc.More(); sc.Forward()) {
 
-		if (sc.state == SCE_BAAN_OPERATOR) {
+		// Determine if the current state should terminate.
+		switch (sc.state) {
+		case SCE_BAAN_OPERATOR:
 			sc.SetState(SCE_BAAN_DEFAULT);
-		} else if (sc.state == SCE_BAAN_NUMBER) {
+			break;
+		case SCE_BAAN_NUMBER:
 			if (!IsAWordChar(sc.ch)) {
 				sc.SetState(SCE_BAAN_DEFAULT);
 			}
-		} else if (sc.state == SCE_BAAN_IDENTIFIER) {
+			break;
+		case SCE_BAAN_IDENTIFIER:
 			if (!IsAWordChar(sc.ch)) {
-				char s[100];
+				char s[1000];
+				char s1[1000];
 				sc.GetCurrentLowered(s, sizeof(s));
-				if (keywords.InList(s)) {
+				if (sc.ch == ':') {
+					memcpy(s1, s, sizeof(s));
+					s1[sc.LengthCurrent()] = sc.ch;
+					s1[sc.LengthCurrent() + 1] = '\0';
+				}
+				if ((keywords.kwHasSection && (sc.ch == ':')) ? keywords.Contains(s1) : keywords.Contains(s)) {
 					sc.ChangeState(SCE_BAAN_WORD);
-				} else if (keywords2.InList(s)) {
+					if (0 == strcmp(s, "domain")) {
+						lineHasDomain = true;
+					}
+					else if (0 == strcmp(s, "function")) {
+						lineHasFunction = true;
+					}
+				}
+				else if (lineHasDomain) {
+					sc.ChangeState(SCE_BAAN_DOMDEF);
+					lineHasDomain = false;
+				}
+				else if (lineHasFunction) {
+					sc.ChangeState(SCE_BAAN_FUNCDEF);
+					lineHasFunction = false;
+				}
+				else if ((keywords2.kwHasSection && (sc.ch == ':')) ? keywords2.Contains(s1) : keywords2.Contains(s)) {
 					sc.ChangeState(SCE_BAAN_WORD2);
 				}
+				else if ((keywords3.kwHasSection && (sc.ch == ':')) ? keywords3.Contains(s1) : keywords3.Contains(s)) {
+					sc.ChangeState(SCE_BAAN_WORD3);
+				}
+				else if ((keywords4.kwHasSection && (sc.ch == ':')) ? keywords4.Contains(s1) : keywords4.Contains(s)) {
+					sc.ChangeState(SCE_BAAN_WORD4);
+				}
+				else if ((keywords5.kwHasSection && (sc.ch == ':')) ? keywords5.Contains(s1) : keywords5.Contains(s)) {
+					sc.ChangeState(SCE_BAAN_WORD5);
+				}
+				else if ((keywords6.kwHasSection && (sc.ch == ':')) ? keywords6.Contains(s1) : keywords6.Contains(s)) {
+					sc.ChangeState(SCE_BAAN_WORD6);
+				}
+				else if ((keywords7.kwHasSection && (sc.ch == ':')) ? keywords7.Contains(s1) : keywords7.Contains(s)) {
+					sc.ChangeState(SCE_BAAN_WORD7);
+				}
+				else if ((keywords8.kwHasSection && (sc.ch == ':')) ? keywords8.Contains(s1) : keywords8.Contains(s)) {
+					sc.ChangeState(SCE_BAAN_WORD8);
+				}
+				else if ((keywords9.kwHasSection && (sc.ch == ':')) ? keywords9.Contains(s1) : keywords9.Contains(s)) {
+					sc.ChangeState(SCE_BAAN_WORD9);
+				}
+				else if (lineHasPreProc) {
+					sc.ChangeState(SCE_BAAN_OBJECTDEF);
+					lineHasPreProc = false;
+				}
+				else if (lineHasDefines) {
+					sc.ChangeState(SCE_BAAN_DEFINEDEF);
+					lineHasDefines = false;
+				}
+				else {
+					int state = IsAnyOtherIdentifier(s, sc.LengthCurrent());
+					if (state > 0) {
+						sc.ChangeState(state);
+					}
+				}
 				sc.SetState(SCE_BAAN_DEFAULT);
 			}
-		} else if (sc.state == SCE_BAAN_PREPROCESSOR) {
-			if (stylingWithinPreprocessor) {
-				if (IsASpace(sc.ch)) {
+			break;
+		case SCE_BAAN_PREPROCESSOR:
+			if (options.baanStylingWithinPreprocessor) {
+				if (IsASpace(sc.ch) || IsAnOperator(sc.ch)) {
 					sc.SetState(SCE_BAAN_DEFAULT);
 				}
-			} else {
+			}
+			else {
 				if (sc.atLineEnd && (sc.chNext != '^')) {
 					sc.SetState(SCE_BAAN_DEFAULT);
 				}
 			}
-		} else if (sc.state == SCE_BAAN_COMMENT) {
+			break;
+		case SCE_BAAN_COMMENT:
 			if (sc.atLineEnd) {
 				sc.SetState(SCE_BAAN_DEFAULT);
 			}
-		} else if (sc.state == SCE_BAAN_COMMENTDOC) {
+			break;
+		case SCE_BAAN_COMMENTDOC:
 			if (sc.MatchIgnoreCase("enddllusage")) {
-				for (unsigned int i = 0; i < 10; i++){
+				for (unsigned int i = 0; i < 10; i++) {
+					sc.Forward();
+				}
+				sc.ForwardSetState(SCE_BAAN_DEFAULT);
+			}
+			else if (sc.MatchIgnoreCase("endfunctionusage")) {
+				for (unsigned int i = 0; i < 15; i++) {
 					sc.Forward();
 				}
 				sc.ForwardSetState(SCE_BAAN_DEFAULT);
 			}
-		} else if (sc.state == SCE_BAAN_STRING) {
+			break;
+		case SCE_BAAN_STRING:
 			if (sc.ch == '\"') {
 				sc.ForwardSetState(SCE_BAAN_DEFAULT);
-			} else if ((sc.atLineEnd) && (sc.chNext != '^')) {
+			}
+			else if ((sc.atLineEnd) && (sc.chNext != '^')) {
 				sc.ChangeState(SCE_BAAN_STRINGEOL);
-				sc.ForwardSetState(SCE_C_DEFAULT);
+				sc.ForwardSetState(SCE_BAAN_DEFAULT);
 				visibleChars = 0;
 			}
+			break;
 		}
 
+		// Determine if a new state should be entered.
 		if (sc.state == SCE_BAAN_DEFAULT) {
 			if (IsADigit(sc.ch) || (sc.ch == '.' && IsADigit(sc.chNext))) {
 				sc.SetState(SCE_BAAN_NUMBER);
-			} else if (sc.MatchIgnoreCase("dllusage")){
-					sc.SetState(SCE_BAAN_COMMENTDOC);
-					do {
-						sc.Forward();
-					} while ((!sc.atLineEnd) && sc.More());
-			} else if (IsAWordStart(sc.ch)) {
-					sc.SetState(SCE_BAAN_IDENTIFIER);
-			} else if (sc.Match('|')){
-					sc.SetState(SCE_BAAN_COMMENT);
-			} else if (sc.ch == '\"') {
+			}
+			else if (sc.MatchIgnoreCase("dllusage") || sc.MatchIgnoreCase("functionusage")) {
+				sc.SetState(SCE_BAAN_COMMENTDOC);
+				do {
+					sc.Forward();
+				} while ((!sc.atLineEnd) && sc.More());
+			}
+			else if (iswordstart(sc.ch)) {
+				sc.SetState(SCE_BAAN_IDENTIFIER);
+			}
+			else if (sc.Match('|')) {
+				sc.SetState(SCE_BAAN_COMMENT);
+			}
+			else if (sc.ch == '\"' && !(lineIgnoreString)) {
 				sc.SetState(SCE_BAAN_STRING);
-			} else if (sc.ch == '#' && visibleChars == 0) {
+			}
+			else if (sc.ch == '#' && visibleChars == 0) {
 				// Preprocessor commands are alone on their line
 				sc.SetState(SCE_BAAN_PREPROCESSOR);
-				// Skip whitespace between # and preprocessor word
-				do {
+				word[0] = '\0';
+				wordlen = 0;
+				while (sc.More() && !(IsASpace(sc.chNext) || IsAnOperator(sc.chNext))) {
 					sc.Forward();
-				} while (IsASpace(sc.ch) && sc.More());
-			} else if (isoperator(static_cast<char>(sc.ch))) {
+					wordlen++;
+				}
+				sc.GetCurrentLowered(word, sizeof(word));
+				if (!sc.atLineEnd) {
+					word[wordlen++] = sc.ch;
+					word[wordlen++] = '\0';
+				}
+				if (!wordInArray(word, preProcessorTags, 11))
+					// Colorise only preprocessor built in Baan.
+					sc.ChangeState(SCE_BAAN_IDENTIFIER);
+				if (strcmp(word, "#pragma") == 0 || strcmp(word, "#include") == 0) {
+					lineHasPreProc = true;
+					lineIgnoreString = true;
+				}
+				else if (strcmp(word, "#define") == 0 || strcmp(word, "#undef") == 0 ||
+					strcmp(word, "#ifdef") == 0 || strcmp(word, "#if") == 0 || strcmp(word, "#ifndef") == 0) {
+					lineHasDefines = true;
+					lineIgnoreString = false;
+				}
+			}
+			else if (IsAnOperator(static_cast<char>(sc.ch))) {
 				sc.SetState(SCE_BAAN_OPERATOR);
 			}
 		}
+
 		if (sc.atLineEnd) {
 			// Reset states to begining of colourise so no surprises
 			// if different sets of lines lexed.
 			visibleChars = 0;
+			lineHasDomain = false;
+			lineHasFunction = false;
+			lineHasPreProc = false;
+			lineIgnoreString = false;
+			lineHasDefines = false;
 		}
 		if (!IsASpace(sc.ch)) {
 			visibleChars++;
@@ -137,44 +705,247 @@ static void ColouriseBaanDoc(Sci_PositionU startPos, Sci_Position length, int in
 	sc.Complete();
 }
 
-static void FoldBaanDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *[],
-                            Accessor &styler) {
-	bool foldComment = styler.GetPropertyInt("fold.comment") != 0;
-	bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
+void SCI_METHOD LexerBaan::Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
+	if (!options.fold)
+		return;
+
+	char word[100];
+	int wordlen = 0;
+	bool foldStart = true;
+	bool foldNextSelect = true;
+	bool afterFunctionSection = false;
+	bool beforeDeclarationSection = false;
+	int currLineStyle = 0;
+	int nextLineStyle = 0;
+
+	std::string startTags[6] = { "for", "if", "on", "repeat", "select", "while" };
+	std::string endTags[6] = { "endcase", "endfor", "endif", "endselect", "endwhile", "until" };
+	std::string selectCloseTags[5] = { "selectdo", "selecteos", "selectempty", "selecterror", "endselect" };
+
+	LexAccessor styler(pAccess);
 	Sci_PositionU endPos = startPos + length;
 	int visibleChars = 0;
 	Sci_Position lineCurrent = styler.GetLine(startPos);
-	int levelPrev = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
+
+	// Backtrack to previous line in case need to fix its fold status
+	if (startPos > 0) {
+		if (lineCurrent > 0) {
+			lineCurrent--;
+			startPos = styler.LineStart(lineCurrent);
+		}
+	}
+
+	int levelPrev = SC_FOLDLEVELBASE;
+	if (lineCurrent > 0)
+		levelPrev = styler.LevelAt(lineCurrent - 1) >> 16;
 	int levelCurrent = levelPrev;
 	char chNext = styler[startPos];
-	int styleNext = styler.StyleAt(startPos);
 	int style = initStyle;
+	int styleNext = styler.StyleAt(startPos);
+
 	for (Sci_PositionU i = startPos; i < endPos; i++) {
 		char ch = chNext;
 		chNext = styler.SafeGetCharAt(i + 1);
-		int stylePrev = style;
 		style = styleNext;
 		styleNext = styler.StyleAt(i + 1);
+		int stylePrev = (i) ? styler.StyleAt(i - 1) : SCE_BAAN_DEFAULT;
 		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
-		if (foldComment &&
-			(style == SCE_BAAN_COMMENT || style == SCE_BAAN_COMMENTDOC)) {
+
+		// Comment folding
+		if (options.foldComment && style == SCE_BAAN_COMMENTDOC) {
 			if (style != stylePrev) {
 				levelCurrent++;
-			} else if ((style != styleNext) && !atEOL) {
-				// Comments don't end at end of line and the next character may be unstyled.
+			}
+			else if (style != styleNext) {
 				levelCurrent--;
 			}
 		}
-		if (style == SCE_BAAN_OPERATOR) {
-			if (ch == '{') {
+		if (options.foldComment && atEOL && IsCommentLine(lineCurrent, styler)) {
+			if (!IsCommentLine(lineCurrent - 1, styler)
+				&& IsCommentLine(lineCurrent + 1, styler))
 				levelCurrent++;
-			} else if (ch == '}') {
+			else if (IsCommentLine(lineCurrent - 1, styler)
+				&& !IsCommentLine(lineCurrent + 1, styler))
 				levelCurrent--;
+		}
+		// PreProcessor Folding
+		if (options.foldPreprocessor) {
+			if (atEOL && IsPreProcLine(lineCurrent, styler)) {
+				if (!IsPreProcLine(lineCurrent - 1, styler)
+					&& IsPreProcLine(lineCurrent + 1, styler))
+					levelCurrent++;
+				else if (IsPreProcLine(lineCurrent - 1, styler)
+					&& !IsPreProcLine(lineCurrent + 1, styler))
+					levelCurrent--;
+			}
+			else if (style == SCE_BAAN_PREPROCESSOR) {
+				// folds #ifdef/#if/#ifndef - they are not part of the IsPreProcLine folding.
+				if (ch == '#') {
+					if (styler.Match(i, "#ifdef") || styler.Match(i, "#if") || styler.Match(i, "#ifndef"))
+						levelCurrent++;
+					else if (styler.Match(i, "#endif"))
+						levelCurrent--;
+				}
+			}
+		}
+		//Syntax Folding
+		if (options.baanFoldSyntaxBased && (style == SCE_BAAN_OPERATOR)) {
+			if (ch == '{' || ch == '(') {
+				levelCurrent++;
+			}
+			else if (ch == '}' || ch == ')') {
+				levelCurrent--;
+			}
+		}
+		//Keywords Folding
+		if (options.baanFoldKeywordsBased) {
+			if (atEOL && IsDeclarationLine(lineCurrent, styler)) {
+				if (!IsDeclarationLine(lineCurrent - 1, styler)
+					&& IsDeclarationLine(lineCurrent + 1, styler))
+					levelCurrent++;
+				else if (IsDeclarationLine(lineCurrent - 1, styler)
+					&& !IsDeclarationLine(lineCurrent + 1, styler))
+					levelCurrent--;
+			}
+			else if (style == SCE_BAAN_WORD) {
+				word[wordlen++] = static_cast<char>(MakeLowerCase(ch));
+				if (wordlen == 100) {                   // prevent overflow
+					word[0] = '\0';
+					wordlen = 1;
+				}
+				if (styleNext != SCE_BAAN_WORD) {
+					word[wordlen] = '\0';
+					wordlen = 0;
+					if (strcmp(word, "for") == 0) {
+						Sci_PositionU j = i + 1;
+						while ((j < endPos) && IsASpaceOrTab(styler.SafeGetCharAt(j))) {
+							j++;
+						}
+						if (styler.Match(j, "update")) {
+							// Means this is a "for update" used by Select which is already folded.
+							foldStart = false;
+						}
+					}
+					else if (strcmp(word, "on") == 0) {
+						Sci_PositionU j = i + 1;
+						while ((j < endPos) && IsASpaceOrTab(styler.SafeGetCharAt(j))) {
+							j++;
+						}
+						if (!styler.Match(j, "case")) {
+							// Means this is not a "on Case" statement... could be "on" used by index.
+							foldStart = false;
+						}
+					}
+					else if (strcmp(word, "select") == 0) {
+						if (foldNextSelect) {
+							// Next Selects are sub-clause till reach of selectCloseTags[] array.
+							foldNextSelect = false;
+							foldStart = true;
+						}
+						else {
+							foldNextSelect = false;
+							foldStart = false;
+						}
+					}
+					else if (wordInArray(word, selectCloseTags, 5)) {
+						// select clause ends, next select clause can be folded.
+						foldNextSelect = true;
+						foldStart = true;
+					}
+					else {
+						foldStart = true;
+					}
+					if (foldStart) {
+						if (wordInArray(word, startTags, 6)) {
+							levelCurrent++;
+						}
+						else if (wordInArray(word, endTags, 6)) {
+							levelCurrent--;
+						}
+					}
+				}
+			}
+		}
+		// Fold inner level of if/select/case statements
+		if (options.baanFoldInnerLevel && atEOL) {
+			bool currLineInnerLevel = IsInnerLevelFold(lineCurrent, styler);
+			bool nextLineInnerLevel = IsInnerLevelFold(lineCurrent + 1, styler);
+			if (currLineInnerLevel && currLineInnerLevel != nextLineInnerLevel) {
+				levelCurrent++;
+			}
+			else if (nextLineInnerLevel && nextLineInnerLevel != currLineInnerLevel) {
+				levelCurrent--;
+			}
+		}
+		// Section Foldings.
+		// One way of implementing Section Foldings, as there is no END markings of sections.
+		// first section ends on the previous line of next section.
+		// Re-written whole folding to accomodate this.
+		if (options.baanFoldSections && atEOL) {
+			currLineStyle = mainOrSubSectionLine(lineCurrent, styler);
+			nextLineStyle = mainOrSubSectionLine(lineCurrent + 1, styler);
+			if (currLineStyle != 0 && currLineStyle != nextLineStyle) {
+				if (levelCurrent < levelPrev)
+					--levelPrev;
+				for (Sci_Position j = styler.LineStart(lineCurrent); j < styler.LineStart(lineCurrent + 1) - 1; j++) {
+					if (IsASpaceOrTab(styler[j]))
+						continue;
+					else if (styler.StyleAt(j) == SCE_BAAN_WORD5) {
+						if (styler.Match(j, "functions:")) {
+							// Means functions: is the end of MainSections.
+							// Nothing to fold after this.
+							afterFunctionSection = true;
+							break;
+						}
+						else {
+							afterFunctionSection = false;
+							break;
+						}
+					}
+					else {
+						afterFunctionSection = false;
+						break;
+					}
+				}
+				if (!afterFunctionSection)
+					levelCurrent++;
+			}
+			else if (nextLineStyle != 0 && currLineStyle != nextLineStyle
+				&& (priorSectionIsSubSection(lineCurrent -1 ,styler) 
+					|| !nextSectionIsSubSection(lineCurrent + 1, styler))) {
+				for (Sci_Position j = styler.LineStart(lineCurrent + 1); j < styler.LineStart(lineCurrent + 1 + 1) - 1; j++) {
+					if (IsASpaceOrTab(styler[j]))
+						continue;
+					else if (styler.StyleAt(j) == SCE_BAAN_WORD5) {
+						if (styler.Match(j, "declaration:")) {
+							// Means declaration: is the start of MainSections.
+							// Nothing to fold before this.
+							beforeDeclarationSection = true;
+							break;
+						}
+						else {
+							beforeDeclarationSection = false;
+							break;
+						}
+					}
+					else {
+						beforeDeclarationSection = false;
+						break;
+					}
+				}
+				if (!beforeDeclarationSection) {
+					levelCurrent--;
+					if (nextLineStyle == SCE_BAAN_WORD5 && priorSectionIsSubSection(lineCurrent-1, styler))
+						// next levelCurrent--; is to unfold previous subsection fold.
+						// On reaching the next main section, the previous main as well sub section ends.
+						levelCurrent--;
+				}
 			}
 		}
 		if (atEOL) {
 			int lev = levelPrev;
-			if (visibleChars == 0 && foldCompact)
+			lev |= levelCurrent << 16;
+			if (visibleChars == 0 && options.foldCompact)
 				lev |= SC_FOLDLEVELWHITEFLAG;
 			if ((levelCurrent > levelPrev) && (visibleChars > 0))
 				lev |= SC_FOLDLEVELHEADERFLAG;
@@ -188,9 +959,8 @@ static void FoldBaanDoc(Sci_PositionU startPos, Sci_Position length, int initSty
 		if (!isspacechar(ch))
 			visibleChars++;
 	}
-	// Fill in the real level of the next line, keeping the current flags as they will be filled in later
 	int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
 	styler.SetLevel(lineCurrent, levelPrev | flagsNext);
 }
 
-LexerModule lmBaan(SCLEX_BAAN, ColouriseBaanDoc, "baan", FoldBaanDoc);
+LexerModule lmBaan(SCLEX_BAAN, LexerBaan::LexerFactoryBaan, "baan", baanWordLists);
diff --git a/src/stc/scintilla/lexers/LexCPP.cxx b/src/stc/scintilla/lexers/LexCPP.cxx
index 4261084..ec040fb 100644
--- a/src/stc/scintilla/lexers/LexCPP.cxx
+++ b/src/stc/scintilla/lexers/LexCPP.cxx
@@ -229,7 +229,7 @@ struct PPDefinition {
 	std::string value;
 	bool isUndef;
 	std::string arguments;
-	PPDefinition(Sci_Position line_, const std::string &key_, const std::string &value_, bool isUndef_ = false, std::string arguments_="") :
+	PPDefinition(Sci_Position line_, const std::string &key_, const std::string &value_, bool isUndef_ = false, const std::string &arguments_="") :
 		line(line_), key(key_), value(value_), isUndef(isUndef_), arguments(arguments_) {
 	}
 };
@@ -320,6 +320,7 @@ struct OptionsCPP {
 	std::string foldExplicitEnd;
 	bool foldExplicitAnywhere;
 	bool foldPreprocessor;
+	bool foldPreprocessorAtElse;
 	bool foldCompact;
 	bool foldAtElse;
 	OptionsCPP() {
@@ -341,6 +342,7 @@ struct OptionsCPP {
 		foldExplicitEnd = "";
 		foldExplicitAnywhere = false;
 		foldPreprocessor = false;
+		foldPreprocessorAtElse = false;
 		foldCompact = false;
 		foldAtElse = false;
 	}
@@ -411,6 +413,9 @@ struct OptionSetCPP : public OptionSet<OptionsCPP> {
 
 		DefineProperty("fold.cpp.explicit.anywhere", &OptionsCPP::foldExplicitAnywhere,
 			"Set this property to 1 to enable explicit fold points anywhere, not just in line comments.");
+		
+		DefineProperty("fold.cpp.preprocessor.at.else", &OptionsCPP::foldPreprocessorAtElse,
+			"This option enables folding on a preprocessor #else or #endif line of an #if statement.");
 
 		DefineProperty("fold.preprocessor", &OptionsCPP::foldPreprocessor,
 			"This option enables folding preprocessor directives when using the C++ lexer. "
@@ -687,7 +692,7 @@ void SCI_METHOD LexerCPP::Lex(Sci_PositionU startPos, Sci_Position length, int i
 		}
 	}
 
-	StyleContext sc(startPos, length, initStyle, styler, static_cast<unsigned char>(0xff));
+	StyleContext sc(startPos, length, initStyle, styler);
 	LinePPState preproc = vlls.ForLine(lineCurrent);
 
 	bool definitionsChanged = false;
@@ -1349,13 +1354,17 @@ void SCI_METHOD LexerCPP::Fold(Sci_PositionU startPos, Sci_Position length, int
 				} else if (styler.Match(j, "end")) {
 					levelNext--;
 				}
+				
+				if (options.foldPreprocessorAtElse && (styler.Match(j, "else") || styler.Match(j, "elif"))) {
+					levelMinCurrent--;
+				}
 			}
 		}
 		if (options.foldSyntaxBased && (style == SCE_C_OPERATOR)) {
 			if (ch == '{' || ch == '[' || ch == '(') {
 				// Measure the minimum before a '{' to allow
 				// folding on "} else {"
-				if (levelMinCurrent > levelNext) {
+				if (options.foldAtElse && levelMinCurrent > levelNext) {
 					levelMinCurrent = levelNext;
 				}
 				levelNext++;
@@ -1367,7 +1376,9 @@ void SCI_METHOD LexerCPP::Fold(Sci_PositionU startPos, Sci_Position length, int
 			visibleChars++;
 		if (atEOL || (i == endPos-1)) {
 			int levelUse = levelCurrent;
-			if (options.foldSyntaxBased && options.foldAtElse) {
+			if ((options.foldSyntaxBased && options.foldAtElse) ||
+				(options.foldPreprocessor && options.foldPreprocessorAtElse)
+			) {
 				levelUse = levelMinCurrent;
 			}
 			int lev = levelUse | levelNext << 16;
diff --git a/src/stc/scintilla/lexers/LexCoffeeScript.cxx b/src/stc/scintilla/lexers/LexCoffeeScript.cxx
index f325600..63ee172 100644
--- a/src/stc/scintilla/lexers/LexCoffeeScript.cxx
+++ b/src/stc/scintilla/lexers/LexCoffeeScript.cxx
@@ -40,6 +40,36 @@ static bool IsSpaceEquiv(int state) {
 	    || state == SCE_COFFEESCRIPT_REGEX);
 }
 
+// Store the current lexer state and brace count prior to starting a new
+// `#{}` interpolation level.
+// Based on LexRuby.cxx.
+static void enterInnerExpression(int  *p_inner_string_types,
+                                 int  *p_inner_expn_brace_counts,
+                                 int&  inner_string_count,
+                                 int   state,
+                                 int&  brace_counts
+                                 ) {
+	p_inner_string_types[inner_string_count] = state;
+	p_inner_expn_brace_counts[inner_string_count] = brace_counts;
+	brace_counts = 0;
+	++inner_string_count;
+}
+
+// Restore the lexer state and brace count for the previous `#{}` interpolation
+// level upon returning to it.
+// Note the previous lexer state is the return value and needs to be restored
+// manually by the StyleContext.
+// Based on LexRuby.cxx.
+static int exitInnerExpression(int  *p_inner_string_types,
+                               int  *p_inner_expn_brace_counts,
+                               int&  inner_string_count,
+                               int&  brace_counts
+                              ) {
+	--inner_string_count;
+	brace_counts = p_inner_expn_brace_counts[inner_string_count];
+	return p_inner_string_types[inner_string_count];
+}
+
 // Preconditions: sc.currentPos points to a character after '+' or '-'.
 // The test for pos reaching 0 should be redundant,
 // and is in only for safety measures.
@@ -88,6 +118,27 @@ static void ColouriseCoffeeScriptDoc(Sci_PositionU startPos, Sci_Position length
 	int chPrevNonWhite = ' ';
 	int visibleChars = 0;
 
+	// String/Regex interpolation variables, based on LexRuby.cxx.
+	// In most cases a value of 2 should be ample for the code the user is
+	// likely to enter. For example,
+	//   "Filling the #{container} with #{liquid}..."
+	// from the CoffeeScript homepage nests to a level of 2
+	// If the user actually hits a 6th occurrence of '#{' in a double-quoted
+	// string (including regexes), it will stay as a string.  The problem with
+	// this is that quotes might flip, a 7th '#{' will look like a comment,
+	// and code-folding might be wrong.
+#define INNER_STRINGS_MAX_COUNT 5
+	// These vars track our instances of "...#{,,,'..#{,,,}...',,,}..."
+	int inner_string_types[INNER_STRINGS_MAX_COUNT];
+	// Track # braces when we push a new #{ thing
+	int inner_expn_brace_counts[INNER_STRINGS_MAX_COUNT];
+	int inner_string_count = 0;
+	int brace_counts = 0;   // Number of #{ ... } things within an expression
+	for (int i = 0; i < INNER_STRINGS_MAX_COUNT; i++) {
+		inner_string_types[i] = 0;
+		inner_expn_brace_counts[i] = 0;
+	}
+
 	// look back to set chPrevNonWhite properly for better regex colouring
 	Sci_Position endPos = startPos + length;
         if (startPos > 0 && IsSpaceEquiv(initStyle)) {
@@ -109,7 +160,7 @@ static void ColouriseCoffeeScriptDoc(Sci_PositionU startPos, Sci_Position length
 
 	StyleContext sc(startPos, endPos - startPos, initStyle, styler);
 
-	for (; sc.More(); sc.Forward()) {
+	for (; sc.More();) {
 
 		if (sc.atLineStart) {
 			// Reset states to beginning of colourise so no surprises
@@ -164,6 +215,15 @@ static void ColouriseCoffeeScriptDoc(Sci_PositionU startPos, Sci_Position length
 					}
 				} else if (sc.ch == '\"') {
 					sc.ForwardSetState(SCE_COFFEESCRIPT_DEFAULT);
+				} else if (sc.ch == '#' && sc.chNext == '{' && inner_string_count < INNER_STRINGS_MAX_COUNT) {
+					// process interpolated code #{ ... }
+					enterInnerExpression(inner_string_types,
+					                     inner_expn_brace_counts,
+					                     inner_string_count,
+					                     sc.state,
+					                     brace_counts);
+					sc.SetState(SCE_COFFEESCRIPT_OPERATOR);
+					sc.ForwardSetState(SCE_COFFEESCRIPT_DEFAULT);
 				}
 				break;
 			case SCE_COFFEESCRIPT_CHARACTER:
@@ -255,6 +315,15 @@ static void ColouriseCoffeeScriptDoc(Sci_PositionU startPos, Sci_Position length
 				// Handle '..' and '...' operators correctly.
 				if (sc.ch == '.') {
 					for (int i = 0; i < 2 && sc.chNext == '.'; i++, sc.Forward()) ;
+				} else if (sc.ch == '{') {
+					++brace_counts;
+				} else if (sc.ch == '}' && --brace_counts <= 0 && inner_string_count > 0) {
+					// Return to previous state before #{ ... }
+					sc.ForwardSetState(exitInnerExpression(inner_string_types,
+					                                       inner_expn_brace_counts,
+					                                       inner_string_count,
+					                                       brace_counts));
+					continue; // skip sc.Forward() at loop end
 				}
 			}
 		}
@@ -263,6 +332,7 @@ static void ColouriseCoffeeScriptDoc(Sci_PositionU startPos, Sci_Position length
 			chPrevNonWhite = sc.ch;
 			visibleChars++;
 		}
+		sc.Forward();
 	}
 	sc.Complete();
 }
diff --git a/src/stc/scintilla/lexers/LexEDIFACT.cxx b/src/stc/scintilla/lexers/LexEDIFACT.cxx
new file mode 100644
index 0000000..53e5bb3
--- /dev/null
+++ b/src/stc/scintilla/lexers/LexEDIFACT.cxx
@@ -0,0 +1,319 @@
+// Scintilla Lexer for EDIFACT
+// Written by Iain Clarke, IMCSoft & Inobiz AB.
+// EDIFACT documented here: https://www.unece.org/cefact/edifact/welcome.html
+// and more readably here: https://en.wikipedia.org/wiki/EDIFACT
+// This code is subject to the same license terms as the rest of the scintilla project:
+// The License.txt file describes the conditions under which this software may be distributed.
+// 
+
+// Header order must match order in scripts/HeaderOrder.txt
+#include <cstdlib>
+#include <cassert>
+#include <cstring>
+#include <cctype>
+
+#include "ILexer.h"
+#include "Scintilla.h"
+#include "SciLexer.h"
+
+#include "LexAccessor.h"
+#include "LexerModule.h"
+
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
+class LexerEDIFACT : public ILexer
+{
+public:
+	LexerEDIFACT();
+	virtual ~LexerEDIFACT() {} // virtual destructor, as we inherit from ILexer
+
+	static ILexer *Factory() {
+		return new LexerEDIFACT;
+	}
+
+	virtual int SCI_METHOD Version() const
+	{
+		return lvOriginal;
+	}
+	virtual void SCI_METHOD Release()
+	{
+		delete this;
+	}
+
+	const char * SCI_METHOD PropertyNames()
+	{
+		return "fold";
+	}
+	int SCI_METHOD PropertyType(const char *)
+	{
+		return SC_TYPE_BOOLEAN; // Only one property!
+	}
+	const char * SCI_METHOD DescribeProperty(const char *name)
+	{
+		if (strcmp(name, "fold"))
+			return NULL;
+		return "Whether to apply folding to document or not";
+	}
+
+	virtual Sci_Position SCI_METHOD PropertySet(const char *key, const char *val)
+	{
+		if (strcmp(key, "fold"))
+			return -1;
+		m_bFold = strcmp(val, "0") ? true : false;
+		return 0;
+	}
+	const char * SCI_METHOD DescribeWordListSets()
+	{
+		return NULL;
+	}
+	virtual Sci_Position SCI_METHOD WordListSet(int, const char *)
+	{
+		return -1;
+	}
+	virtual void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position lengthDoc, int initStyle, IDocument *pAccess);
+	virtual void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position lengthDoc, int initStyle, IDocument *pAccess);
+	virtual void * SCI_METHOD PrivateCall(int, void *)
+	{
+		return NULL;
+	}
+
+protected:
+	Sci_Position InitialiseFromUNA(IDocument *pAccess, Sci_PositionU MaxLength);
+	Sci_Position FindPreviousEnd(IDocument *pAccess, Sci_Position startPos) const;
+	Sci_Position ForwardPastWhitespace(IDocument *pAccess, Sci_Position startPos, Sci_Position MaxLength) const;
+	int DetectSegmentHeader(char SegmentHeader[3]) const;
+
+	bool m_bFold;
+	char m_chComponent;
+	char m_chData;
+	char m_chDecimal;
+	char m_chRelease;
+	char m_chSegment;
+};
+
+LexerModule lmEDIFACT(SCLEX_EDIFACT, LexerEDIFACT::Factory, "edifact");
+
+///////////////////////////////////////////////////////////////////////////////
+
+
+
+///////////////////////////////////////////////////////////////////////////////
+
+LexerEDIFACT::LexerEDIFACT()
+{
+	m_bFold = false;
+	m_chComponent = ':';
+	m_chData = '+';
+	m_chDecimal = '.';
+	m_chRelease = '?';
+	m_chSegment = '\'';
+}
+
+void LexerEDIFACT::Lex(Sci_PositionU startPos, Sci_Position lengthDoc, int, IDocument *pAccess)
+{
+	Sci_PositionU posFinish = startPos + lengthDoc;
+	InitialiseFromUNA(pAccess, posFinish);
+
+	// Look backwards for a ' or a document beginning
+	Sci_PositionU posCurrent = FindPreviousEnd(pAccess, startPos);
+	// And jump past the ' if this was not the beginning of the document
+	if (posCurrent != 0)
+		posCurrent++;
+
+	// Style buffer, so we're not issuing loads of notifications
+	LexAccessor styler (pAccess);
+	pAccess->StartStyling(posCurrent, '\377');
+	styler.StartSegment(posCurrent);
+	Sci_Position posSegmentStart = -1;
+
+	while ((posCurrent < posFinish) && (posSegmentStart == -1))
+	{
+		posCurrent = ForwardPastWhitespace(pAccess, posCurrent, posFinish);
+		// Mark whitespace as default
+		styler.ColourTo(posCurrent - 1, SCE_EDI_DEFAULT);
+		if (posCurrent >= posFinish)
+			break;
+
+		// Does is start with 3 charaters? ie, UNH
+		char SegmentHeader[4] = { 0 };
+		pAccess->GetCharRange(SegmentHeader, posCurrent, 3);
+
+		int SegmentStyle = DetectSegmentHeader(SegmentHeader);
+		if (SegmentStyle == SCE_EDI_BADSEGMENT)
+			break;
+		if (SegmentStyle == SCE_EDI_UNA)
+		{
+			posCurrent += 9;
+			styler.ColourTo(posCurrent - 1, SCE_EDI_UNA); // UNA   
+			continue;
+		}
+		posSegmentStart = posCurrent;
+		posCurrent += 3;
+
+		styler.ColourTo(posCurrent - 1, SegmentStyle); // UNH etc
+
+		// Colour in the rest of the segment
+		for (char c; posCurrent < posFinish; posCurrent++)
+		{
+			pAccess->GetCharRange(&c, posCurrent, 1);
+
+			if (c == m_chRelease) // ? escape character, check first, in case of ?'
+				posCurrent++;
+			else if (c == m_chSegment) // '
+			{
+				// Make sure the whole segment is on one line. styler won't let us go back in time, so we'll settle for marking the ' as bad.
+				Sci_Position lineSegmentStart = pAccess->LineFromPosition(posSegmentStart);
+				Sci_Position lineSegmentEnd = pAccess->LineFromPosition(posCurrent);
+				if (lineSegmentStart == lineSegmentEnd)
+					styler.ColourTo(posCurrent, SCE_EDI_SEGMENTEND);
+				else
+					styler.ColourTo(posCurrent, SCE_EDI_BADSEGMENT);
+				posSegmentStart = -1;
+				posCurrent++;
+				break;
+			}
+			else if (c == m_chComponent) // :
+				styler.ColourTo(posCurrent, SCE_EDI_SEP_COMPOSITE);
+			else if (c == m_chData) // +
+				styler.ColourTo(posCurrent, SCE_EDI_SEP_ELEMENT);
+			else
+				styler.ColourTo(posCurrent, SCE_EDI_DEFAULT);
+		}
+	}
+	styler.Flush();
+
+	if (posSegmentStart == -1)
+		return;
+
+	pAccess->StartStyling(posSegmentStart, -1);
+	pAccess->SetStyleFor(posFinish - posSegmentStart, SCE_EDI_BADSEGMENT);
+}
+
+void LexerEDIFACT::Fold(Sci_PositionU startPos, Sci_Position lengthDoc, int, IDocument *pAccess)
+{
+	if (!m_bFold)
+		return;
+
+	// Fold at UNx lines. ie, UNx segments = 0, other segments = 1.
+	// There's no sub folding, so we can be quite simple.
+	Sci_Position endPos = startPos + lengthDoc;
+	char SegmentHeader[4] = { 0 };
+
+	int iIndentPrevious = 0;
+	Sci_Position lineLast = pAccess->LineFromPosition(endPos);
+
+	for (Sci_Position lineCurrent = pAccess->LineFromPosition(startPos); lineCurrent <= lineLast; lineCurrent++)
+	{
+		Sci_Position posLineStart = pAccess->LineStart(lineCurrent);
+		posLineStart = ForwardPastWhitespace(pAccess, posLineStart, endPos);
+		Sci_Position lineDataStart = pAccess->LineFromPosition(posLineStart);
+		// Fill in whitespace lines?
+		for (; lineCurrent < lineDataStart; lineCurrent++)
+			pAccess->SetLevel(lineCurrent, SC_FOLDLEVELBASE | SC_FOLDLEVELWHITEFLAG | iIndentPrevious);
+		pAccess->GetCharRange(SegmentHeader, posLineStart, 3);
+		//if (DetectSegmentHeader(SegmentHeader) == SCE_EDI_BADSEGMENT) // Abort if this is not a proper segment header
+
+		int level = 0;
+		if (memcmp(SegmentHeader, "UNH", 3) == 0) // UNH starts blocks
+			level = SC_FOLDLEVELBASE | SC_FOLDLEVELHEADERFLAG;
+		// Check for UNA,B and Z. All others are inside messages
+		else if (!memcmp(SegmentHeader, "UNA", 3) || !memcmp(SegmentHeader, "UNB", 3) || !memcmp(SegmentHeader, "UNZ", 3))
+			level = SC_FOLDLEVELBASE;
+		else
+			level = SC_FOLDLEVELBASE | 1;
+		pAccess->SetLevel(lineCurrent, level);
+		iIndentPrevious = level & SC_FOLDLEVELNUMBERMASK;
+	}
+}
+
+Sci_Position LexerEDIFACT::InitialiseFromUNA(IDocument *pAccess, Sci_PositionU MaxLength)
+{
+	MaxLength -= 9; // drop 9 chars, to give us room for UNA:+.? '
+
+	Sci_PositionU startPos = 0;
+	startPos += ForwardPastWhitespace(pAccess, 0, MaxLength);
+	if (startPos < MaxLength)
+	{
+		char bufUNA[9];
+		pAccess->GetCharRange(bufUNA, startPos, 9);
+
+		// Check it's UNA segment
+		if (!memcmp(bufUNA, "UNA", 3))
+		{
+			m_chComponent = bufUNA[3];
+			m_chData = bufUNA[4];
+			m_chDecimal = bufUNA[5];
+			m_chRelease = bufUNA[6];
+			// bufUNA [7] should be space - reserved.
+			m_chSegment = bufUNA[8];
+
+			return 0; // success!
+		}
+	}
+
+	// We failed to find a UNA, so drop to defaults
+	m_chComponent = ':';
+	m_chData = '+';
+	m_chDecimal = '.';
+	m_chRelease = '?';
+	m_chSegment = '\'';
+
+	return -1;
+}
+
+Sci_Position LexerEDIFACT::ForwardPastWhitespace(IDocument *pAccess, Sci_Position startPos, Sci_Position MaxLength) const
+{
+	char c;
+
+	while (startPos < MaxLength)
+	{
+		pAccess->GetCharRange(&c, startPos, 1);
+		switch (c)
+		{
+		case '\t':
+		case '\r':
+		case '\n':
+		case ' ':
+			break;
+		default:
+			return startPos;
+		}
+
+		startPos++;
+	}
+
+	return MaxLength;
+}
+
+int LexerEDIFACT::DetectSegmentHeader(char SegmentHeader[3]) const
+{
+	if (
+		SegmentHeader[0] < 'A' || SegmentHeader[0] > 'Z' ||
+		SegmentHeader[1] < 'A' || SegmentHeader[1] > 'Z' ||
+		SegmentHeader[2] < 'A' || SegmentHeader[2] > 'Z')
+		return SCE_EDI_BADSEGMENT;
+
+	if (memcmp(SegmentHeader, "UNA", 3) == 0)
+		return SCE_EDI_UNA;
+	if (memcmp(SegmentHeader, "UNH", 3) == 0)
+		return SCE_EDI_UNH;
+
+	return SCE_EDI_SEGMENTSTART;
+}
+
+// Look backwards for a ' or a document beginning
+Sci_Position LexerEDIFACT::FindPreviousEnd(IDocument *pAccess, Sci_Position startPos) const
+{
+	for (char c; startPos > 0; startPos--)
+	{
+		pAccess->GetCharRange(&c, startPos, 1);
+		if (c == m_chSegment)
+			return startPos;
+	}
+	// We didn't find a ', so just go with the beginning
+	return 0;
+}
+
+
diff --git a/src/stc/scintilla/lexers/LexErrorList.cxx b/src/stc/scintilla/lexers/LexErrorList.cxx
index d6fe5ee..6dc6b02 100644
--- a/src/stc/scintilla/lexers/LexErrorList.cxx
+++ b/src/stc/scintilla/lexers/LexErrorList.cxx
@@ -257,6 +257,10 @@ static int RecogniseErrorListLine(const char *lineBuffer, Sci_PositionU lengthLi
 			return SCE_ERR_MS;
 		} else if ((state == stCtagsStringDollar) || (state == stCtags)) {
 			return SCE_ERR_CTAG;
+		} else if (initialColonPart && strstr(lineBuffer, ": warning C")) {
+			// Microsoft warning without line number
+			// <filename>: warning C9999
+			return SCE_ERR_MS;
 		} else {
 			return SCE_ERR_DEFAULT;
 		}
@@ -316,12 +320,12 @@ static void ColouriseErrorListLine(
 		int portionStyle = style;
 		while (const char *startSeq = strstr(linePortion, CSI)) {
 			if (startSeq > linePortion) {
-				styler.ColourTo(startPortion + (startSeq - linePortion), portionStyle);
+				styler.ColourTo(startPortion + static_cast<int>(startSeq - linePortion), portionStyle);
 			}
 			const char *endSeq = startSeq + 2;
 			while (!SequenceEnd(*endSeq))
 				endSeq++;
-			const int endSeqPosition = startPortion + (endSeq - linePortion) + 1;
+			const int endSeqPosition = startPortion + static_cast<int>(endSeq - linePortion) + 1;
 			switch (*endSeq) {
 			case 0:
 				styler.ColourTo(endPos, SCE_ERR_ESCSEQ_UNKNOWN);
diff --git a/src/stc/scintilla/lexers/LexHTML.cxx b/src/stc/scintilla/lexers/LexHTML.cxx
index 43f51de..bd14534 100644
--- a/src/stc/scintilla/lexers/LexHTML.cxx
+++ b/src/stc/scintilla/lexers/LexHTML.cxx
@@ -610,6 +610,17 @@ static void ColouriseHyperTextDoc(Sci_PositionU startPos, Sci_Position length, i
 	}
 	styler.StartAt(startPos);
 
+	/* Nothing handles getting out of these, so we need not start in any of them.
+	 * As we're at line start and they can't span lines, we'll re-detect them anyway */
+	switch (state) {
+		case SCE_H_QUESTION:
+		case SCE_H_XMLSTART:
+		case SCE_H_XMLEND:
+		case SCE_H_ASP:
+			state = SCE_H_DEFAULT;
+			break;
+	}
+
 	Sci_Position lineCurrent = styler.GetLine(startPos);
 	int lineState;
 	if (lineCurrent > 0) {
@@ -898,7 +909,7 @@ static void ColouriseHyperTextDoc(Sci_PositionU startPos, Sci_Position length, i
 		/////////////////////////////////////
 		// handle the start of PHP pre-processor = Non-HTML
 		else if ((state != SCE_H_ASPAT) &&
-		         !isPHPStringState(state) &&
+		         !isStringState(state) &&
 		         (state != SCE_HPHP_COMMENT) &&
 		         (state != SCE_HPHP_COMMENTLINE) &&
 		         (ch == '<') &&
diff --git a/src/stc/scintilla/lexers/LexJSON.cxx b/src/stc/scintilla/lexers/LexJSON.cxx
index 9c044e5..6c06061 100644
--- a/src/stc/scintilla/lexers/LexJSON.cxx
+++ b/src/stc/scintilla/lexers/LexJSON.cxx
@@ -457,7 +457,9 @@ void SCI_METHOD LexerJSON::Fold(Sci_PositionU startPos,
 	LexAccessor styler(pAccess);
 	Sci_PositionU currLine = styler.GetLine(startPos);
 	Sci_PositionU endPos = startPos + length;
-	int currLevel = styler.LevelAt(currLine) & SC_FOLDLEVELNUMBERMASK;
+	int currLevel = SC_FOLDLEVELBASE;
+	if (currLine > 0)
+		currLevel = styler.LevelAt(currLine - 1) >> 16;
 	int nextLevel = currLevel;
 	int visibleChars = 0;
 	for (Sci_PositionU i = startPos; i < endPos; i++) {
@@ -472,7 +474,7 @@ void SCI_METHOD LexerJSON::Fold(Sci_PositionU startPos,
 			}
 		}
 		if (atEOL || i == (endPos-1)) {
-			int level = currLevel;
+			int level = currLevel | nextLevel << 16;
 			if (!visibleChars && options.foldCompact) {
 				level |= SC_FOLDLEVELWHITEFLAG;
 			} else if (nextLevel > currLevel) {
diff --git a/src/stc/scintilla/lexers/LexMatlab.cxx b/src/stc/scintilla/lexers/LexMatlab.cxx
index 6b4b2a9..ca5e4d9 100644
--- a/src/stc/scintilla/lexers/LexMatlab.cxx
+++ b/src/stc/scintilla/lexers/LexMatlab.cxx
@@ -15,6 +15,9 @@
  **
  ** Changes by John Donoghue 2014/08/01
  **   - fix allowed transpose ' after {} operator
+ **
+ ** Changes by John Donoghue 2016/11/15
+ **   - update matlab code folding
  **/
 // Copyright 1998-2001 by Neil Hodgson <neilh@scintilla.org>
 // The License.txt file describes the conditions under which this software may be distributed.
@@ -49,14 +52,28 @@ static bool IsOctaveCommentChar(int c) {
 	return (c == '%' || c == '#') ;
 }
 
-static bool IsMatlabComment(Accessor &styler, Sci_Position pos, Sci_Position len) {
-	return len > 0 && IsMatlabCommentChar(styler[pos]) ;
+static inline int LowerCase(int c) {
+	if (c >= 'A' && c <= 'Z')
+		return 'a' + c - 'A';
+	return c;
 }
 
-static bool IsOctaveComment(Accessor &styler, Sci_Position pos, Sci_Position len) {
-	return len > 0 && IsOctaveCommentChar(styler[pos]) ;
+static int CheckKeywordFoldPoint(char *str) {
+	if (strcmp ("if", str) == 0 ||
+		strcmp ("for", str) == 0 ||
+		strcmp ("switch", str) == 0 ||
+		strcmp ("try", str) == 0 ||
+		strcmp ("do", str) == 0 ||
+		strcmp ("parfor", str) == 0 ||
+		strcmp ("function", str) == 0)
+		return 1;
+	if (strncmp("end", str, 3) == 0 ||
+		strcmp("until", str) == 0)
+		return -1;
+	return 0;
 }
 
+
 static void ColouriseMatlabOctaveDoc(
             Sci_PositionU startPos, Sci_Position length, int initStyle,
             WordList *keywordlists[], Accessor &styler,
@@ -245,58 +262,82 @@ static void ColouriseOctaveDoc(Sci_PositionU startPos, Sci_Position length, int
 	ColouriseMatlabOctaveDoc(startPos, length, initStyle, keywordlists, styler, IsOctaveCommentChar, false);
 }
 
-static void FoldMatlabOctaveDoc(Sci_PositionU startPos, Sci_Position length, int,
+static void FoldMatlabOctaveDoc(Sci_PositionU startPos, Sci_Position length, int initStyle,
                                 WordList *[], Accessor &styler,
-                                bool (*IsComment)(Accessor&, Sci_Position, Sci_Position)) {
-
-	Sci_Position endPos = startPos + length;
+                                bool (*IsComment)(int ch)) {
 
-	// Backtrack to previous line in case need to fix its fold status
+	Sci_PositionU endPos = startPos + length;
+	int visibleChars = 0;
 	Sci_Position lineCurrent = styler.GetLine(startPos);
-	if (startPos > 0) {
-		if (lineCurrent > 0) {
-			lineCurrent--;
-			startPos = styler.LineStart(lineCurrent);
-		}
-	}
-	int spaceFlags = 0;
-	int indentCurrent = styler.IndentAmount(lineCurrent, &spaceFlags, IsComment);
+	int levelCurrent = SC_FOLDLEVELBASE;
+	if (lineCurrent > 0)
+		levelCurrent = styler.LevelAt(lineCurrent-1) >> 16;
+	int levelNext = levelCurrent;
 	char chNext = styler[startPos];
-	for (Sci_Position i = startPos; i < endPos; i++) {
+	int styleNext = styler.StyleAt(startPos);
+	int style = initStyle;
+	char word[100];
+	int wordlen = 0;
+	for (Sci_PositionU i = startPos; i < endPos; i++) {
 		char ch = chNext;
 		chNext = styler.SafeGetCharAt(i + 1);
-
-		if ((ch == '\r' && chNext != '\n') || (ch == '\n') || (i == endPos)) {
-			int lev = indentCurrent;
-			int indentNext = styler.IndentAmount(lineCurrent + 1, &spaceFlags, IsComment);
-			if (!(indentCurrent & SC_FOLDLEVELWHITEFLAG)) {
-				// Only non whitespace lines can be headers
-				if ((indentCurrent & SC_FOLDLEVELNUMBERMASK) < (indentNext & SC_FOLDLEVELNUMBERMASK)) {
-					lev |= SC_FOLDLEVELHEADERFLAG;
-				} else if (indentNext & SC_FOLDLEVELWHITEFLAG) {
-					// Line after is blank so check the next - maybe should continue further?
-					int spaceFlags2 = 0;
-					int indentNext2 = styler.IndentAmount(lineCurrent + 2, &spaceFlags2, IsComment);
-					if ((indentCurrent & SC_FOLDLEVELNUMBERMASK) < (indentNext2 & SC_FOLDLEVELNUMBERMASK)) {
-						lev |= SC_FOLDLEVELHEADERFLAG;
-					}
-				}
+		style = styleNext;
+		styleNext = styler.StyleAt(i + 1);
+		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
+	
+		// a line that starts with a comment
+		if (style == SCE_MATLAB_COMMENT && IsComment(ch) && visibleChars == 0) {
+			// start/end of block comment 
+			if (chNext == '{')
+				levelNext ++;
+			if (chNext == '}')
+				levelNext --;
+		}
+		// keyword
+		if(style == SCE_MATLAB_KEYWORD) {
+			word[wordlen++] = static_cast<char>(LowerCase(ch));
+			if (wordlen == 100) {  // prevent overflow
+				word[0] = '\0';
+				wordlen = 1;
+			}
+			if (styleNext !=  SCE_MATLAB_KEYWORD) {
+				word[wordlen] = '\0';
+				wordlen = 0;
+	
+				levelNext += CheckKeywordFoldPoint(word);
+ 			}
+		}
+		if (!IsASpace(ch))
+			visibleChars++;
+		if (atEOL || (i == endPos-1)) {
+			int levelUse = levelCurrent;
+			int lev = levelUse | levelNext << 16;
+			if (visibleChars == 0)
+				lev |= SC_FOLDLEVELWHITEFLAG;
+			if (levelUse < levelNext)
+				lev |= SC_FOLDLEVELHEADERFLAG;
+			if (lev != styler.LevelAt(lineCurrent)) {
+				styler.SetLevel(lineCurrent, lev);
 			}
-			indentCurrent = indentNext;
-			styler.SetLevel(lineCurrent, lev);
 			lineCurrent++;
+			levelCurrent = levelNext;
+			if (atEOL && (i == static_cast<Sci_PositionU>(styler.Length() - 1))) {
+				// There is an empty line at end of file so give it same level and empty
+				styler.SetLevel(lineCurrent, (levelCurrent | levelCurrent << 16) | SC_FOLDLEVELWHITEFLAG);
+			}
+			visibleChars = 0;
 		}
 	}
 }
 
 static void FoldMatlabDoc(Sci_PositionU startPos, Sci_Position length, int initStyle,
                           WordList *keywordlists[], Accessor &styler) {
-	FoldMatlabOctaveDoc(startPos, length, initStyle, keywordlists, styler, IsMatlabComment);
+	FoldMatlabOctaveDoc(startPos, length, initStyle, keywordlists, styler, IsMatlabCommentChar);
 }
 
 static void FoldOctaveDoc(Sci_PositionU startPos, Sci_Position length, int initStyle,
                           WordList *keywordlists[], Accessor &styler) {
-	FoldMatlabOctaveDoc(startPos, length, initStyle, keywordlists, styler, IsOctaveComment);
+	FoldMatlabOctaveDoc(startPos, length, initStyle, keywordlists, styler, IsOctaveCommentChar);
 }
 
 static const char * const matlabWordListDesc[] = {
diff --git a/src/stc/scintilla/lexers/LexPerl.cxx b/src/stc/scintilla/lexers/LexPerl.cxx
index 3b10b47..b3c5d58 100644
--- a/src/stc/scintilla/lexers/LexPerl.cxx
+++ b/src/stc/scintilla/lexers/LexPerl.cxx
@@ -755,7 +755,7 @@ void SCI_METHOD LexerPerl::Lex(Sci_PositionU startPos, Sci_Position length, int
 		backPos++;
 	}
 
-	StyleContext sc(startPos, endPos - startPos, initStyle, styler, static_cast<char>(STYLE_MAX));
+	StyleContext sc(startPos, endPos - startPos, initStyle, styler);
 
 	for (; sc.More(); sc.Forward()) {
 
diff --git a/src/stc/scintilla/lexers/LexPowerShell.cxx b/src/stc/scintilla/lexers/LexPowerShell.cxx
index 00d79db..bf1ee29 100644
--- a/src/stc/scintilla/lexers/LexPowerShell.cxx
+++ b/src/stc/scintilla/lexers/LexPowerShell.cxx
@@ -149,6 +149,8 @@ static void ColourisePowerShellDoc(Sci_PositionU startPos, Sci_Position length,
 				sc.SetState(SCE_POWERSHELL_OPERATOR);
 			} else if (IsAWordChar(sc.ch)) {
 				sc.SetState(SCE_POWERSHELL_IDENTIFIER);
+			} else if (sc.ch == '`') {
+				sc.Forward(); // skip next escaped character
 			}
 		}
 	}
diff --git a/src/stc/scintilla/lexers/LexProgress.cxx b/src/stc/scintilla/lexers/LexProgress.cxx
index 6c687ef..c1c4529 100644
--- a/src/stc/scintilla/lexers/LexProgress.cxx
+++ b/src/stc/scintilla/lexers/LexProgress.cxx
@@ -3,13 +3,18 @@
  **  Lexer for Progress 4GL.
  ** Based on LexCPP.cxx of Neil Hodgson <neilh@scintilla.org>
   **/
-// Copyright 2006-2007 by Yuval Papish <Yuval@YuvCom.com>
+// Copyright 2006-2016 by Yuval Papish <Yuval@YuvCom.com>
 // The License.txt file describes the conditions under which this software may be distributed.
 
 /** TODO:
-WebSpeed support in html lexer
-Support "end triggers" expression of the triggers phrase
+
+SpeedScript support in html lexer
+Differentiate between labels and variables
+  Option 1: By symbols table
+  Option 2: As a single unidentified symbol in a sytactical line 
+
 **/
+
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
@@ -17,300 +22,538 @@ Support "end triggers" expression of the triggers phrase
 #include <assert.h>
 #include <ctype.h>
 
+#include <string>
+#include <vector>
+#include <map>
+
 #include "ILexer.h"
 #include "Scintilla.h"
 #include "SciLexer.h"
 
 #include "WordList.h"
 #include "LexAccessor.h"
-#include "Accessor.h"
 #include "StyleContext.h"
 #include "CharacterSet.h"
 #include "LexerModule.h"
+#include "OptionSet.h"
+#include "SparseState.h"
 
 #ifdef SCI_NAMESPACE
 using namespace Scintilla;
 #endif
 
-static inline bool IsAWordChar(int ch) {
-	return (ch < 0x80) && (isalnum(ch) || ch == '_');
+namespace {
+   // Use an unnamed namespace to protect the functions and classes from name conflicts
+
+   bool IsSpaceEquiv(int state) {
+      return (state == SCE_ABL_COMMENT ||
+              state == SCE_ABL_LINECOMMENT ||
+              state == SCE_ABL_DEFAULT);
+   }
+
+   void highlightTaskMarker(StyleContext &sc, LexAccessor &styler, WordList &markerList){
+      if ((isoperator(sc.chPrev) || IsASpace(sc.chPrev)) && markerList.Length()) {
+         const int lengthMarker = 50;
+         char marker[lengthMarker+1];
+         Sci_Position currPos = (Sci_Position) sc.currentPos;
+         Sci_Position i = 0;
+         while (i < lengthMarker) {
+            char ch = styler.SafeGetCharAt(currPos + i);
+            if (IsASpace(ch) || isoperator(ch)) {
+               break;
+            }
+            marker[i] = ch;
+            i++;
+         }
+         marker[i] = '\0';
+         if (markerList.InListAbbreviated (marker,'(')) {
+            sc.SetState(SCE_ABL_TASKMARKER);
+         }
+      }
+   }
+
+   bool IsStreamCommentStyle(int style) {
+      return style == SCE_ABL_COMMENT;
+             // style == SCE_ABL_LINECOMMENT;  Only block comments are used for folding 
+   }
+
+   // Options used for LexerABL
+   struct OptionsABL {
+      bool fold;
+      bool foldSyntaxBased;
+      bool foldComment;
+      bool foldCommentMultiline;
+      bool foldCompact;
+      OptionsABL() {
+         fold = false;
+         foldSyntaxBased = true;
+         foldComment = true;
+         foldCommentMultiline = true;
+         foldCompact = false;
+      }
+   };
+
+   const char *const ablWordLists[] = {
+               "Primary keywords and identifiers",
+               "Keywords that opens a block, only when used to begin a syntactic line",
+               "Keywords that opens a block anywhere in a syntactic line",
+               "Task Marker", /* "END MODIFY START TODO" */
+               0,
+   };
+
+   struct OptionSetABL : public OptionSet<OptionsABL> {
+      OptionSetABL() {
+         DefineProperty("fold", &OptionsABL::fold);
+
+         DefineProperty("fold.abl.syntax.based", &OptionsABL::foldSyntaxBased,
+            "Set this property to 0 to disable syntax based folding.");
+
+         DefineProperty("fold.comment", &OptionsABL::foldComment,
+            "This option enables folding multi-line comments and explicit fold points when using the ABL lexer. ");
+
+         DefineProperty("fold.abl.comment.multiline", &OptionsABL::foldCommentMultiline,
+            "Set this property to 0 to disable folding multi-line comments when fold.comment=1.");
+
+         DefineProperty("fold.compact", &OptionsABL::foldCompact);
+
+         DefineWordListSets(ablWordLists);
+      }
+   };
 }
 
-static inline bool IsAWordStart(int ch) {
-	return (ch < 0x80) && (isalpha(ch) || ch == '_');
+class LexerABL : public ILexer {
+   CharacterSet setWord;
+   CharacterSet setNegationOp;
+   CharacterSet setArithmethicOp;
+   CharacterSet setRelOp;
+   CharacterSet setLogicalOp;
+   CharacterSet setWordStart;
+   WordList keywords1;      // regular keywords
+   WordList keywords2;      // block opening keywords, only when isSentenceStart
+   WordList keywords3;      // block opening keywords
+   WordList keywords4;      // Task Marker
+   OptionsABL options;
+   OptionSetABL osABL;
+public:
+   LexerABL() :
+      setWord(CharacterSet::setAlphaNum, "_", 0x80, true),
+      setNegationOp(CharacterSet::setNone, "!"),
+      setArithmethicOp(CharacterSet::setNone, "+-/*%"),
+      setRelOp(CharacterSet::setNone, "=!<>"),
+      setLogicalOp(CharacterSet::setNone, "|&"){
+   }
+   virtual ~LexerABL() {
+   }
+   void SCI_METHOD Release() {
+      delete this;
+   }
+   int SCI_METHOD Version() const {
+      return lvOriginal;
+   }
+   const char * SCI_METHOD PropertyNames() {
+      return osABL.PropertyNames();
+   }
+   int SCI_METHOD PropertyType(const char *name) {
+      return osABL.PropertyType(name);
+   }
+   const char * SCI_METHOD DescribeProperty(const char *name) {
+      return osABL.DescribeProperty(name);
+   }
+   Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) ;
+   
+   const char * SCI_METHOD DescribeWordListSets() {
+      return osABL.DescribeWordListSets();
+   }
+   Sci_Position SCI_METHOD WordListSet(int n, const char *wl);
+   void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess);
+   void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess);
+
+   void * SCI_METHOD PrivateCall(int, void *) {
+      return 0;
+   }
+   int SCI_METHOD LineEndTypesSupported() {
+      return SC_LINE_END_TYPE_DEFAULT;
+   }
+   static ILexer *LexerFactoryABL() {
+      return new LexerABL();
+   }
+};
+
+Sci_Position SCI_METHOD LexerABL::PropertySet(const char *key, const char *val) {
+   if (osABL.PropertySet(&options, key, val)) {
+      return 0;
+   }
+   return -1;
 }
 
-enum SentenceStart { SetSentenceStart = 0xf, ResetSentenceStart = 0x10}; // true -> bit = 0
-
-static void Colourise4glDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *keywordlists[],
-							Accessor &styler) {
-
-	WordList &keywords1 = *keywordlists[0];   // regular keywords
-	WordList &keywords2 = *keywordlists[1];   // block opening keywords, only when SentenceStart
-	WordList &keywords3 = *keywordlists[2];   // block opening keywords
-	//WordList &keywords4 = *keywordlists[3]; // preprocessor keywords. Not implemented
-
-	Sci_Position currentLine = styler.GetLine(startPos);
-	// Initialize the block comment /* */ nesting level, if we are inside such a comment.
-	int blockCommentLevel = 0;
-	if (initStyle == SCE_4GL_COMMENT1 ||
-		initStyle == SCE_4GL_COMMENT1_) {
-		blockCommentLevel = styler.GetLineState(currentLine - 1);
-	}
-
-	// Do not leak single-line comments onto next line
-	if (initStyle == SCE_4GL_COMMENT2 ||
-		initStyle == SCE_4GL_COMMENT2_) {
-		initStyle = SCE_4GL_DEFAULT;
-	}
-
-	int visibleChars = 0;
-	int mask;
-
-	StyleContext sc(startPos, length, initStyle, styler);
-
-	for (; sc.More(); sc.Forward()) {
-
-		if (sc.atLineStart) {
-			// Reset states to begining of colourise so no surprises
-			// if different sets of lines lexed.
-			visibleChars = 0;
-		}
-
-		if (sc.atLineEnd) {
-			// Update the line state, so it can be seen by next line
-			currentLine = styler.GetLine(sc.currentPos);
-			if (sc.state == SCE_4GL_COMMENT1 ||
-				sc.state == SCE_4GL_COMMENT1_) {
-				// Inside a block comment, we set the line state
-				styler.SetLineState(currentLine, blockCommentLevel);
-			} else {
-				// Reset the line state
-				styler.SetLineState(currentLine, 0);
-			}
-		}
-
-		// Handle line continuation generically.
-		if ((sc.state & 0xf) < SCE_4GL_COMMENT1) {
-		if (sc.ch == '~') {
-			if (sc.chNext > ' ') {
-				// skip special char after ~
-				sc.Forward();
-				continue;
-			}
-			else {
-				// Skip whitespace between ~ and EOL
-				while (sc.More() && (sc.chNext == ' ' || sc.chNext == '\t') ) {
-					sc.Forward();
-				}
-				if (sc.chNext == '\n' || sc.chNext == '\r') {
-					sc.Forward();
-					if (sc.ch == '\r' && sc.chNext == '\n') {
-						sc.Forward();
-					}
-					sc.Forward();
-					continue;
-				}
-			}
-		}
-		}
-		// Determine if a new state should be terminated.
-		mask = sc.state & 0x10;
-		switch (sc.state & 0xf) {
-			case SCE_4GL_OPERATOR:
-				sc.SetState(SCE_4GL_DEFAULT | mask);
-				break;
-			case SCE_4GL_NUMBER:
-				// Hex numbers (0xnnnn) are supported so accept any
-				// alphanumeric character if it follows a leading digit.
-				if (!(IsAlphaNumeric(sc.ch))) {
-					sc.SetState(SCE_4GL_DEFAULT | mask);
-				}
-				break;
-			case SCE_4GL_IDENTIFIER:
-				if (!IsAWordChar(sc.ch) && sc.ch != '-') {
-					char s[1000];
-					sc.GetCurrentLowered(s, sizeof(s));
-					if ((((sc.state & 0x10) == 0) && keywords2.InListAbbreviated(s, '(')) || keywords3.InListAbbreviated(s, '(')) {
-						sc.ChangeState(SCE_4GL_BLOCK | ResetSentenceStart);
-					}
-					else if (keywords1.InListAbbreviated(s, '(')) {
-						if ((s[0] == 'e' && s[1] =='n' && s[2] == 'd' && !isalnum(s[3]) && s[3] != '-') ||
-							(s[0] == 'f' && s[1] =='o' && s[2] == 'r' && s[3] == 'w' && s[4] =='a' && s[5] == 'r' && s[6] == 'd'&& !isalnum(s[7]))) {
-							sc.ChangeState(SCE_4GL_END | ResetSentenceStart);
-						}
-						else if	((s[0] == 'e' && s[1] =='l' && s[2] == 's' && s[3] == 'e') ||
-								 (s[0] == 't' && s[1] =='h' && s[2] == 'e' && s[3] == 'n')) {
-							sc.ChangeState(SCE_4GL_WORD & SetSentenceStart);
-						}
-						else {
-							sc.ChangeState(SCE_4GL_WORD | ResetSentenceStart);
-						}
-					}
-					sc.SetState(SCE_4GL_DEFAULT | (sc.state & 0x10));
-				}
-				break;
-			case SCE_4GL_PREPROCESSOR:
-				if (sc.atLineStart) {
-					sc.SetState(SCE_4GL_DEFAULT & SetSentenceStart);
-				}
-				/* code removed to allow comments inside preprocessor
-					else if (sc.ch == '*' && sc.chNext == '/') {
-					sc.ForwardSetState(SCE_4GL_DEFAULT | sentenceStartState); } */
-				break;
-			case SCE_4GL_STRING:
-				if (sc.ch == '\"') {
-					sc.ForwardSetState(SCE_4GL_DEFAULT | mask);
-				}
-				break;
-			case SCE_4GL_CHARACTER:
-				if (sc.ch == '\'') {
-					sc.ForwardSetState(SCE_4GL_DEFAULT | mask);
-				}
-				break;
-			case SCE_4GL_COMMENT1:
-				if (sc.Match('/', '*')) {
-					blockCommentLevel++;
-					sc.Forward();
-				} else if (sc.Match('*', '/') && blockCommentLevel > 0) {
-					blockCommentLevel--;
-					sc.Forward();
-					if (blockCommentLevel == 0) {
-						sc.ForwardSetState(SCE_4GL_DEFAULT | mask);
-					}
-				}
-				break;
-			case SCE_4GL_COMMENT2:
-				if (sc.atLineEnd) {
-					sc.ForwardSetState(SCE_4GL_DEFAULT | mask);
-				}
-				break;
-		}
-
-		// Determine if a new state should be entered.
-		mask = sc.state & 0x10;
-		if ((sc.state & 0xf) == SCE_4GL_DEFAULT) {
-			if (IsADigit(sc.ch) || (sc.ch == '.' && IsADigit(sc.chNext))) {
-				sc.SetState(SCE_4GL_NUMBER | ResetSentenceStart);
-			} else if (IsAWordStart(sc.ch) || (sc.ch == '@')) {
-				sc.SetState(SCE_4GL_IDENTIFIER | mask);
-			} else if (sc.Match('/', '*')) {
-				blockCommentLevel = 1;
-				sc.SetState(SCE_4GL_COMMENT1 | mask);
-				sc.Forward();
-			} else if (sc.Match('/', '/') &&
-					   (sc.atLineStart || sc.chPrev == ' ' || sc.chPrev == '\t')) {
-				sc.SetState(SCE_4GL_COMMENT2 | mask);
-			} else if (sc.ch == '\"') {
-				sc.SetState(SCE_4GL_STRING | ResetSentenceStart);
-			} else if (sc.ch == '\'') {
-				sc.SetState(SCE_4GL_CHARACTER | ResetSentenceStart);
-			} else if (sc.ch == '&' && visibleChars == 0 && ((sc.state & 0x10) == 0)) {
-				sc.SetState(SCE_4GL_PREPROCESSOR | ResetSentenceStart);
-				// Skip whitespace between & and preprocessor word
-				do {
-					sc.Forward();
-				} while ((sc.ch == ' ' || sc.ch == '\t') && sc.More());
-			// Handle syntactical line termination
-			} else if ((sc.ch == '.' || sc.ch == ':' || sc.ch == '}') && (sc.chNext == ' ' || sc.chNext == '\t' || sc.chNext == '\n' || sc.chNext == '\r')) {
-				sc.SetState(sc.state & SetSentenceStart);
-			} else if (isoperator(static_cast<char>(sc.ch))) {
-		/* 	This code allows highlight of handles. Alas, it would cause the phrase "last-event:function"
-			to be recognized as a BlockBegin */
-
-				if (sc.ch == ':')
-					sc.SetState(SCE_4GL_OPERATOR & SetSentenceStart);
-				/* else */
-					sc.SetState(SCE_4GL_OPERATOR | ResetSentenceStart);
-			}
-		}
-
-		if (!IsASpace(sc.ch)) {
-			visibleChars++;
-		}
-	}
-	sc.Complete();
+Sci_Position SCI_METHOD LexerABL::WordListSet(int n, const char *wl) {
+   WordList *wordListN = 0;
+   switch (n) {
+   case 0:
+      wordListN = &keywords1;
+      break;
+   case 1:
+      wordListN = &keywords2;
+      break;
+   case 2:
+      wordListN = &keywords3;
+      break;
+   case 3:
+      wordListN = &keywords4;
+      break;
+   }
+   Sci_Position firstModification = -1;
+   if (wordListN) {
+      WordList wlNew;
+      wlNew.Set(wl);
+      if (*wordListN != wlNew) {
+         wordListN->Set(wl);
+         firstModification = 0;
+      }
+   }
+   return firstModification;
 }
 
-static bool IsStreamCommentStyle(int style) {
-	return (style & 0xf) == SCE_4GL_COMMENT1 ;
+void SCI_METHOD LexerABL::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
+   LexAccessor styler(pAccess);
+
+   setWordStart = CharacterSet(CharacterSet::setAlpha, "_", 0x80, true);
+
+   int visibleChars = 0;
+   int visibleChars1 = 0;
+   int styleBeforeTaskMarker = SCE_ABL_DEFAULT;
+   bool continuationLine = false;
+   int commentNestingLevel = 0;
+   bool isSentenceStart = true;
+   bool possibleOOLChange = false;
+
+   Sci_Position lineCurrent = styler.GetLine(startPos);
+   if (initStyle == SCE_ABL_PREPROCESSOR) {
+      // Set continuationLine if last character of previous line is '~'
+      if (lineCurrent > 0) {
+         Sci_Position endLinePrevious = styler.LineEnd(lineCurrent-1);
+         if (endLinePrevious > 0) {
+            continuationLine = styler.SafeGetCharAt(endLinePrevious-1) == '~';
+         }
+      }
+   } 
+
+    // Look back to set variables that are actually invisible secondary states. The reason to avoid formal states is to cut down on state's bits
+   if (startPos > 0) {
+      Sci_Position back = startPos;
+      bool checkCommentNestingLevel = (initStyle == SCE_ABL_COMMENT);
+      bool checkIsSentenceStart = (initStyle == SCE_ABL_DEFAULT || initStyle == SCE_ABL_IDENTIFIER);
+      char ch;
+      char st;
+      char chPrev;
+      char chPrev_1;
+      char chPrev_2;
+      char chPrev_3;
+
+      while (back >= 0 && (checkCommentNestingLevel || checkIsSentenceStart)) {
+         ch = styler.SafeGetCharAt(back);
+         styler.Flush();  // looking at styles so need to flush
+         st = styler.StyleAt(back);
+         
+         chPrev = styler.SafeGetCharAt(back-1);
+         // isSentenceStart is a non-visible state, used to identify where statements and preprocessor declerations can start 
+         if (checkIsSentenceStart && st != SCE_ABL_COMMENT && st != SCE_ABL_LINECOMMENT && st != SCE_ABL_CHARACTER  && st != SCE_ABL_STRING ) {
+            chPrev_1 = styler.SafeGetCharAt(back-2);
+            chPrev_2 = styler.SafeGetCharAt(back-3);
+            chPrev_3 = styler.SafeGetCharAt(back-4);
+            if ((chPrev == '.' || chPrev == ':' || chPrev == '}' ||
+               (chPrev_3 == 'e' && chPrev_2 == 'l' && chPrev_1 == 's' &&  chPrev == 'e') ||
+               (chPrev_3 == 't' && chPrev_2 == 'h' && chPrev_1 == 'e' &&  chPrev == 'n')) &&
+               (IsASpace(ch) || (ch == '/' && styler.SafeGetCharAt(back+1) == '*'))
+               ) {
+                  checkIsSentenceStart = false;
+                  isSentenceStart = true;
+            }
+            else if (IsASpace(chPrev) && ch == '{') {
+               checkIsSentenceStart = false;
+               isSentenceStart = false;
+            }
+         }
+
+         // commentNestingLevel is a non-visible state, used to identify the nesting level of a comment
+         if (checkCommentNestingLevel) {
+            if (chPrev == '/' && ch == '*')
+               commentNestingLevel++;
+            if (chPrev == '*' && ch == '/') {
+               commentNestingLevel--;
+            }
+         }         
+         --back;
+      }
+   }
+
+   StyleContext sc(startPos, length, initStyle, styler, static_cast<unsigned char>(0xff));
+   Sci_Position lineEndNext = styler.LineEnd(lineCurrent);
+
+   for (; sc.More();) {
+      if (sc.atLineStart) {
+         visibleChars = 0;
+         visibleChars1 = 0;
+      }
+      if (sc.atLineEnd) {
+         lineCurrent++;
+         lineEndNext = styler.LineEnd(lineCurrent);
+      }
+      // Handle line continuation generically.
+      if (sc.ch == '~') {
+         if (static_cast<Sci_Position>((sc.currentPos+1)) >= lineEndNext) {
+            lineCurrent++;
+            lineEndNext = styler.LineEnd(lineCurrent);
+            sc.Forward();
+            if (sc.ch == '\r' && sc.chNext == '\n') {
+               sc.Forward();
+            }
+            continuationLine = true;
+            sc.Forward();
+            continue;
+         }
+      }
+
+      const bool atLineEndBeforeSwitch = sc.atLineEnd;
+      // Determine if the current state should terminate.
+      switch (sc.state) {
+         case SCE_ABL_OPERATOR:
+            sc.SetState(SCE_ABL_DEFAULT);
+            break;
+         case SCE_ABL_NUMBER:
+            // We accept almost anything because of hex. and maybe number suffixes and scientific notations in the future
+            if (!(setWord.Contains(sc.ch)
+				   || ((sc.ch == '+' || sc.ch == '-') && (sc.chPrev == 'e' || sc.chPrev == 'E' ||
+				                                          sc.chPrev == 'p' || sc.chPrev == 'P')))) {
+               sc.SetState(SCE_ABL_DEFAULT);
+            }
+            break;
+         case SCE_ABL_IDENTIFIER:
+            if (sc.atLineStart || sc.atLineEnd || (!setWord.Contains(sc.ch) && sc.ch != '-')) {
+               char s[1000];
+               sc.GetCurrentLowered(s, sizeof(s));
+               bool isLastWordEnd = (s[0] == 'e' && s[1] =='n' && s[2] == 'd' && !IsAlphaNumeric(s[3]) && s[3] != '-');  // helps to identify "end trigger" phrase
+               if ((isSentenceStart && keywords2.InListAbbreviated (s,'(')) || (!isLastWordEnd && keywords3.InListAbbreviated (s,'('))) {
+                  sc.ChangeState(SCE_ABL_BLOCK);
+                  isSentenceStart = false;
+               }
+               else if (keywords1.InListAbbreviated (s,'(')) {
+                  if (isLastWordEnd ||
+                     (s[0] == 'f' && s[1] =='o' && s[2] == 'r' && s[3] == 'w' && s[4] =='a' && s[5] == 'r' && s[6] == 'd'&& !IsAlphaNumeric(s[7]))) {
+                     sc.ChangeState(SCE_ABL_END);
+                     isSentenceStart = false;
+                  }
+                  else if ((s[0] == 'e' && s[1] =='l' && s[2] == 's' && s[3] == 'e') ||
+                         (s[0] == 't' && s[1] =='h' && s[2] == 'e' && s[3] == 'n')) {
+                     sc.ChangeState(SCE_ABL_WORD);
+                     isSentenceStart = true;
+                  }
+                  else {
+                     sc.ChangeState(SCE_ABL_WORD);
+                     isSentenceStart = false;
+                  }
+               }
+               sc.SetState(SCE_ABL_DEFAULT);
+            }
+            break;
+         case SCE_ABL_PREPROCESSOR:
+            if (sc.atLineStart && !continuationLine) {
+               sc.SetState(SCE_ABL_DEFAULT);
+               // Force Scintilla to acknowledge changed stated even though this change might happen outside of the current line
+               possibleOOLChange = true;
+               isSentenceStart = true;
+            }
+            break;
+         case SCE_ABL_LINECOMMENT:
+            if (sc.atLineStart && !continuationLine) {
+               sc.SetState(SCE_ABL_DEFAULT);
+               isSentenceStart = true;
+            } else {
+               styleBeforeTaskMarker = SCE_ABL_LINECOMMENT;
+               highlightTaskMarker(sc, styler, keywords4);
+            }
+            break;
+         case SCE_ABL_TASKMARKER:
+            if (isoperator(sc.ch) || IsASpace(sc.ch)) {
+               sc.SetState(styleBeforeTaskMarker);
+               styleBeforeTaskMarker = SCE_ABL_DEFAULT;
+            }
+            // fall through
+         case SCE_ABL_COMMENT:
+            if (sc.Match('*', '/')) {
+               sc.Forward();
+               commentNestingLevel--;
+               if (commentNestingLevel == 0) {
+                  sc.ForwardSetState(SCE_ABL_DEFAULT);
+                  possibleOOLChange = true;
+               }
+            } else if (sc.Match('/', '*')) {
+               commentNestingLevel++;
+               sc.Forward();
+            }
+            if (commentNestingLevel > 0) {
+               styleBeforeTaskMarker = SCE_ABL_COMMENT;
+               possibleOOLChange = true;
+               highlightTaskMarker(sc, styler, keywords4);
+            }
+            break;
+         case SCE_ABL_STRING:
+            if (sc.ch == '~') {
+               sc.Forward(); // Skip a character after a tilde
+            } else if (sc.ch == '\"') {
+                  sc.ForwardSetState(SCE_ABL_DEFAULT);
+            }
+            break;
+         case SCE_ABL_CHARACTER:
+            if (sc.ch == '~') {
+               sc.Forward(); // Skip a character after a tilde
+            } else if (sc.ch == '\'') {
+                  sc.ForwardSetState(SCE_ABL_DEFAULT);
+            }
+            break;
+      }
+
+      if (sc.atLineEnd && !atLineEndBeforeSwitch) {
+         // State exit processing consumed characters up to end of line.
+         lineCurrent++;
+         lineEndNext = styler.LineEnd(lineCurrent);
+      }
+
+      // Determine if a new state should be entered.
+      if (sc.state == SCE_ABL_DEFAULT) {
+         if (IsADigit(sc.ch) || (sc.ch == '.' && IsADigit(sc.chNext))) {
+               sc.SetState(SCE_ABL_NUMBER);
+               isSentenceStart = false;
+         } else if (!sc.atLineEnd && (setWordStart.Contains(sc.ch)) && sc.chPrev != '&') {
+               sc.SetState(SCE_ABL_IDENTIFIER);
+         } else if (sc.Match('/', '*')) {
+            if (sc.chPrev == '.' || sc.chPrev == ':' || sc.chPrev == '}') {
+               isSentenceStart = true;
+            }
+            sc.SetState(SCE_ABL_COMMENT);
+            possibleOOLChange = true;
+            commentNestingLevel++;
+            sc.Forward();   // Eat the * so it isn't used for the end of the comment
+         } else if (sc.ch == '\"') {
+               sc.SetState(SCE_ABL_STRING);
+               isSentenceStart = false;
+         } else if (sc.ch == '\'') {
+            sc.SetState(SCE_ABL_CHARACTER);
+            isSentenceStart = false;
+         } else if (sc.ch == '&' && visibleChars1 == 0 && isSentenceStart) {
+            // Preprocessor commands are alone on their line
+            sc.SetState(SCE_ABL_PREPROCESSOR);
+            // Force Scintilla to acknowledge changed stated even though this change might happen outside of the current line
+            possibleOOLChange = true;
+            // Skip whitespace between & and preprocessor word
+            do {
+               sc.Forward();
+            } while ((sc.ch == ' ' || sc.ch == '\t') && sc.More());
+            if (sc.atLineEnd) {
+               sc.SetState(SCE_ABL_DEFAULT);
+            }
+         } else if (sc.Match('/','/') && (IsASpace(sc.chPrev) || isSentenceStart)) {
+            // Line comments are valid after a white space or EOL
+            sc.SetState(SCE_ABL_LINECOMMENT);
+            // Skip whitespace between // and preprocessor word
+            do {
+               sc.Forward();
+            } while ((sc.ch == ' ' || sc.ch == '\t') && sc.More());
+            if (sc.atLineEnd) {
+               sc.SetState(SCE_ABL_DEFAULT);
+            }
+         } else if (isoperator(sc.ch)) {
+            sc.SetState(SCE_ABL_OPERATOR);
+            /*    This code allows highlight of handles. Alas, it would cause the phrase "last-event:function"
+               to be recognized as a BlockBegin */
+               isSentenceStart = false;
+         }
+         else if ((sc.chPrev == '.' || sc.chPrev == ':' || sc.chPrev == '}') && (IsASpace(sc.ch))) {
+            isSentenceStart = true;
+         }
+      }
+      if (!IsASpace(sc.ch)) {
+         visibleChars1++;
+      }
+      if (!IsASpace(sc.ch) && !IsSpaceEquiv(sc.state)) {
+         visibleChars++;
+      }
+      continuationLine = false;
+      sc.Forward();
+   }
+	if (possibleOOLChange)
+		styler.ChangeLexerState(startPos, startPos + length);
+   sc.Complete();
 }
 
+
 // Store both the current line's fold level and the next lines in the
 // level store to make it easy to pick up with each increment
 // and to make it possible to fiddle the current level for "} else {".
-static void FoldNoBox4glDoc(Sci_PositionU startPos, Sci_Position length, int initStyle,
-                            Accessor &styler) {
-	bool foldComment = styler.GetPropertyInt("fold.comment") != 0;
-	bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
-	bool foldAtElse = styler.GetPropertyInt("fold.at.else", 0) != 0;
-	Sci_PositionU endPos = startPos + length;
-	int visibleChars = 0;
-	Sci_Position lineCurrent = styler.GetLine(startPos);
-	int levelCurrent = SC_FOLDLEVELBASE;
-	if (lineCurrent > 0)
-		levelCurrent = styler.LevelAt(lineCurrent-1) >> 16;
-	int levelMinCurrent = levelCurrent;
-	int levelNext = levelCurrent;
-	char chNext = static_cast<char>(tolower(styler[startPos]));
-	int styleNext = styler.StyleAt(startPos);
-	int style = initStyle;
-	for (Sci_PositionU i = startPos; i < endPos; i++) {
-		char ch = chNext;
-		chNext = static_cast<char>(tolower(styler.SafeGetCharAt(i + 1)));
-		int stylePrev = style;
-		style = styleNext;
-		styleNext = styler.StyleAt(i + 1);
-		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
-		if (foldComment && IsStreamCommentStyle(style)) {
-			if (!IsStreamCommentStyle(stylePrev)) {
-				levelNext++;
-			} else if (!IsStreamCommentStyle(styleNext)) { // && !atEOL) {
-				// Comments don't end at end of line and the next character may be unstyled.
-				levelNext--;
-			}
-		}
-		else if ((style & 0xf) == SCE_4GL_BLOCK && !isalnum(chNext)) {
-			levelNext++;
-		}
-		else if ((style & 0xf) == SCE_4GL_END  && (ch == 'e' || ch == 'f')) {
-			levelNext--;
-		}
-		if (atEOL) {
-			int levelUse = levelCurrent;
-			if (foldAtElse) {
-				levelUse = levelMinCurrent;
-			}
-			int lev = levelUse | levelNext << 16;
-			if (visibleChars == 0 && foldCompact)
-				lev |= SC_FOLDLEVELWHITEFLAG;
-			if (levelUse < levelNext)
-				lev |= SC_FOLDLEVELHEADERFLAG;
-			if (lev != styler.LevelAt(lineCurrent)) {
-				styler.SetLevel(lineCurrent, lev);
-			}
-			lineCurrent++;
-			levelCurrent = levelNext;
-			levelMinCurrent = levelCurrent;
-			visibleChars = 0;
-		}
-		if (!isspacechar(ch))
-			visibleChars++;
-	}
-}
 
-static void Fold4glDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *[],
-                       Accessor &styler) {
-	FoldNoBox4glDoc(startPos, length, initStyle, styler);
-}
+void SCI_METHOD LexerABL::Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
+
+   if (!options.fold)
+      return;
 
-static const char * const FglWordLists[] = {
-            "Primary keywords and identifiers",
-            "Secondary keywords and identifiers",
-            "Documentation comment keywords",
-            "Unused",
-            "Global classes and typedefs",
-            0,
-        };
+   LexAccessor styler(pAccess);
+
+   Sci_PositionU endPos = startPos + length;
+   int visibleChars = 0;
+   Sci_Position lineCurrent = styler.GetLine(startPos);
+   int levelCurrent = SC_FOLDLEVELBASE;
+   if (lineCurrent > 0)
+      levelCurrent = styler.LevelAt(lineCurrent-1) >> 16;
+   Sci_PositionU lineStartNext = styler.LineStart(lineCurrent+1);
+   int levelNext = levelCurrent;
+   char chNext = styler[startPos];
+   int styleNext = styler.StyleAt(startPos);
+   int style = initStyle;
+   for (Sci_PositionU i = startPos; i < endPos; i++) {
+      chNext = static_cast<char>(tolower(chNext));  // check tolower
+      char ch = chNext;
+      chNext = styler.SafeGetCharAt(i+1);
+      int stylePrev = style;
+      style = styleNext;
+      styleNext = styler.StyleAt(i+1);
+      bool atEOL = i == (lineStartNext-1);
+      if (options.foldComment && options.foldCommentMultiline && IsStreamCommentStyle(style)) {
+         if (!IsStreamCommentStyle(stylePrev)) {
+            levelNext++;
+         } else if (!IsStreamCommentStyle(styleNext) && !atEOL) {
+            // Comments don't end at end of line and the next character may be unstyled.
+            levelNext--;
+         }
+      }
+      if (options.foldSyntaxBased) {
+         if (style == SCE_ABL_BLOCK && !IsAlphaNumeric(chNext)) {
+            levelNext++;
+         }
+         else if (style == SCE_ABL_END  && (ch == 'e' || ch == 'f')) {
+            levelNext--;
+         }
+      }
+      if (!IsASpace(ch))
+         visibleChars++;
+      if (atEOL || (i == endPos-1)) {
+         int lev = levelCurrent | levelNext << 16;
+         if (visibleChars == 0 && options.foldCompact)
+            lev |= SC_FOLDLEVELWHITEFLAG;
+         if (levelCurrent < levelNext)
+            lev |= SC_FOLDLEVELHEADERFLAG;
+         if (lev != styler.LevelAt(lineCurrent)) {
+            styler.SetLevel(lineCurrent, lev);
+         }
+         lineCurrent++;
+         lineStartNext = styler.LineStart(lineCurrent+1);
+         levelCurrent = levelNext;
+         if (atEOL && (i == static_cast<Sci_PositionU>(styler.Length()-1))) {
+            // There is an empty line at end of file so give it same level and empty
+            styler.SetLevel(lineCurrent, (levelCurrent | levelCurrent << 16) | SC_FOLDLEVELWHITEFLAG);
+         }
+         visibleChars = 0;
+      }
+   }
+}
 
-LexerModule lmProgress(SCLEX_PROGRESS, Colourise4glDoc, "progress", Fold4glDoc, FglWordLists);
+LexerModule lmProgress(SCLEX_PROGRESS, LexerABL::LexerFactoryABL, "abl", ablWordLists);
diff --git a/src/stc/scintilla/lexers/LexYAML.cxx b/src/stc/scintilla/lexers/LexYAML.cxx
index 5cd348f..9f28bb8 100644
--- a/src/stc/scintilla/lexers/LexYAML.cxx
+++ b/src/stc/scintilla/lexers/LexYAML.cxx
@@ -46,13 +46,28 @@ static unsigned int SpaceCount(char* lineBuffer) {
 	while (*headBuffer == ' ')
 		headBuffer++;
 
-	return headBuffer - lineBuffer;
+	return static_cast<unsigned int>(headBuffer - lineBuffer);
 }
 
-#define YAML_STATE_BITSIZE 16
+static bool KeywordAtChar(char* lineBuffer, char* startComment, const WordList &keywords) {
+	if (lineBuffer == NULL || startComment <= lineBuffer)
+		return false;
+	char* endValue = startComment - 1;
+	while (endValue >= lineBuffer && *endValue == ' ')
+		endValue--;
+	Sci_PositionU len = static_cast<Sci_PositionU>(endValue - lineBuffer) + 1;
+	char s[100];
+	if (len > (sizeof(s) / sizeof(s[0]) - 1))
+		return false;
+	strncpy(s, lineBuffer, len);
+	s[len] = '\0';
+	return (keywords.InList(s));
+}
+
+#define YAML_STATE_BITSIZE		16
 #define YAML_STATE_MASK			(0xFFFF0000)
 #define YAML_STATE_DOCUMENT		(1 << YAML_STATE_BITSIZE)
-#define YAML_STATE_VALUE			(2 << YAML_STATE_BITSIZE)
+#define YAML_STATE_VALUE		(2 << YAML_STATE_BITSIZE)
 #define YAML_STATE_COMMENT		(3 << YAML_STATE_BITSIZE)
 #define YAML_STATE_TEXT_PARENT	(4 << YAML_STATE_BITSIZE)
 #define YAML_STATE_TEXT			(5 << YAML_STATE_BITSIZE)
@@ -139,27 +154,44 @@ static void ColouriseYAMLLine(
 				styler.ColourTo(endPos, SCE_YAML_COMMENT);
 				return;
 			}
+			Sci_PositionU startComment = i;
+			bInQuotes = false;
+			while (startComment < lengthLine) { // Comment must be space padded
+				if (lineBuffer[startComment] == '\'' || lineBuffer[startComment] == '\"')
+					bInQuotes = !bInQuotes;
+				if (lineBuffer[startComment] == '#' && isspacechar(lineBuffer[startComment - 1]) && !bInQuotes)
+					break;
+				startComment++;
+			}
 			styler.SetLineState(currentLine, YAML_STATE_VALUE);
 			if (lineBuffer[i] == '&' || lineBuffer[i] == '*') {
-				styler.ColourTo(endPos, SCE_YAML_REFERENCE);
+				styler.ColourTo(startLine + startComment - 1, SCE_YAML_REFERENCE);
+				if (startComment < lengthLine)
+					styler.ColourTo(endPos, SCE_YAML_COMMENT);
 				return;
 			}
-			if (keywords.InList(&lineBuffer[i])) { // Convertible value (true/false, etc.)
-				styler.ColourTo(endPos, SCE_YAML_KEYWORD);
+			if (KeywordAtChar(&lineBuffer[i], &lineBuffer[startComment], keywords)) { // Convertible value (true/false, etc.)
+				styler.ColourTo(startLine + startComment - 1, SCE_YAML_KEYWORD);
+				if (startComment < lengthLine)
+					styler.ColourTo(endPos, SCE_YAML_COMMENT);
 				return;
-			} else {
-				Sci_PositionU i2 = i;
-				while ((i < lengthLine) && lineBuffer[i]) {
-					if (!(IsASCII(lineBuffer[i]) && isdigit(lineBuffer[i])) && lineBuffer[i] != '-' && lineBuffer[i] != '.' && lineBuffer[i] != ',') {
-						styler.ColourTo(endPos, SCE_YAML_DEFAULT);
-						return;
-					}
-					i++;
-				}
-				if (i > i2) {
-					styler.ColourTo(endPos, SCE_YAML_NUMBER);
+			}
+			Sci_PositionU i2 = i;
+			while ((i < startComment) && lineBuffer[i]) {
+				if (!(IsASCII(lineBuffer[i]) && isdigit(lineBuffer[i])) && lineBuffer[i] != '-'
+				        && lineBuffer[i] != '.' && lineBuffer[i] != ',' && lineBuffer[i] != ' ') {
+					styler.ColourTo(startLine + startComment - 1, SCE_YAML_DEFAULT);
+					if (startComment < lengthLine)
+						styler.ColourTo(endPos, SCE_YAML_COMMENT);
 					return;
 				}
+				i++;
+			}
+			if (i > i2) {
+				styler.ColourTo(startLine + startComment - 1, SCE_YAML_NUMBER);
+				if (startComment < lengthLine)
+					styler.ColourTo(endPos, SCE_YAML_COMMENT);
+				return;
 			}
 			break; // shouldn't get here, but just in case, the rest of the line is coloured the default
 		}
@@ -241,7 +273,7 @@ static void FoldYAMLDoc(Sci_PositionU startPos, Sci_Position length, int /*initS
 		if (lineNext <= docLines) {
 			// Information about next line is only available if not at end of document
 			indentNext = styler.IndentAmount(lineNext, &spaceFlags, NULL);
-	}
+		}
 		const int comment = foldComment && IsCommentLine(lineCurrent, styler);
 		const int comment_start = (comment && !prevComment && (lineNext <= docLines) &&
 		                           IsCommentLine(lineNext, styler) && (lev > SC_FOLDLEVELBASE));
diff --git a/src/stc/scintilla/lexlib/CharacterSet.cxx b/src/stc/scintilla/lexlib/CharacterSet.cxx
index 0ab2cc0..55602af 100644
--- a/src/stc/scintilla/lexlib/CharacterSet.cxx
+++ b/src/stc/scintilla/lexlib/CharacterSet.cxx
@@ -25,8 +25,8 @@ namespace Scintilla {
 int CompareCaseInsensitive(const char *a, const char *b) {
 	while (*a && *b) {
 		if (*a != *b) {
-			char upperA = MakeUpperCase(*a);
-			char upperB = MakeUpperCase(*b);
+			char upperA = static_cast<char>(MakeUpperCase(*a));
+			char upperB = static_cast<char>(MakeUpperCase(*b));
 			if (upperA != upperB)
 				return upperA - upperB;
 		}
@@ -40,8 +40,8 @@ int CompareCaseInsensitive(const char *a, const char *b) {
 int CompareNCaseInsensitive(const char *a, const char *b, size_t len) {
 	while (*a && *b && len) {
 		if (*a != *b) {
-			char upperA = MakeUpperCase(*a);
-			char upperB = MakeUpperCase(*b);
+			char upperA = static_cast<char>(MakeUpperCase(*a));
+			char upperB = static_cast<char>(MakeUpperCase(*b));
 			if (upperA != upperB)
 				return upperA - upperB;
 		}
diff --git a/src/stc/scintilla/lexlib/CharacterSet.h b/src/stc/scintilla/lexlib/CharacterSet.h
index a0c45b2..183fbe4 100644
--- a/src/stc/scintilla/lexlib/CharacterSet.h
+++ b/src/stc/scintilla/lexlib/CharacterSet.h
@@ -160,13 +160,20 @@ inline bool isoperator(int ch) {
 
 // Simple case functions for ASCII.
 
-inline char MakeUpperCase(char ch) {
+inline int MakeUpperCase(int ch) {
 	if (ch < 'a' || ch > 'z')
 		return ch;
 	else
 		return static_cast<char>(ch - 'a' + 'A');
 }
 
+inline int MakeLowerCase(int ch) {
+	if (ch < 'A' || ch > 'Z')
+		return ch;
+	else
+		return ch - 'A' + 'a';
+}
+
 int CompareCaseInsensitive(const char *a, const char *b);
 int CompareNCaseInsensitive(const char *a, const char *b, size_t len);
 
diff --git a/src/stc/scintilla/lexlib/LexerModule.h b/src/stc/scintilla/lexlib/LexerModule.h
index 356ff27..a561cf1 100644
--- a/src/stc/scintilla/lexlib/LexerModule.h
+++ b/src/stc/scintilla/lexlib/LexerModule.h
@@ -67,7 +67,7 @@ inline int Maximum(int a, int b) {
 
 // Shut up annoying Visual C++ warnings:
 #ifdef _MSC_VER
-#pragma warning(disable: 4244 4309 4456 4457)
+#pragma warning(disable: 4244 4456 4457)
 #endif
 
 // Turn off shadow warnings for lexers as may be maintained by others
diff --git a/src/stc/scintilla/lexlib/StyleContext.cxx b/src/stc/scintilla/lexlib/StyleContext.cxx
index 5bcacb0..f9f15be 100644
--- a/src/stc/scintilla/lexlib/StyleContext.cxx
+++ b/src/stc/scintilla/lexlib/StyleContext.cxx
@@ -16,11 +16,28 @@
 #include "LexAccessor.h"
 #include "Accessor.h"
 #include "StyleContext.h"
+#include "CharacterSet.h"
 
 #ifdef SCI_NAMESPACE
 using namespace Scintilla;
 #endif
 
+bool StyleContext::MatchIgnoreCase(const char *s) {
+	if (MakeLowerCase(ch) != static_cast<unsigned char>(*s))
+		return false;
+	s++;
+	if (MakeLowerCase(chNext) != static_cast<unsigned char>(*s))
+		return false;
+	s++;
+	for (int n = 2; *s; n++) {
+		if (static_cast<unsigned char>(*s) !=
+			MakeLowerCase(static_cast<unsigned char>(styler.SafeGetCharAt(currentPos + n, 0))))
+			return false;
+		s++;
+	}
+	return true;
+}
+
 static void getRange(Sci_PositionU start,
 		Sci_PositionU end,
 		LexAccessor &styler,
diff --git a/src/stc/scintilla/lexlib/StyleContext.h b/src/stc/scintilla/lexlib/StyleContext.h
index c8aa4ab..6cbda35 100644
--- a/src/stc/scintilla/lexlib/StyleContext.h
+++ b/src/stc/scintilla/lexlib/StyleContext.h
@@ -12,13 +12,6 @@
 namespace Scintilla {
 #endif
 
-static inline int MakeLowerCase(int ch) {
-	if (ch < 'A' || ch > 'Z')
-		return ch;
-	else
-		return ch - 'A' + 'a';
-}
-
 // All languages handled so far can treat all characters >= 0x80 as one class
 // which just continues the current token or starts an identifier if in default.
 // DBCS treated specially as the second character can be < 0x80 and hence
@@ -204,22 +197,8 @@ public:
 		}
 		return true;
 	}
-	bool MatchIgnoreCase(const char *s) {
-		if (MakeLowerCase(ch) != static_cast<unsigned char>(*s))
-			return false;
-		s++;
-		if (MakeLowerCase(chNext) != static_cast<unsigned char>(*s))
-			return false;
-		s++;
-		for (int n=2; *s; n++) {
-			if (static_cast<unsigned char>(*s) !=
-				MakeLowerCase(static_cast<unsigned char>(styler.SafeGetCharAt(currentPos+n, 0))))
-				return false;
-			s++;
-		}
-		return true;
-	}
 	// Non-inline
+	bool MatchIgnoreCase(const char *s);
 	void GetCurrent(char *s, Sci_PositionU len);
 	void GetCurrentLowered(char *s, Sci_PositionU len);
 };
diff --git a/src/stc/scintilla/lexlib/WordList.cxx b/src/stc/scintilla/lexlib/WordList.cxx
index 63d2233..b866291 100644
--- a/src/stc/scintilla/lexlib/WordList.cxx
+++ b/src/stc/scintilla/lexlib/WordList.cxx
@@ -236,6 +236,66 @@ bool WordList::InListAbbreviated(const char *s, const char marker) const {
 	return false;
 }
 
+/** similar to InListAbbreviated, but word s can be a abridged version of a keyword.
+* eg. the keyword is defined as "after.~:". This means the word must have a prefix (begins with) of
+* "after." and suffix (ends with) of ":" to be a keyword, Hence "after.field:" , "after.form.item:" are valid.
+* Similarly "~.is.valid" keyword is suffix only... hence "field.is.valid" , "form.is.valid" are valid.
+* The marker is ~ in this case.
+* No multiple markers check is done and wont work.
+*/
+bool WordList::InListAbridged(const char *s, const char marker) const {
+	if (0 == words)
+		return false;
+	unsigned char firstChar = s[0];
+	int j = starts[firstChar];
+	if (j >= 0) {
+		while (static_cast<unsigned char>(words[j][0]) == firstChar) {
+			const char *a = words[j];
+			const char *b = s;
+			while (*a && *a == *b) {
+				a++;
+				if (*a == marker) {
+					a++;
+					const size_t suffixLengthA = strlen(a);
+					const size_t suffixLengthB = strlen(b);
+					if (suffixLengthA >= suffixLengthB)
+						break;
+					b = b + suffixLengthB - suffixLengthA - 1;
+				}
+				b++;
+			}
+			if (!*a  && !*b)
+				return true;
+			j++;
+		}
+	}
+
+	j = starts[static_cast<unsigned int>(marker)];
+	if (j >= 0) {
+		while (words[j][0] == marker) {
+			const char *a = words[j] + 1;
+			const char *b = s;
+			const size_t suffixLengthA = strlen(a);
+			const size_t suffixLengthB = strlen(b);
+			if (suffixLengthA > suffixLengthB) {
+				j++;
+				continue;
+			}
+			b = b + suffixLengthB - suffixLengthA;
+
+			while (*a && *a == *b) {
+				a++;
+				b++;
+			}
+			if (!*a && !*b)
+				return true;
+			j++;
+		}
+	}
+
+	return false;
+}
+
 const char *WordList::WordAt(int n) const {
 	return words[n];
 }
diff --git a/src/stc/scintilla/lexlib/WordList.h b/src/stc/scintilla/lexlib/WordList.h
index 382be28..b1f8c85 100644
--- a/src/stc/scintilla/lexlib/WordList.h
+++ b/src/stc/scintilla/lexlib/WordList.h
@@ -31,6 +31,7 @@ public:
 	void Set(const char *s);
 	bool InList(const char *s) const;
 	bool InListAbbreviated(const char *s, const char marker) const;
+	bool InListAbridged(const char *s, const char marker) const;
 	const char *WordAt(int n) const;
 };
 
diff --git a/src/stc/scintilla/src/CaseConvert.cxx b/src/stc/scintilla/src/CaseConvert.cxx
index 63a2722..4fb7559 100644
--- a/src/stc/scintilla/src/CaseConvert.cxx
+++ b/src/stc/scintilla/src/CaseConvert.cxx
@@ -11,6 +11,7 @@
 #include <cstring>
 
 #include <stdexcept>
+#include <string>
 #include <vector>
 #include <algorithm>
 
@@ -630,6 +631,14 @@ size_t CaseConvertString(char *converted, size_t sizeConverted, const char *mixe
 	return pCaseConv->CaseConvertString(converted, sizeConverted, mixed, lenMixed);
 }
 
+std::string CaseConvertString(const std::string &s, enum CaseConversion conversion) {
+	std::string retMapped(s.length() * maxExpansionCaseConversion, 0);
+	size_t lenMapped = CaseConvertString(&retMapped[0], retMapped.length(), s.c_str(), s.length(),
+		conversion);
+	retMapped.resize(lenMapped);
+	return retMapped;
+}
+
 #ifdef SCI_NAMESPACE
 }
 #endif
diff --git a/src/stc/scintilla/src/CaseConvert.h b/src/stc/scintilla/src/CaseConvert.h
index 60de227..7a01003 100644
--- a/src/stc/scintilla/src/CaseConvert.h
+++ b/src/stc/scintilla/src/CaseConvert.h
@@ -40,6 +40,9 @@ const int maxExpansionCaseConversion=3;
 // If there is not enough space then 0 is returned.
 size_t CaseConvertString(char *converted, size_t sizeConverted, const char *mixed, size_t lenMixed, enum CaseConversion conversion);
 
+// Converts a mixed case string using a particular conversion.
+std::string CaseConvertString(const std::string &s, enum CaseConversion conversion);
+
 #ifdef SCI_NAMESPACE
 }
 #endif
diff --git a/src/stc/scintilla/src/Catalogue.cxx b/src/stc/scintilla/src/Catalogue.cxx
index e6aa258..2eadd95 100644
--- a/src/stc/scintilla/src/Catalogue.cxx
+++ b/src/stc/scintilla/src/Catalogue.cxx
@@ -110,6 +110,7 @@ int Scintilla_LinkLexers() {
 	LINK_LEXER(lmDMAP);
 	LINK_LEXER(lmDMIS);
 	LINK_LEXER(lmECL);
+	LINK_LEXER(lmEDIFACT);
 	LINK_LEXER(lmEiffel);
 	LINK_LEXER(lmEiffelkw);
 	LINK_LEXER(lmErlang);
diff --git a/src/stc/scintilla/src/CellBuffer.h b/src/stc/scintilla/src/CellBuffer.h
index 1c53d14..c1e973c 100644
--- a/src/stc/scintilla/src/CellBuffer.h
+++ b/src/stc/scintilla/src/CellBuffer.h
@@ -47,22 +47,6 @@ public:
 	int LineStart(int line) const {
 		return starts.PositionFromPartition(line);
 	}
-
-	int MarkValue(int line);
-	int AddMark(int line, int marker);
-	void MergeMarkers(int pos);
-	void DeleteMark(int line, int markerNum, bool all);
-	void DeleteMarkFromHandle(int markerHandle);
-	int LineFromHandle(int markerHandle);
-
-	void ClearLevels();
-	int SetLevel(int line, int level);
-	int GetLevel(int line);
-
-	int SetLineState(int line, int state);
-	int GetLineState(int line);
-	int GetMaxLineState();
-
 };
 
 enum actionType { insertAction, removeAction, startAction, containerAction };
diff --git a/src/stc/scintilla/src/CharClassify.cxx b/src/stc/scintilla/src/CharClassify.cxx
index 595b0da..8678e6d 100644
--- a/src/stc/scintilla/src/CharClassify.cxx
+++ b/src/stc/scintilla/src/CharClassify.cxx
@@ -44,7 +44,7 @@ void CharClassify::SetCharClasses(const unsigned char *chars, cc newCharClass) {
 	}
 }
 
-int CharClassify::GetCharsOfClass(cc characterClass, unsigned char *buffer) {
+int CharClassify::GetCharsOfClass(cc characterClass, unsigned char *buffer) const {
 	// Get characters belonging to the given char class; return the number
 	// of characters (if the buffer is NULL, don't write to it).
 	int count = 0;
diff --git a/src/stc/scintilla/src/CharClassify.h b/src/stc/scintilla/src/CharClassify.h
index 5d2734c..63e8e8b 100644
--- a/src/stc/scintilla/src/CharClassify.h
+++ b/src/stc/scintilla/src/CharClassify.h
@@ -19,7 +19,7 @@ public:
 	enum cc { ccSpace, ccNewLine, ccWord, ccPunctuation };
 	void SetDefaultCharClasses(bool includeWordClass);
 	void SetCharClasses(const unsigned char *chars, cc newCharClass);
-	int GetCharsOfClass(cc charClass, unsigned char *buffer);
+	int GetCharsOfClass(cc charClass, unsigned char *buffer) const;
 	cc GetClass(unsigned char ch) const { return static_cast<cc>(charClass[ch]);}
 	bool IsWord(unsigned char ch) const { return static_cast<cc>(charClass[ch]) == ccWord;}
 
diff --git a/src/stc/scintilla/src/ContractionState.cxx b/src/stc/scintilla/src/ContractionState.cxx
index 80f79de..41627c1 100644
--- a/src/stc/scintilla/src/ContractionState.cxx
+++ b/src/stc/scintilla/src/ContractionState.cxx
@@ -6,6 +6,7 @@
 // The License.txt file describes the conditions under which this software may be distributed.
 
 #include <string.h>
+#include <assert.h>
 
 #include <stdexcept>
 #include <algorithm>
@@ -16,13 +17,14 @@
 #include "SplitVector.h"
 #include "Partitioning.h"
 #include "RunStyles.h"
+#include "SparseVector.h"
 #include "ContractionState.h"
 
 #ifdef SCI_NAMESPACE
 using namespace Scintilla;
 #endif
 
-ContractionState::ContractionState() : visible(0), expanded(0), heights(0), displayLines(0), linesInDocument(1) {
+ContractionState::ContractionState() : visible(0), expanded(0), heights(0), foldDisplayTexts(0), displayLines(0), linesInDocument(1) {
 	//InsertLine(0);
 }
 
@@ -35,6 +37,7 @@ void ContractionState::EnsureData() {
 		visible = new RunStyles();
 		expanded = new RunStyles();
 		heights = new RunStyles();
+		foldDisplayTexts = new SparseVector<const char *>();
 		displayLines = new Partitioning(4);
 		InsertLines(0, linesInDocument);
 	}
@@ -47,6 +50,8 @@ void ContractionState::Clear() {
 	expanded = 0;
 	delete heights;
 	heights = 0;
+	delete foldDisplayTexts;
+	foldDisplayTexts = 0;
 	delete displayLines;
 	displayLines = 0;
 	linesInDocument = 1;
@@ -108,6 +113,8 @@ void ContractionState::InsertLine(int lineDoc) {
 		expanded->SetValueAt(lineDoc, 1);
 		heights->InsertSpace(lineDoc, 1);
 		heights->SetValueAt(lineDoc, 1);
+		foldDisplayTexts->InsertSpace(lineDoc, 1);
+		foldDisplayTexts->SetValueAt(lineDoc, NULL);
 		int lineDisplay = DisplayFromDoc(lineDoc);
 		displayLines->InsertPartition(lineDoc, lineDisplay);
 		displayLines->InsertText(lineDoc, 1);
@@ -132,6 +139,7 @@ void ContractionState::DeleteLine(int lineDoc) {
 		visible->DeleteRange(lineDoc, 1);
 		expanded->DeleteRange(lineDoc, 1);
 		heights->DeleteRange(lineDoc, 1);
+		foldDisplayTexts->DeletePosition(lineDoc);
 	}
 }
 
@@ -184,6 +192,24 @@ bool ContractionState::HiddenLines() const {
 	}
 }
 
+const char *ContractionState::GetFoldDisplayText(int lineDoc) const {
+	Check();
+	return foldDisplayTexts->ValueAt(lineDoc);
+}
+
+bool ContractionState::SetFoldDisplayText(int lineDoc, const char *text) {
+	EnsureData();
+	const char *foldText = foldDisplayTexts->ValueAt(lineDoc);
+	if (!foldText || 0 != strcmp(text, foldText)) {
+		foldDisplayTexts->SetValueAt(lineDoc, text);
+		Check();
+		return true;
+	} else {
+		Check();
+		return false;
+	}
+}
+
 bool ContractionState::GetExpanded(int lineDoc) const {
 	if (OneToOne()) {
 		return true;
@@ -209,6 +235,10 @@ bool ContractionState::SetExpanded(int lineDoc, bool isExpanded) {
 	}
 }
 
+bool ContractionState::GetFoldDisplayTextShown(int lineDoc) const {
+	return !GetExpanded(lineDoc) && GetFoldDisplayText(lineDoc);
+}
+
 int ContractionState::ContractedNext(int lineDocStart) const {
 	if (OneToOne()) {
 		return -1;
diff --git a/src/stc/scintilla/src/ContractionState.h b/src/stc/scintilla/src/ContractionState.h
index 96cbf07..6226969 100644
--- a/src/stc/scintilla/src/ContractionState.h
+++ b/src/stc/scintilla/src/ContractionState.h
@@ -12,6 +12,9 @@
 namespace Scintilla {
 #endif
 
+template<class T>
+class SparseVector;
+
 /**
  */
 class ContractionState {
@@ -19,6 +22,7 @@ class ContractionState {
 	RunStyles *visible;
 	RunStyles *expanded;
 	RunStyles *heights;
+	SparseVector<const char *> *foldDisplayTexts;
 	Partitioning *displayLines;
 	int linesInDocument;
 
@@ -51,8 +55,12 @@ public:
 	bool SetVisible(int lineDocStart, int lineDocEnd, bool isVisible);
 	bool HiddenLines() const;
 
+	const char *GetFoldDisplayText(int lineDoc) const;
+	bool SetFoldDisplayText(int lineDoc, const char *text);
+
 	bool GetExpanded(int lineDoc) const;
 	bool SetExpanded(int lineDoc, bool isExpanded);
+	bool GetFoldDisplayTextShown(int lineDoc) const;
 	int ContractedNext(int lineDocStart) const;
 
 	int GetHeight(int lineDoc) const;
diff --git a/src/stc/scintilla/src/Document.cxx b/src/stc/scintilla/src/Document.cxx
index d96a889..c105bdd 100644
--- a/src/stc/scintilla/src/Document.cxx
+++ b/src/stc/scintilla/src/Document.cxx
@@ -16,8 +16,16 @@
 #include <vector>
 #include <algorithm>
 
+#define NOEXCEPT
+
 #ifndef NO_CXX11_REGEX
 #include <regex>
+#if defined(__GLIBCXX__)
+// If using the GNU implementation of <regex> then have 'noexcept' so can use
+// when defining regex iterators to keep Clang analyze happy.
+#undef NOEXCEPT
+#define NOEXCEPT noexcept
+#endif
 #endif
 
 #include "Platform.h"
@@ -26,6 +34,7 @@
 #include "Scintilla.h"
 
 #include "CharacterSet.h"
+#include "CharacterCategory.h"
 #include "Position.h"
 #include "SplitVector.h"
 #include "Partitioning.h"
@@ -44,10 +53,6 @@
 using namespace Scintilla;
 #endif
 
-static inline bool IsPunctuation(char ch) {
-	return IsASCII(ch) && ispunct(ch);
-}
-
 void LexInterface::Colourise(int start, int end) {
 	if (pdoc && instance && !performingStyle) {
 		// Protect against reentrance, which may occur, for example, when
@@ -771,6 +776,77 @@ bool Document::NextCharacter(int &pos, int moveDir) const {
 	}
 }
 
+Document::CharacterExtracted Document::CharacterAfter(int position) const {
+	if (position >= Length()) {
+		return CharacterExtracted(unicodeReplacementChar, 0);
+	}
+	const unsigned char leadByte = static_cast<unsigned char>(cb.CharAt(position));
+	if (!dbcsCodePage || UTF8IsAscii(leadByte)) {
+		// Common case: ASCII character
+		return CharacterExtracted(leadByte, 1);
+	}
+	if (SC_CP_UTF8 == dbcsCodePage) {
+		const int widthCharBytes = UTF8BytesOfLead[leadByte];
+		unsigned char charBytes[UTF8MaxBytes] = { leadByte, 0, 0, 0 };
+		for (int b = 1; b<widthCharBytes; b++)
+			charBytes[b] = static_cast<unsigned char>(cb.CharAt(position + b));
+		int utf8status = UTF8Classify(charBytes, widthCharBytes);
+		if (utf8status & UTF8MaskInvalid) {
+			// Treat as invalid and use up just one byte
+			return CharacterExtracted(unicodeReplacementChar, 1);
+		} else {
+			return CharacterExtracted(UnicodeFromUTF8(charBytes), utf8status & UTF8MaskWidth);
+		}
+	} else {
+		if (IsDBCSLeadByte(leadByte) && ((position + 1) < Length())) {
+			return CharacterExtracted::DBCS(leadByte, static_cast<unsigned char>(cb.CharAt(position + 1)));
+		} else {
+			return CharacterExtracted(leadByte, 1);
+		}
+	}
+}
+
+Document::CharacterExtracted Document::CharacterBefore(int position) const {
+	if (position <= 0) {
+		return CharacterExtracted(unicodeReplacementChar, 0);
+	}
+	const unsigned char previousByte = static_cast<unsigned char>(cb.CharAt(position - 1));
+	if (0 == dbcsCodePage) {
+		return CharacterExtracted(previousByte, 1);
+	}
+	if (SC_CP_UTF8 == dbcsCodePage) {
+		if (UTF8IsAscii(previousByte)) {
+			return CharacterExtracted(previousByte, 1);
+		}
+		position--;
+		// If previousByte is not a trail byte then its invalid
+		if (UTF8IsTrailByte(previousByte)) {
+			// If previousByte is a trail byte in a valid UTF-8 character then find start of character
+			int startUTF = position;
+			int endUTF = position;
+			if (InGoodUTF8(position, startUTF, endUTF)) {
+				const int widthCharBytes = endUTF - startUTF;
+				unsigned char charBytes[UTF8MaxBytes] = { 0, 0, 0, 0 };
+				for (int b = 0; b<widthCharBytes; b++)
+					charBytes[b] = static_cast<unsigned char>(cb.CharAt(startUTF + b));
+				int utf8status = UTF8Classify(charBytes, widthCharBytes);
+				if (utf8status & UTF8MaskInvalid) {
+					// Treat as invalid and use up just one byte
+					return CharacterExtracted(unicodeReplacementChar, 1);
+				} else {
+					return CharacterExtracted(UnicodeFromUTF8(charBytes), utf8status & UTF8MaskWidth);
+				}
+			}
+			// Else invalid UTF-8 so return position of isolated trail byte
+		}
+		return CharacterExtracted(unicodeReplacementChar, 1);
+	} else {
+		// Moving backwards in DBCS is complex so use NextPosition
+		const int posStartCharacter = NextPosition(position, -1);
+		return CharacterAfter(posStartCharacter);
+	}
+}
+
 // Return -1  on out-of-bounds
 Sci_Position SCI_METHOD Document::GetRelativePosition(Sci_Position positionStart, Sci_Position characterOffset) const {
 	int pos = positionStart;
@@ -1485,28 +1561,104 @@ int Document::ParaDown(int pos) const {
 		return LineEnd(line-1);
 }
 
-CharClassify::cc Document::WordCharClass(unsigned char ch) const {
-	if ((SC_CP_UTF8 == dbcsCodePage) && (!UTF8IsAscii(ch)))
-		return CharClassify::ccWord;
-	return charClass.GetClass(ch);
+bool Document::IsASCIIWordByte(unsigned char ch) const {
+	if (IsASCII(ch)) {
+		return charClass.GetClass(ch) == CharClassify::ccWord;
+	} else {
+		return false;
+	}
+}
+
+CharClassify::cc Document::WordCharacterClass(unsigned int ch) const {
+	if (dbcsCodePage && (!UTF8IsAscii(ch))) {
+		if (SC_CP_UTF8 == dbcsCodePage) {
+			// Use hard coded Unicode class
+			const CharacterCategory cc = CategoriseCharacter(ch);
+			switch (cc) {
+
+				// Separator, Line/Paragraph
+			case ccZl:
+			case ccZp:
+				return CharClassify::ccNewLine;
+
+				// Separator, Space
+			case ccZs:
+				// Other
+			case ccCc:
+			case ccCf:
+			case ccCs:
+			case ccCo:
+			case ccCn:
+				return CharClassify::ccSpace;
+
+				// Letter
+			case ccLu:
+			case ccLl:
+			case ccLt:
+			case ccLm:
+			case ccLo:
+				// Number
+			case ccNd:
+			case ccNl:
+			case ccNo:
+				// Mark - includes combining diacritics
+			case ccMn:
+			case ccMc:
+			case ccMe:
+				return CharClassify::ccWord;
+
+				// Punctuation
+			case ccPc:
+			case ccPd:
+			case ccPs:
+			case ccPe:
+			case ccPi:
+			case ccPf:
+			case ccPo:
+				// Symbol
+			case ccSm:
+			case ccSc:
+			case ccSk:
+			case ccSo:
+				return CharClassify::ccPunctuation;
+
+			}
+		} else {
+			// Asian DBCS
+			return CharClassify::ccWord;
+		}
+	}
+	return charClass.GetClass(static_cast<unsigned char>(ch));
 }
 
 /**
  * Used by commmands that want to select whole words.
  * Finds the start of word at pos when delta < 0 or the end of the word when delta >= 0.
  */
-int Document::ExtendWordSelect(int pos, int delta, bool onlyWordCharacters) {
+int Document::ExtendWordSelect(int pos, int delta, bool onlyWordCharacters) const {
 	CharClassify::cc ccStart = CharClassify::ccWord;
 	if (delta < 0) {
-		if (!onlyWordCharacters)
-			ccStart = WordCharClass(cb.CharAt(pos-1));
-		while (pos > 0 && (WordCharClass(cb.CharAt(pos - 1)) == ccStart))
-			pos--;
+		if (!onlyWordCharacters) {
+			const CharacterExtracted ce = CharacterBefore(pos);
+			ccStart = WordCharacterClass(ce.character);
+		}
+		while (pos > 0) {
+			const CharacterExtracted ce = CharacterBefore(pos);
+			if (WordCharacterClass(ce.character) != ccStart)
+				break;
+			pos -= ce.widthBytes;
+		}
 	} else {
-		if (!onlyWordCharacters && pos < Length())
-			ccStart = WordCharClass(cb.CharAt(pos));
-		while (pos < (Length()) && (WordCharClass(cb.CharAt(pos)) == ccStart))
-			pos++;
+		if (!onlyWordCharacters && pos < Length()) {
+			const CharacterExtracted ce = CharacterAfter(pos);
+			ccStart = WordCharacterClass(ce.character);
+		}
+		while (pos < Length()) {
+			const CharacterExtracted ce = CharacterAfter(pos);
+			if (WordCharacterClass(ce.character) != ccStart)
+				break;
+			pos += ce.widthBytes;
+		}
 	}
 	return MovePositionOutsideChar(pos, delta, true);
 }
@@ -1518,22 +1670,39 @@ int Document::ExtendWordSelect(int pos, int delta, bool onlyWordCharacters) {
  * additional movement to transit white space.
  * Used by cursor movement by word commands.
  */
-int Document::NextWordStart(int pos, int delta) {
+int Document::NextWordStart(int pos, int delta) const {
 	if (delta < 0) {
-		while (pos > 0 && (WordCharClass(cb.CharAt(pos - 1)) == CharClassify::ccSpace))
-			pos--;
+		while (pos > 0) {
+			const CharacterExtracted ce = CharacterBefore(pos);
+			if (WordCharacterClass(ce.character) != CharClassify::ccSpace)
+				break;
+			pos -= ce.widthBytes;
+		}
 		if (pos > 0) {
-			CharClassify::cc ccStart = WordCharClass(cb.CharAt(pos-1));
-			while (pos > 0 && (WordCharClass(cb.CharAt(pos - 1)) == ccStart)) {
-				pos--;
+			CharacterExtracted ce = CharacterBefore(pos);
+			const CharClassify::cc ccStart = WordCharacterClass(ce.character);
+			while (pos > 0) {
+				ce = CharacterBefore(pos);
+				if (WordCharacterClass(ce.character) != ccStart)
+					break;
+				pos -= ce.widthBytes;
 			}
 		}
 	} else {
-		CharClassify::cc ccStart = WordCharClass(cb.CharAt(pos));
-		while (pos < (Length()) && (WordCharClass(cb.CharAt(pos)) == ccStart))
-			pos++;
-		while (pos < (Length()) && (WordCharClass(cb.CharAt(pos)) == CharClassify::ccSpace))
-			pos++;
+		CharacterExtracted ce = CharacterAfter(pos);
+		const CharClassify::cc ccStart = WordCharacterClass(ce.character);
+		while (pos < Length()) {
+			ce = CharacterAfter(pos);
+			if (WordCharacterClass(ce.character) != ccStart)
+				break;
+			pos += ce.widthBytes;
+		}
+		while (pos < Length()) {
+			ce = CharacterAfter(pos);
+			if (WordCharacterClass(ce.character) != CharClassify::ccSpace)
+				break;
+			pos += ce.widthBytes;
+		}
 	}
 	return pos;
 }
@@ -1545,27 +1714,41 @@ int Document::NextWordStart(int pos, int delta) {
  * additional movement to transit white space.
  * Used by cursor movement by word commands.
  */
-int Document::NextWordEnd(int pos, int delta) {
+int Document::NextWordEnd(int pos, int delta) const {
 	if (delta < 0) {
 		if (pos > 0) {
-			CharClassify::cc ccStart = WordCharClass(cb.CharAt(pos-1));
+			CharacterExtracted ce = CharacterBefore(pos);
+			CharClassify::cc ccStart = WordCharacterClass(ce.character);
 			if (ccStart != CharClassify::ccSpace) {
-				while (pos > 0 && WordCharClass(cb.CharAt(pos - 1)) == ccStart) {
-					pos--;
+				while (pos > 0) {
+					ce = CharacterBefore(pos);
+					if (WordCharacterClass(ce.character) != ccStart)
+						break;
+					pos -= ce.widthBytes;
 				}
 			}
-			while (pos > 0 && WordCharClass(cb.CharAt(pos - 1)) == CharClassify::ccSpace) {
-				pos--;
+			while (pos > 0) {
+				ce = CharacterBefore(pos);
+				if (WordCharacterClass(ce.character) != CharClassify::ccSpace)
+					break;
+				pos -= ce.widthBytes;
 			}
 		}
 	} else {
-		while (pos < Length() && WordCharClass(cb.CharAt(pos)) == CharClassify::ccSpace) {
-			pos++;
+		while (pos < Length()) {
+			CharacterExtracted ce = CharacterAfter(pos);
+			if (WordCharacterClass(ce.character) != CharClassify::ccSpace)
+				break;
+			pos += ce.widthBytes;
 		}
 		if (pos < Length()) {
-			CharClassify::cc ccStart = WordCharClass(cb.CharAt(pos));
-			while (pos < Length() && WordCharClass(cb.CharAt(pos)) == ccStart) {
-				pos++;
+			CharacterExtracted ce = CharacterAfter(pos);
+			CharClassify::cc ccStart = WordCharacterClass(ce.character);
+			while (pos < Length()) {
+				ce = CharacterAfter(pos);
+				if (WordCharacterClass(ce.character) != ccStart)
+					break;
+				pos += ce.widthBytes;
 			}
 		}
 	}
@@ -1577,10 +1760,15 @@ int Document::NextWordEnd(int pos, int delta) {
  * the previous character is of a different character class.
  */
 bool Document::IsWordStartAt(int pos) const {
+	if (pos >= Length())
+		return false;
 	if (pos > 0) {
-		CharClassify::cc ccPos = WordCharClass(CharAt(pos));
+		const CharacterExtracted cePos = CharacterAfter(pos);
+		const CharClassify::cc ccPos = WordCharacterClass(cePos.character);
+		const CharacterExtracted cePrev = CharacterBefore(pos);
+		const CharClassify::cc ccPrev = WordCharacterClass(cePrev.character);
 		return (ccPos == CharClassify::ccWord || ccPos == CharClassify::ccPunctuation) &&
-			(ccPos != WordCharClass(CharAt(pos - 1)));
+			(ccPos != ccPrev);
 	}
 	return true;
 }
@@ -1590,10 +1778,15 @@ bool Document::IsWordStartAt(int pos) const {
  * the next character is of a different character class.
  */
 bool Document::IsWordEndAt(int pos) const {
+	if (pos <= 0)
+		return false;
 	if (pos < Length()) {
-		CharClassify::cc ccPrev = WordCharClass(CharAt(pos-1));
+		const CharacterExtracted cePos = CharacterAfter(pos);
+		const CharClassify::cc ccPos = WordCharacterClass(cePos.character);
+		const CharacterExtracted cePrev = CharacterBefore(pos);
+		const CharClassify::cc ccPrev = WordCharacterClass(cePrev.character);
 		return (ccPrev == CharClassify::ccWord || ccPrev == CharClassify::ccPunctuation) &&
-			(ccPrev != WordCharClass(CharAt(pos)));
+			(ccPrev != ccPos);
 	}
 	return true;
 }
@@ -1823,7 +2016,7 @@ void Document::SetCharClasses(const unsigned char *chars, CharClassify::cc newCh
     charClass.SetCharClasses(chars, newCharClass);
 }
 
-int Document::GetCharsOfClass(CharClassify::cc characterClass, unsigned char *buffer) {
+int Document::GetCharsOfClass(CharClassify::cc characterClass, unsigned char *buffer) const {
     return charClass.GetCharsOfClass(characterClass, buffer);
 }
 
@@ -2075,96 +2268,137 @@ void Document::NotifyModified(DocModification mh) {
 	}
 }
 
-bool Document::IsWordPartSeparator(char ch) const {
-	return (WordCharClass(ch) == CharClassify::ccWord) && IsPunctuation(ch);
+// Used for word part navigation.
+static bool IsASCIIPunctuationCharacter(unsigned int ch) {
+	switch (ch) {
+	case '!':
+	case '"':
+	case '#':
+	case '$':
+	case '%':
+	case '&':
+	case '\'':
+	case '(':
+	case ')':
+	case '*':
+	case '+':
+	case ',':
+	case '-':
+	case '.':
+	case '/':
+	case ':':
+	case ';':
+	case '<':
+	case '=':
+	case '>':
+	case '?':
+	case '@':
+	case '[':
+	case '\\':
+	case ']':
+	case '^':
+	case '_':
+	case '`':
+	case '{':
+	case '|':
+	case '}':
+	case '~':
+		return true;
+	default:
+		return false;
+	}
 }
 
-int Document::WordPartLeft(int pos) {
+bool Document::IsWordPartSeparator(unsigned int ch) const {
+	return (WordCharacterClass(ch) == CharClassify::ccWord) && IsASCIIPunctuationCharacter(ch);
+}
+
+int Document::WordPartLeft(int pos) const {
 	if (pos > 0) {
-		--pos;
-		char startChar = cb.CharAt(pos);
-		if (IsWordPartSeparator(startChar)) {
-			while (pos > 0 && IsWordPartSeparator(cb.CharAt(pos))) {
-				--pos;
+		pos -= CharacterBefore(pos).widthBytes;
+		CharacterExtracted ceStart = CharacterAfter(pos);
+		if (IsWordPartSeparator(ceStart.character)) {
+			while (pos > 0 && IsWordPartSeparator(CharacterAfter(pos).character)) {
+				pos -= CharacterBefore(pos).widthBytes;
 			}
 		}
 		if (pos > 0) {
-			startChar = cb.CharAt(pos);
-			--pos;
-			if (IsLowerCase(startChar)) {
-				while (pos > 0 && IsLowerCase(cb.CharAt(pos)))
-					--pos;
-				if (!IsUpperCase(cb.CharAt(pos)) && !IsLowerCase(cb.CharAt(pos)))
-					++pos;
-			} else if (IsUpperCase(startChar)) {
-				while (pos > 0 && IsUpperCase(cb.CharAt(pos)))
-					--pos;
-				if (!IsUpperCase(cb.CharAt(pos)))
-					++pos;
-			} else if (IsADigit(startChar)) {
-				while (pos > 0 && IsADigit(cb.CharAt(pos)))
-					--pos;
-				if (!IsADigit(cb.CharAt(pos)))
-					++pos;
-			} else if (IsPunctuation(startChar)) {
-				while (pos > 0 && IsPunctuation(cb.CharAt(pos)))
-					--pos;
-				if (!IsPunctuation(cb.CharAt(pos)))
-					++pos;
-			} else if (isspacechar(startChar)) {
-				while (pos > 0 && isspacechar(cb.CharAt(pos)))
-					--pos;
-				if (!isspacechar(cb.CharAt(pos)))
-					++pos;
-			} else if (!IsASCII(startChar)) {
-				while (pos > 0 && !IsASCII(cb.CharAt(pos)))
-					--pos;
-				if (IsASCII(cb.CharAt(pos)))
-					++pos;
+			ceStart = CharacterAfter(pos);
+			pos -= CharacterBefore(pos).widthBytes;
+			if (IsLowerCase(ceStart.character)) {
+				while (pos > 0 && IsLowerCase(CharacterAfter(pos).character))
+					pos -= CharacterBefore(pos).widthBytes;
+				if (!IsUpperCase(CharacterAfter(pos).character) && !IsLowerCase(CharacterAfter(pos).character))
+					pos += CharacterAfter(pos).widthBytes;
+			} else if (IsUpperCase(ceStart.character)) {
+				while (pos > 0 && IsUpperCase(CharacterAfter(pos).character))
+					pos -= CharacterBefore(pos).widthBytes;
+				if (!IsUpperCase(CharacterAfter(pos).character))
+					pos += CharacterAfter(pos).widthBytes;
+			} else if (IsADigit(ceStart.character)) {
+				while (pos > 0 && IsADigit(CharacterAfter(pos).character))
+					pos -= CharacterBefore(pos).widthBytes;
+				if (!IsADigit(CharacterAfter(pos).character))
+					pos += CharacterAfter(pos).widthBytes;
+			} else if (IsASCIIPunctuationCharacter(ceStart.character)) {
+				while (pos > 0 && IsASCIIPunctuationCharacter(CharacterAfter(pos).character))
+					pos -= CharacterBefore(pos).widthBytes;
+				if (!IsASCIIPunctuationCharacter(CharacterAfter(pos).character))
+					pos += CharacterAfter(pos).widthBytes;
+			} else if (isspacechar(ceStart.character)) {
+				while (pos > 0 && isspacechar(CharacterAfter(pos).character))
+					pos -= CharacterBefore(pos).widthBytes;
+				if (!isspacechar(CharacterAfter(pos).character))
+					pos += CharacterAfter(pos).widthBytes;
+			} else if (!IsASCII(ceStart.character)) {
+				while (pos > 0 && !IsASCII(CharacterAfter(pos).character))
+					pos -= CharacterBefore(pos).widthBytes;
+				if (IsASCII(CharacterAfter(pos).character))
+					pos += CharacterAfter(pos).widthBytes;
 			} else {
-				++pos;
+				pos += CharacterAfter(pos).widthBytes;
 			}
 		}
 	}
 	return pos;
 }
 
-int Document::WordPartRight(int pos) {
-	char startChar = cb.CharAt(pos);
-	int length = Length();
-	if (IsWordPartSeparator(startChar)) {
-		while (pos < length && IsWordPartSeparator(cb.CharAt(pos)))
-			++pos;
-		startChar = cb.CharAt(pos);
-	}
-	if (!IsASCII(startChar)) {
-		while (pos < length && !IsASCII(cb.CharAt(pos)))
-			++pos;
-	} else if (IsLowerCase(startChar)) {
-		while (pos < length && IsLowerCase(cb.CharAt(pos)))
-			++pos;
-	} else if (IsUpperCase(startChar)) {
-		if (IsLowerCase(cb.CharAt(pos + 1))) {
-			++pos;
-			while (pos < length && IsLowerCase(cb.CharAt(pos)))
-				++pos;
+int Document::WordPartRight(int pos) const {
+	CharacterExtracted ceStart = CharacterAfter(pos);
+	const int length = Length();
+	if (IsWordPartSeparator(ceStart.character)) {
+		while (pos < length && IsWordPartSeparator(CharacterAfter(pos).character))
+			pos += CharacterAfter(pos).widthBytes;
+		ceStart = CharacterAfter(pos);
+	}
+	if (!IsASCII(ceStart.character)) {
+		while (pos < length && !IsASCII(CharacterAfter(pos).character))
+			pos += CharacterAfter(pos).widthBytes;
+	} else if (IsLowerCase(ceStart.character)) {
+		while (pos < length && IsLowerCase(CharacterAfter(pos).character))
+			pos += CharacterAfter(pos).widthBytes;
+	} else if (IsUpperCase(ceStart.character)) {
+		if (IsLowerCase(CharacterAfter(pos + ceStart.widthBytes).character)) {
+			pos += CharacterAfter(pos).widthBytes;
+			while (pos < length && IsLowerCase(CharacterAfter(pos).character))
+				pos += CharacterAfter(pos).widthBytes;
 		} else {
-			while (pos < length && IsUpperCase(cb.CharAt(pos)))
-				++pos;
-		}
-		if (IsLowerCase(cb.CharAt(pos)) && IsUpperCase(cb.CharAt(pos - 1)))
-			--pos;
-	} else if (IsADigit(startChar)) {
-		while (pos < length && IsADigit(cb.CharAt(pos)))
-			++pos;
-	} else if (IsPunctuation(startChar)) {
-		while (pos < length && IsPunctuation(cb.CharAt(pos)))
-			++pos;
-	} else if (isspacechar(startChar)) {
-		while (pos < length && isspacechar(cb.CharAt(pos)))
-			++pos;
+			while (pos < length && IsUpperCase(CharacterAfter(pos).character))
+				pos += CharacterAfter(pos).widthBytes;
+		}
+		if (IsLowerCase(CharacterAfter(pos).character) && IsUpperCase(CharacterBefore(pos).character))
+			pos -= CharacterBefore(pos).widthBytes;
+	} else if (IsADigit(ceStart.character)) {
+		while (pos < length && IsADigit(CharacterAfter(pos).character))
+			pos += CharacterAfter(pos).widthBytes;
+	} else if (IsASCIIPunctuationCharacter(ceStart.character)) {
+		while (pos < length && IsASCIIPunctuationCharacter(CharacterAfter(pos).character))
+			pos += CharacterAfter(pos).widthBytes;
+	} else if (isspacechar(ceStart.character)) {
+		while (pos < length && isspacechar(CharacterAfter(pos).character))
+			pos += CharacterAfter(pos).widthBytes;
 	} else {
-		++pos;
+		pos += CharacterAfter(pos).widthBytes;
 	}
 	return pos;
 }
@@ -2344,7 +2578,7 @@ public:
 	Position position;
 	ByteIterator(const Document *doc_ = 0, Position position_ = 0) : doc(doc_), position(position_) {
 	}
-	ByteIterator(const ByteIterator &other) {
+	ByteIterator(const ByteIterator &other) NOEXCEPT {
 		doc = other.doc;
 		position = other.position;
 	}
@@ -2519,7 +2753,7 @@ class UTF8Iterator : public std::iterator<std::bidirectional_iterator_tag, wchar
 public:
 	UTF8Iterator(const Document *doc_=0, Position position_=0) : doc(doc_), position(position_) {
 	}
-	UTF8Iterator(const UTF8Iterator &other) {
+	UTF8Iterator(const UTF8Iterator &other) NOEXCEPT {
 		doc = other.doc;
 		position = other.position;
 	}
diff --git a/src/stc/scintilla/src/Document.h b/src/stc/scintilla/src/Document.h
index 2d6005b..c0a0bb8 100644
--- a/src/stc/scintilla/src/Document.h
+++ b/src/stc/scintilla/src/Document.h
@@ -211,9 +211,6 @@ public:
 		bool operator==(const WatcherWithUserData &other) const {
 			return (watcher == other.watcher) && (userData == other.userData);
 		}
-		bool operator!=(const WatcherWithUserData &other) const {
-			return !((watcher == other.watcher) && (userData == other.userData));
-		}
 	};
 
 private:
@@ -241,6 +238,18 @@ private:
 
 public:
 
+	struct CharacterExtracted {
+		unsigned int character;
+		unsigned int widthBytes;
+		CharacterExtracted(unsigned int character_, unsigned int widthBytes_) :
+			character(character_), widthBytes(widthBytes_) {
+		}
+		// For DBCS characters turn 2 bytes into an int
+		static CharacterExtracted DBCS(unsigned char lead, unsigned char trail) {
+			return CharacterExtracted((lead << 8) | trail, 2);
+		}
+	};
+
 	LexInterface *pli;
 
 	int eolMode;
@@ -287,6 +296,8 @@ public:
 	int MovePositionOutsideChar(int pos, int moveDir, bool checkLineEnd=true) const;
 	int NextPosition(int pos, int moveDir) const;
 	bool NextCharacter(int &pos, int moveDir) const;	// Returns true if pos changed
+	Document::CharacterExtracted CharacterAfter(int position) const;
+	Document::CharacterExtracted CharacterBefore(int position) const;
 	Sci_Position SCI_METHOD GetRelativePosition(Sci_Position positionStart, Sci_Position characterOffset) const;
 	int GetRelativePositionUTF16(int positionStart, int characterOffset) const;
 	int SCI_METHOD GetCharacterAndWidth(Sci_Position position, Sci_Position *pWidth) const;
@@ -376,19 +387,12 @@ public:
 	void GetHighlightDelimiters(HighlightDelimiter &hDelimiter, int line, int lastLine);
 
 	void Indent(bool forwards);
-	int ExtendWordSelect(int pos, int delta, bool onlyWordCharacters=false);
-	int NextWordStart(int pos, int delta);
-	int NextWordEnd(int pos, int delta);
+	int ExtendWordSelect(int pos, int delta, bool onlyWordCharacters=false) const;
+	int NextWordStart(int pos, int delta) const;
+	int NextWordEnd(int pos, int delta) const;
 	Sci_Position SCI_METHOD Length() const { return cb.Length(); }
 	void Allocate(int newSize) { cb.Allocate(newSize); }
 
-	struct CharacterExtracted {
-		unsigned int character;
-		unsigned int widthBytes;
-		CharacterExtracted(unsigned int character_, unsigned int widthBytes_) :
-			character(character_), widthBytes(widthBytes_) {
-		}
-	};
 	CharacterExtracted ExtractCharacter(int position) const;
 
 	bool IsWordStartAt(int pos) const;
@@ -404,7 +408,7 @@ public:
 
 	void SetDefaultCharClasses(bool includeWordClass);
 	void SetCharClasses(const unsigned char *chars, CharClassify::cc newCharClass);
-	int GetCharsOfClass(CharClassify::cc characterClass, unsigned char *buffer);
+	int GetCharsOfClass(CharClassify::cc characterClass, unsigned char *buffer) const;
 	void SCI_METHOD StartStyling(Sci_Position position, char mask);
 	bool SCI_METHOD SetStyleFor(Sci_Position length, char style);
 	bool SCI_METHOD SetStyles(Sci_Position length, const char *styles);
@@ -440,10 +444,11 @@ public:
 	bool AddWatcher(DocWatcher *watcher, void *userData);
 	bool RemoveWatcher(DocWatcher *watcher, void *userData);
 
-	CharClassify::cc WordCharClass(unsigned char ch) const;
-	bool IsWordPartSeparator(char ch) const;
-	int WordPartLeft(int pos);
-	int WordPartRight(int pos);
+	bool IsASCIIWordByte(unsigned char ch) const;
+	CharClassify::cc WordCharacterClass(unsigned int ch) const;
+	bool IsWordPartSeparator(unsigned int ch) const;
+	int WordPartLeft(int pos) const;
+	int WordPartRight(int pos) const;
 	int ExtendStyleRange(int pos, int delta, bool singleLine = false);
 	bool IsWhiteLine(int line) const;
 	int ParaUp(int pos) const;
diff --git a/src/stc/scintilla/src/EditModel.cxx b/src/stc/scintilla/src/EditModel.cxx
index 35903c6..0f64e07 100644
--- a/src/stc/scintilla/src/EditModel.cxx
+++ b/src/stc/scintilla/src/EditModel.cxx
@@ -65,6 +65,7 @@ EditModel::EditModel() {
 	primarySelection = true;
 	imeInteraction = imeWindowed;
 	foldFlags = 0;
+	foldDisplayTextStyle = SC_FOLDDISPLAYTEXT_HIDDEN;
 	hotspot = Range(invalidPosition);
 	hoverIndicatorPos = invalidPosition;
 	wrapWidth = LineLayout::wrapWidthInfinite;
diff --git a/src/stc/scintilla/src/EditModel.h b/src/stc/scintilla/src/EditModel.h
index 021bf67..847fd72 100644
--- a/src/stc/scintilla/src/EditModel.h
+++ b/src/stc/scintilla/src/EditModel.h
@@ -45,6 +45,7 @@ public:
 	enum IMEInteraction { imeWindowed, imeInline } imeInteraction;
 
 	int foldFlags;
+	int foldDisplayTextStyle;
 	ContractionState cs;
 	// Hotspot support
 	Range hotspot;
diff --git a/src/stc/scintilla/src/EditView.cxx b/src/stc/scintilla/src/EditView.cxx
index 9ca6e95..5c62256 100644
--- a/src/stc/scintilla/src/EditView.cxx
+++ b/src/stc/scintilla/src/EditView.cxx
@@ -25,6 +25,7 @@
 #include "Scintilla.h"
 
 #include "StringCopy.h"
+#include "CharacterSet.h"
 #include "Position.h"
 #include "SplitVector.h"
 #include "Partitioning.h"
@@ -305,21 +306,25 @@ static const char *ControlCharacterString(unsigned char ch) {
 	}
 }
 
-static void DrawTabArrow(Surface *surface, PRectangle rcTab, int ymid) {
-	int ydiff = static_cast<int>(rcTab.bottom - rcTab.top) / 2;
-	int xhead = static_cast<int>(rcTab.right) - 1 - ydiff;
-	if (xhead <= rcTab.left) {
-		ydiff -= static_cast<int>(rcTab.left) - xhead - 1;
-		xhead = static_cast<int>(rcTab.left) - 1;
-	}
+static void DrawTabArrow(Surface *surface, PRectangle rcTab, int ymid, const ViewStyle &vsDraw) {
 	if ((rcTab.left + 2) < (rcTab.right - 1))
 		surface->MoveTo(static_cast<int>(rcTab.left) + 2, ymid);
 	else
 		surface->MoveTo(static_cast<int>(rcTab.right) - 1, ymid);
 	surface->LineTo(static_cast<int>(rcTab.right) - 1, ymid);
-	surface->LineTo(xhead, ymid - ydiff);
-	surface->MoveTo(static_cast<int>(rcTab.right) - 1, ymid);
-	surface->LineTo(xhead, ymid + ydiff);
+
+	// Draw the arrow head if needed
+	if (vsDraw.tabDrawMode == tdLongArrow) {
+		int ydiff = static_cast<int>(rcTab.bottom - rcTab.top) / 2;
+		int xhead = static_cast<int>(rcTab.right) - 1 - ydiff;
+		if (xhead <= rcTab.left) {
+			ydiff -= static_cast<int>(rcTab.left) - xhead - 1;
+			xhead = static_cast<int>(rcTab.left) - 1;
+		}
+		surface->LineTo(xhead, ymid - ydiff);
+		surface->MoveTo(static_cast<int>(rcTab.right) - 1, ymid);
+		surface->LineTo(xhead, ymid + ydiff);
+	}
 }
 
 void EditView::RefreshPixMaps(Surface *surfaceWindow, WindowID wid, const ViewStyle &vsDraw) {
@@ -389,16 +394,16 @@ void EditView::LayoutLine(const EditModel &model, int line, Surface *surface, co
 					(ll->chars[numCharsInLine] == chDoc);
 				else if (vstyle.styles[ll->styles[numCharsInLine]].caseForce == Style::caseLower)
 					allSame = allSame &&
-					(ll->chars[numCharsInLine] == static_cast<char>(tolower(chDoc)));
+					(ll->chars[numCharsInLine] == MakeLowerCase(chDoc));
 				else if (vstyle.styles[ll->styles[numCharsInLine]].caseForce == Style::caseUpper)
 					allSame = allSame &&
-					(ll->chars[numCharsInLine] == static_cast<char>(toupper(chDoc)));
+					(ll->chars[numCharsInLine] == MakeUpperCase(chDoc));
 				else	{ // Style::caseCamel
-					if ((model.pdoc->WordCharClass(ll->chars[numCharsInLine]) == CharClassify::ccWord) &&
-					  ((numCharsInLine == 0) || (model.pdoc->WordCharClass(ll->chars[numCharsInLine - 1]) != CharClassify::ccWord))) {
-						allSame = allSame && (ll->chars[numCharsInLine] == static_cast<char>(toupper(chDoc)));
+					if ((model.pdoc->IsASCIIWordByte(ll->chars[numCharsInLine])) &&
+					  ((numCharsInLine == 0) || (!model.pdoc->IsASCIIWordByte(ll->chars[numCharsInLine - 1])))) {
+						allSame = allSame && (ll->chars[numCharsInLine] == MakeUpperCase(chDoc));
 					} else {
-						allSame = allSame && (ll->chars[numCharsInLine] == static_cast<char>(tolower(chDoc)));
+						allSame = allSame && (ll->chars[numCharsInLine] == MakeLowerCase(chDoc));
 					}
 				}
 				numCharsInLine++;
@@ -417,7 +422,7 @@ void EditView::LayoutLine(const EditModel &model, int line, Surface *surface, co
 		ll->widthLine = LineLayout::wrapWidthInfinite;
 		ll->lines = 1;
 		if (vstyle.edgeState == EDGE_BACKGROUND) {
-			ll->edgeColumn = model.pdoc->FindColumn(line, vstyle.theEdge);
+			ll->edgeColumn = model.pdoc->FindColumn(line, vstyle.theEdge.column);
 			if (ll->edgeColumn >= posLineStart) {
 				ll->edgeColumn -= posLineStart;
 			}
@@ -440,15 +445,15 @@ void EditView::LayoutLine(const EditModel &model, int line, Surface *surface, co
 			for (int charInLine = 0; charInLine<lineLength; charInLine++) {
 				char chDoc = ll->chars[charInLine];
 				if (vstyle.styles[ll->styles[charInLine]].caseForce == Style::caseUpper)
-					ll->chars[charInLine] = static_cast<char>(toupper(chDoc));
+					ll->chars[charInLine] = static_cast<char>(MakeUpperCase(chDoc));
 				else if (vstyle.styles[ll->styles[charInLine]].caseForce == Style::caseLower)
-					ll->chars[charInLine] = static_cast<char>(tolower(chDoc));
+					ll->chars[charInLine] = static_cast<char>(MakeLowerCase(chDoc));
 				else if (vstyle.styles[ll->styles[charInLine]].caseForce == Style::caseCamel) {
-					if ((model.pdoc->WordCharClass(ll->chars[charInLine]) == CharClassify::ccWord) &&
-					  ((charInLine == 0) || (model.pdoc->WordCharClass(ll->chars[charInLine - 1]) != CharClassify::ccWord))) {
-						ll->chars[charInLine] = static_cast<char>(toupper(chDoc));
+					if ((model.pdoc->IsASCIIWordByte(ll->chars[charInLine])) &&
+					  ((charInLine == 0) || (!model.pdoc->IsASCIIWordByte(ll->chars[charInLine - 1])))) {
+						ll->chars[charInLine] = static_cast<char>(MakeUpperCase(chDoc));
 					} else {
-						ll->chars[charInLine] = static_cast<char>(tolower(chDoc));
+						ll->chars[charInLine] = static_cast<char>(MakeLowerCase(chDoc));
 					}
 				}
 			}
@@ -595,19 +600,24 @@ void EditView::LayoutLine(const EditModel &model, int line, Surface *surface, co
 	}
 }
 
-Point EditView::LocationFromPosition(Surface *surface, const EditModel &model, SelectionPosition pos, int topLine, const ViewStyle &vs) {
+Point EditView::LocationFromPosition(Surface *surface, const EditModel &model, SelectionPosition pos, int topLine,
+				     const ViewStyle &vs, PointEnd pe) {
 	Point pt;
 	if (pos.Position() == INVALID_POSITION)
 		return pt;
-	const int line = model.pdoc->LineFromPosition(pos.Position());
-	const int lineVisible = model.cs.DisplayFromDoc(line);
-	//Platform::DebugPrintf("line=%d\n", line);
-	AutoLineLayout ll(llc, RetrieveLineLayout(line, model));
+	int lineDoc = model.pdoc->LineFromPosition(pos.Position());
+	int posLineStart = model.pdoc->LineStart(lineDoc);
+	if ((pe & peLineEnd) && (lineDoc > 0) && (pos.Position() == posLineStart)) {
+		// Want point at end of first line
+		lineDoc--;
+		posLineStart = model.pdoc->LineStart(lineDoc);
+	}
+	const int lineVisible = model.cs.DisplayFromDoc(lineDoc);
+	AutoLineLayout ll(llc, RetrieveLineLayout(lineDoc, model));
 	if (surface && ll) {
-		const int posLineStart = model.pdoc->LineStart(line);
-		LayoutLine(model, line, surface, vs, ll, model.wrapWidth);
+		LayoutLine(model, lineDoc, surface, vs, ll, model.wrapWidth);
 		const int posInLine = pos.Position() - posLineStart;
-		pt = ll->PointFromPosition(posInLine, vs.lineHeight);
+		pt = ll->PointFromPosition(posInLine, vs.lineHeight, pe);
 		pt.y += (lineVisible - topLine) * vs.lineHeight;
 		pt.x += vs.textStart - model.xOffset;
 	}
@@ -615,7 +625,32 @@ Point EditView::LocationFromPosition(Surface *surface, const EditModel &model, S
 	return pt;
 }
 
-SelectionPosition EditView::SPositionFromLocation(Surface *surface, const EditModel &model, Point pt, bool canReturnInvalid, bool charPosition, bool virtualSpace, const ViewStyle &vs) {
+Range EditView::RangeDisplayLine(Surface *surface, const EditModel &model, int lineVisible, const ViewStyle &vs) {
+	Range rangeSubLine = Range(0,0);
+	if (lineVisible < 0) {
+		return rangeSubLine;
+	}
+	const int lineDoc = model.cs.DocFromDisplay(lineVisible);
+	const int positionLineStart = model.pdoc->LineStart(lineDoc);
+	AutoLineLayout ll(llc, RetrieveLineLayout(lineDoc, model));
+	if (surface && ll) {
+		LayoutLine(model, lineDoc, surface, vs, ll, model.wrapWidth);
+		const int lineStartSet = model.cs.DisplayFromDoc(lineDoc);
+		const int subLine = lineVisible - lineStartSet;
+		if (subLine < ll->lines) {
+			rangeSubLine = ll->SubLineRange(subLine);
+			if (subLine == ll->lines-1) {
+				rangeSubLine.end = model.pdoc->LineStart(lineDoc + 1) -
+					positionLineStart;
+			}
+		}
+	}
+	rangeSubLine.start += positionLineStart;
+	rangeSubLine.end += positionLineStart;
+	return rangeSubLine;
+}
+
+SelectionPosition EditView::SPositionFromLocation(Surface *surface, const EditModel &model, PointDocument pt, bool canReturnInvalid, bool charPosition, bool virtualSpace, const ViewStyle &vs) {
 	pt.x = pt.x - vs.textStart;
 	int visibleLine = static_cast<int>(floor(pt.y / vs.lineHeight));
 	if (!canReturnInvalid && (visibleLine < 0))
@@ -636,7 +671,8 @@ SelectionPosition EditView::SPositionFromLocation(Surface *surface, const EditMo
 			const XYPOSITION subLineStart = ll->positions[rangeSubLine.start];
 			if (subLine > 0)	// Wrapped
 				pt.x -= ll->wrapIndent;
-			const int positionInLine = ll->FindPositionFromX(pt.x + subLineStart, rangeSubLine, charPosition);
+			const int positionInLine = ll->FindPositionFromX(static_cast<XYPOSITION>(pt.x + subLineStart),
+				rangeSubLine, charPosition);
 			if (positionInLine < rangeSubLine.end) {
 				return SelectionPosition(model.pdoc->MovePositionOutsideChar(positionInLine + posLineStart, 1));
 			}
@@ -749,7 +785,7 @@ static ColourDesired TextBackground(const EditModel &model, const ViewStyle &vsD
 		if ((vsDraw.edgeState == EDGE_BACKGROUND) &&
 			(i >= ll->edgeColumn) &&
 			(i < ll->numCharsBeforeEOL))
-			return vsDraw.edgecolour;
+			return vsDraw.theEdge.colour;
 		if (inHotspot && vsDraw.hotspotColours.back.isSet)
 			return vsDraw.hotspotColours.back;
 	}
@@ -844,7 +880,7 @@ void EditView::DrawEOL(Surface *surface, const EditModel &model, const ViewStyle
 	int alpha = SC_ALPHA_NOALPHA;
 	if (!hideSelection) {
 		int posAfterLineEnd = model.pdoc->LineStart(line + 1);
-		eolInSelection = (subLine == (ll->lines - 1)) ? model.sel.InSelectionForEOL(posAfterLineEnd) : 0;
+		eolInSelection = (lastSubLine == true) ? model.sel.InSelectionForEOL(posAfterLineEnd) : 0;
 		alpha = (eolInSelection == 1) ? vsDraw.selAlpha : vsDraw.selAdditionalAlpha;
 	}
 
@@ -913,25 +949,15 @@ void EditView::DrawEOL(Surface *surface, const EditModel &model, const ViewStyle
 		}
 	}
 
-	// Fill the remainder of the line
 	rcSegment.left = rcSegment.right;
 	if (rcSegment.left < rcLine.left)
 		rcSegment.left = rcLine.left;
 	rcSegment.right = rcLine.right;
 
-	if (eolInSelection && vsDraw.selEOLFilled && vsDraw.selColours.back.isSet && (line < model.pdoc->LinesTotal() - 1) && (alpha == SC_ALPHA_NOALPHA)) {
-		surface->FillRectangle(rcSegment, SelectionBackground(vsDraw, eolInSelection == 1, model.primarySelection));
-	} else {
-		if (background.isSet) {
-			surface->FillRectangle(rcSegment, background);
-		} else if (vsDraw.styles[ll->styles[ll->numCharsInLine]].eolFilled) {
-			surface->FillRectangle(rcSegment, vsDraw.styles[ll->styles[ll->numCharsInLine]].back);
-		} else {
-			surface->FillRectangle(rcSegment, vsDraw.styles[STYLE_DEFAULT].back);
-		}
-		if (eolInSelection && vsDraw.selEOLFilled && vsDraw.selColours.back.isSet && (line < model.pdoc->LinesTotal() - 1) && (alpha != SC_ALPHA_NOALPHA)) {
-			SimpleAlphaRectangle(surface, rcSegment, SelectionBackground(vsDraw, eolInSelection == 1, model.primarySelection), alpha);
-		}
+	bool fillRemainder = !lastSubLine || model.foldDisplayTextStyle == SC_FOLDDISPLAYTEXT_HIDDEN || !model.cs.GetFoldDisplayTextShown(line);
+	if (fillRemainder) {
+		// Fill the remainder of the line
+		FillLineRemainder(surface, model, vsDraw, ll, line, rcSegment, subLine);
 	}
 
 	bool drawWrapMarkEnd = false;
@@ -962,14 +988,23 @@ void EditView::DrawEOL(Surface *surface, const EditModel &model, const ViewStyle
 }
 
 static void DrawIndicator(int indicNum, int startPos, int endPos, Surface *surface, const ViewStyle &vsDraw,
-	const LineLayout *ll, int xStart, PRectangle rcLine, int subLine, Indicator::DrawState drawState, int value) {
+	const LineLayout *ll, int xStart, PRectangle rcLine, int secondCharacter, int subLine, Indicator::DrawState drawState, int value) {
 	const XYPOSITION subLineStart = ll->positions[ll->LineStart(subLine)];
 	PRectangle rcIndic(
 		ll->positions[startPos] + xStart - subLineStart,
 		rcLine.top + vsDraw.maxAscent,
 		ll->positions[endPos] + xStart - subLineStart,
 		rcLine.top + vsDraw.maxAscent + 3);
-	vsDraw.indicators[indicNum].Draw(surface, rcIndic, rcLine, drawState, value);
+	PRectangle rcFirstCharacter = rcIndic;
+	// Allow full descent space for character indicators
+	rcFirstCharacter.bottom = rcLine.top + vsDraw.maxAscent + vsDraw.maxDescent;
+	if (secondCharacter >= 0) {
+		rcFirstCharacter.right = ll->positions[secondCharacter] + xStart - subLineStart;
+	} else {
+		// Indicator continued from earlier line so make an empty box and don't draw
+		rcFirstCharacter.right = rcFirstCharacter.left;
+	}
+	vsDraw.indicators[indicNum].Draw(surface, rcIndic, rcLine, rcFirstCharacter, drawState, value);
 }
 
 static void DrawIndicators(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
@@ -992,8 +1027,9 @@ static void DrawIndicators(Surface *surface, const EditModel &model, const ViewS
 					rangeRun.ContainsCharacter(hoverIndicatorPos);
 				const int value = deco->rs.ValueAt(startPos);
 				Indicator::DrawState drawState = hover ? Indicator::drawHover : Indicator::drawNormal;
+				const int posSecond = model.pdoc->MovePositionOutsideChar(rangeRun.First() + 1, 1);
 				DrawIndicator(deco->indicator, startPos - posLineStart, endPos - posLineStart,
-					surface, vsDraw, ll, xStart, rcLine, subLine, drawState, value);
+					surface, vsDraw, ll, xStart, rcLine, posSecond - posLineStart, subLine, drawState, value);
 				startPos = endPos;
 				if (!deco->rs.ValueAt(startPos)) {
 					startPos = deco->rs.EndRun(startPos);
@@ -1011,19 +1047,110 @@ static void DrawIndicators(Surface *surface, const EditModel &model, const ViewS
 			if (rangeLine.ContainsCharacter(model.braces[0])) {
 				int braceOffset = model.braces[0] - posLineStart;
 				if (braceOffset < ll->numCharsInLine) {
-					DrawIndicator(braceIndicator, braceOffset, braceOffset + 1, surface, vsDraw, ll, xStart, rcLine, subLine, Indicator::drawNormal, 1);
+					const int secondOffset = model.pdoc->MovePositionOutsideChar(model.braces[0] + 1, 1) - posLineStart;
+					DrawIndicator(braceIndicator, braceOffset, braceOffset + 1, surface, vsDraw, ll, xStart, rcLine, secondOffset, subLine, Indicator::drawNormal, 1);
 				}
 			}
 			if (rangeLine.ContainsCharacter(model.braces[1])) {
 				int braceOffset = model.braces[1] - posLineStart;
 				if (braceOffset < ll->numCharsInLine) {
-					DrawIndicator(braceIndicator, braceOffset, braceOffset + 1, surface, vsDraw, ll, xStart, rcLine, subLine, Indicator::drawNormal, 1);
+					const int secondOffset = model.pdoc->MovePositionOutsideChar(model.braces[1] + 1, 1) - posLineStart;
+					DrawIndicator(braceIndicator, braceOffset, braceOffset + 1, surface, vsDraw, ll, xStart, rcLine, secondOffset, subLine, Indicator::drawNormal, 1);
 				}
 			}
 		}
 	}
 }
 
+void EditView::DrawFoldDisplayText(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
+							  int line, int xStart, PRectangle rcLine, int subLine, XYACCUMULATOR subLineStart, DrawPhase phase) {
+	const bool lastSubLine = subLine == (ll->lines - 1);
+	if (!lastSubLine)
+		return;
+
+	if ((model.foldDisplayTextStyle == SC_FOLDDISPLAYTEXT_HIDDEN) || !model.cs.GetFoldDisplayTextShown(line))
+		return;
+
+	PRectangle rcSegment = rcLine;
+	const char *foldDisplayText = model.cs.GetFoldDisplayText(line);
+	const int lengthFoldDisplayText = static_cast<int>(strlen(foldDisplayText));
+	FontAlias fontText = vsDraw.styles[STYLE_FOLDDISPLAYTEXT].font;
+	const int widthFoldDisplayText = static_cast<int>(surface->WidthText(fontText, foldDisplayText, lengthFoldDisplayText));
+
+	int eolInSelection = 0;
+	int alpha = SC_ALPHA_NOALPHA;
+	if (!hideSelection) {
+		int posAfterLineEnd = model.pdoc->LineStart(line + 1);
+		eolInSelection = (subLine == (ll->lines - 1)) ? model.sel.InSelectionForEOL(posAfterLineEnd) : 0;
+		alpha = (eolInSelection == 1) ? vsDraw.selAlpha : vsDraw.selAdditionalAlpha;
+	}
+
+	const XYPOSITION spaceWidth = vsDraw.styles[ll->EndLineStyle()].spaceWidth;
+	XYPOSITION virtualSpace = model.sel.VirtualSpaceFor(model.pdoc->LineEnd(line)) * spaceWidth;
+	rcSegment.left = xStart + static_cast<XYPOSITION>(ll->positions[ll->numCharsInLine] - subLineStart) + spaceWidth + virtualSpace;
+	rcSegment.right = rcSegment.left + static_cast<XYPOSITION>(widthFoldDisplayText);
+
+	ColourOptional background = vsDraw.Background(model.pdoc->GetMark(line), model.caret.active, ll->containsCaret);
+	FontAlias textFont = vsDraw.styles[STYLE_FOLDDISPLAYTEXT].font;
+	ColourDesired textFore = vsDraw.styles[STYLE_FOLDDISPLAYTEXT].fore;
+	if (eolInSelection && (vsDraw.selColours.fore.isSet)) {
+		textFore = (eolInSelection == 1) ? vsDraw.selColours.fore : vsDraw.selAdditionalForeground;
+	}
+	ColourDesired textBack = TextBackground(model, vsDraw, ll, background, eolInSelection,
+											false, STYLE_FOLDDISPLAYTEXT, -1);
+
+	if (model.trackLineWidth) {
+		if (rcSegment.right + 1> lineWidthMaxSeen) {
+			// Fold display text border drawn on rcSegment.right with width 1 is the last visble object of the line
+			lineWidthMaxSeen = static_cast<int>(rcSegment.right + 1);
+		}
+	}
+
+	if ((phasesDraw != phasesOne) && (phase & drawBack)) {
+		surface->FillRectangle(rcSegment, textBack);
+
+		// Fill Remainder of the line
+		PRectangle rcRemainder = rcSegment;
+		rcRemainder.left = rcRemainder.right + 1;
+		if (rcRemainder.left < rcLine.left)
+			rcRemainder.left = rcLine.left;
+		rcRemainder.right = rcLine.right;
+		FillLineRemainder(surface, model, vsDraw, ll, line, rcRemainder, subLine);
+	}
+
+	if (phase & drawText) {
+		if (phasesDraw != phasesOne) {
+			surface->DrawTextTransparent(rcSegment, textFont,
+				rcSegment.top + vsDraw.maxAscent, foldDisplayText,
+				lengthFoldDisplayText, textFore);
+		} else {
+			surface->DrawTextNoClip(rcSegment, textFont,
+				rcSegment.top + vsDraw.maxAscent, foldDisplayText,
+				lengthFoldDisplayText, textFore, textBack);
+		}
+	}
+
+	if (phase & drawIndicatorsFore) {
+		if (model.foldDisplayTextStyle == SC_FOLDDISPLAYTEXT_BOXED) {
+			surface->PenColour(textFore);
+			surface->MoveTo(static_cast<int>(rcSegment.left), static_cast<int>(rcSegment.top));
+			surface->LineTo(static_cast<int>(rcSegment.left), static_cast<int>(rcSegment.bottom));
+			surface->MoveTo(static_cast<int>(rcSegment.right), static_cast<int>(rcSegment.top));
+			surface->LineTo(static_cast<int>(rcSegment.right), static_cast<int>(rcSegment.bottom));
+			surface->MoveTo(static_cast<int>(rcSegment.left), static_cast<int>(rcSegment.top));
+			surface->LineTo(static_cast<int>(rcSegment.right), static_cast<int>(rcSegment.top));
+			surface->MoveTo(static_cast<int>(rcSegment.left), static_cast<int>(rcSegment.bottom - 1));
+			surface->LineTo(static_cast<int>(rcSegment.right), static_cast<int>(rcSegment.bottom - 1));
+		}
+	}
+
+	if (phase & drawSelectionTranslucent) {
+		if (eolInSelection && vsDraw.selColours.back.isSet && (line < model.pdoc->LinesTotal() - 1) && alpha != SC_ALPHA_NOALPHA) {
+			SimpleAlphaRectangle(surface, rcSegment, SelectionBackground(vsDraw, eolInSelection == 1, model.primarySelection), alpha);
+		}
+	}
+}
+
 static bool AnnotationBoxedOrIndented(int annotationVisible) {
 	return annotationVisible == ANNOTATION_BOXED || annotationVisible == ANNOTATION_INDENTED;
 }
@@ -1339,12 +1466,24 @@ static void DrawEdgeLine(Surface *surface, const ViewStyle &vsDraw, const LineLa
 	Range lineRange, int xStart) {
 	if (vsDraw.edgeState == EDGE_LINE) {
 		PRectangle rcSegment = rcLine;
-		int edgeX = static_cast<int>(vsDraw.theEdge * vsDraw.spaceWidth);
+		int edgeX = static_cast<int>(vsDraw.theEdge.column * vsDraw.spaceWidth);
 		rcSegment.left = static_cast<XYPOSITION>(edgeX + xStart);
 		if ((ll->wrapIndent != 0) && (lineRange.start != 0))
 			rcSegment.left -= ll->wrapIndent;
 		rcSegment.right = rcSegment.left + 1;
-		surface->FillRectangle(rcSegment, vsDraw.edgecolour);
+		surface->FillRectangle(rcSegment, vsDraw.theEdge.colour);
+	} else if (vsDraw.edgeState == EDGE_MULTILINE) {
+		for (size_t edge = 0; edge < vsDraw.theMultiEdge.size(); edge++) {
+			if (vsDraw.theMultiEdge[edge].column >= 0) {
+				PRectangle rcSegment = rcLine;
+				int edgeX = static_cast<int>(vsDraw.theMultiEdge[edge].column * vsDraw.spaceWidth);
+				rcSegment.left = static_cast<XYPOSITION>(edgeX + xStart);
+				if ((ll->wrapIndent != 0) && (lineRange.start != 0))
+					rcSegment.left -= ll->wrapIndent;
+				rcSegment.right = rcSegment.left + 1;
+				surface->FillRectangle(rcSegment, vsDraw.theMultiEdge[edge].colour);
+			}
+		}
 	}
 }
 
@@ -1524,7 +1663,7 @@ void EditView::DrawForeground(Surface *surface, const EditModel &model, const Vi
 							PRectangle rcTab(rcSegment.left + 1, rcSegment.top + tabArrowHeight,
 								rcSegment.right - 1, rcSegment.bottom - vsDraw.maxDescent);
 							if (customDrawTabArrow == NULL)
-								DrawTabArrow(surface, rcTab, static_cast<int>(rcSegment.top + vsDraw.lineHeight / 2));
+								DrawTabArrow(surface, rcTab, static_cast<int>(rcSegment.top + vsDraw.lineHeight / 2), vsDraw);
 							else
 								customDrawTabArrow(surface, rcTab, static_cast<int>(rcSegment.top + vsDraw.lineHeight / 2));
 						}
@@ -1730,6 +1869,8 @@ void EditView::DrawLine(Surface *surface, const EditModel &model, const ViewStyl
 			xStart, subLine, subLineStart, background);
 	}
 
+	DrawFoldDisplayText(surface, model, vsDraw, ll, line, xStart, rcLine, subLine, subLineStart, phase);
+
 	if (!hideSelection && (phase & drawSelectionTranslucent)) {
 		DrawTranslucentSelection(surface, model, vsDraw, ll, line, rcLine, subLine, lineRange, xStart);
 	}
@@ -1865,7 +2006,8 @@ void EditView::PaintText(Surface *surfaceWindow, const EditModel &model, PRectan
 					ll->SetBracesHighlight(rangeLine, model.braces, static_cast<char>(model.bracesMatchStyle),
 						static_cast<int>(model.highlightGuideColumn * vsDraw.spaceWidth), bracesIgnoreStyle);
 
-					if (leftTextOverlap && bufferedDraw) {
+					if (leftTextOverlap && (bufferedDraw || ((phasesDraw < phasesMultiple) && (*it & drawBack)))) {
+						// Clear the left margin
 						PRectangle rcSpacer = rcLine;
 						rcSpacer.right = rcSpacer.left;
 						rcSpacer.left -= 1;
@@ -1919,10 +2061,19 @@ void EditView::PaintText(Surface *surfaceWindow, const EditModel &model, PRectan
 		if (rcBeyondEOF.top < rcBeyondEOF.bottom) {
 			surfaceWindow->FillRectangle(rcBeyondEOF, vsDraw.styles[STYLE_DEFAULT].back);
 			if (vsDraw.edgeState == EDGE_LINE) {
-				int edgeX = static_cast<int>(vsDraw.theEdge * vsDraw.spaceWidth);
+				int edgeX = static_cast<int>(vsDraw.theEdge.column * vsDraw.spaceWidth);
 				rcBeyondEOF.left = static_cast<XYPOSITION>(edgeX + xStart);
 				rcBeyondEOF.right = rcBeyondEOF.left + 1;
-				surfaceWindow->FillRectangle(rcBeyondEOF, vsDraw.edgecolour);
+				surfaceWindow->FillRectangle(rcBeyondEOF, vsDraw.theEdge.colour);
+			} else if (vsDraw.edgeState == EDGE_MULTILINE) {
+				for (size_t edge = 0; edge < vsDraw.theMultiEdge.size(); edge++) {
+					if (vsDraw.theMultiEdge[edge].column >= 0) {
+						int edgeX = static_cast<int>(vsDraw.theMultiEdge[edge].column * vsDraw.spaceWidth);
+						rcBeyondEOF.left = static_cast<XYPOSITION>(edgeX + xStart);
+						rcBeyondEOF.right = rcBeyondEOF.left + 1;
+						surfaceWindow->FillRectangle(rcBeyondEOF, vsDraw.theMultiEdge[edge].colour);
+					}
+				}
 			}
 		}
 		//Platform::DebugPrintf("start display %d, offset = %d\n", pdoc->Length(), xOffset);
@@ -1933,6 +2084,34 @@ void EditView::PaintText(Surface *surfaceWindow, const EditModel &model, PRectan
 	}
 }
 
+void EditView::FillLineRemainder(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
+	int line, PRectangle rcArea, int subLine) {
+		int eolInSelection = 0;
+		int alpha = SC_ALPHA_NOALPHA;
+		if (!hideSelection) {
+			int posAfterLineEnd = model.pdoc->LineStart(line + 1);
+			eolInSelection = (subLine == (ll->lines - 1)) ? model.sel.InSelectionForEOL(posAfterLineEnd) : 0;
+			alpha = (eolInSelection == 1) ? vsDraw.selAlpha : vsDraw.selAdditionalAlpha;
+		}
+
+		ColourOptional background = vsDraw.Background(model.pdoc->GetMark(line), model.caret.active, ll->containsCaret);
+
+		if (eolInSelection && vsDraw.selEOLFilled && vsDraw.selColours.back.isSet && (line < model.pdoc->LinesTotal() - 1) && (alpha == SC_ALPHA_NOALPHA)) {
+			surface->FillRectangle(rcArea, SelectionBackground(vsDraw, eolInSelection == 1, model.primarySelection));
+		} else {
+			if (background.isSet) {
+				surface->FillRectangle(rcArea, background);
+			} else if (vsDraw.styles[ll->styles[ll->numCharsInLine]].eolFilled) {
+				surface->FillRectangle(rcArea, vsDraw.styles[ll->styles[ll->numCharsInLine]].back);
+			} else {
+				surface->FillRectangle(rcArea, vsDraw.styles[STYLE_DEFAULT].back);
+			}
+			if (eolInSelection && vsDraw.selEOLFilled && vsDraw.selColours.back.isSet && (line < model.pdoc->LinesTotal() - 1) && (alpha != SC_ALPHA_NOALPHA)) {
+				SimpleAlphaRectangle(surface, rcArea, SelectionBackground(vsDraw, eolInSelection == 1, model.primarySelection), alpha);
+			}
+		}
+}
+
 // Space (3 space characters) between line numbers and text when printing.
 #define lineNumberPrintSpace "   "
 
@@ -1961,9 +2140,9 @@ long EditView::FormatRange(bool draw, Sci_RangeToFormat *pfr, Surface *surface,
 	// Modify the view style for printing as do not normally want any of the transient features to be printed
 	// Printing supports only the line number margin.
 	int lineNumberIndex = -1;
-	for (int margin = 0; margin <= SC_MAX_MARGIN; margin++) {
+	for (size_t margin = 0; margin < vs.ms.size(); margin++) {
 		if ((vsPrint.ms[margin].style == SC_MARGIN_NUMBER) && (vsPrint.ms[margin].width > 0)) {
-			lineNumberIndex = margin;
+			lineNumberIndex = static_cast<int>(margin);
 		} else {
 			vsPrint.ms[margin].width = 0;
 		}
diff --git a/src/stc/scintilla/src/EditView.h b/src/stc/scintilla/src/EditView.h
index 79a8865..8551daa 100644
--- a/src/stc/scintilla/src/EditView.h
+++ b/src/stc/scintilla/src/EditView.h
@@ -111,8 +111,10 @@ public:
 	void LayoutLine(const EditModel &model, int line, Surface *surface, const ViewStyle &vstyle,
 		LineLayout *ll, int width = LineLayout::wrapWidthInfinite);
 
-	Point LocationFromPosition(Surface *surface, const EditModel &model, SelectionPosition pos, int topLine, const ViewStyle &vs);
-	SelectionPosition SPositionFromLocation(Surface *surface, const EditModel &model, Point pt, bool canReturnInvalid,
+	Point LocationFromPosition(Surface *surface, const EditModel &model, SelectionPosition pos, int topLine,
+				   const ViewStyle &vs, PointEnd pe);
+	Range RangeDisplayLine(Surface *surface, const EditModel &model, int lineVisible, const ViewStyle &vs);
+	SelectionPosition SPositionFromLocation(Surface *surface, const EditModel &model, PointDocument pt, bool canReturnInvalid,
 		bool charPosition, bool virtualSpace, const ViewStyle &vs);
 	SelectionPosition SPositionFromLineX(Surface *surface, const EditModel &model, int lineDoc, int x, const ViewStyle &vs);
 	int DisplayFromPosition(Surface *surface, const EditModel &model, int pos, const ViewStyle &vs);
@@ -122,6 +124,8 @@ public:
 	void DrawEOL(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll, PRectangle rcLine,
 		int line, int lineEnd, int xStart, int subLine, XYACCUMULATOR subLineStart,
 		ColourOptional background);
+	void DrawFoldDisplayText(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
+		int line, int xStart, PRectangle rcLine, int subLine, XYACCUMULATOR subLineStart, DrawPhase phase);
 	void DrawAnnotation(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
 		int line, int xStart, PRectangle rcLine, int subLine, DrawPhase phase);
 	void DrawCarets(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll, int line,
@@ -138,6 +142,8 @@ public:
 		int lineVisible, int xStart, PRectangle rcLine, int subLine, DrawPhase phase);
 	void PaintText(Surface *surfaceWindow, const EditModel &model, PRectangle rcArea, PRectangle rcClient,
 		const ViewStyle &vsDraw);
+	void FillLineRemainder(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
+		int line, PRectangle rcArea, int subLine);
 	long FormatRange(bool draw, Sci_RangeToFormat *pfr, Surface *surface, Surface *surfaceMeasure,
 		const EditModel &model, const ViewStyle &vs);
 };
diff --git a/src/stc/scintilla/src/Editor.cxx b/src/stc/scintilla/src/Editor.cxx
index 1253996..8e4ebf1 100644
--- a/src/stc/scintilla/src/Editor.cxx
+++ b/src/stc/scintilla/src/Editor.cxx
@@ -112,6 +112,7 @@ Editor::Editor() {
 	hasFocus = false;
 	errorStatus = 0;
 	mouseDownCaptures = true;
+	mouseWheelCaptures = true;
 
 	lastClickTime = 0;
 	doubleClickCloseThreshold = Point(3, 3);
@@ -282,8 +283,8 @@ Point Editor::GetVisibleOriginInMain() const {
 	return Point(0,0);
 }
 
-Point Editor::DocumentPointFromView(Point ptView) const {
-	Point ptDocument = ptView;
+PointDocument Editor::DocumentPointFromView(Point ptView) const {
+	PointDocument ptDocument(ptView);
 	if (wMargin.GetID()) {
 		Point ptOrigin = GetVisibleOriginInMain();
 		ptDocument.x += ptOrigin.x;
@@ -362,14 +363,14 @@ SelectionPosition Editor::ClampPositionIntoDocument(SelectionPosition sp) const
 	}
 }
 
-Point Editor::LocationFromPosition(SelectionPosition pos) {
+Point Editor::LocationFromPosition(SelectionPosition pos, PointEnd pe) {
 	RefreshStyleData();
 	AutoSurface surface(this);
-	return view.LocationFromPosition(surface, *this, pos, topLine, vs);
+	return view.LocationFromPosition(surface, *this, pos, topLine, vs, pe);
 }
 
-Point Editor::LocationFromPosition(int pos) {
-	return LocationFromPosition(SelectionPosition(pos));
+Point Editor::LocationFromPosition(int pos, PointEnd pe) {
+	return LocationFromPosition(SelectionPosition(pos), pe);
 }
 
 int Editor::XFromPosition(int pos) {
@@ -398,8 +399,8 @@ SelectionPosition Editor::SPositionFromLocation(Point pt, bool canReturnInvalid,
 		if (pt.y < 0)
 			return SelectionPosition(INVALID_POSITION);
 	}
-	pt = DocumentPointFromView(pt);
-	return view.SPositionFromLocation(surface, *this, pt, canReturnInvalid, charPosition, virtualSpace, vs);
+	PointDocument ptdoc = DocumentPointFromView(pt);
+	return view.SPositionFromLocation(surface, *this, ptdoc, canReturnInvalid, charPosition, virtualSpace, vs);
 }
 
 int Editor::PositionFromLocation(Point pt, bool canReturnInvalid, bool charPosition) {
@@ -739,8 +740,8 @@ void Editor::MultipleSelectAdd(AddNumber addNumber) {
 			const int searchEnd = it->end;
 			for (;;) {
 				int lengthFound = static_cast<int>(selectedText.length());
-				int pos = pdoc->FindText(searchStart, searchEnd, selectedText.c_str(),
-					searchFlags, &lengthFound);
+				int pos = static_cast<int>(pdoc->FindText(searchStart, searchEnd,
+					selectedText.c_str(), searchFlags, &lengthFound));
 				if (pos >= 0) {
 					sel.AddSelection(SelectionRange(pos + lengthFound, pos));
 					ScrollRange(sel.RangeMain());
@@ -1837,15 +1838,26 @@ void Editor::ChangeSize() {
 	}
 }
 
-int Editor::InsertSpace(int position, unsigned int spaces) {
-	if (spaces > 0) {
-		std::string spaceText(spaces, ' ');
-		const int lengthInserted = pdoc->InsertString(position, spaceText.c_str(), spaces);
-		position += lengthInserted;
+int Editor::RealizeVirtualSpace(int position, unsigned int virtualSpace) {
+	if (virtualSpace > 0) {
+		const int line = pdoc->LineFromPosition(position);
+		const int indent = pdoc->GetLineIndentPosition(line);
+		if (indent == position) {
+			return pdoc->SetLineIndentation(line, pdoc->GetLineIndentation(line) + virtualSpace);
+		} else {
+			std::string spaceText(virtualSpace, ' ');
+			const int lengthInserted = pdoc->InsertString(position, spaceText.c_str(), virtualSpace);
+			position += lengthInserted;
+		}
 	}
 	return position;
 }
 
+SelectionPosition Editor::RealizeVirtualSpace(const SelectionPosition &position) {
+	// Return the new position with no virtual space
+	return SelectionPosition(RealizeVirtualSpace(position.Position(), position.VirtualSpace()));
+}
+
 void Editor::AddChar(char ch) {
 	char s[2];
 	s[0] = ch;
@@ -1901,7 +1913,7 @@ void Editor::AddCharUTF(const char *s, unsigned int len, bool treatAsDBCS) {
 						}
 					}
 				}
-				positionInsert = InsertSpace(positionInsert, currentSel->caret.VirtualSpace());
+				positionInsert = RealizeVirtualSpace(positionInsert, currentSel->caret.VirtualSpace());
 				const int lengthInserted = pdoc->InsertString(positionInsert, s, len);
 				if (lengthInserted > 0) {
 					currentSel->caret.SetPosition(positionInsert + lengthInserted);
@@ -1975,7 +1987,7 @@ void Editor::ClearBeforeTentativeStart() {
 					sel.Range(r).MinimizeVirtualSpace();
 				}
 			}
-			InsertSpace(positionInsert, sel.Range(r).caret.VirtualSpace());
+			RealizeVirtualSpace(positionInsert, sel.Range(r).caret.VirtualSpace());
 			sel.Range(r).ClearVirtualSpace();
 		}
 	}
@@ -1984,7 +1996,7 @@ void Editor::ClearBeforeTentativeStart() {
 void Editor::InsertPaste(const char *text, int len) {
 	if (multiPasteMode == SC_MULTIPASTE_ONCE) {
 		SelectionPosition selStart = sel.Start();
-		selStart = SelectionPosition(InsertSpace(selStart.Position(), selStart.VirtualSpace()));
+		selStart = RealizeVirtualSpace(selStart);
 		const int lengthInserted = pdoc->InsertString(selStart.Position(), text, len);
 		if (lengthInserted > 0) {
 			SetEmptySelection(selStart.Position() + lengthInserted);
@@ -2004,7 +2016,7 @@ void Editor::InsertPaste(const char *text, int len) {
 						sel.Range(r).MinimizeVirtualSpace();
 					}
 				}
-				positionInsert = InsertSpace(positionInsert, sel.Range(r).caret.VirtualSpace());
+				positionInsert = RealizeVirtualSpace(positionInsert, sel.Range(r).caret.VirtualSpace());
 				const int lengthInserted = pdoc->InsertString(positionInsert, text, len);
 				if (lengthInserted > 0) {
 					sel.Range(r).caret.SetPosition(positionInsert + lengthInserted);
@@ -2126,8 +2138,7 @@ void Editor::PasteRectangular(SelectionPosition pos, const char *ptr, int len) {
 	sel.RangeMain() = SelectionRange(pos);
 	int line = pdoc->LineFromPosition(sel.MainCaret());
 	UndoGroup ug(pdoc);
-	sel.RangeMain().caret = SelectionPosition(
-		InsertSpace(sel.RangeMain().caret.Position(), sel.RangeMain().caret.VirtualSpace()));
+	sel.RangeMain().caret = RealizeVirtualSpace(sel.RangeMain().caret);
 	int xInsert = XFromPosition(sel.RangeMain().caret);
 	bool prevCr = false;
 	while ((len > 0) && IsEOLChar(ptr[len-1]))
@@ -2179,9 +2190,9 @@ void Editor::Clear() {
 			if (!RangeContainsProtected(sel.Range(r).caret.Position(), sel.Range(r).caret.Position() + 1)) {
 				if (sel.Range(r).Start().VirtualSpace()) {
 					if (sel.Range(r).anchor < sel.Range(r).caret)
-						sel.Range(r) = SelectionRange(InsertSpace(sel.Range(r).anchor.Position(), sel.Range(r).anchor.VirtualSpace()));
+						sel.Range(r) = SelectionRange(RealizeVirtualSpace(sel.Range(r).anchor.Position(), sel.Range(r).anchor.VirtualSpace()));
 					else
-						sel.Range(r) = SelectionRange(InsertSpace(sel.Range(r).caret.Position(), sel.Range(r).caret.VirtualSpace()));
+						sel.Range(r) = SelectionRange(RealizeVirtualSpace(sel.Range(r).caret.Position(), sel.Range(r).caret.VirtualSpace()));
 				}
 				if ((sel.Count() == 1) || !pdoc->IsPositionInLineEnd(sel.Range(r).caret.Position())) {
 					pdoc->DelChar(sel.Range(r).caret.Position());
@@ -2413,13 +2424,7 @@ void Editor::NotifyIndicatorClick(bool click, int position, bool shift, bool ctr
 }
 
 bool Editor::NotifyMarginClick(Point pt, int modifiers) {
-	int marginClicked = -1;
-	int x = vs.textStart - vs.fixedColumnWidth;
-	for (int margin = 0; margin <= SC_MAX_MARGIN; margin++) {
-		if ((pt.x >= x) && (pt.x < x + vs.ms[margin].width))
-			marginClicked = margin;
-		x += vs.ms[margin].width;
-	}
+	const int marginClicked = vs.MarginFromLocation(pt);
 	if ((marginClicked >= 0) && vs.ms[marginClicked].sensitive) {
 		int position = pdoc->LineStart(LineFromLocation(pt));
 		if ((vs.ms[marginClicked].mask & SC_MASK_FOLDERS) && (foldAutomatic & SC_AUTOMATICFOLD_CLICK)) {
@@ -2460,6 +2465,22 @@ bool Editor::NotifyMarginClick(Point pt, bool shift, bool ctrl, bool alt) {
 	return NotifyMarginClick(pt, ModifierFlags(shift, ctrl, alt));
 }
 
+bool Editor::NotifyMarginRightClick(Point pt, int modifiers) {
+	int marginRightClicked = vs.MarginFromLocation(pt);
+	if ((marginRightClicked >= 0) && vs.ms[marginRightClicked].sensitive) {
+		int position = pdoc->LineStart(LineFromLocation(pt));
+		SCNotification scn = {};
+		scn.nmhdr.code = SCN_MARGINRIGHTCLICK;
+		scn.modifiers = modifiers;
+		scn.position = position;
+		scn.margin = marginRightClicked;
+		NotifyParent(scn);
+		return true;
+	} else {
+		return false;
+	}
+}
+
 void Editor::NotifyNeedShown(int pos, int len) {
 	SCNotification scn = {};
 	scn.nmhdr.code = SCN_NEEDSHOWN;
@@ -3145,6 +3166,12 @@ void Editor::ParaUpOrDown(int direction, Selection::selTypes selt) {
 	} while (!cs.GetVisible(lineDoc));
 }
 
+Range Editor::RangeDisplayLine(int lineVisible) {
+	RefreshStyleData();
+	AutoSurface surface(this);
+	return view.RangeDisplayLine(surface, *this, lineVisible, vs);
+}
+
 int Editor::StartEndDisplayLine(int pos, bool start) {
 	RefreshStyleData();
 	AutoSurface surface(this);
@@ -3283,7 +3310,7 @@ int Editor::HorizontalMove(unsigned int iMessage) {
 		case SCI_CHARLEFTRECTEXTEND:
 			if (pdoc->IsLineEndPosition(spCaret.Position()) && spCaret.VirtualSpace()) {
 				spCaret.SetVirtualSpace(spCaret.VirtualSpace() - 1);
-			} else {
+			} else if ((virtualSpaceOptions & SCVS_NOWRAPLINESTART) == 0 || pdoc->GetColumn(spCaret.Position()) > 0) {
 				spCaret = SelectionPosition(spCaret.Position() - 1);
 			}
 			break;
@@ -3309,13 +3336,13 @@ int Editor::HorizontalMove(unsigned int iMessage) {
 		sel.selType = Selection::selRectangle;
 		sel.Rectangular() = SelectionRange(spCaret, rangeBase.anchor);
 		SetRectangularRange();
+	} else if (sel.IsRectangular()) {
+		// Not a rectangular extension so switch to stream.
+		const SelectionPosition selAtLimit = 
+			(NaturalDirection(iMessage) > 0) ? sel.Limits().end : sel.Limits().start;
+		sel.selType = Selection::selStream;
+		sel.SetSelection(SelectionRange(selAtLimit));
 	} else {
-		if (sel.IsRectangular()) {
-			// Not a rectangular extension so switch to stream.
-			SelectionPosition selAtLimit = (NaturalDirection(iMessage) > 0) ? sel.Limits().end : sel.Limits().start;
-			sel.selType = Selection::selStream;
-			sel.SetSelection(SelectionRange(selAtLimit));
-		}
 		if (!additionalSelectionTyping) {
 			InvalidateWholeSelection();
 			sel.DropAdditionalRanges();
@@ -3328,7 +3355,7 @@ int Editor::HorizontalMove(unsigned int iMessage) {
 			case SCI_CHARLEFTEXTEND:
 				if (spCaret.VirtualSpace()) {
 					spCaret.SetVirtualSpace(spCaret.VirtualSpace() - 1);
-				} else {
+				} else if ((virtualSpaceOptions & SCVS_NOWRAPLINESTART) == 0 || pdoc->GetColumn(spCaret.Position()) > 0) {
 					spCaret = SelectionPosition(spCaret.Position() - 1);
 				}
 				break;
@@ -3411,7 +3438,7 @@ int Editor::HorizontalMove(unsigned int iMessage) {
 			const int directionMove = (spCaret < spCaretNow) ? -1 : 1;
 			spCaret = MovePositionSoVisible(spCaret, directionMove);
 
-			// Handle move versus extend, and special behaviour for non-emoty left/right
+			// Handle move versus extend, and special behaviour for non-empty left/right
 			switch (iMessage) {
 			case SCI_CHARLEFT:
 			case SCI_CHARRIGHT:
@@ -3504,7 +3531,7 @@ int Editor::DelWordOrLine(unsigned int iMessage) {
 		} else {
 			// Delete to the right so first realise the virtual space.
 			sel.Range(r) = SelectionRange(
-				InsertSpace(sel.Range(r).caret.Position(), sel.Range(r).caret.VirtualSpace()));
+				RealizeVirtualSpace(sel.Range(r).caret));
 		}
 
 		Range rangeDelete;
@@ -3921,7 +3948,7 @@ CaseFolder *Editor::CaseFolderForEncoding() {
 long Editor::FindText(
     uptr_t wParam,		///< Search modes : @c SCFIND_MATCHCASE, @c SCFIND_WHOLEWORD,
     ///< @c SCFIND_WORDSTART, @c SCFIND_REGEXP or @c SCFIND_POSIX.
-    sptr_t lParam) {	///< @c TextToFind structure: The text to search for in the given range.
+    sptr_t lParam) {	///< @c Sci_TextToFind structure: The text to search for in the given range.
 
 	Sci_TextToFind *ft = reinterpret_cast<Sci_TextToFind *>(lParam);
 	int lengthFound = istrlen(ft->lpstrText);
@@ -4208,7 +4235,7 @@ void Editor::DropAt(SelectionPosition position, const char *value, size_t length
 			SetEmptySelection(position);
 		} else {
 			position = MovePositionOutsideChar(position, sel.MainCaret() - position.Position());
-			position = SelectionPosition(InsertSpace(position.Position(), position.VirtualSpace()));
+			position = RealizeVirtualSpace(position);
 			const int lengthInserted = pdoc->InsertString(
 				position.Position(), convertedText.c_str(), static_cast<int>(convertedText.length()));
 			if (lengthInserted > 0) {
@@ -4278,7 +4305,7 @@ bool Editor::PointInSelMargin(Point pt) const {
 
 Window::Cursor Editor::GetMarginCursor(Point pt) const {
 	int x = 0;
-	for (int margin = 0; margin <= SC_MAX_MARGIN; margin++) {
+	for (size_t margin = 0; margin < vs.ms.size(); margin++) {
 		if ((pt.x >= x) && (pt.x < x + vs.ms[margin].width))
 			return static_cast<Window::Cursor>(vs.ms[margin].cursor);
 		x += vs.ms[margin].width;
@@ -4487,6 +4514,10 @@ void Editor::ButtonDownWithModifiers(Point pt, unsigned int curTime, int modifie
 		}
 	} else {	// Single click
 		if (inSelMargin) {
+			if (sel.IsRectangular() || (sel.Count() > 1)) {
+				InvalidateWholeSelection();
+				sel.Clear();
+			}
 			sel.selType = Selection::selStream;
 			if (!shift) {
 				// Single click in margin: select whole line or only subline if word wrap is enabled
@@ -4563,6 +4594,11 @@ void Editor::ButtonDownWithModifiers(Point pt, unsigned int curTime, int modifie
 	ShowCaretAtCurrentPosition();
 }
 
+void Editor::RightButtonDownWithModifiers(Point pt, unsigned int, int modifiers) {
+	if (NotifyMarginRightClick(pt, modifiers))
+		return;
+}
+
 void Editor::ButtonDown(Point pt, unsigned int curTime, bool shift, bool ctrl, bool alt) {
 	return ButtonDownWithModifiers(pt, curTime, ModifierFlags(shift, ctrl, alt));
 }
@@ -5293,6 +5329,9 @@ void Editor::FoldExpand(int line, int action, int level) {
 	if (action == SC_FOLDACTION_TOGGLE) {
 		expanding = !cs.GetExpanded(line);
 	}
+	// Ensure child lines lexed and fold information extracted before
+	// flipping the state.
+	pdoc->GetLastChild(line, LevelNumber(level));
 	SetFoldExpanded(line, expanding);
 	if (expanding && (cs.HiddenLines() == 0))
 		// Nothing to do
@@ -5555,8 +5594,8 @@ void Editor::AddStyledText(char *buffer, int appendLength) {
 	SetEmptySelection(sel.MainCaret() + lengthInserted);
 }
 
-static bool ValidMargin(uptr_t wParam) {
-	return wParam <= SC_MAX_MARGIN;
+bool Editor::ValidMargin(uptr_t wParam) const {
+	return wParam < vs.ms.size();
 }
 
 static char *CharPtrFromSPtr(sptr_t lParam) {
@@ -5655,6 +5694,39 @@ sptr_t Editor::StyleGetMessage(unsigned int iMessage, uptr_t wParam, sptr_t lPar
 	return 0;
 }
 
+void Editor::SetSelectionNMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
+	InvalidateRange(sel.Range(wParam).Start().Position(), sel.Range(wParam).End().Position());
+
+	switch (iMessage) {
+	case SCI_SETSELECTIONNCARET:
+		sel.Range(wParam).caret.SetPosition(static_cast<int>(lParam));
+		break;
+
+	case SCI_SETSELECTIONNANCHOR:
+		sel.Range(wParam).anchor.SetPosition(static_cast<int>(lParam));
+		break;
+
+	case SCI_SETSELECTIONNCARETVIRTUALSPACE:
+		sel.Range(wParam).caret.SetVirtualSpace(static_cast<int>(lParam));
+		break;
+
+	case SCI_SETSELECTIONNANCHORVIRTUALSPACE:
+		sel.Range(wParam).anchor.SetVirtualSpace(static_cast<int>(lParam));
+		break;
+
+	case SCI_SETSELECTIONNSTART:
+		sel.Range(wParam).anchor.SetPosition(static_cast<int>(lParam));
+		break;
+
+	case SCI_SETSELECTIONNEND:
+		sel.Range(wParam).caret.SetPosition(static_cast<int>(lParam));
+		break;
+	}
+
+	InvalidateRange(sel.Range(wParam).Start().Position(), sel.Range(wParam).End().Position());
+	ContainerNeedsUpdate(SC_UPDATE_SELECTION);
+}
+
 sptr_t Editor::StringResult(sptr_t lParam, const char *val) {
 	const size_t len = val ? strlen(val) : 0;
 	if (lParam) {
@@ -6270,6 +6342,14 @@ sptr_t Editor::WndProc(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
 		Redraw();
 		break;
 
+	case SCI_GETTABDRAWMODE:
+		return vs.tabDrawMode;
+
+	case SCI_SETTABDRAWMODE:
+		vs.tabDrawMode = static_cast<TabDrawMode>(wParam);
+		Redraw();
+		break;
+
 	case SCI_GETWHITESPACESIZE:
 		return vs.whitespaceSize;
 
@@ -6690,15 +6770,6 @@ sptr_t Editor::WndProc(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
 	case SCI_GETIMEINTERACTION:
 		return imeInteraction;
 
-#ifdef INCLUDE_DEPRECATED_FEATURES
-	case SCI_SETUSEPALETTE:
-		InvalidateStyleRedraw();
-		break;
-
-	case SCI_GETUSEPALETTE:
-		return 0;
-#endif
-
 		// Marker definition and setting
 	case SCI_MARKERDEFINE:
 		if (wParam <= MARKER_MAX) {
@@ -6870,6 +6941,27 @@ sptr_t Editor::WndProc(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
 		else
 			return 0;
 
+	case SCI_SETMARGINBACKN:
+		if (ValidMargin(wParam)) {
+			vs.ms[wParam].back = ColourDesired(static_cast<long>(lParam));
+			InvalidateStyleRedraw();
+		}
+		break;
+
+	case SCI_GETMARGINBACKN:
+		if (ValidMargin(wParam))
+			return vs.ms[wParam].back.AsLong();
+		else
+			return 0;
+
+	case SCI_SETMARGINS:
+		if (wParam < 1000)
+			vs.ms.resize(wParam);
+		break;
+
+	case SCI_GETMARGINS:
+		return vs.ms.size();
+
 	case SCI_STYLECLEARALL:
 		vs.ClearStyles();
 		InvalidateStyleRedraw();
@@ -7021,6 +7113,16 @@ sptr_t Editor::WndProc(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
 		Redraw();
 		break;
 
+	case SCI_TOGGLEFOLDSHOWTEXT:
+		cs.SetFoldDisplayText(static_cast<int>(wParam), CharPtrFromSPtr(lParam));
+		FoldLine(static_cast<int>(wParam), SC_FOLDACTION_TOGGLE);
+		break;
+
+	case SCI_FOLDDISPLAYTEXTSETSTYLE:
+		foldDisplayTextStyle = static_cast<int>(wParam);
+		Redraw();
+		break;
+
 	case SCI_TOGGLEFOLD:
 		FoldLine(static_cast<int>(wParam), SC_FOLDACTION_TOGGLE);
 		break;
@@ -7420,10 +7522,10 @@ sptr_t Editor::WndProc(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
 		return vs.zoomLevel;
 
 	case SCI_GETEDGECOLUMN:
-		return vs.theEdge;
+		return vs.theEdge.column;
 
 	case SCI_SETEDGECOLUMN:
-		vs.theEdge = static_cast<int>(wParam);
+		vs.theEdge.column = static_cast<int>(wParam);
 		InvalidateStyleRedraw();
 		break;
 
@@ -7436,10 +7538,20 @@ sptr_t Editor::WndProc(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
 		break;
 
 	case SCI_GETEDGECOLOUR:
-		return vs.edgecolour.AsLong();
+		return vs.theEdge.colour.AsLong();
 
 	case SCI_SETEDGECOLOUR:
-		vs.edgecolour = ColourDesired(static_cast<long>(wParam));
+		vs.theEdge.colour = ColourDesired(static_cast<long>(wParam));
+		InvalidateStyleRedraw();
+		break;
+
+	case SCI_MULTIEDGEADDLINE:
+		vs.theMultiEdge.push_back(EdgeProperties(wParam, lParam));
+		InvalidateStyleRedraw();
+		break;
+
+	case SCI_MULTIEDGECLEARALL:
+		std::vector<EdgeProperties>().swap(vs.theMultiEdge); // Free vector and memory, C++03 compatible
 		InvalidateStyleRedraw();
 		break;
 
@@ -7571,6 +7683,13 @@ sptr_t Editor::WndProc(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
 	case SCI_GETMOUSEDOWNCAPTURES:
 		return mouseDownCaptures;
 
+	case SCI_SETMOUSEWHEELCAPTURES:
+		mouseWheelCaptures = wParam != 0;
+		break;
+
+	case SCI_GETMOUSEWHEELCAPTURES:
+		return mouseWheelCaptures;
+
 	case SCI_SETCURSOR:
 		cursorMode = static_cast<int>(wParam);
 		DisplayCursor(Window::cursorText);
@@ -7881,55 +8000,29 @@ sptr_t Editor::WndProc(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
 		return sel.Main();
 
 	case SCI_SETSELECTIONNCARET:
-		sel.Range(wParam).caret.SetPosition(static_cast<int>(lParam));
-		ContainerNeedsUpdate(SC_UPDATE_SELECTION);
-		Redraw();
+	case SCI_SETSELECTIONNANCHOR:
+	case SCI_SETSELECTIONNCARETVIRTUALSPACE:
+	case SCI_SETSELECTIONNANCHORVIRTUALSPACE:
+	case SCI_SETSELECTIONNSTART:
+	case SCI_SETSELECTIONNEND:
+		SetSelectionNMessage(iMessage, wParam, lParam);
 		break;
 
 	case SCI_GETSELECTIONNCARET:
 		return sel.Range(wParam).caret.Position();
 
-	case SCI_SETSELECTIONNANCHOR:
-		sel.Range(wParam).anchor.SetPosition(static_cast<int>(lParam));
-		ContainerNeedsUpdate(SC_UPDATE_SELECTION);
-		Redraw();
-		break;
 	case SCI_GETSELECTIONNANCHOR:
 		return sel.Range(wParam).anchor.Position();
 
-	case SCI_SETSELECTIONNCARETVIRTUALSPACE:
-		sel.Range(wParam).caret.SetVirtualSpace(static_cast<int>(lParam));
-		ContainerNeedsUpdate(SC_UPDATE_SELECTION);
-		Redraw();
-		break;
-
 	case SCI_GETSELECTIONNCARETVIRTUALSPACE:
 		return sel.Range(wParam).caret.VirtualSpace();
 
-	case SCI_SETSELECTIONNANCHORVIRTUALSPACE:
-		sel.Range(wParam).anchor.SetVirtualSpace(static_cast<int>(lParam));
-		ContainerNeedsUpdate(SC_UPDATE_SELECTION);
-		Redraw();
-		break;
-
 	case SCI_GETSELECTIONNANCHORVIRTUALSPACE:
 		return sel.Range(wParam).anchor.VirtualSpace();
 
-	case SCI_SETSELECTIONNSTART:
-		sel.Range(wParam).anchor.SetPosition(static_cast<int>(lParam));
-		ContainerNeedsUpdate(SC_UPDATE_SELECTION);
-		Redraw();
-		break;
-
 	case SCI_GETSELECTIONNSTART:
 		return sel.Range(wParam).Start().Position();
 
-	case SCI_SETSELECTIONNEND:
-		sel.Range(wParam).caret.SetPosition(static_cast<int>(lParam));
-		ContainerNeedsUpdate(SC_UPDATE_SELECTION);
-		Redraw();
-		break;
-
 	case SCI_GETSELECTIONNEND:
 		return sel.Range(wParam).End().Position();
 
diff --git a/src/stc/scintilla/src/Editor.h b/src/stc/scintilla/src/Editor.h
index 93a86fa..864bac9 100644
--- a/src/stc/scintilla/src/Editor.h
+++ b/src/stc/scintilla/src/Editor.h
@@ -176,6 +176,7 @@ protected:	// ScintillaBase subclass needs access to much of Editor
 
 	bool hasFocus;
 	bool mouseDownCaptures;
+	bool mouseWheelCaptures;
 
 	int xCaretMargin;	///< Ensure this many pixels visible on both sides of caret
 	bool horizontalScrollBarVisible;
@@ -274,7 +275,7 @@ protected:	// ScintillaBase subclass needs access to much of Editor
 	// The top left visible point in main window coordinates. Will be 0,0 except for
 	// scroll views where it will be equivalent to the current scroll position.
 	virtual Point GetVisibleOriginInMain() const;
-	Point DocumentPointFromView(Point ptView) const;  // Convert a point from view space to document
+	PointDocument DocumentPointFromView(Point ptView) const;  // Convert a point from view space to document
 	int TopLineOfMain() const;   // Return the line at Main's y coordinate 0
 	virtual PRectangle GetClientRectangle() const;
 	virtual PRectangle GetClientDrawingRectangle();
@@ -284,8 +285,8 @@ protected:	// ScintillaBase subclass needs access to much of Editor
 	int LinesToScroll() const;
 	int MaxScrollPos() const;
 	SelectionPosition ClampPositionIntoDocument(SelectionPosition sp) const;
-	Point LocationFromPosition(SelectionPosition pos);
-	Point LocationFromPosition(int pos);
+	Point LocationFromPosition(SelectionPosition pos, PointEnd pe=peDefault);
+	Point LocationFromPosition(int pos, PointEnd pe=peDefault);
 	int XFromPosition(int pos);
 	int XFromPosition(SelectionPosition sp);
 	SelectionPosition SPositionFromLocation(Point pt, bool canReturnInvalid=false, bool charPosition=false, bool virtualSpace=true);
@@ -390,7 +391,8 @@ protected:	// ScintillaBase subclass needs access to much of Editor
 	void ChangeSize();
 
 	void FilterSelections();
-	int InsertSpace(int position, unsigned int spaces);
+	int RealizeVirtualSpace(int position, unsigned int virtualSpace);
+	SelectionPosition RealizeVirtualSpace(const SelectionPosition &position);
 	void AddChar(char ch);
 	virtual void AddCharUTF(const char *s, unsigned int len, bool treatAsDBCS=false);
 	void ClearBeforeTentativeStart();
@@ -437,6 +439,7 @@ protected:	// ScintillaBase subclass needs access to much of Editor
 	void NotifyIndicatorClick(bool click, int position, bool shift, bool ctrl, bool alt);
 	bool NotifyMarginClick(Point pt, int modifiers);
 	bool NotifyMarginClick(Point pt, bool shift, bool ctrl, bool alt);
+	bool NotifyMarginRightClick(Point pt, int modifiers);
 	void NotifyNeedShown(int pos, int len);
 	void NotifyDwelling(Point pt, bool state);
 	void NotifyZoom();
@@ -463,6 +466,7 @@ protected:	// ScintillaBase subclass needs access to much of Editor
 	SelectionPosition PositionUpOrDown(SelectionPosition spStart, int direction, int lastX);
 	void CursorUpOrDown(int direction, Selection::selTypes selt);
 	void ParaUpOrDown(int direction, Selection::selTypes selt);
+	Range RangeDisplayLine(int lineVisible);
 	int StartEndDisplayLine(int pos, bool start);
 	int VCHomeDisplayPosition(int position);
 	int VCHomeWrapPosition(int position);
@@ -505,6 +509,7 @@ protected:	// ScintillaBase subclass needs access to much of Editor
 	void DwellEnd(bool mouseMoved);
 	void MouseLeave();
 	virtual void ButtonDownWithModifiers(Point pt, unsigned int curTime, int modifiers);
+	virtual void RightButtonDownWithModifiers(Point pt, unsigned int curTime, int modifiers);
 	virtual void ButtonDown(Point pt, unsigned int curTime, bool shift, bool ctrl, bool alt);
 	void ButtonMoveWithModifiers(Point pt, int modifiers);
 	void ButtonMove(Point pt);
@@ -569,8 +574,10 @@ protected:	// ScintillaBase subclass needs access to much of Editor
 	void AddStyledText(char *buffer, int appendLength);
 
 	virtual sptr_t DefWndProc(unsigned int iMessage, uptr_t wParam, sptr_t lParam) = 0;
+	bool ValidMargin(uptr_t wParam) const;
 	void StyleSetMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
 	sptr_t StyleGetMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
+	void SetSelectionNMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
 
 	static const char *StringFromEOLMode(int eolMode);
 
diff --git a/src/stc/scintilla/src/Indicator.cxx b/src/stc/scintilla/src/Indicator.cxx
index 4bc25a8..c23ae4e 100644
--- a/src/stc/scintilla/src/Indicator.cxx
+++ b/src/stc/scintilla/src/Indicator.cxx
@@ -24,7 +24,7 @@ static PRectangle PixelGridAlign(const PRectangle &rc) {
 	return PRectangle::FromInts(int(rc.left + 0.5), int(rc.top), int(rc.right + 0.5), int(rc.bottom));
 }
 
-void Indicator::Draw(Surface *surface, const PRectangle &rc, const PRectangle &rcLine, DrawState drawState, int value) const {
+void Indicator::Draw(Surface *surface, const PRectangle &rc, const PRectangle &rcLine, const PRectangle &rcCharacter, DrawState drawState, int value) const {
 	StyleAndColour sacDraw = sacNormal;
 	if (Flags() & SC_INDICFLAG_VALUEFORE) {
 		sacDraw.fore = value & SC_INDICVALUEMASK;
@@ -170,6 +170,19 @@ void Indicator::Draw(Surface *surface, const PRectangle &rc, const PRectangle &r
 	} else if (sacDraw.style == INDIC_COMPOSITIONTHIN) {
 		PRectangle rcComposition(rc.left+1, rcLine.bottom-2, rc.right-1, rcLine.bottom-1);
 		surface->FillRectangle(rcComposition, sacDraw.fore);
+	} else if (sacDraw.style == INDIC_POINT || sacDraw.style == INDIC_POINTCHARACTER) {
+		if (rcCharacter.Width() >= 0.1) {
+			const int pixelHeight = static_cast<int>(rc.Height() - 1.0f);	// 1 pixel onto next line if multiphase
+			const XYPOSITION x = (sacDraw.style == INDIC_POINT) ? (rcCharacter.left) : ((rcCharacter.right + rcCharacter.left) / 2);
+			const int ix = static_cast<int>(x + 0.5f);
+			const int iy = static_cast<int>(rc.top + 1.0f);
+			Point pts[] = {
+				Point::FromInts(ix - pixelHeight, iy + pixelHeight),	// Left
+				Point::FromInts(ix + pixelHeight, iy + pixelHeight),	// Right
+				Point::FromInts(ix, iy)									// Top
+			};
+			surface->Polygon(pts, 3, sacDraw.fore, sacDraw.fore);
+		}
 	} else {	// Either INDIC_PLAIN or unknown
 		surface->MoveTo(static_cast<int>(rc.left), ymid);
 		surface->LineTo(static_cast<int>(rc.right), ymid);
diff --git a/src/stc/scintilla/src/Indicator.h b/src/stc/scintilla/src/Indicator.h
index c22ec71..9b887df 100644
--- a/src/stc/scintilla/src/Indicator.h
+++ b/src/stc/scintilla/src/Indicator.h
@@ -40,7 +40,7 @@ public:
 	Indicator(int style_, ColourDesired fore_=ColourDesired(0,0,0), bool under_=false, int fillAlpha_=30, int outlineAlpha_=50) :
 		sacNormal(style_, fore_), sacHover(style_, fore_), under(under_), fillAlpha(fillAlpha_), outlineAlpha(outlineAlpha_), attributes(0) {
 	}
-	void Draw(Surface *surface, const PRectangle &rc, const PRectangle &rcLine, DrawState drawState, int value) const;
+	void Draw(Surface *surface, const PRectangle &rc, const PRectangle &rcLine, const PRectangle &rcCharacter, DrawState drawState, int value) const;
 	bool IsDynamic() const {
 		return !(sacNormal == sacHover);
 	}
diff --git a/src/stc/scintilla/src/MarginView.cxx b/src/stc/scintilla/src/MarginView.cxx
index 52a2cb2..3ec70f0 100644
--- a/src/stc/scintilla/src/MarginView.cxx
+++ b/src/stc/scintilla/src/MarginView.cxx
@@ -193,7 +193,7 @@ void MarginView::PaintMargin(Surface *surface, int topLine, PRectangle rc, PRect
 
 	Point ptOrigin = model.GetVisibleOriginInMain();
 	FontAlias fontLineNumber = vs.styles[STYLE_LINENUMBER].font;
-	for (int margin = 0; margin <= SC_MAX_MARGIN; margin++) {
+	for (size_t margin = 0; margin < vs.ms.size(); margin++) {
 		if (vs.ms[margin].width > 0) {
 
 			rcSelMargin.left = rcSelMargin.right;
@@ -216,6 +216,9 @@ void MarginView::PaintMargin(Surface *surface, int topLine, PRectangle rc, PRect
 					case SC_MARGIN_FORE:
 						colour = vs.styles[STYLE_DEFAULT].fore;
 						break;
+					case SC_MARGIN_COLOUR:
+						colour = vs.ms[margin].back;
+						break;
 					default:
 						colour = vs.styles[STYLE_LINENUMBER].back;
 						break;
diff --git a/src/stc/scintilla/src/PositionCache.cxx b/src/stc/scintilla/src/PositionCache.cxx
index 997a4bf..4573160 100644
--- a/src/stc/scintilla/src/PositionCache.cxx
+++ b/src/stc/scintilla/src/PositionCache.cxx
@@ -217,7 +217,7 @@ int LineLayout::FindPositionFromX(XYPOSITION x, Range range, bool charPosition)
 	return range.end;
 }
 
-Point LineLayout::PointFromPosition(int posInLine, int lineHeight) const {
+Point LineLayout::PointFromPosition(int posInLine, int lineHeight, PointEnd pe) const {
 	Point pt;
 	// In case of very long line put x at arbitrary large position
 	if (posInLine > maxLineLength) {
@@ -232,6 +232,12 @@ Point LineLayout::PointFromPosition(int posInLine, int lineHeight) const {
 				pt.x = positions[posInLine] - positions[rangeSubLine.start];
 				if (rangeSubLine.start != 0)	// Wrapped lines may be indented
 					pt.x += wrapIndent;
+				if (pe & peSubLineEnd)	// Return end of first subline not start of next
+					break;
+			} else if ((pe & peLineEnd) && (subLine == (lines-1))) {
+				pt.x = positions[numCharsInLine] - positions[rangeSubLine.start];
+				if (rangeSubLine.start != 0)	// Wrapped lines may be indented
+					pt.x += wrapIndent;
 			}
 		} else {
 			break;
diff --git a/src/stc/scintilla/src/PositionCache.h b/src/stc/scintilla/src/PositionCache.h
index edc0a5d..c0d2b7f 100644
--- a/src/stc/scintilla/src/PositionCache.h
+++ b/src/stc/scintilla/src/PositionCache.h
@@ -17,6 +17,32 @@ static inline bool IsEOLChar(char ch) {
 }
 
 /**
+* A point in document space.
+* Uses double for sufficient resolution in large (>20,000,000 line) documents.
+*/
+class PointDocument {
+public:
+	double x;
+	double y;
+
+	explicit PointDocument(double x_ = 0, double y_ = 0) : x(x_), y(y_) {
+	}
+
+	// Conversion from Point.
+	explicit PointDocument(Point pt) : x(pt.x), y(pt.y) {
+	}
+};
+
+// There are two points for some positions and this enumeration
+// can choose between the end of the first line or subline
+// and the start of the next line or subline.
+enum PointEnd {
+	peDefault = 0x0,
+	peLineEnd = 0x1,
+	peSubLineEnd = 0x2
+};
+
+/**
  */
 class LineLayout {
 private:
@@ -28,6 +54,7 @@ private:
 	bool inCache;
 public:
 	enum { wrapWidthInfinite = 0x7ffffff };
+
 	int maxLineLength;
 	int numCharsInLine;
 	int numCharsBeforeEOL;
@@ -64,7 +91,7 @@ public:
 	void RestoreBracesHighlight(Range rangeLine, const Position braces[], bool ignoreStyle);
 	int FindBefore(XYPOSITION x, int lower, int upper) const;
 	int FindPositionFromX(XYPOSITION x, Range range, bool charPosition) const;
-	Point PointFromPosition(int posInLine, int lineHeight) const;
+	Point PointFromPosition(int posInLine, int lineHeight, PointEnd pe) const;
 	int EndLineStyle() const;
 };
 
diff --git a/src/stc/scintilla/src/ScintillaBase.cxx b/src/stc/scintilla/src/ScintillaBase.cxx
index b6e2fb3..08b9fe8 100644
--- a/src/stc/scintilla/src/ScintillaBase.cxx
+++ b/src/stc/scintilla/src/ScintillaBase.cxx
@@ -64,7 +64,7 @@ using namespace Scintilla;
 #endif
 
 ScintillaBase::ScintillaBase() {
-	displayPopupMenu = true;
+	displayPopupMenu = SC_POPUP_ALL;
 	listType = 0;
 	maxListWidth = 0;
 	multiAutoCMode = SC_MULTIAUTOC_ONCE;
@@ -218,7 +218,7 @@ void ScintillaBase::AutoCompleteInsert(Position startPos, int removeLen, const c
 			if (!RangeContainsProtected(sel.Range(r).Start().Position(),
 				sel.Range(r).End().Position())) {
 				int positionInsert = sel.Range(r).Start().Position();
-				positionInsert = InsertSpace(positionInsert, sel.Range(r).caret.VirtualSpace());
+				positionInsert = RealizeVirtualSpace(positionInsert, sel.Range(r).caret.VirtualSpace());
 				if (positionInsert - removeLen >= 0) {
 					positionInsert -= removeLen;
 					pdoc->DeleteChars(positionInsert, removeLen);
@@ -478,6 +478,11 @@ void ScintillaBase::CallTipClick() {
 	NotifyParent(scn);
 }
 
+bool ScintillaBase::ShouldDisplayPopup(Point ptInWindowCoordinates) const {
+	return (displayPopupMenu == SC_POPUP_ALL ||
+		(displayPopupMenu == SC_POPUP_TEXT && !PointInSelMargin(ptInWindowCoordinates)));
+}
+
 void ScintillaBase::ContextMenu(Point pt) {
 	if (displayPopupMenu) {
 		bool writable = !WndProc(SCI_GETREADONLY, 0, 0);
@@ -510,6 +515,11 @@ void ScintillaBase::ButtonDown(Point pt, unsigned int curTime, bool shift, bool
 	ButtonDownWithModifiers(pt, curTime, ModifierFlags(shift, ctrl, alt));
 }
 
+void ScintillaBase::RightButtonDownWithModifiers(Point pt, unsigned int curTime, int modifiers) {
+	CancelModes();
+	Editor::RightButtonDownWithModifiers(pt, curTime, modifiers);
+}
+
 #ifdef SCI_LEXER
 
 #ifdef SCI_NAMESPACE
@@ -970,7 +980,7 @@ sptr_t ScintillaBase::WndProc(unsigned int iMessage, uptr_t wParam, sptr_t lPara
 		break;
 
 	case SCI_USEPOPUP:
-		displayPopupMenu = wParam != 0;
+		displayPopupMenu = static_cast<int>(wParam);
 		break;
 
 #ifdef SCI_LEXER
diff --git a/src/stc/scintilla/src/ScintillaBase.h b/src/stc/scintilla/src/ScintillaBase.h
index 4bdf24e..e664033 100644
--- a/src/stc/scintilla/src/ScintillaBase.h
+++ b/src/stc/scintilla/src/ScintillaBase.h
@@ -40,7 +40,7 @@ protected:
 
 	enum { maxLenInputIME = 200 };
 
-	bool displayPopupMenu;
+	int displayPopupMenu;
 	Menu popup;
 	AutoComplete ac;
 
@@ -84,10 +84,12 @@ protected:
 	virtual void CreateCallTipWindow(PRectangle rc) = 0;
 
 	virtual void AddToPopUp(const char *label, int cmd=0, bool enabled=true) = 0;
+	bool ShouldDisplayPopup(Point ptInWindowCoordinates) const;
 	void ContextMenu(Point pt);
 
 	virtual void ButtonDownWithModifiers(Point pt, unsigned int curTime, int modifiers);
 	virtual void ButtonDown(Point pt, unsigned int curTime, bool shift, bool ctrl, bool alt);
+	virtual void RightButtonDownWithModifiers(Point pt, unsigned int curTime, int modifiers);
 
 	void NotifyStyleToNeeded(int endStyleNeeded);
 	void NotifyLexerChanged(Document *doc, void *userData);
diff --git a/src/stc/scintilla/src/SparseVector.h b/src/stc/scintilla/src/SparseVector.h
new file mode 100644
index 0000000..f96b36b
--- /dev/null
+++ b/src/stc/scintilla/src/SparseVector.h
@@ -0,0 +1,186 @@
+// Scintilla source code edit control
+/** @file SparseVector.h
+ ** Hold data sparsely associated with elements in a range.
+ **/
+// Copyright 2016 by Neil Hodgson <neilh@scintilla.org>
+// The License.txt file describes the conditions under which this software may be distributed.
+
+#ifndef SPARSEVECTOR_H
+#define SPARSEVECTOR_H
+
+#ifdef SCI_NAMESPACE
+namespace Scintilla {
+#endif
+
+// SparseVector is similar to RunStyles but is more efficient for cases where values occur
+// for one position instead of over a range of positions.
+template <typename T>
+class SparseVector {
+private:
+	Partitioning *starts;
+	SplitVector<T> *values;
+	// Private so SparseVector objects can not be copied
+	SparseVector(const SparseVector &);
+	void ClearValue(int partition) {
+		values->SetValueAt(partition, T());
+	}
+	void CommonSetValueAt(int position, T value) {
+		// Do the work of setting the value to allow for specialization of SetValueAt.
+		assert(position < Length());
+		const int partition = starts->PartitionFromPosition(position);
+		const int startPartition = starts->PositionFromPartition(partition);
+		if (value == T()) {
+			// Setting the empty value is equivalent to deleting the position
+			if (position == 0) {
+				ClearValue(partition);
+			} else if (position == startPartition) {
+				// Currently an element at this position, so remove
+				ClearValue(partition);
+				starts->RemovePartition(partition);
+				values->Delete(partition);
+			}
+			// Else element remains empty
+		} else {
+			if (position == startPartition) {
+				// Already a value at this position, so replace
+				ClearValue(partition);
+				values->SetValueAt(partition, value);
+			} else {
+				// Insert a new element
+				starts->InsertPartition(partition + 1, position);
+				values->InsertValue(partition + 1, 1, value);
+			}
+		}
+	}
+public:
+	SparseVector() {
+		starts = new Partitioning(8);
+		values = new SplitVector<T>();
+		values->InsertValue(0, 2, T());
+	}
+	~SparseVector() {
+		delete starts;
+		starts = NULL;
+		// starts dead here but not used by ClearValue.
+		for (int part = 0; part < values->Length(); part++) {
+			ClearValue(part);
+		}
+		delete values;
+		values = NULL;
+	}
+	int Length() const {
+		return starts->PositionFromPartition(starts->Partitions());
+	}
+	int Elements() const {
+		return starts->Partitions();
+	}
+	int PositionOfElement(int element) const {
+		return starts->PositionFromPartition(element);
+	}
+	T ValueAt(int position) const {
+		assert(position < Length());
+		const int partition = starts->PartitionFromPosition(position);
+		const int startPartition = starts->PositionFromPartition(partition);
+		if (startPartition == position) {
+			return values->ValueAt(partition);
+		} else {
+			return T();
+		}
+	}
+	void SetValueAt(int position, T value) {
+		CommonSetValueAt(position, value);
+	}
+	void InsertSpace(int position, int insertLength) {
+		assert(position <= Length());	// Only operation that works at end.
+		const int partition = starts->PartitionFromPosition(position);
+		const int startPartition = starts->PositionFromPartition(partition);
+		if (startPartition == position) {
+			T valueCurrent = values->ValueAt(partition);
+			// Inserting at start of run so make previous longer
+			if (partition == 0) {
+				// Inserting at start of document so ensure 0
+				if (valueCurrent != T()) {
+					ClearValue(0);
+					starts->InsertPartition(1, 0);
+					values->InsertValue(1, 1, valueCurrent);
+					starts->InsertText(0, insertLength);
+				} else {
+					starts->InsertText(partition, insertLength);
+				}
+			} else {
+				if (valueCurrent != T()) {
+					starts->InsertText(partition - 1, insertLength);
+				} else {
+					// Insert at end of run so do not extend style
+					starts->InsertText(partition, insertLength);
+				}
+			}
+		} else {
+			starts->InsertText(partition, insertLength);
+		}
+	}
+	void DeletePosition(int position) {
+		assert(position < Length());
+		int partition = starts->PartitionFromPosition(position);
+		const int startPartition = starts->PositionFromPartition(partition);
+		if (startPartition == position) {
+			if (partition == 0) {
+				ClearValue(0);
+			} else if (partition == starts->Partitions()) {
+				// This should not be possible
+				ClearValue(partition);
+				throw std::runtime_error("SparseVector: deleting end partition.");
+			} else {
+				ClearValue(partition);
+				starts->RemovePartition(partition);
+				values->Delete(partition);
+				// Its the previous partition now that gets smaller 
+				partition--;
+			}
+		}
+		starts->InsertText(partition, -1);
+	}
+	void Check() const {
+		if (Length() < 0) {
+			throw std::runtime_error("SparseVector: Length can not be negative.");
+		}
+		if (starts->Partitions() < 1) {
+			throw std::runtime_error("SparseVector: Must always have 1 or more partitions.");
+		}
+		if (starts->Partitions() != values->Length() - 1) {
+			throw std::runtime_error("SparseVector: Partitions and values different lengths.");
+		}
+		// The final element can not be set
+		if (values->ValueAt(values->Length() - 1) != T()) {
+			throw std::runtime_error("SparseVector: Unused style at end changed.");
+		}
+	}
+};
+
+// The specialization for const char * makes copies and deletes them as needed.
+
+template<>
+inline void SparseVector<const char *>::ClearValue(int partition) {
+	const char *value = values->ValueAt(partition);
+	delete []value;
+	values->SetValueAt(partition, NULL);
+}
+
+template<>
+inline void SparseVector<const char *>::SetValueAt(int position, const char *value) {
+	// Make a copy of the string
+	if (value) {
+		const size_t len = strlen(value);
+		char *valueCopy = new char[len + 1]();
+		std::copy(value, value + len, valueCopy);
+		CommonSetValueAt(position, valueCopy);
+	} else {
+		CommonSetValueAt(position, NULL);
+	}
+}
+
+#ifdef SCI_NAMESPACE
+}
+#endif
+
+#endif
diff --git a/src/stc/scintilla/src/SplitVector.h b/src/stc/scintilla/src/SplitVector.h
index 3153700..df72253 100644
--- a/src/stc/scintilla/src/SplitVector.h
+++ b/src/stc/scintilla/src/SplitVector.h
@@ -29,15 +29,17 @@ protected:
 	void GapTo(int position) {
 		if (position != part1Length) {
 			if (position < part1Length) {
-				memmove(
-					body + position + gapLength,
+				// Moving the gap towards start so moving elements towards end
+				std::copy_backward(
 					body + position,
-					sizeof(T) * (part1Length - position));
-			} else {	// position > part1Length
-				memmove(
 					body + part1Length,
+					body + gapLength + part1Length);
+			} else {	// position > part1Length
+				// Moving the gap towards end so moving elements towards start
+				std::copy(
 					body + part1Length + gapLength,
-					sizeof(T) * (position - part1Length));
+					body + gapLength + position,
+					body + part1Length);
 			}
 			part1Length = position;
 		}
@@ -93,7 +95,7 @@ public:
 			GapTo(lengthBody);
 			T *newBody = new T[newSize];
 			if ((size != 0) && (body != 0)) {
-				memmove(newBody, body, sizeof(T) * lengthBody);
+				std::copy(body, body + lengthBody, newBody);
 				delete []body;
 			}
 			body = newBody;
@@ -205,7 +207,7 @@ public:
 			}
 			RoomFor(insertLength);
 			GapTo(positionToInsert);
-			memmove(body + part1Length, s + positionFrom, sizeof(T) * insertLength);
+			std::copy(s + positionFrom, s + positionFrom + insertLength, body + part1Length);
 			lengthBody += insertLength;
 			part1Length += insertLength;
 			gapLength -= insertLength;
@@ -254,11 +256,11 @@ public:
 			if (range1Length > part1AfterPosition)
 				range1Length = part1AfterPosition;
 		}
-		memcpy(buffer, body + position, range1Length * sizeof(T));
+		std::copy(body + position, body + position + range1Length, buffer);
 		buffer += range1Length;
 		position = position + range1Length + gapLength;
 		int range2Length = retrieveLength - range1Length;
-		memcpy(buffer, body + position, range2Length * sizeof(T));
+		std::copy(body + position, body + position + range2Length, buffer);
 	}
 
 	T *BufferPointer() {
diff --git a/src/stc/scintilla/src/ViewStyle.cxx b/src/stc/scintilla/src/ViewStyle.cxx
index ae68d8b..b694a62 100644
--- a/src/stc/scintilla/src/ViewStyle.cxx
+++ b/src/stc/scintilla/src/ViewStyle.cxx
@@ -139,17 +139,13 @@ ViewStyle::ViewStyle(const ViewStyle &source) {
 	alwaysShowCaretLineBackground = source.alwaysShowCaretLineBackground;
 	caretLineBackground = source.caretLineBackground;
 	caretLineAlpha = source.caretLineAlpha;
-	edgecolour = source.edgecolour;
-	edgeState = source.edgeState;
 	caretStyle = source.caretStyle;
 	caretWidth = source.caretWidth;
 	someStylesProtected = false;
 	someStylesForceCase = false;
 	leftMarginWidth = source.leftMarginWidth;
 	rightMarginWidth = source.rightMarginWidth;
-	for (int margin=0; margin <= SC_MAX_MARGIN; margin++) {
-		ms[margin] = source.ms[margin];
-	}
+	ms = source.ms;
 	maskInLine = source.maskInLine;
 	maskDrawInText = source.maskDrawInText;
 	fixedColumnWidth = source.fixedColumnWidth;
@@ -157,6 +153,7 @@ ViewStyle::ViewStyle(const ViewStyle &source) {
 	textStart = source.textStart;
 	zoomLevel = source.zoomLevel;
 	viewWhitespace = source.viewWhitespace;
+	tabDrawMode = source.tabDrawMode;
 	whitespaceSize = source.whitespaceSize;
 	viewIndentationGuides = source.viewIndentationGuides;
 	viewEOL = source.viewEOL;
@@ -171,7 +168,9 @@ ViewStyle::ViewStyle(const ViewStyle &source) {
 	braceBadLightIndicatorSet = source.braceBadLightIndicatorSet;
 	braceBadLightIndicator = source.braceBadLightIndicator;
 
+	edgeState = source.edgeState;
 	theEdge = source.theEdge;
+	theMultiEdge = source.theMultiEdge;
 
 	marginNumberPadding = source.marginNumberPadding;
 	ctrlCharPadding = source.ctrlCharPadding;
@@ -196,7 +195,7 @@ void ViewStyle::CalculateMarginWidthAndMask() {
 	fixedColumnWidth = marginInside ? leftMarginWidth : 0;
 	maskInLine = 0xffffffff;
 	int maskDefinedMarkers = 0;
-	for (int margin = 0; margin <= SC_MAX_MARGIN; margin++) {
+	for (size_t margin = 0; margin < ms.size(); margin++) {
 		fixedColumnWidth += ms[margin].width;
 		if (ms[margin].width > 0)
 			maskInLine &= ~ms[margin].mask;
@@ -268,8 +267,6 @@ void ViewStyle::Init(size_t stylesSize_) {
 	alwaysShowCaretLineBackground = false;
 	caretLineBackground = ColourDesired(0xff, 0xff, 0);
 	caretLineAlpha = SC_ALPHA_NOALPHA;
-	edgecolour = ColourDesired(0xc0, 0xc0, 0xc0);
-	edgeState = EDGE_NONE;
 	caretStyle = CARETSTYLE_LINE;
 	caretWidth = 1;
 	someStylesProtected = false;
@@ -282,6 +279,7 @@ void ViewStyle::Init(size_t stylesSize_) {
 
 	leftMarginWidth = 1;
 	rightMarginWidth = 1;
+	ms.resize(SC_MAX_MARGIN + 1);
 	ms[0].style = SC_MARGIN_NUMBER;
 	ms[0].width = 0;
 	ms[0].mask = 0;
@@ -296,6 +294,7 @@ void ViewStyle::Init(size_t stylesSize_) {
 	textStart = marginInside ? fixedColumnWidth : leftMarginWidth;
 	zoomLevel = 0;
 	viewWhitespace = wsInvisible;
+	tabDrawMode = tdLongArrow;
 	whitespaceSize = 1;
 	viewIndentationGuides = ivNone;
 	viewEOL = false;
@@ -310,7 +309,8 @@ void ViewStyle::Init(size_t stylesSize_) {
 	braceBadLightIndicatorSet = false;
 	braceBadLightIndicator = 0;
 
-	theEdge = 0;
+	edgeState = EDGE_NONE;
+	theEdge = EdgeProperties(0, ColourDesired(0xc0, 0xc0, 0xc0));
 
 	marginNumberPadding = 3;
 	ctrlCharPadding = 3; // +3 For a blank on front and rounded edge each side
@@ -447,6 +447,17 @@ int ViewStyle::ExternalMarginWidth() const {
 	return marginInside ? 0 : fixedColumnWidth;
 }
 
+int ViewStyle::MarginFromLocation(Point pt) const {
+	int margin = -1;
+	int x = textStart - fixedColumnWidth;
+	for (size_t i = 0; i < ms.size(); i++) {
+		if ((pt.x >= x) && (pt.x < x + ms[i].width))
+			margin = static_cast<int>(i);
+		x += ms[i].width;
+	}
+	return margin;
+}
+
 bool ViewStyle::ValidStyle(size_t styleIndex) const {
 	return styleIndex < styles.size();
 }
diff --git a/src/stc/scintilla/src/ViewStyle.h b/src/stc/scintilla/src/ViewStyle.h
index d5a9d5b..1a876f8 100644
--- a/src/stc/scintilla/src/ViewStyle.h
+++ b/src/stc/scintilla/src/ViewStyle.h
@@ -17,6 +17,7 @@ namespace Scintilla {
 class MarginStyle {
 public:
 	int style;
+	ColourDesired back;
 	int width;
 	int mask;
 	bool sensitive;
@@ -54,6 +55,8 @@ enum IndentView {ivNone, ivReal, ivLookForward, ivLookBoth};
 
 enum WhiteSpaceVisibility {wsInvisible=0, wsVisibleAlways=1, wsVisibleAfterIndent=2, wsVisibleOnlyInIndent=3};
 
+enum TabDrawMode {tdLongArrow=0, tdStrikeOut=1};
+
 typedef std::map<FontSpecification, FontRealised *> FontMap;
 
 enum WrapMode { eWrapNone, eWrapWord, eWrapChar, eWrapWhitespace };
@@ -72,6 +75,17 @@ struct ForeBackColours {
 	ColourOptional back;
 };
 
+struct EdgeProperties {
+	int column;
+	ColourDesired colour;
+	EdgeProperties(int column_ = 0, ColourDesired colour_ = ColourDesired(0)) :
+		column(column_), colour(colour_) {
+	}
+	EdgeProperties(uptr_t wParam, sptr_t lParam) :
+		column(static_cast<int>(wParam)), colour(static_cast<long>(lParam)) {
+	}
+};
+
 /**
  */
 class ViewStyle {
@@ -115,12 +129,13 @@ public:
 	int rightMarginWidth;	///< Spacing margin on right of text
 	int maskInLine;	///< Mask for markers to be put into text because there is nowhere for them to go in margin
 	int maskDrawInText;	///< Mask for markers that always draw in text
-	MarginStyle ms[SC_MAX_MARGIN+1];
+	std::vector<MarginStyle> ms;
 	int fixedColumnWidth;	///< Total width of margins
 	bool marginInside;	///< true: margin included in text view, false: separate views
 	int textStart;	///< Starting x position of text within the view
 	int zoomLevel;
 	WhiteSpaceVisibility viewWhitespace;
+	TabDrawMode tabDrawMode;
 	int whitespaceSize;
 	IndentView viewIndentationGuides;
 	bool viewEOL;
@@ -130,8 +145,6 @@ public:
 	bool alwaysShowCaretLineBackground;
 	ColourDesired caretLineBackground;
 	int caretLineAlpha;
-	ColourDesired edgecolour;
-	int edgeState;
 	int caretStyle;
 	int caretWidth;
 	bool someStylesProtected;
@@ -146,7 +159,9 @@ public:
 	int braceHighlightIndicator;
 	bool braceBadLightIndicatorSet;
 	int braceBadLightIndicator;
-	int theEdge;
+	int edgeState;
+	EdgeProperties theEdge;
+	std::vector<EdgeProperties> theMultiEdge;
 	int marginNumberPadding; // the right-side padding of the number margin
 	int ctrlCharPadding; // the padding around control character text blobs
 	int lastSegItalicsOffset; // the offset so as not to clip italic characters at EOLs
@@ -172,6 +187,7 @@ public:
 	void SetStyleFontName(int styleIndex, const char *name);
 	bool ProtectionActive() const;
 	int ExternalMarginWidth() const;
+	int MarginFromLocation(Point pt) const;
 	bool ValidStyle(size_t styleIndex) const;
 	void CalcLargestMarkerHeight();
 	ColourOptional Background(int marksOfLine, bool caretActive, bool lineContainsCaret) const;
diff --git a/src/stc/scintilla/src/XPM.cxx b/src/stc/scintilla/src/XPM.cxx
index 20e6c8b..4841e4f 100644
--- a/src/stc/scintilla/src/XPM.cxx
+++ b/src/stc/scintilla/src/XPM.cxx
@@ -22,13 +22,13 @@ using namespace Scintilla;
 
 static const char *NextField(const char *s) {
 	// In case there are leading spaces in the string
-	while (*s && *s == ' ') {
+	while (*s == ' ') {
 		s++;
 	}
 	while (*s && *s != ' ') {
 		s++;
 	}
-	while (*s && *s == ' ') {
+	while (*s == ' ') {
 		s++;
 	}
 	return s;
diff --git a/src/stc/stc.cpp.in b/src/stc/stc.cpp.in
index f72676e..254165c 100644
--- a/src/stc/stc.cpp.in
+++ b/src/stc/stc.cpp.in
@@ -137,7 +137,7 @@ wxDEFINE_EVENT( wxEVT_STC_HOTSPOT_RELEASE_CLICK, wxStyledTextEvent );
 wxDEFINE_EVENT( wxEVT_STC_CLIPBOARD_COPY, wxStyledTextEvent );
 wxDEFINE_EVENT( wxEVT_STC_CLIPBOARD_PASTE, wxStyledTextEvent );
 wxDEFINE_EVENT( wxEVT_STC_AUTOCOMP_COMPLETED, wxStyledTextEvent );
-
+wxDEFINE_EVENT( wxEVT_STC_MARGIN_RIGHT_CLICK, wxStyledTextEvent );
 
 
 wxBEGIN_EVENT_TABLE(wxStyledTextCtrl, wxControl)
@@ -146,6 +146,7 @@ wxBEGIN_EVENT_TABLE(wxStyledTextCtrl, wxControl)
     EVT_SCROLL                  (wxStyledTextCtrl::OnScroll)
     EVT_SIZE                    (wxStyledTextCtrl::OnSize)
     EVT_LEFT_DOWN               (wxStyledTextCtrl::OnMouseLeftDown)
+    EVT_RIGHT_DOWN              (wxStyledTextCtrl::OnMouseRightDown)
     // Let Scintilla see the double click as a second click
     EVT_LEFT_DCLICK             (wxStyledTextCtrl::OnMouseLeftDown)
     EVT_MOTION                  (wxStyledTextCtrl::OnMouseMove)
@@ -741,7 +742,7 @@ wxCharBuffer wxStyledTextCtrl::GetTextRangeRaw(int startPos, int endPos)
     }
 
     wxCharBuffer buf(len);
-    TextRange tr;
+    Sci_TextRange tr;
     tr.lpstrText = buf.data();
     tr.chrg.cpMin = startPos;
     tr.chrg.cpMax = endPos;
@@ -770,9 +771,10 @@ void wxStyledTextCtrl::AppendTextRaw(const char* text, int length)
     SendMsg(SCI_APPENDTEXT, length, (sptr_t)text);
 }
 
-
-
-
+void wxStyledTextCtrl::UsePopUp(bool allowPopUp)
+{
+    SendMsg(SCI_USEPOPUP, allowPopUp ? SC_POPUP_ALL : SC_POPUP_NEVER, 0);
+}
 
 //----------------------------------------------------------------------
 // Event handlers
@@ -817,6 +819,13 @@ void wxStyledTextCtrl::OnMouseLeftDown(wxMouseEvent& evt) {
                       evt.ShiftDown(), evt.ControlDown(), evt.AltDown());
 }
 
+void wxStyledTextCtrl::OnMouseRightDown(wxMouseEvent& evt) {
+    SetFocus();
+    wxPoint pt = evt.GetPosition();
+    m_swx->DoRightButtonDown(Point(pt.x, pt.y), m_stopWatch.Time(),
+                      evt.ShiftDown(), evt.ControlDown(), evt.AltDown());
+}
+
 void wxStyledTextCtrl::OnMouseMove(wxMouseEvent& evt) {
     wxPoint pt = evt.GetPosition();
     m_swx->DoLeftButtonMove(Point(pt.x, pt.y));
@@ -857,6 +866,22 @@ void wxStyledTextCtrl::OnContextMenu(wxContextMenuEvent& evt) {
 
 void wxStyledTextCtrl::OnMouseWheel(wxMouseEvent& evt)
 {
+    // if the mouse wheel is not captured, test if the mouse
+    // pointer is over the editor window and if not, don't
+    // handle the message but pass it on.
+    if ( !GetMouseWheelCaptures() ) {
+        if ( !GetRect().Contains(evt.GetPosition()) ) {
+            wxWindow* parent = GetParent();
+            if (parent != NULL) {
+                wxMouseEvent newevt(evt);
+                newevt.SetPosition(
+                    parent->ScreenToClient(ClientToScreen(evt.GetPosition())));
+                parent->ProcessWindowEvent(newevt);
+            }
+            return;
+        }
+    }
+    
     m_swx->DoMouseWheel(evt.GetWheelAxis(),
                         evt.GetWheelRotation(),
                         evt.GetWheelDelta(),
@@ -1147,6 +1172,11 @@ void wxStyledTextCtrl::NotifyParent(SCNotification* _scn) {
         evt.SetListCompletionMethod(scn.listCompletionMethod);
         break;
 
+    case SCN_MARGINRIGHTCLICK:
+        evt.SetEventType(wxEVT_STC_MARGIN_RIGHT_CLICK);
+        evt.SetMargin(scn.margin);
+        break;
+
     default:
         return;
     }
@@ -1233,7 +1263,7 @@ wxStyledTextEvent::wxStyledTextEvent(const wxStyledTextEvent& event):
 
 /*static*/ wxVersionInfo wxStyledTextCtrl::GetLibraryVersionInfo()
 {
-    return wxVersionInfo("Scintilla", 3, 6, 6, "Scintilla 3.6.6");
+    return wxVersionInfo("Scintilla", 3, 7, 2, "Scintilla 3.7.2");
 }
 
 #endif // wxUSE_STC
diff --git a/src/stc/stc.h.in b/src/stc/stc.h.in
index 72a701a..2cb06e8 100644
--- a/src/stc/stc.h.in
+++ b/src/stc/stc.h.in
@@ -466,6 +466,13 @@ public:
     {
         return wxTextAreaBase::HitTest(pt, col, row);
     }
+    
+    // methods deprecated due to changes in the scintilla library
+    // ---------------------------------------------
+    
+    wxDEPRECATED_MSG("use UsePopUp(int) instead.") 
+    void UsePopUp(bool allowPopUp);
+
 
     static wxVersionInfo GetLibraryVersionInfo();
 
@@ -484,6 +491,7 @@ protected:
     void OnScroll(wxScrollEvent& evt);
     void OnSize(wxSizeEvent& evt);
     void OnMouseLeftDown(wxMouseEvent& evt);
+    void OnMouseRightDown(wxMouseEvent& evt);
     void OnMouseMove(wxMouseEvent& evt);
     void OnMouseLeftUp(wxMouseEvent& evt);
     void OnMouseRightUp(wxMouseEvent& evt);
@@ -685,6 +693,8 @@ wxDECLARE_EXPORTED_EVENT( WXDLLIMPEXP_STC, wxEVT_STC_HOTSPOT_RELEASE_CLICK, wxSt
 wxDECLARE_EXPORTED_EVENT( WXDLLIMPEXP_STC, wxEVT_STC_CLIPBOARD_COPY, wxStyledTextEvent );
 wxDECLARE_EXPORTED_EVENT( WXDLLIMPEXP_STC, wxEVT_STC_CLIPBOARD_PASTE, wxStyledTextEvent );
 wxDECLARE_EXPORTED_EVENT( WXDLLIMPEXP_STC, wxEVT_STC_AUTOCOMP_COMPLETED, wxStyledTextEvent );
+wxDECLARE_EXPORTED_EVENT( WXDLLIMPEXP_STC, wxEVT_STC_MARGIN_RIGHT_CLICK, wxStyledTextEvent );
+
 #else
     enum {
         wxEVT_STC_CHANGE,
@@ -720,7 +730,8 @@ wxDECLARE_EXPORTED_EVENT( WXDLLIMPEXP_STC, wxEVT_STC_AUTOCOMP_COMPLETED, wxStyle
         wxEVT_STC_HOTSPOT_RELEASE_CLICK,
         wxEVT_STC_CLIPBOARD_COPY,
         wxEVT_STC_CLIPBOARD_PASTE,
-        wxEVT_STC_AUTOCOMP_COMPLETED
+        wxEVT_STC_AUTOCOMP_COMPLETED,
+        wxEVT_STC_MARGIN_RIGHT_CLICK
     };
 #endif
 
@@ -766,6 +777,7 @@ typedef void (wxEvtHandler::*wxStyledTextEventFunction)(wxStyledTextEvent&);
 #define EVT_STC_CLIPBOARD_COPY(id, fn)        wxDECLARE_EVENT_TABLE_ENTRY( wxEVT_STC_CLIPBOARD_COPY,        id, wxID_ANY, wxStyledTextEventHandler( fn ), (wxObject *) NULL ),
 #define EVT_STC_CLIPBOARD_PASTE(id, fn)       wxDECLARE_EVENT_TABLE_ENTRY( wxEVT_STC_CLIPBOARD_PASTE,       id, wxID_ANY, wxStyledTextEventHandler( fn ), (wxObject *) NULL ),
 #define EVT_STC_AUTOCOMP_COMPLETED(id, fn)    wxDECLARE_EVENT_TABLE_ENTRY( wxEVT_STC_AUTOCOMP_COMPLETED,    id, wxID_ANY, wxStyledTextEventHandler( fn ), (wxObject *) NULL ),
+#define EVT_STC_MARGIN_RIGHT_CLICK(id, fn)    wxDECLARE_EVENT_TABLE_ENTRY( wxEVT_STC_MARGIN_RIGHT_CLICK,    id, wxID_ANY, wxStyledTextEventHandler( fn ), (wxObject *) NULL ),
 
 #endif
 
diff --git a/src/stc/stc.interface.h.in b/src/stc/stc.interface.h.in
index 2ee9e0e..ab37df4 100644
--- a/src/stc/stc.interface.h.in
+++ b/src/stc/stc.interface.h.in
@@ -119,6 +119,10 @@
     @event{EVT_STC_AUTOCOMP_COMPLETED(id, fn)}
         Process a @c wxEVT_STC_AUTOCOMP_COMPLETED event, generated after an autocompletion list has closed and inserted its text into the control. Valid event functions: @link wxStyledTextEvent::GetPosition GetPosition@endlink, @link wxStyledTextEvent::GetString GetString@endlink, @link wxStyledTextEvent::GetKey GetKey@endlink, @link wxStyledTextEvent::GetListCompletionMethod GetListCompletionMethod@endlink.
         @since 3.1.1
+        
+    @event{EVT_STC_MARGIN_RIGHT_CLICK(id, fn)}
+        Process a @c wxEVT_STC_MARGIN_RIGHT_CLICK event. Valid event functions: @link wxStyledTextEvent::GetMargin GetMargin@endlink, @link wxStyledTextEvent::GetModifiers GetModifiers@endlink, @link wxStyledTextEvent::GetPosition GetPosition@endlink, @link wxStyledTextEvent::GetAlt GetAlt@endlink, @link wxStyledTextEvent::GetControl GetControl@endlink, @link wxStyledTextEvent::GetShift GetShift@endlink.
+        @since 3.1.1
 
     @endEventTable
 
