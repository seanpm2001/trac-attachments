diff --git a/src/stc/gen_iface.py b/src/stc/gen_iface.py
index ef4440d..becb27d 100755
--- a/src/stc/gen_iface.py
+++ b/src/stc/gen_iface.py
@@ -228,7 +228,10 @@ methodOverrideMap = {
         ''',
      ('Define a marker from a bitmap',)),
 
-
+    'GetMargins' : ('GetMarginCount', 0, 0, 0),
+    'SetMargins' : ('SetMarginCount', 0, 0, 0),
+    'GetMarginBackN' : ('GetMarginBackground', 0, 0, 0),
+    'SetMarginBackN' : ('SetMarginBackground', 0, 0, 0),
     'SetMarginTypeN' : ('SetMarginType', 0, 0, 0),
     'GetMarginTypeN' : ('GetMarginType', 0, 0, 0),
     'SetMarginWidthN' : ('SetMarginWidth', 0, 0, 0),
@@ -351,6 +354,13 @@ methodOverrideMap = {
 
     'ClearAllCmdKeys' : ('CmdKeyClearAll', 0, 0, 0),
 
+    'StartStyling' : 
+    (0,
+     'void %s(int start, int unused=0);',
+
+     '''void %s(int start, int unused) {
+        SendMsg(%s, start, unused);''',
+     0),
 
     'SetStylingEx' :
     ('SetStyleBytes',
@@ -710,10 +720,20 @@ methodOverrideMap = {
      ("Retrieve a 'property' value previously set with SetProperty,",
       "with '$()' variable replacement on returned buffer.")),
 
-    'GetPropertyInt'   : (0, 0, 0,
+    'GetPropertyInt' : 
+    (0, 
+    'int %s(const wxString &key, int defaultValue=0) const;', 
+    '''int %s(const wxString &key, int defaultValue) const {
+        return SendMsg(%s, (uptr_t)(const char*)wx2stc(key), defaultValue);''',
        ("Retrieve a 'property' value previously set with SetProperty,",
         "interpreted as an int AFTER any '$()' variable replacement.")),
 
+    'BraceMatch' : 
+    (0, 
+    'int %s(int pos, int maxReStyle=0);', 
+    '''int %s(int pos, int maxReStyle){
+        return SendMsg(%s, pos, maxReStyle);''',
+     0),
 
     'GetDocPointer' :
     (0,
diff --git a/src/stc/scintilla/README.txt b/src/stc/scintilla/README.txt
index f5498d4..01c27b3 100644
--- a/src/stc/scintilla/README.txt
+++ b/src/stc/scintilla/README.txt
@@ -3,7 +3,7 @@ directories from the Scintilla source distribution. All other code
 needed to implement Scintilla on top of wxWidgets is located in the
 directory above this one.
 
-The current version of the Scintilla code is 3.6.6
+The current version of the Scintilla code is 3.7.0
 
 These are the basic steps needed to update the version of Scintilla used by wxSTC.  
 
@@ -30,7 +30,7 @@ keep the compile working cleanly, but try to keep them minimal.
 5. Adjust the version number in wxStyledTextCtrl::GetLibraryVersionInfo()
 in src/stc/stc.cpp.in.
 
-6. Edit the gen_iface.py file.  This is where the Scintilla.iface file
+6a. Edit the gen_iface.py file.  This is where the Scintilla.iface file
 is read and the code for stc.h and stc.cpp is generated.  For all new
 methods or constant names check if there are similarly named things
 defined here that are having something special done to them, and then
@@ -38,11 +38,12 @@ do the same sort of thing for those new items.  For example if there
 is a new AutoCFoo method, I add the line in gen_iface.py that will
 cause the AutoCompFoo name to be used instead.  The same for any
 methods dealing with "Fore" or "Back" colors, they are renamed to
-Foreground and Background.  If there is a new method that could be
-considered a "command function" (something that takes no parameters
-and could conceivably be bound to a key event) then I make sure that
-it's ID is in cmdValues or included in one of the existing ranges in
-that list.
+Foreground and Background.  
+
+6b. If there is a new method that could be considered a "command function" 
+(something that takes no parameters and could conceivably be bound to a key 
+event) then I make sure that it's ID is in cmdValues or included in one of the 
+existing ranges in that list.
 
 7. Run gen_iface.py.
 
diff --git a/src/stc/scintilla/include/SciLexer.h b/src/stc/scintilla/include/SciLexer.h
index 6b98b09..0eb0b29 100644
--- a/src/stc/scintilla/include/SciLexer.h
+++ b/src/stc/scintilla/include/SciLexer.h
@@ -599,6 +599,20 @@
 #define SCE_BAAN_IDENTIFIER 8
 #define SCE_BAAN_STRINGEOL 9
 #define SCE_BAAN_WORD2 10
+#define SCE_BAAN_WORD3 11
+#define SCE_BAAN_WORD4 12
+#define SCE_BAAN_WORD5 13
+#define SCE_BAAN_WORD6 14
+#define SCE_BAAN_WORD7 15
+#define SCE_BAAN_WORD8 16
+#define SCE_BAAN_WORD9 17
+#define SCE_BAAN_TABLEDEF 18
+#define SCE_BAAN_TABLESQL 19
+#define SCE_BAAN_FUNCTION 20
+#define SCE_BAAN_DOMDEF 21
+#define SCE_BAAN_FUNCDEF 22
+#define SCE_BAAN_OBJECTDEF 23
+#define SCE_BAAN_DEFINEDEF 24
 #define SCE_LISP_DEFAULT 0
 #define SCE_LISP_COMMENT 1
 #define SCE_LISP_NUMBER 2
@@ -1277,38 +1291,19 @@
 #define SCE_PLM_OPERATOR 5
 #define SCE_PLM_CONTROL 6
 #define SCE_PLM_KEYWORD 7
-#define SCE_4GL_DEFAULT 0
-#define SCE_4GL_NUMBER 1
-#define SCE_4GL_WORD 2
-#define SCE_4GL_STRING 3
-#define SCE_4GL_CHARACTER 4
-#define SCE_4GL_PREPROCESSOR 5
-#define SCE_4GL_OPERATOR 6
-#define SCE_4GL_IDENTIFIER 7
-#define SCE_4GL_BLOCK 8
-#define SCE_4GL_END 9
-#define SCE_4GL_COMMENT1 10
-#define SCE_4GL_COMMENT2 11
-#define SCE_4GL_COMMENT3 12
-#define SCE_4GL_COMMENT4 13
-#define SCE_4GL_COMMENT5 14
-#define SCE_4GL_COMMENT6 15
-#define SCE_4GL_DEFAULT_ 16
-#define SCE_4GL_NUMBER_ 17
-#define SCE_4GL_WORD_ 18
-#define SCE_4GL_STRING_ 19
-#define SCE_4GL_CHARACTER_ 20
-#define SCE_4GL_PREPROCESSOR_ 21
-#define SCE_4GL_OPERATOR_ 22
-#define SCE_4GL_IDENTIFIER_ 23
-#define SCE_4GL_BLOCK_ 24
-#define SCE_4GL_END_ 25
-#define SCE_4GL_COMMENT1_ 26
-#define SCE_4GL_COMMENT2_ 27
-#define SCE_4GL_COMMENT3_ 28
-#define SCE_4GL_COMMENT4_ 29
-#define SCE_4GL_COMMENT5_ 30
-#define SCE_4GL_COMMENT6_ 31
+#define SCE_ABL_DEFAULT 0
+#define SCE_ABL_NUMBER 1
+#define SCE_ABL_WORD 2
+#define SCE_ABL_STRING 3
+#define SCE_ABL_CHARACTER 4
+#define SCE_ABL_PREPROCESSOR 5
+#define SCE_ABL_OPERATOR 6
+#define SCE_ABL_IDENTIFIER 7
+#define SCE_ABL_BLOCK 8
+#define SCE_ABL_END 9
+#define SCE_ABL_COMMENT 10
+#define SCE_ABL_TASKMARKER 11
+#define SCE_ABL_LINECOMMENT 12
 #define SCE_ABAQUS_DEFAULT 0
 #define SCE_ABAQUS_COMMENT 1
 #define SCE_ABAQUS_COMMENTBLOCK 2
diff --git a/src/stc/scintilla/include/Scintilla.h b/src/stc/scintilla/include/Scintilla.h
index 99bc6e7..9fd519f 100644
--- a/src/stc/scintilla/include/Scintilla.h
+++ b/src/stc/scintilla/include/Scintilla.h
@@ -167,6 +167,7 @@ typedef sptr_t (*SciFnDirect)(sptr_t ptr, unsigned int iMessage, uptr_t wParam,
 #define SC_MARGIN_FORE 3
 #define SC_MARGIN_TEXT 4
 #define SC_MARGIN_RTEXT 5
+#define SC_MARGIN_COLOUR 6
 #define SCI_SETMARGINTYPEN 2240
 #define SCI_GETMARGINTYPEN 2241
 #define SCI_SETMARGINWIDTHN 2242
@@ -177,6 +178,10 @@ typedef sptr_t (*SciFnDirect)(sptr_t ptr, unsigned int iMessage, uptr_t wParam,
 #define SCI_GETMARGINSENSITIVEN 2247
 #define SCI_SETMARGINCURSORN 2248
 #define SCI_GETMARGINCURSORN 2249
+#define SCI_SETMARGINBACKN 2250
+#define SCI_GETMARGINBACKN 2251
+#define SCI_SETMARGINS 2252
+#define SCI_GETMARGINS 2253
 #define STYLE_DEFAULT 32
 #define STYLE_LINENUMBER 33
 #define STYLE_BRACELIGHT 34
@@ -650,12 +655,15 @@ typedef sptr_t (*SciFnDirect)(sptr_t ptr, unsigned int iMessage, uptr_t wParam,
 #define EDGE_NONE 0
 #define EDGE_LINE 1
 #define EDGE_BACKGROUND 2
+#define EDGE_MULTILINE 3
 #define SCI_GETEDGECOLUMN 2360
 #define SCI_SETEDGECOLUMN 2361
 #define SCI_GETEDGEMODE 2362
 #define SCI_SETEDGEMODE 2363
 #define SCI_GETEDGECOLOUR 2364
 #define SCI_SETEDGECOLOUR 2365
+#define SCI_MULTIEDGEADDLINE 2694
+#define SCI_MULTIEDGECLEARALL 2695
 #define SCI_SEARCHANCHOR 2366
 #define SCI_SEARCHNEXT 2367
 #define SCI_SEARCHPREV 2368
@@ -679,6 +687,8 @@ typedef sptr_t (*SciFnDirect)(sptr_t ptr, unsigned int iMessage, uptr_t wParam,
 #define SCI_GETSTATUS 2383
 #define SCI_SETMOUSEDOWNCAPTURES 2384
 #define SCI_GETMOUSEDOWNCAPTURES 2385
+#define SCI_SETMOUSEWHEELCAPTURES 2696
+#define SCI_GETMOUSEWHEELCAPTURES 2697
 #define SC_CURSORNORMAL -1
 #define SC_CURSORARROW 2
 #define SC_CURSORWAIT 4
@@ -895,6 +905,7 @@ typedef sptr_t (*SciFnDirect)(sptr_t ptr, unsigned int iMessage, uptr_t wParam,
 #define SCVS_NONE 0
 #define SCVS_RECTANGULARSELECTION 1
 #define SCVS_USERACCESSIBLE 2
+#define SCVS_NOWRAPLINESTART 4
 #define SCI_SETVIRTUALSPACEOPTIONS 2596
 #define SCI_GETVIRTUALSPACEOPTIONS 2597
 #define SCI_SETRECTANGULARSELECTIONMODIFIER 2598
diff --git a/src/stc/scintilla/include/Scintilla.iface b/src/stc/scintilla/include/Scintilla.iface
index 310d877..de0d881 100644
--- a/src/stc/scintilla/include/Scintilla.iface
+++ b/src/stc/scintilla/include/Scintilla.iface
@@ -105,7 +105,7 @@ fun void ChangeInsertion=2672(int length, string text)
 fun void ClearAll=2004(,)
 
 # Delete a range of text in the document.
-fun void DeleteRange=2645(position pos, int deleteLength)
+fun void DeleteRange=2645(position start, int lengthDelete)
 
 # Set all style bytes to 0, remove all folding information.
 fun void ClearDocumentStyle=2005(,)
@@ -147,10 +147,10 @@ fun int GetStyledText=2015(, textrange tr)
 fun bool CanRedo=2016(,)
 
 # Retrieve the line number at which a particular marker is located.
-fun int MarkerLineFromHandle=2017(int handle,)
+fun int MarkerLineFromHandle=2017(int markerHandle,)
 
 # Delete a marker.
-fun void MarkerDeleteHandle=2018(int handle,)
+fun void MarkerDeleteHandle=2018(int markerHandle,)
 
 # Is undo history being collected?
 get bool GetUndoCollection=2019(,)
@@ -179,11 +179,11 @@ fun position PositionFromPointClose=2023(int x, int y)
 fun void GotoLine=2024(int line,)
 
 # Set caret to a position and ensure it is visible.
-fun void GotoPos=2025(position pos,)
+fun void GotoPos=2025(position caret,)
 
 # Set the selection anchor to a position. The anchor is the opposite
 # end of the selection from the caret.
-set void SetAnchor=2026(position posAnchor,)
+set void SetAnchor=2026(position anchor,)
 
 # Retrieve the text of the line containing the caret.
 # Returns the index of the caret on the line.
@@ -207,9 +207,9 @@ get int GetEOLMode=2030(,)
 # Set the current end of line mode.
 set void SetEOLMode=2031(int eolMode,)
 
-# Set the current styling position to pos and the styling mask to mask.
-# The styling mask can be used to protect some bits in each styling byte from modification.
-fun void StartStyling=2032(position pos, int mask)
+# Set the current styling position to start.
+# The unused parameter is no longer used and should be set to 0.
+fun void StartStyling=2032(position start, int unused)
 
 # Change style from current styling position for length characters to a style
 # and move the current styling position to after this newly styled segment.
@@ -346,7 +346,7 @@ fun int MarkerPrevious=2048(int lineStart, int markerMask)
 fun void MarkerDefinePixmap=2049(int markerNumber, string pixmap)
 
 # Add a set of markers to a line.
-fun void MarkerAddSet=2466(int line, int set)
+fun void MarkerAddSet=2466(int line, int markerSet)
 
 # Set the alpha used for a marker that is drawn in the text area, not the margin.
 set void MarkerSetAlpha=2476(int markerNumber, int alpha)
@@ -360,6 +360,7 @@ val SC_MARGIN_BACK=2
 val SC_MARGIN_FORE=3
 val SC_MARGIN_TEXT=4
 val SC_MARGIN_RTEXT=5
+val SC_MARGIN_COLOUR=6
 
 # Set a margin to be either numeric or symbolic.
 set void SetMarginTypeN=2240(int margin, int marginType)
@@ -391,6 +392,18 @@ set void SetMarginCursorN=2248(int margin, int cursor)
 # Retrieve the cursor shown in a margin.
 get int GetMarginCursorN=2249(int margin,)
 
+# Set the background colour of a margin. Only visible for SC_MARGIN_COLOUR.
+set void SetMarginBackN=2250(int margin, colour back)
+
+# Retrieve the background colour of a margin
+get colour GetMarginBackN=2251(int margin,)
+
+# Allocate a non-standard number of margins.
+set void SetMargins=2252(int margins,)
+
+# How many margins are there?.
+get int GetMargins=2253(,)
+
 # Styles in range 32..38 are predefined for parts of the UI and are not used as normal styles.
 # Style 39 is for future use.
 enu StylesCommon=STYLE_
@@ -452,7 +465,7 @@ set void StyleSetSize=2055(int style, int sizePoints)
 set void StyleSetFont=2056(int style, string fontName)
 
 # Set a style to have its end of line filled or not.
-set void StyleSetEOLFilled=2057(int style, bool filled)
+set void StyleSetEOLFilled=2057(int style, bool eolFilled)
 
 # Reset the default style to its state at startup
 fun void StyleResetDefault=2058(,)
@@ -509,12 +522,12 @@ get bool StyleGetChangeable=2492(int style,)
 get bool StyleGetHotSpot=2493(int style,)
 
 # Set a style to be mixed case, or to force upper or lower case.
-set void StyleSetCase=2060(int style, int caseForce)
+set void StyleSetCase=2060(int style, int caseVisible)
 
 val SC_FONT_SIZE_MULTIPLIER=100
 
 # Set the size of characters of a style. Size is in points multiplied by 100.
-set void StyleSetSizeFractional=2061(int style, int caseForce)
+set void StyleSetSizeFractional=2061(int style, int sizeHundredthPoints)
 
 # Get the size of characters of a style in points multiplied by 100
 get int StyleGetSizeFractional=2062(int style,)
@@ -557,11 +570,11 @@ set void SetSelEOLFilled=2480(bool filled,)
 # Set the foreground colour of the caret.
 set void SetCaretFore=2069(colour fore,)
 
-# When key+modifier combination km is pressed perform msg.
-fun void AssignCmdKey=2070(keymod km, int msg)
+# When key+modifier combination keyDefinition is pressed perform sciCommand.
+fun void AssignCmdKey=2070(keymod keyDefinition, int sciCommand)
 
-# When key+modifier combination km is pressed do nothing.
-fun void ClearCmdKey=2071(keymod km,)
+# When key+modifier combination keyDefinition is pressed do nothing.
+fun void ClearCmdKey=2071(keymod keyDefinition,)
 
 # Drop all key mappings.
 fun void ClearAllCmdKeys=2072(,)
@@ -623,34 +636,34 @@ val INDIC2_MASK=0x80
 val INDICS_MASK=0xE0
 
 # Set an indicator to plain, squiggle or TT.
-set void IndicSetStyle=2080(int indic, int style)
+set void IndicSetStyle=2080(int indicator, int indicatorStyle)
 
 # Retrieve the style of an indicator.
-get int IndicGetStyle=2081(int indic,)
+get int IndicGetStyle=2081(int indicator,)
 
 # Set the foreground colour of an indicator.
-set void IndicSetFore=2082(int indic, colour fore)
+set void IndicSetFore=2082(int indicator, colour fore)
 
 # Retrieve the foreground colour of an indicator.
-get colour IndicGetFore=2083(int indic,)
+get colour IndicGetFore=2083(int indicator,)
 
 # Set an indicator to draw under text or over(default).
-set void IndicSetUnder=2510(int indic, bool under)
+set void IndicSetUnder=2510(int indicator, bool under)
 
 # Retrieve whether indicator drawn under or over text.
-get bool IndicGetUnder=2511(int indic,)
+get bool IndicGetUnder=2511(int indicator,)
 
 # Set a hover indicator to plain, squiggle or TT.
-set void IndicSetHoverStyle=2680(int indic, int style)
+set void IndicSetHoverStyle=2680(int indicator, int indicatorStyle)
 
 # Retrieve the hover style of an indicator.
-get int IndicGetHoverStyle=2681(int indic,)
+get int IndicGetHoverStyle=2681(int indicator,)
 
 # Set the foreground hover colour of an indicator.
-set void IndicSetHoverFore=2682(int indic, colour fore)
+set void IndicSetHoverFore=2682(int indicator, colour fore)
 
 # Retrieve the foreground hover colour of an indicator.
-get colour IndicGetHoverFore=2683(int indic,)
+get colour IndicGetHoverFore=2683(int indicator,)
 
 val SC_INDICVALUEBIT=0x1000000
 val SC_INDICVALUEMASK=0xFFFFFF
@@ -659,10 +672,10 @@ enu IndicFlag=SC_INDICFLAG_
 val SC_INDICFLAG_VALUEFORE=1
 
 # Set the attributes of an indicator.
-set void IndicSetFlags=2684(int indic, int flags)
+set void IndicSetFlags=2684(int indicator, int flags)
 
 # Retrieve the attributes of an indicator.
-get int IndicGetFlags=2685(int indic,)
+get int IndicGetFlags=2685(int indicator,)
 
 # Set the foreground colour of all whitespace and whether to use this setting.
 fun void SetWhitespaceFore=2084(bool useSetting, colour fore)
@@ -710,9 +723,9 @@ set void SetCaretLineBack=2098(colour back,)
 set void StyleSetChangeable=2099(int style, bool changeable)
 
 # Display a auto-completion list.
-# The lenEntered parameter indicates how many characters before
+# The lengthEntered parameter indicates how many characters before
 # the caret should be used to provide context.
-fun void AutoCShow=2100(int lenEntered, string itemList)
+fun void AutoCShow=2100(int lengthEntered, string itemList)
 
 # Remove the auto-completion list from the screen.
 fun void AutoCCancel=2101(,)
@@ -737,7 +750,7 @@ set void AutoCSetSeparator=2106(int separatorCharacter,)
 get int AutoCGetSeparator=2107(,)
 
 # Select the item in the auto-completion list that starts with a string.
-fun void AutoCSelect=2108(, string text)
+fun void AutoCSelect=2108(, string select)
 
 # Should the auto-completion list be cancelled if the user backspaces to a
 # position before where the box was created.
@@ -820,7 +833,7 @@ set void SetUseTabs=2124(bool useTabs,)
 get bool GetUseTabs=2125(,)
 
 # Change the indentation of a line to a number of columns.
-set void SetLineIndentation=2126(int line, int indentSize)
+set void SetLineIndentation=2126(int line, int indentation)
 
 # Retrieve the number of columns that a line is indented.
 get int GetLineIndentation=2127(int line,)
@@ -832,10 +845,10 @@ get position GetLineIndentPosition=2128(int line,)
 get int GetColumn=2129(position pos,)
 
 # Count characters between two positions.
-fun int CountCharacters=2633(int startPos, int endPos)
+fun int CountCharacters=2633(position start, position end)
 
 # Show or hide the horizontal scroll bar.
-set void SetHScrollBar=2130(bool show,)
+set void SetHScrollBar=2130(bool visible,)
 # Is the horizontal scroll bar visible?
 get bool GetHScrollBar=2131(,)
 
@@ -871,22 +884,22 @@ get colour GetCaretFore=2138(,)
 get bool GetReadOnly=2140(,)
 
 # Sets the position of the caret.
-set void SetCurrentPos=2141(position pos,)
+set void SetCurrentPos=2141(position caret,)
 
 # Sets the position that starts the selection - this becomes the anchor.
-set void SetSelectionStart=2142(position pos,)
+set void SetSelectionStart=2142(position anchor,)
 
 # Returns the position at the start of the selection.
 get position GetSelectionStart=2143(,)
 
-# Sets the position that ends the selection - this becomes the currentPosition.
-set void SetSelectionEnd=2144(position pos,)
+# Sets the position that ends the selection - this becomes the caret.
+set void SetSelectionEnd=2144(position caret,)
 
 # Returns the position at the end of the selection.
 get position GetSelectionEnd=2145(,)
 
 # Set caret to a position, while removing any existing selection.
-fun void SetEmptySelection=2556(position pos,)
+fun void SetEmptySelection=2556(position caret,)
 
 # Sets the print magnification added to the point size of each style for printing.
 set void SetPrintMagnification=2146(int magnification,)
@@ -921,7 +934,7 @@ val SCFIND_POSIX=0x00400000
 val SCFIND_CXX11REGEX=0x00800000
 
 # Find some text in the document.
-fun position FindText=2150(int flags, findtext ft)
+fun position FindText=2150(int searchFlags, findtext ft)
 
 # On Windows, will draw the document into a display context such as a printer.
 fun position FormatRange=2151(bool draw, formatrange fr)
@@ -952,7 +965,7 @@ get int GetMarginRight=2158(,)
 get bool GetModify=2159(,)
 
 # Select a range of text.
-fun void SetSel=2160(position start, position end)
+fun void SetSel=2160(position anchor, position caret)
 
 # Retrieve the selected text.
 # Return the length of the text.
@@ -964,7 +977,7 @@ fun int GetSelText=2161(, stringresult text)
 fun int GetTextRange=2162(, textrange tr)
 
 # Draw the selection in normal style or with selection highlighted.
-fun void HideSelection=2163(bool normal,)
+fun void HideSelection=2163(bool hide,)
 
 # Retrieve the x value of the point in the window where a position is displayed.
 fun int PointXFromPosition=2164(, position pos)
@@ -1041,7 +1054,7 @@ get int GetDirectFunction=2184(,)
 get int GetDirectPointer=2185(,)
 
 # Set to overtype (true) or insert mode.
-set void SetOvertype=2186(bool overtype,)
+set void SetOvertype=2186(bool overType,)
 
 # Returns true if overtype mode is active otherwise false is returned.
 get bool GetOvertype=2187(,)
@@ -1054,14 +1067,14 @@ get int GetCaretWidth=2189(,)
 
 # Sets the position that starts the target which is used for updating the
 # document without affecting the scroll position.
-set void SetTargetStart=2190(position pos,)
+set void SetTargetStart=2190(position start,)
 
 # Get the position that starts the target.
 get position GetTargetStart=2191(,)
 
 # Sets the position that ends the target which is used for updating the
 # document without affecting the scroll position.
-set void SetTargetEnd=2192(position pos,)
+set void SetTargetEnd=2192(position end,)
 
 # Get the position that ends the target.
 get position GetTargetEnd=2193(,)
@@ -1070,7 +1083,7 @@ get position GetTargetEnd=2193(,)
 fun void SetTargetRange=2686(position start, position end)
 
 # Retrieve the text in the target.
-get int GetTargetText=2687(, stringresult characters)
+get int GetTargetText=2687(, stringresult text)
 
 # Make the target range start and end be the same as the selection range start and end.
 fun void TargetFromSelection=2287(,)
@@ -1097,7 +1110,7 @@ fun int ReplaceTargetRE=2195(int length, string text)
 fun int SearchInTarget=2197(int length, string text)
 
 # Set the search flags used by SearchInTarget.
-set void SetSearchFlags=2198(int flags,)
+set void SetSearchFlags=2198(int searchFlags,)
 
 # Get the search flags used by SearchInTarget.
 get int GetSearchFlags=2199(,)
@@ -1118,7 +1131,7 @@ fun position CallTipPosStart=2203(,)
 set void CallTipSetPosStart=2214(int posStart,)
 
 # Highlight a segment of the definition.
-fun void CallTipSetHlt=2204(int start, int end)
+fun void CallTipSetHlt=2204(int highlightStart, int highlightEnd)
 
 # Set the background colour for the call tip.
 set void CallTipSetBack=2205(colour back,)
@@ -1136,13 +1149,13 @@ set void CallTipUseStyle=2212(int tabSize,)
 set void CallTipSetPosition=2213(bool above,)
 
 # Find the display line of a document line taking hidden lines into account.
-fun int VisibleFromDocLine=2220(int line,)
+fun int VisibleFromDocLine=2220(int docLine,)
 
 # Find the document line of a display line taking hidden lines into account.
-fun int DocLineFromVisible=2221(int lineDisplay,)
+fun int DocLineFromVisible=2221(int displayLine,)
 
 # The number of display lines needed to wrap a document line
-fun int WrapCount=2235(int line,)
+fun int WrapCount=2235(int docLine,)
 
 enu FoldLevel=SC_FOLDLEVEL
 val SC_FOLDLEVELBASE=0x400
@@ -1185,7 +1198,7 @@ get bool GetFoldExpanded=2230(int line,)
 # Switch a header line between expanded and contracted.
 fun void ToggleFold=2231(int line,)
 
-enu FoldAction=SC_FOLDACTION
+enu FoldAction=SC_FOLDACTION_
 val SC_FOLDACTION_CONTRACT=0
 val SC_FOLDACTION_EXPAND=1
 val SC_FOLDACTION_TOGGLE=2
@@ -1279,7 +1292,7 @@ val SC_WRAP_CHAR=2
 val SC_WRAP_WHITESPACE=3
 
 # Sets whether text is word wrapped.
-set void SetWrapMode=2268(int mode,)
+set void SetWrapMode=2268(int wrapMode,)
 
 # Retrieve whether text is word wrapped.
 get int GetWrapMode=2269(,)
@@ -1319,7 +1332,7 @@ val SC_WRAPINDENT_SAME=1
 val SC_WRAPINDENT_INDENT=2
 
 # Sets how wrapped sublines are placed. Default is fixed.
-set void SetWrapIndentMode=2472(int mode,)
+set void SetWrapIndentMode=2472(int wrapIndentMode,)
 
 # Retrieve how wrapped sublines are placed. Default is fixed.
 get int GetWrapIndentMode=2473(,)
@@ -1331,7 +1344,7 @@ val SC_CACHE_PAGE=2
 val SC_CACHE_DOCUMENT=3
 
 # Sets the degree of caching of layout information.
-set void SetLayoutCache=2272(int mode,)
+set void SetLayoutCache=2272(int cacheMode,)
 
 # Retrieve the degree of caching of layout information.
 get int GetLayoutCache=2273(,)
@@ -1366,7 +1379,7 @@ get bool GetEndAtLastLine=2278(,)
 fun int TextHeight=2279(int line,)
 
 # Show or hide the vertical scroll bar.
-set void SetVScrollBar=2280(bool show,)
+set void SetVScrollBar=2280(bool visible,)
 
 # Is the vertical scroll bar visible?
 get bool GetVScrollBar=2281(,)
@@ -1381,7 +1394,7 @@ get bool GetTwoPhaseDraw=2283(,)
 # and then the foreground. This avoids chopping off characters that overlap the next run.
 set void SetTwoPhaseDraw=2284(bool twoPhase,)
 
-enu FontQuality=SC_PHASES_
+enu PhasesDraw=SC_PHASES_
 val SC_PHASES_ONE=0
 val SC_PHASES_TWO=1
 val SC_PHASES_MULTIPLE=2
@@ -1411,7 +1424,7 @@ set void SetFontQuality=2611(int fontQuality,)
 get int GetFontQuality=2612(,)
 
 # Scroll so that a display line is at the top of the display.
-set void SetFirstVisibleLine=2613(int lineDisplay,)
+set void SetFirstVisibleLine=2613(int displayLine,)
 
 enu MultiPaste=SC_MULTIPASTE_
 val SC_MULTIPASTE_ONCE=0
@@ -1434,8 +1447,9 @@ fun void LinesJoin=2288(,)
 # where possible.
 fun void LinesSplit=2289(int pixelWidth,)
 
-# Set the colours used as a chequerboard pattern in the fold margin
+# Set one of the colours used as a chequerboard pattern in the fold margin
 fun void SetFoldMarginColour=2290(bool useSetting, colour back)
+# Set the other colour used as a chequerboard pattern in the fold margin
 fun void SetFoldMarginHiColour=2291(bool useSetting, colour fore)
 
 ## New messages go here
@@ -1599,17 +1613,28 @@ fun void LineEndDisplay=2347(,)
 # caret position.
 fun void LineEndDisplayExtend=2348(,)
 
-# These are like their namesakes Home(Extend)?, LineEnd(Extend)?, VCHome(Extend)?
-# except they behave differently when word-wrap is enabled:
-# They go first to the start / end of the display line, like (Home|LineEnd)Display
-# The difference is that, the cursor is already at the point, it goes on to the start
-# or end of the document line, as appropriate for (Home|LineEnd|VCHome)(Extend)?.
-
+# Like Home but when word-wrap is enabled goes first to start of display line
+# HomeDisplay, then to start of document line Home.
 fun void HomeWrap=2349(,)
+
+# Like HomeExtend but when word-wrap is enabled extends first to start of display line
+# HomeDisplayExtend, then to start of document line HomeExtend.
 fun void HomeWrapExtend=2450(,)
+
+# Like LineEnd but when word-wrap is enabled goes first to end of display line
+# LineEndDisplay, then to start of document line LineEnd.
 fun void LineEndWrap=2451(,)
+
+# Like LineEndExtend but when word-wrap is enabled extends first to end of display line
+# LineEndDisplayExtend, then to start of document line LineEndExtend.
 fun void LineEndWrapExtend=2452(,)
+
+# Like VCHome but when word-wrap is enabled goes first to start of display line
+# VCHomeDisplay, then behaves like VCHome.
 fun void VCHomeWrap=2453(,)
+
+# Like VCHomeExtend but when word-wrap is enabled extends first to start of display line
+# VCHomeDisplayExtend, then behaves like VCHomeExtend.
 fun void VCHomeWrapExtend=2454(,)
 
 # Copy the line containing the caret.
@@ -1622,19 +1647,20 @@ fun void MoveCaretInsideView=2401(,)
 fun int LineLength=2350(int line,)
 
 # Highlight the characters at two positions.
-fun void BraceHighlight=2351(position pos1, position pos2)
+fun void BraceHighlight=2351(position posA, position posB)
 
 # Use specified indicator to highlight matching braces instead of changing their style.
-fun void BraceHighlightIndicator=2498(bool useBraceHighlightIndicator, int indicator)
+fun void BraceHighlightIndicator=2498(bool useSetting, int indicator)
 
 # Highlight the character at a position indicating there is no matching brace.
 fun void BraceBadLight=2352(position pos,)
 
 # Use specified indicator to highlight non matching brace instead of changing its style.
-fun void BraceBadLightIndicator=2499(bool useBraceBadLightIndicator, int indicator)
+fun void BraceBadLightIndicator=2499(bool useSetting, int indicator)
 
 # Find the position of a matching brace or INVALID_POSITION if no match.
-fun position BraceMatch=2353(position pos,)
+# The maxReStyle must be 0 for now. It may be defined in a future release.
+fun position BraceMatch=2353(position pos, int maxReStyle)
 
 # Are the end of line characters visible?
 get bool GetViewEOL=2355(,)
@@ -1646,15 +1672,16 @@ set void SetViewEOL=2356(bool visible,)
 get int GetDocPointer=2357(,)
 
 # Change the document object used.
-set void SetDocPointer=2358(, int pointer)
+set void SetDocPointer=2358(, int doc)
 
 # Set which document modification events are sent to the container.
-set void SetModEventMask=2359(int mask,)
+set void SetModEventMask=2359(int eventMask,)
 
 enu EdgeVisualStyle=EDGE_
 val EDGE_NONE=0
 val EDGE_LINE=1
 val EDGE_BACKGROUND=2
+val EDGE_MULTILINE=3
 
 # Retrieve the column number which text should be kept within.
 get int GetEdgeColumn=2360(,)
@@ -1666,9 +1693,9 @@ set void SetEdgeColumn=2361(int column,)
 # Retrieve the edge highlight mode.
 get int GetEdgeMode=2362(,)
 
-# The edge may be displayed by a line (EDGE_LINE) or by highlighting text that
+# The edge may be displayed by a line (EDGE_LINE/EDGE_MULTILINE) or by highlighting text that
 # goes beyond it (EDGE_BACKGROUND) or not displayed at all (EDGE_NONE).
-set void SetEdgeMode=2363(int mode,)
+set void SetEdgeMode=2363(int edgeMode,)
 
 # Retrieve the colour used in edge indication.
 get colour GetEdgeColour=2364(,)
@@ -1676,16 +1703,22 @@ get colour GetEdgeColour=2364(,)
 # Change the colour used in edge indication.
 set void SetEdgeColour=2365(colour edgeColour,)
 
+# Add a new vertical edge to the view.
+fun void MultiEdgeAddLine=2694(int column, colour edgeColour)
+
+# Clear all vertical edges.
+fun void MultiEdgeClearAll=2695(,)
+
 # Sets the current caret position to be the search anchor.
 fun void SearchAnchor=2366(,)
 
 # Find some text starting at the search anchor.
 # Does not ensure the selection is visible.
-fun int SearchNext=2367(int flags, string text)
+fun int SearchNext=2367(int searchFlags, string text)
 
 # Find some text starting at the search anchor and moving backwards.
 # Does not ensure the selection is visible.
-fun int SearchPrev=2368(int flags, string text)
+fun int SearchPrev=2368(int searchFlags, string text)
 
 # Retrieves the number of lines completely visible.
 get int LinesOnScreen=2370(,)
@@ -1699,7 +1732,7 @@ get bool SelectionIsRectangle=2372(,)
 
 # Set the zoom level. This number of points is added to the size of all fonts.
 # It may be positive to magnify or negative to reduce.
-set void SetZoom=2373(int zoom,)
+set void SetZoom=2373(int zoomInPoints,)
 # Retrieve the zoom level.
 get int GetZoom=2374(,)
 
@@ -1727,7 +1760,7 @@ val SC_STATUS_WARN_START=1000
 val SC_STATUS_WARN_REGEX=1001
 
 # Change error status - 0 = OK.
-set void SetStatus=2382(int statusCode,)
+set void SetStatus=2382(int status,)
 # Get error status.
 get int GetStatus=2383(,)
 
@@ -1736,6 +1769,11 @@ set void SetMouseDownCaptures=2384(bool captures,)
 # Get whether mouse gets captured.
 get bool GetMouseDownCaptures=2385(,)
 
+# Set whether the mouse wheel can be active outside the window.
+set void SetMouseWheelCaptures=2696(bool captures,)
+# Get whether mouse wheel can be active outside the window.
+get bool GetMouseWheelCaptures=2697(,)
+
 enu CursorShape=SC_CURSOR
 val SC_CURSORNORMAL=-1
 val SC_CURSORARROW=2
@@ -1777,7 +1815,7 @@ fun void DelLineLeft=2395(,)
 fun void DelLineRight=2396(,)
 
 # Get and Set the xOffset (ie, horizontal scroll position).
-set void SetXOffset=2397(int newOffset,)
+set void SetXOffset=2397(int xOffset,)
 get int GetXOffset=2398(,)
 
 # Set the last x chosen value to be the caret x position.
@@ -1819,7 +1857,7 @@ fun void SetXCaretPolicy=2402(int caretPolicy, int caretSlop)
 fun void SetYCaretPolicy=2403(int caretPolicy, int caretSlop)
 
 # Set printing to line wrapped (SC_WRAP_WORD) or not line wrapped (SC_WRAP_NONE).
-set void SetPrintWrapMode=2406(int mode,)
+set void SetPrintWrapMode=2406(int wrapMode,)
 
 # Is printing line wrapped?
 get int GetPrintWrapMode=2407(,)
@@ -1848,10 +1886,13 @@ set void SetHotspotSingleLine=2421(bool singleLine,)
 # Get the HotspotSingleLine property
 get bool GetHotspotSingleLine=2497(,)
 
-# Move caret between paragraphs (delimited by empty lines).
+# Move caret down one paragraph (delimited by empty lines).
 fun void ParaDown=2413(,)
+# Extend selection down one paragraph (delimited by empty lines).
 fun void ParaDownExtend=2414(,)
+# Move caret up one paragraph (delimited by empty lines).
 fun void ParaUp=2415(,)
+# Extend selection up one paragraph (delimited by empty lines).
 fun void ParaUpExtend=2416(,)
 
 # Given a valid document position, return the previous position taking code
@@ -1880,7 +1921,7 @@ val SC_SEL_THIN=3
 
 # Set the selection mode to stream (SC_SEL_STREAM) or rectangular (SC_SEL_RECTANGLE/SC_SEL_THIN) or
 # by lines (SC_SEL_LINES).
-set void SetSelectionMode=2422(int mode,)
+set void SetSelectionMode=2422(int selectionMode,)
 
 # Get the mode of the current selection.
 get int GetSelectionMode=2423(,)
@@ -1970,7 +2011,7 @@ get int AutoCGetCurrent=2445(,)
 # Get currently selected item text in the auto-completion list
 # Returns the length of the item text
 # Result is NUL-terminated.
-get int AutoCGetCurrentText=2610(, stringresult s)
+get int AutoCGetCurrentText=2610(, stringresult text)
 
 enu CaseInsensitiveBehaviour=SC_CASEINSENSITIVEBEHAVIOUR_
 val SC_CASEINSENSITIVEBEHAVIOUR_RESPECTCASE=0
@@ -2080,22 +2121,22 @@ set void SetIndicatorValue=2502(int value,)
 get int GetIndicatorValue=2503(,)
 
 # Turn a indicator on over a range.
-fun void IndicatorFillRange=2504(int position, int fillLength)
+fun void IndicatorFillRange=2504(position start, int lengthFill)
 
 # Turn a indicator off over a range.
-fun void IndicatorClearRange=2505(int position, int clearLength)
+fun void IndicatorClearRange=2505(position start, int lengthClear)
 
-# Are any indicators present at position?
-fun int IndicatorAllOnFor=2506(int position,)
+# Are any indicators present at pos?
+fun int IndicatorAllOnFor=2506(position pos,)
 
-# What value does a particular indicator have at at a position?
-fun int IndicatorValueAt=2507(int indicator, int position)
+# What value does a particular indicator have at a position?
+fun int IndicatorValueAt=2507(int indicator, position pos)
 
 # Where does a particular indicator start?
-fun int IndicatorStart=2508(int indicator, int position)
+fun int IndicatorStart=2508(int indicator, position pos)
 
 # Where does a particular indicator end?
-fun int IndicatorEnd=2509(int indicator, int position)
+fun int IndicatorEnd=2509(int indicator, position pos)
 
 # Set number of entries in position cache
 set void SetPositionCache=2514(int size,)
@@ -2112,8 +2153,8 @@ get int GetCharacterPointer=2520(,)
 
 # Return a read-only pointer to a range of characters in the document.
 # May move the gap so that the range is contiguous, but will only move up
-# to rangeLength bytes.
-get int GetRangePointer=2643(int position, int rangeLength)
+# to lengthRange bytes.
+get int GetRangePointer=2643(position start, int lengthRange)
 
 # Return a position which, to avoid performance costs, should not be within
 # the range of a call to GetRangePointer.
@@ -2268,7 +2309,7 @@ set void SetAdditionalCaretsBlink=2567(bool additionalCaretsBlink,)
 get bool GetAdditionalCaretsBlink=2568(,)
 
 # Set whether additional carets are visible
-set void SetAdditionalCaretsVisible=2608(bool additionalCaretsBlink,)
+set void SetAdditionalCaretsVisible=2608(bool additionalCaretsVisible,)
 
 # Whether additional carets are visible
 get bool GetAdditionalCaretsVisible=2609(,)
@@ -2283,10 +2324,10 @@ get bool GetSelectionEmpty=2650(,)
 fun void ClearSelections=2571(,)
 
 # Set a simple selection
-fun int SetSelection=2572(int caret, int anchor)
+fun int SetSelection=2572(position caret, position anchor)
 
 # Add a selection
-fun int AddSelection=2573(int caret, int anchor)
+fun int AddSelection=2573(position caret, position anchor)
 
 # Drop one selection
 fun void DropSelectionN=2671(int selection,)
@@ -2297,42 +2338,61 @@ set void SetMainSelection=2574(int selection,)
 # Which selection is the main selection
 get int GetMainSelection=2575(,)
 
-set void SetSelectionNCaret=2576(int selection, position pos)
+# Set the caret position of the nth selection.
+set void SetSelectionNCaret=2576(int selection, position caret)
+# Return the caret position of the nth selection.
 get position GetSelectionNCaret=2577(int selection,)
-set void SetSelectionNAnchor=2578(int selection, position posAnchor)
+# Set the anchor position of the nth selection.
+set void SetSelectionNAnchor=2578(int selection, position anchor)
+# Return the anchor position of the nth selection.
 get position GetSelectionNAnchor=2579(int selection,)
+# Set the virtual space of the caret of the nth selection.
 set void SetSelectionNCaretVirtualSpace=2580(int selection, int space)
+# Return the virtual space of the caret of the nth selection.
 get int GetSelectionNCaretVirtualSpace=2581(int selection,)
+# Set the virtual space of the anchor of the nth selection.
 set void SetSelectionNAnchorVirtualSpace=2582(int selection, int space)
+# Return the virtual space of the anchor of the nth selection.
 get int GetSelectionNAnchorVirtualSpace=2583(int selection,)
 
 # Sets the position that starts the selection - this becomes the anchor.
-set void SetSelectionNStart=2584(int selection, position pos)
+set void SetSelectionNStart=2584(int selection, position anchor)
 
 # Returns the position at the start of the selection.
 get position GetSelectionNStart=2585(int selection,)
 
 # Sets the position that ends the selection - this becomes the currentPosition.
-set void SetSelectionNEnd=2586(int selection, position pos)
+set void SetSelectionNEnd=2586(int selection, position caret)
 
 # Returns the position at the end of the selection.
 get position GetSelectionNEnd=2587(int selection,)
 
-set void SetRectangularSelectionCaret=2588(position pos,)
+# Set the caret position of the rectangular selection.
+set void SetRectangularSelectionCaret=2588(position caret,)
+# Return the caret position of the rectangular selection.
 get position GetRectangularSelectionCaret=2589(,)
-set void SetRectangularSelectionAnchor=2590(position posAnchor,)
+# Set the anchor position of the rectangular selection.
+set void SetRectangularSelectionAnchor=2590(position anchor,)
+# Return the anchor position of the rectangular selection.
 get position GetRectangularSelectionAnchor=2591(,)
+# Set the virtual space of the caret of the rectangular selection.
 set void SetRectangularSelectionCaretVirtualSpace=2592(int space,)
+# Return the virtual space of the caret of the rectangular selection.
 get int GetRectangularSelectionCaretVirtualSpace=2593(,)
+# Set the virtual space of the anchor of the rectangular selection.
 set void SetRectangularSelectionAnchorVirtualSpace=2594(int space,)
+# Return the virtual space of the anchor of the rectangular selection.
 get int GetRectangularSelectionAnchorVirtualSpace=2595(,)
 
 enu VirtualSpace=SCVS_
 val SCVS_NONE=0
 val SCVS_RECTANGULARSELECTION=1
 val SCVS_USERACCESSIBLE=2
+val SCVS_NOWRAPLINESTART=4
 
+# Set options for virtual space behaviour.
 set void SetVirtualSpaceOptions=2596(int virtualSpaceOptions,)
+# Return options for virtual space behaviour.
 get int GetVirtualSpaceOptions=2597(,)
 
 # On GTK+, allow selecting the modifier key to use for mouse-based
@@ -2509,7 +2569,7 @@ set void SetProperty=4004(string key, string value)
 val KEYWORDSET_MAX=8
 
 # Set up the key words used by the lexer.
-set void SetKeyWords=4005(int keywordSet, string keyWords)
+set void SetKeyWords=4005(int keyWordSet, string keyWords)
 
 # Set the lexing language of the document based on string name.
 set void SetLexerLanguage=4006(, string language)
@@ -2519,16 +2579,16 @@ fun void LoadLexerLibrary=4007(, string path)
 
 # Retrieve a "property" value previously set with SetProperty.
 # Result is NUL-terminated.
-get int GetProperty=4008(string key, stringresult buf)
+get int GetProperty=4008(string key, stringresult value)
 
 # Retrieve a "property" value previously set with SetProperty,
 # with "$()" variable replacement on returned buffer.
 # Result is NUL-terminated.
-get int GetPropertyExpanded=4009(string key, stringresult buf)
+get int GetPropertyExpanded=4009(string key, stringresult value)
 
 # Retrieve a "property" value previously set with SetProperty,
 # interpreted as an int AFTER any "$()" variable replacement.
-get int GetPropertyInt=4010(string key,)
+get int GetPropertyInt=4010(string key, int defaultValue)
 
 # Retrieve the number of bits the current lexer needs for styling.
 get int GetStyleBitsNeeded=4011(,)
@@ -2536,7 +2596,7 @@ get int GetStyleBitsNeeded=4011(,)
 # Retrieve the name of the lexer.
 # Return the length of the text.
 # Result is NUL-terminated.
-get int GetLexerLanguage=4012(, stringresult text)
+get int GetLexerLanguage=4012(, stringresult language)
 
 # For private communication between an application and a known lexer.
 fun int PrivateLexerCall=4013(int operation, int pointer)
@@ -3332,6 +3392,20 @@ val SCE_BAAN_OPERATOR=7
 val SCE_BAAN_IDENTIFIER=8
 val SCE_BAAN_STRINGEOL=9
 val SCE_BAAN_WORD2=10
+val SCE_BAAN_WORD3=11
+val SCE_BAAN_WORD4=12
+val SCE_BAAN_WORD5=13
+val SCE_BAAN_WORD6=14
+val SCE_BAAN_WORD7=15
+val SCE_BAAN_WORD8=16
+val SCE_BAAN_WORD9=17
+val SCE_BAAN_TABLEDEF=18
+val SCE_BAAN_TABLESQL=19
+val SCE_BAAN_FUNCTION=20
+val SCE_BAAN_DOMDEF=21
+val SCE_BAAN_FUNCDEF=22
+val SCE_BAAN_OBJECTDEF=23
+val SCE_BAAN_DEFINEDEF=24
 # Lexical states for SCLEX_LISP
 lex Lisp=SCLEX_LISP SCE_LISP_
 val SCE_LISP_DEFAULT=0
@@ -4106,39 +4180,20 @@ val SCE_PLM_OPERATOR=5
 val SCE_PLM_CONTROL=6
 val SCE_PLM_KEYWORD=7
 # Lexical state for SCLEX_PROGRESS
-lex Progress=SCLEX_PROGRESS SCE_4GL_
-val SCE_4GL_DEFAULT=0
-val SCE_4GL_NUMBER=1
-val SCE_4GL_WORD=2
-val SCE_4GL_STRING=3
-val SCE_4GL_CHARACTER=4
-val SCE_4GL_PREPROCESSOR=5
-val SCE_4GL_OPERATOR=6
-val SCE_4GL_IDENTIFIER=7
-val SCE_4GL_BLOCK=8
-val SCE_4GL_END=9
-val SCE_4GL_COMMENT1=10
-val SCE_4GL_COMMENT2=11
-val SCE_4GL_COMMENT3=12
-val SCE_4GL_COMMENT4=13
-val SCE_4GL_COMMENT5=14
-val SCE_4GL_COMMENT6=15
-val SCE_4GL_DEFAULT_=16
-val SCE_4GL_NUMBER_=17
-val SCE_4GL_WORD_=18
-val SCE_4GL_STRING_=19
-val SCE_4GL_CHARACTER_=20
-val SCE_4GL_PREPROCESSOR_=21
-val SCE_4GL_OPERATOR_=22
-val SCE_4GL_IDENTIFIER_=23
-val SCE_4GL_BLOCK_=24
-val SCE_4GL_END_=25
-val SCE_4GL_COMMENT1_=26
-val SCE_4GL_COMMENT2_=27
-val SCE_4GL_COMMENT3_=28
-val SCE_4GL_COMMENT4_=29
-val SCE_4GL_COMMENT5_=30
-val SCE_4GL_COMMENT6_=31
+lex Progress=SCLEX_PROGRESS SCE_ABL_
+val SCE_ABL_DEFAULT=0
+val SCE_ABL_NUMBER=1
+val SCE_ABL_WORD=2
+val SCE_ABL_STRING=3
+val SCE_ABL_CHARACTER=4
+val SCE_ABL_PREPROCESSOR=5
+val SCE_ABL_OPERATOR=6
+val SCE_ABL_IDENTIFIER=7
+val SCE_ABL_BLOCK=8
+val SCE_ABL_END=9
+val SCE_ABL_COMMENT=10
+val SCE_ABL_TASKMARKER=11
+val SCE_ABL_LINECOMMENT=12
 # Lexical states for SCLEX_ABAQUS
 lex ABAQUS=SCLEX_ABAQUS SCE_ABAQUS_
 val SCE_ABAQUS_DEFAULT=0
diff --git a/src/stc/scintilla/lexers/LexAbaqus.cxx b/src/stc/scintilla/lexers/LexAbaqus.cxx
index 509d89a..5f265c7 100644
--- a/src/stc/scintilla/lexers/LexAbaqus.cxx
+++ b/src/stc/scintilla/lexers/LexAbaqus.cxx
@@ -581,14 +581,14 @@ WordList *[], Accessor &styler) {
     for ( Sci_Position ll = beginData; ll < beginComment; ll++ )
         SafeSetLevel(ll, datLevel, styler) ;
 
-	if ( prvKeyLineTp == 5 ) {
-		level += 1 ;
-	}
+    if ( prvKeyLineTp == 5 ) {
+        level += 1 ;
+    }
 
-	if ( prvKeyLineTp == 6 ) {
-		level -= 1 ;
-	}
-	for ( Sci_Position m = beginComment; m <= endLine; m++ )
+    if ( prvKeyLineTp == 6 ) {
+        level -= 1 ;
+    }
+    for ( Sci_Position m = beginComment; m <= endLine; m++ )
         SafeSetLevel(m, level, styler) ;
 }
 
diff --git a/src/stc/scintilla/lexers/LexBaan.cxx b/src/stc/scintilla/lexers/LexBaan.cxx
index 8da2f3a..a4e2d41 100644
--- a/src/stc/scintilla/lexers/LexBaan.cxx
+++ b/src/stc/scintilla/lexers/LexBaan.cxx
@@ -1,134 +1,568 @@
 // Scintilla source code edit control
 /** @file LexBaan.cxx
- ** Lexer for Baan.
- ** Based heavily on LexCPP.cxx
- **/
+** Lexer for Baan.
+** Based heavily on LexCPP.cxx
+**/
 // Copyright 2001- by Vamsi Potluru <vamsi@who.net> & Praveen Ambekar <ambekarpraveen@yahoo.com>
 // The License.txt file describes the conditions under which this software may be distributed.
 
+// C standard library
 #include <stdlib.h>
 #include <string.h>
-#include <stdio.h>
-#include <stdarg.h>
-#include <assert.h>
-#include <ctype.h>
 
+// C++ wrappers of C standard library
+#include <cassert>
+
+// C++ standard library
+#include <string>
+#include <map>
+
+// Scintilla headers
+
+// Non-platform-specific headers
+
+// include
 #include "ILexer.h"
 #include "Scintilla.h"
 #include "SciLexer.h"
 
+// lexlib
 #include "WordList.h"
 #include "LexAccessor.h"
-#include "Accessor.h"
 #include "StyleContext.h"
 #include "CharacterSet.h"
 #include "LexerModule.h"
+#include "OptionSet.h"
 
-#ifdef SCI_NAMESPACE
+# ifdef SCI_NAMESPACE
 using namespace Scintilla;
-#endif
+# endif
+
+namespace {
+	// Use an unnamed namespace to protect the functions and classes from name conflicts
+
+// Options used for LexerBaan
+struct OptionsBaan {
+	bool fold;
+	bool foldComment;
+	bool foldPreprocessor;
+	bool foldCompact;
+	bool baanFoldSyntaxBased;
+	bool baanFoldKeywordsBased;
+	bool baanStylingWithinPreprocessor;
+	OptionsBaan() {
+		fold = false;
+		foldComment = false;
+		foldPreprocessor = false;
+		foldCompact = false;
+		baanFoldSyntaxBased = false;
+		baanFoldKeywordsBased = false;
+		baanStylingWithinPreprocessor = false;
+	}
+};
+
+const char *const baanWordLists[] = {
+	"Baan & BaanSQL Reserved Keywords ",
+	"Baan Standard functions",
+	"Baan Functions Abridged",
+	"Baan Main Sections ",
+	"Baan Sub Sections",
+	"PreDefined Variables",
+	"PreDefined Attributes",
+	"Enumerates",
+	0,
+};
+
+struct OptionSetBaan : public OptionSet<OptionsBaan> {
+	OptionSetBaan() {
+		DefineProperty("fold", &OptionsBaan::fold);
+
+		DefineProperty("fold.comment", &OptionsBaan::foldComment);
+
+		DefineProperty("fold.preprocessor", &OptionsBaan::foldPreprocessor);
+
+		DefineProperty("fold.compact", &OptionsBaan::foldCompact);
+
+		DefineProperty("fold.baan.syntax.based", &OptionsBaan::baanFoldSyntaxBased,
+			"Set this property to 0 to disable syntax based folding, which is folding based on '{' & '('.");
+		
+		DefineProperty("fold.baan.keywords.based", &OptionsBaan::baanFoldKeywordsBased,
+			"Set this property to 0 to disable keywords based folding, which is folding based on "
+			" for, if, on (case), repeat, select, while and fold ends based on endfor, endif, endcase, until, endselect, endwhile respectively.");
+
+		DefineProperty("lexer.baan.styling.within.preprocessor", &OptionsBaan::baanStylingWithinPreprocessor,
+			"For Baan code, determines whether all preprocessor code is styled in the "
+			"preprocessor style (0, the default) or only from the initial # to the end "
+			"of the command word(1).");
+
+		DefineWordListSets(baanWordLists);
+	}
+};
 
 static inline bool IsAWordChar(const int  ch) {
-	return (ch < 0x80) && (isalnum(ch) || ch == '.' || ch == '_' || ch == '$' || ch == ':');
+	return (ch < 0x80) && (isalnum(ch) || ch == '.' || ch == '_' || ch == '$');
 }
 
 static inline bool IsAWordStart(const int ch) {
 	return (ch < 0x80) && (isalnum(ch) || ch == '_');
 }
 
-static void ColouriseBaanDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *keywordlists[],
-                            Accessor &styler) {
+static inline bool IsAnOperator(int ch) {
+	if (IsAlphaNumeric(ch))
+		return false;
+	if (ch == '#' || ch == '^' || ch == '&' || ch == '*' ||
+		ch == '(' || ch == ')' || ch == '-' || ch == '+' ||
+		ch == '=' || ch == '|' || ch == '{' || ch == '}' ||
+		ch == '[' || ch == ']' || ch == ':' || ch == ';' ||
+		ch == '<' || ch == '>' || ch == ',' || ch == '/' ||
+		ch == '?' || ch == '!' || ch == '"' || ch == '~' ||
+		ch == '\\')
+		return true;
+	return false;
+}
+
+static inline int IsAnyOtherIdentifier(char *s, int sLength) {
+
+	/*	IsAnyOtherIdentifier uses standard templates used in baan.
+	The matching template is shown as comments just above the return condition.
+	^ - refers to any character [a-z].
+	# - refers to any number [0-9].
+	Other characters shown are compared as is.
+	Tried implementing with Regex... it was too complicated for me.
+	Any other implementation suggestion welcome.
+	*/
+	switch (sLength) {
+	case 8:
+		if (isalpha(s[0]) && isalpha(s[1]) && isalpha(s[2]) && isalpha(s[3]) && isalpha(s[4]) && IsADigit(s[5]) && IsADigit(s[6]) && IsADigit(s[7])) {
+			//^^^^^### 
+			return(SCE_BAAN_TABLEDEF);
+		}
+		break;
+	case 9:
+		if (s[0] == 't' && isalpha(s[1]) && isalpha(s[2]) && isalpha(s[3]) && isalpha(s[4]) && isalpha(s[5]) && IsADigit(s[6]) && IsADigit(s[7]) && IsADigit(s[8])) {
+			//t^^^^^###
+			return(SCE_BAAN_TABLEDEF);
+		}
+		else if (s[8] == '.' && isalpha(s[0]) && isalpha(s[1]) && isalpha(s[2]) && isalpha(s[3]) && isalpha(s[4]) && IsADigit(s[5]) && IsADigit(s[6]) && IsADigit(s[7])) {
+			//^^^^^###.
+			return(SCE_BAAN_TABLESQL);
+		}
+		break;
+	case 13:
+		if (s[8] == '.' && isalpha(s[0]) && isalpha(s[1]) && isalpha(s[2]) && isalpha(s[3]) && isalpha(s[4]) && IsADigit(s[5]) && IsADigit(s[6]) && IsADigit(s[7])) {
+			//^^^^^###.****
+			return(SCE_BAAN_TABLESQL);
+		}
+		else if (s[0] == 'r' && s[1] == 'c' && s[2] == 'd' && s[3] == '.' && s[4] == 't' && isalpha(s[5]) && isalpha(s[6]) && isalpha(s[7]) && isalpha(s[8]) && isalpha(s[9]) && IsADigit(s[10]) && IsADigit(s[11]) && IsADigit(s[12])) {
+			//rcd.t^^^^^###
+			return(SCE_BAAN_TABLEDEF);
+		}
+		break;
+	case 14:
+	case 15:
+		if (s[8] == '.' && isalpha(s[0]) && isalpha(s[1]) && isalpha(s[2]) && isalpha(s[3]) && isalpha(s[4]) && IsADigit(s[5]) && IsADigit(s[6]) && IsADigit(s[7])) {
+			if (s[13] != ':') {
+				//^^^^^###.******
+				return(SCE_BAAN_TABLESQL);
+			}
+		}
+		break;
+	case 16:
+	case 17:
+		if (s[8] == '.' && s[9] == '_' && s[10] == 'i' && s[11] == 'n' && s[12] == 'd' && s[13] == 'e' && s[14] == 'x' && IsADigit(s[15]) && isalpha(s[0]) && isalpha(s[1]) && isalpha(s[2]) && isalpha(s[3]) && isalpha(s[4]) && IsADigit(s[5]) && IsADigit(s[6]) && IsADigit(s[7])) {
+			//^^^^^###._index##
+			return(SCE_BAAN_TABLEDEF);
+		}
+		else if (s[8] == '.' && s[9] == '_' && s[10] == 'c' && s[11] == 'o' && s[12] == 'm' && s[13] == 'p' && s[14] == 'n' && s[15] == 'r' && isalpha(s[0]) && isalpha(s[1]) && isalpha(s[2]) && isalpha(s[3]) && isalpha(s[4]) && IsADigit(s[5]) && IsADigit(s[6]) && IsADigit(s[7])) {
+			//^^^^^###._compnr
+			return(SCE_BAAN_TABLEDEF);
+		}
+		break;
+	default:
+		break;
+	}
+	if (sLength > 14 && s[5] == '.' && s[6] == 'd' && s[7] == 'l' && s[8] == 'l' && s[13] == '.' && isalpha(s[0]) && isalpha(s[1]) && isalpha(s[2]) && isalpha(s[3]) && isalpha(s[4]) && IsADigit(s[9]) && IsADigit(s[10]) && IsADigit(s[11]) && IsADigit(s[12])) {
+		//^^^^^.dll####.
+		return(SCE_BAAN_FUNCTION);
+	}
+	else if (sLength > 15 && s[2] == 'i' && s[3] == 'n' && s[4] == 't' && s[5] == '.' && s[6] == 'd' && s[7] == 'l' && s[8] == 'l' && isalpha(s[0]) && isalpha(s[1]) && isalpha(s[9]) && isalpha(s[10]) && isalpha(s[11]) && isalpha(s[12]) && isalpha(s[13])) {
+		//^^int.dll^^^^^.
+		return(SCE_BAAN_FUNCTION);
+	}
+	else if (sLength > 11 && s[0] == 'i' && s[10] == '.' && isalpha(s[1]) && isalpha(s[2]) && isalpha(s[3]) && isalpha(s[4]) && isalpha(s[5]) && IsADigit(s[6]) && IsADigit(s[7]) && IsADigit(s[8]) && IsADigit(s[9])) {
+		//i^^^^^####.
+		return(SCE_BAAN_FUNCTION);
+	}
+
+	return(SCE_BAAN_DEFAULT);
+}
+
+static inline bool IsCommentLine(Sci_Position line, IDocument *pAccess) {
+	LexAccessor styler(pAccess);
+	Sci_Position pos = styler.LineStart(line);
+	Sci_Position eol_pos = styler.LineStart(line + 1) - 1;
+	for (Sci_Position i = pos; i < eol_pos; i++) {
+		char ch = styler[i];
+		if (ch == '|')
+			return true;
+		else if (ch != ' ' && ch != '\t')
+			return false;
+	}
+	return false;
+}
+
+static inline bool IsPreProcLine(Sci_Position line, IDocument *pAccess) {
+	LexAccessor styler(pAccess);
+	Sci_Position pos = styler.LineStart(line);
+	Sci_Position eol_pos = styler.LineStart(line + 1) - 1;
+	for (Sci_Position i = pos; i < eol_pos; i++) {
+		char ch = styler[i];
+		if (ch == '#' || ch == '|' || ch == '^')
+			return true;
+		else if (ch != ' ' && ch != '\t')
+			return false;
+	}
+	return false;
+}
+
+static inline int ToLowerCase(int c) {
+	if (c >= 'A' && c <= 'Z')
+		return 'a' + c - 'A';
+	return c;
+}
+
+static inline bool wordInArray(const std::string& value, std::string *array, int length)
+{
+	for (int i = 0; i < length; i++)
+	{
+		if (value == array[i])
+		{
+			return true;
+		}
+	}
+
+	return false;
+}
+
+class WordListAbridged : public WordList {
+public:
+	WordListAbridged() {
+		kwAbridged = false;
+		kwHasSection = false;
+	};
+	~WordListAbridged() {
+		Clear();
+	};
+	bool kwAbridged;
+	bool kwHasSection;
+	bool Contains(const char *s) {
+		return kwAbridged ? InListAbridged(s, '~') : InList(s);
+	};
+};
+
+}
+
+class LexerBaan : public ILexer {
+	WordListAbridged keywords;
+	WordListAbridged keywords2;
+	WordListAbridged keywords3;
+	WordListAbridged keywords4;
+	WordListAbridged keywords5;
+	WordListAbridged keywords6;
+	WordListAbridged keywords7;
+	WordListAbridged keywords8;
+	WordListAbridged keywords9;
+	OptionsBaan options;
+	OptionSetBaan osBaan;
+public:
+	LexerBaan() {
+	}
+
+	virtual ~LexerBaan() {
+	}
+
+	int SCI_METHOD Version() const {
+		return lvOriginal;
+	}
+
+	void SCI_METHOD Release() {
+		delete this;
+	}
+
+	const char * SCI_METHOD PropertyNames() {
+		return osBaan.PropertyNames();
+	}
+
+	int SCI_METHOD PropertyType(const char * name) {
+		return osBaan.PropertyType(name);
+	}
+
+	const char * SCI_METHOD DescribeProperty(const char * name) {
+		return osBaan.DescribeProperty(name);
+	}
+
+	int SCI_METHOD PropertySet(const char *key, const char *val);
+
+	const char * SCI_METHOD DescribeWordListSets() {
+		return osBaan.DescribeWordListSets();
+	}
+
+	Sci_Position SCI_METHOD WordListSet(int n, const char *wl);
+
+	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess);
+
+	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess);
+
+	void * SCI_METHOD PrivateCall(int, void *) {
+		return NULL;
+	}
+
+	static ILexer * LexerFactoryBaan() {
+		return new LexerBaan();
+	}
+};
+
+Sci_Position SCI_METHOD LexerBaan::PropertySet(const char *key, const char *val) {
+	if (osBaan.PropertySet(&options, key, val)) {
+		return 0;
+	}
+	return -1;
+}
+
+Sci_Position SCI_METHOD LexerBaan::WordListSet(int n, const char *wl) {
+	WordListAbridged *WordListAbridgedN = 0;
+	switch (n) {
+	case 0:
+		WordListAbridgedN = &keywords;
+		break;
+	case 1:
+		WordListAbridgedN = &keywords2;
+		break;
+	case 2:
+		WordListAbridgedN = &keywords3;
+		break;
+	case 3:
+		WordListAbridgedN = &keywords4;
+		break;
+	case 4:
+		WordListAbridgedN = &keywords5;
+		break;
+	case 5:
+		WordListAbridgedN = &keywords6;
+		break;
+	case 6:
+		WordListAbridgedN = &keywords7;
+		break;
+	case 7:
+		WordListAbridgedN = &keywords8;
+		break;
+	case 8:
+		WordListAbridgedN = &keywords9;
+		break;
+	}
+	Sci_Position firstModification = -1;
+	if (WordListAbridgedN) {
+		WordListAbridged wlNew;
+		wlNew.Set(wl);
+		if (*WordListAbridgedN != wlNew) {
+			WordListAbridgedN->Set(wl);
+			WordListAbridgedN->kwAbridged = strchr(wl, '~') != NULL;
+			WordListAbridgedN->kwHasSection = strchr(wl, ':') != NULL;
+
+			firstModification = 0;
+		}
+	}
+	return firstModification;
+}
 
-	WordList &keywords = *keywordlists[0];
-	WordList &keywords2 = *keywordlists[1];
-	bool stylingWithinPreprocessor = styler.GetPropertyInt("styling.within.preprocessor") != 0;
+void SCI_METHOD LexerBaan::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
 
 	if (initStyle == SCE_BAAN_STRINGEOL)	// Does not leak onto next line
 		initStyle = SCE_BAAN_DEFAULT;
 
 	int visibleChars = 0;
+	bool lineHasDomain = false;
+	bool lineHasFunction = false;
+	bool lineHasPreProc = false;
+	bool lineIgnoreString = false;
+	bool lineHasDefines = false;
 
+	LexAccessor styler(pAccess);
 	StyleContext sc(startPos, length, initStyle, styler);
 
 	for (; sc.More(); sc.Forward()) {
 
-		if (sc.state == SCE_BAAN_OPERATOR) {
+		// Determine if the current state should terminate.
+		switch (sc.state) {
+		case SCE_BAAN_OPERATOR:
 			sc.SetState(SCE_BAAN_DEFAULT);
-		} else if (sc.state == SCE_BAAN_NUMBER) {
+			break;
+		case SCE_BAAN_NUMBER:
 			if (!IsAWordChar(sc.ch)) {
 				sc.SetState(SCE_BAAN_DEFAULT);
 			}
-		} else if (sc.state == SCE_BAAN_IDENTIFIER) {
+			break;
+		case SCE_BAAN_IDENTIFIER:
 			if (!IsAWordChar(sc.ch)) {
-				char s[100];
+				char s[1000];
+				char s1[1000];
 				sc.GetCurrentLowered(s, sizeof(s));
-				if (keywords.InList(s)) {
+				if (sc.ch == ':') {
+					memcpy(s1, s, sizeof(s));
+					s1[sc.LengthCurrent()] = sc.ch;
+					s1[sc.LengthCurrent() + 1] = '\0';
+				}
+				if ((keywords.kwHasSection && (sc.ch == ':')) ? keywords.Contains(s1) : keywords.Contains(s)) {
 					sc.ChangeState(SCE_BAAN_WORD);
-				} else if (keywords2.InList(s)) {
+					if (0 == strcmp(s, "domain")) {
+						lineHasDomain = true;
+					}
+					else if (0 == strcmp(s, "function")) {
+						lineHasFunction = true;
+					}
+				}
+				else if ((keywords2.kwHasSection && (sc.ch == ':')) ? keywords2.Contains(s1) : keywords2.Contains(s)) {
 					sc.ChangeState(SCE_BAAN_WORD2);
 				}
+				else if ((keywords3.kwHasSection && (sc.ch == ':')) ? keywords3.Contains(s1) : keywords3.Contains(s)) {
+					sc.ChangeState(SCE_BAAN_WORD3);
+				}
+				else if ((keywords4.kwHasSection && (sc.ch == ':')) ? keywords4.Contains(s1) : keywords4.Contains(s)) {
+					sc.ChangeState(SCE_BAAN_WORD4);
+				}
+				else if ((keywords5.kwHasSection && (sc.ch == ':')) ? keywords5.Contains(s1) : keywords5.Contains(s)) {
+					sc.ChangeState(SCE_BAAN_WORD5);
+				}
+				else if ((keywords6.kwHasSection && (sc.ch == ':')) ? keywords6.Contains(s1) : keywords6.Contains(s)) {
+					sc.ChangeState(SCE_BAAN_WORD6);
+				}
+				else if ((keywords7.kwHasSection && (sc.ch == ':')) ? keywords7.Contains(s1) : keywords7.Contains(s)) {
+					sc.ChangeState(SCE_BAAN_WORD7);
+				}
+				else if ((keywords8.kwHasSection && (sc.ch == ':')) ? keywords8.Contains(s1) : keywords8.Contains(s)) {
+					sc.ChangeState(SCE_BAAN_WORD8);
+				}
+				else if ((keywords9.kwHasSection && (sc.ch == ':')) ? keywords9.Contains(s1) : keywords9.Contains(s)) {
+					sc.ChangeState(SCE_BAAN_WORD9);
+				}
+				else if (lineHasDomain) {
+					sc.ChangeState(SCE_BAAN_DOMDEF);
+					lineHasDomain = false;
+				}
+				else if (lineHasFunction) {
+					sc.ChangeState(SCE_BAAN_FUNCDEF);
+					lineHasFunction = false;
+				}
+				else if (lineHasPreProc) {
+					sc.ChangeState(SCE_BAAN_OBJECTDEF);
+					lineHasPreProc = false;
+				}
+				else if (lineHasDefines) {
+					sc.ChangeState(SCE_BAAN_DEFINEDEF);
+					lineHasDefines = false;
+				}
+				else {
+					int state = IsAnyOtherIdentifier(s, sc.LengthCurrent());
+					if (state > 0) {
+						sc.ChangeState(state);
+					}
+				}
 				sc.SetState(SCE_BAAN_DEFAULT);
 			}
-		} else if (sc.state == SCE_BAAN_PREPROCESSOR) {
-			if (stylingWithinPreprocessor) {
-				if (IsASpace(sc.ch)) {
+			break;
+		case SCE_BAAN_PREPROCESSOR:
+			if (options.baanStylingWithinPreprocessor) {
+				if (IsASpace(sc.ch) || IsAnOperator(sc.ch)) {
 					sc.SetState(SCE_BAAN_DEFAULT);
 				}
-			} else {
+			}
+			else {
 				if (sc.atLineEnd && (sc.chNext != '^')) {
 					sc.SetState(SCE_BAAN_DEFAULT);
 				}
 			}
-		} else if (sc.state == SCE_BAAN_COMMENT) {
+			break;
+		case SCE_BAAN_COMMENT:
 			if (sc.atLineEnd) {
 				sc.SetState(SCE_BAAN_DEFAULT);
 			}
-		} else if (sc.state == SCE_BAAN_COMMENTDOC) {
+			break;
+		case SCE_BAAN_COMMENTDOC:
 			if (sc.MatchIgnoreCase("enddllusage")) {
-				for (unsigned int i = 0; i < 10; i++){
+				for (unsigned int i = 0; i < 10; i++) {
+					sc.Forward();
+				}
+				sc.ForwardSetState(SCE_BAAN_DEFAULT);
+			}
+			else if (sc.MatchIgnoreCase("endfunctionusage")) {
+				for (unsigned int i = 0; i < 15; i++) {
 					sc.Forward();
 				}
 				sc.ForwardSetState(SCE_BAAN_DEFAULT);
 			}
-		} else if (sc.state == SCE_BAAN_STRING) {
+			break;
+		case SCE_BAAN_STRING:
 			if (sc.ch == '\"') {
 				sc.ForwardSetState(SCE_BAAN_DEFAULT);
-			} else if ((sc.atLineEnd) && (sc.chNext != '^')) {
+			}
+			else if ((sc.atLineEnd) && (sc.chNext != '^')) {
 				sc.ChangeState(SCE_BAAN_STRINGEOL);
-				sc.ForwardSetState(SCE_C_DEFAULT);
+				sc.ForwardSetState(SCE_BAAN_DEFAULT);
 				visibleChars = 0;
 			}
+			break;
 		}
 
+		// Determine if a new state should be entered.
 		if (sc.state == SCE_BAAN_DEFAULT) {
 			if (IsADigit(sc.ch) || (sc.ch == '.' && IsADigit(sc.chNext))) {
 				sc.SetState(SCE_BAAN_NUMBER);
-			} else if (sc.MatchIgnoreCase("dllusage")){
-					sc.SetState(SCE_BAAN_COMMENTDOC);
-					do {
-						sc.Forward();
-					} while ((!sc.atLineEnd) && sc.More());
-			} else if (IsAWordStart(sc.ch)) {
-					sc.SetState(SCE_BAAN_IDENTIFIER);
-			} else if (sc.Match('|')){
-					sc.SetState(SCE_BAAN_COMMENT);
-			} else if (sc.ch == '\"') {
+			}
+			else if (sc.MatchIgnoreCase("dllusage") || sc.MatchIgnoreCase("functionusage")) {
+				sc.SetState(SCE_BAAN_COMMENTDOC);
+				do {
+					sc.Forward();
+				} while ((!sc.atLineEnd) && sc.More());
+			}
+			else if (IsAWordStart(sc.ch)) {
+				sc.SetState(SCE_BAAN_IDENTIFIER);
+			}
+			else if (sc.Match('|')) {
+				sc.SetState(SCE_BAAN_COMMENT);
+			}
+			else if (sc.ch == '\"' && !(lineIgnoreString)) {
 				sc.SetState(SCE_BAAN_STRING);
-			} else if (sc.ch == '#' && visibleChars == 0) {
+			}
+			else if (sc.ch == '#' && visibleChars == 0) {
 				// Preprocessor commands are alone on their line
 				sc.SetState(SCE_BAAN_PREPROCESSOR);
 				// Skip whitespace between # and preprocessor word
 				do {
 					sc.Forward();
 				} while (IsASpace(sc.ch) && sc.More());
-			} else if (isoperator(static_cast<char>(sc.ch))) {
+				if (sc.MatchIgnoreCase("pragma") || sc.MatchIgnoreCase("include")) {
+					lineHasPreProc = true;
+					lineIgnoreString = true;
+				}
+				else if (sc.MatchIgnoreCase("define") || sc.MatchIgnoreCase("undef")) {
+					lineHasDefines = true;
+					lineIgnoreString = false;
+				}
+			}
+			else if (IsAnOperator(static_cast<char>(sc.ch))) {
 				sc.SetState(SCE_BAAN_OPERATOR);
 			}
 		}
+
 		if (sc.atLineEnd) {
 			// Reset states to begining of colourise so no surprises
 			// if different sets of lines lexed.
 			visibleChars = 0;
+			lineHasDomain = false;
+			lineHasFunction = false;
+			lineHasPreProc = false;
+			lineIgnoreString = false;
+			lineHasDefines = false;
 		}
 		if (!IsASpace(sc.ch)) {
 			visibleChars++;
@@ -137,10 +571,18 @@ static void ColouriseBaanDoc(Sci_PositionU startPos, Sci_Position length, int in
 	sc.Complete();
 }
 
-static void FoldBaanDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *[],
-                            Accessor &styler) {
-	bool foldComment = styler.GetPropertyInt("fold.comment") != 0;
-	bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
+void SCI_METHOD LexerBaan::Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
+
+	char word[100];
+	bool foldStart = true;
+	bool foldNextSelect = true;
+	int wordlen = 0;
+
+	std::string startTags[6] = { "for", "if", "on", "repeat", "select", "while" };
+	std::string endTags[6] = { "endcase", "endfor", "endif", "endselect", "endwhile", "until" };
+	std::string selectCloseTags[5] = { "selectdo", "selecteos", "selectempty", "selecterror", "endselect" };
+
+	LexAccessor styler(pAccess);
 	Sci_PositionU endPos = startPos + length;
 	int visibleChars = 0;
 	Sci_Position lineCurrent = styler.GetLine(startPos);
@@ -149,6 +591,7 @@ static void FoldBaanDoc(Sci_PositionU startPos, Sci_Position length, int initSty
 	char chNext = styler[startPos];
 	int styleNext = styler.StyleAt(startPos);
 	int style = initStyle;
+
 	for (Sci_PositionU i = startPos; i < endPos; i++) {
 		char ch = chNext;
 		chNext = styler.SafeGetCharAt(i + 1);
@@ -156,25 +599,100 @@ static void FoldBaanDoc(Sci_PositionU startPos, Sci_Position length, int initSty
 		style = styleNext;
 		styleNext = styler.StyleAt(i + 1);
 		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
-		if (foldComment &&
-			(style == SCE_BAAN_COMMENT || style == SCE_BAAN_COMMENTDOC)) {
+		if (options.foldComment && style == SCE_BAAN_COMMENTDOC) {
 			if (style != stylePrev) {
 				levelCurrent++;
-			} else if ((style != styleNext) && !atEOL) {
+			}
+			else if ((style != styleNext) && !atEOL) {
 				// Comments don't end at end of line and the next character may be unstyled.
 				levelCurrent--;
 			}
 		}
-		if (style == SCE_BAAN_OPERATOR) {
-			if (ch == '{') {
+		if (options.foldComment && atEOL && IsCommentLine(lineCurrent, pAccess)) {
+			if (!IsCommentLine(lineCurrent - 1, pAccess)
+				&& IsCommentLine(lineCurrent + 1, pAccess))
 				levelCurrent++;
-			} else if (ch == '}') {
+			else if (IsCommentLine(lineCurrent - 1, pAccess)
+				&& !IsCommentLine(lineCurrent + 1, pAccess))
 				levelCurrent--;
+		}
+		if (options.foldPreprocessor && atEOL && IsPreProcLine(lineCurrent, pAccess)) {
+			if (!IsPreProcLine(lineCurrent - 1, pAccess)
+				&& IsPreProcLine(lineCurrent + 1, pAccess))
+				levelCurrent++;
+			else if (IsPreProcLine(lineCurrent - 1, pAccess)
+				&& !IsPreProcLine(lineCurrent + 1, pAccess))
+				levelCurrent--;
+		}
+		if (options.baanFoldSyntaxBased && (style == SCE_BAAN_OPERATOR)) {
+			if (ch == '{' || ch == '(') {
+				levelCurrent++;
+			}
+			else if (ch == '}' || ch == ')') {
+				levelCurrent--;
+			}
+		}
+		if (options.baanFoldKeywordsBased && style == SCE_BAAN_WORD) {
+			word[wordlen++] = static_cast<char>(ToLowerCase(ch));
+			if (wordlen == 100) {                   // prevent overflow
+				word[0] = '\0';
+				wordlen = 1;
+			}
+			if (styleNext != SCE_BAAN_WORD) {
+				word[wordlen] = '\0';
+				wordlen = 0;
+				if (strcmp(word, "for") == 0) {
+					Sci_PositionU j = i + 1;
+					while ((j < endPos) && IsASpaceOrTab(styler.SafeGetCharAt(j))) {
+						j++;
+					}
+					if (styler.Match(j, "update")) {
+						// Means this is a "for update" used by Select which is already folded.
+						foldStart = false;
+					}
+				}
+				else if (strcmp(word, "on") == 0) {
+					Sci_PositionU j = i + 1;
+					while ((j < endPos) && IsASpaceOrTab(styler.SafeGetCharAt(j))) {
+						j++;
+					}
+					if (!styler.Match(j, "case")) {
+						// Means this is not a "on Case" statement... could be "on" used by index.
+						foldStart = false;
+					}
+				}
+				else if (strcmp(word, "select") == 0) {
+					if (foldNextSelect) {
+						// Next Selects are sub-clause till reach of selectCloseTags[] array.
+						foldNextSelect = false;
+						foldStart = true;
+					}
+					else {
+						foldNextSelect = false;
+						foldStart = false;
+					}
+				}
+				else if (wordInArray(word, selectCloseTags, 5)) {
+					// select clause ends, next select clause can be folded.
+					foldNextSelect = true;
+					foldStart = true;
+				}
+				else {
+					foldStart = true;
+				}
+				if (foldStart) {
+					if (wordInArray(word, startTags, 6)) {
+						levelCurrent++;
+					}
+					else if (wordInArray(word, endTags, 6)) {
+						levelCurrent--;
+					}
+				}
 			}
 		}
 		if (atEOL) {
 			int lev = levelPrev;
-			if (visibleChars == 0 && foldCompact)
+			if (visibleChars == 0 && options.foldCompact)
 				lev |= SC_FOLDLEVELWHITEFLAG;
 			if ((levelCurrent > levelPrev) && (visibleChars > 0))
 				lev |= SC_FOLDLEVELHEADERFLAG;
@@ -193,4 +711,4 @@ static void FoldBaanDoc(Sci_PositionU startPos, Sci_Position length, int initSty
 	styler.SetLevel(lineCurrent, levelPrev | flagsNext);
 }
 
-LexerModule lmBaan(SCLEX_BAAN, ColouriseBaanDoc, "baan", FoldBaanDoc);
+LexerModule lmBaan(SCLEX_BAAN, LexerBaan::LexerFactoryBaan, "baan", baanWordLists);
diff --git a/src/stc/scintilla/lexers/LexCPP.cxx b/src/stc/scintilla/lexers/LexCPP.cxx
index 4261084..64387a0 100644
--- a/src/stc/scintilla/lexers/LexCPP.cxx
+++ b/src/stc/scintilla/lexers/LexCPP.cxx
@@ -229,7 +229,7 @@ struct PPDefinition {
 	std::string value;
 	bool isUndef;
 	std::string arguments;
-	PPDefinition(Sci_Position line_, const std::string &key_, const std::string &value_, bool isUndef_ = false, std::string arguments_="") :
+	PPDefinition(Sci_Position line_, const std::string &key_, const std::string &value_, bool isUndef_ = false, const std::string &arguments_="") :
 		line(line_), key(key_), value(value_), isUndef(isUndef_), arguments(arguments_) {
 	}
 };
@@ -320,6 +320,7 @@ struct OptionsCPP {
 	std::string foldExplicitEnd;
 	bool foldExplicitAnywhere;
 	bool foldPreprocessor;
+	bool foldPreprocessorAtElse;
 	bool foldCompact;
 	bool foldAtElse;
 	OptionsCPP() {
@@ -341,6 +342,7 @@ struct OptionsCPP {
 		foldExplicitEnd = "";
 		foldExplicitAnywhere = false;
 		foldPreprocessor = false;
+		foldPreprocessorAtElse = false;
 		foldCompact = false;
 		foldAtElse = false;
 	}
@@ -411,6 +413,9 @@ struct OptionSetCPP : public OptionSet<OptionsCPP> {
 
 		DefineProperty("fold.cpp.explicit.anywhere", &OptionsCPP::foldExplicitAnywhere,
 			"Set this property to 1 to enable explicit fold points anywhere, not just in line comments.");
+		
+		DefineProperty("fold.cpp.preprocessor.at.else", &OptionsCPP::foldPreprocessorAtElse,
+			"This option enables folding on a preprocessor #else or #endif line of an #if statement.");
 
 		DefineProperty("fold.preprocessor", &OptionsCPP::foldPreprocessor,
 			"This option enables folding preprocessor directives when using the C++ lexer. "
@@ -1349,13 +1354,17 @@ void SCI_METHOD LexerCPP::Fold(Sci_PositionU startPos, Sci_Position length, int
 				} else if (styler.Match(j, "end")) {
 					levelNext--;
 				}
+				
+				if (options.foldPreprocessorAtElse && (styler.Match(j, "else") || styler.Match(j, "elif"))) {
+					levelMinCurrent--;
+				}
 			}
 		}
 		if (options.foldSyntaxBased && (style == SCE_C_OPERATOR)) {
 			if (ch == '{' || ch == '[' || ch == '(') {
 				// Measure the minimum before a '{' to allow
 				// folding on "} else {"
-				if (levelMinCurrent > levelNext) {
+				if (options.foldAtElse && levelMinCurrent > levelNext) {
 					levelMinCurrent = levelNext;
 				}
 				levelNext++;
@@ -1367,7 +1376,9 @@ void SCI_METHOD LexerCPP::Fold(Sci_PositionU startPos, Sci_Position length, int
 			visibleChars++;
 		if (atEOL || (i == endPos-1)) {
 			int levelUse = levelCurrent;
-			if (options.foldSyntaxBased && options.foldAtElse) {
+			if ((options.foldSyntaxBased && options.foldAtElse) ||
+				(options.foldPreprocessor && options.foldPreprocessorAtElse)
+			) {
 				levelUse = levelMinCurrent;
 			}
 			int lev = levelUse | levelNext << 16;
diff --git a/src/stc/scintilla/lexers/LexCoffeeScript.cxx b/src/stc/scintilla/lexers/LexCoffeeScript.cxx
index f325600..63ee172 100644
--- a/src/stc/scintilla/lexers/LexCoffeeScript.cxx
+++ b/src/stc/scintilla/lexers/LexCoffeeScript.cxx
@@ -40,6 +40,36 @@ static bool IsSpaceEquiv(int state) {
 	    || state == SCE_COFFEESCRIPT_REGEX);
 }
 
+// Store the current lexer state and brace count prior to starting a new
+// `#{}` interpolation level.
+// Based on LexRuby.cxx.
+static void enterInnerExpression(int  *p_inner_string_types,
+                                 int  *p_inner_expn_brace_counts,
+                                 int&  inner_string_count,
+                                 int   state,
+                                 int&  brace_counts
+                                 ) {
+	p_inner_string_types[inner_string_count] = state;
+	p_inner_expn_brace_counts[inner_string_count] = brace_counts;
+	brace_counts = 0;
+	++inner_string_count;
+}
+
+// Restore the lexer state and brace count for the previous `#{}` interpolation
+// level upon returning to it.
+// Note the previous lexer state is the return value and needs to be restored
+// manually by the StyleContext.
+// Based on LexRuby.cxx.
+static int exitInnerExpression(int  *p_inner_string_types,
+                               int  *p_inner_expn_brace_counts,
+                               int&  inner_string_count,
+                               int&  brace_counts
+                              ) {
+	--inner_string_count;
+	brace_counts = p_inner_expn_brace_counts[inner_string_count];
+	return p_inner_string_types[inner_string_count];
+}
+
 // Preconditions: sc.currentPos points to a character after '+' or '-'.
 // The test for pos reaching 0 should be redundant,
 // and is in only for safety measures.
@@ -88,6 +118,27 @@ static void ColouriseCoffeeScriptDoc(Sci_PositionU startPos, Sci_Position length
 	int chPrevNonWhite = ' ';
 	int visibleChars = 0;
 
+	// String/Regex interpolation variables, based on LexRuby.cxx.
+	// In most cases a value of 2 should be ample for the code the user is
+	// likely to enter. For example,
+	//   "Filling the #{container} with #{liquid}..."
+	// from the CoffeeScript homepage nests to a level of 2
+	// If the user actually hits a 6th occurrence of '#{' in a double-quoted
+	// string (including regexes), it will stay as a string.  The problem with
+	// this is that quotes might flip, a 7th '#{' will look like a comment,
+	// and code-folding might be wrong.
+#define INNER_STRINGS_MAX_COUNT 5
+	// These vars track our instances of "...#{,,,'..#{,,,}...',,,}..."
+	int inner_string_types[INNER_STRINGS_MAX_COUNT];
+	// Track # braces when we push a new #{ thing
+	int inner_expn_brace_counts[INNER_STRINGS_MAX_COUNT];
+	int inner_string_count = 0;
+	int brace_counts = 0;   // Number of #{ ... } things within an expression
+	for (int i = 0; i < INNER_STRINGS_MAX_COUNT; i++) {
+		inner_string_types[i] = 0;
+		inner_expn_brace_counts[i] = 0;
+	}
+
 	// look back to set chPrevNonWhite properly for better regex colouring
 	Sci_Position endPos = startPos + length;
         if (startPos > 0 && IsSpaceEquiv(initStyle)) {
@@ -109,7 +160,7 @@ static void ColouriseCoffeeScriptDoc(Sci_PositionU startPos, Sci_Position length
 
 	StyleContext sc(startPos, endPos - startPos, initStyle, styler);
 
-	for (; sc.More(); sc.Forward()) {
+	for (; sc.More();) {
 
 		if (sc.atLineStart) {
 			// Reset states to beginning of colourise so no surprises
@@ -164,6 +215,15 @@ static void ColouriseCoffeeScriptDoc(Sci_PositionU startPos, Sci_Position length
 					}
 				} else if (sc.ch == '\"') {
 					sc.ForwardSetState(SCE_COFFEESCRIPT_DEFAULT);
+				} else if (sc.ch == '#' && sc.chNext == '{' && inner_string_count < INNER_STRINGS_MAX_COUNT) {
+					// process interpolated code #{ ... }
+					enterInnerExpression(inner_string_types,
+					                     inner_expn_brace_counts,
+					                     inner_string_count,
+					                     sc.state,
+					                     brace_counts);
+					sc.SetState(SCE_COFFEESCRIPT_OPERATOR);
+					sc.ForwardSetState(SCE_COFFEESCRIPT_DEFAULT);
 				}
 				break;
 			case SCE_COFFEESCRIPT_CHARACTER:
@@ -255,6 +315,15 @@ static void ColouriseCoffeeScriptDoc(Sci_PositionU startPos, Sci_Position length
 				// Handle '..' and '...' operators correctly.
 				if (sc.ch == '.') {
 					for (int i = 0; i < 2 && sc.chNext == '.'; i++, sc.Forward()) ;
+				} else if (sc.ch == '{') {
+					++brace_counts;
+				} else if (sc.ch == '}' && --brace_counts <= 0 && inner_string_count > 0) {
+					// Return to previous state before #{ ... }
+					sc.ForwardSetState(exitInnerExpression(inner_string_types,
+					                                       inner_expn_brace_counts,
+					                                       inner_string_count,
+					                                       brace_counts));
+					continue; // skip sc.Forward() at loop end
 				}
 			}
 		}
@@ -263,6 +332,7 @@ static void ColouriseCoffeeScriptDoc(Sci_PositionU startPos, Sci_Position length
 			chPrevNonWhite = sc.ch;
 			visibleChars++;
 		}
+		sc.Forward();
 	}
 	sc.Complete();
 }
diff --git a/src/stc/scintilla/lexers/LexErrorList.cxx b/src/stc/scintilla/lexers/LexErrorList.cxx
index d6fe5ee..6dc6b02 100644
--- a/src/stc/scintilla/lexers/LexErrorList.cxx
+++ b/src/stc/scintilla/lexers/LexErrorList.cxx
@@ -257,6 +257,10 @@ static int RecogniseErrorListLine(const char *lineBuffer, Sci_PositionU lengthLi
 			return SCE_ERR_MS;
 		} else if ((state == stCtagsStringDollar) || (state == stCtags)) {
 			return SCE_ERR_CTAG;
+		} else if (initialColonPart && strstr(lineBuffer, ": warning C")) {
+			// Microsoft warning without line number
+			// <filename>: warning C9999
+			return SCE_ERR_MS;
 		} else {
 			return SCE_ERR_DEFAULT;
 		}
@@ -316,12 +320,12 @@ static void ColouriseErrorListLine(
 		int portionStyle = style;
 		while (const char *startSeq = strstr(linePortion, CSI)) {
 			if (startSeq > linePortion) {
-				styler.ColourTo(startPortion + (startSeq - linePortion), portionStyle);
+				styler.ColourTo(startPortion + static_cast<int>(startSeq - linePortion), portionStyle);
 			}
 			const char *endSeq = startSeq + 2;
 			while (!SequenceEnd(*endSeq))
 				endSeq++;
-			const int endSeqPosition = startPortion + (endSeq - linePortion) + 1;
+			const int endSeqPosition = startPortion + static_cast<int>(endSeq - linePortion) + 1;
 			switch (*endSeq) {
 			case 0:
 				styler.ColourTo(endPos, SCE_ERR_ESCSEQ_UNKNOWN);
diff --git a/src/stc/scintilla/lexers/LexHTML.cxx b/src/stc/scintilla/lexers/LexHTML.cxx
index 43f51de..bd14534 100644
--- a/src/stc/scintilla/lexers/LexHTML.cxx
+++ b/src/stc/scintilla/lexers/LexHTML.cxx
@@ -610,6 +610,17 @@ static void ColouriseHyperTextDoc(Sci_PositionU startPos, Sci_Position length, i
 	}
 	styler.StartAt(startPos);
 
+	/* Nothing handles getting out of these, so we need not start in any of them.
+	 * As we're at line start and they can't span lines, we'll re-detect them anyway */
+	switch (state) {
+		case SCE_H_QUESTION:
+		case SCE_H_XMLSTART:
+		case SCE_H_XMLEND:
+		case SCE_H_ASP:
+			state = SCE_H_DEFAULT;
+			break;
+	}
+
 	Sci_Position lineCurrent = styler.GetLine(startPos);
 	int lineState;
 	if (lineCurrent > 0) {
@@ -898,7 +909,7 @@ static void ColouriseHyperTextDoc(Sci_PositionU startPos, Sci_Position length, i
 		/////////////////////////////////////
 		// handle the start of PHP pre-processor = Non-HTML
 		else if ((state != SCE_H_ASPAT) &&
-		         !isPHPStringState(state) &&
+		         !isStringState(state) &&
 		         (state != SCE_HPHP_COMMENT) &&
 		         (state != SCE_HPHP_COMMENTLINE) &&
 		         (ch == '<') &&
diff --git a/src/stc/scintilla/lexers/LexPowerShell.cxx b/src/stc/scintilla/lexers/LexPowerShell.cxx
index 00d79db..bf1ee29 100644
--- a/src/stc/scintilla/lexers/LexPowerShell.cxx
+++ b/src/stc/scintilla/lexers/LexPowerShell.cxx
@@ -149,6 +149,8 @@ static void ColourisePowerShellDoc(Sci_PositionU startPos, Sci_Position length,
 				sc.SetState(SCE_POWERSHELL_OPERATOR);
 			} else if (IsAWordChar(sc.ch)) {
 				sc.SetState(SCE_POWERSHELL_IDENTIFIER);
+			} else if (sc.ch == '`') {
+				sc.Forward(); // skip next escaped character
 			}
 		}
 	}
diff --git a/src/stc/scintilla/lexers/LexProgress.cxx b/src/stc/scintilla/lexers/LexProgress.cxx
index 6c687ef..c1c4529 100644
--- a/src/stc/scintilla/lexers/LexProgress.cxx
+++ b/src/stc/scintilla/lexers/LexProgress.cxx
@@ -3,13 +3,18 @@
  **  Lexer for Progress 4GL.
  ** Based on LexCPP.cxx of Neil Hodgson <neilh@scintilla.org>
   **/
-// Copyright 2006-2007 by Yuval Papish <Yuval@YuvCom.com>
+// Copyright 2006-2016 by Yuval Papish <Yuval@YuvCom.com>
 // The License.txt file describes the conditions under which this software may be distributed.
 
 /** TODO:
-WebSpeed support in html lexer
-Support "end triggers" expression of the triggers phrase
+
+SpeedScript support in html lexer
+Differentiate between labels and variables
+  Option 1: By symbols table
+  Option 2: As a single unidentified symbol in a sytactical line 
+
 **/
+
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
@@ -17,300 +22,538 @@ Support "end triggers" expression of the triggers phrase
 #include <assert.h>
 #include <ctype.h>
 
+#include <string>
+#include <vector>
+#include <map>
+
 #include "ILexer.h"
 #include "Scintilla.h"
 #include "SciLexer.h"
 
 #include "WordList.h"
 #include "LexAccessor.h"
-#include "Accessor.h"
 #include "StyleContext.h"
 #include "CharacterSet.h"
 #include "LexerModule.h"
+#include "OptionSet.h"
+#include "SparseState.h"
 
 #ifdef SCI_NAMESPACE
 using namespace Scintilla;
 #endif
 
-static inline bool IsAWordChar(int ch) {
-	return (ch < 0x80) && (isalnum(ch) || ch == '_');
+namespace {
+   // Use an unnamed namespace to protect the functions and classes from name conflicts
+
+   bool IsSpaceEquiv(int state) {
+      return (state == SCE_ABL_COMMENT ||
+              state == SCE_ABL_LINECOMMENT ||
+              state == SCE_ABL_DEFAULT);
+   }
+
+   void highlightTaskMarker(StyleContext &sc, LexAccessor &styler, WordList &markerList){
+      if ((isoperator(sc.chPrev) || IsASpace(sc.chPrev)) && markerList.Length()) {
+         const int lengthMarker = 50;
+         char marker[lengthMarker+1];
+         Sci_Position currPos = (Sci_Position) sc.currentPos;
+         Sci_Position i = 0;
+         while (i < lengthMarker) {
+            char ch = styler.SafeGetCharAt(currPos + i);
+            if (IsASpace(ch) || isoperator(ch)) {
+               break;
+            }
+            marker[i] = ch;
+            i++;
+         }
+         marker[i] = '\0';
+         if (markerList.InListAbbreviated (marker,'(')) {
+            sc.SetState(SCE_ABL_TASKMARKER);
+         }
+      }
+   }
+
+   bool IsStreamCommentStyle(int style) {
+      return style == SCE_ABL_COMMENT;
+             // style == SCE_ABL_LINECOMMENT;  Only block comments are used for folding 
+   }
+
+   // Options used for LexerABL
+   struct OptionsABL {
+      bool fold;
+      bool foldSyntaxBased;
+      bool foldComment;
+      bool foldCommentMultiline;
+      bool foldCompact;
+      OptionsABL() {
+         fold = false;
+         foldSyntaxBased = true;
+         foldComment = true;
+         foldCommentMultiline = true;
+         foldCompact = false;
+      }
+   };
+
+   const char *const ablWordLists[] = {
+               "Primary keywords and identifiers",
+               "Keywords that opens a block, only when used to begin a syntactic line",
+               "Keywords that opens a block anywhere in a syntactic line",
+               "Task Marker", /* "END MODIFY START TODO" */
+               0,
+   };
+
+   struct OptionSetABL : public OptionSet<OptionsABL> {
+      OptionSetABL() {
+         DefineProperty("fold", &OptionsABL::fold);
+
+         DefineProperty("fold.abl.syntax.based", &OptionsABL::foldSyntaxBased,
+            "Set this property to 0 to disable syntax based folding.");
+
+         DefineProperty("fold.comment", &OptionsABL::foldComment,
+            "This option enables folding multi-line comments and explicit fold points when using the ABL lexer. ");
+
+         DefineProperty("fold.abl.comment.multiline", &OptionsABL::foldCommentMultiline,
+            "Set this property to 0 to disable folding multi-line comments when fold.comment=1.");
+
+         DefineProperty("fold.compact", &OptionsABL::foldCompact);
+
+         DefineWordListSets(ablWordLists);
+      }
+   };
 }
 
-static inline bool IsAWordStart(int ch) {
-	return (ch < 0x80) && (isalpha(ch) || ch == '_');
+class LexerABL : public ILexer {
+   CharacterSet setWord;
+   CharacterSet setNegationOp;
+   CharacterSet setArithmethicOp;
+   CharacterSet setRelOp;
+   CharacterSet setLogicalOp;
+   CharacterSet setWordStart;
+   WordList keywords1;      // regular keywords
+   WordList keywords2;      // block opening keywords, only when isSentenceStart
+   WordList keywords3;      // block opening keywords
+   WordList keywords4;      // Task Marker
+   OptionsABL options;
+   OptionSetABL osABL;
+public:
+   LexerABL() :
+      setWord(CharacterSet::setAlphaNum, "_", 0x80, true),
+      setNegationOp(CharacterSet::setNone, "!"),
+      setArithmethicOp(CharacterSet::setNone, "+-/*%"),
+      setRelOp(CharacterSet::setNone, "=!<>"),
+      setLogicalOp(CharacterSet::setNone, "|&"){
+   }
+   virtual ~LexerABL() {
+   }
+   void SCI_METHOD Release() {
+      delete this;
+   }
+   int SCI_METHOD Version() const {
+      return lvOriginal;
+   }
+   const char * SCI_METHOD PropertyNames() {
+      return osABL.PropertyNames();
+   }
+   int SCI_METHOD PropertyType(const char *name) {
+      return osABL.PropertyType(name);
+   }
+   const char * SCI_METHOD DescribeProperty(const char *name) {
+      return osABL.DescribeProperty(name);
+   }
+   Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) ;
+   
+   const char * SCI_METHOD DescribeWordListSets() {
+      return osABL.DescribeWordListSets();
+   }
+   Sci_Position SCI_METHOD WordListSet(int n, const char *wl);
+   void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess);
+   void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess);
+
+   void * SCI_METHOD PrivateCall(int, void *) {
+      return 0;
+   }
+   int SCI_METHOD LineEndTypesSupported() {
+      return SC_LINE_END_TYPE_DEFAULT;
+   }
+   static ILexer *LexerFactoryABL() {
+      return new LexerABL();
+   }
+};
+
+Sci_Position SCI_METHOD LexerABL::PropertySet(const char *key, const char *val) {
+   if (osABL.PropertySet(&options, key, val)) {
+      return 0;
+   }
+   return -1;
 }
 
-enum SentenceStart { SetSentenceStart = 0xf, ResetSentenceStart = 0x10}; // true -> bit = 0
-
-static void Colourise4glDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *keywordlists[],
-							Accessor &styler) {
-
-	WordList &keywords1 = *keywordlists[0];   // regular keywords
-	WordList &keywords2 = *keywordlists[1];   // block opening keywords, only when SentenceStart
-	WordList &keywords3 = *keywordlists[2];   // block opening keywords
-	//WordList &keywords4 = *keywordlists[3]; // preprocessor keywords. Not implemented
-
-	Sci_Position currentLine = styler.GetLine(startPos);
-	// Initialize the block comment /* */ nesting level, if we are inside such a comment.
-	int blockCommentLevel = 0;
-	if (initStyle == SCE_4GL_COMMENT1 ||
-		initStyle == SCE_4GL_COMMENT1_) {
-		blockCommentLevel = styler.GetLineState(currentLine - 1);
-	}
-
-	// Do not leak single-line comments onto next line
-	if (initStyle == SCE_4GL_COMMENT2 ||
-		initStyle == SCE_4GL_COMMENT2_) {
-		initStyle = SCE_4GL_DEFAULT;
-	}
-
-	int visibleChars = 0;
-	int mask;
-
-	StyleContext sc(startPos, length, initStyle, styler);
-
-	for (; sc.More(); sc.Forward()) {
-
-		if (sc.atLineStart) {
-			// Reset states to begining of colourise so no surprises
-			// if different sets of lines lexed.
-			visibleChars = 0;
-		}
-
-		if (sc.atLineEnd) {
-			// Update the line state, so it can be seen by next line
-			currentLine = styler.GetLine(sc.currentPos);
-			if (sc.state == SCE_4GL_COMMENT1 ||
-				sc.state == SCE_4GL_COMMENT1_) {
-				// Inside a block comment, we set the line state
-				styler.SetLineState(currentLine, blockCommentLevel);
-			} else {
-				// Reset the line state
-				styler.SetLineState(currentLine, 0);
-			}
-		}
-
-		// Handle line continuation generically.
-		if ((sc.state & 0xf) < SCE_4GL_COMMENT1) {
-		if (sc.ch == '~') {
-			if (sc.chNext > ' ') {
-				// skip special char after ~
-				sc.Forward();
-				continue;
-			}
-			else {
-				// Skip whitespace between ~ and EOL
-				while (sc.More() && (sc.chNext == ' ' || sc.chNext == '\t') ) {
-					sc.Forward();
-				}
-				if (sc.chNext == '\n' || sc.chNext == '\r') {
-					sc.Forward();
-					if (sc.ch == '\r' && sc.chNext == '\n') {
-						sc.Forward();
-					}
-					sc.Forward();
-					continue;
-				}
-			}
-		}
-		}
-		// Determine if a new state should be terminated.
-		mask = sc.state & 0x10;
-		switch (sc.state & 0xf) {
-			case SCE_4GL_OPERATOR:
-				sc.SetState(SCE_4GL_DEFAULT | mask);
-				break;
-			case SCE_4GL_NUMBER:
-				// Hex numbers (0xnnnn) are supported so accept any
-				// alphanumeric character if it follows a leading digit.
-				if (!(IsAlphaNumeric(sc.ch))) {
-					sc.SetState(SCE_4GL_DEFAULT | mask);
-				}
-				break;
-			case SCE_4GL_IDENTIFIER:
-				if (!IsAWordChar(sc.ch) && sc.ch != '-') {
-					char s[1000];
-					sc.GetCurrentLowered(s, sizeof(s));
-					if ((((sc.state & 0x10) == 0) && keywords2.InListAbbreviated(s, '(')) || keywords3.InListAbbreviated(s, '(')) {
-						sc.ChangeState(SCE_4GL_BLOCK | ResetSentenceStart);
-					}
-					else if (keywords1.InListAbbreviated(s, '(')) {
-						if ((s[0] == 'e' && s[1] =='n' && s[2] == 'd' && !isalnum(s[3]) && s[3] != '-') ||
-							(s[0] == 'f' && s[1] =='o' && s[2] == 'r' && s[3] == 'w' && s[4] =='a' && s[5] == 'r' && s[6] == 'd'&& !isalnum(s[7]))) {
-							sc.ChangeState(SCE_4GL_END | ResetSentenceStart);
-						}
-						else if	((s[0] == 'e' && s[1] =='l' && s[2] == 's' && s[3] == 'e') ||
-								 (s[0] == 't' && s[1] =='h' && s[2] == 'e' && s[3] == 'n')) {
-							sc.ChangeState(SCE_4GL_WORD & SetSentenceStart);
-						}
-						else {
-							sc.ChangeState(SCE_4GL_WORD | ResetSentenceStart);
-						}
-					}
-					sc.SetState(SCE_4GL_DEFAULT | (sc.state & 0x10));
-				}
-				break;
-			case SCE_4GL_PREPROCESSOR:
-				if (sc.atLineStart) {
-					sc.SetState(SCE_4GL_DEFAULT & SetSentenceStart);
-				}
-				/* code removed to allow comments inside preprocessor
-					else if (sc.ch == '*' && sc.chNext == '/') {
-					sc.ForwardSetState(SCE_4GL_DEFAULT | sentenceStartState); } */
-				break;
-			case SCE_4GL_STRING:
-				if (sc.ch == '\"') {
-					sc.ForwardSetState(SCE_4GL_DEFAULT | mask);
-				}
-				break;
-			case SCE_4GL_CHARACTER:
-				if (sc.ch == '\'') {
-					sc.ForwardSetState(SCE_4GL_DEFAULT | mask);
-				}
-				break;
-			case SCE_4GL_COMMENT1:
-				if (sc.Match('/', '*')) {
-					blockCommentLevel++;
-					sc.Forward();
-				} else if (sc.Match('*', '/') && blockCommentLevel > 0) {
-					blockCommentLevel--;
-					sc.Forward();
-					if (blockCommentLevel == 0) {
-						sc.ForwardSetState(SCE_4GL_DEFAULT | mask);
-					}
-				}
-				break;
-			case SCE_4GL_COMMENT2:
-				if (sc.atLineEnd) {
-					sc.ForwardSetState(SCE_4GL_DEFAULT | mask);
-				}
-				break;
-		}
-
-		// Determine if a new state should be entered.
-		mask = sc.state & 0x10;
-		if ((sc.state & 0xf) == SCE_4GL_DEFAULT) {
-			if (IsADigit(sc.ch) || (sc.ch == '.' && IsADigit(sc.chNext))) {
-				sc.SetState(SCE_4GL_NUMBER | ResetSentenceStart);
-			} else if (IsAWordStart(sc.ch) || (sc.ch == '@')) {
-				sc.SetState(SCE_4GL_IDENTIFIER | mask);
-			} else if (sc.Match('/', '*')) {
-				blockCommentLevel = 1;
-				sc.SetState(SCE_4GL_COMMENT1 | mask);
-				sc.Forward();
-			} else if (sc.Match('/', '/') &&
-					   (sc.atLineStart || sc.chPrev == ' ' || sc.chPrev == '\t')) {
-				sc.SetState(SCE_4GL_COMMENT2 | mask);
-			} else if (sc.ch == '\"') {
-				sc.SetState(SCE_4GL_STRING | ResetSentenceStart);
-			} else if (sc.ch == '\'') {
-				sc.SetState(SCE_4GL_CHARACTER | ResetSentenceStart);
-			} else if (sc.ch == '&' && visibleChars == 0 && ((sc.state & 0x10) == 0)) {
-				sc.SetState(SCE_4GL_PREPROCESSOR | ResetSentenceStart);
-				// Skip whitespace between & and preprocessor word
-				do {
-					sc.Forward();
-				} while ((sc.ch == ' ' || sc.ch == '\t') && sc.More());
-			// Handle syntactical line termination
-			} else if ((sc.ch == '.' || sc.ch == ':' || sc.ch == '}') && (sc.chNext == ' ' || sc.chNext == '\t' || sc.chNext == '\n' || sc.chNext == '\r')) {
-				sc.SetState(sc.state & SetSentenceStart);
-			} else if (isoperator(static_cast<char>(sc.ch))) {
-		/* 	This code allows highlight of handles. Alas, it would cause the phrase "last-event:function"
-			to be recognized as a BlockBegin */
-
-				if (sc.ch == ':')
-					sc.SetState(SCE_4GL_OPERATOR & SetSentenceStart);
-				/* else */
-					sc.SetState(SCE_4GL_OPERATOR | ResetSentenceStart);
-			}
-		}
-
-		if (!IsASpace(sc.ch)) {
-			visibleChars++;
-		}
-	}
-	sc.Complete();
+Sci_Position SCI_METHOD LexerABL::WordListSet(int n, const char *wl) {
+   WordList *wordListN = 0;
+   switch (n) {
+   case 0:
+      wordListN = &keywords1;
+      break;
+   case 1:
+      wordListN = &keywords2;
+      break;
+   case 2:
+      wordListN = &keywords3;
+      break;
+   case 3:
+      wordListN = &keywords4;
+      break;
+   }
+   Sci_Position firstModification = -1;
+   if (wordListN) {
+      WordList wlNew;
+      wlNew.Set(wl);
+      if (*wordListN != wlNew) {
+         wordListN->Set(wl);
+         firstModification = 0;
+      }
+   }
+   return firstModification;
 }
 
-static bool IsStreamCommentStyle(int style) {
-	return (style & 0xf) == SCE_4GL_COMMENT1 ;
+void SCI_METHOD LexerABL::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
+   LexAccessor styler(pAccess);
+
+   setWordStart = CharacterSet(CharacterSet::setAlpha, "_", 0x80, true);
+
+   int visibleChars = 0;
+   int visibleChars1 = 0;
+   int styleBeforeTaskMarker = SCE_ABL_DEFAULT;
+   bool continuationLine = false;
+   int commentNestingLevel = 0;
+   bool isSentenceStart = true;
+   bool possibleOOLChange = false;
+
+   Sci_Position lineCurrent = styler.GetLine(startPos);
+   if (initStyle == SCE_ABL_PREPROCESSOR) {
+      // Set continuationLine if last character of previous line is '~'
+      if (lineCurrent > 0) {
+         Sci_Position endLinePrevious = styler.LineEnd(lineCurrent-1);
+         if (endLinePrevious > 0) {
+            continuationLine = styler.SafeGetCharAt(endLinePrevious-1) == '~';
+         }
+      }
+   } 
+
+    // Look back to set variables that are actually invisible secondary states. The reason to avoid formal states is to cut down on state's bits
+   if (startPos > 0) {
+      Sci_Position back = startPos;
+      bool checkCommentNestingLevel = (initStyle == SCE_ABL_COMMENT);
+      bool checkIsSentenceStart = (initStyle == SCE_ABL_DEFAULT || initStyle == SCE_ABL_IDENTIFIER);
+      char ch;
+      char st;
+      char chPrev;
+      char chPrev_1;
+      char chPrev_2;
+      char chPrev_3;
+
+      while (back >= 0 && (checkCommentNestingLevel || checkIsSentenceStart)) {
+         ch = styler.SafeGetCharAt(back);
+         styler.Flush();  // looking at styles so need to flush
+         st = styler.StyleAt(back);
+         
+         chPrev = styler.SafeGetCharAt(back-1);
+         // isSentenceStart is a non-visible state, used to identify where statements and preprocessor declerations can start 
+         if (checkIsSentenceStart && st != SCE_ABL_COMMENT && st != SCE_ABL_LINECOMMENT && st != SCE_ABL_CHARACTER  && st != SCE_ABL_STRING ) {
+            chPrev_1 = styler.SafeGetCharAt(back-2);
+            chPrev_2 = styler.SafeGetCharAt(back-3);
+            chPrev_3 = styler.SafeGetCharAt(back-4);
+            if ((chPrev == '.' || chPrev == ':' || chPrev == '}' ||
+               (chPrev_3 == 'e' && chPrev_2 == 'l' && chPrev_1 == 's' &&  chPrev == 'e') ||
+               (chPrev_3 == 't' && chPrev_2 == 'h' && chPrev_1 == 'e' &&  chPrev == 'n')) &&
+               (IsASpace(ch) || (ch == '/' && styler.SafeGetCharAt(back+1) == '*'))
+               ) {
+                  checkIsSentenceStart = false;
+                  isSentenceStart = true;
+            }
+            else if (IsASpace(chPrev) && ch == '{') {
+               checkIsSentenceStart = false;
+               isSentenceStart = false;
+            }
+         }
+
+         // commentNestingLevel is a non-visible state, used to identify the nesting level of a comment
+         if (checkCommentNestingLevel) {
+            if (chPrev == '/' && ch == '*')
+               commentNestingLevel++;
+            if (chPrev == '*' && ch == '/') {
+               commentNestingLevel--;
+            }
+         }         
+         --back;
+      }
+   }
+
+   StyleContext sc(startPos, length, initStyle, styler, static_cast<unsigned char>(0xff));
+   Sci_Position lineEndNext = styler.LineEnd(lineCurrent);
+
+   for (; sc.More();) {
+      if (sc.atLineStart) {
+         visibleChars = 0;
+         visibleChars1 = 0;
+      }
+      if (sc.atLineEnd) {
+         lineCurrent++;
+         lineEndNext = styler.LineEnd(lineCurrent);
+      }
+      // Handle line continuation generically.
+      if (sc.ch == '~') {
+         if (static_cast<Sci_Position>((sc.currentPos+1)) >= lineEndNext) {
+            lineCurrent++;
+            lineEndNext = styler.LineEnd(lineCurrent);
+            sc.Forward();
+            if (sc.ch == '\r' && sc.chNext == '\n') {
+               sc.Forward();
+            }
+            continuationLine = true;
+            sc.Forward();
+            continue;
+         }
+      }
+
+      const bool atLineEndBeforeSwitch = sc.atLineEnd;
+      // Determine if the current state should terminate.
+      switch (sc.state) {
+         case SCE_ABL_OPERATOR:
+            sc.SetState(SCE_ABL_DEFAULT);
+            break;
+         case SCE_ABL_NUMBER:
+            // We accept almost anything because of hex. and maybe number suffixes and scientific notations in the future
+            if (!(setWord.Contains(sc.ch)
+				   || ((sc.ch == '+' || sc.ch == '-') && (sc.chPrev == 'e' || sc.chPrev == 'E' ||
+				                                          sc.chPrev == 'p' || sc.chPrev == 'P')))) {
+               sc.SetState(SCE_ABL_DEFAULT);
+            }
+            break;
+         case SCE_ABL_IDENTIFIER:
+            if (sc.atLineStart || sc.atLineEnd || (!setWord.Contains(sc.ch) && sc.ch != '-')) {
+               char s[1000];
+               sc.GetCurrentLowered(s, sizeof(s));
+               bool isLastWordEnd = (s[0] == 'e' && s[1] =='n' && s[2] == 'd' && !IsAlphaNumeric(s[3]) && s[3] != '-');  // helps to identify "end trigger" phrase
+               if ((isSentenceStart && keywords2.InListAbbreviated (s,'(')) || (!isLastWordEnd && keywords3.InListAbbreviated (s,'('))) {
+                  sc.ChangeState(SCE_ABL_BLOCK);
+                  isSentenceStart = false;
+               }
+               else if (keywords1.InListAbbreviated (s,'(')) {
+                  if (isLastWordEnd ||
+                     (s[0] == 'f' && s[1] =='o' && s[2] == 'r' && s[3] == 'w' && s[4] =='a' && s[5] == 'r' && s[6] == 'd'&& !IsAlphaNumeric(s[7]))) {
+                     sc.ChangeState(SCE_ABL_END);
+                     isSentenceStart = false;
+                  }
+                  else if ((s[0] == 'e' && s[1] =='l' && s[2] == 's' && s[3] == 'e') ||
+                         (s[0] == 't' && s[1] =='h' && s[2] == 'e' && s[3] == 'n')) {
+                     sc.ChangeState(SCE_ABL_WORD);
+                     isSentenceStart = true;
+                  }
+                  else {
+                     sc.ChangeState(SCE_ABL_WORD);
+                     isSentenceStart = false;
+                  }
+               }
+               sc.SetState(SCE_ABL_DEFAULT);
+            }
+            break;
+         case SCE_ABL_PREPROCESSOR:
+            if (sc.atLineStart && !continuationLine) {
+               sc.SetState(SCE_ABL_DEFAULT);
+               // Force Scintilla to acknowledge changed stated even though this change might happen outside of the current line
+               possibleOOLChange = true;
+               isSentenceStart = true;
+            }
+            break;
+         case SCE_ABL_LINECOMMENT:
+            if (sc.atLineStart && !continuationLine) {
+               sc.SetState(SCE_ABL_DEFAULT);
+               isSentenceStart = true;
+            } else {
+               styleBeforeTaskMarker = SCE_ABL_LINECOMMENT;
+               highlightTaskMarker(sc, styler, keywords4);
+            }
+            break;
+         case SCE_ABL_TASKMARKER:
+            if (isoperator(sc.ch) || IsASpace(sc.ch)) {
+               sc.SetState(styleBeforeTaskMarker);
+               styleBeforeTaskMarker = SCE_ABL_DEFAULT;
+            }
+            // fall through
+         case SCE_ABL_COMMENT:
+            if (sc.Match('*', '/')) {
+               sc.Forward();
+               commentNestingLevel--;
+               if (commentNestingLevel == 0) {
+                  sc.ForwardSetState(SCE_ABL_DEFAULT);
+                  possibleOOLChange = true;
+               }
+            } else if (sc.Match('/', '*')) {
+               commentNestingLevel++;
+               sc.Forward();
+            }
+            if (commentNestingLevel > 0) {
+               styleBeforeTaskMarker = SCE_ABL_COMMENT;
+               possibleOOLChange = true;
+               highlightTaskMarker(sc, styler, keywords4);
+            }
+            break;
+         case SCE_ABL_STRING:
+            if (sc.ch == '~') {
+               sc.Forward(); // Skip a character after a tilde
+            } else if (sc.ch == '\"') {
+                  sc.ForwardSetState(SCE_ABL_DEFAULT);
+            }
+            break;
+         case SCE_ABL_CHARACTER:
+            if (sc.ch == '~') {
+               sc.Forward(); // Skip a character after a tilde
+            } else if (sc.ch == '\'') {
+                  sc.ForwardSetState(SCE_ABL_DEFAULT);
+            }
+            break;
+      }
+
+      if (sc.atLineEnd && !atLineEndBeforeSwitch) {
+         // State exit processing consumed characters up to end of line.
+         lineCurrent++;
+         lineEndNext = styler.LineEnd(lineCurrent);
+      }
+
+      // Determine if a new state should be entered.
+      if (sc.state == SCE_ABL_DEFAULT) {
+         if (IsADigit(sc.ch) || (sc.ch == '.' && IsADigit(sc.chNext))) {
+               sc.SetState(SCE_ABL_NUMBER);
+               isSentenceStart = false;
+         } else if (!sc.atLineEnd && (setWordStart.Contains(sc.ch)) && sc.chPrev != '&') {
+               sc.SetState(SCE_ABL_IDENTIFIER);
+         } else if (sc.Match('/', '*')) {
+            if (sc.chPrev == '.' || sc.chPrev == ':' || sc.chPrev == '}') {
+               isSentenceStart = true;
+            }
+            sc.SetState(SCE_ABL_COMMENT);
+            possibleOOLChange = true;
+            commentNestingLevel++;
+            sc.Forward();   // Eat the * so it isn't used for the end of the comment
+         } else if (sc.ch == '\"') {
+               sc.SetState(SCE_ABL_STRING);
+               isSentenceStart = false;
+         } else if (sc.ch == '\'') {
+            sc.SetState(SCE_ABL_CHARACTER);
+            isSentenceStart = false;
+         } else if (sc.ch == '&' && visibleChars1 == 0 && isSentenceStart) {
+            // Preprocessor commands are alone on their line
+            sc.SetState(SCE_ABL_PREPROCESSOR);
+            // Force Scintilla to acknowledge changed stated even though this change might happen outside of the current line
+            possibleOOLChange = true;
+            // Skip whitespace between & and preprocessor word
+            do {
+               sc.Forward();
+            } while ((sc.ch == ' ' || sc.ch == '\t') && sc.More());
+            if (sc.atLineEnd) {
+               sc.SetState(SCE_ABL_DEFAULT);
+            }
+         } else if (sc.Match('/','/') && (IsASpace(sc.chPrev) || isSentenceStart)) {
+            // Line comments are valid after a white space or EOL
+            sc.SetState(SCE_ABL_LINECOMMENT);
+            // Skip whitespace between // and preprocessor word
+            do {
+               sc.Forward();
+            } while ((sc.ch == ' ' || sc.ch == '\t') && sc.More());
+            if (sc.atLineEnd) {
+               sc.SetState(SCE_ABL_DEFAULT);
+            }
+         } else if (isoperator(sc.ch)) {
+            sc.SetState(SCE_ABL_OPERATOR);
+            /*    This code allows highlight of handles. Alas, it would cause the phrase "last-event:function"
+               to be recognized as a BlockBegin */
+               isSentenceStart = false;
+         }
+         else if ((sc.chPrev == '.' || sc.chPrev == ':' || sc.chPrev == '}') && (IsASpace(sc.ch))) {
+            isSentenceStart = true;
+         }
+      }
+      if (!IsASpace(sc.ch)) {
+         visibleChars1++;
+      }
+      if (!IsASpace(sc.ch) && !IsSpaceEquiv(sc.state)) {
+         visibleChars++;
+      }
+      continuationLine = false;
+      sc.Forward();
+   }
+	if (possibleOOLChange)
+		styler.ChangeLexerState(startPos, startPos + length);
+   sc.Complete();
 }
 
+
 // Store both the current line's fold level and the next lines in the
 // level store to make it easy to pick up with each increment
 // and to make it possible to fiddle the current level for "} else {".
-static void FoldNoBox4glDoc(Sci_PositionU startPos, Sci_Position length, int initStyle,
-                            Accessor &styler) {
-	bool foldComment = styler.GetPropertyInt("fold.comment") != 0;
-	bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
-	bool foldAtElse = styler.GetPropertyInt("fold.at.else", 0) != 0;
-	Sci_PositionU endPos = startPos + length;
-	int visibleChars = 0;
-	Sci_Position lineCurrent = styler.GetLine(startPos);
-	int levelCurrent = SC_FOLDLEVELBASE;
-	if (lineCurrent > 0)
-		levelCurrent = styler.LevelAt(lineCurrent-1) >> 16;
-	int levelMinCurrent = levelCurrent;
-	int levelNext = levelCurrent;
-	char chNext = static_cast<char>(tolower(styler[startPos]));
-	int styleNext = styler.StyleAt(startPos);
-	int style = initStyle;
-	for (Sci_PositionU i = startPos; i < endPos; i++) {
-		char ch = chNext;
-		chNext = static_cast<char>(tolower(styler.SafeGetCharAt(i + 1)));
-		int stylePrev = style;
-		style = styleNext;
-		styleNext = styler.StyleAt(i + 1);
-		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
-		if (foldComment && IsStreamCommentStyle(style)) {
-			if (!IsStreamCommentStyle(stylePrev)) {
-				levelNext++;
-			} else if (!IsStreamCommentStyle(styleNext)) { // && !atEOL) {
-				// Comments don't end at end of line and the next character may be unstyled.
-				levelNext--;
-			}
-		}
-		else if ((style & 0xf) == SCE_4GL_BLOCK && !isalnum(chNext)) {
-			levelNext++;
-		}
-		else if ((style & 0xf) == SCE_4GL_END  && (ch == 'e' || ch == 'f')) {
-			levelNext--;
-		}
-		if (atEOL) {
-			int levelUse = levelCurrent;
-			if (foldAtElse) {
-				levelUse = levelMinCurrent;
-			}
-			int lev = levelUse | levelNext << 16;
-			if (visibleChars == 0 && foldCompact)
-				lev |= SC_FOLDLEVELWHITEFLAG;
-			if (levelUse < levelNext)
-				lev |= SC_FOLDLEVELHEADERFLAG;
-			if (lev != styler.LevelAt(lineCurrent)) {
-				styler.SetLevel(lineCurrent, lev);
-			}
-			lineCurrent++;
-			levelCurrent = levelNext;
-			levelMinCurrent = levelCurrent;
-			visibleChars = 0;
-		}
-		if (!isspacechar(ch))
-			visibleChars++;
-	}
-}
 
-static void Fold4glDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *[],
-                       Accessor &styler) {
-	FoldNoBox4glDoc(startPos, length, initStyle, styler);
-}
+void SCI_METHOD LexerABL::Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
+
+   if (!options.fold)
+      return;
 
-static const char * const FglWordLists[] = {
-            "Primary keywords and identifiers",
-            "Secondary keywords and identifiers",
-            "Documentation comment keywords",
-            "Unused",
-            "Global classes and typedefs",
-            0,
-        };
+   LexAccessor styler(pAccess);
+
+   Sci_PositionU endPos = startPos + length;
+   int visibleChars = 0;
+   Sci_Position lineCurrent = styler.GetLine(startPos);
+   int levelCurrent = SC_FOLDLEVELBASE;
+   if (lineCurrent > 0)
+      levelCurrent = styler.LevelAt(lineCurrent-1) >> 16;
+   Sci_PositionU lineStartNext = styler.LineStart(lineCurrent+1);
+   int levelNext = levelCurrent;
+   char chNext = styler[startPos];
+   int styleNext = styler.StyleAt(startPos);
+   int style = initStyle;
+   for (Sci_PositionU i = startPos; i < endPos; i++) {
+      chNext = static_cast<char>(tolower(chNext));  // check tolower
+      char ch = chNext;
+      chNext = styler.SafeGetCharAt(i+1);
+      int stylePrev = style;
+      style = styleNext;
+      styleNext = styler.StyleAt(i+1);
+      bool atEOL = i == (lineStartNext-1);
+      if (options.foldComment && options.foldCommentMultiline && IsStreamCommentStyle(style)) {
+         if (!IsStreamCommentStyle(stylePrev)) {
+            levelNext++;
+         } else if (!IsStreamCommentStyle(styleNext) && !atEOL) {
+            // Comments don't end at end of line and the next character may be unstyled.
+            levelNext--;
+         }
+      }
+      if (options.foldSyntaxBased) {
+         if (style == SCE_ABL_BLOCK && !IsAlphaNumeric(chNext)) {
+            levelNext++;
+         }
+         else if (style == SCE_ABL_END  && (ch == 'e' || ch == 'f')) {
+            levelNext--;
+         }
+      }
+      if (!IsASpace(ch))
+         visibleChars++;
+      if (atEOL || (i == endPos-1)) {
+         int lev = levelCurrent | levelNext << 16;
+         if (visibleChars == 0 && options.foldCompact)
+            lev |= SC_FOLDLEVELWHITEFLAG;
+         if (levelCurrent < levelNext)
+            lev |= SC_FOLDLEVELHEADERFLAG;
+         if (lev != styler.LevelAt(lineCurrent)) {
+            styler.SetLevel(lineCurrent, lev);
+         }
+         lineCurrent++;
+         lineStartNext = styler.LineStart(lineCurrent+1);
+         levelCurrent = levelNext;
+         if (atEOL && (i == static_cast<Sci_PositionU>(styler.Length()-1))) {
+            // There is an empty line at end of file so give it same level and empty
+            styler.SetLevel(lineCurrent, (levelCurrent | levelCurrent << 16) | SC_FOLDLEVELWHITEFLAG);
+         }
+         visibleChars = 0;
+      }
+   }
+}
 
-LexerModule lmProgress(SCLEX_PROGRESS, Colourise4glDoc, "progress", Fold4glDoc, FglWordLists);
+LexerModule lmProgress(SCLEX_PROGRESS, LexerABL::LexerFactoryABL, "abl", ablWordLists);
diff --git a/src/stc/scintilla/lexers/LexYAML.cxx b/src/stc/scintilla/lexers/LexYAML.cxx
index 5cd348f..e420d9d 100644
--- a/src/stc/scintilla/lexers/LexYAML.cxx
+++ b/src/stc/scintilla/lexers/LexYAML.cxx
@@ -46,7 +46,7 @@ static unsigned int SpaceCount(char* lineBuffer) {
 	while (*headBuffer == ' ')
 		headBuffer++;
 
-	return headBuffer - lineBuffer;
+	return static_cast<unsigned int>(headBuffer - lineBuffer);
 }
 
 #define YAML_STATE_BITSIZE 16
@@ -148,16 +148,30 @@ static void ColouriseYAMLLine(
 				styler.ColourTo(endPos, SCE_YAML_KEYWORD);
 				return;
 			} else {
+				Sci_PositionU startComment = i;
+				bInQuotes = false;
+				while (startComment < lengthLine) { // Comment must be space padded
+					if (lineBuffer[startComment] == '\'' || lineBuffer[startComment] == '\"')
+						bInQuotes = !bInQuotes;
+					if (lineBuffer[startComment] == '#' && isspacechar(lineBuffer[startComment - 1]) && !bInQuotes)
+						break;
+					startComment++;
+				}
 				Sci_PositionU i2 = i;
-				while ((i < lengthLine) && lineBuffer[i]) {
-					if (!(IsASCII(lineBuffer[i]) && isdigit(lineBuffer[i])) && lineBuffer[i] != '-' && lineBuffer[i] != '.' && lineBuffer[i] != ',') {
-						styler.ColourTo(endPos, SCE_YAML_DEFAULT);
+				while ((i < startComment) && lineBuffer[i]) {
+					if (!(IsASCII(lineBuffer[i]) && isdigit(lineBuffer[i])) && lineBuffer[i] != '-' 
+						    && lineBuffer[i] != '.' && lineBuffer[i] != ',' && lineBuffer[i] != ' ') {
+						styler.ColourTo(startLine + startComment - 1, SCE_YAML_DEFAULT);
+						if (startComment < lengthLine)
+							styler.ColourTo(endPos, SCE_YAML_COMMENT);
 						return;
 					}
 					i++;
 				}
 				if (i > i2) {
-					styler.ColourTo(endPos, SCE_YAML_NUMBER);
+					styler.ColourTo(startLine + startComment - 1, SCE_YAML_NUMBER);
+					if (startComment < lengthLine)
+						styler.ColourTo(endPos, SCE_YAML_COMMENT);
 					return;
 				}
 			}
diff --git a/src/stc/scintilla/lexlib/CharacterSet.cxx b/src/stc/scintilla/lexlib/CharacterSet.cxx
index 0ab2cc0..55602af 100644
--- a/src/stc/scintilla/lexlib/CharacterSet.cxx
+++ b/src/stc/scintilla/lexlib/CharacterSet.cxx
@@ -25,8 +25,8 @@ namespace Scintilla {
 int CompareCaseInsensitive(const char *a, const char *b) {
 	while (*a && *b) {
 		if (*a != *b) {
-			char upperA = MakeUpperCase(*a);
-			char upperB = MakeUpperCase(*b);
+			char upperA = static_cast<char>(MakeUpperCase(*a));
+			char upperB = static_cast<char>(MakeUpperCase(*b));
 			if (upperA != upperB)
 				return upperA - upperB;
 		}
@@ -40,8 +40,8 @@ int CompareCaseInsensitive(const char *a, const char *b) {
 int CompareNCaseInsensitive(const char *a, const char *b, size_t len) {
 	while (*a && *b && len) {
 		if (*a != *b) {
-			char upperA = MakeUpperCase(*a);
-			char upperB = MakeUpperCase(*b);
+			char upperA = static_cast<char>(MakeUpperCase(*a));
+			char upperB = static_cast<char>(MakeUpperCase(*b));
 			if (upperA != upperB)
 				return upperA - upperB;
 		}
diff --git a/src/stc/scintilla/lexlib/CharacterSet.h b/src/stc/scintilla/lexlib/CharacterSet.h
index a0c45b2..183fbe4 100644
--- a/src/stc/scintilla/lexlib/CharacterSet.h
+++ b/src/stc/scintilla/lexlib/CharacterSet.h
@@ -160,13 +160,20 @@ inline bool isoperator(int ch) {
 
 // Simple case functions for ASCII.
 
-inline char MakeUpperCase(char ch) {
+inline int MakeUpperCase(int ch) {
 	if (ch < 'a' || ch > 'z')
 		return ch;
 	else
 		return static_cast<char>(ch - 'a' + 'A');
 }
 
+inline int MakeLowerCase(int ch) {
+	if (ch < 'A' || ch > 'Z')
+		return ch;
+	else
+		return ch - 'A' + 'a';
+}
+
 int CompareCaseInsensitive(const char *a, const char *b);
 int CompareNCaseInsensitive(const char *a, const char *b, size_t len);
 
diff --git a/src/stc/scintilla/lexlib/StyleContext.cxx b/src/stc/scintilla/lexlib/StyleContext.cxx
index 5bcacb0..f9f15be 100644
--- a/src/stc/scintilla/lexlib/StyleContext.cxx
+++ b/src/stc/scintilla/lexlib/StyleContext.cxx
@@ -16,11 +16,28 @@
 #include "LexAccessor.h"
 #include "Accessor.h"
 #include "StyleContext.h"
+#include "CharacterSet.h"
 
 #ifdef SCI_NAMESPACE
 using namespace Scintilla;
 #endif
 
+bool StyleContext::MatchIgnoreCase(const char *s) {
+	if (MakeLowerCase(ch) != static_cast<unsigned char>(*s))
+		return false;
+	s++;
+	if (MakeLowerCase(chNext) != static_cast<unsigned char>(*s))
+		return false;
+	s++;
+	for (int n = 2; *s; n++) {
+		if (static_cast<unsigned char>(*s) !=
+			MakeLowerCase(static_cast<unsigned char>(styler.SafeGetCharAt(currentPos + n, 0))))
+			return false;
+		s++;
+	}
+	return true;
+}
+
 static void getRange(Sci_PositionU start,
 		Sci_PositionU end,
 		LexAccessor &styler,
diff --git a/src/stc/scintilla/lexlib/StyleContext.h b/src/stc/scintilla/lexlib/StyleContext.h
index c8aa4ab..6cbda35 100644
--- a/src/stc/scintilla/lexlib/StyleContext.h
+++ b/src/stc/scintilla/lexlib/StyleContext.h
@@ -12,13 +12,6 @@
 namespace Scintilla {
 #endif
 
-static inline int MakeLowerCase(int ch) {
-	if (ch < 'A' || ch > 'Z')
-		return ch;
-	else
-		return ch - 'A' + 'a';
-}
-
 // All languages handled so far can treat all characters >= 0x80 as one class
 // which just continues the current token or starts an identifier if in default.
 // DBCS treated specially as the second character can be < 0x80 and hence
@@ -204,22 +197,8 @@ public:
 		}
 		return true;
 	}
-	bool MatchIgnoreCase(const char *s) {
-		if (MakeLowerCase(ch) != static_cast<unsigned char>(*s))
-			return false;
-		s++;
-		if (MakeLowerCase(chNext) != static_cast<unsigned char>(*s))
-			return false;
-		s++;
-		for (int n=2; *s; n++) {
-			if (static_cast<unsigned char>(*s) !=
-				MakeLowerCase(static_cast<unsigned char>(styler.SafeGetCharAt(currentPos+n, 0))))
-				return false;
-			s++;
-		}
-		return true;
-	}
 	// Non-inline
+	bool MatchIgnoreCase(const char *s);
 	void GetCurrent(char *s, Sci_PositionU len);
 	void GetCurrentLowered(char *s, Sci_PositionU len);
 };
diff --git a/src/stc/scintilla/lexlib/WordList.cxx b/src/stc/scintilla/lexlib/WordList.cxx
index 63d2233..b866291 100644
--- a/src/stc/scintilla/lexlib/WordList.cxx
+++ b/src/stc/scintilla/lexlib/WordList.cxx
@@ -236,6 +236,66 @@ bool WordList::InListAbbreviated(const char *s, const char marker) const {
 	return false;
 }
 
+/** similar to InListAbbreviated, but word s can be a abridged version of a keyword.
+* eg. the keyword is defined as "after.~:". This means the word must have a prefix (begins with) of
+* "after." and suffix (ends with) of ":" to be a keyword, Hence "after.field:" , "after.form.item:" are valid.
+* Similarly "~.is.valid" keyword is suffix only... hence "field.is.valid" , "form.is.valid" are valid.
+* The marker is ~ in this case.
+* No multiple markers check is done and wont work.
+*/
+bool WordList::InListAbridged(const char *s, const char marker) const {
+	if (0 == words)
+		return false;
+	unsigned char firstChar = s[0];
+	int j = starts[firstChar];
+	if (j >= 0) {
+		while (static_cast<unsigned char>(words[j][0]) == firstChar) {
+			const char *a = words[j];
+			const char *b = s;
+			while (*a && *a == *b) {
+				a++;
+				if (*a == marker) {
+					a++;
+					const size_t suffixLengthA = strlen(a);
+					const size_t suffixLengthB = strlen(b);
+					if (suffixLengthA >= suffixLengthB)
+						break;
+					b = b + suffixLengthB - suffixLengthA - 1;
+				}
+				b++;
+			}
+			if (!*a  && !*b)
+				return true;
+			j++;
+		}
+	}
+
+	j = starts[static_cast<unsigned int>(marker)];
+	if (j >= 0) {
+		while (words[j][0] == marker) {
+			const char *a = words[j] + 1;
+			const char *b = s;
+			const size_t suffixLengthA = strlen(a);
+			const size_t suffixLengthB = strlen(b);
+			if (suffixLengthA > suffixLengthB) {
+				j++;
+				continue;
+			}
+			b = b + suffixLengthB - suffixLengthA;
+
+			while (*a && *a == *b) {
+				a++;
+				b++;
+			}
+			if (!*a && !*b)
+				return true;
+			j++;
+		}
+	}
+
+	return false;
+}
+
 const char *WordList::WordAt(int n) const {
 	return words[n];
 }
diff --git a/src/stc/scintilla/lexlib/WordList.h b/src/stc/scintilla/lexlib/WordList.h
index 382be28..b1f8c85 100644
--- a/src/stc/scintilla/lexlib/WordList.h
+++ b/src/stc/scintilla/lexlib/WordList.h
@@ -31,6 +31,7 @@ public:
 	void Set(const char *s);
 	bool InList(const char *s) const;
 	bool InListAbbreviated(const char *s, const char marker) const;
+	bool InListAbridged(const char *s, const char marker) const;
 	const char *WordAt(int n) const;
 };
 
diff --git a/src/stc/scintilla/src/CharClassify.cxx b/src/stc/scintilla/src/CharClassify.cxx
index 595b0da..8678e6d 100644
--- a/src/stc/scintilla/src/CharClassify.cxx
+++ b/src/stc/scintilla/src/CharClassify.cxx
@@ -44,7 +44,7 @@ void CharClassify::SetCharClasses(const unsigned char *chars, cc newCharClass) {
 	}
 }
 
-int CharClassify::GetCharsOfClass(cc characterClass, unsigned char *buffer) {
+int CharClassify::GetCharsOfClass(cc characterClass, unsigned char *buffer) const {
 	// Get characters belonging to the given char class; return the number
 	// of characters (if the buffer is NULL, don't write to it).
 	int count = 0;
diff --git a/src/stc/scintilla/src/CharClassify.h b/src/stc/scintilla/src/CharClassify.h
index 5d2734c..63e8e8b 100644
--- a/src/stc/scintilla/src/CharClassify.h
+++ b/src/stc/scintilla/src/CharClassify.h
@@ -19,7 +19,7 @@ public:
 	enum cc { ccSpace, ccNewLine, ccWord, ccPunctuation };
 	void SetDefaultCharClasses(bool includeWordClass);
 	void SetCharClasses(const unsigned char *chars, cc newCharClass);
-	int GetCharsOfClass(cc charClass, unsigned char *buffer);
+	int GetCharsOfClass(cc charClass, unsigned char *buffer) const;
 	cc GetClass(unsigned char ch) const { return static_cast<cc>(charClass[ch]);}
 	bool IsWord(unsigned char ch) const { return static_cast<cc>(charClass[ch]) == ccWord;}
 
diff --git a/src/stc/scintilla/src/Document.cxx b/src/stc/scintilla/src/Document.cxx
index d96a889..58f6633 100644
--- a/src/stc/scintilla/src/Document.cxx
+++ b/src/stc/scintilla/src/Document.cxx
@@ -26,6 +26,7 @@
 #include "Scintilla.h"
 
 #include "CharacterSet.h"
+#include "CharacterCategory.h"
 #include "Position.h"
 #include "SplitVector.h"
 #include "Partitioning.h"
@@ -44,10 +45,6 @@
 using namespace Scintilla;
 #endif
 
-static inline bool IsPunctuation(char ch) {
-	return IsASCII(ch) && ispunct(ch);
-}
-
 void LexInterface::Colourise(int start, int end) {
 	if (pdoc && instance && !performingStyle) {
 		// Protect against reentrance, which may occur, for example, when
@@ -771,6 +768,77 @@ bool Document::NextCharacter(int &pos, int moveDir) const {
 	}
 }
 
+Document::CharacterExtracted Document::CharacterAfter(int position) const {
+	if (position >= Length()) {
+		return CharacterExtracted(unicodeReplacementChar, 0);
+	}
+	const unsigned char leadByte = static_cast<unsigned char>(cb.CharAt(position));
+	if (!dbcsCodePage || UTF8IsAscii(leadByte)) {
+		// Common case: ASCII character
+		return CharacterExtracted(leadByte, 1);
+	}
+	if (SC_CP_UTF8 == dbcsCodePage) {
+		const int widthCharBytes = UTF8BytesOfLead[leadByte];
+		unsigned char charBytes[UTF8MaxBytes] = { leadByte, 0, 0, 0 };
+		for (int b = 1; b<widthCharBytes; b++)
+			charBytes[b] = static_cast<unsigned char>(cb.CharAt(position + b));
+		int utf8status = UTF8Classify(charBytes, widthCharBytes);
+		if (utf8status & UTF8MaskInvalid) {
+			// Treat as invalid and use up just one byte
+			return CharacterExtracted(unicodeReplacementChar, 1);
+		} else {
+			return CharacterExtracted(UnicodeFromUTF8(charBytes), utf8status & UTF8MaskWidth);
+		}
+	} else {
+		if (IsDBCSLeadByte(leadByte) && ((position + 1) < Length())) {
+			return CharacterExtracted::DBCS(leadByte, static_cast<unsigned char>(cb.CharAt(position + 1)));
+		} else {
+			return CharacterExtracted(leadByte, 1);
+		}
+	}
+}
+
+Document::CharacterExtracted Document::CharacterBefore(int position) const {
+	if (position <= 0) {
+		return CharacterExtracted(unicodeReplacementChar, 0);
+	}
+	const unsigned char previousByte = static_cast<unsigned char>(cb.CharAt(position - 1));
+	if (0 == dbcsCodePage) {
+		return CharacterExtracted(previousByte, 1);
+	}
+	if (SC_CP_UTF8 == dbcsCodePage) {
+		if (UTF8IsAscii(previousByte)) {
+			return CharacterExtracted(previousByte, 1);
+		}
+		position--;
+		// If previousByte is not a trail byte then its invalid
+		if (UTF8IsTrailByte(previousByte)) {
+			// If previousByte is a trail byte in a valid UTF-8 character then find start of character
+			int startUTF = position;
+			int endUTF = position;
+			if (InGoodUTF8(position, startUTF, endUTF)) {
+				const int widthCharBytes = endUTF - startUTF;
+				unsigned char charBytes[UTF8MaxBytes] = { 0, 0, 0, 0 };
+				for (int b = 0; b<widthCharBytes; b++)
+					charBytes[b] = static_cast<unsigned char>(cb.CharAt(startUTF + b));
+				int utf8status = UTF8Classify(charBytes, widthCharBytes);
+				if (utf8status & UTF8MaskInvalid) {
+					// Treat as invalid and use up just one byte
+					return CharacterExtracted(unicodeReplacementChar, 1);
+				} else {
+					return CharacterExtracted(UnicodeFromUTF8(charBytes), utf8status & UTF8MaskWidth);
+				}
+			}
+			// Else invalid UTF-8 so return position of isolated trail byte
+		}
+		return CharacterExtracted(unicodeReplacementChar, 1);
+	} else {
+		// Moving backwards in DBCS is complex so use NextPosition
+		const int posStartCharacter = NextPosition(position, -1);
+		return CharacterAfter(posStartCharacter);
+	}
+}
+
 // Return -1  on out-of-bounds
 Sci_Position SCI_METHOD Document::GetRelativePosition(Sci_Position positionStart, Sci_Position characterOffset) const {
 	int pos = positionStart;
@@ -1485,28 +1553,104 @@ int Document::ParaDown(int pos) const {
 		return LineEnd(line-1);
 }
 
-CharClassify::cc Document::WordCharClass(unsigned char ch) const {
-	if ((SC_CP_UTF8 == dbcsCodePage) && (!UTF8IsAscii(ch)))
-		return CharClassify::ccWord;
-	return charClass.GetClass(ch);
+bool Document::IsASCIIWordByte(unsigned char ch) const {
+	if (IsASCII(ch)) {
+		return charClass.GetClass(ch) == CharClassify::ccWord;
+	} else {
+		return false;
+	}
+}
+
+CharClassify::cc Document::WordCharacterClass(unsigned int ch) const {
+	if (dbcsCodePage && (!UTF8IsAscii(ch))) {
+		if (SC_CP_UTF8 == dbcsCodePage) {
+			// Use hard coded Unicode class
+			const CharacterCategory cc = CategoriseCharacter(ch);
+			switch (cc) {
+
+				// Separator, Line/Paragraph
+			case ccZl:
+			case ccZp:
+				return CharClassify::ccNewLine;
+
+				// Separator, Space
+			case ccZs:
+				// Other
+			case ccCc:
+			case ccCf:
+			case ccCs:
+			case ccCo:
+			case ccCn:
+				return CharClassify::ccSpace;
+
+				// Letter
+			case ccLu:
+			case ccLl:
+			case ccLt:
+			case ccLm:
+			case ccLo:
+				// Number
+			case ccNd:
+			case ccNl:
+			case ccNo:
+				// Mark - includes combining diacritics
+			case ccMn:
+			case ccMc:
+			case ccMe:
+				return CharClassify::ccWord;
+
+				// Punctuation
+			case ccPc:
+			case ccPd:
+			case ccPs:
+			case ccPe:
+			case ccPi:
+			case ccPf:
+			case ccPo:
+				// Symbol
+			case ccSm:
+			case ccSc:
+			case ccSk:
+			case ccSo:
+				return CharClassify::ccPunctuation;
+
+			}
+		} else {
+			// Asian DBCS
+			return CharClassify::ccWord;
+		}
+	}
+	return charClass.GetClass(static_cast<unsigned char>(ch));
 }
 
 /**
  * Used by commmands that want to select whole words.
  * Finds the start of word at pos when delta < 0 or the end of the word when delta >= 0.
  */
-int Document::ExtendWordSelect(int pos, int delta, bool onlyWordCharacters) {
+int Document::ExtendWordSelect(int pos, int delta, bool onlyWordCharacters) const {
 	CharClassify::cc ccStart = CharClassify::ccWord;
 	if (delta < 0) {
-		if (!onlyWordCharacters)
-			ccStart = WordCharClass(cb.CharAt(pos-1));
-		while (pos > 0 && (WordCharClass(cb.CharAt(pos - 1)) == ccStart))
-			pos--;
+		if (!onlyWordCharacters) {
+			const CharacterExtracted ce = CharacterBefore(pos);
+			ccStart = WordCharacterClass(ce.character);
+		}
+		while (pos > 0) {
+			const CharacterExtracted ce = CharacterBefore(pos);
+			if (WordCharacterClass(ce.character) != ccStart)
+				break;
+			pos -= ce.widthBytes;
+		}
 	} else {
-		if (!onlyWordCharacters && pos < Length())
-			ccStart = WordCharClass(cb.CharAt(pos));
-		while (pos < (Length()) && (WordCharClass(cb.CharAt(pos)) == ccStart))
-			pos++;
+		if (!onlyWordCharacters && pos < Length()) {
+			const CharacterExtracted ce = CharacterAfter(pos);
+			ccStart = WordCharacterClass(ce.character);
+		}
+		while (pos < Length()) {
+			const CharacterExtracted ce = CharacterAfter(pos);
+			if (WordCharacterClass(ce.character) != ccStart)
+				break;
+			pos += ce.widthBytes;
+		}
 	}
 	return MovePositionOutsideChar(pos, delta, true);
 }
@@ -1518,22 +1662,39 @@ int Document::ExtendWordSelect(int pos, int delta, bool onlyWordCharacters) {
  * additional movement to transit white space.
  * Used by cursor movement by word commands.
  */
-int Document::NextWordStart(int pos, int delta) {
+int Document::NextWordStart(int pos, int delta) const {
 	if (delta < 0) {
-		while (pos > 0 && (WordCharClass(cb.CharAt(pos - 1)) == CharClassify::ccSpace))
-			pos--;
+		while (pos > 0) {
+			const CharacterExtracted ce = CharacterBefore(pos);
+			if (WordCharacterClass(ce.character) != CharClassify::ccSpace)
+				break;
+			pos -= ce.widthBytes;
+		}
 		if (pos > 0) {
-			CharClassify::cc ccStart = WordCharClass(cb.CharAt(pos-1));
-			while (pos > 0 && (WordCharClass(cb.CharAt(pos - 1)) == ccStart)) {
-				pos--;
+			CharacterExtracted ce = CharacterBefore(pos);
+			const CharClassify::cc ccStart = WordCharacterClass(ce.character);
+			while (pos > 0) {
+				ce = CharacterBefore(pos);
+				if (WordCharacterClass(ce.character) != ccStart)
+					break;
+				pos -= ce.widthBytes;
 			}
 		}
 	} else {
-		CharClassify::cc ccStart = WordCharClass(cb.CharAt(pos));
-		while (pos < (Length()) && (WordCharClass(cb.CharAt(pos)) == ccStart))
-			pos++;
-		while (pos < (Length()) && (WordCharClass(cb.CharAt(pos)) == CharClassify::ccSpace))
-			pos++;
+		CharacterExtracted ce = CharacterAfter(pos);
+		const CharClassify::cc ccStart = WordCharacterClass(ce.character);
+		while (pos < Length()) {
+			ce = CharacterAfter(pos);
+			if (WordCharacterClass(ce.character) != ccStart)
+				break;
+			pos += ce.widthBytes;
+		}
+		while (pos < Length()) {
+			ce = CharacterAfter(pos);
+			if (WordCharacterClass(ce.character) != CharClassify::ccSpace)
+				break;
+			pos += ce.widthBytes;
+		}
 	}
 	return pos;
 }
@@ -1545,27 +1706,41 @@ int Document::NextWordStart(int pos, int delta) {
  * additional movement to transit white space.
  * Used by cursor movement by word commands.
  */
-int Document::NextWordEnd(int pos, int delta) {
+int Document::NextWordEnd(int pos, int delta) const {
 	if (delta < 0) {
 		if (pos > 0) {
-			CharClassify::cc ccStart = WordCharClass(cb.CharAt(pos-1));
+			CharacterExtracted ce = CharacterBefore(pos);
+			CharClassify::cc ccStart = WordCharacterClass(ce.character);
 			if (ccStart != CharClassify::ccSpace) {
-				while (pos > 0 && WordCharClass(cb.CharAt(pos - 1)) == ccStart) {
-					pos--;
+				while (pos > 0) {
+					ce = CharacterBefore(pos);
+					if (WordCharacterClass(ce.character) != ccStart)
+						break;
+					pos -= ce.widthBytes;
 				}
 			}
-			while (pos > 0 && WordCharClass(cb.CharAt(pos - 1)) == CharClassify::ccSpace) {
-				pos--;
+			while (pos > 0) {
+				ce = CharacterBefore(pos);
+				if (WordCharacterClass(ce.character) != CharClassify::ccSpace)
+					break;
+				pos -= ce.widthBytes;
 			}
 		}
 	} else {
-		while (pos < Length() && WordCharClass(cb.CharAt(pos)) == CharClassify::ccSpace) {
-			pos++;
+		while (pos < Length()) {
+			CharacterExtracted ce = CharacterAfter(pos);
+			if (WordCharacterClass(ce.character) != CharClassify::ccSpace)
+				break;
+			pos += ce.widthBytes;
 		}
 		if (pos < Length()) {
-			CharClassify::cc ccStart = WordCharClass(cb.CharAt(pos));
-			while (pos < Length() && WordCharClass(cb.CharAt(pos)) == ccStart) {
-				pos++;
+			CharacterExtracted ce = CharacterAfter(pos);
+			CharClassify::cc ccStart = WordCharacterClass(ce.character);
+			while (pos < Length()) {
+				ce = CharacterAfter(pos);
+				if (WordCharacterClass(ce.character) != ccStart)
+					break;
+				pos += ce.widthBytes;
 			}
 		}
 	}
@@ -1577,10 +1752,15 @@ int Document::NextWordEnd(int pos, int delta) {
  * the previous character is of a different character class.
  */
 bool Document::IsWordStartAt(int pos) const {
+	if (pos >= Length())
+		return false;
 	if (pos > 0) {
-		CharClassify::cc ccPos = WordCharClass(CharAt(pos));
+		const CharacterExtracted cePos = CharacterAfter(pos);
+		const CharClassify::cc ccPos = WordCharacterClass(cePos.character);
+		const CharacterExtracted cePrev = CharacterBefore(pos);
+		const CharClassify::cc ccPrev = WordCharacterClass(cePrev.character);
 		return (ccPos == CharClassify::ccWord || ccPos == CharClassify::ccPunctuation) &&
-			(ccPos != WordCharClass(CharAt(pos - 1)));
+			(ccPos != ccPrev);
 	}
 	return true;
 }
@@ -1590,10 +1770,15 @@ bool Document::IsWordStartAt(int pos) const {
  * the next character is of a different character class.
  */
 bool Document::IsWordEndAt(int pos) const {
+	if (pos <= 0)
+		return false;
 	if (pos < Length()) {
-		CharClassify::cc ccPrev = WordCharClass(CharAt(pos-1));
+		const CharacterExtracted cePos = CharacterAfter(pos);
+		const CharClassify::cc ccPos = WordCharacterClass(cePos.character);
+		const CharacterExtracted cePrev = CharacterBefore(pos);
+		const CharClassify::cc ccPrev = WordCharacterClass(cePrev.character);
 		return (ccPrev == CharClassify::ccWord || ccPrev == CharClassify::ccPunctuation) &&
-			(ccPrev != WordCharClass(CharAt(pos)));
+			(ccPrev != ccPos);
 	}
 	return true;
 }
@@ -1823,7 +2008,7 @@ void Document::SetCharClasses(const unsigned char *chars, CharClassify::cc newCh
     charClass.SetCharClasses(chars, newCharClass);
 }
 
-int Document::GetCharsOfClass(CharClassify::cc characterClass, unsigned char *buffer) {
+int Document::GetCharsOfClass(CharClassify::cc characterClass, unsigned char *buffer) const {
     return charClass.GetCharsOfClass(characterClass, buffer);
 }
 
@@ -2075,96 +2260,137 @@ void Document::NotifyModified(DocModification mh) {
 	}
 }
 
-bool Document::IsWordPartSeparator(char ch) const {
-	return (WordCharClass(ch) == CharClassify::ccWord) && IsPunctuation(ch);
+// Used for word part navigation.
+static bool IsASCIIPunctuationCharacter(unsigned int ch) {
+	switch (ch) {
+	case '!':
+	case '"':
+	case '#':
+	case '$':
+	case '%':
+	case '&':
+	case '\'':
+	case '(':
+	case ')':
+	case '*':
+	case '+':
+	case ',':
+	case '-':
+	case '.':
+	case '/':
+	case ':':
+	case ';':
+	case '<':
+	case '=':
+	case '>':
+	case '?':
+	case '@':
+	case '[':
+	case '\\':
+	case ']':
+	case '^':
+	case '_':
+	case '`':
+	case '{':
+	case '|':
+	case '}':
+	case '~':
+		return true;
+	default:
+		return false;
+	}
+}
+
+bool Document::IsWordPartSeparator(unsigned int ch) const {
+	return (WordCharacterClass(ch) == CharClassify::ccWord) && IsASCIIPunctuationCharacter(ch);
 }
 
-int Document::WordPartLeft(int pos) {
+int Document::WordPartLeft(int pos) const {
 	if (pos > 0) {
-		--pos;
-		char startChar = cb.CharAt(pos);
-		if (IsWordPartSeparator(startChar)) {
-			while (pos > 0 && IsWordPartSeparator(cb.CharAt(pos))) {
-				--pos;
+		pos -= CharacterBefore(pos).widthBytes;
+		CharacterExtracted ceStart = CharacterAfter(pos);
+		if (IsWordPartSeparator(ceStart.character)) {
+			while (pos > 0 && IsWordPartSeparator(CharacterAfter(pos).character)) {
+				pos -= CharacterBefore(pos).widthBytes;
 			}
 		}
 		if (pos > 0) {
-			startChar = cb.CharAt(pos);
-			--pos;
-			if (IsLowerCase(startChar)) {
-				while (pos > 0 && IsLowerCase(cb.CharAt(pos)))
-					--pos;
-				if (!IsUpperCase(cb.CharAt(pos)) && !IsLowerCase(cb.CharAt(pos)))
-					++pos;
-			} else if (IsUpperCase(startChar)) {
-				while (pos > 0 && IsUpperCase(cb.CharAt(pos)))
-					--pos;
-				if (!IsUpperCase(cb.CharAt(pos)))
-					++pos;
-			} else if (IsADigit(startChar)) {
-				while (pos > 0 && IsADigit(cb.CharAt(pos)))
-					--pos;
-				if (!IsADigit(cb.CharAt(pos)))
-					++pos;
-			} else if (IsPunctuation(startChar)) {
-				while (pos > 0 && IsPunctuation(cb.CharAt(pos)))
-					--pos;
-				if (!IsPunctuation(cb.CharAt(pos)))
-					++pos;
-			} else if (isspacechar(startChar)) {
-				while (pos > 0 && isspacechar(cb.CharAt(pos)))
-					--pos;
-				if (!isspacechar(cb.CharAt(pos)))
-					++pos;
-			} else if (!IsASCII(startChar)) {
-				while (pos > 0 && !IsASCII(cb.CharAt(pos)))
-					--pos;
-				if (IsASCII(cb.CharAt(pos)))
-					++pos;
+			ceStart = CharacterAfter(pos);
+			pos -= CharacterBefore(pos).widthBytes;
+			if (IsLowerCase(ceStart.character)) {
+				while (pos > 0 && IsLowerCase(CharacterAfter(pos).character))
+					pos -= CharacterBefore(pos).widthBytes;
+				if (!IsUpperCase(CharacterAfter(pos).character) && !IsLowerCase(CharacterAfter(pos).character))
+					pos += CharacterAfter(pos).widthBytes;
+			} else if (IsUpperCase(ceStart.character)) {
+				while (pos > 0 && IsUpperCase(CharacterAfter(pos).character))
+					pos -= CharacterBefore(pos).widthBytes;
+				if (!IsUpperCase(CharacterAfter(pos).character))
+					pos += CharacterAfter(pos).widthBytes;
+			} else if (IsADigit(ceStart.character)) {
+				while (pos > 0 && IsADigit(CharacterAfter(pos).character))
+					pos -= CharacterBefore(pos).widthBytes;
+				if (!IsADigit(CharacterAfter(pos).character))
+					pos += CharacterAfter(pos).widthBytes;
+			} else if (IsASCIIPunctuationCharacter(ceStart.character)) {
+				while (pos > 0 && IsASCIIPunctuationCharacter(CharacterAfter(pos).character))
+					pos -= CharacterBefore(pos).widthBytes;
+				if (!IsASCIIPunctuationCharacter(CharacterAfter(pos).character))
+					pos += CharacterAfter(pos).widthBytes;
+			} else if (isspacechar(ceStart.character)) {
+				while (pos > 0 && isspacechar(CharacterAfter(pos).character))
+					pos -= CharacterBefore(pos).widthBytes;
+				if (!isspacechar(CharacterAfter(pos).character))
+					pos += CharacterAfter(pos).widthBytes;
+			} else if (!IsASCII(ceStart.character)) {
+				while (pos > 0 && !IsASCII(CharacterAfter(pos).character))
+					pos -= CharacterBefore(pos).widthBytes;
+				if (IsASCII(CharacterAfter(pos).character))
+					pos += CharacterAfter(pos).widthBytes;
 			} else {
-				++pos;
+				pos += CharacterAfter(pos).widthBytes;
 			}
 		}
 	}
 	return pos;
 }
 
-int Document::WordPartRight(int pos) {
-	char startChar = cb.CharAt(pos);
-	int length = Length();
-	if (IsWordPartSeparator(startChar)) {
-		while (pos < length && IsWordPartSeparator(cb.CharAt(pos)))
-			++pos;
-		startChar = cb.CharAt(pos);
-	}
-	if (!IsASCII(startChar)) {
-		while (pos < length && !IsASCII(cb.CharAt(pos)))
-			++pos;
-	} else if (IsLowerCase(startChar)) {
-		while (pos < length && IsLowerCase(cb.CharAt(pos)))
-			++pos;
-	} else if (IsUpperCase(startChar)) {
-		if (IsLowerCase(cb.CharAt(pos + 1))) {
-			++pos;
-			while (pos < length && IsLowerCase(cb.CharAt(pos)))
-				++pos;
+int Document::WordPartRight(int pos) const {
+	CharacterExtracted ceStart = CharacterAfter(pos);
+	const int length = Length();
+	if (IsWordPartSeparator(ceStart.character)) {
+		while (pos < length && IsWordPartSeparator(CharacterAfter(pos).character))
+			pos += CharacterAfter(pos).widthBytes;
+		ceStart = CharacterAfter(pos);
+	}
+	if (!IsASCII(ceStart.character)) {
+		while (pos < length && !IsASCII(CharacterAfter(pos).character))
+			pos += CharacterAfter(pos).widthBytes;
+	} else if (IsLowerCase(ceStart.character)) {
+		while (pos < length && IsLowerCase(CharacterAfter(pos).character))
+			pos += CharacterAfter(pos).widthBytes;
+	} else if (IsUpperCase(ceStart.character)) {
+		if (IsLowerCase(CharacterAfter(pos + ceStart.widthBytes).character)) {
+			pos += CharacterAfter(pos).widthBytes;
+			while (pos < length && IsLowerCase(CharacterAfter(pos).character))
+				pos += CharacterAfter(pos).widthBytes;
 		} else {
-			while (pos < length && IsUpperCase(cb.CharAt(pos)))
-				++pos;
-		}
-		if (IsLowerCase(cb.CharAt(pos)) && IsUpperCase(cb.CharAt(pos - 1)))
-			--pos;
-	} else if (IsADigit(startChar)) {
-		while (pos < length && IsADigit(cb.CharAt(pos)))
-			++pos;
-	} else if (IsPunctuation(startChar)) {
-		while (pos < length && IsPunctuation(cb.CharAt(pos)))
-			++pos;
-	} else if (isspacechar(startChar)) {
-		while (pos < length && isspacechar(cb.CharAt(pos)))
-			++pos;
+			while (pos < length && IsUpperCase(CharacterAfter(pos).character))
+				pos += CharacterAfter(pos).widthBytes;
+		}
+		if (IsLowerCase(CharacterAfter(pos).character) && IsUpperCase(CharacterBefore(pos).character))
+			pos -= CharacterBefore(pos).widthBytes;
+	} else if (IsADigit(ceStart.character)) {
+		while (pos < length && IsADigit(CharacterAfter(pos).character))
+			pos += CharacterAfter(pos).widthBytes;
+	} else if (IsASCIIPunctuationCharacter(ceStart.character)) {
+		while (pos < length && IsASCIIPunctuationCharacter(CharacterAfter(pos).character))
+			pos += CharacterAfter(pos).widthBytes;
+	} else if (isspacechar(ceStart.character)) {
+		while (pos < length && isspacechar(CharacterAfter(pos).character))
+			pos += CharacterAfter(pos).widthBytes;
 	} else {
-		++pos;
+		pos += CharacterAfter(pos).widthBytes;
 	}
 	return pos;
 }
diff --git a/src/stc/scintilla/src/Document.h b/src/stc/scintilla/src/Document.h
index 2d6005b..c0a0bb8 100644
--- a/src/stc/scintilla/src/Document.h
+++ b/src/stc/scintilla/src/Document.h
@@ -211,9 +211,6 @@ public:
 		bool operator==(const WatcherWithUserData &other) const {
 			return (watcher == other.watcher) && (userData == other.userData);
 		}
-		bool operator!=(const WatcherWithUserData &other) const {
-			return !((watcher == other.watcher) && (userData == other.userData));
-		}
 	};
 
 private:
@@ -241,6 +238,18 @@ private:
 
 public:
 
+	struct CharacterExtracted {
+		unsigned int character;
+		unsigned int widthBytes;
+		CharacterExtracted(unsigned int character_, unsigned int widthBytes_) :
+			character(character_), widthBytes(widthBytes_) {
+		}
+		// For DBCS characters turn 2 bytes into an int
+		static CharacterExtracted DBCS(unsigned char lead, unsigned char trail) {
+			return CharacterExtracted((lead << 8) | trail, 2);
+		}
+	};
+
 	LexInterface *pli;
 
 	int eolMode;
@@ -287,6 +296,8 @@ public:
 	int MovePositionOutsideChar(int pos, int moveDir, bool checkLineEnd=true) const;
 	int NextPosition(int pos, int moveDir) const;
 	bool NextCharacter(int &pos, int moveDir) const;	// Returns true if pos changed
+	Document::CharacterExtracted CharacterAfter(int position) const;
+	Document::CharacterExtracted CharacterBefore(int position) const;
 	Sci_Position SCI_METHOD GetRelativePosition(Sci_Position positionStart, Sci_Position characterOffset) const;
 	int GetRelativePositionUTF16(int positionStart, int characterOffset) const;
 	int SCI_METHOD GetCharacterAndWidth(Sci_Position position, Sci_Position *pWidth) const;
@@ -376,19 +387,12 @@ public:
 	void GetHighlightDelimiters(HighlightDelimiter &hDelimiter, int line, int lastLine);
 
 	void Indent(bool forwards);
-	int ExtendWordSelect(int pos, int delta, bool onlyWordCharacters=false);
-	int NextWordStart(int pos, int delta);
-	int NextWordEnd(int pos, int delta);
+	int ExtendWordSelect(int pos, int delta, bool onlyWordCharacters=false) const;
+	int NextWordStart(int pos, int delta) const;
+	int NextWordEnd(int pos, int delta) const;
 	Sci_Position SCI_METHOD Length() const { return cb.Length(); }
 	void Allocate(int newSize) { cb.Allocate(newSize); }
 
-	struct CharacterExtracted {
-		unsigned int character;
-		unsigned int widthBytes;
-		CharacterExtracted(unsigned int character_, unsigned int widthBytes_) :
-			character(character_), widthBytes(widthBytes_) {
-		}
-	};
 	CharacterExtracted ExtractCharacter(int position) const;
 
 	bool IsWordStartAt(int pos) const;
@@ -404,7 +408,7 @@ public:
 
 	void SetDefaultCharClasses(bool includeWordClass);
 	void SetCharClasses(const unsigned char *chars, CharClassify::cc newCharClass);
-	int GetCharsOfClass(CharClassify::cc characterClass, unsigned char *buffer);
+	int GetCharsOfClass(CharClassify::cc characterClass, unsigned char *buffer) const;
 	void SCI_METHOD StartStyling(Sci_Position position, char mask);
 	bool SCI_METHOD SetStyleFor(Sci_Position length, char style);
 	bool SCI_METHOD SetStyles(Sci_Position length, const char *styles);
@@ -440,10 +444,11 @@ public:
 	bool AddWatcher(DocWatcher *watcher, void *userData);
 	bool RemoveWatcher(DocWatcher *watcher, void *userData);
 
-	CharClassify::cc WordCharClass(unsigned char ch) const;
-	bool IsWordPartSeparator(char ch) const;
-	int WordPartLeft(int pos);
-	int WordPartRight(int pos);
+	bool IsASCIIWordByte(unsigned char ch) const;
+	CharClassify::cc WordCharacterClass(unsigned int ch) const;
+	bool IsWordPartSeparator(unsigned int ch) const;
+	int WordPartLeft(int pos) const;
+	int WordPartRight(int pos) const;
 	int ExtendStyleRange(int pos, int delta, bool singleLine = false);
 	bool IsWhiteLine(int line) const;
 	int ParaUp(int pos) const;
diff --git a/src/stc/scintilla/src/EditView.cxx b/src/stc/scintilla/src/EditView.cxx
index 9ca6e95..e6cd8fc 100644
--- a/src/stc/scintilla/src/EditView.cxx
+++ b/src/stc/scintilla/src/EditView.cxx
@@ -25,6 +25,7 @@
 #include "Scintilla.h"
 
 #include "StringCopy.h"
+#include "CharacterSet.h"
 #include "Position.h"
 #include "SplitVector.h"
 #include "Partitioning.h"
@@ -389,16 +390,16 @@ void EditView::LayoutLine(const EditModel &model, int line, Surface *surface, co
 					(ll->chars[numCharsInLine] == chDoc);
 				else if (vstyle.styles[ll->styles[numCharsInLine]].caseForce == Style::caseLower)
 					allSame = allSame &&
-					(ll->chars[numCharsInLine] == static_cast<char>(tolower(chDoc)));
+					(ll->chars[numCharsInLine] == MakeLowerCase(chDoc));
 				else if (vstyle.styles[ll->styles[numCharsInLine]].caseForce == Style::caseUpper)
 					allSame = allSame &&
-					(ll->chars[numCharsInLine] == static_cast<char>(toupper(chDoc)));
+					(ll->chars[numCharsInLine] == MakeUpperCase(chDoc));
 				else	{ // Style::caseCamel
-					if ((model.pdoc->WordCharClass(ll->chars[numCharsInLine]) == CharClassify::ccWord) &&
-					  ((numCharsInLine == 0) || (model.pdoc->WordCharClass(ll->chars[numCharsInLine - 1]) != CharClassify::ccWord))) {
-						allSame = allSame && (ll->chars[numCharsInLine] == static_cast<char>(toupper(chDoc)));
+					if ((model.pdoc->IsASCIIWordByte(ll->chars[numCharsInLine])) &&
+					  ((numCharsInLine == 0) || (!model.pdoc->IsASCIIWordByte(ll->chars[numCharsInLine - 1])))) {
+						allSame = allSame && (ll->chars[numCharsInLine] == MakeUpperCase(chDoc));
 					} else {
-						allSame = allSame && (ll->chars[numCharsInLine] == static_cast<char>(tolower(chDoc)));
+						allSame = allSame && (ll->chars[numCharsInLine] == MakeLowerCase(chDoc));
 					}
 				}
 				numCharsInLine++;
@@ -417,7 +418,7 @@ void EditView::LayoutLine(const EditModel &model, int line, Surface *surface, co
 		ll->widthLine = LineLayout::wrapWidthInfinite;
 		ll->lines = 1;
 		if (vstyle.edgeState == EDGE_BACKGROUND) {
-			ll->edgeColumn = model.pdoc->FindColumn(line, vstyle.theEdge);
+			ll->edgeColumn = model.pdoc->FindColumn(line, vstyle.theEdge.column);
 			if (ll->edgeColumn >= posLineStart) {
 				ll->edgeColumn -= posLineStart;
 			}
@@ -440,15 +441,15 @@ void EditView::LayoutLine(const EditModel &model, int line, Surface *surface, co
 			for (int charInLine = 0; charInLine<lineLength; charInLine++) {
 				char chDoc = ll->chars[charInLine];
 				if (vstyle.styles[ll->styles[charInLine]].caseForce == Style::caseUpper)
-					ll->chars[charInLine] = static_cast<char>(toupper(chDoc));
+					ll->chars[charInLine] = static_cast<char>(MakeUpperCase(chDoc));
 				else if (vstyle.styles[ll->styles[charInLine]].caseForce == Style::caseLower)
-					ll->chars[charInLine] = static_cast<char>(tolower(chDoc));
+					ll->chars[charInLine] = static_cast<char>(MakeLowerCase(chDoc));
 				else if (vstyle.styles[ll->styles[charInLine]].caseForce == Style::caseCamel) {
-					if ((model.pdoc->WordCharClass(ll->chars[charInLine]) == CharClassify::ccWord) &&
-					  ((charInLine == 0) || (model.pdoc->WordCharClass(ll->chars[charInLine - 1]) != CharClassify::ccWord))) {
-						ll->chars[charInLine] = static_cast<char>(toupper(chDoc));
+					if ((model.pdoc->IsASCIIWordByte(ll->chars[charInLine])) &&
+					  ((charInLine == 0) || (!model.pdoc->IsASCIIWordByte(ll->chars[charInLine - 1])))) {
+						ll->chars[charInLine] = static_cast<char>(MakeUpperCase(chDoc));
 					} else {
-						ll->chars[charInLine] = static_cast<char>(tolower(chDoc));
+						ll->chars[charInLine] = static_cast<char>(MakeLowerCase(chDoc));
 					}
 				}
 			}
@@ -749,7 +750,7 @@ static ColourDesired TextBackground(const EditModel &model, const ViewStyle &vsD
 		if ((vsDraw.edgeState == EDGE_BACKGROUND) &&
 			(i >= ll->edgeColumn) &&
 			(i < ll->numCharsBeforeEOL))
-			return vsDraw.edgecolour;
+			return vsDraw.theEdge.colour;
 		if (inHotspot && vsDraw.hotspotColours.back.isSet)
 			return vsDraw.hotspotColours.back;
 	}
@@ -1339,12 +1340,24 @@ static void DrawEdgeLine(Surface *surface, const ViewStyle &vsDraw, const LineLa
 	Range lineRange, int xStart) {
 	if (vsDraw.edgeState == EDGE_LINE) {
 		PRectangle rcSegment = rcLine;
-		int edgeX = static_cast<int>(vsDraw.theEdge * vsDraw.spaceWidth);
+		int edgeX = static_cast<int>(vsDraw.theEdge.column * vsDraw.spaceWidth);
 		rcSegment.left = static_cast<XYPOSITION>(edgeX + xStart);
 		if ((ll->wrapIndent != 0) && (lineRange.start != 0))
 			rcSegment.left -= ll->wrapIndent;
 		rcSegment.right = rcSegment.left + 1;
-		surface->FillRectangle(rcSegment, vsDraw.edgecolour);
+		surface->FillRectangle(rcSegment, vsDraw.theEdge.colour);
+	} else if (vsDraw.edgeState == EDGE_MULTILINE) {
+		for (size_t edge = 0; edge < vsDraw.theMultiEdge.size(); edge++) {
+			if (vsDraw.theMultiEdge[edge].column >= 0) {
+				PRectangle rcSegment = rcLine;
+				int edgeX = static_cast<int>(vsDraw.theMultiEdge[edge].column * vsDraw.spaceWidth);
+				rcSegment.left = static_cast<XYPOSITION>(edgeX + xStart);
+				if ((ll->wrapIndent != 0) && (lineRange.start != 0))
+					rcSegment.left -= ll->wrapIndent;
+				rcSegment.right = rcSegment.left + 1;
+				surface->FillRectangle(rcSegment, vsDraw.theMultiEdge[edge].colour);
+			}
+		}
 	}
 }
 
@@ -1919,10 +1932,19 @@ void EditView::PaintText(Surface *surfaceWindow, const EditModel &model, PRectan
 		if (rcBeyondEOF.top < rcBeyondEOF.bottom) {
 			surfaceWindow->FillRectangle(rcBeyondEOF, vsDraw.styles[STYLE_DEFAULT].back);
 			if (vsDraw.edgeState == EDGE_LINE) {
-				int edgeX = static_cast<int>(vsDraw.theEdge * vsDraw.spaceWidth);
+				int edgeX = static_cast<int>(vsDraw.theEdge.column * vsDraw.spaceWidth);
 				rcBeyondEOF.left = static_cast<XYPOSITION>(edgeX + xStart);
 				rcBeyondEOF.right = rcBeyondEOF.left + 1;
-				surfaceWindow->FillRectangle(rcBeyondEOF, vsDraw.edgecolour);
+				surfaceWindow->FillRectangle(rcBeyondEOF, vsDraw.theEdge.colour);
+			} else if (vsDraw.edgeState == EDGE_MULTILINE) {
+				for (size_t edge = 0; edge < vsDraw.theMultiEdge.size(); edge++) {
+					if (vsDraw.theMultiEdge[edge].column >= 0) {
+						int edgeX = static_cast<int>(vsDraw.theMultiEdge[edge].column * vsDraw.spaceWidth);
+						rcBeyondEOF.left = static_cast<XYPOSITION>(edgeX + xStart);
+						rcBeyondEOF.right = rcBeyondEOF.left + 1;
+						surfaceWindow->FillRectangle(rcBeyondEOF, vsDraw.theMultiEdge[edge].colour);
+					}
+				}
 			}
 		}
 		//Platform::DebugPrintf("start display %d, offset = %d\n", pdoc->Length(), xOffset);
@@ -1961,9 +1983,9 @@ long EditView::FormatRange(bool draw, Sci_RangeToFormat *pfr, Surface *surface,
 	// Modify the view style for printing as do not normally want any of the transient features to be printed
 	// Printing supports only the line number margin.
 	int lineNumberIndex = -1;
-	for (int margin = 0; margin <= SC_MAX_MARGIN; margin++) {
+	for (size_t margin = 0; margin < vs.ms.size(); margin++) {
 		if ((vsPrint.ms[margin].style == SC_MARGIN_NUMBER) && (vsPrint.ms[margin].width > 0)) {
-			lineNumberIndex = margin;
+			lineNumberIndex = static_cast<int>(margin);
 		} else {
 			vsPrint.ms[margin].width = 0;
 		}
diff --git a/src/stc/scintilla/src/Editor.cxx b/src/stc/scintilla/src/Editor.cxx
index 1253996..9fcd01f 100644
--- a/src/stc/scintilla/src/Editor.cxx
+++ b/src/stc/scintilla/src/Editor.cxx
@@ -112,6 +112,7 @@ Editor::Editor() {
 	hasFocus = false;
 	errorStatus = 0;
 	mouseDownCaptures = true;
+	mouseWheelCaptures = true;
 
 	lastClickTime = 0;
 	doubleClickCloseThreshold = Point(3, 3);
@@ -739,8 +740,8 @@ void Editor::MultipleSelectAdd(AddNumber addNumber) {
 			const int searchEnd = it->end;
 			for (;;) {
 				int lengthFound = static_cast<int>(selectedText.length());
-				int pos = pdoc->FindText(searchStart, searchEnd, selectedText.c_str(),
-					searchFlags, &lengthFound);
+				int pos = static_cast<int>(pdoc->FindText(searchStart, searchEnd,
+					selectedText.c_str(), searchFlags, &lengthFound));
 				if (pos >= 0) {
 					sel.AddSelection(SelectionRange(pos + lengthFound, pos));
 					ScrollRange(sel.RangeMain());
@@ -1837,15 +1838,26 @@ void Editor::ChangeSize() {
 	}
 }
 
-int Editor::InsertSpace(int position, unsigned int spaces) {
-	if (spaces > 0) {
-		std::string spaceText(spaces, ' ');
-		const int lengthInserted = pdoc->InsertString(position, spaceText.c_str(), spaces);
-		position += lengthInserted;
+int Editor::RealizeVirtualSpace(int position, unsigned int virtualSpace) {
+	if (virtualSpace > 0) {
+		const int line = pdoc->LineFromPosition(position);
+		const int indent = pdoc->GetLineIndentPosition(line);
+		if (indent == position) {
+			return pdoc->SetLineIndentation(line, pdoc->GetLineIndentation(line) + virtualSpace);
+		} else {
+			std::string spaceText(virtualSpace, ' ');
+			const int lengthInserted = pdoc->InsertString(position, spaceText.c_str(), virtualSpace);
+			position += lengthInserted;
+		}
 	}
 	return position;
 }
 
+SelectionPosition Editor::RealizeVirtualSpace(const SelectionPosition &position) {
+	// Return the new position with no virtual space
+	return SelectionPosition(RealizeVirtualSpace(position.Position(), position.VirtualSpace()));
+}
+
 void Editor::AddChar(char ch) {
 	char s[2];
 	s[0] = ch;
@@ -1901,7 +1913,7 @@ void Editor::AddCharUTF(const char *s, unsigned int len, bool treatAsDBCS) {
 						}
 					}
 				}
-				positionInsert = InsertSpace(positionInsert, currentSel->caret.VirtualSpace());
+				positionInsert = RealizeVirtualSpace(positionInsert, currentSel->caret.VirtualSpace());
 				const int lengthInserted = pdoc->InsertString(positionInsert, s, len);
 				if (lengthInserted > 0) {
 					currentSel->caret.SetPosition(positionInsert + lengthInserted);
@@ -1975,7 +1987,7 @@ void Editor::ClearBeforeTentativeStart() {
 					sel.Range(r).MinimizeVirtualSpace();
 				}
 			}
-			InsertSpace(positionInsert, sel.Range(r).caret.VirtualSpace());
+			RealizeVirtualSpace(positionInsert, sel.Range(r).caret.VirtualSpace());
 			sel.Range(r).ClearVirtualSpace();
 		}
 	}
@@ -1984,7 +1996,7 @@ void Editor::ClearBeforeTentativeStart() {
 void Editor::InsertPaste(const char *text, int len) {
 	if (multiPasteMode == SC_MULTIPASTE_ONCE) {
 		SelectionPosition selStart = sel.Start();
-		selStart = SelectionPosition(InsertSpace(selStart.Position(), selStart.VirtualSpace()));
+		selStart = RealizeVirtualSpace(selStart);
 		const int lengthInserted = pdoc->InsertString(selStart.Position(), text, len);
 		if (lengthInserted > 0) {
 			SetEmptySelection(selStart.Position() + lengthInserted);
@@ -2004,7 +2016,7 @@ void Editor::InsertPaste(const char *text, int len) {
 						sel.Range(r).MinimizeVirtualSpace();
 					}
 				}
-				positionInsert = InsertSpace(positionInsert, sel.Range(r).caret.VirtualSpace());
+				positionInsert = RealizeVirtualSpace(positionInsert, sel.Range(r).caret.VirtualSpace());
 				const int lengthInserted = pdoc->InsertString(positionInsert, text, len);
 				if (lengthInserted > 0) {
 					sel.Range(r).caret.SetPosition(positionInsert + lengthInserted);
@@ -2126,8 +2138,7 @@ void Editor::PasteRectangular(SelectionPosition pos, const char *ptr, int len) {
 	sel.RangeMain() = SelectionRange(pos);
 	int line = pdoc->LineFromPosition(sel.MainCaret());
 	UndoGroup ug(pdoc);
-	sel.RangeMain().caret = SelectionPosition(
-		InsertSpace(sel.RangeMain().caret.Position(), sel.RangeMain().caret.VirtualSpace()));
+	sel.RangeMain().caret = RealizeVirtualSpace(sel.RangeMain().caret);
 	int xInsert = XFromPosition(sel.RangeMain().caret);
 	bool prevCr = false;
 	while ((len > 0) && IsEOLChar(ptr[len-1]))
@@ -2179,9 +2190,9 @@ void Editor::Clear() {
 			if (!RangeContainsProtected(sel.Range(r).caret.Position(), sel.Range(r).caret.Position() + 1)) {
 				if (sel.Range(r).Start().VirtualSpace()) {
 					if (sel.Range(r).anchor < sel.Range(r).caret)
-						sel.Range(r) = SelectionRange(InsertSpace(sel.Range(r).anchor.Position(), sel.Range(r).anchor.VirtualSpace()));
+						sel.Range(r) = SelectionRange(RealizeVirtualSpace(sel.Range(r).anchor.Position(), sel.Range(r).anchor.VirtualSpace()));
 					else
-						sel.Range(r) = SelectionRange(InsertSpace(sel.Range(r).caret.Position(), sel.Range(r).caret.VirtualSpace()));
+						sel.Range(r) = SelectionRange(RealizeVirtualSpace(sel.Range(r).caret.Position(), sel.Range(r).caret.VirtualSpace()));
 				}
 				if ((sel.Count() == 1) || !pdoc->IsPositionInLineEnd(sel.Range(r).caret.Position())) {
 					pdoc->DelChar(sel.Range(r).caret.Position());
@@ -2415,9 +2426,9 @@ void Editor::NotifyIndicatorClick(bool click, int position, bool shift, bool ctr
 bool Editor::NotifyMarginClick(Point pt, int modifiers) {
 	int marginClicked = -1;
 	int x = vs.textStart - vs.fixedColumnWidth;
-	for (int margin = 0; margin <= SC_MAX_MARGIN; margin++) {
+	for (size_t margin = 0; margin < vs.ms.size(); margin++) {
 		if ((pt.x >= x) && (pt.x < x + vs.ms[margin].width))
-			marginClicked = margin;
+			marginClicked = static_cast<int>(margin);
 		x += vs.ms[margin].width;
 	}
 	if ((marginClicked >= 0) && vs.ms[marginClicked].sensitive) {
@@ -3283,7 +3294,7 @@ int Editor::HorizontalMove(unsigned int iMessage) {
 		case SCI_CHARLEFTRECTEXTEND:
 			if (pdoc->IsLineEndPosition(spCaret.Position()) && spCaret.VirtualSpace()) {
 				spCaret.SetVirtualSpace(spCaret.VirtualSpace() - 1);
-			} else {
+			} else if ((virtualSpaceOptions & SCVS_NOWRAPLINESTART) == 0 || pdoc->GetColumn(spCaret.Position()) > 0) {
 				spCaret = SelectionPosition(spCaret.Position() - 1);
 			}
 			break;
@@ -3309,13 +3320,13 @@ int Editor::HorizontalMove(unsigned int iMessage) {
 		sel.selType = Selection::selRectangle;
 		sel.Rectangular() = SelectionRange(spCaret, rangeBase.anchor);
 		SetRectangularRange();
+	} else if (sel.IsRectangular()) {
+		// Not a rectangular extension so switch to stream.
+		const SelectionPosition selAtLimit = 
+			(NaturalDirection(iMessage) > 0) ? sel.Limits().end : sel.Limits().start;
+		sel.selType = Selection::selStream;
+		sel.SetSelection(SelectionRange(selAtLimit));
 	} else {
-		if (sel.IsRectangular()) {
-			// Not a rectangular extension so switch to stream.
-			SelectionPosition selAtLimit = (NaturalDirection(iMessage) > 0) ? sel.Limits().end : sel.Limits().start;
-			sel.selType = Selection::selStream;
-			sel.SetSelection(SelectionRange(selAtLimit));
-		}
 		if (!additionalSelectionTyping) {
 			InvalidateWholeSelection();
 			sel.DropAdditionalRanges();
@@ -3328,7 +3339,7 @@ int Editor::HorizontalMove(unsigned int iMessage) {
 			case SCI_CHARLEFTEXTEND:
 				if (spCaret.VirtualSpace()) {
 					spCaret.SetVirtualSpace(spCaret.VirtualSpace() - 1);
-				} else {
+				} else if ((virtualSpaceOptions & SCVS_NOWRAPLINESTART) == 0 || pdoc->GetColumn(spCaret.Position()) > 0) {
 					spCaret = SelectionPosition(spCaret.Position() - 1);
 				}
 				break;
@@ -3411,7 +3422,7 @@ int Editor::HorizontalMove(unsigned int iMessage) {
 			const int directionMove = (spCaret < spCaretNow) ? -1 : 1;
 			spCaret = MovePositionSoVisible(spCaret, directionMove);
 
-			// Handle move versus extend, and special behaviour for non-emoty left/right
+			// Handle move versus extend, and special behaviour for non-empty left/right
 			switch (iMessage) {
 			case SCI_CHARLEFT:
 			case SCI_CHARRIGHT:
@@ -3504,7 +3515,7 @@ int Editor::DelWordOrLine(unsigned int iMessage) {
 		} else {
 			// Delete to the right so first realise the virtual space.
 			sel.Range(r) = SelectionRange(
-				InsertSpace(sel.Range(r).caret.Position(), sel.Range(r).caret.VirtualSpace()));
+				RealizeVirtualSpace(sel.Range(r).caret));
 		}
 
 		Range rangeDelete;
@@ -4208,7 +4219,7 @@ void Editor::DropAt(SelectionPosition position, const char *value, size_t length
 			SetEmptySelection(position);
 		} else {
 			position = MovePositionOutsideChar(position, sel.MainCaret() - position.Position());
-			position = SelectionPosition(InsertSpace(position.Position(), position.VirtualSpace()));
+			position = RealizeVirtualSpace(position);
 			const int lengthInserted = pdoc->InsertString(
 				position.Position(), convertedText.c_str(), static_cast<int>(convertedText.length()));
 			if (lengthInserted > 0) {
@@ -4278,7 +4289,7 @@ bool Editor::PointInSelMargin(Point pt) const {
 
 Window::Cursor Editor::GetMarginCursor(Point pt) const {
 	int x = 0;
-	for (int margin = 0; margin <= SC_MAX_MARGIN; margin++) {
+	for (size_t margin = 0; margin < vs.ms.size(); margin++) {
 		if ((pt.x >= x) && (pt.x < x + vs.ms[margin].width))
 			return static_cast<Window::Cursor>(vs.ms[margin].cursor);
 		x += vs.ms[margin].width;
@@ -5293,6 +5304,9 @@ void Editor::FoldExpand(int line, int action, int level) {
 	if (action == SC_FOLDACTION_TOGGLE) {
 		expanding = !cs.GetExpanded(line);
 	}
+	// Ensure child lines lexed and fold information extracted before
+	// flipping the state.
+	pdoc->GetLastChild(line, LevelNumber(level));
 	SetFoldExpanded(line, expanding);
 	if (expanding && (cs.HiddenLines() == 0))
 		// Nothing to do
@@ -5555,8 +5569,8 @@ void Editor::AddStyledText(char *buffer, int appendLength) {
 	SetEmptySelection(sel.MainCaret() + lengthInserted);
 }
 
-static bool ValidMargin(uptr_t wParam) {
-	return wParam <= SC_MAX_MARGIN;
+bool Editor::ValidMargin(uptr_t wParam) {
+	return wParam < vs.ms.size();
 }
 
 static char *CharPtrFromSPtr(sptr_t lParam) {
@@ -6870,6 +6884,27 @@ sptr_t Editor::WndProc(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
 		else
 			return 0;
 
+	case SCI_SETMARGINBACKN:
+		if (ValidMargin(wParam)) {
+			vs.ms[wParam].back = ColourDesired(static_cast<long>(lParam));
+			InvalidateStyleRedraw();
+		}
+		break;
+
+	case SCI_GETMARGINBACKN:
+		if (ValidMargin(wParam))
+			return vs.ms[wParam].back.AsLong();
+		else
+			return 0;
+
+	case SCI_SETMARGINS:
+		if (wParam < 1000)
+			vs.ms.resize(wParam);
+		break;
+
+	case SCI_GETMARGINS:
+		return vs.ms.size();
+
 	case SCI_STYLECLEARALL:
 		vs.ClearStyles();
 		InvalidateStyleRedraw();
@@ -7420,10 +7455,10 @@ sptr_t Editor::WndProc(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
 		return vs.zoomLevel;
 
 	case SCI_GETEDGECOLUMN:
-		return vs.theEdge;
+		return vs.theEdge.column;
 
 	case SCI_SETEDGECOLUMN:
-		vs.theEdge = static_cast<int>(wParam);
+		vs.theEdge.column = static_cast<int>(wParam);
 		InvalidateStyleRedraw();
 		break;
 
@@ -7436,10 +7471,20 @@ sptr_t Editor::WndProc(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
 		break;
 
 	case SCI_GETEDGECOLOUR:
-		return vs.edgecolour.AsLong();
+		return vs.theEdge.colour.AsLong();
 
 	case SCI_SETEDGECOLOUR:
-		vs.edgecolour = ColourDesired(static_cast<long>(wParam));
+		vs.theEdge.colour = ColourDesired(static_cast<long>(wParam));
+		InvalidateStyleRedraw();
+		break;
+
+	case SCI_MULTIEDGEADDLINE:
+		vs.theMultiEdge.push_back(EdgeProperties(wParam, lParam));
+		InvalidateStyleRedraw();
+		break;
+
+	case SCI_MULTIEDGECLEARALL:
+		std::vector<EdgeProperties>().swap(vs.theMultiEdge); // Free vector and memory, C++03 compatible
 		InvalidateStyleRedraw();
 		break;
 
@@ -7571,6 +7616,13 @@ sptr_t Editor::WndProc(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
 	case SCI_GETMOUSEDOWNCAPTURES:
 		return mouseDownCaptures;
 
+	case SCI_SETMOUSEWHEELCAPTURES:
+		mouseWheelCaptures = wParam != 0;
+		break;
+
+	case SCI_GETMOUSEWHEELCAPTURES:
+		return mouseWheelCaptures;
+
 	case SCI_SETCURSOR:
 		cursorMode = static_cast<int>(wParam);
 		DisplayCursor(Window::cursorText);
diff --git a/src/stc/scintilla/src/Editor.h b/src/stc/scintilla/src/Editor.h
index 93a86fa..5fdcbff 100644
--- a/src/stc/scintilla/src/Editor.h
+++ b/src/stc/scintilla/src/Editor.h
@@ -176,6 +176,7 @@ protected:	// ScintillaBase subclass needs access to much of Editor
 
 	bool hasFocus;
 	bool mouseDownCaptures;
+	bool mouseWheelCaptures;
 
 	int xCaretMargin;	///< Ensure this many pixels visible on both sides of caret
 	bool horizontalScrollBarVisible;
@@ -390,7 +391,8 @@ protected:	// ScintillaBase subclass needs access to much of Editor
 	void ChangeSize();
 
 	void FilterSelections();
-	int InsertSpace(int position, unsigned int spaces);
+	int RealizeVirtualSpace(int position, unsigned int virtualSpace);
+	SelectionPosition RealizeVirtualSpace(const SelectionPosition &position);
 	void AddChar(char ch);
 	virtual void AddCharUTF(const char *s, unsigned int len, bool treatAsDBCS=false);
 	void ClearBeforeTentativeStart();
@@ -569,6 +571,7 @@ protected:	// ScintillaBase subclass needs access to much of Editor
 	void AddStyledText(char *buffer, int appendLength);
 
 	virtual sptr_t DefWndProc(unsigned int iMessage, uptr_t wParam, sptr_t lParam) = 0;
+	bool ValidMargin(uptr_t wParam);
 	void StyleSetMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
 	sptr_t StyleGetMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
 
diff --git a/src/stc/scintilla/src/MarginView.cxx b/src/stc/scintilla/src/MarginView.cxx
index 52a2cb2..3ec70f0 100644
--- a/src/stc/scintilla/src/MarginView.cxx
+++ b/src/stc/scintilla/src/MarginView.cxx
@@ -193,7 +193,7 @@ void MarginView::PaintMargin(Surface *surface, int topLine, PRectangle rc, PRect
 
 	Point ptOrigin = model.GetVisibleOriginInMain();
 	FontAlias fontLineNumber = vs.styles[STYLE_LINENUMBER].font;
-	for (int margin = 0; margin <= SC_MAX_MARGIN; margin++) {
+	for (size_t margin = 0; margin < vs.ms.size(); margin++) {
 		if (vs.ms[margin].width > 0) {
 
 			rcSelMargin.left = rcSelMargin.right;
@@ -216,6 +216,9 @@ void MarginView::PaintMargin(Surface *surface, int topLine, PRectangle rc, PRect
 					case SC_MARGIN_FORE:
 						colour = vs.styles[STYLE_DEFAULT].fore;
 						break;
+					case SC_MARGIN_COLOUR:
+						colour = vs.ms[margin].back;
+						break;
 					default:
 						colour = vs.styles[STYLE_LINENUMBER].back;
 						break;
diff --git a/src/stc/scintilla/src/ScintillaBase.cxx b/src/stc/scintilla/src/ScintillaBase.cxx
index b6e2fb3..92605d9 100644
--- a/src/stc/scintilla/src/ScintillaBase.cxx
+++ b/src/stc/scintilla/src/ScintillaBase.cxx
@@ -218,7 +218,7 @@ void ScintillaBase::AutoCompleteInsert(Position startPos, int removeLen, const c
 			if (!RangeContainsProtected(sel.Range(r).Start().Position(),
 				sel.Range(r).End().Position())) {
 				int positionInsert = sel.Range(r).Start().Position();
-				positionInsert = InsertSpace(positionInsert, sel.Range(r).caret.VirtualSpace());
+				positionInsert = RealizeVirtualSpace(positionInsert, sel.Range(r).caret.VirtualSpace());
 				if (positionInsert - removeLen >= 0) {
 					positionInsert -= removeLen;
 					pdoc->DeleteChars(positionInsert, removeLen);
diff --git a/src/stc/scintilla/src/SplitVector.h b/src/stc/scintilla/src/SplitVector.h
index 3153700..df72253 100644
--- a/src/stc/scintilla/src/SplitVector.h
+++ b/src/stc/scintilla/src/SplitVector.h
@@ -29,15 +29,17 @@ protected:
 	void GapTo(int position) {
 		if (position != part1Length) {
 			if (position < part1Length) {
-				memmove(
-					body + position + gapLength,
+				// Moving the gap towards start so moving elements towards end
+				std::copy_backward(
 					body + position,
-					sizeof(T) * (part1Length - position));
-			} else {	// position > part1Length
-				memmove(
 					body + part1Length,
+					body + gapLength + part1Length);
+			} else {	// position > part1Length
+				// Moving the gap towards end so moving elements towards start
+				std::copy(
 					body + part1Length + gapLength,
-					sizeof(T) * (position - part1Length));
+					body + gapLength + position,
+					body + part1Length);
 			}
 			part1Length = position;
 		}
@@ -93,7 +95,7 @@ public:
 			GapTo(lengthBody);
 			T *newBody = new T[newSize];
 			if ((size != 0) && (body != 0)) {
-				memmove(newBody, body, sizeof(T) * lengthBody);
+				std::copy(body, body + lengthBody, newBody);
 				delete []body;
 			}
 			body = newBody;
@@ -205,7 +207,7 @@ public:
 			}
 			RoomFor(insertLength);
 			GapTo(positionToInsert);
-			memmove(body + part1Length, s + positionFrom, sizeof(T) * insertLength);
+			std::copy(s + positionFrom, s + positionFrom + insertLength, body + part1Length);
 			lengthBody += insertLength;
 			part1Length += insertLength;
 			gapLength -= insertLength;
@@ -254,11 +256,11 @@ public:
 			if (range1Length > part1AfterPosition)
 				range1Length = part1AfterPosition;
 		}
-		memcpy(buffer, body + position, range1Length * sizeof(T));
+		std::copy(body + position, body + position + range1Length, buffer);
 		buffer += range1Length;
 		position = position + range1Length + gapLength;
 		int range2Length = retrieveLength - range1Length;
-		memcpy(buffer, body + position, range2Length * sizeof(T));
+		std::copy(body + position, body + position + range2Length, buffer);
 	}
 
 	T *BufferPointer() {
diff --git a/src/stc/scintilla/src/ViewStyle.cxx b/src/stc/scintilla/src/ViewStyle.cxx
index ae68d8b..58dbf16 100644
--- a/src/stc/scintilla/src/ViewStyle.cxx
+++ b/src/stc/scintilla/src/ViewStyle.cxx
@@ -139,17 +139,13 @@ ViewStyle::ViewStyle(const ViewStyle &source) {
 	alwaysShowCaretLineBackground = source.alwaysShowCaretLineBackground;
 	caretLineBackground = source.caretLineBackground;
 	caretLineAlpha = source.caretLineAlpha;
-	edgecolour = source.edgecolour;
-	edgeState = source.edgeState;
 	caretStyle = source.caretStyle;
 	caretWidth = source.caretWidth;
 	someStylesProtected = false;
 	someStylesForceCase = false;
 	leftMarginWidth = source.leftMarginWidth;
 	rightMarginWidth = source.rightMarginWidth;
-	for (int margin=0; margin <= SC_MAX_MARGIN; margin++) {
-		ms[margin] = source.ms[margin];
-	}
+	ms = source.ms;
 	maskInLine = source.maskInLine;
 	maskDrawInText = source.maskDrawInText;
 	fixedColumnWidth = source.fixedColumnWidth;
@@ -171,7 +167,9 @@ ViewStyle::ViewStyle(const ViewStyle &source) {
 	braceBadLightIndicatorSet = source.braceBadLightIndicatorSet;
 	braceBadLightIndicator = source.braceBadLightIndicator;
 
+	edgeState = source.edgeState;
 	theEdge = source.theEdge;
+	theMultiEdge = source.theMultiEdge;
 
 	marginNumberPadding = source.marginNumberPadding;
 	ctrlCharPadding = source.ctrlCharPadding;
@@ -196,7 +194,7 @@ void ViewStyle::CalculateMarginWidthAndMask() {
 	fixedColumnWidth = marginInside ? leftMarginWidth : 0;
 	maskInLine = 0xffffffff;
 	int maskDefinedMarkers = 0;
-	for (int margin = 0; margin <= SC_MAX_MARGIN; margin++) {
+	for (size_t margin = 0; margin < ms.size(); margin++) {
 		fixedColumnWidth += ms[margin].width;
 		if (ms[margin].width > 0)
 			maskInLine &= ~ms[margin].mask;
@@ -268,8 +266,6 @@ void ViewStyle::Init(size_t stylesSize_) {
 	alwaysShowCaretLineBackground = false;
 	caretLineBackground = ColourDesired(0xff, 0xff, 0);
 	caretLineAlpha = SC_ALPHA_NOALPHA;
-	edgecolour = ColourDesired(0xc0, 0xc0, 0xc0);
-	edgeState = EDGE_NONE;
 	caretStyle = CARETSTYLE_LINE;
 	caretWidth = 1;
 	someStylesProtected = false;
@@ -282,6 +278,7 @@ void ViewStyle::Init(size_t stylesSize_) {
 
 	leftMarginWidth = 1;
 	rightMarginWidth = 1;
+	ms.resize(SC_MAX_MARGIN + 1);
 	ms[0].style = SC_MARGIN_NUMBER;
 	ms[0].width = 0;
 	ms[0].mask = 0;
@@ -310,7 +307,8 @@ void ViewStyle::Init(size_t stylesSize_) {
 	braceBadLightIndicatorSet = false;
 	braceBadLightIndicator = 0;
 
-	theEdge = 0;
+	edgeState = EDGE_NONE;
+	theEdge = EdgeProperties(0, ColourDesired(0xc0, 0xc0, 0xc0));
 
 	marginNumberPadding = 3;
 	ctrlCharPadding = 3; // +3 For a blank on front and rounded edge each side
diff --git a/src/stc/scintilla/src/ViewStyle.h b/src/stc/scintilla/src/ViewStyle.h
index d5a9d5b..3b81269 100644
--- a/src/stc/scintilla/src/ViewStyle.h
+++ b/src/stc/scintilla/src/ViewStyle.h
@@ -17,6 +17,7 @@ namespace Scintilla {
 class MarginStyle {
 public:
 	int style;
+	ColourDesired back;
 	int width;
 	int mask;
 	bool sensitive;
@@ -72,6 +73,17 @@ struct ForeBackColours {
 	ColourOptional back;
 };
 
+struct EdgeProperties {
+	int column;
+	ColourDesired colour;
+	EdgeProperties(int column_ = 0, ColourDesired colour_ = ColourDesired(0)) :
+		column(column_), colour(colour_) {
+	}
+	EdgeProperties(uptr_t wParam, sptr_t lParam) :
+		column(static_cast<int>(wParam)), colour(static_cast<long>(lParam)) {
+	}
+};
+
 /**
  */
 class ViewStyle {
@@ -115,7 +127,7 @@ public:
 	int rightMarginWidth;	///< Spacing margin on right of text
 	int maskInLine;	///< Mask for markers to be put into text because there is nowhere for them to go in margin
 	int maskDrawInText;	///< Mask for markers that always draw in text
-	MarginStyle ms[SC_MAX_MARGIN+1];
+	std::vector<MarginStyle> ms;
 	int fixedColumnWidth;	///< Total width of margins
 	bool marginInside;	///< true: margin included in text view, false: separate views
 	int textStart;	///< Starting x position of text within the view
@@ -130,8 +142,6 @@ public:
 	bool alwaysShowCaretLineBackground;
 	ColourDesired caretLineBackground;
 	int caretLineAlpha;
-	ColourDesired edgecolour;
-	int edgeState;
 	int caretStyle;
 	int caretWidth;
 	bool someStylesProtected;
@@ -146,7 +156,9 @@ public:
 	int braceHighlightIndicator;
 	bool braceBadLightIndicatorSet;
 	int braceBadLightIndicator;
-	int theEdge;
+	int edgeState;
+	EdgeProperties theEdge;
+	std::vector<EdgeProperties> theMultiEdge;
 	int marginNumberPadding; // the right-side padding of the number margin
 	int ctrlCharPadding; // the padding around control character text blobs
 	int lastSegItalicsOffset; // the offset so as not to clip italic characters at EOLs
diff --git a/src/stc/scintilla/src/XPM.cxx b/src/stc/scintilla/src/XPM.cxx
index 20e6c8b..4841e4f 100644
--- a/src/stc/scintilla/src/XPM.cxx
+++ b/src/stc/scintilla/src/XPM.cxx
@@ -22,13 +22,13 @@ using namespace Scintilla;
 
 static const char *NextField(const char *s) {
 	// In case there are leading spaces in the string
-	while (*s && *s == ' ') {
+	while (*s == ' ') {
 		s++;
 	}
 	while (*s && *s != ' ') {
 		s++;
 	}
-	while (*s && *s == ' ') {
+	while (*s == ' ') {
 		s++;
 	}
 	return s;
diff --git a/src/stc/stc.cpp.in b/src/stc/stc.cpp.in
index f72676e..354b855 100644
--- a/src/stc/stc.cpp.in
+++ b/src/stc/stc.cpp.in
@@ -857,6 +857,22 @@ void wxStyledTextCtrl::OnContextMenu(wxContextMenuEvent& evt) {
 
 void wxStyledTextCtrl::OnMouseWheel(wxMouseEvent& evt)
 {
+    // if the mouse wheel is not captured, test if the mouse
+    // pointer is over the editor window and if not, don't
+    // handle the message but pass it on.
+    if ( !GetMouseWheelCaptures() ) {
+        if ( !GetRect().Contains(evt.GetPosition()) ) {
+            wxWindow* parent = GetParent();
+            if (parent != NULL) {
+                wxMouseEvent newevt(evt);
+                newevt.SetPosition(
+                    parent->ScreenToClient(ClientToScreen(evt.GetPosition())));
+                parent->ProcessWindowEvent(newevt);
+            }
+            return;
+        }
+    }
+    
     m_swx->DoMouseWheel(evt.GetWheelAxis(),
                         evt.GetWheelRotation(),
                         evt.GetWheelDelta(),
@@ -1233,7 +1249,7 @@ wxStyledTextEvent::wxStyledTextEvent(const wxStyledTextEvent& event):
 
 /*static*/ wxVersionInfo wxStyledTextCtrl::GetLibraryVersionInfo()
 {
-    return wxVersionInfo("Scintilla", 3, 6, 6, "Scintilla 3.6.6");
+    return wxVersionInfo("Scintilla", 3, 7, 0, "Scintilla 3.7.0");
 }
 
 #endif // wxUSE_STC
