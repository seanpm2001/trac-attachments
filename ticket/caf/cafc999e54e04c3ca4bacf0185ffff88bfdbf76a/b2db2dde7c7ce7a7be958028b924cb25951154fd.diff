Index: wxX11.spec
===================================================================
--- wxX11.spec	(revision 52157)
+++ wxX11.spec	(working copy)
@@ -256,7 +256,6 @@ wx/unix/private.h
 wx/unix/stackwalk.h
 wx/unix/stdpaths.h
 wx/fs_inet.h
-wx/gsocket.h
 wx/protocol/file.h
 wx/protocol/ftp.h
 wx/protocol/http.h
@@ -266,7 +265,6 @@ wx/sckipc.h
 wx/sckstrm.h
 wx/socket.h
 wx/url.h
-wx/unix/gsockunx.h
 wx/xml/xml.h
 wx/xtixml.h
 wx/db.h
Index: autoconf_inc.m4
===================================================================
--- autoconf_inc.m4	(revision 52157)
+++ autoconf_inc.m4	(working copy)
@@ -1,10 +1,10 @@
 dnl ### begin block 00_header[../../contrib/build/deprecated/deprecated.bkl,../../contrib/build/fl/fl.bkl,../../contrib/build/foldbar/foldbar.bkl,../../contrib/build/gizmos/gizmos.bkl,../../contrib/build/mmedia/mmedia.bkl,../../contrib/build/net/net.bkl,../../contrib/build/ogl/ogl.bkl,../../contrib/build/plot/plot.bkl,../../contrib/build/stc/stc.bkl,../../contrib/build/svg/svg.bkl,../../contrib/samples/deprecated/proplist/proplist.bkl,../../contrib/samples/deprecated/resource/resource.bkl,../../contrib/samples/deprecated/treelay/treelay.bkl,../../contrib/samples/fl/fl.bkl,../../contrib/samples/foldbar/extended/extended.bkl,../../contrib/samples/foldbar/foldpanelbar/foldtest.bkl,../../contrib/samples/gizmos/dynsash/dynsash.bkl,../../contrib/samples/gizmos/dynsash_switch/dynsash_switch.bkl,../../contrib/samples/gizmos/editlbox/editlbox.bkl,../../contrib/samples/gizmos/led/led.bkl,../../contrib/samples/gizmos/multicell/multicell.bkl,../../contrib/samples/gizmos/splittree/splittree.bkl,../../contrib/samples/mmedia/mmboard.bkl,../../contrib/samples/ogl/ogledit/ogledit.bkl,../../contrib/samples/ogl/studio/studio.bkl,../../contrib/samples/plot/plot.bkl,../../contrib/samples/stc/stctest.bkl,../../contrib/samples/svg/svgtest.bkl,../../contrib/utils/convertrc/convertrc.bkl,../../demos/bombs/bombs.bkl,../../demos/dbbrowse/dbbrowse.bkl,../../demos/demos.bkl,../../demos/forty/forty.bkl,../../demos/fractal/fractal.bkl,../../demos/life/life.bkl,../../demos/poem/poem.bkl,../../samples/access/access.bkl,../../samples/animate/anitest.bkl,../../samples/artprov/artprov.bkl,../../samples/aui/auidemo.bkl,../../samples/calendar/calendar.bkl,../../samples/caret/caret.bkl,../../samples/checklst/checklst.bkl,../../samples/collpane/collpane.bkl,../../samples/combo/combo.bkl,../../samples/config/config.bkl,../../samples/console/console.bkl,../../samples/controls/controls.bkl,../../samples/dataview/dataview.bkl,../../samples/db/db.bkl,../../samples/debugrpt/debugrpt.bkl,../../samples/dialogs/dialogs.bkl,../../samples/dialup/dialup.bkl,../../samples/display/display.bkl,../../samples/dnd/dnd.bkl,../../samples/docview/docview.bkl,../../samples/docvwmdi/docvwmdi.bkl,../../samples/dragimag/dragimag.bkl,../../samples/drawing/drawing.bkl,../../samples/dynamic/dynamic.bkl,../../samples/erase/erase.bkl,../../samples/event/event.bkl,../../samples/except/except.bkl,../../samples/exec/exec.bkl,../../samples/font/font.bkl,../../samples/grid/grid.bkl,../../samples/help/help.bkl,../../samples/htlbox/htlbox.bkl,../../samples/html/about/about.bkl,../../samples/html/help/help.bkl,../../samples/html/helpview/helpview.bkl,../../samples/html/html_samples.bkl,../../samples/html/htmlctrl/htmlctrl.bkl,../../samples/html/printing/printing.bkl,../../samples/html/test/test.bkl,../../samples/html/virtual/virtual.bkl,../../samples/html/widget/widget.bkl,../../samples/html/zip/zip.bkl,../../samples/image/image.bkl,../../samples/internat/internat.bkl,../../samples/ipc/ipc.bkl,../../samples/joytest/joytest.bkl,../../samples/keyboard/keyboard.bkl,../../samples/layout/layout.bkl,../../samples/listbox/listbox.bkl,../../samples/listctrl/listctrl.bkl,../../samples/mdi/mdi.bkl,../../samples/mediaplayer/mediaplayer.bkl,../../samples/memcheck/memcheck.bkl,../../samples/menu/menu.bkl,../../samples/mfc/mfc.bkl,../../samples/minifram/minifram.bkl,../../samples/minimal/minimal.bkl,../../samples/mobile/mobile_samples.bkl,../../samples/mobile/styles/styles.bkl,../../samples/mobile/wxedit/wxedit.bkl,../../samples/multimon/multimon.bkl,../../samples/nativdlg/nativdlg.bkl,../../samples/notebook/notebook.bkl,../../samples/oleauto/oleauto.bkl,../../samples/opengl/cube/cube.bkl,../../samples/opengl/isosurf/isosurf.bkl,../../samples/opengl/opengl_samples.bkl,../../samples/opengl/penguin/penguin.bkl,../../samples/ownerdrw/ownerdrw.bkl,../../samples/png/png.bkl,../../samples/popup/popup.bkl,../../samples/power/power.bkl,../../samples/printing/printing.bkl,../../samples/propsize/propsize.bkl,../../samples/regtest/regtest.bkl,../../samples/render/render.bkl,../../samples/richtext/richtext.bkl,../../samples/rotate/rotate.bkl,../../samples/sashtest/sashtest.bkl,../../samples/scroll/scroll.bkl,../../samples/scrollsub/scrollsub.bkl,../../samples/shaped/shaped.bkl,../../samples/sockets/sockets.bkl,../../samples/sound/sound.bkl,../../samples/splash/splash.bkl,../../samples/splitter/splitter.bkl,../../samples/statbar/statbar.bkl,../../samples/taskbar/taskbar.bkl,../../samples/text/text.bkl,../../samples/thread/thread.bkl,../../samples/toolbar/toolbar.bkl,../../samples/treectrl/treectrl.bkl,../../samples/typetest/typetest.bkl,../../samples/validate/validate.bkl,../../samples/vscroll/vscroll.bkl,../../samples/widgets/widgets.bkl,../../samples/wizard/wizard.bkl,../../samples/xrc/xrcdemo.bkl,../../tests/test.bkl,../../utils/HelpGen/src/helpgen.bkl,../../utils/emulator/src/emulator.bkl,../../utils/helpview/src/helpview.bkl,../../utils/hhp2cached/hhp2cached.bkl,../../utils/tex2rtf/src/tex2rtf.bkl,../../utils/utils.bkl,../../utils/wxrc/wxrc.bkl,wx.bkl] ###
 dnl
 dnl This macro was generated by
-dnl Bakefile 0.2.2 (http://bakefile.sourceforge.net)
+dnl Bakefile 0.2.3 (http://www.bakefile.org)
 dnl Do not modify, all changes will be overwritten!
 
-BAKEFILE_AUTOCONF_INC_M4_VERSION="0.2.2"
+BAKEFILE_AUTOCONF_INC_M4_VERSION="0.2.3"
 
 dnl ### begin block 10_AC_BAKEFILE_PRECOMP_HEADERS[../../contrib/build/deprecated/deprecated.bkl,../../contrib/build/fl/fl.bkl,../../contrib/build/foldbar/foldbar.bkl,../../contrib/build/gizmos/gizmos.bkl,../../contrib/build/mmedia/mmedia.bkl,../../contrib/build/net/net.bkl,../../contrib/build/ogl/ogl.bkl,../../contrib/build/plot/plot.bkl,../../contrib/build/svg/svg.bkl,../../tests/test.bkl,wx.bkl] ###
 AC_BAKEFILE_PRECOMP_HEADERS
@@ -350,6 +350,12 @@ dnl ### begin block 20_COND_PLATFORM_MAC
         COND_PLATFORM_MACOS_1=""
     fi
     AC_SUBST(COND_PLATFORM_MACOS_1)
+dnl ### begin block 20_COND_PLATFORM_MAC_0[../../contrib/samples/deprecated/proplist/proplist.bkl,../../contrib/samples/deprecated/resource/resource.bkl,../../contrib/samples/deprecated/treelay/treelay.bkl,../../contrib/samples/fl/fl.bkl,../../contrib/samples/foldbar/extended/extended.bkl,../../contrib/samples/foldbar/foldpanelbar/foldtest.bkl,../../contrib/samples/gizmos/dynsash/dynsash.bkl,../../contrib/samples/gizmos/dynsash_switch/dynsash_switch.bkl,../../contrib/samples/gizmos/editlbox/editlbox.bkl,../../contrib/samples/gizmos/led/led.bkl,../../contrib/samples/gizmos/multicell/multicell.bkl,../../contrib/samples/gizmos/splittree/splittree.bkl,../../contrib/samples/mmedia/mmboard.bkl,../../contrib/samples/ogl/ogledit/ogledit.bkl,../../contrib/samples/ogl/studio/studio.bkl,../../contrib/samples/plot/plot.bkl,../../contrib/samples/stc/stctest.bkl,../../contrib/samples/svg/svgtest.bkl,../../contrib/utils/convertrc/convertrc.bkl,../../demos/bombs/bombs.bkl,../../demos/dbbrowse/dbbrowse.bkl,../../demos/forty/forty.bkl,../../demos/fractal/fractal.bkl,../../demos/life/life.bkl,../../demos/poem/poem.bkl,../../samples/access/access.bkl,../../samples/animate/anitest.bkl,../../samples/artprov/artprov.bkl,../../samples/aui/auidemo.bkl,../../samples/calendar/calendar.bkl,../../samples/caret/caret.bkl,../../samples/checklst/checklst.bkl,../../samples/collpane/collpane.bkl,../../samples/combo/combo.bkl,../../samples/config/config.bkl,../../samples/console/console.bkl,../../samples/controls/controls.bkl,../../samples/dataview/dataview.bkl,../../samples/db/db.bkl,../../samples/debugrpt/debugrpt.bkl,../../samples/dialogs/dialogs.bkl,../../samples/dialup/dialup.bkl,../../samples/display/display.bkl,../../samples/dnd/dnd.bkl,../../samples/docview/docview.bkl,../../samples/docvwmdi/docvwmdi.bkl,../../samples/dragimag/dragimag.bkl,../../samples/drawing/drawing.bkl,../../samples/dynamic/dynamic.bkl,../../samples/erase/erase.bkl,../../samples/event/event.bkl,../../samples/except/except.bkl,../../samples/exec/exec.bkl,../../samples/font/font.bkl,../../samples/grid/grid.bkl,../../samples/help/help.bkl,../../samples/htlbox/htlbox.bkl,../../samples/html/about/about.bkl,../../samples/html/help/help.bkl,../../samples/html/helpview/helpview.bkl,../../samples/html/htmlctrl/htmlctrl.bkl,../../samples/html/printing/printing.bkl,../../samples/html/test/test.bkl,../../samples/html/virtual/virtual.bkl,../../samples/html/widget/widget.bkl,../../samples/html/zip/zip.bkl,../../samples/image/image.bkl,../../samples/internat/internat.bkl,../../samples/ipc/ipc.bkl,../../samples/joytest/joytest.bkl,../../samples/keyboard/keyboard.bkl,../../samples/layout/layout.bkl,../../samples/listbox/listbox.bkl,../../samples/listctrl/listctrl.bkl,../../samples/mdi/mdi.bkl,../../samples/mediaplayer/mediaplayer.bkl,../../samples/memcheck/memcheck.bkl,../../samples/menu/menu.bkl,../../samples/mfc/mfc.bkl,../../samples/minifram/minifram.bkl,../../samples/minimal/minimal.bkl,../../samples/mobile/styles/styles.bkl,../../samples/mobile/wxedit/wxedit.bkl,../../samples/multimon/multimon.bkl,../../samples/nativdlg/nativdlg.bkl,../../samples/notebook/notebook.bkl,../../samples/oleauto/oleauto.bkl,../../samples/opengl/cube/cube.bkl,../../samples/opengl/isosurf/isosurf.bkl,../../samples/opengl/penguin/penguin.bkl,../../samples/ownerdrw/ownerdrw.bkl,../../samples/png/png.bkl,../../samples/popup/popup.bkl,../../samples/power/power.bkl,../../samples/printing/printing.bkl,../../samples/propsize/propsize.bkl,../../samples/regtest/regtest.bkl,../../samples/render/render.bkl,../../samples/richtext/richtext.bkl,../../samples/rotate/rotate.bkl,../../samples/sashtest/sashtest.bkl,../../samples/scroll/scroll.bkl,../../samples/scrollsub/scrollsub.bkl,../../samples/shaped/shaped.bkl,../../samples/sockets/sockets.bkl,../../samples/sound/sound.bkl,../../samples/splash/splash.bkl,../../samples/splitter/splitter.bkl,../../samples/statbar/statbar.bkl,../../samples/taskbar/taskbar.bkl,../../samples/text/text.bkl,../../samples/thread/thread.bkl,../../samples/toolbar/toolbar.bkl,../../samples/treectrl/treectrl.bkl,../../samples/typetest/typetest.bkl,../../samples/validate/validate.bkl,../../samples/vscroll/vscroll.bkl,../../samples/widgets/widgets.bkl,../../samples/wizard/wizard.bkl,../../samples/xrc/xrcdemo.bkl,../../tests/test.bkl,../../utils/HelpGen/src/helpgen.bkl,../../utils/emulator/src/emulator.bkl,../../utils/helpview/src/helpview.bkl,../../utils/hhp2cached/hhp2cached.bkl,../../utils/tex2rtf/src/tex2rtf.bkl,../../utils/wxrc/wxrc.bkl] ###
+    COND_PLATFORM_MAC_0="#"
+    if test "x$PLATFORM_MAC" = "x0" ; then
+        COND_PLATFORM_MAC_0=""
+    fi
+    AC_SUBST(COND_PLATFORM_MAC_0)
 dnl ### begin block 20_COND_PLATFORM_MAC_1[../../contrib/samples/deprecated/proplist/proplist.bkl,../../contrib/samples/deprecated/resource/resource.bkl,../../contrib/samples/deprecated/treelay/treelay.bkl,../../contrib/samples/fl/fl.bkl,../../contrib/samples/foldbar/extended/extended.bkl,../../contrib/samples/foldbar/foldpanelbar/foldtest.bkl,../../contrib/samples/gizmos/dynsash/dynsash.bkl,../../contrib/samples/gizmos/dynsash_switch/dynsash_switch.bkl,../../contrib/samples/gizmos/editlbox/editlbox.bkl,../../contrib/samples/gizmos/led/led.bkl,../../contrib/samples/gizmos/multicell/multicell.bkl,../../contrib/samples/gizmos/splittree/splittree.bkl,../../contrib/samples/mmedia/mmboard.bkl,../../contrib/samples/ogl/ogledit/ogledit.bkl,../../contrib/samples/ogl/studio/studio.bkl,../../contrib/samples/plot/plot.bkl,../../contrib/samples/stc/stctest.bkl,../../contrib/samples/svg/svgtest.bkl,../../contrib/utils/convertrc/convertrc.bkl,../../demos/bombs/bombs.bkl,../../demos/dbbrowse/dbbrowse.bkl,../../demos/forty/forty.bkl,../../demos/fractal/fractal.bkl,../../demos/life/life.bkl,../../demos/poem/poem.bkl,../../samples/access/access.bkl,../../samples/animate/anitest.bkl,../../samples/artprov/artprov.bkl,../../samples/aui/auidemo.bkl,../../samples/calendar/calendar.bkl,../../samples/caret/caret.bkl,../../samples/checklst/checklst.bkl,../../samples/collpane/collpane.bkl,../../samples/combo/combo.bkl,../../samples/config/config.bkl,../../samples/console/console.bkl,../../samples/controls/controls.bkl,../../samples/dataview/dataview.bkl,../../samples/db/db.bkl,../../samples/debugrpt/debugrpt.bkl,../../samples/dialogs/dialogs.bkl,../../samples/dialup/dialup.bkl,../../samples/display/display.bkl,../../samples/dnd/dnd.bkl,../../samples/docview/docview.bkl,../../samples/docvwmdi/docvwmdi.bkl,../../samples/dragimag/dragimag.bkl,../../samples/drawing/drawing.bkl,../../samples/dynamic/dynamic.bkl,../../samples/erase/erase.bkl,../../samples/event/event.bkl,../../samples/except/except.bkl,../../samples/exec/exec.bkl,../../samples/font/font.bkl,../../samples/grid/grid.bkl,../../samples/help/help.bkl,../../samples/htlbox/htlbox.bkl,../../samples/html/about/about.bkl,../../samples/html/help/help.bkl,../../samples/html/helpview/helpview.bkl,../../samples/html/htmlctrl/htmlctrl.bkl,../../samples/html/printing/printing.bkl,../../samples/html/test/test.bkl,../../samples/html/virtual/virtual.bkl,../../samples/html/widget/widget.bkl,../../samples/html/zip/zip.bkl,../../samples/image/image.bkl,../../samples/internat/internat.bkl,../../samples/ipc/ipc.bkl,../../samples/joytest/joytest.bkl,../../samples/keyboard/keyboard.bkl,../../samples/layout/layout.bkl,../../samples/listbox/listbox.bkl,../../samples/listctrl/listctrl.bkl,../../samples/mdi/mdi.bkl,../../samples/mediaplayer/mediaplayer.bkl,../../samples/memcheck/memcheck.bkl,../../samples/menu/menu.bkl,../../samples/mfc/mfc.bkl,../../samples/minifram/minifram.bkl,../../samples/minimal/minimal.bkl,../../samples/mobile/styles/styles.bkl,../../samples/mobile/wxedit/wxedit.bkl,../../samples/multimon/multimon.bkl,../../samples/nativdlg/nativdlg.bkl,../../samples/notebook/notebook.bkl,../../samples/oleauto/oleauto.bkl,../../samples/opengl/cube/cube.bkl,../../samples/opengl/isosurf/isosurf.bkl,../../samples/opengl/penguin/penguin.bkl,../../samples/ownerdrw/ownerdrw.bkl,../../samples/png/png.bkl,../../samples/popup/popup.bkl,../../samples/power/power.bkl,../../samples/printing/printing.bkl,../../samples/propsize/propsize.bkl,../../samples/regtest/regtest.bkl,../../samples/render/render.bkl,../../samples/richtext/richtext.bkl,../../samples/rotate/rotate.bkl,../../samples/sashtest/sashtest.bkl,../../samples/scroll/scroll.bkl,../../samples/scrollsub/scrollsub.bkl,../../samples/shaped/shaped.bkl,../../samples/sockets/sockets.bkl,../../samples/sound/sound.bkl,../../samples/splash/splash.bkl,../../samples/splitter/splitter.bkl,../../samples/statbar/statbar.bkl,../../samples/taskbar/taskbar.bkl,../../samples/text/text.bkl,../../samples/thread/thread.bkl,../../samples/toolbar/toolbar.bkl,../../samples/treectrl/treectrl.bkl,../../samples/typetest/typetest.bkl,../../samples/validate/validate.bkl,../../samples/vscroll/vscroll.bkl,../../samples/widgets/widgets.bkl,../../samples/wizard/wizard.bkl,../../samples/xrc/xrcdemo.bkl,../../tests/test.bkl,../../utils/HelpGen/src/helpgen.bkl,../../utils/emulator/src/emulator.bkl,../../utils/helpview/src/helpview.bkl,../../utils/hhp2cached/hhp2cached.bkl,../../utils/tex2rtf/src/tex2rtf.bkl,../../utils/wxrc/wxrc.bkl] ###
     COND_PLATFORM_MAC_1="#"
     if test "x$PLATFORM_MAC" = "x1" ; then
@@ -824,6 +830,18 @@ dnl ### begin block 20_COND_USE_RTTI_1[.
         COND_USE_RTTI_1=""
     fi
     AC_SUBST(COND_USE_RTTI_1)
+dnl ### begin block 20_COND_USE_RW_MUTEX_0[../../contrib/build/deprecated/deprecated.bkl,../../contrib/build/fl/fl.bkl,../../contrib/build/foldbar/foldbar.bkl,../../contrib/build/gizmos/gizmos.bkl,../../contrib/build/mmedia/mmedia.bkl,../../contrib/build/net/net.bkl,../../contrib/build/ogl/ogl.bkl,../../contrib/build/plot/plot.bkl,../../contrib/build/stc/stc.bkl,../../contrib/build/svg/svg.bkl,../../contrib/samples/deprecated/proplist/proplist.bkl,../../contrib/samples/deprecated/resource/resource.bkl,../../contrib/samples/deprecated/treelay/treelay.bkl,../../contrib/samples/fl/fl.bkl,../../contrib/samples/foldbar/extended/extended.bkl,../../contrib/samples/foldbar/foldpanelbar/foldtest.bkl,../../contrib/samples/gizmos/dynsash/dynsash.bkl,../../contrib/samples/gizmos/dynsash_switch/dynsash_switch.bkl,../../contrib/samples/gizmos/editlbox/editlbox.bkl,../../contrib/samples/gizmos/led/led.bkl,../../contrib/samples/gizmos/multicell/multicell.bkl,../../contrib/samples/gizmos/splittree/splittree.bkl,../../contrib/samples/mmedia/mmboard.bkl,../../contrib/samples/ogl/ogledit/ogledit.bkl,../../contrib/samples/ogl/studio/studio.bkl,../../contrib/samples/plot/plot.bkl,../../contrib/samples/stc/stctest.bkl,../../contrib/samples/svg/svgtest.bkl,../../contrib/utils/convertrc/convertrc.bkl,../../demos/bombs/bombs.bkl,../../demos/dbbrowse/dbbrowse.bkl,../../demos/forty/forty.bkl,../../demos/fractal/fractal.bkl,../../demos/life/life.bkl,../../demos/poem/poem.bkl,../../samples/access/access.bkl,../../samples/animate/anitest.bkl,../../samples/artprov/artprov.bkl,../../samples/aui/auidemo.bkl,../../samples/calendar/calendar.bkl,../../samples/caret/caret.bkl,../../samples/checklst/checklst.bkl,../../samples/collpane/collpane.bkl,../../samples/combo/combo.bkl,../../samples/config/config.bkl,../../samples/console/console.bkl,../../samples/controls/controls.bkl,../../samples/dataview/dataview.bkl,../../samples/db/db.bkl,../../samples/debugrpt/debugrpt.bkl,../../samples/dialogs/dialogs.bkl,../../samples/dialup/dialup.bkl,../../samples/display/display.bkl,../../samples/dnd/dnd.bkl,../../samples/docview/docview.bkl,../../samples/docvwmdi/docvwmdi.bkl,../../samples/dragimag/dragimag.bkl,../../samples/drawing/drawing.bkl,../../samples/dynamic/dynamic.bkl,../../samples/erase/erase.bkl,../../samples/event/event.bkl,../../samples/except/except.bkl,../../samples/exec/exec.bkl,../../samples/font/font.bkl,../../samples/grid/grid.bkl,../../samples/help/help.bkl,../../samples/htlbox/htlbox.bkl,../../samples/html/about/about.bkl,../../samples/html/help/help.bkl,../../samples/html/helpview/helpview.bkl,../../samples/html/htmlctrl/htmlctrl.bkl,../../samples/html/printing/printing.bkl,../../samples/html/test/test.bkl,../../samples/html/virtual/virtual.bkl,../../samples/html/widget/widget.bkl,../../samples/html/zip/zip.bkl,../../samples/image/image.bkl,../../samples/internat/internat.bkl,../../samples/ipc/ipc.bkl,../../samples/joytest/joytest.bkl,../../samples/keyboard/keyboard.bkl,../../samples/layout/layout.bkl,../../samples/listbox/listbox.bkl,../../samples/listctrl/listctrl.bkl,../../samples/mdi/mdi.bkl,../../samples/mediaplayer/mediaplayer.bkl,../../samples/memcheck/memcheck.bkl,../../samples/menu/menu.bkl,../../samples/mfc/mfc.bkl,../../samples/minifram/minifram.bkl,../../samples/minimal/minimal.bkl,../../samples/mobile/styles/styles.bkl,../../samples/mobile/wxedit/wxedit.bkl,../../samples/multimon/multimon.bkl,../../samples/nativdlg/nativdlg.bkl,../../samples/notebook/notebook.bkl,../../samples/oleauto/oleauto.bkl,../../samples/opengl/cube/cube.bkl,../../samples/opengl/isosurf/isosurf.bkl,../../samples/opengl/penguin/penguin.bkl,../../samples/ownerdrw/ownerdrw.bkl,../../samples/png/png.bkl,../../samples/popup/popup.bkl,../../samples/power/power.bkl,../../samples/printing/printing.bkl,../../samples/propsize/propsize.bkl,../../samples/regtest/regtest.bkl,../../samples/render/render.bkl,../../samples/richtext/richtext.bkl,../../samples/rotate/rotate.bkl,../../samples/sashtest/sashtest.bkl,../../samples/scroll/scroll.bkl,../../samples/scrollsub/scrollsub.bkl,../../samples/shaped/shaped.bkl,../../samples/sockets/sockets.bkl,../../samples/sound/sound.bkl,../../samples/splash/splash.bkl,../../samples/splitter/splitter.bkl,../../samples/statbar/statbar.bkl,../../samples/taskbar/taskbar.bkl,../../samples/text/text.bkl,../../samples/thread/thread.bkl,../../samples/toolbar/toolbar.bkl,../../samples/treectrl/treectrl.bkl,../../samples/typetest/typetest.bkl,../../samples/validate/validate.bkl,../../samples/vscroll/vscroll.bkl,../../samples/widgets/widgets.bkl,../../samples/wizard/wizard.bkl,../../samples/xrc/xrcdemo.bkl,../../tests/test.bkl,../../utils/HelpGen/src/helpgen.bkl,../../utils/emulator/src/emulator.bkl,../../utils/helpview/src/helpview.bkl,../../utils/hhp2cached/hhp2cached.bkl,../../utils/tex2rtf/src/tex2rtf.bkl,../../utils/wxrc/wxrc.bkl,wx.bkl] ###
+    COND_USE_RW_MUTEX_0="#"
+    if test "x$USE_RW_MUTEX" = "x0" ; then
+        COND_USE_RW_MUTEX_0=""
+    fi
+    AC_SUBST(COND_USE_RW_MUTEX_0)
+dnl ### begin block 20_COND_USE_SHARED_MUTEX_0[../../contrib/build/deprecated/deprecated.bkl,../../contrib/build/fl/fl.bkl,../../contrib/build/foldbar/foldbar.bkl,../../contrib/build/gizmos/gizmos.bkl,../../contrib/build/mmedia/mmedia.bkl,../../contrib/build/net/net.bkl,../../contrib/build/ogl/ogl.bkl,../../contrib/build/plot/plot.bkl,../../contrib/build/stc/stc.bkl,../../contrib/build/svg/svg.bkl,../../contrib/samples/deprecated/proplist/proplist.bkl,../../contrib/samples/deprecated/resource/resource.bkl,../../contrib/samples/deprecated/treelay/treelay.bkl,../../contrib/samples/fl/fl.bkl,../../contrib/samples/foldbar/extended/extended.bkl,../../contrib/samples/foldbar/foldpanelbar/foldtest.bkl,../../contrib/samples/gizmos/dynsash/dynsash.bkl,../../contrib/samples/gizmos/dynsash_switch/dynsash_switch.bkl,../../contrib/samples/gizmos/editlbox/editlbox.bkl,../../contrib/samples/gizmos/led/led.bkl,../../contrib/samples/gizmos/multicell/multicell.bkl,../../contrib/samples/gizmos/splittree/splittree.bkl,../../contrib/samples/mmedia/mmboard.bkl,../../contrib/samples/ogl/ogledit/ogledit.bkl,../../contrib/samples/ogl/studio/studio.bkl,../../contrib/samples/plot/plot.bkl,../../contrib/samples/stc/stctest.bkl,../../contrib/samples/svg/svgtest.bkl,../../contrib/utils/convertrc/convertrc.bkl,../../demos/bombs/bombs.bkl,../../demos/dbbrowse/dbbrowse.bkl,../../demos/forty/forty.bkl,../../demos/fractal/fractal.bkl,../../demos/life/life.bkl,../../demos/poem/poem.bkl,../../samples/access/access.bkl,../../samples/animate/anitest.bkl,../../samples/artprov/artprov.bkl,../../samples/aui/auidemo.bkl,../../samples/calendar/calendar.bkl,../../samples/caret/caret.bkl,../../samples/checklst/checklst.bkl,../../samples/collpane/collpane.bkl,../../samples/combo/combo.bkl,../../samples/config/config.bkl,../../samples/console/console.bkl,../../samples/controls/controls.bkl,../../samples/dataview/dataview.bkl,../../samples/db/db.bkl,../../samples/debugrpt/debugrpt.bkl,../../samples/dialogs/dialogs.bkl,../../samples/dialup/dialup.bkl,../../samples/display/display.bkl,../../samples/dnd/dnd.bkl,../../samples/docview/docview.bkl,../../samples/docvwmdi/docvwmdi.bkl,../../samples/dragimag/dragimag.bkl,../../samples/drawing/drawing.bkl,../../samples/dynamic/dynamic.bkl,../../samples/erase/erase.bkl,../../samples/event/event.bkl,../../samples/except/except.bkl,../../samples/exec/exec.bkl,../../samples/font/font.bkl,../../samples/grid/grid.bkl,../../samples/help/help.bkl,../../samples/htlbox/htlbox.bkl,../../samples/html/about/about.bkl,../../samples/html/help/help.bkl,../../samples/html/helpview/helpview.bkl,../../samples/html/htmlctrl/htmlctrl.bkl,../../samples/html/printing/printing.bkl,../../samples/html/test/test.bkl,../../samples/html/virtual/virtual.bkl,../../samples/html/widget/widget.bkl,../../samples/html/zip/zip.bkl,../../samples/image/image.bkl,../../samples/internat/internat.bkl,../../samples/ipc/ipc.bkl,../../samples/joytest/joytest.bkl,../../samples/keyboard/keyboard.bkl,../../samples/layout/layout.bkl,../../samples/listbox/listbox.bkl,../../samples/listctrl/listctrl.bkl,../../samples/mdi/mdi.bkl,../../samples/mediaplayer/mediaplayer.bkl,../../samples/memcheck/memcheck.bkl,../../samples/menu/menu.bkl,../../samples/mfc/mfc.bkl,../../samples/minifram/minifram.bkl,../../samples/minimal/minimal.bkl,../../samples/mobile/styles/styles.bkl,../../samples/mobile/wxedit/wxedit.bkl,../../samples/multimon/multimon.bkl,../../samples/nativdlg/nativdlg.bkl,../../samples/notebook/notebook.bkl,../../samples/oleauto/oleauto.bkl,../../samples/opengl/cube/cube.bkl,../../samples/opengl/isosurf/isosurf.bkl,../../samples/opengl/penguin/penguin.bkl,../../samples/ownerdrw/ownerdrw.bkl,../../samples/png/png.bkl,../../samples/popup/popup.bkl,../../samples/power/power.bkl,../../samples/printing/printing.bkl,../../samples/propsize/propsize.bkl,../../samples/regtest/regtest.bkl,../../samples/render/render.bkl,../../samples/richtext/richtext.bkl,../../samples/rotate/rotate.bkl,../../samples/sashtest/sashtest.bkl,../../samples/scroll/scroll.bkl,../../samples/scrollsub/scrollsub.bkl,../../samples/shaped/shaped.bkl,../../samples/sockets/sockets.bkl,../../samples/sound/sound.bkl,../../samples/splash/splash.bkl,../../samples/splitter/splitter.bkl,../../samples/statbar/statbar.bkl,../../samples/taskbar/taskbar.bkl,../../samples/text/text.bkl,../../samples/thread/thread.bkl,../../samples/toolbar/toolbar.bkl,../../samples/treectrl/treectrl.bkl,../../samples/typetest/typetest.bkl,../../samples/validate/validate.bkl,../../samples/vscroll/vscroll.bkl,../../samples/widgets/widgets.bkl,../../samples/wizard/wizard.bkl,../../samples/xrc/xrcdemo.bkl,../../tests/test.bkl,../../utils/HelpGen/src/helpgen.bkl,../../utils/emulator/src/emulator.bkl,../../utils/helpview/src/helpview.bkl,../../utils/hhp2cached/hhp2cached.bkl,../../utils/tex2rtf/src/tex2rtf.bkl,../../utils/wxrc/wxrc.bkl,wx.bkl] ###
+    COND_USE_SHARED_MUTEX_0="#"
+    if test "x$USE_SHARED_MUTEX" = "x0" ; then
+        COND_USE_SHARED_MUTEX_0=""
+    fi
+    AC_SUBST(COND_USE_SHARED_MUTEX_0)
 dnl ### begin block 20_COND_USE_SOSYMLINKS_1[../../contrib/build/deprecated/deprecated.bkl,../../contrib/build/fl/fl.bkl,../../contrib/build/foldbar/foldbar.bkl,../../contrib/build/gizmos/gizmos.bkl,../../contrib/build/mmedia/mmedia.bkl,../../contrib/build/net/net.bkl,../../contrib/build/ogl/ogl.bkl,../../contrib/build/plot/plot.bkl,../../contrib/build/stc/stc.bkl,../../contrib/build/svg/svg.bkl,wx.bkl] ###
     COND_USE_SOSYMLINKS_1="#"
     if test "x$USE_SOSYMLINKS" = "x1" ; then
Index: wxMotif.spec
===================================================================
--- wxMotif.spec	(revision 52157)
+++ wxMotif.spec	(working copy)
@@ -231,7 +231,6 @@ wx/unix/private.h
 wx/unix/stackwalk.h
 wx/unix/stdpaths.h
 wx/fs_inet.h
-wx/gsocket.h
 wx/protocol/file.h
 wx/protocol/ftp.h
 wx/protocol/http.h
@@ -241,7 +240,6 @@ wx/sckipc.h
 wx/sckstrm.h
 wx/socket.h
 wx/url.h
-wx/unix/gsockunx.h
 wx/xml/xml.h
 wx/xtixml.h
 wx/db.h
Index: src/mac/carbon/thread.cpp
===================================================================
--- src/mac/carbon/thread.cpp	(revision 52157)
+++ src/mac/carbon/thread.cpp	(working copy)
@@ -138,8 +138,8 @@ void wxCriticalSection::Leave()
 
 #if TARGET_API_MAC_OSX
 #define wxUSE_MAC_SEMAPHORE_MUTEX 0
-#define wxUSE_MAC_CRITICAL_REGION_MUTEX 1
-#define wxUSE_MAC_PTHREADS_MUTEX 0
+#define wxUSE_MAC_CRITICAL_REGION_MUTEX 0
+#define wxUSE_MAC_PTHREADS_MUTEX 1
 #else
 #define wxUSE_MAC_SEMAPHORE_MUTEX 0
 #define wxUSE_MAC_CRITICAL_REGION_MUTEX 1
@@ -194,7 +194,7 @@ wxMutexInternal::wxMutexInternal( wxMute
                 pthread_mutexattr_t attr;
                 pthread_mutexattr_init( &attr );
                 pthread_mutexattr_settype( &attr, PTHREAD_MUTEX_RECURSIVE );
-
+				pthread_mutexattr_setpshared( &attr, PTHREAD_PROCESS_PRIVATE );
                 err = pthread_mutex_init( &m_mutex, &attr );
             }
 #elif defined(HAVE_PTHREAD_RECURSIVE_MUTEX_INITIALIZER)
@@ -210,6 +210,48 @@ wxMutexInternal::wxMutexInternal( wxMute
 #endif // HAVE_PTHREAD_MUTEXATTR_T/...
             break;
 
+			
+			
+#if wxUSE_SHARED_MUTEX
+		case wxMUTEX_SHARED:
+#	ifdef HAVE_PTHREAD_MUTEXATTR_T
+			{
+				pthread_mutexattr_t attr;
+				pthread_mutexattr_init( &attr );
+				pthread_mutexattr_settype( &attr, PTHREAD_MUTEX_ERRORCHECK );
+				pthread_mutexattr_setpshared( &attr, PTHREAD_PROCESS_SHARED );
+				err = pthread_mutex_init( &m_mutex, &attr );
+			}
+#	else // don't know how to implement shared mutexes
+#error FIXME:  Don't know how to implement shared mutexes
+            err = EINVAL;
+#	endif // HAVE_PTHREAD_MUTEXATTR_T/...			
+			break;
+			
+			
+			
+		case wxMUTEX_SHARED_RECURSIVE:
+            // support recursive locks like Win32, i.e. a thread can lock a
+            // mutex which it had itself already locked
+            //
+            // unfortunately initialization of recursive mutexes is non
+            // portable, so try several methods
+#	ifdef HAVE_PTHREAD_MUTEXATTR_T
+			{
+				pthread_mutexattr_t attr;
+				pthread_mutexattr_init( &attr );
+				pthread_mutexattr_settype( &attr, PTHREAD_MUTEX_RECURSIVE );
+				pthread_mutexattr_setpshared( &attr, PTHREAD_PROCESS_SHARED );
+				err = pthread_mutex_init( &m_mutex, &attr );
+			}
+#	else // don't know how to implement shared mutexes
+#error FIXME:  Don't know how to implement shared mutexes
+            err = EINVAL;
+#	endif // HAVE_PTHREAD_MUTEXATTR_T/...
+			break;
+#endif
+			
+	
         default:
             wxFAIL_MSG( wxT("unknown mutex type") );
             // fall through
@@ -309,6 +351,214 @@ wxMutexError wxMutexInternal::Unlock()
     return wxMUTEX_MISC_ERROR;
 }
 
+
+#if wxUSE_RW_MUTEX
+
+class wxReadWriteMutexInternal
+{
+public:
+	wxReadWriteMutexInternal( wxMutexType mutexType );
+	~wxReadWriteMutexInternal();
+	
+	wxMutexError ReadLock();
+	wxMutexError TryReadLock();
+	
+	wxMutexError WriteLock();
+    wxMutexError TryWriteLock();
+	
+	wxMutexError Unlock();
+	
+	bool IsOk() const
+	{ return m_isOk; }
+	
+private:
+	pthread_rwlock_t m_mutex;
+	bool m_isOk;	
+};
+
+
+wxReadWriteMutexInternal::wxReadWriteMutexInternal( wxMutexType mutexType )
+{
+    int err;
+    switch ( mutexType )
+    {
+        case wxMUTEX_RECURSIVE:
+		case wxMUTEX_SHARED_RECURSIVE:
+			// No recursive mutexes.
+			err = EINVAL;
+			break;
+			
+#if wxUSE_SHARED_MUTEX
+		case wxMUTEX_SHARED:
+            // support recursive locks like Win32, i.e. a thread can lock a
+            // mutex which it had itself already locked
+            //
+            // unfortunately initialization of recursive mutexes is non
+            // portable, so try several methods
+#ifdef HAVE_PTHREAD_MUTEXATTR_T
+		{
+			pthread_rwlockattr_t attr;
+			pthread_rwlockattr_init( &attr );
+			pthread_rwlockattr_setpshared( &attr, PTHREAD_PROCESS_SHARED );
+			
+			err = pthread_rwlock_init( &m_mutex, &attr );
+		}
+#else // don't know how to implement shared mutexes
+            err = EINVAL;
+#endif // HAVE_PTHREAD_MUTEXATTR_T/...
+            break;
+			
+#endif // wxUSE_SHARED_MUTEX
+			
+        default:
+            wxFAIL_MSG( wxT("unknown mutex type") );
+            // fall through
+			
+        case wxMUTEX_DEFAULT:
+            err = pthread_rwlock_init( &m_mutex, NULL );
+            break;
+    }
+	
+    m_isOk = err == 0;
+    if ( !m_isOk )
+    {
+        wxLogApiError( wxT("pthread_mutex_init()"), err );
+    }
+}
+
+wxReadWriteMutexInternal::~wxReadWriteMutexInternal()
+{
+    if ( m_isOk )
+    {
+        int err = pthread_rwlock_destroy( &m_mutex );
+        if ( err != 0 )
+        {
+            wxLogApiError( wxT("pthread_mutex_destroy()"), err );
+        }
+    }
+}
+
+wxMutexError wxReadWriteMutexInternal::ReadLock()
+{
+    int err = pthread_rwlock_rdlock( &m_mutex );
+    switch ( err )
+    {
+        case EDEADLK:
+            // only error checking mutexes return this value and so it's an
+            // unexpected situation -- hence use assert, not wxLogDebug
+            wxFAIL_MSG( wxT("mutex deadlock prevented") );
+            return wxMUTEX_DEAD_LOCK;
+			
+        case EINVAL:
+            wxLogDebug( wxT("pthread_mutex_lock(): mutex not initialized.") );
+            break;
+			
+        case 0:
+            return wxMUTEX_NO_ERROR;
+			
+        default:
+            wxLogApiError( wxT("pthread_mutex_lock()"), err );
+    }
+	
+    return wxMUTEX_MISC_ERROR;
+}
+
+wxMutexError wxReadWriteMutexInternal::TryReadLock()
+{
+    int err = pthread_rwlock_tryrdlock( &m_mutex );
+    switch ( err )
+    {
+        case EBUSY:
+            // not an error: mutex is already locked, but we're prepared for this case
+            return wxMUTEX_BUSY;
+			
+        case EINVAL:
+            wxLogDebug( wxT("pthread_mutex_trylock(): mutex not initialized.") );
+            break;
+			
+        case 0:
+            return wxMUTEX_NO_ERROR;
+			
+        default:
+            wxLogApiError( wxT("pthread_mutex_trylock()"), err );
+    }
+	
+    return wxMUTEX_MISC_ERROR;
+}
+
+wxMutexError wxReadWriteMutexInternal::WriteLock()
+{
+    int err = pthread_rwlock_rdlock( &m_mutex );
+    switch ( err )
+    {
+        case EDEADLK:
+            // only error checking mutexes return this value and so it's an
+            // unexpected situation -- hence use assert, not wxLogDebug
+            wxFAIL_MSG( wxT("mutex deadlock prevented") );
+            return wxMUTEX_DEAD_LOCK;
+			
+        case EINVAL:
+            wxLogDebug( wxT("pthread_mutex_lock(): mutex not initialized.") );
+            break;
+			
+        case 0:
+            return wxMUTEX_NO_ERROR;
+			
+        default:
+            wxLogApiError( wxT("pthread_mutex_lock()"), err );
+    }
+	
+    return wxMUTEX_MISC_ERROR;
+}
+
+wxMutexError wxReadWriteMutexInternal::TryWriteLock()
+{
+    int err = pthread_rwlock_tryrdlock( &m_mutex );
+    switch ( err )
+    {
+        case EBUSY:
+            // not an error: mutex is already locked, but we're prepared for this case
+            return wxMUTEX_BUSY;
+			
+        case EINVAL:
+            wxLogDebug( wxT("pthread_mutex_trylock(): mutex not initialized.") );
+            break;
+			
+        case 0:
+            return wxMUTEX_NO_ERROR;
+			
+        default:
+            wxLogApiError( wxT("pthread_mutex_trylock()"), err );
+    }
+	
+    return wxMUTEX_MISC_ERROR;
+}
+
+wxMutexError wxReadWriteMutexInternal::Unlock()
+{
+    int err = pthread_rwlock_unlock( &m_mutex );
+    switch ( err )
+    {
+        case EPERM:
+            // we don't own the mutex
+            return wxMUTEX_UNLOCKED;
+			
+        case EINVAL:
+            wxLogDebug( wxT("pthread_mutex_unlock(): mutex not initialized.") );
+            break;
+			
+        case 0:
+            return wxMUTEX_NO_ERROR;
+			
+        default:
+            wxLogApiError( wxT("pthread_mutex_unlock()"), err );
+    }
+	
+    return wxMUTEX_MISC_ERROR;
+}
+#endif // wxUSE_RW_MUTEX
+
+
 #endif
 
 #if wxUSE_MAC_SEMAPHORE_MUTEX
@@ -1589,6 +1839,13 @@ unsigned long wxThread::GetId() const
     return (unsigned long)m_internal->GetId();
 }
 
+
+wxThreadIdType wxThread::GetMainThreadId()
+{
+	return gs_idMainThread;
+}
+
+
 // -----------------------------------------------------------------------------
 // state tests
 // -----------------------------------------------------------------------------

Property changes on: src/wxWindows.xcodeproj
___________________________________________________________________
Modified: svn:ignore
   - *.pbxuser

   + *.pbxuser
*.perspectivev3


Index: src/wxWindows.xcodeproj/project.pbxproj
===================================================================
--- src/wxWindows.xcodeproj/project.pbxproj	(revision 52157)
+++ src/wxWindows.xcodeproj/project.pbxproj	(working copy)
@@ -100,9 +100,7 @@
 		405DD168063C2BFC00F579EE /* libiconv.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 405DD167063C2BFC00F579EE /* libiconv.dylib */; };
 		40607C1607493C3F00DC0420 /* archive.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 40607C1407493C3F00DC0420 /* archive.cpp */; };
 		40607C1A07493C3F00DC0420 /* archive.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 40607C1407493C3F00DC0420 /* archive.cpp */; };
-		40607C760749432A00DC0420 /* gsockosx.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 40607C740749432A00DC0420 /* gsockosx.cpp */; };
 		40607C770749432A00DC0420 /* utilsexc_cf.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 40607C750749432A00DC0420 /* utilsexc_cf.cpp */; };
-		40607C7A0749432A00DC0420 /* gsockosx.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 40607C740749432A00DC0420 /* gsockosx.cpp */; };
 		40607C7B0749432B00DC0420 /* utilsexc_cf.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 40607C750749432A00DC0420 /* utilsexc_cf.cpp */; };
 		40670A8407377A6400F7C08C /* cfstring.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 40670A8207377A6300F7C08C /* cfstring.cpp */; };
 		40670A8507377A6400F7C08C /* stdpaths_cf.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 40670A8307377A6300F7C08C /* stdpaths_cf.cpp */; };
@@ -1089,8 +1087,6 @@
 		40CDE8D40982505E00E8156D /* evtloopcmn.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 40CDE8D00982505E00E8156D /* evtloopcmn.cpp */; };
 		40CDE8DA098250AB00E8156D /* evtloop.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 40CDE8D9098250AB00E8156D /* evtloop.cpp */; };
 		40CDE8DB098250AB00E8156D /* evtloop.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 40CDE8D9098250AB00E8156D /* evtloop.cpp */; };
-		40DCE35006C744C90000D83E /* gsocket.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 40DCE34F06C744C90000D83E /* gsocket.cpp */; };
-		40DCE35206C744C90000D83E /* gsocket.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 40DCE34F06C744C90000D83E /* gsocket.cpp */; };
 		40ECB13A074BD1D0005AAC48 /* stdpaths.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 40ECB139074BD1D0005AAC48 /* stdpaths.cpp */; };
 		40ECB13C074BD1D0005AAC48 /* stdpaths.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 40ECB139074BD1D0005AAC48 /* stdpaths.cpp */; };
 		40F0173A0A30684000AC9076 /* colourcmn.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 40F017380A30683F00AC9076 /* colourcmn.cpp */; };
@@ -1348,6 +1344,7 @@
 		61048A700B277DE5009C253D /* print.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = print.h; path = private/print.h; sourceTree = "<group>"; };
 		61048AE10B278C9A009C253D /* srchctrl.h */ = {isa = PBXFileReference; fileEncoding = 30; indentWidth = 4; lastKnownFileType = sourcecode.c.h; path = srchctrl.h; sourceTree = "<group>"; tabWidth = 4; usesTabs = 0; };
 		61048BE80B27B7D0009C253D /* srchctlg.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = srchctlg.cpp; sourceTree = "<group>"; };
+		A47AF7F60E2534190080D9AA /* apptrait.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = apptrait.h; sourceTree = "<group>"; };
 		CA0CB57B0450773900000102 /* accesscmn.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = accesscmn.cpp; sourceTree = "<group>"; };
 		CA0CB57C0450773900000102 /* datacmn.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = datacmn.cpp; sourceTree = "<group>"; };
 		CA0CB57D0450773900000102 /* dpycmn.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = dpycmn.cpp; sourceTree = "<group>"; };
@@ -2319,6 +2316,7 @@
 			children = (
 				F5A85C1E01FA022A0175ACA7 /* accel.h */,
 				F5A85C1F01FA022A0175ACA7 /* app.h */,
+				A47AF7F60E2534190080D9AA /* apptrait.h */,
 				F5A85C2001FA022A0175ACA7 /* arrimpl.cpp */,
 				F5CC83D90379C17C01000133 /* artprov.h */,
 				F5A85C2101FA022A0175ACA7 /* bitmap.h */,
@@ -3354,10 +3352,12 @@
 		0867D690FE84028FC02AAC07 /* Project object */ = {
 			isa = PBXProject;
 			buildConfigurationList = 18B5B99E08564B5D002803C9 /* Build configuration list for PBXProject "wxWindows" */;
+			compatibilityVersion = "Xcode 2.4";
 			hasScannedForEncodings = 1;
 			mainGroup = 0867D691FE84028FC02AAC07 /* wxWindows */;
 			productRefGroup = 034768DDFF38A45A11DB9C8B /* Products */;
 			projectDirPath = "";
+			projectRoot = ..;
 			targets = (
 				4086C742063AB2FF00D4CD53 /* static */,
 				4086CA55063AB30000D4CD53 /* dynamic */,
@@ -3788,7 +3788,6 @@
 				407A90FA065742ED00F01665 /* spinctrl.cpp in Sources */,
 				40F10E5806AD0230003C7AC3 /* tglbtn.cpp in Sources */,
 				40F10E5906AD0230003C7AC3 /* thread.cpp in Sources */,
-				40DCE35006C744C90000D83E /* gsocket.cpp in Sources */,
 				0A98CB6B07146A06007B4289 /* statbar.cpp in Sources */,
 				0A98CC480715CFBC007B4289 /* gdiobj.cpp in Sources */,
 				0A98CC4C0715D03E007B4289 /* taskbarcmn.cpp in Sources */,
@@ -3799,7 +3798,6 @@
 				40670A9907377B1000F7C08C /* stdpbase.cpp in Sources */,
 				40670A9A07377B1000F7C08C /* uri.cpp in Sources */,
 				40607C1607493C3F00DC0420 /* archive.cpp in Sources */,
-				40607C760749432A00DC0420 /* gsockosx.cpp in Sources */,
 				40607C770749432A00DC0420 /* utilsexc_cf.cpp in Sources */,
 				40ECB13A074BD1D0005AAC48 /* stdpaths.cpp in Sources */,
 				40AF909107C8A926006A6D3C /* mediactrlcmn.cpp in Sources */,
@@ -4334,7 +4332,6 @@
 				407A90F7065742ED00F01665 /* spinctrl.cpp in Sources */,
 				40F10E5C06AD0230003C7AC3 /* tglbtn.cpp in Sources */,
 				40F10E5D06AD0230003C7AC3 /* thread.cpp in Sources */,
-				40DCE35206C744C90000D83E /* gsocket.cpp in Sources */,
 				0A98CB6D07146A06007B4289 /* statbar.cpp in Sources */,
 				0A98CC4A0715CFBC007B4289 /* gdiobj.cpp in Sources */,
 				0A98CC4E0715D04C007B4289 /* taskbarcmn.cpp in Sources */,
@@ -4345,7 +4342,6 @@
 				40670AA107377B1000F7C08C /* stdpbase.cpp in Sources */,
 				40670AA207377B1000F7C08C /* uri.cpp in Sources */,
 				40607C1A07493C3F00DC0420 /* archive.cpp in Sources */,
-				40607C7A0749432A00DC0420 /* gsockosx.cpp in Sources */,
 				40607C7B0749432B00DC0420 /* utilsexc_cf.cpp in Sources */,
 				40ECB13C074BD1D0005AAC48 /* stdpaths.cpp in Sources */,
 				40AF909307C8A926006A6D3C /* mediactrlcmn.cpp in Sources */,
@@ -4753,6 +4749,11 @@
 				GCC_OPTIMIZATION_LEVEL = 1;
 				GCC_PREPROCESSOR_DEFINITIONS = "__WXDEBUG__\n";
 				GCC_WARN_ABOUT_DEPRECATED_FUNCTIONS = NO;
+				GCC_WARN_HIDDEN_VIRTUAL_FUNCTIONS = YES;
+				HEADER_SEARCH_PATHS = (
+					"$(SRCROOT)/../misc/boost/boost_1_35_0/",
+					"$(SRCROOT)/../misc/boost/asio-1.0.0/include",
+				);
 				PRODUCT_NAME = wx_mac;
 				SDKROOT = /Developer/SDKs/MacOSX10.4u.sdk;
 				ZERO_LINK = YES;
@@ -4767,6 +4768,10 @@
 					i386,
 				);
 				GCC_WARN_ABOUT_DEPRECATED_FUNCTIONS = NO;
+				HEADER_SEARCH_PATHS = (
+					"$(SRCROOT)/../misc/boost/boost_1_35_0/",
+					"$(SRCROOT)/../misc/boost/asio-1.0.0/include",
+				);
 				PRODUCT_NAME = wx_mac;
 				SDKROOT = /Developer/SDKs/MacOSX10.4u.sdk;
 				ZERO_LINK = NO;
Index: src/regex/regc_locale.c
===================================================================
--- src/regex/regc_locale.c	(revision 52157)
+++ src/regex/regc_locale.c	(working copy)
@@ -16,7 +16,9 @@
  *  for wxWidgets are under the wxWidgets licence, see README for details.
  */
 
+#ifndef CONST
 #define CONST const
+#endif
 
 /* ASCII character-name table */
 
Index: src/common/protocol.cpp
===================================================================
--- src/common/protocol.cpp	(revision 52157)
+++ src/common/protocol.cpp	(working copy)
@@ -73,7 +73,7 @@ wxProtocol::wxProtocol()
 #if wxUSE_SOCKETS
 bool wxProtocol::Reconnect()
 {
-    wxIPV4address addr;
+    wxTCPIPendpoint addr;
 
     if (!GetPeer(addr))
     {
Index: src/common/sckipc.cpp
===================================================================
--- src/common/sckipc.cpp	(revision 52157)
+++ src/common/sckipc.cpp	(working copy)
@@ -82,7 +82,7 @@ enum
 // ----------------------------------------------------------------------------
 
 // get the address object for the given server name, the caller must delete it
-static wxSockAddress *
+static wxTCPIPendpoint *
 GetAddressFromName(const wxString& serverName, const wxString& host = wxEmptyString)
 {
     // we always use INET sockets under non-Unix systems
@@ -98,7 +98,7 @@ GetAddressFromName(const wxString& serve
     }
 #endif // Unix/!Unix
     {
-        wxIPV4address *addr = new wxIPV4address;
+        wxTCPIPendpoint *addr = new wxTCPIPendpoint;
         addr->Service(serverName);
         if ( !host.empty() )
         {
@@ -155,7 +155,7 @@ wxTCPClient::~wxTCPClient ()
 
 bool wxTCPClient::ValidHost(const wxString& host)
 {
-  wxIPV4address addr;
+	wxTCPIPendpoint addr;
 
   return addr.Hostname(host);
 }
@@ -164,7 +164,7 @@ wxConnectionBase *wxTCPClient::MakeConne
                                                const wxString& serverName,
                                                const wxString& topic)
 {
-  wxSockAddress *addr = GetAddressFromName(serverName, host);
+  wxTCPIPendpoint *addr = GetAddressFromName(serverName, host);
   if ( !addr )
       return NULL;
 
@@ -248,7 +248,7 @@ bool wxTCPServer::Create(const wxString&
     m_server = NULL;
   }
 
-  wxSockAddress *addr = GetAddressFromName(serverName);
+  wxTCPIPendpoint *addr = GetAddressFromName(serverName);
   if ( !addr )
       return false;
 
Index: src/common/event.cpp
===================================================================
--- src/common/event.cpp	(revision 52157)
+++ src/common/event.cpp	(working copy)
@@ -158,6 +158,8 @@ const wxEventType wxEVT_USER_FIRST = wxE
 DEFINE_EVENT_TYPE(wxEVT_NULL)
 DEFINE_EVENT_TYPE(wxEVT_IDLE)
 DEFINE_EVENT_TYPE(wxEVT_SOCKET)
+DEFINE_EVENT_TYPE(wxEVT_SOCKET_RESOLVE)
+DEFINE_EVENT_TYPE(wxEVT_SOCKET_WAIT)
 
 #endif // !WXWIN_COMPATIBILITY_EVENT_TYPES
 
Index: src/common/socket.cpp
===================================================================
--- src/common/socket.cpp	(revision 52157)
+++ src/common/socket.cpp	(working copy)
@@ -10,19 +10,23 @@
 /////////////////////////////////////////////////////////////////////////////
 
 // ==========================================================================
+#pragma mark - Declarations
 // Declarations
 // ==========================================================================
 
 // For compilers that support precompilation, includes "wx.h".
 #include "wx/wxprec.h"
 
+#include "wx/setup.h" // for wxUSE_GUI
+
 #ifdef __BORLANDC__
     #pragma hdrstop
 #endif
 
-#if wxUSE_SOCKETS
 
-#include "wx/socket.h"
+
+#include <boost/bind.hpp>
+
 
 #ifndef WX_PRECOMP
     #include "wx/object.h"
@@ -38,14 +42,25 @@
 
 #include "wx/apptrait.h"
 
+#if wxUSE_GUI
+	#include "wx/evtloop.h"
+#endif
+
+#include "wx/socket.h"
 #include "wx/sckaddr.h"
+
 #include "wx/datetime.h"
 
+#if wxUSE_SOCKETS
+
+using namespace asio;
+
 // DLL options compatibility check:
 #include "wx/build.h"
 WX_CHECK_BUILD_OPTIONS("wxNet")
 
 // --------------------------------------------------------------------------
+#pragma mark - Macros and Constants
 // macros and constants
 // --------------------------------------------------------------------------
 
@@ -74,16 +89,20 @@ WX_CHECK_BUILD_OPTIONS("wxNet")
 #define wxTRACE_Socket _T("wxSocket")
 
 // --------------------------------------------------------------------------
+#pragma mark - wxWin macros
 // wxWin macros
 // --------------------------------------------------------------------------
 
 IMPLEMENT_CLASS(wxSocketBase, wxObject)
-IMPLEMENT_CLASS(wxSocketServer, wxSocketBase)
-IMPLEMENT_CLASS(wxSocketClient, wxSocketBase)
+IMPLEMENT_CLASS(wxSocket, wxSocketBase)
+IMPLEMENT_CLASS(wxSocketServer, wxSocket)
+IMPLEMENT_CLASS(wxSocketClient, wxSocket)
 IMPLEMENT_CLASS(wxDatagramSocket, wxSocketBase)
 IMPLEMENT_DYNAMIC_CLASS(wxSocketEvent, wxEvent)
+IMPLEMENT_DYNAMIC_CLASS(wxSocketWaitEvent, wxEvent)
 
 // --------------------------------------------------------------------------
+#pragma mark - Private classes
 // private classes
 // --------------------------------------------------------------------------
 
@@ -101,80 +120,348 @@ public:
   DECLARE_NO_COPY_CLASS(wxSocketState)
 };
 
+
+
+class WXDLLIMPEXP_CORE wxNullEvent : public wxEvent
+{
+public:
+    wxNullEvent()
+	: wxEvent(0, wxEVT_NULL)
+	{ }
+    wxNullEvent(const wxNullEvent & event)
+	: wxEvent(event)
+    { }
+	
+    virtual wxEvent *Clone() const { return new wxNullEvent(*this); }
+		
+private:
+    DECLARE_DYNAMIC_CLASS_NO_ASSIGN(wxNullEvent)
+};
+
+
+IMPLEMENT_DYNAMIC_CLASS(wxNullEvent, wxEvent)
+
+
+class wxSocketIdleHelper : public wxEvtHandler
+{
+public:
+	wxSocketIdleHelper()
+	: m_bShutdown( false )
+	{
+		wxASSERT( ms_pInstance == NULL );
+		ms_pInstance = this;
+		
+		wxNullEvent event;
+		AddPendingEvent(event);
+	}
+	
+	~wxSocketIdleHelper()
+	{
+		wxASSERT( ms_pInstance == this );
+		ms_pInstance = NULL;
+	}
+	
+	virtual bool ProcessEvent(wxEvent& event)
+	{
+		if ( !m_bShutdown )
+		{
+			wxSocketBase::DoIdle();
+//			AddPendingEvent(event);
+		}
+		
+		return true;
+	}
+	
+	static wxSocketIdleHelper * ms_pInstance;
+	bool m_bShutdown;
+};
+
+
+wxSocketIdleHelper * wxSocketIdleHelper::ms_pInstance = NULL;
+
+
 // ==========================================================================
-// wxSocketBase
+#pragma mark - wxSocketServiceHandler
+// wxSocketServiceHandler
 // ==========================================================================
 
-// --------------------------------------------------------------------------
-// Initialization and shutdown
-// --------------------------------------------------------------------------
+wxMutex wxSocketServiceHandler::ms_ActiveServicesMutex( wxMUTEX_RECURSIVE );
+std::map<wxThreadIdType, wxSocketServiceHandler::wxIOServiceHelper *>	wxSocketServiceHandler::ms_ActiveServices;
+
+size_t wxSocketServiceHandler::Run(asio::error_code &ec)
+{
+	wxASSERT( ServiceExistsForThread() );
 
-// FIXME-MT: all this is MT-unsafe, of course, we should protect all accesses
-//           to m_countInit with a crit section
-size_t wxSocketBase::m_countInit = 0;
+	wxIOServiceHelper *	pHelper		= GetServiceHelperForThread();
+	io_service &		rService	= pHelper->GetService();
 
-bool wxSocketBase::IsInitialized()
+	size_t output = 0;
+	
+	{
+		wxReadMutexLocker shared_run_lock( pHelper->m_ResetMutex );
+		output = rService.run( ec );
+	}
+	
+	if ( output == 0 )
+	{
+		wxWriteMutexLocker reset_lock( pHelper->m_ResetMutex );
+		
+		rService.reset();
+	}
+
+	return output;
+}
+
+
+
+size_t wxSocketServiceHandler::RunOne(asio::error_code &ec)
 {
-    return m_countInit > 0;
+	wxASSERT( ServiceExistsForThread() );
+	
+	wxIOServiceHelper *	pHelper		= GetServiceHelperForThread();
+	io_service &		rService	= pHelper->GetService();
+
+	size_t output = 0;
+	
+	{
+		wxReadMutexLocker shared_run_lock( pHelper->m_ResetMutex );
+		output = rService.run_one( ec );
+	}
+	
+	if ( output == 0 )
+	{
+		wxWriteMutexLocker reset_lock( pHelper->m_ResetMutex );
+		
+		rService.reset();
+	}
+	
+	return output;	
 }
 
-bool wxSocketBase::Initialize()
+
+size_t wxSocketServiceHandler::Poll(asio::error_code &ec)
 {
-    if ( !m_countInit++ )
+	wxASSERT( ServiceExistsForThread() );
+	
+	wxIOServiceHelper *	pHelper		= GetServiceHelperForThread();
+	io_service &		rService	= pHelper->GetService();
+
+	size_t output = 0;
+	
     {
-        /*
-            Details: Initialize() creates a hidden window as a sink for socket
-            events, such as 'read completed'. wxMSW has only one message loop
-            for the main thread. If Initialize is called in a secondary thread,
-            the socket window will be created for the secondary thread, but
-            since there is no message loop on this thread, it will never
-            receive events and all socket operations will time out.
-            BTW, the main thread must not be stopped using sleep or block
-            on a semaphore (a bad idea in any case) or socket operations
-            will time out.
-
-            On the Mac side, Initialize() stores a pointer to the CFRunLoop for
-            the main thread. Because secondary threads do not have run loops,
-            adding event notifications to the "Current" loop would have no
-            effect at all, events would never fire.
-        */
-        wxASSERT_MSG( wxIsMainThread(),
-            wxT("Call wxSocketBase::Initialize() from the main thread first!"));
-
-        wxAppTraits *traits = wxAppConsole::GetInstance() ?
-                              wxAppConsole::GetInstance()->GetTraits() : NULL;
-        GSocketGUIFunctionsTable *functions =
-            traits ? traits->GetSocketGUIFunctionsTable() : NULL;
-        GSocket_SetGUIFunctions(functions);
+		wxReadMutexLocker shared_run_lock( pHelper->m_ResetMutex );
+		output = rService.poll( ec );
+	}
 
-        if ( !GSocket_Init() )
+	if ( output == 0 )
         {
-            m_countInit--;
+		wxWriteMutexLocker reset_lock( pHelper->m_ResetMutex );
 
-            return false;
+		rService.reset();
+	}
+	
+	return output;	
+}
+
+
+size_t wxSocketServiceHandler::PollOne(asio::error_code &ec)
+{
+	wxASSERT( ServiceExistsForThread() );
+	
+	wxIOServiceHelper *	pHelper		= GetServiceHelperForThread();
+	io_service &		rService	= pHelper->GetService();
+
+	size_t output = 0;
+	
+	{
+		wxReadMutexLocker shared_run_lock( pHelper->m_ResetMutex );
+		output = rService.poll_one( ec );
         }
+	
+	if ( output == 0 )
+	{
+		wxWriteMutexLocker reset_lock( pHelper->m_ResetMutex );
+		
+		rService.reset();
     }
 
-    return true;
+	return output;	
 }
 
-void wxSocketBase::Shutdown()
+
+io_service & wxSocketServiceHandler::GetServiceForThread( wxThreadIdType thread )
+{
+	return GetServiceHelperForThread()->GetService();
+}
+
+
+
+wxSocketServiceHandler::wxIOServiceHelper * wxSocketServiceHandler::GetServiceHelperForThread( wxThreadIdType thread )
+{
+	wxMutexLocker pad_lock( ms_ActiveServicesMutex );
+	
+	wxIOServiceHelper * pHelper = ms_ActiveServices[thread];
+	
+	if ( pHelper == NULL )
+	{
+		pHelper = new wxIOServiceHelper;
+		ms_ActiveServices[thread] = pHelper;
+	}
+	
+	return pHelper;
+}
+
+
+
+bool wxSocketServiceHandler::ServiceExistsForThread( wxThreadIdType thread )
+{
+	wxMutexLocker u_bolt( ms_ActiveServicesMutex );
+
+	return ms_ActiveServices.find( thread ) != ms_ActiveServices.end();
+}
+
+
+bool wxSocketServiceHandler::InitThread( wxThreadIdType thread )
+{
+	wxMutexLocker lock( ms_ActiveServicesMutex );
+	
+	wxIOServiceHelper * pHelper = GetServiceHelperForThread();
+	
+    return pHelper->Retain() > 0;
+}
+
+
+
+void wxSocketServiceHandler::ShutdownThread( wxThreadIdType thread )
+{
+	wxMutexLocker head_lock( ms_ActiveServicesMutex );
+
+	wxIOServiceHelper * helper = ms_ActiveServices[thread];
+
+	if ( helper != NULL )
+	{
+		if ( helper->Release() == 0 )
+		{
+			ms_ActiveServices.erase( thread );
+			delete helper;
+			
+			if ( wxSocketIdleHelper::ms_pInstance != NULL )
+				wxSocketIdleHelper::ms_pInstance->m_bShutdown = true;
+		}
+	}
+}
+
+
+
+// ==========================================================================
+#pragma mark - wxSocketServiceHandler::wxIOServiceHelper
+// wxSocketServiceHandler::wxIOServiceHelper
+// ==========================================================================
+
+
+int wxSocketServiceHandler::wxIOServiceHelper::Retain(void)
+{
+	wxMutexLocker safe_deposit_box( m_RetainCountMutex );
+	
+	if ( ++m_RetainCount == 1 )
+	{
+		m_pThread = new asio::thread(boost::bind(&wxIOServiceHelper::RunService, this));
+	}
+	
+	return m_RetainCount;
+}
+
+
+int wxSocketServiceHandler::wxIOServiceHelper::Release(void)
+{
+	wxMutexLocker bank_vault( m_RetainCountMutex );
+	
+	wxASSERT( m_RetainCount > 0 );
+	
+	if ( --m_RetainCount == 0 )
+	{
+		m_Service.stop();
+		
+		if ( m_pThread != NULL )
+			m_pThread->join();
+		
+		delete m_pThread;
+		m_pThread = NULL;
+	}
+	
+	return m_RetainCount;
+}
+
+
+void wxSocketServiceHandler::wxIOServiceHelper::RunService(void)
 {
-    // we should be initialized
-    wxASSERT_MSG( m_countInit, _T("extra call to Shutdown()") );
-    if ( --m_countInit == 0 )
     {
-        GSocket_Cleanup();
+		wxMutexLocker locker_room_locker( wxSocketServiceHandler::ms_ActiveServicesMutex );
+		wxThreadIdType thread_id = wxThread::GetCurrentId();
+		wxSocketServiceHandler::ms_ActiveServices[thread_id] = this;
+	}
+	
+	while( m_RetainCount > 0 )
+	{
+		try
+		{
+			while( m_RetainCount > 0 )
+			{
+				wxReadMutexLocker shared_run_lock( m_ResetMutex );
+				
+				asio::error_code ec;
+				m_Service.run_one( ec );
+			}
+		}
+		catch (asio::error_code & ec)
+		{
     }
+		catch ( ... )
+		{
+		}
+		
+		wxWriteMutexLocker reset_lock( m_ResetMutex );
+		m_Service.reset();
+	}
+}
+
+
+
+// ==========================================================================
+#pragma mark - wxSocketBase
+// wxSocketBase
+// ==========================================================================
+
+// --------------------------------------------------------------------------
+// Initialization and shutdown
+// --------------------------------------------------------------------------
+
+
+bool wxSocketBase::IsInitialized()
+{
+	return wxSocketServiceHandler::ServiceExistsForThread();
+}
+
+
+bool wxSocketBase::Initialize()
+{
+    return wxSocketServiceHandler::InitThread();
 }
 
+
+void wxSocketBase::Shutdown()
+{
+	wxSocketServiceHandler::ShutdownThread();
+}
+
+
+
 // --------------------------------------------------------------------------
 // Ctor and dtor
 // --------------------------------------------------------------------------
 
 void wxSocketBase::Init()
 {
-  m_socket       = NULL;
   m_type         = wxSOCKET_UNINIT;
 
   // state
@@ -186,6 +473,8 @@ void wxSocketBase::Init()
   m_error        = false;
   m_lcount       = 0;
   m_timeout      = 600;
+	m_waitComplete = true;
+	m_waitResult   = false;
   m_beingDeleted = false;
 
   // pushback buffer
@@ -195,7 +484,7 @@ void wxSocketBase::Init()
 
   // events
   m_id           = wxID_ANY;
-  m_handler      = NULL;
+	m_pHandler     = NULL;
   m_clientData   = NULL;
   m_notify       = false;
   m_eventmask    = 0;
@@ -209,11 +498,15 @@ void wxSocketBase::Init()
 }
 
 wxSocketBase::wxSocketBase()
+: m_ReadTimer	( wxSocketServiceHandler::GetServiceForThread() ),
+m_WriteTimer	( wxSocketServiceHandler::GetServiceForThread() )
 {
   Init();
 }
 
 wxSocketBase::wxSocketBase(wxSocketFlags flags, wxSocketType type)
+: m_ReadTimer	( wxSocketServiceHandler::GetServiceForThread() ),
+m_WriteTimer	( wxSocketServiceHandler::GetServiceForThread() )
 {
   Init();
 
@@ -233,10 +526,6 @@ wxSocketBase::~wxSocketBase()
   if (!m_beingDeleted)
     Close();
 
-  // Destroy the GSocket object
-  if (m_socket)
-    delete m_socket;
-
   // Free the pushback buffer
   if (m_unread)
     free(m_unread);
@@ -285,18 +574,6 @@ bool wxSocketBase::Close()
   // Interrupt pending waits
   InterruptWait();
 
-  if (m_socket)
-  {
-    // Disable callbacks
-    m_socket->UnsetCallback(GSOCK_INPUT_FLAG | GSOCK_OUTPUT_FLAG |
-                                    GSOCK_LOST_FLAG | GSOCK_CONNECTION_FLAG);
-
-    // Shutdown the connection
-    m_socket->Shutdown();
-  }
-
-  m_connected = false;
-  m_establishing = false;
   return true;
 }
 
@@ -319,66 +596,7 @@ wxSocketBase& wxSocketBase::Read(void* b
   return *this;
 }
 
-wxUint32 wxSocketBase::_Read(void* buffer, wxUint32 nbytes)
-{
-  int total;
-
-  // Try the pushback buffer first
-  total = GetPushback(buffer, nbytes, false);
-  nbytes -= total;
-  buffer  = (char *)buffer + total;
-
-  // Return now in one of the following cases:
-  // - the socket is invalid,
-  // - we got all the data
-  if ( !m_socket ||
-       !nbytes )
-    return total;
-
-  // Possible combinations (they are checked in this order)
-  // wxSOCKET_NOWAIT
-  // wxSOCKET_WAITALL (with or without wxSOCKET_BLOCK)
-  // wxSOCKET_BLOCK
-  // wxSOCKET_NONE
-  //
-  int ret;
-  if (m_flags & wxSOCKET_NOWAIT)
-  {
-    m_socket->SetNonBlocking(1);
-    ret = m_socket->Read((char *)buffer, nbytes);
-    m_socket->SetNonBlocking(0);
-
-    if (ret > 0)
-      total += ret;
-  }
-  else
-  {
-    bool more = true;
-
-    while (more)
-    {
-      if ( !(m_flags & wxSOCKET_BLOCK) && !WaitForRead() )
-        break;
-
-      ret = m_socket->Read((char *)buffer, nbytes);
-
-      if (ret > 0)
-      {
-        total  += ret;
-        nbytes -= ret;
-        buffer  = (char *)buffer + ret;
-      }
-
-      // If we got here and wxSOCKET_WAITALL is not set, we can leave
-      // now. Otherwise, wait until we recv all the data or until there
-      // is an error.
-      //
-      more = (ret > 0 && nbytes > 0 && (m_flags & wxSOCKET_WAITALL));
-    }
-  }
 
-  return total;
-}
 
 wxSocketBase& wxSocketBase::ReadMsg(void* buffer, wxUint32 nbytes)
 {
@@ -518,71 +736,19 @@ wxSocketBase& wxSocketBase::Write(const 
   return *this;
 }
 
-wxUint32 wxSocketBase::_Write(const void *buffer, wxUint32 nbytes)
+
+wxSocketBase& wxSocketBase::WriteMsg(const void *buffer, wxUint32 nbytes)
 {
-  wxUint32 total = 0;
+  wxUint32 total;
+  bool error;
+  struct
+  {
+    unsigned char sig[4];
+    unsigned char len[4];
+  } msg;
 
-  // If the socket is invalid or parameters are ill, return immediately
-  if (!m_socket || !buffer || !nbytes)
-    return 0;
-
-  // Possible combinations (they are checked in this order)
-  // wxSOCKET_NOWAIT
-  // wxSOCKET_WAITALL (with or without wxSOCKET_BLOCK)
-  // wxSOCKET_BLOCK
-  // wxSOCKET_NONE
-  //
-  int ret;
-  if (m_flags & wxSOCKET_NOWAIT)
-  {
-    m_socket->SetNonBlocking(1);
-    ret = m_socket->Write((const char *)buffer, nbytes);
-    m_socket->SetNonBlocking(0);
-
-    if (ret > 0)
-      total = ret;
-  }
-  else
-  {
-    bool more = true;
-
-    while (more)
-    {
-      if ( !(m_flags & wxSOCKET_BLOCK) && !WaitForWrite() )
-        break;
-
-      ret = m_socket->Write((const char *)buffer, nbytes);
-
-      if (ret > 0)
-      {
-        total  += ret;
-        nbytes -= ret;
-        buffer  = (const char *)buffer + ret;
-      }
-
-      // If we got here and wxSOCKET_WAITALL is not set, we can leave
-      // now. Otherwise, wait until we send all the data or until there
-      // is an error.
-      //
-      more = (ret > 0 && nbytes > 0 && (m_flags & wxSOCKET_WAITALL));
-    }
-  }
-
-  return total;
-}
-
-wxSocketBase& wxSocketBase::WriteMsg(const void *buffer, wxUint32 nbytes)
-{
-  wxUint32 total;
-  bool error;
-  struct
-  {
-    unsigned char sig[4];
-    unsigned char len[4];
-  } msg;
-
-  // Mask write events
-  m_writing = true;
+  // Mask write events
+  m_writing = true;
 
   error = true;
   total = 0;
@@ -675,115 +841,292 @@ wxSocketBase& wxSocketBase::Discard()
 // timeout elapses. The polling loop calls PROCESS_EVENTS(), so
 // this won't block the GUI.
 
-bool wxSocketBase::_Wait(long seconds,
-                         long milliseconds,
+bool wxSocketBase::_DoWait(long milliseconds,
                          wxSocketEventFlags flags)
 {
-  GSocketEventFlags result;
-  long timeout;
-
   // Set this to true to interrupt ongoing waits
-  m_interrupt = false;
-
-  // Check for valid socket
-  if (!m_socket)
-    return false;
+	m_waitComplete = false;
 
-  // Check for valid timeout value.
-  if (seconds != -1)
-    timeout = seconds * 1000 + milliseconds;
-  else
-    timeout = m_timeout * 1000;
+#if wxUSE_GUI
+	const bool has_event_loop = wxEventLoopBase::GetActive() != NULL;
+#else
+	const bool has_event_loop = false;
+#endif
 
-  bool has_event_loop = wxTheApp->GetTraits() ? (wxTheApp->GetTraits()->GetSocketGUIFunctionsTable() ? true : false) : false;
+	wxSocketWaitEvent idle_event( m_id );
+	idle_event.SetEventObject(this);
+	idle_event.m_event 		= wxSOCKET_WAIT_IDLE_EVENT;
+	idle_event.m_clientData = m_clientData;
 
-  // Wait in an active polling loop.
-  //
-  // NOTE: We duplicate some of the code in OnRequest, but this doesn't
-  //   hurt. It has to be here because the (GSocket) event might arrive
-  //   a bit delayed, and it has to be in OnRequest as well because we
-  //   don't know whether the Wait functions are being used.
-  //
-  // Do this at least once (important if timeout == 0, when
-  // we are just polling). Also, if just polling, do not yield.
 
-  wxDateTime current_time = wxDateTime::UNow();
-  unsigned int time_limit = (current_time.GetTicks() * 1000) + current_time.GetMillisecond() + timeout;
-  bool done = false;
-  bool valid_result = false;
+	if ( flags & wxSOCKET_INPUT_FLAG )
+	{
+		m_ReadTimer.expires_from_now( boost::posix_time::milliseconds( milliseconds == 0 ? 10 : milliseconds ) );
+		m_ReadTimer.async_wait(boost::bind(&wxSocketBase::handle_wait_timer,
+										   this,
+										   asio::placeholders::error) );
+	}
 
-  if (!has_event_loop)
+	if ( flags & wxSOCKET_OUTPUT_FLAG )
   {
-    // This is used to avoid a busy loop on wxBase - having a select
-    // timeout of 50 ms per iteration should be enough.
-    if (timeout > 50)
-      m_socket->SetTimeout(50);
-    else
-      m_socket->SetTimeout(timeout);
+		m_WriteTimer.expires_from_now( boost::posix_time::milliseconds( milliseconds == 0 ? 10 : milliseconds ) );
+		m_WriteTimer.async_wait(boost::bind(&wxSocketBase::handle_wait_timer,
+											this,
+											asio::placeholders::error) );
   }
 
-  while (!done)
+	do
   {
-    result = m_socket->Select(flags | GSOCK_LOST_FLAG);
 
-    // Incoming connection (server) or connection established (client)
-    if (result & GSOCK_CONNECTION_FLAG)
+		try
     {
-      m_connected = true;
-      m_establishing = false;
-      valid_result = true;
-      break;
-    }
+			asio::error_code ec;
 
-    // Data available or output buffer ready
-    if ((result & GSOCK_INPUT_FLAG) || (result & GSOCK_OUTPUT_FLAG))
+			while (!m_waitComplete)
     {
-      valid_result = true;
-      break;
+				if ( ( m_flags & wxSOCKET_BLOCK ) ||
+					 ( !has_event_loop ) )
+				{
+					// doesn't return until one event has been handled
+					if ( milliseconds > 0 )
+					{
+						if ( wxSocketServiceHandler::RunOne(ec) == 0 )
+						{
+							wxFAIL; // we should run at least one!
+							wxThread::Sleep(0);
+						}
+					}
+					else
+					{
+						// This will effectively continue running one event
+						// until we get what we desire.
+						wxSocketServiceHandler::PollOne(ec);
+					}
+				}
+				else
+				{
+					PROCESS_EVENTS();
+					
+					// returns immediately if no events are available to be handled.
+					// otherwise, handles all events that are currently ready.
+					wxSocketServiceHandler::Poll(ec);
     }
 
-    // Connection lost
-    if (result & GSOCK_LOST_FLAG)
+				if ( ( flags & wxSOCKET_WAIT_IDLE_EVENT_FLAG ) &&
+					 ( m_pHandler != NULL ) )
     {
-      m_connected = false;
-      m_establishing = false;
-      valid_result = ((flags & GSOCK_LOST_FLAG) != 0);
+					m_pHandler->ProcessEvent( idle_event );
+				}
+				
+				InterpretErrorCode(ec);
+			}
+			
+			// we successfully left the while loop.  We have no
+			// reason to compute the outer loop since its only purpose
+			// is to restart after a thrown exception.
       break;
     }
+		catch ( asio::error_code & ec )
+		{
+			// an error occurred that wasn't handled internally.  we should handle it here
+			// and then restart the loop (or break) if appropriate.
+			InterpretErrorCode(ec);
+		}
 
-    // Wait more?
-    current_time = wxDateTime::UNow();
-    int time_left = time_limit - ((current_time.GetTicks() * 1000) + current_time.GetMillisecond());
-    if ((!timeout) || (time_left <= 0) || (m_interrupt))
-      done = true;
-    else
+		// this is cleaner than using a "goto" to jump back before the beginning
+		// of the "try" block.
+	} while (!m_waitComplete);
+	  
+	
+	return m_waitResult;
+}
+
+
+void wxSocketBase::DoHandleWaitTimer(const asio::error_code& err)
+{
+	m_waitComplete = true;
+	
+	if ( err == asio::error::operation_aborted )
     {
-      if (has_event_loop)
+		// Then desired event occurred, and the timer was stopped.
+		m_waitResult = true;
+	}
+	else if ( err == asio::error::timed_out )
       {
-          PROCESS_EVENTS();
+		// Then the wait timed out.
+		m_waitResult = false;
       }
       else
       {
-        // If there's less than 50 ms left, just call select with that timeout.
-        if (time_left < 50)
-          m_socket->SetTimeout(time_left);
+		// Some other error occurred, and we're stopping the wait.
+		m_waitResult = false;
+		InterpretErrorCode(err);
+	}
+}
+
+
+bool wxSocketBase::InterpretErrorCode( const asio::error_code& err ) const
+{
+	bool output = !err;
+		
+	if ( err )
+	{
+		wxLogDebug( wxT("const Socket Error (%d):  %s"),
+				   (int)err.value(),
+				   err.message().c_str() );
+	}
+	
+	return output;
+}
+
+bool wxSocketBase::InterpretErrorCode( const asio::error_code& err )
+{
+	bool output = !err;
+	
+	using namespace asio::error;
+	
+	if ( err )
+	{
+		wxLogError( wxT("Socket Error (%d):  %s"),
+				    (int)err.value(),
+				    err.message().c_str() );
+		
+		// TODO:  Finish handling error codes here.
+//		if ( err.category() == basic_errors )
+		{
+			switch ( err.value() )
+			{
+				case access_denied:
+				case no_permission:
+					m_lasterror = wxSOCKET_ACCESS_DENIED;
+					break;
+					
+				case connection_refused:
+					m_lasterror = wxSOCKET_REFUSED;
+					break;
+
+				case host_unreachable:
+					m_lasterror = wxSOCKET_NOHOST;
+					break;
+					
+				case timed_out:
+					m_lasterror = wxSOCKET_TIMEDOUT;
+					break;
+					
+				case address_family_not_supported:
+				case fault:
+					m_lasterror = wxSOCKET_INVADDR;
+					break;
+					
+				case broken_pipe:
+				case connection_aborted:
+				case interrupted:
+				case network_down:
+				case network_reset:
+				case network_unreachable:
+				case shut_down:
+					m_lasterror = wxSOCKET_IOERR;
+					break;
+					
+				case already_connected:
+				case already_started:
+				case invalid_argument:
+					m_lasterror = wxSOCKET_INVOP;
+					break;
+					
+				case service_not_found:
+				case socket_type_not_supported:
+				case operation_not_supported:
+					m_lasterror = wxSOCKET_NOT_SUPPORTED;
+					break;
+					
+				case would_block:
+					m_lasterror = wxSOCKET_WOULDBLOCK;
+					break;
+					
+				case no_memory:
+				case no_buffer_space:
+				case no_descriptors:
+					m_lasterror = wxSOCKET_MEMERR;
+					break;
+					
+				default:
+					m_lasterror = wxSOCKET_DUMMY;
+					break;
+			}
       }
+		
+	}
+	
+	return output;
+}
+
+
+
+void wxSocketBase::DoHandleWriteRequest	(const asio::error_code& err, size_t bytes_transferred)
+{
+	if ( InterpretErrorCode( err ) )
+		m_WriteTimer.cancel();
+	
+	m_lcount = bytes_transferred;
+
+	if ( ( m_flags & wxSOCKET_OUTPUT_FLAG ) &&
+		 ( m_pHandler != NULL ) )
+	{
+		wxSocketEvent write_event( m_id );
+		write_event.SetEventObject( this );
+		write_event.m_event 			= wxSOCKET_OUTPUT;
+		write_event.m_clientData 		= m_clientData;
+		write_event.m_bytes_transferred	= bytes_transferred;
+		
+		if ( err )
+		{
+			write_event.m_success = false;
     }
+		
+		m_pHandler->ProcessEvent( write_event );
   }
+}
+
 
-  // Set timeout back to original value (we overwrote it for polling)
-  if (!has_event_loop)
-    m_socket->SetTimeout(m_timeout*1000);
+void wxSocketBase::DoHandleReadContent	(const asio::error_code& err, size_t bytes_transferred)
+{
+	if ( InterpretErrorCode( err ) )
+		m_ReadTimer.cancel();
+	
+	m_lcount = bytes_transferred;
+	
+	if ( ( m_flags & wxSOCKET_INPUT_FLAG ) &&
+		 ( m_pHandler != NULL ) )
+	{
+		wxSocketEvent read_event( m_id );
+		read_event.SetEventObject( this );
+		read_event.m_event 				= wxSOCKET_INPUT_SUCCEEDED;
+		read_event.m_clientData 		= m_clientData;
+		read_event.m_bytes_transferred	= bytes_transferred;
 
-  return valid_result;
+		if ( err )
+		{
+			read_event.m_success = false;
+		}
+		
+		m_pHandler->ProcessEvent( read_event );
+	}	
 }
 
-bool wxSocketBase::Wait(long seconds, long milliseconds)
+		
+
+bool wxSocketBase::Wait(long seconds, long milliseconds,wxSocketEventFlags flags)
 {
-    return _Wait(seconds, milliseconds, GSOCK_INPUT_FLAG |
-                                        GSOCK_OUTPUT_FLAG |
-                                        GSOCK_CONNECTION_FLAG |
-                                        GSOCK_LOST_FLAG);
+	long timeout = 0;
+	
+	// Check for valid timeout value.
+	if (seconds != -1)
+		timeout = seconds * 1000 + milliseconds;
+	else
+		timeout = m_timeout * 1000;
+	
+    return _DoWait(timeout, flags);
 }
 
 bool wxSocketBase::WaitForRead(long seconds, long milliseconds)
@@ -797,62 +1140,38 @@ bool wxSocketBase::WaitForRead(long seco
   // value of true means that a GSocket_Read call will return
   // immediately, not that there is actually data to read.
 
-  return _Wait(seconds, milliseconds, GSOCK_INPUT_FLAG |
-                                      GSOCK_LOST_FLAG);
+	return Wait(seconds, milliseconds, wxSOCKET_INPUT_FLAG |
+				                       wxSOCKET_LOST_FLAG);
 }
 
 
 bool wxSocketBase::WaitForWrite(long seconds, long milliseconds)
 {
-    return _Wait(seconds, milliseconds, GSOCK_OUTPUT_FLAG);
+    return Wait(seconds, milliseconds, wxSOCKET_OUTPUT_FLAG);
 }
 
 bool wxSocketBase::WaitForLost(long seconds, long milliseconds)
 {
-    return _Wait(seconds, milliseconds, GSOCK_LOST_FLAG);
+    return Wait(seconds, milliseconds, wxSOCKET_LOST_FLAG);
 }
 
-// --------------------------------------------------------------------------
-// Miscellaneous
-// --------------------------------------------------------------------------
-
-//
-// Get local or peer address
-//
 
-bool wxSocketBase::GetPeer(wxSockAddress& addr_man) const
+void wxSocketBase::InterruptWait()
 {
-  GAddress *peer;
+	asio::error_code ec;
+	m_ReadTimer.cancel( ec );
+	m_WriteTimer.cancel( ec );
 
-  if (!m_socket)
-    return false;
-
-  peer = m_socket->GetPeer();
-
-    // copying a null address would just trigger an assert anyway
-
-  if (!peer)
-    return false;
-
-  addr_man.SetAddress(peer);
-  GAddress_destroy(peer);
+	m_waitComplete = true;
 
-  return true;
+	wxASSERT( !ec );
 }
 
-bool wxSocketBase::GetLocal(wxSockAddress& addr_man) const
-{
-    GAddress *local;
-
-    if (!m_socket)
-        return false;
 
-    local = m_socket->GetLocal();
-    addr_man.SetAddress(local);
-    GAddress_destroy(local);
+// --------------------------------------------------------------------------
+// Miscellaneous
+// --------------------------------------------------------------------------
 
-    return true;
-}
 
 //
 // Save and restore socket state
@@ -899,9 +1218,6 @@ void wxSocketBase::RestoreState()
 void wxSocketBase::SetTimeout(long seconds)
 {
     m_timeout = seconds;
-
-    if (m_socket)
-        m_socket->SetTimeout(m_timeout * 1000);
 }
 
 void wxSocketBase::SetFlags(wxSocketFlags flags)
@@ -910,120 +1226,29 @@ void wxSocketBase::SetFlags(wxSocketFlag
 }
 
 
-// --------------------------------------------------------------------------
-// Event handling
-// --------------------------------------------------------------------------
-
-// A note on how events are processed, which is probably the most
-// difficult thing to get working right while keeping the same API
-// and functionality for all platforms.
-//
-// When GSocket detects an event, it calls wx_socket_callback, which in
-// turn just calls wxSocketBase::OnRequest in the corresponding wxSocket
-// object. OnRequest does some housekeeping, and if the event is to be
-// propagated to the user, it creates a new wxSocketEvent object and
-// posts it. The event is not processed immediately, but delayed with
-// AddPendingEvent instead. This is necessary in order to decouple the
-// event processing from wx_socket_callback; otherwise, subsequent IO
-// calls made from the user event handler would fail, as gtk callbacks
-// are not reentrant.
-//
-// Note that, unlike events, user callbacks (now deprecated) are _not_
-// decoupled from wx_socket_callback and thus they suffer from a variety
-// of problems. Avoid them where possible and use events instead.
-
-extern "C"
-void LINKAGEMODE wx_socket_callback(GSocket * WXUNUSED(socket),
-                                    GSocketEvent notification,
-                                    char *cdata)
-{
-    wxSocketBase *sckobj = (wxSocketBase *)cdata;
-
-    sckobj->OnRequest((wxSocketNotify) notification);
-}
-
-void wxSocketBase::OnRequest(wxSocketNotify notification)
-{
-  // NOTE: We duplicate some of the code in _Wait, but this doesn't
-  //   hurt. It has to be here because the (GSocket) event might arrive
-  //   a bit delayed, and it has to be in _Wait as well because we don't
-  //   know whether the Wait functions are being used.
-
-  switch(notification)
-  {
-    case wxSOCKET_CONNECTION:
-      m_establishing = false;
-      m_connected = true;
-      break;
-
-    // If we are in the middle of a R/W operation, do not
-    // propagate events to users. Also, filter 'late' events
-    // which are no longer valid.
-
-    case wxSOCKET_INPUT:
-      if (m_reading || !m_socket->Select(GSOCK_INPUT_FLAG))
-        return;
-      break;
-
-    case wxSOCKET_OUTPUT:
-      if (m_writing || !m_socket->Select(GSOCK_OUTPUT_FLAG))
-        return;
-      break;
-
-    case wxSOCKET_LOST:
-      m_connected = false;
-      m_establishing = false;
-      break;
-
-    default:
-      break;
-  }
-
-  // Schedule the event
-
-  wxSocketEventFlags flag = 0;
-  wxUnusedVar(flag);
-  switch (notification)
-  {
-    case GSOCK_INPUT:      flag = GSOCK_INPUT_FLAG; break;
-    case GSOCK_OUTPUT:     flag = GSOCK_OUTPUT_FLAG; break;
-    case GSOCK_CONNECTION: flag = GSOCK_CONNECTION_FLAG; break;
-    case GSOCK_LOST:       flag = GSOCK_LOST_FLAG; break;
-    default:
-      wxLogWarning(_("wxSocket: unknown event!."));
-      return;
-  }
-
-  if (((m_eventmask & flag) == flag) && m_notify)
-  {
-    if (m_handler)
-    {
-      wxSocketEvent event(m_id);
-      event.m_event      = notification;
-      event.m_clientData = m_clientData;
-      event.SetEventObject(this);
-
-      m_handler->AddPendingEvent(event);
-    }
-  }
-}
 
 void wxSocketBase::Notify(bool notify)
 {
     m_notify = notify;
 }
 
+
+
 void wxSocketBase::SetNotify(wxSocketEventFlags flags)
 {
     m_eventmask = flags;
 }
 
+
+
 void wxSocketBase::SetEventHandler(wxEvtHandler& handler, int id)
 {
-    m_handler = &handler;
+    m_pHandler	= &handler;
     m_id      = id;
 }
 
+
+
 // --------------------------------------------------------------------------
 // Pushback buffer
 // --------------------------------------------------------------------------
@@ -1050,6 +1275,8 @@ void wxSocketBase::Pushback(const void *
   memcpy(m_unread, buffer, size);
 }
 
+
+
 wxUint32 wxSocketBase::GetPushback(void *buffer, wxUint32 size, bool peek)
 {
   if (!m_unrd_size)
@@ -1077,321 +1304,1408 @@ wxUint32 wxSocketBase::GetPushback(void 
 
 
 // ==========================================================================
-// wxSocketServer
+#pragma mark - wxSocket
+// wxSocket - a TCP Socket
 // ==========================================================================
 
-// --------------------------------------------------------------------------
-// Ctor
-// --------------------------------------------------------------------------
+wxSocket::wxSocket(wxSocketFlags flags, wxSocketType type)
+: wxSocketBase	( flags, type ),
+m_Socket		( wxSocketServiceHandler::GetServiceForThread() ),
+m_ConnectTimer	( wxSocketServiceHandler::GetServiceForThread() ),
+m_CloseTimer	( wxSocketServiceHandler::GetServiceForThread() )
+{	
+}
 
-wxSocketServer::wxSocketServer(const wxSockAddress& addr_man,
-                               wxSocketFlags flags)
-              : wxSocketBase(flags, wxSOCKET_SERVER)
+
+
+wxUint32 wxSocket::_Write(const void *buffer, wxUint32 nbytes)
 {
-    wxLogTrace( wxTRACE_Socket, _T("Opening wxSocketServer") );
+	wxUint32 total = 0;
 
-    m_socket = GSocket_new();
+	// If the socket is invalid or parameters are ill, return immediately
+	if (!m_Socket.is_open() || !buffer || !nbytes)
+		return 0;
 
-    if (!m_socket)
+	// Possible combinations (they are checked in this order)
+	// wxSOCKET_NOWAIT
+	// wxSOCKET_WAITALL (with or without wxSOCKET_BLOCK)
+	// wxSOCKET_BLOCK
+	// wxSOCKET_NONE
+	//
+	if ( m_flags & wxSOCKET_BLOCK )
     {
-        wxLogTrace( wxTRACE_Socket, _T("*** GSocket_new failed") );
-        return;
-    }
+		asio::error_code ec;
 
-        // Setup the socket as server
+		// We're doing a synchronous write because we're in blocking mode.
+		total = asio::write( m_Socket,
+							asio::buffer(buffer, nbytes),
+							asio::transfer_all(),
+							ec );
 
-    m_socket->SetLocal(addr_man.GetAddress());
 
-    if (GetFlags() & wxSOCKET_REUSEADDR) {
-        m_socket->SetReusable();
-    }
+		DoHandleWriteRequest(ec, total);
+		
+		wxASSERT( total == nbytes );
 
-    if (m_socket->SetServer() != GSOCK_NOERROR)
+		// cancel any asynchronous waits in progress.
+		m_WriteTimer.cancel();
+	}
+	else
     {
-        delete m_socket;
-        m_socket = NULL;
+		m_Socket.async_send(asio::buffer(buffer, nbytes),
+							boost::bind(&wxSocket::handle_write_request, 
+										this,
+										asio::placeholders::error,
+										asio::placeholders::bytes_transferred));
 
-        wxLogTrace( wxTRACE_Socket, _T("*** GSocket_SetServer failed") );
-        return;
+		if ( ( (~m_flags) & wxSOCKET_NOWAIT ) &&
+			( m_flags & wxSOCKET_WAITALL ) )
+		{
+			_DoWait(m_timeout*1000, wxSOCKET_OUTPUT_FLAG);
+		}
     }
 
-    m_socket->SetTimeout(m_timeout * 1000);
-    m_socket->SetCallback(GSOCK_INPUT_FLAG | GSOCK_OUTPUT_FLAG |
-                                  GSOCK_LOST_FLAG | GSOCK_CONNECTION_FLAG,
-                                  wx_socket_callback, (char *)this);
+	return total;
 }
 
-// --------------------------------------------------------------------------
-// Accept
-// --------------------------------------------------------------------------
 
-bool wxSocketServer::AcceptWith(wxSocketBase& sock, bool wait)
+
+
+wxUint32 wxSocket::_Read(void *buffer, wxUint32 nbytes)
 {
-  GSocket *child_socket;
+	wxUint32 total = 0;
 
-  if (!m_socket)
-    return false;
+	// If the socket is invalid or parameters are ill, return immediately
+	if (!m_Socket.is_open() || !buffer || !nbytes)
+		return 0;
+	
+	// Possible combinations (they are checked in this order)
+	// wxSOCKET_NOWAIT
+	// wxSOCKET_WAITALL (with or without wxSOCKET_BLOCK)
+	// wxSOCKET_BLOCK
+	// wxSOCKET_NONE
+	//
+	if ( ( m_flags & wxSOCKET_NOWAIT ) ||
+		 ( m_flags == (wxUint32)wxSOCKET_NONE ) )
+	{
+		asio::error_code ec;
+		
+		if ( ( m_flags == (wxUint32)wxSOCKET_NONE ) ||
+			 ( m_Socket.available( ec ) > 0 ) )
+		{
+			// May not read everything and returns nearly immediately.
+			total = m_Socket.read_some(asio::buffer(buffer, nbytes),
+									   ec);
+		}
 
-  // If wait == false, then the call should be nonblocking.
-  // When we are finished, we put the socket to blocking mode
-  // again.
+		if ( ( InterpretErrorCode( ec ) ) &&
+			 ( total > 0 ) )
+		{
+			m_ReadTimer.cancel();
+		}
 
-  if (!wait)
-    m_socket->SetNonBlocking(1);
+//		DoHandleReadContent(ec,total);
+//		
+//		if ( total > 0 )
+//		{
+//			// cancel any asynchronous waits in progress.
+//			m_ReadTimer.cancel();
+//		}
+	}
+	else
+	{		
+		m_Socket.async_receive(asio::buffer(buffer, nbytes),
+							   boost::bind(&wxSocket::handle_read_content, 
+										   this,
+										   asio::placeholders::error,
+										   asio::placeholders::bytes_transferred));
+		
+		if ( m_flags & wxSOCKET_WAITALL )
+		{
+			if ( ( ( m_timeout > 0 ) || ( IsData() ) ) && // this stops us from waiting when timeout is zero and we know there's no data.
+				 ( _DoWait(m_timeout*1000, wxSOCKET_INPUT_FLAG) ) )
+			{
+				// Then the wait was successful.  
+				
+				// FIXME:  The following is an assumption.
+				// The data is available to the event handler.
+				total = nbytes;
+			}
+		}
+	}
 
-  child_socket = m_socket->WaitConnection();
+	return total;
+}
 
-  if (!wait)
-    m_socket->SetNonBlocking(0);
 
-  if (!child_socket)
-    return false;
 
-  sock.m_type = wxSOCKET_BASE;
-  sock.m_socket = child_socket;
-  sock.m_connected = true;
+bool wxSocket::_DoWait(long milliseconds, wxSocketEventFlags flags)
+{
+	if ( flags & wxSOCKET_CONNECTION_FLAG )
+	{
+		m_ConnectTimer.expires_from_now( boost::posix_time::milliseconds( milliseconds == 0 ? 10 : milliseconds ) );
+		m_ConnectTimer.async_wait(boost::bind(&wxSocket::handle_wait_timer,
+											  this,
+											  asio::placeholders::error) );
+	}
 
-  sock.m_socket->SetTimeout(sock.m_timeout * 1000);
-  sock.m_socket->SetCallback(GSOCK_INPUT_FLAG | GSOCK_OUTPUT_FLAG |
-                                     GSOCK_LOST_FLAG | GSOCK_CONNECTION_FLAG,
-                                     wx_socket_callback, (char *)&sock);
+	if ( flags & wxSOCKET_LOST_FLAG )
+	{
+		m_CloseTimer.expires_from_now( boost::posix_time::milliseconds( milliseconds == 0 ? 10 : milliseconds ) );
+		m_CloseTimer.async_wait(boost::bind(&wxSocket::handle_wait_timer,
+											this,
+											asio::placeholders::error) );
+	}
 
-  return true;
+	return wxSocketBase::_DoWait( milliseconds, flags );
 }
 
-wxSocketBase *wxSocketServer::Accept(bool wait)
+
+
+void wxSocket::DoHandleConnectTimer	(const asio::error_code& err)
 {
-  wxSocketBase* sock = new wxSocketBase();
+	InterpretErrorCode(err);
 
-  sock->SetFlags(m_flags);
+	if ( ( m_pHandler != NULL ) &&
+		( GetFlags() & wxSOCKET_WAIT_CONNECT_FLAG ) )
+	{
+		wxSocketWaitEvent event( m_id );
+		event.SetEventObject(&m_Peer);
+		event.m_event = wxSOCKET_CONNECTION;
 
-  if (!AcceptWith(*sock, wait))
+		if ( err == asio::error::operation_aborted )
   {
-    sock->Destroy();
-    sock = NULL;
+			// Then the timer was aborted, which means we should have connected
+			event.m_timeout = false;
+		}
+		else if ( err == asio::error::timed_out )
+		{
+			// Timer expired.
+			event.m_timeout = true;
+		}
+		else
+		{
+			// unknown error
   }
 
-  return sock;
+		m_pHandler->ProcessEvent( event );
+	}	
 }
 
-bool wxSocketServer::WaitForAccept(long seconds, long milliseconds)
-{
-    return _Wait(seconds, milliseconds, GSOCK_CONNECTION_FLAG);
-}
 
-bool wxSocketBase::GetOption(int level, int optname, void *optval, int *optlen)
+void wxSocket::DoHandleCloseTimer(const asio::error_code& err)
 {
-    wxASSERT_MSG( m_socket, _T("Socket not initialised") );
+	InterpretErrorCode(err);
 
-    if (m_socket->GetSockOpt(level, optname, optval, optlen)
-        != GSOCK_NOERROR)
+	if ( ( m_pHandler != NULL ) &&
+		( GetFlags() & wxSOCKET_LOST_FLAG ) )
     {
-        return false;
+		wxSocketWaitEvent event( m_id );
+		event.SetEventObject(&m_Peer);
+		event.m_event = wxSOCKET_CLOSED;
+		
+		if ( err == asio::error::operation_aborted )
+		{
+			// Then the timer was aborted, which means we should have connected
+			event.m_timeout = false;
+		}
+		else if ( err == asio::error::timed_out )
+		{
+			// Timer expired.
+			event.m_timeout = true;
+		}
+		else
+		{
+			// unknown error
+		}
+	
+		m_pHandler->ProcessEvent( event );
     }
-    return true;
 }
 
-bool wxSocketBase::SetOption(int level, int optname, const void *optval,
-                              int optlen)
+
+
+bool wxSocket::SetLocal(wxIPendpoint& local)
 {
-    wxASSERT_MSG( m_socket, _T("Socket not initialised") );
+	bool output = false;
+	
+	wxTCPIPendpoint * pEndpoint = dynamic_cast< wxTCPIPendpoint * > ( &local );
 
-    if (m_socket->SetSockOpt(level, optname, optval, optlen)
-        != GSOCK_NOERROR)
+	if ( pEndpoint != NULL )
     {
-        return false;
+		asio::error_code ec;
+		m_Socket.bind( pEndpoint->GetEndpoint(), ec );
+		
+		if ( InterpretErrorCode(ec) )
+			output = true;
+		else
+			wxFAIL;
     }
-    return true;
+	
+	return output;
 }
 
-bool wxSocketBase::SetLocal(wxIPV4address& local)
+
+
+bool wxSocket::Close()
 {
-  GAddress* la = local.GetAddress();
+	bool output = wxSocketBase::Close();
 
-  // If the address is valid, save it for use when we call Connect
-  if (la && la->m_addr)
+	if ( output )
   {
-    m_localAddress = local;
+		asio::error_code ec;
+		m_Socket.close( ec );
 
-    return true;
+		output = InterpretErrorCode(ec);
   }
 
-  return false;
+	return output;
 }
 
-// ==========================================================================
-// wxSocketClient
-// ==========================================================================
 
-// --------------------------------------------------------------------------
-// Ctor and dtor
-// --------------------------------------------------------------------------
 
-wxSocketClient::wxSocketClient(wxSocketFlags flags)
-              : wxSocketBase(flags, wxSOCKET_CLIENT)
+void wxSocket::InterruptWait()
 {
-}
+	wxSocketBase::InterruptWait();
 
-wxSocketClient::~wxSocketClient()
-{
+	asio::error_code ec;
+	m_ConnectTimer.cancel( ec );
+	InterpretErrorCode(ec);
+	
+	m_CloseTimer.cancel( ec );
+	InterpretErrorCode(ec);
+	
+	m_Socket.cancel( ec );
+	InterpretErrorCode(ec);
 }
 
-// --------------------------------------------------------------------------
-// Connect
-// --------------------------------------------------------------------------
 
-bool wxSocketClient::DoConnect(wxSockAddress& addr_man, wxSockAddress* local, bool wait)
+void wxSocket::SetFlags(wxSocketFlags flags)
 {
-  GSocketError err;
+	wxSocketBase::SetFlags( flags );
 
-  if (m_socket)
-  {
-    // Shutdown and destroy the socket
-    Close();
-    delete m_socket;
-  }
+	asio::error_code ec;
 
-  m_socket = GSocket_new();
-  m_connected = false;
-  m_establishing = false;
+	asio::socket_base::non_blocking_io 	non_blocking_command(false);
+	asio::socket_base::do_not_route		do_not_route_option(false);
+	asio::socket_base::keep_alive 		keep_alive_option(false);
+	asio::socket_base::broadcast 		broadcast_option(false);
 
-  if (!m_socket)
-    return false;
+	if ( m_flags & wxSOCKET_NOWAIT )
+	{
+		non_blocking_command.set(true);
+	}
 
-  m_socket->SetTimeout(m_timeout * 1000);
-  m_socket->SetCallback(GSOCK_INPUT_FLAG | GSOCK_OUTPUT_FLAG |
-                                GSOCK_LOST_FLAG | GSOCK_CONNECTION_FLAG,
-                                wx_socket_callback, (char *)this);
+	if( m_flags & wxSOCKET_WAITALL )
+	{
+//		non_blocking_command.set(false);
+	}		
 
-  // If wait == false, then the call should be nonblocking.
-  // When we are finished, we put the socket to blocking mode
-  // again.
+	if ( m_flags & wxSOCKET_BLOCK )
+	{
+		non_blocking_command.set(false);
+	}
 
-  if (!wait)
-    m_socket->SetNonBlocking(1);
+	if ( m_flags & wxSOCKET_DO_NOT_ROUTE )
+	{
+		do_not_route_option = true;
+	}
 
-  // Reuse makes sense for clients too, if we are trying to rebind to the same port
-  if (GetFlags() & wxSOCKET_REUSEADDR)
+	if ( m_flags & wxSOCKET_KEEP_ALIVE )
   {
-    m_socket->SetReusable();
+		keep_alive_option = true;
   }
 
-  // If no local address was passed and one has been set, use the one that was Set
-  if (!local && m_localAddress.GetAddress())
+	if ( m_flags & wxSOCKET_BROADCAST )
   {
-    local = &m_localAddress;
+		broadcast_option = true;
   }
 
-  // Bind to the local IP address and port, when provided
-  if (local)
+	
+	m_Socket.io_control( non_blocking_command, ec );
+	
+	if ( !ec )
+		m_Socket.set_option( do_not_route_option, ec );
+	
+	if ( !ec )
+		m_Socket.set_option( keep_alive_option, ec );
+	
+	if ( !ec )
+		m_Socket.set_option( broadcast_option, ec );
+	
+	InterpretErrorCode(ec);
+}
+
+
+
+wxSocketBase& wxSocket::Peek(void* buffer, wxUint32 nbytes)
+{
+	m_lcount = 0;
+
+	// If the socket is invalid or parameters are ill, return immediately
+	if (!m_Socket.is_open() || !buffer || !nbytes)
+		return *this;
+	
+	asio::error_code ec;
+	std::size_t bytes_read = 0;
+
+	if ( m_Socket.available( ec ) > 0 )
   {
-    GAddress* la = local->GetAddress();
+		// May not read everything and returns nearly immediately.
+		bytes_read = m_Socket.receive(asio::buffer(buffer, nbytes),
+										  asio::socket_base::message_peek,
+										  ec);
 
-    if (la && la->m_addr)
-      m_socket->SetLocal(la);
+		m_lcount = bytes_read;
   }
 
-  m_socket->SetPeer(addr_man.GetAddress());
-  err = m_socket->Connect(GSOCK_STREAMED);
+	return *this;
+}
+
+
+size_t	wxSocket::DataReadable()
+{
+	asio::error_code ec;
+	asio::socket_base::bytes_readable command(true);
+	m_Socket.io_control(command,ec);
+	std::size_t bytes_readable = 0;
+	
+	if ( InterpretErrorCode(ec) )
+		bytes_readable = command.get();
+	
+	return bytes_readable;
+}
+
+
+
+
+//
+// Get local or peer address
+//
+
+bool wxSocket::GetPeer(wxIPendpoint& addr_man) const
+{
+	bool output = false;
 
-  if (!wait)
-    m_socket->SetNonBlocking(0);
+	wxTCPIPendpoint * pEndpoint = dynamic_cast< wxTCPIPendpoint * > ( &addr_man );
 
-  if (err != GSOCK_NOERROR)
+	if ( pEndpoint != NULL )
   {
-    if (err == GSOCK_WOULDBLOCK)
-      m_establishing = true;
+		if ( m_Socket.is_open() )
+		{
+			asio::error_code ec;
 
-    return false;
+			*pEndpoint = m_Socket.remote_endpoint(ec);
+			
+			if ( InterpretErrorCode(ec) )
+				output = true;
+		}
   }
 
-  m_connected = true;
-  return true;
+	return output;
 }
 
-bool wxSocketClient::Connect(wxSockAddress& addr_man, bool wait)
+bool wxSocket::GetLocal(wxIPendpoint& addr_man) const
 {
-    return (DoConnect(addr_man, NULL, wait));
+	bool output = false;
+	
+	wxTCPIPendpoint * pEndpoint = dynamic_cast< wxTCPIPendpoint * > ( &addr_man );
+	
+	if ( pEndpoint != NULL )
+	{
+		asio::error_code ec;
+		
+		*pEndpoint = m_Socket.local_endpoint(ec);
+		
+		if ( InterpretErrorCode(ec) )
+			output = true;
+	}
+	
+	return output;
 }
 
-bool wxSocketClient::Connect(wxSockAddress& addr_man, wxSockAddress& local, bool wait)
+
+
+bool wxSocket::GetOption(int level, int optname, void *optval, size_t *optlen)
 {
-    return (DoConnect(addr_man, &local, wait));
+	asio::error_code ec;
+	
+	asio::detail::socket_ops::getsockopt(m_Socket.native(), level, optname, optval, optlen, ec);
+	
+	return InterpretErrorCode(ec);
 }
 
-bool wxSocketClient::WaitOnConnect(long seconds, long milliseconds)
+
+
+bool wxSocket::SetOption(int level, int optname, const void *optval,
+						 size_t optlen)
 {
-    if (m_connected)                      // Already connected
-        return true;
+	asio::error_code ec;
 
-    if (!m_establishing || !m_socket)     // No connection in progress
-        return false;
+	asio::detail::socket_ops::setsockopt(m_Socket.native(), level, optname, optval, optlen, ec);
 
-    return _Wait(seconds, milliseconds, GSOCK_CONNECTION_FLAG |
-                                        GSOCK_LOST_FLAG);
+	return InterpretErrorCode(ec);
 }
 
+
+
+
 // ==========================================================================
-// wxDatagramSocket
+#pragma mark - wxSocketServer
+// wxSocketServer
 // ==========================================================================
 
-/* NOTE: experimental stuff - might change */
+// --------------------------------------------------------------------------
+// Ctor
+// --------------------------------------------------------------------------
 
-wxDatagramSocket::wxDatagramSocket( const wxSockAddress& addr,
-                                    wxSocketFlags flags )
-                : wxSocketBase( flags, wxSOCKET_DATAGRAM )
+wxSocketServer::wxSocketServer(const wxTCPIPendpoint& addr_man,
+                               wxSocketFlags flags)
+: wxSocket(flags, wxSOCKET_SERVER),
+m_Acceptor( wxSocketServiceHandler::GetServiceForThread() )
 {
-    // Create the socket
-    m_socket = GSocket_new();
+	wxLogTrace( wxTRACE_Socket, _T("Opening wxSocketServer") );
 
-    if (!m_socket)
+	asio::error_code ec;
+	
+	switch ( addr_man.Type() )
     {
-        wxFAIL_MSG( _T("datagram socket not new'd") );
-        return;
+		case wxSockAddress::IPV4:
+			m_Acceptor.open( tcp::v4(), ec );
+			if ( !ec )
+				m_Acceptor.bind( addr_man.GetEndpoint(), ec );
+			
+			if ( !ec )
+				m_Acceptor.listen(socket_base::max_connections,ec);
+			break;
+			
+		case wxSockAddress::IPV6:
+			m_Acceptor.open( tcp::v6(), ec );
+			if ( !ec )
+				m_Acceptor.bind( addr_man.GetEndpoint(), ec );
+			
+			if ( !ec )
+				m_Acceptor.listen(socket_base::max_connections,ec);
+			break;
+			
+		default:
+			wxFAIL;
+			break;
     }
-    // Setup the socket as non connection oriented
-    m_socket->SetLocal(addr.GetAddress());
-    if (flags & wxSOCKET_REUSEADDR)
+
+	InterpretErrorCode(ec);
+}
+
+
+wxSocketServer::wxSocketServer(unsigned short port, wxSockAddress::Addr ip_version, wxSocketFlags flags )
+: wxSocket(flags, wxSOCKET_SERVER),
+m_Acceptor( wxSocketServiceHandler::GetServiceForThread() )
+{
+	asio::error_code ec;
+
+	switch ( ip_version )
     {
-        m_socket->SetReusable();
+		case wxSockAddress::IPV4:
+			m_Acceptor.open( tcp::v4(), ec );
+			if ( !ec )
+				m_Acceptor.bind( tcp::endpoint( tcp::v4(), port ), ec );
+			
+			if ( !ec )
+				m_Acceptor.listen(socket_base::max_connections,ec);
+			break;
+			
+		case wxSockAddress::IPV6:
+			m_Acceptor.open( tcp::v6(), ec );
+			if ( !ec )
+				m_Acceptor.bind( tcp::endpoint( tcp::v6(), port ), ec );
+			
+			if ( !ec )
+				m_Acceptor.listen(socket_base::max_connections,ec);
+			break;
+			
+		default:
+			wxFAIL;
+			break;
     }
-    if ( m_socket->SetNonOriented() != GSOCK_NOERROR )
+	
+	InterpretErrorCode(ec);
+}
+
+
+void wxSocketServer::SetFlags(wxSocketFlags flags)
+{
+	wxSocket::SetFlags( flags );
+	
+	asio::error_code ec;
+	
+	asio::socket_base::reuse_address reuse_address_option(false);
+	
+	if ( m_flags & wxSOCKET_REUSEADDR )
     {
-        delete m_socket;
-        m_socket = NULL;
-        return;
+		reuse_address_option = true;
     }
 
-    // Initialize all stuff
-    m_connected = false;
-    m_establishing = false;
-    m_socket->SetTimeout( m_timeout );
-    m_socket->SetCallback( GSOCK_INPUT_FLAG | GSOCK_OUTPUT_FLAG |
-                           GSOCK_LOST_FLAG | GSOCK_CONNECTION_FLAG,
-                           wx_socket_callback, (char*)this );
+	m_Acceptor.set_option( reuse_address_option, ec );
+	InterpretErrorCode(ec);
 }
 
-wxDatagramSocket& wxDatagramSocket::RecvFrom( wxSockAddress& addr,
-                                              void* buf,
-                                              wxUint32 nBytes )
+
+
+// --------------------------------------------------------------------------
+// Accept
+// --------------------------------------------------------------------------
+
+bool wxSocketServer::AcceptWith(wxSocket& sock, bool wait)
 {
-    Read(buf, nBytes);
-    GetPeer(addr);
-    return (*this);
+	sock.m_connected = false;
+	
+	if ( wait )
+	{
+		asio::error_code ec;
+
+		m_Acceptor.accept(sock.m_Socket, 
+						  sock.m_Peer.GetEndpoint(),
+						  ec );
+		sock.m_type = wxSOCKET_BASE;
+
+		if ( !ec )
+			sock.m_connected = sock.m_Socket.is_open();
+		
+		DoHandleAccept(sock, ec);
+	}
+	else
+	{
+		m_Acceptor.async_accept( sock.m_Socket,
+								 sock.m_Peer.GetEndpoint(),
+								 boost::bind(&wxSocketServer::handle_accept,
+											 this,
+											 boost::ref(sock),
+											 asio::placeholders::error) );
+		
+		if ( ( (~m_flags) & wxSOCKET_NOWAIT ) &&
+			( m_flags & wxSOCKET_WAITALL ) )
+		{
+			_DoWait( wait ? m_timeout*1000 : 0, wxSOCKET_CONNECTION_FLAG);
+		}
+	}
+
+	return sock.IsConnected();
 }
 
-wxDatagramSocket& wxDatagramSocket::SendTo( const wxSockAddress& addr,
-                                            const void* buf,
-                                            wxUint32 nBytes )
+
+
+void wxSocketServer::DoHandleAccept( wxSocket& sock, const asio::error_code& err )
 {
-    wxASSERT_MSG( m_socket, _T("Socket not initialised") );
+	wxSocketEvent connect_event( sock.m_id );
+	connect_event.SetEventObject( &sock );
+	connect_event.m_event 		= wxSOCKET_CONNECTION;
+	connect_event.m_clientData 	= m_clientData;
+
+	connect_event.m_success 	= InterpretErrorCode(err) && sock.m_connected;
+	
+	connect_event.Skip();
+
+	if ( ( sock.m_pHandler != NULL ) &&
+		 ( sock.GetFlags() & wxSOCKET_CONNECTION_FLAG ) )
+	{
+		// this object's event handler must explicitly call Skip()
+		// for the server object's event handler to handle the event.
+		
+		connect_event.Skip(false); 
+		sock.m_pHandler->ProcessEvent( connect_event );
+	}
 
-    m_socket->SetPeer(addr.GetAddress());
-    Write(buf, nBytes);
-    return (*this);
+	if ( ( m_pHandler != NULL ) &&
+		 ( connect_event.GetSkipped() ) &&
+		 ( GetFlags() & wxSOCKET_CONNECTION_FLAG ) )
+	{
+		m_pHandler->ProcessEvent( connect_event );
+	}
 }
 
+
+
+wxSocket *wxSocketServer::Accept(bool wait)
+{
+	wxSocket* sock = new wxSocket();
+
+	sock->SetFlags(m_flags);
+
+	if (!AcceptWith(*sock, wait))
+	{
+		if ( !wait )
+		{
+			// AcceptWith() always returns false if
+			// wait is passed.
+			asio::error_code ec;
+			while( wxSocketServiceHandler::Poll( ec ) > 0 ) 
+			{
+				if ( !InterpretErrorCode(ec) )
+					break;
+			}
+		}
+
+		if ( ! sock->IsConnected() )
+		{
+			sock->Destroy();
+			sock = NULL;
+		}
+	}
+
+	return sock;
+}
+
+
+
+bool wxSocketServer::WaitForAccept(long seconds, long milliseconds)
+{
+    return Wait(seconds, milliseconds, wxSOCKET_CONNECTION_FLAG);
+}
+
+
+
+
+
+// ==========================================================================
+#pragma mark - wxSocketClient
+// wxSocketClient
+// ==========================================================================
+
+
+// --------------------------------------------------------------------------
+// Ctor and dtor
+// --------------------------------------------------------------------------
+
+wxSocketClient::wxSocketClient(wxSocketFlags flags)
+: wxSocket(flags, wxSOCKET_CLIENT)
+{
+}
+
+
+wxSocketClient::wxSocketClient(const wxTCPIPendpoint& local, wxSocketFlags flags)
+: wxSocket( flags, wxSOCKET_CLIENT )
+{
+	asio::error_code ec;
+	m_Socket.bind( local.GetEndpoint(), ec );
+	
+	InterpretErrorCode(ec);
+}
+
+
+wxSocketClient::~wxSocketClient()
+{
+}
+
+// --------------------------------------------------------------------------
+// Connect
+// --------------------------------------------------------------------------
+
+//bool wxSocketClient::DoConnect(wxTCPIPendpoint& addr_man)
+//{
+//	bool output = true;
+//	
+//	m_Socket.async_connect(addr_man.GetEndpoint(),
+//						   boost::bind(&wxSocket::handle_connect, this,
+//									   asio::placeholders::error,
+//									   tcp::resolver::end() ) );
+//	
+//	return output;
+//}
+
+bool wxSocketClient::Connect(wxTCPIPendpoint& addr_man, bool wait)
+{
+	bool output = true;
+	
+	m_Peer = addr_man;
+	
+	m_connected = false;
+	m_establishing = true;
+
+#if WX_HAS_UNIX_ENDPOINT
+	wxUNIXendpoint * pEndpoint = wxDynamicCast( &addr_man, wxUNIXendpoint );
+	
+	if ( pEndpoint != NULL )
+	{
+		asio::error_code ec;
+		
+		using namespace asio::detail;
+		
+		int sock_fd = socket_ops::socket( pEndpoint->m_addr.sun_family,
+										 SOCK_STREAM,
+										 PF_UNSPEC,
+										 ec );
+		
+		if ( !ec )
+		{
+			int result = socket_ops::bind( sock_fd, 
+										  reinterpret_cast< sockaddr * > ( &pEndpoint->m_addr ), 
+										  sizeof( pEndpoint->m_addr ),
+										  ec );
+			
+			wxASSERT( result == 0 );
+			
+			if ( !ec )
+			{
+				m_Socket.assign( tcp::v4(), sock_fd, ec );
+			}
+			else
+			{
+				
+			}
+		}
+		
+		InterpretErrorCode(ec);
+	}
+#endif
+	
+	if ( ( m_flags & wxSOCKET_BLOCK ) && wait )
+	{
+		// synchronous
+		ip::tcp::resolver resolver( wxSocketServiceHandler::GetServiceForThread() );
+		
+		asio::error_code ec;
+		// this function returns a list of potential results
+		tcp::resolver::iterator result = resolver.resolve( addr_man.GetEndpoint(), ec );
+
+		if (!ec)
+		{
+			tcp::resolver::iterator end;
+			
+			// iterate through the results until we get a successful connection
+			while ( result != end ) 
+			{
+				tcp::endpoint endpoint = *result;
+				
+				m_Peer.GetEndpoint() = endpoint;
+				
+				// If we have an event handler, notify it of the resolve.
+				if ( ( m_pHandler != NULL ) &&
+					 ( GetFlags() & wxSOCKET_RESOLVE_FLAG ) )
+				{
+					wxResolveEvent resolve_event( m_Peer.GetId() );
+					resolve_event.SetEventObject( &m_Peer );
+
+					m_pHandler->ProcessEvent( resolve_event );
+					
+					if ( ! resolve_event.ShouldContinueResolve() )
+						break;
+					
+					if ( resolve_event.GetSkipped() )
+					{
+						result++;
+						continue;
+					}
+				}
+				
+				// attempt to connect to the endpoint
+				m_Socket.close();
+				m_Socket.connect( endpoint, ec );
+				
+				// we don't call InterpretErrorCode(ec) here because we only
+				// care if *all* endpoints fail--not if an individual endpoint
+				// fails.
+				
+				if ( !ec )
+				{
+					wxASSERT( m_Socket.is_open() );
+					
+					m_connected = true;
+					
+					// cancel any asynchronous waits in progress.
+					m_ConnectTimer.cancel();
+
+					// if successful, notify our event handler.
+					if ( ( m_pHandler != NULL ) &&
+						 ( m_Socket.is_open() ) && 
+						 ( GetFlags() & wxSOCKET_CONNECTION_FLAG ) )
+					{
+						wxSocketEvent connect_event( m_id );
+						connect_event.SetEventObject( &m_Peer );
+						connect_event.m_event 		= wxSOCKET_CONNECTION;
+						connect_event.m_clientData 	= m_clientData;
+
+						m_pHandler->ProcessEvent( connect_event );
+					}
+					
+					break;
+				}
+				
+				result++;
+			}
+		}
+		else
+		{
+			std::cout << "Error: " << ec.message() << "\n";
+		}
+		
+		InterpretErrorCode(ec);
+		
+		output = m_Socket.is_open();
+		
+		m_establishing = false;
+		
+		// cancel any asynchronous waits in progress.
+		m_ConnectTimer.cancel();
+	}
+	else
+	{
+		// async
+		ip::tcp::resolver resolver( wxSocketServiceHandler::GetServiceForThread() );
+		
+		resolver.async_resolve(m_Peer.GetEndpoint(),
+							   boost::bind(&wxSocketClient::handle_resolve, 
+										   this,
+										   asio::placeholders::error,
+										   asio::placeholders::iterator) );
+		
+		if ( wait )
+		{
+			output = _DoWait(m_timeout * 1000, wxSOCKET_CONNECTION_FLAG);
+		}
+		else
+			output = true;
+	}
+	
+	return output;
+}
+
+bool wxSocketClient::Connect(wxTCPIPendpoint& addr_man, wxTCPIPendpoint& local, bool wait)
+{
+	bool output = true;
+
+	asio::error_code ec;
+	m_Socket.bind( local.GetEndpoint(), ec );
+	
+	if ( InterpretErrorCode(ec) )
+	{
+		output = true;
+	}
+	else
+	{
+		output = false;
+		wxFAIL_MSG( wxT("Failed to bind to local endpoint!") );
+	}
+	
+	if ( output )
+		output = Connect( addr_man, wait );
+	
+	return output;
+}
+
+
+bool wxSocketClient::WaitOnConnect(long seconds, long milliseconds, bool async)
+{
+    if (m_connected)		// Already connected
+        return true;
+
+    if (!m_establishing)	// No connection in progress
+        return false;
+
+	m_ConnectTimer.expires_from_now( boost::posix_time::seconds( seconds ) + boost::posix_time::milliseconds( milliseconds ) );
+	
+	bool output = false;
+	
+	if ( !async )
+	{
+		asio::error_code ec;
+		m_ConnectTimer.wait( ec );
+		
+		// should we do this?  This causes an event handler to be called.
+		// perhaps the call was synchronous because they didn't want this.
+		// If not, call InterpretErrorCode(ec) instead to report the error.
+		DoHandleConnectTimer( ec );
+		
+		output = !ec;
+	}
+	else
+	{
+		m_ConnectTimer.async_wait( boost::bind(&wxSocketClient::handle_connect_timer,
+											   this,
+											   asio::placeholders::error ) );
+	}
+
+    return output;
+}
+
+
+void wxSocketClient::DoHandleConnectTimer(const asio::error_code& err)
+{
+	InterpretErrorCode(err);
+	
+	wxSocketWaitEvent event( m_id );
+	event.SetEventObject(&m_Peer);
+	event.m_event = wxSOCKET_CONNECTION;
+	
+	if ( err == asio::error::operation_aborted )
+	{
+		// Then the timer was aborted, which means we should have connected
+		event.m_timeout = false;
+	}
+	else if ( err == asio::error::timed_out )
+	{
+		// Timer expired.
+		event.m_timeout = true;
+	}
+	else
+	{
+		// unknown error
+		wxSocket::DoHandleConnectTimer( err );
+	}
+	
+	if ( ( m_pHandler != NULL ) &&
+		 ( GetFlags() & wxSOCKET_WAIT_CONNECT_FLAG ) )
+	{
+		m_pHandler->ProcessEvent( event );
+	}
+}
+
+
+
+void wxSocketClient::handle_resolve(const asio::error_code& err,
+									tcp::resolver::iterator endpoint_iterator)
+{
+	// this function should only be called during an async connect.
+	
+	if (!err)
+    {
+		// Attempt a connection to the first endpoint in the list. Each endpoint
+		// will be tried until we successfully establish a connection.
+		tcp::endpoint endpoint = *endpoint_iterator;
+		m_Peer.GetEndpoint() = endpoint;
+		m_Socket.async_connect(endpoint,
+							   boost::bind(&wxSocketClient::handle_connect,
+										   this,
+										   asio::placeholders::error, 
+										   ++endpoint_iterator));
+    }
+    else
+    {
+		// resolving failed.  :(
+		InterpretErrorCode(err);
+		
+		m_connected = false;
+		m_establishing = false;
+		
+		// cancel any asynchronous waits in progress.
+		m_ConnectTimer.cancel();
+
+		// TODO:  send an event notifying resolve failed
+    }	
+}
+
+
+void wxSocketClient::handle_connect(const asio::error_code& err,
+									tcp::resolver::iterator endpoint_iterator)
+{
+	if (!err)
+    {
+		wxASSERT( m_Socket.is_open() );
+		
+		m_connected = true;
+		m_establishing = false;
+		
+		// cancel any asynchronous waits in progress.
+		m_ConnectTimer.cancel();
+		
+		// The connection was successful. Notify our event handler
+		if ( ( m_pHandler != NULL ) &&
+			 ( GetFlags() & wxSOCKET_CONNECTION_FLAG ) )
+		{
+			wxSocketEvent connect_event( m_id );
+			connect_event.SetEventObject( &m_Peer );
+			connect_event.m_event 		= wxSOCKET_CONNECTION;
+			connect_event.m_clientData 	= m_clientData;
+
+			m_pHandler->ProcessEvent( connect_event );
+		}
+    }
+    else if (endpoint_iterator != tcp::resolver::iterator())
+    {
+		// The connection failed. Try the next endpoint in the list.
+		m_Socket.close();
+		tcp::endpoint endpoint = *endpoint_iterator;
+		m_Peer.GetEndpoint() = endpoint;
+		m_Socket.async_connect(endpoint,
+							   boost::bind(&wxSocketClient::handle_connect,
+										   this,
+										   asio::placeholders::error,
+										   ++endpoint_iterator));
+    }
+    else
+    {
+		// At this point, connecting to all resolved endpoints failed.
+		// spit out and store the error.
+		InterpretErrorCode(err);
+		
+		m_connected = false;
+		m_establishing = false;
+
+		// cancel any asynchronous waits in progress.
+		m_ConnectTimer.cancel();
+
+		// The connection failed. Notify our event handler
+		if ( ( m_pHandler != NULL ) &&
+			( GetFlags() & wxSOCKET_CONNECTION_FLAG ) )
+		{
+			wxSocketEvent connect_event( m_id );
+			connect_event.SetEventObject( &m_Peer );
+			connect_event.m_event		= wxSOCKET_CONNECTION;
+			connect_event.m_success		= false;
+			connect_event.m_clientData 	= m_clientData;
+
+			m_pHandler->ProcessEvent( connect_event );
+		}		
+    }
+}
+
+
+
+
+
+
+// ==========================================================================
+#pragma mark - wxDatagramSocket
+// wxDatagramSocket
+// ==========================================================================
+
+/* NOTE: experimental stuff - might change */
+
+wxDatagramSocket::wxDatagramSocket( const wxUDPIPendpoint& addr,
+                                    wxSocketFlags flags )
+                : wxSocketBase( flags, wxSOCKET_DATAGRAM ),
+m_Socket		( wxSocketServiceHandler::GetServiceForThread() )
+{
+}
+
+wxDatagramSocket& wxDatagramSocket::RecvFrom( wxUDPIPendpoint& addr,
+                                              void* buf,
+                                              wxUint32 nBytes )
+{
+	// Mask read events
+	m_reading = true;
+	
+	m_lcount = _Read(buf, nBytes,addr);
+	
+	// If in wxSOCKET_WAITALL mode, all bytes should have been read.
+	if (m_flags & wxSOCKET_WAITALL)
+		m_error = (m_lcount != nBytes);
+	else
+		m_error = (m_lcount == 0);
+	
+	// Allow read events from now on
+	m_reading = false;
+	
+	return *this;
+}
+
+wxDatagramSocket& wxDatagramSocket::SendTo( const wxUDPIPendpoint& addr,
+                                            const void* buf,
+                                            wxUint32 nBytes )
+{
+	// Mask write events
+	m_writing = true;
+	
+	m_lcount = _Write(buf, nBytes,addr);
+	
+	// If in wxSOCKET_WAITALL mode, all bytes should have been written.
+	if (m_flags & wxSOCKET_WAITALL)
+		m_error = (m_lcount != nBytes);
+	else
+		m_error = (m_lcount == 0);
+	
+	// Allow write events again
+	m_writing = false;
+	
+	return *this;
+}
+
+
+bool wxDatagramSocket::SetLocal(wxIPendpoint& local)
+{
+	bool output = false;
+	
+	wxUDPIPendpoint * pEndpoint = dynamic_cast< wxUDPIPendpoint * > ( &local );
+	
+	if ( pEndpoint != NULL )
+	{
+		asio::error_code ec;
+		m_Socket.bind( pEndpoint->GetEndpoint(), ec );
+		
+		output = InterpretErrorCode(ec);
+	}
+	
+	return output;
+}
+
+
+
+bool wxDatagramSocket::GetLocal(wxIPendpoint& addr_man) const
+{
+	bool output = false;
+	
+	wxUDPIPendpoint * pEndpoint = dynamic_cast< wxUDPIPendpoint * > ( &addr_man );
+	
+	if ( pEndpoint != NULL )
+	{
+		asio::error_code ec;
+		
+		*pEndpoint = m_Socket.local_endpoint(ec);
+		
+		output = InterpretErrorCode(ec);
+	}
+	
+	return output;
+}
+
+
+
+bool wxDatagramSocket::GetPeer(wxIPendpoint& addr_man) const
+{
+	bool output = false;
+	
+	wxUDPIPendpoint * pEndpoint = dynamic_cast< wxUDPIPendpoint * > ( &addr_man );
+	
+	if ( pEndpoint != NULL )
+	{
+		if ( m_Socket.is_open() )
+		{
+			asio::error_code ec;
+			
+			*pEndpoint = m_Socket.remote_endpoint(ec);
+			
+			output = InterpretErrorCode(ec);
+		}
+	}
+	
+	return output;
+}
+
+
+
+void wxDatagramSocket::InterruptWait()
+{
+	wxSocketBase::InterruptWait();
+	
+	asio::error_code ec;
+	
+	// cancel any pending asynchronous events.
+	m_Socket.cancel( ec );
+	
+	InterpretErrorCode(ec);
+}
+
+
+
+
+void wxDatagramSocket::SetFlags(wxSocketFlags flags)
+{
+	wxSocketBase::SetFlags( flags );
+	
+	asio::error_code ec;
+	
+	asio::socket_base::non_blocking_io 	non_blocking_command(false);
+	asio::socket_base::do_not_route		do_not_route_option(false);
+//	asio::socket_base::keep_alive 		keep_alive_option(false); // not applicable to connectionless UDP
+	asio::socket_base::broadcast 		broadcast_option(false);
+	
+	if ( m_flags & wxSOCKET_NOWAIT )
+	{
+		non_blocking_command.set(true);
+	}
+	
+	if( m_flags & wxSOCKET_WAITALL )
+	{
+		//		non_blocking_command.set(false);
+	}		
+	
+	if ( m_flags & wxSOCKET_BLOCK )
+	{
+		non_blocking_command.set(false);
+	}
+	
+	if ( m_flags & wxSOCKET_DO_NOT_ROUTE )
+	{
+		do_not_route_option = true;
+	}
+	
+//	if ( m_flags & wxSOCKET_KEEP_ALIVE )
+//	{
+//		keep_alive_option = true;
+//	}
+	
+	if ( m_flags & wxSOCKET_BROADCAST )
+	{
+		broadcast_option = true;
+	}
+	
+	
+	m_Socket.io_control( non_blocking_command, ec );
+	
+	if ( !ec )
+		m_Socket.set_option( do_not_route_option, ec );
+	
+//	if ( !ec )
+//		m_Socket.set_option( keep_alive_option, ec );
+	
+	if ( !ec )
+		m_Socket.set_option( broadcast_option, ec );
+	
+	InterpretErrorCode(ec);
+}
+
+
+
+size_t	wxDatagramSocket::DataReadable()
+{
+	asio::error_code ec;
+	asio::socket_base::bytes_readable command(true);
+	m_Socket.io_control(command,ec);
+	std::size_t bytes_readable = 0;
+	
+	if ( InterpretErrorCode(ec) )
+		bytes_readable = command.get();
+	
+	return bytes_readable;
+}
+
+
+
+wxUint32 wxDatagramSocket::_Write(const void *buffer, wxUint32 nbytes,const wxUDPIPendpoint & rPeer)
+{
+	wxUint32 total = 0;
+	
+	// If the socket is invalid or parameters are ill, return immediately
+	if (!m_Socket.is_open() || !buffer || !nbytes)
+		return 0;
+	
+	// Possible combinations (they are checked in this order)
+	// wxSOCKET_NOWAIT
+	// wxSOCKET_WAITALL (with or without wxSOCKET_BLOCK)
+	// wxSOCKET_BLOCK
+	// wxSOCKET_NONE
+	//
+	if (m_flags & wxSOCKET_NOWAIT)
+	{
+		m_Socket.async_send_to( asio::buffer(buffer, nbytes),
+							   rPeer.GetEndpoint(),
+							   boost::bind(&wxDatagramSocket::handle_write_request, 
+										   this,
+										   boost::ref(rPeer),
+										   asio::placeholders::error,
+										   asio::placeholders::bytes_transferred ) );
+	}
+	else
+	{
+		asio::error_code ec;
+		
+		if ( m_flags & wxSOCKET_BLOCK )
+		{
+			// We're doing a synchronous write because we're in blocking mode.
+			total = m_Socket.send_to( asio::buffer(buffer, nbytes),
+									 rPeer.GetEndpoint(),
+									 0,
+									 ec );
+			
+			DoHandleWriteRequest(rPeer, ec, total);
+			
+			wxASSERT( total == nbytes );
+			
+			// cancel any asynchronous waits in progress.
+			m_WriteTimer.cancel();
+		}
+	}
+	
+	return total;
+}
+
+
+wxUint32 wxDatagramSocket::_Read(void *buffer, wxUint32 nbytes,wxUDPIPendpoint & rPeer)
+{
+	wxUint32 total = 0;
+	
+	// If the socket is invalid or parameters are ill, return immediately
+	if (!m_Socket.is_open() || !buffer || !nbytes)
+		return 0;
+	
+	// Possible combinations (they are checked in this order)
+	// wxSOCKET_NOWAIT
+	// wxSOCKET_WAITALL (with or without wxSOCKET_BLOCK)
+	// wxSOCKET_BLOCK
+	// wxSOCKET_NONE
+	//
+	if (m_flags & wxSOCKET_NOWAIT)
+	{
+		m_Socket.async_receive_from(asio::buffer(buffer, nbytes),
+									rPeer.GetEndpoint(),
+									boost::bind(&wxDatagramSocket::handle_read_content, 
+												this,
+												boost::ref(rPeer),
+												asio::placeholders::error,
+												asio::placeholders::bytes_transferred) );
+	}
+	else
+	{
+		asio::error_code ec;
+		
+		if ( m_flags & wxSOCKET_BLOCK )
+		{
+			// We're doing a synchronous read because we're in blocking mode.
+			total = m_Socket.receive_from(asio::buffer(buffer, nbytes),
+										  rPeer.GetEndpoint(),
+										  0,
+										  ec );
+			
+			DoHandleReadContent( rPeer, ec, total );
+			
+			wxASSERT( total == nbytes );
+			
+			// cancel any asynchronous waits in progress.
+			m_ReadTimer.cancel();			
+		}
+	}
+	
+	return total;
+}
+
+
+
+void wxDatagramSocket::DoHandleWriteRequest	(const wxUDPIPendpoint & WXUNUSED( rPeer ), const asio::error_code& err, size_t bytes_transferred)
+{
+	wxSocketBase::DoHandleWriteRequest( err, bytes_transferred );
+}
+
+
+void wxDatagramSocket::DoHandleReadContent	(wxUDPIPendpoint & WXUNUSED( rPeer ), const asio::error_code& err, size_t bytes_transferred)
+{
+	wxSocketBase::DoHandleReadContent( err, bytes_transferred );
+}
+
+
+bool wxDatagramSocket::GetOption(int level, int optname, void *optval, size_t *optlen)
+{
+	asio::error_code ec;
+	
+	asio::detail::socket_ops::getsockopt(m_Socket.native(), level, optname, optval, optlen, ec);
+	
+	return InterpretErrorCode(ec);
+}
+
+
+
+bool wxDatagramSocket::SetOption(int level, int optname, const void *optval,
+								 size_t optlen)
+{
+	asio::error_code ec;
+	
+	asio::detail::socket_ops::setsockopt(m_Socket.native(), level, optname, optval, optlen, ec);
+	
+	return InterpretErrorCode(ec);
+}
+
+
+
 // ==========================================================================
+#pragma mark - wxSocketModule
 // wxSocketModule
 // ==========================================================================
 
Index: src/common/appbase.cpp
===================================================================
--- src/common/appbase.cpp	(revision 52157)
+++ src/common/appbase.cpp	(working copy)
@@ -524,12 +524,12 @@ void wxConsoleAppTraitsBase::RemoveFromP
     // nothing to do
 }
 
-#if wxUSE_SOCKETS
-GSocketGUIFunctionsTable* wxConsoleAppTraitsBase::GetSocketGUIFunctionsTable()
-{
-    return NULL;
-}
-#endif
+//#if wxUSE_SOCKETS
+//GSocketGUIFunctionsTable* wxConsoleAppTraitsBase::GetSocketGUIFunctionsTable()
+//{
+//    return NULL;
+//}
+//#endif
 
 // ----------------------------------------------------------------------------
 // wxAppTraits
Index: src/common/appcmn.cpp
===================================================================
--- src/common/appcmn.cpp	(revision 52157)
+++ src/common/appcmn.cpp	(working copy)
@@ -676,16 +676,16 @@ void wxGUIAppTraitsBase::RemoveFromPendi
     #error "Must include correct GSocket header here"
 #endif
 
-GSocketGUIFunctionsTable* wxGUIAppTraitsBase::GetSocketGUIFunctionsTable()
-{
-#if defined(__WXMAC__) && !defined(__DARWIN__)
-    // NB: wxMac CFM does not have any GUI-specific functions in gsocket.c and
-    //     so it doesn't need this table at all
-    return NULL;
-#else // !__WXMAC__ || __DARWIN__
-    static GSocketGUIFunctionsTableConcrete table;
-    return &table;
-#endif // !__WXMAC__ || __DARWIN__
-}
+//GSocketGUIFunctionsTable* wxGUIAppTraitsBase::GetSocketGUIFunctionsTable()
+//{
+//#if defined(__WXMAC__) && !defined(__DARWIN__)
+//    // NB: wxMac CFM does not have any GUI-specific functions in gsocket.c and
+//    //     so it doesn't need this table at all
+//    return NULL;
+//#else // !__WXMAC__ || __DARWIN__
+//    static GSocketGUIFunctionsTableConcrete table;
+//    return &table;
+//#endif // !__WXMAC__ || __DARWIN__
+//}
 
 #endif
Index: src/common/http.cpp
===================================================================
--- src/common/http.cpp	(revision 52157)
+++ src/common/http.cpp	(working copy)
@@ -191,7 +191,7 @@ bool wxHTTP::ParseHeaders()
 
 bool wxHTTP::Connect(const wxString& host, unsigned short port)
 {
-    wxIPV4address *addr;
+    wxTCPIPendpoint *addr;
 
     if (m_addr) {
         delete m_addr;
@@ -199,7 +199,7 @@ bool wxHTTP::Connect(const wxString& hos
         Close();
     }
 
-    m_addr = addr = new wxIPV4address();
+    m_addr = addr = new wxTCPIPendpoint();
 
     if (!addr->Hostname(host)) {
         delete m_addr;
@@ -210,7 +210,7 @@ bool wxHTTP::Connect(const wxString& hos
 
     if ( port )
         addr->Service(port);
-    else if (!addr->Service(wxT("http")))
+    else if (!addr->Service(wxString(wxT("http"))))
         addr->Service(80);
 
     SetHeader(wxT("Host"), host);
@@ -218,7 +218,7 @@ bool wxHTTP::Connect(const wxString& hos
     return true;
 }
 
-bool wxHTTP::Connect(wxSockAddress& addr, bool WXUNUSED(wait))
+bool wxHTTP::Connect(wxTCPIPendpoint& addr, bool wait)
 {
     if (m_addr) {
         delete m_addr;
@@ -226,10 +226,7 @@ bool wxHTTP::Connect(wxSockAddress& addr
     }
 
     m_addr = addr.Clone();
-
-    wxIPV4address *ipv4addr = wxDynamicCast(&addr, wxIPV4address);
-    if (ipv4addr)
-        SetHeader(wxT("Host"), ipv4addr->OrigHostname());
+//        SetHeader(wxT("Host"), tcpaddr->OrigHostname());
 
     return true;
 }
@@ -391,7 +388,8 @@ wxInputStream *wxHTTP::GetInputStream(co
 
     // We set m_connected back to false so wxSocketBase will know what to do.
 #ifdef __WXMAC__
-    wxSocketClient::Connect(*m_addr , false );
+    wxSocketClient::Connect(*m_addr );
+	if ( ! ( m_flags & ( wxSOCKET_WAITALL | wxSOCKET_BLOCK ) ) )
     wxSocketClient::WaitOnConnect(10);
 
     if (!wxSocketClient::IsConnected())
Index: src/common/ftp.cpp
===================================================================
--- src/common/ftp.cpp	(revision 52157)
+++ src/common/ftp.cpp	(working copy)
@@ -32,6 +32,9 @@
 
 #if wxUSE_PROTOCOL_FTP
 
+#include "wx/sckaddr.h"
+#include "wx/socket.h"
+
 #ifndef WX_PRECOMP
     #include <stdlib.h>
     #include "wx/string.h"
@@ -40,8 +43,6 @@
     #include "wx/intl.h"
 #endif // WX_PRECOMP
 
-#include "wx/sckaddr.h"
-#include "wx/socket.h"
 #include "wx/url.h"
 #include "wx/sckstrm.h"
 #include "wx/protocol/protocol.h"
@@ -110,9 +111,9 @@ wxFTP::~wxFTP()
 // wxFTP connect and login methods
 // ----------------------------------------------------------------------------
 
-bool wxFTP::Connect(wxSockAddress& addr, bool WXUNUSED(wait))
+bool wxFTP::Connect(wxTCPIPendpoint& addr, bool wait)
 {
-    if ( !wxProtocol::Connect(addr) )
+    if ( !wxProtocol::Connect(addr,wait) )
     {
         m_lastError = wxPROTO_NETERR;
         return false;
@@ -158,7 +159,7 @@ bool wxFTP::Connect(wxSockAddress& addr,
 
 bool wxFTP::Connect(const wxString& host)
 {
-    wxIPV4address addr;
+    wxTCPIPendpoint addr;
     addr.Hostname(host);
     addr.Service(wxT("ftp"));
 
@@ -641,8 +642,8 @@ wxSocketBase *wxFTP::AcceptIfActive(wxSo
     return sock;
 }
 
-wxString wxFTP::GetPortCmdArgument(const wxIPV4address& addrLocal,
-                                   const wxIPV4address& addrNew)
+wxString wxFTP::GetPortCmdArgument(const wxIPendpoint& addrLocal,
+                                   const wxIPendpoint& addrNew)
 {
     // Just fills in the return value with the local IP
     // address of the current socket.  Also it fill in the
@@ -664,7 +665,7 @@ wxString wxFTP::GetPortCmdArgument(const
 wxSocketBase *wxFTP::GetActivePort()
 {
     // we need an address to listen on
-    wxIPV4address addrNew, addrLocal;
+    wxTCPIPendpoint addrNew, addrLocal;
     GetLocal(addrLocal);
     addrNew.AnyAddress();
     addrNew.Service(0); // pick an open port number.
@@ -726,7 +727,7 @@ wxSocketBase *wxFTP::GetPassivePort()
                         a[5];
     wxUint16 port = (wxUint16)(a[0] << 8 | a[1]);
 
-    wxIPV4address addr;
+    wxTCPIPendpoint addr;
     addr.Hostname(hostaddr);
     addr.Service(port);
 
Index: src/common/url.cpp
===================================================================
--- src/common/url.cpp	(revision 52157)
+++ src/common/url.cpp	(working copy)
@@ -264,7 +264,7 @@ wxInputStream *wxURL::GetInputStream()
 #endif // wxUSE_URL_NATIVE
 
 #if wxUSE_SOCKETS
-    wxIPV4address addr;
+    wxTCPIPendpoint addr;
 
     // m_protoinfo is NULL when we use a proxy
     if (!m_useProxy && m_protoinfo->m_needhost)
@@ -334,7 +334,7 @@ void wxURL::SetDefaultProxy(const wxStri
 
         wxString hostname = tmp_str(0, pos),
         port = tmp_str(pos+1, tmp_str.length()-pos);
-        wxIPV4address addr;
+        wxTCPIPendpoint addr;
 
         if (!addr.Hostname(hostname))
             return;
@@ -367,7 +367,7 @@ void wxURL::SetProxy(const wxString& url
         wxString tmp_str;
         wxString hostname, port;
         int pos;
-        wxIPV4address addr;
+        wxTCPIPendpoint addr;
 
         tmp_str = url_proxy;
         pos = tmp_str.Find(wxT(':'));
Index: src/common/sckaddr.cpp
===================================================================
--- src/common/sckaddr.cpp	(revision 52157)
+++ src/common/sckaddr.cpp	(working copy)
@@ -18,6 +18,9 @@
 
 #if wxUSE_SOCKETS
 
+#include "wx/sckaddr.h"
+#include "wx/socket.h"
+
 #ifndef WX_PRECOMP
     #include "wx/object.h"
     #include "wx/log.h"
@@ -32,20 +35,118 @@
     #endif
 #endif // !WX_PRECOMP
 
-#include "wx/gsocket.h"
-#include "wx/socket.h"
-#include "wx/sckaddr.h"
+#include <asio/ip/host_name.hpp>
+#include <boost/bind.hpp>
+
+using namespace asio;
+
 
 IMPLEMENT_ABSTRACT_CLASS(wxSockAddress, wxObject)
-IMPLEMENT_ABSTRACT_CLASS(wxIPaddress, wxSockAddress)
-IMPLEMENT_DYNAMIC_CLASS(wxIPV4address, wxIPaddress)
-#if wxUSE_IPV6
-IMPLEMENT_DYNAMIC_CLASS(wxIPV6address, wxIPaddress)
-#endif
+IMPLEMENT_DYNAMIC_CLASS(wxIPaddress, wxSockAddress)
+IMPLEMENT_ABSTRACT_CLASS(wxIPendpoint, wxIPaddress)
+IMPLEMENT_DYNAMIC_CLASS(wxTCPIPendpoint, wxIPendpoint)
+IMPLEMENT_DYNAMIC_CLASS(wxUDPIPendpoint, wxIPendpoint)
+IMPLEMENT_DYNAMIC_CLASS(wxUNIXendpoint, wxTCPIPendpoint)
+
 #if defined(__UNIX__) && !defined(__WINDOWS__) && !defined(__WINE__) && (!defined(__WXMAC__) || defined(__DARWIN__))
-IMPLEMENT_DYNAMIC_CLASS(wxUNIXaddress, wxSockAddress)
+//IMPLEMENT_DYNAMIC_CLASS(wxUNIXendpoint, wxSockAddress)
 #endif
 
+
+#if defined(HAVE_GETSERVBYNAME) && wxUSE_THREADS
+static wxMutex servLock;
+#endif
+
+#if defined(HAVE_GETSERVBYNAME)
+static struct servent * deepCopyServent(struct servent *s,
+										const struct servent *se,
+										char *buffer, int size)
+{
+	/* copy plain old structure */
+	memcpy(s, se, sizeof(struct servent));
+	
+	/* copy name */
+	int len = strlen(s->s_name);
+	if (len >= size)
+	{
+		return NULL;
+	}
+	memcpy(buffer, s->s_name, len);
+	buffer[len] = '\0';
+	s->s_name = buffer;
+	
+	/* track position in the buffer */
+	int pos = len + 1;
+	
+	/* copy protocol */
+	len = strlen(s->s_proto);
+	if (pos + len >= size)
+	{
+		return NULL;
+	}
+	memcpy(buffer + pos, s->s_proto, len);
+	buffer[pos + len] = '\0';
+	s->s_proto = buffer + pos;
+	
+	/* track position in the buffer */
+	pos += len + 1;
+	
+	/* ensure pointer alignment */
+	unsigned int misalign = sizeof(char *) - pos%sizeof(char *);
+	if(misalign < sizeof(char *))
+		pos += misalign;
+	
+	/* leave space for pointer list */
+	char **p = s->s_aliases, **q;
+	char **s_aliases = (char **)(buffer + pos);
+	while(*(p++) != 0)
+		pos += sizeof(char *);
+	
+	/* copy addresses and fill new pointer list */
+	for (p = s->s_aliases, q = s_aliases; *p != 0; p++, q++){
+		len = strlen(*p);
+		if (size <= pos + len)
+		{
+			return NULL;
+		}
+		memcpy(buffer + pos, *p, len); /* copy content */
+		buffer[pos + len] = '\0';
+		*q = buffer + pos; /* set copied pointer to copied content */
+		pos += len + 1;
+	}
+	*++q = 0; /* null terminate the pointer list */
+	s->s_aliases = s_aliases; /* copy pointer to pointers */
+	return s;
+}
+#endif
+
+struct servent *wxGetservbyname_r(const char *port, const char *protocol,
+								  struct servent *serv, void *buffer, int size)
+{
+	struct servent *se = NULL;
+#if defined(HAVE_FUNC_GETSERVBYNAME_R_6)
+	if (getservbyname_r(port, protocol, serv, (char*)buffer, size, &se))
+		se = NULL;
+#elif defined(HAVE_FUNC_GETSERVBYNAME_R_5)
+	se = getservbyname_r(port, protocol, serv, (char*)buffer, size);
+#elif defined(HAVE_FUNC_GETSERVBYNAME_R_4)
+	if (getservbyname_r(port, protocol, serv, (struct servent_data*) buffer))
+		se = NULL;
+	else
+		se = serv;
+#elif defined(HAVE_GETSERVBYNAME)
+#	if wxUSE_THREADS
+		wxMutexLocker locker(servLock);
+#	endif
+	se = getservbyname(port, protocol);
+	if (se)
+		se = deepCopyServent(serv, se, (char*)buffer, size);
+#endif
+	return se;
+}
+
+
+
 // ---------------------------------------------------------------------------
 // wxSockAddress
 // ---------------------------------------------------------------------------
@@ -62,285 +163,644 @@ void wxSockAddress::Init()
 wxSockAddress::wxSockAddress()
 {
     Init();
-
-    m_address = GAddress_new();
 }
 
 wxSockAddress::wxSockAddress(const wxSockAddress& other)
     : wxObject()
 {
     Init();
-
-    m_address = GAddress_copy(other.m_address);
 }
 
 wxSockAddress::~wxSockAddress()
 {
-  GAddress_destroy(m_address);
-}
-
-void wxSockAddress::SetAddress(GAddress *address)
-{
-    if ( address != m_address )
-    {
-        GAddress_destroy(m_address);
-        m_address = GAddress_copy(address);
-    }
 }
 
 wxSockAddress& wxSockAddress::operator=(const wxSockAddress& addr)
 {
-  SetAddress(addr.GetAddress());
   return *this;
 }
 
-void wxSockAddress::Clear()
-{
-  GAddress_destroy(m_address);
-  m_address = GAddress_new();
-}
 
 // ---------------------------------------------------------------------------
 // wxIPaddress
 // ---------------------------------------------------------------------------
 
 wxIPaddress::wxIPaddress()
-            : wxSockAddress()
+: wxSockAddress(),
+m_id( wxID_ANY )
 {
 }
 
 wxIPaddress::wxIPaddress(const wxIPaddress& other)
-            : wxSockAddress(other)
+: wxSockAddress	( other ),
+m_HostName		( other.m_HostName ),
+m_IPAddress		( other.m_IPAddress ),
+m_id ( other.m_id )
 {
 }
 
-wxIPaddress::~wxIPaddress()
+wxIPaddress::wxIPaddress(const wxString& name )
+			: wxSockAddress(),
+			m_id( wxID_ANY )
 {
+	asio::error_code ec;
+	
+	asio::ip::address_v4 ipv4 = asio::ip::address_v4::from_string( name.utf8_str(), ec );
+	
+	if ( ! ec )
+	{
+		m_IPAddress = ipv4;
+	}
+	else
+	{
+		asio::ip::address_v6 ipv6 = asio::ip::address_v6::from_string( name.utf8_str(), ec );
+		
+		if ( ! ec )
+		{
+			m_IPAddress = ipv6;
+		}
+		else
+		{
+			m_HostName = name;
+		}
+	}
 }
 
-// ---------------------------------------------------------------------------
-// wxIPV4address
-// ---------------------------------------------------------------------------
 
-wxIPV4address::wxIPV4address()
-             : wxIPaddress()
+wxIPaddress::wxIPaddress(unsigned long addr )
+: wxSockAddress(),
+m_IPAddress( asio::ip::address_v4::address_v4( addr ) ),
+m_id( wxID_ANY )
 {
 }
 
-wxIPV4address::wxIPV4address(const wxIPV4address& other)
-             : wxIPaddress(other)
+
+wxIPaddress::~wxIPaddress()
 {
 }
 
-wxIPV4address::~wxIPV4address()
+
+
+bool wxIPaddress::IsLocalHost() const
 {
+	return m_IPAddress == asio::ip::address_v4::loopback() || m_IPAddress == asio::ip::address_v6::loopback();
 }
 
-bool wxIPV4address::Hostname(const wxString& name)
+
+
+bool wxIPaddress::LocalHost()
 {
-  // Some people are sometimes fool.
-  if (name.empty())
+	bool output = false;
+	
+	if ( m_IPAddress.is_v4() )
   {
-    wxLogWarning( _("Trying to solve a NULL hostname: giving up") );
-    return false;
+		m_IPAddress = asio::ip::address_v4::loopback();
+		m_HostName = wxT("127.0.0.1");
+		output = true;
   }
-  m_origHostname = name;
-  return (GAddress_INET_SetHostName(m_address, name.mb_str()) == GSOCK_NOERROR);
+	else if ( m_IPAddress.is_v6() )
+	{
+		m_IPAddress = asio::ip::address_v6::loopback();
+		m_HostName = wxT("::1");
+		output = true;
+	}
+	
+	return output;
 }
 
-bool wxIPV4address::Hostname(unsigned long addr)
+
+
+bool wxIPaddress::AnyAddress()
 {
-  bool rv = (GAddress_INET_SetHostAddress(m_address, addr) == GSOCK_NOERROR);
-  if (rv)
-      m_origHostname = Hostname();
-  else
-      m_origHostname = wxEmptyString;
-  return rv;
+	bool output = false;
+	
+	if ( m_IPAddress.is_v4() )
+	{
+		m_IPAddress = asio::ip::address();
+		m_HostName = wxEmptyString;
+		output = true;
+	}
+	else if ( m_IPAddress.is_v6() )
+	{
+		m_IPAddress = asio::ip::address_v6::any();
+		m_HostName = wxEmptyString;
+		output = true;
+	}
+	
+	return output;
 }
 
-bool wxIPV4address::Service(const wxString& name)
+
+
+wxString wxIPaddress::IPAddress() const
 {
-  return (GAddress_INET_SetPortName(m_address, name.mb_str(), "tcp") == GSOCK_NOERROR);
+	return wxString::FromUTF8( m_IPAddress.to_string().c_str() );
 }
 
-bool wxIPV4address::Service(unsigned short port)
+
+bool wxIPaddress::Hostname(const wxString& name)
 {
-  return (GAddress_INET_SetPort(m_address, port) == GSOCK_NOERROR);
+	bool output = false;
+	
+	asio::error_code ec;
+	
+	asio::ip::address_v6 ipv6 = asio::ip::address_v6::from_string( name.utf8_str(), ec );
+
+	if ( ! ec )
+	{
+		m_IPAddress = ipv6;
+		m_HostName = wxEmptyString;
+		output = true;
+	}
+	else
+	{
+		asio::ip::address_v4 ipv4 = asio::ip::address_v4::from_string( name.utf8_str(), ec );
+
+		if ( ! ec )
+		{
+			m_IPAddress = ipv4;
+			m_HostName = wxEmptyString;
+			output = true;
+		}
+		else if ( name != wxEmptyString )
+		{
+			// Then the "hostname" is not an IP address, but should be treated
+			// as a DNS-resolvable host name.
+			m_HostName = name;
+			
+			// FIXME:  resolve the name to an IP address?
+		}
+		else
+		{
+			// Sometimes people are fools.  :P
+			
+			wxLogWarning( _("Trying to resolve a NULL hostname: giving up") );
+		}
+	}
+	
+	return output;
 }
 
-bool wxIPV4address::LocalHost()
+
+bool wxIPaddress::Hostname( unsigned long addr)
 {
-  return (GAddress_INET_SetHostName(m_address, "localhost") == GSOCK_NOERROR);
+	m_IPAddress = asio::ip::address_v4( addr );
+	return true;
 }
 
-bool wxIPV4address::IsLocalHost() const
+
+
+bool wxIPaddress::Hostname(unsigned char addr[16])
 {
-  return (Hostname() == wxT("localhost") || IPAddress() == wxT("127.0.0.1"));
+	asio::ip::address_v6::bytes_type addr_array;
+	
+	wxASSERT_MSG( addr_array.size() == WXSIZEOF( addr ), wxT("An IPv6 address must be 16 bytes!  Something changed.") );
+	
+	memcpy( addr_array.c_array(), addr, addr_array.size() );
+
+	m_IPAddress = asio::ip::address_v6::address_v6( addr_array );
+	
+	return true;
 }
 
-bool wxIPV4address::AnyAddress()
+
+
+wxString wxIPaddress::LocalHostname()
 {
-  return (GAddress_INET_SetAnyAddress(m_address) == GSOCK_NOERROR);
+	asio::error_code ec;
+	
+	std::string name = asio::ip::host_name( ec );
+	
+	wxString output;
+	
+	if ( !ec )
+	{
+		output.FromUTF8( name.c_str() );
+	}
+	else
+	{
+		wxFAIL_MSG( wxT("Failed to retrieve the machine's hostname!") );
+	}
+	
+	return output;
 }
 
-wxString wxIPV4address::Hostname() const
+
+
+// ---------------------------------------------------------------------------
+// wxIPendpoint
+// ---------------------------------------------------------------------------
+
+
+wxIPendpoint::wxIPendpoint()
+: wxIPaddress(),
+m_Port ( 0 ),
+m_pHandler ( NULL )
 {
-   char hostname[1024];
+}
+
 
-   hostname[0] = 0;
-   GAddress_INET_GetHostName(m_address, hostname, 1024);
-   return wxString::FromAscii(hostname);
+wxIPendpoint::wxIPendpoint(const wxIPendpoint& other)
+: wxIPaddress	( other ),
+m_ServiceName	( other.m_ServiceName ),
+m_Port			( other.m_Port ),
+m_pHandler		( other.m_pHandler )
+{
 }
 
-unsigned short wxIPV4address::Service() const
+
+wxIPendpoint::wxIPendpoint(const wxIPaddress& name, const wxString& service )
+: wxIPaddress( name ),
+m_Port( 0 ),
+m_pHandler ( NULL )
 {
-  return GAddress_INET_GetPort(m_address);
+	unsigned long port = 0;
+	if ( ( service.ToULong( &port ) ) &&
+		( port < ( 1 << 15 ) ) )
+	{
+		m_Port		= port;
+	}
+	else
+	{
+		m_ServiceName = service;
+	}
 }
 
-wxSockAddress *wxIPV4address::Clone() const
+
+
+wxIPendpoint::wxIPendpoint(const wxIPaddress& name, unsigned short port )
+: wxIPaddress( name ),
+m_Port( port ),
+m_pHandler ( NULL )
 {
-    wxIPV4address *addr = new wxIPV4address(*this);
-    addr->m_origHostname = m_origHostname;
-    return addr;
 }
 
-wxString wxIPV4address::IPAddress() const
+
+
+
+
+bool wxIPendpoint::Service(const wxString& name)
 {
-    unsigned long raw =  GAddress_INET_GetHostAddress(m_address);
-    return wxString::Format(_T("%lu.%lu.%lu.%lu"),
-                (raw>>24) & 0xff,
-                (raw>>16) & 0xff,
-                (raw>>8) & 0xff,
-                raw & 0xff
-        );
+	m_ServiceName = name;
+	
+	
+	
+	struct servent * se = NULL;
+	
+	if ( TransportType() == wxTCP )
+		se = wxGetservbyname_r(name.ToUTF8(), "tcp",
+							   NULL, NULL, 0);
+	else if ( TransportType() == wxUDP )
+		se = wxGetservbyname_r(name.ToUTF8(), "udp",
+							   NULL, NULL, 0);
+	
+	bool output = false;
+	
+	if ( se != NULL )
+	{
+		m_Port = se->s_port;
+		output = true;
+		
+		free( se );
+	}
+	
+	return output;
+}
+
+
+
+wxIPendpoint *wxIPendpoint::CreateEndpoint( wxTransportLayerType type )
+{
+	wxIPendpoint * pOutput = NULL;
+	
+	switch ( type )
+	{
+		case wxTCP:
+			pOutput = new wxTCPIPendpoint;
+			break;
+			
+		case wxUDP:
+			pOutput = new wxUDPIPendpoint;
+			break;
+			
+		case wxDCCP:
+		case wxSCTP:
+		default:
+			wxFAIL_MSG( wxT("This Transport Layer protocol is unimplemented.") );
+			break;
+	}
+	
+	return pOutput;
 }
 
-bool wxIPV4address::operator==(const wxIPV4address& addr) const
+
+wxIPendpoint * wxIPendpoint::CreateEndpoint( const wxIPaddress& name, const wxString& service )
 {
-    return Hostname().Cmp(addr.Hostname().c_str()) == 0 &&
-            Service() == addr.Service();
+	wxIPendpoint * pOutput = NULL;
+	
+	struct servent * se = NULL;
+	
+	se = wxGetservbyname_r(service.ToUTF8(), "tcp",
+						   NULL, NULL, 0);
+	
+	if ( se != NULL )
+	{
+		pOutput = new wxTCPIPendpoint( name, service );
+		pOutput->m_Port = se->s_port;
+	}
+	else
+	{
+		se = wxGetservbyname_r(service.ToUTF8(), "udp",
+							   NULL, NULL, 0);
+		
+		if ( se != NULL )
+		{
+			pOutput = new wxUDPIPendpoint( name, service );
+			pOutput->m_Port = se->s_port;
+		}
+	}
+	
+	if ( se != NULL )
+		free( se );
+	
+	return pOutput;
 }
 
-#if wxUSE_IPV6
+
+
 // ---------------------------------------------------------------------------
-// wxIPV6address
+// wxTCPIPendpoint
 // ---------------------------------------------------------------------------
 
-wxIPV6address::wxIPV6address()
-  : wxIPaddress()
+
+wxTCPIPendpoint::wxTCPIPendpoint( void )
+: wxIPendpoint()
+{
+}
+
+
+wxTCPIPendpoint::wxTCPIPendpoint(const wxTCPIPendpoint& other)
+: wxIPendpoint	( other ),
+m_Endpoint		( other.m_Endpoint )
+{
+}
+
+
+wxTCPIPendpoint::wxTCPIPendpoint(const wxIPaddress& name, const wxString& service )
+: wxIPendpoint( name, service )
+{
+	if ( m_Port != 0 )
+	{
+		m_Endpoint	= ip::tcp::endpoint( m_IPAddress, m_Port );
+	}
+}
+
+
+
+wxTCPIPendpoint::wxTCPIPendpoint(const wxIPaddress& name, unsigned short port )
+: wxIPendpoint( name, port ),
+m_Endpoint( m_IPAddress, m_Port )
 {
 }
 
-wxIPV6address::wxIPV6address(const wxIPV6address& other)
-             : wxIPaddress(other)
+
+wxTCPIPendpoint::wxTCPIPendpoint( const ip::tcp::endpoint & rEndpoint )
+: wxIPendpoint( wxString::FromUTF8( rEndpoint.address().to_string().c_str() ),
+			   rEndpoint.port() ),
+m_Endpoint( rEndpoint )
+{
+}
+
+
+
+wxTCPIPendpoint *wxTCPIPendpoint::Clone() const
+{
+    wxTCPIPendpoint *addr = new wxTCPIPendpoint(*this);
+    return addr;
+}
+
+
+
+bool wxTCPIPendpoint::Service(unsigned short port)
+{
+	m_Endpoint.port( port );
+	return true;
+}
+
+
+
+void wxTCPIPendpoint::DoSyncResolve( void )
 {
+	ip::tcp::resolver resolver( wxSocketServiceHandler::GetServiceForThread() );
+
+	asio::error_code ec;
+	tcp::resolver::iterator result = resolver.resolve( m_Endpoint, ec );
+	handle_resolve(ec, result);
 }
 
-wxIPV6address::~wxIPV6address()
+
+void wxTCPIPendpoint::DoAsyncResolve( void )
 {
+	ip::tcp::resolver resolver( wxSocketServiceHandler::GetServiceForThread() );
+
+	resolver.async_resolve( m_Endpoint, boost::bind(&wxTCPIPendpoint::handle_resolve, 
+													this,
+													asio::placeholders::error,
+													asio::placeholders::iterator) );
 }
 
-bool wxIPV6address::Hostname(const wxString& name)
+
+
+void wxTCPIPendpoint::handle_resolve(const asio::error_code& err,
+									 tcp::resolver::iterator endpoint_iterator)
 {
-  if (name.empty())
+	wxASSERT( m_pHandler != NULL );
+	
+	if (!err)
+    {
+		tcp::resolver::iterator end;
+
+		while ( endpoint_iterator != end )
+		{
+			tcp::endpoint endpoint = *endpoint_iterator;
+			wxTCPIPendpoint end_point = *this;
+			end_point.m_Endpoint = endpoint;
+			
+			wxResolveEvent event( GetId() );
+			event.SetEventObject( &end_point );
+			
+			m_pHandler->ProcessEvent( event );
+			
+			if ( ! event.ShouldContinueResolve() )
+				break;
+			
+			endpoint_iterator++;
+		}
+    }
+    else
   {
-    wxLogWarning( _("Trying to solve a NULL hostname: giving up") );
-    return false;
+		std::cout << "Error: " << err.message() << "\n";
+		
+		// TODO:  send an event notifying resolve failed
   }
-  return (GAddress_INET_SetHostName(m_address, name.mb_str()) == GSOCK_NOERROR);
 }
 
-bool wxIPV6address::Hostname(unsigned char[16] WXUNUSED(addr))
+
+
+// ---------------------------------------------------------------------------
+// wxUDPIPendpoint
+// ---------------------------------------------------------------------------
+
+
+wxUDPIPendpoint::wxUDPIPendpoint( void )
+: wxIPendpoint()
 {
-  return true;
 }
 
-bool wxIPV6address::Service(const wxString& name)
+
+wxUDPIPendpoint::wxUDPIPendpoint(const wxUDPIPendpoint& other)
+: wxIPendpoint	( other ),
+m_Endpoint		( other.m_Endpoint )
 {
-  return (GAddress_INET_SetPortName(m_address, name.mb_str(), "tcp") == GSOCK_NOERROR);
 }
 
-bool wxIPV6address::Service(unsigned short port)
+
+wxUDPIPendpoint::wxUDPIPendpoint(const wxIPaddress& name, const wxString& service )
+: wxIPendpoint( name, service )
+{
+	if ( m_Port != 0 )
+	{
+		m_Endpoint	= ip::udp::endpoint( m_IPAddress, m_Port );
+	}
+}
+
+
+
+wxUDPIPendpoint::wxUDPIPendpoint(const wxIPaddress& name, unsigned short port )
+: wxIPendpoint( name, port ),
+m_Endpoint( m_IPAddress, m_Port )
 {
-  return (GAddress_INET_SetPort(m_address, port) == GSOCK_NOERROR);
 }
 
-bool wxIPV6address::LocalHost()
+
+
+wxUDPIPendpoint::wxUDPIPendpoint( const ip::udp::endpoint & rEndpoint )
+: wxIPendpoint( wxString::FromUTF8( rEndpoint.address().to_string().c_str() ),
+			   rEndpoint.port() ),
+m_Endpoint( rEndpoint )
 {
-  return (GAddress_INET_SetHostName(m_address, "localhost") == GSOCK_NOERROR);
 }
 
-bool wxIPV6address::IsLocalHost() const
+
+
+wxUDPIPendpoint *wxUDPIPendpoint::Clone() const
 {
-  return (Hostname() == wxT("localhost") || IPAddress() == wxT("127.0.0.1"));
+    wxUDPIPendpoint *addr = new wxUDPIPendpoint(*this);
+    return addr;
 }
 
-bool wxIPV6address::AnyAddress()
+
+
+bool wxUDPIPendpoint::Service(unsigned short port)
 {
-  return (GAddress_INET_SetAnyAddress(m_address) == GSOCK_NOERROR);
+	m_Endpoint.port( port );
+	return true;
 }
 
-wxString wxIPV6address::IPAddress() const
+
+
+void wxUDPIPendpoint::DoSyncResolve( void )
 {
-    unsigned long raw =  GAddress_INET_GetHostAddress(m_address);
-    return wxString::Format(
-        _T("%u.%u.%u.%u"),
-        (unsigned char)((raw>>24) & 0xff),
-        (unsigned char)((raw>>16) & 0xff),
-        (unsigned char)((raw>>8) & 0xff),
-        (unsigned char)(raw & 0xff)
-        );
+	ip::udp::resolver resolver( wxSocketServiceHandler::GetServiceForThread() );
+
+	asio::error_code ec;
+	udp::resolver::iterator result = resolver.resolve( m_Endpoint, ec );
+	handle_resolve(ec, result);
 }
 
-wxString wxIPV6address::Hostname() const
+
+void wxUDPIPendpoint::DoAsyncResolve( void )
 {
-   char hostname[1024];
+	ip::udp::resolver resolver( wxSocketServiceHandler::GetServiceForThread() );
 
-   hostname[0] = 0;
-   GAddress_INET_GetHostName(m_address, hostname, 1024);
-   return wxString::FromAscii(hostname);
+	resolver.async_resolve( m_Endpoint, boost::bind(&wxUDPIPendpoint::handle_resolve, 
+													this,
+													asio::placeholders::error,
+													asio::placeholders::iterator) );
 }
 
-unsigned short wxIPV6address::Service() const
+
+
+void wxUDPIPendpoint::handle_resolve(const asio::error_code& err,
+									 udp::resolver::iterator endpoint_iterator)
 {
-  return GAddress_INET_GetPort(m_address);
+	wxASSERT( m_pHandler != NULL );
+	
+	if (!err)
+    {
+		udp::resolver::iterator end;
+		
+		while ( endpoint_iterator != end )
+		{
+			udp::endpoint endpoint = *endpoint_iterator;
+			wxUDPIPendpoint end_point = *this;
+			end_point.m_Endpoint = endpoint;
+			
+			wxResolveEvent event( GetId() );
+			event.SetEventObject( &end_point );
+			
+			m_pHandler->ProcessEvent( event );
+			
+			if ( ! event.ShouldContinueResolve() )
+				break;
+			
+			endpoint_iterator++;
+		}
+    }
+    else
+    {
+		std::cout << "Error: " << err.message() << "\n";
+    }
 }
 
-#endif // wxUSE_IPV6
+
+
+
+
+
 
 #if defined(__UNIX__) && !defined(__WINDOWS__) && !defined(__WINE__) && (!defined(__WXMAC__) || defined(__DARWIN__))
 
 // ---------------------------------------------------------------------------
-// wxUNIXaddress
+// wxUNIXendpoint
 // ---------------------------------------------------------------------------
 
-wxUNIXaddress::wxUNIXaddress()
-             : wxSockAddress()
+wxUNIXendpoint::wxUNIXendpoint()
+             : wxTCPIPendpoint()
 {
+	memset(&m_addr, 0, sizeof(m_addr) );
 }
 
-wxUNIXaddress::wxUNIXaddress(const wxUNIXaddress& other)
-             : wxSockAddress(other)
+wxUNIXendpoint::wxUNIXendpoint(const wxUNIXendpoint& other)
+             : wxTCPIPendpoint(other)
 {
+	memcpy(&m_addr, &other.m_addr, sizeof(m_addr));
 }
 
-wxUNIXaddress::~wxUNIXaddress()
+wxUNIXendpoint::~wxUNIXendpoint()
 {
 }
 
-void wxUNIXaddress::Filename(const wxString& fname)
+void wxUNIXendpoint::Filename(const wxString& fname)
 {
-  GAddress_UNIX_SetPath(m_address, fname.fn_str());
+	strncpy(m_addr.sun_path, fname.fn_str(), WXSIZEOF(m_addr.sun_path));
+	m_addr.sun_path[WXSIZEOF(m_addr.sun_path) - 1] = '\0';
+	m_addr.sun_family = AF_UNSPEC;
 }
 
-wxString wxUNIXaddress::Filename()
+wxString wxUNIXendpoint::Filename()
 {
-  char path[1024];
-
-  path[0] = 0;
-  GAddress_UNIX_GetPath(m_address, path, 1024);
-
-  return wxString::FromAscii(path);
+	return wxString::FromAscii(m_addr.sun_path);
 }
 
 #endif // __UNIX__
Index: wxGTK.spec
===================================================================
--- wxGTK.spec	(revision 52157)
+++ wxGTK.spec	(working copy)
@@ -328,7 +328,6 @@ wx/unix/private.h
 wx/unix/stackwalk.h
 wx/unix/stdpaths.h
 wx/fs_inet.h
-wx/gsocket.h
 wx/protocol/file.h
 wx/protocol/ftp.h
 wx/protocol/http.h
@@ -338,7 +337,6 @@ wx/sckipc.h
 wx/sckstrm.h
 wx/socket.h
 wx/url.h
-wx/unix/gsockunx.h
 wx/xml/xml.h
 wx/xtixml.h
 wx/db.h
Index: include/wx/thrimpl.cpp
===================================================================
--- include/wx/thrimpl.cpp	(revision 52157)
+++ include/wx/thrimpl.cpp	(working copy)
@@ -60,6 +60,75 @@ wxMutexError wxMutex::Unlock()
     return m_internal->Unlock();
 }
 
+
+#if wxUSE_RW_MUTEX
+// ----------------------------------------------------------------------------
+// wxReadWriteMutex
+// ----------------------------------------------------------------------------
+
+wxReadWriteMutex::wxReadWriteMutex(wxMutexType mutexType)
+{
+    m_internal = new wxReadWriteMutexInternal(mutexType);
+	
+    if ( !m_internal->IsOk() )
+    {
+        delete m_internal;
+        m_internal = NULL;
+    }
+}
+
+wxReadWriteMutex::~wxReadWriteMutex()
+{
+    delete m_internal;
+}
+
+bool wxReadWriteMutex::IsOk() const
+{
+    return m_internal != NULL;
+}
+
+wxMutexError wxReadWriteMutex::ReadLock()
+{
+    wxCHECK_MSG( m_internal, wxMUTEX_INVALID,
+				_T("wxReadWriteMutex::ReadLock(): not initialized") );
+	
+    return m_internal->ReadLock();
+}
+
+wxMutexError wxReadWriteMutex::TryReadLock()
+{
+    wxCHECK_MSG( m_internal, wxMUTEX_INVALID,
+				_T("wxReadWriteMutex::TryReadLock(): not initialized") );
+	
+    return m_internal->TryReadLock();
+}
+
+wxMutexError wxReadWriteMutex::WriteLock()
+{
+    wxCHECK_MSG( m_internal, wxMUTEX_INVALID,
+				_T("wxReadWriteMutex::WriteLock(): not initialized") );
+	
+    return m_internal->WriteLock();
+}
+
+wxMutexError wxReadWriteMutex::TryWriteLock()
+{
+    wxCHECK_MSG( m_internal, wxMUTEX_INVALID,
+				_T("wxReadWriteMutex::TryWriteLock(): not initialized") );
+	
+    return m_internal->TryWriteLock();
+}
+
+wxMutexError wxReadWriteMutex::Unlock()
+{
+    wxCHECK_MSG( m_internal, wxMUTEX_INVALID,
+				_T("wxReadWriteMutex::Unlock(): not initialized") );
+	
+    return m_internal->Unlock();
+}
+#endif // #if wxUSE_RW_MUTEX
+
+
 // --------------------------------------------------------------------------
 // wxConditionInternal
 // --------------------------------------------------------------------------
Index: include/wx/mac/setup0.h
===================================================================
--- include/wx/mac/setup0.h	(revision 52157)
+++ include/wx/mac/setup0.h	(working copy)
@@ -44,7 +44,7 @@
 // in the version after it completely.
 //
 // Recommended setting: 0 (please update your code)
-#define WXWIN_COMPATIBILITY_2_6 1
+#define WXWIN_COMPATIBILITY_2_6 0
 
 // MSW-only: Set to 0 for accurate dialog units, else 1 for old behaviour when
 // default system font is used for wxWindow::GetCharWidth/Height() instead of
@@ -158,7 +158,7 @@
 //
 // Recommended setting: 0 (unless you only plan to use Windows NT/2000/XP)
 #ifndef wxUSE_UNICODE
-    #define wxUSE_UNICODE 0
+    #define wxUSE_UNICODE 1
 #endif
 
 // Setting wxUSE_WCHAR_T to 1 gives you some degree of Unicode support without
@@ -1243,7 +1243,7 @@
 #define wxUSE_LIBMSPACK     0
 
 // native toolbar does not support embedding controls yet, please test by setting to 1
-#define wxMAC_USE_NATIVE_TOOLBAR 0
+#define wxMAC_USE_NATIVE_TOOLBAR 1
 
 
 
Index: include/wx/mac/carbon/config_xcode.h
===================================================================
--- include/wx/mac/carbon/config_xcode.h	(revision 52157)
+++ include/wx/mac/carbon/config_xcode.h	(working copy)
@@ -112,6 +112,7 @@
 #define HAVE_VSWPRINTF 1
 #define HAVE_FSEEKO 1
 #define HAVE_SYS_SELECT_H 1
+#define HAVE_DLOPEN 1
 
 #define WXWIN_OS_DESCRIPTION "Darwin 7.9.0 Power Macintosh"
 #define PACKAGE_BUGREPORT "wx-dev@lists.wxwidgets.org"
Index: include/wx/protocol/ftp.h
===================================================================
--- include/wx/protocol/ftp.h	(revision 52157)
+++ include/wx/protocol/ftp.h	(working copy)
@@ -38,7 +38,7 @@ public:
     void SetUser(const wxString& user) { m_user = user; }
     void SetPassword(const wxString& passwd) { m_passwd = passwd; }
 
-    bool Connect(wxSockAddress& addr, bool wait = true);
+    virtual bool Connect(wxTCPIPendpoint& addr, bool wait = true);
     bool Connect(const wxString& host);
 
     // disconnect
@@ -138,7 +138,7 @@ protected:
     wxSocketBase *GetActivePort();
 
     // helper for GetPort()
-    wxString GetPortCmdArgument(const wxIPV4address& Local, const wxIPV4address& New);
+    wxString GetPortCmdArgument(const wxIPendpoint& Local, const wxIPendpoint& New);
 
     // accept connection from server in active mode, returns the same socket as
     // passed in in passive mode
Index: include/wx/protocol/http.h
===================================================================
--- include/wx/protocol/http.h	(revision 52157)
+++ include/wx/protocol/http.h	(working copy)
@@ -29,7 +29,7 @@ public:
 
   virtual bool Connect(const wxString& host, unsigned short port);
   virtual bool Connect(const wxString& host) { return Connect(host, 0); }
-  virtual bool Connect(wxSockAddress& addr, bool wait);
+  virtual bool Connect(wxTCPIPendpoint& addr, bool wait = true);
   bool Abort();
   wxInputStream *GetInputStream(const wxString& path);
   inline wxProtocolError GetError() { return m_perr; }
@@ -74,7 +74,7 @@ protected:
   wxStringToStringHashMap m_headers;
   bool m_read,
        m_proxy_mode;
-  wxSockAddress *m_addr;
+  wxTCPIPendpoint *m_addr;
   wxString m_post_buf;
   int m_http_response;
   wxString m_username;
Index: include/wx/protocol/protocol.h
===================================================================
--- include/wx/protocol/protocol.h	(revision 52157)
+++ include/wx/protocol/protocol.h	(working copy)
@@ -58,8 +58,10 @@ public:
 
 #if wxUSE_SOCKETS
     bool Reconnect();
+	
+	using wxSocketClient::Connect;
     virtual bool Connect( const wxString& WXUNUSED(host) ) { return FALSE; }
-    virtual bool Connect( wxSockAddress& addr, bool WXUNUSED(wait) = TRUE) { return wxSocketClient::Connect(addr); }
+//    virtual bool Connect( wxTCPIPendpoint& addr ) { return wxSocketClient::Connect(addr); }
 
     // read a '\r\n' terminated line from the given socket and put it in
     // result (without the terminators)
Index: include/wx/event.h
===================================================================
--- include/wx/event.h	(revision 52157)
+++ include/wx/event.h	(working copy)
@@ -154,7 +154,9 @@ BEGIN_DECLARE_EVENT_TYPES()
     DECLARE_EVENT_TYPE(wxEVT_COMMAND_SPINCTRL_UPDATED, 18)
 
         // Sockets and timers send events, too
-    DECLARE_EXPORTED_EVENT_TYPE(WXDLLIMPEXP_BASE, wxEVT_SOCKET, 50)
+    DECLARE_EXPORTED_EVENT_TYPE(WXDLLIMPEXP_NET, wxEVT_SOCKET, 50)
+	DECLARE_EXPORTED_EVENT_TYPE(WXDLLIMPEXP_NET, wxEVT_SOCKET_RESOLVE, 51)
+	DECLARE_EXPORTED_EVENT_TYPE(WXDLLIMPEXP_NET, wxEVT_SOCKET_WAIT, 52)
     DECLARE_EVENT_TYPE(wxEVT_TIMER , 80)
 
         // Mouse event types
Index: include/wx/socket.h
===================================================================
--- include/wx/socket.h	(revision 52157)
+++ include/wx/socket.h	(working copy)
@@ -16,50 +16,96 @@
 
 #if wxUSE_SOCKETS
 
+#ifdef __DARWIN__
+// this gets around a strange error in OpenTransportProviders.h where an enum
+// is defined with values that already exist in a Unix header--specifically netinet/tcp.h
+#    include <Carbon/Carbon.h>
+#endif
+
+#ifndef BOOST_NO_EXCEPTIONS
+#	define BOOST_NO_EXCEPTIONS
+#	include <exception>
+
+namespace boost
+{
+	inline
+#ifdef __DARWIN__
+	__attribute__((noreturn))
+#endif	
+	void throw_exception(std::exception const & e) // user defined
+	{
+		throw e;	
+	}
+}
+
+#	include <boost/throw_exception.hpp>
+#endif
+
+#include <asio.hpp>
+
+#include <map>
+
 // ---------------------------------------------------------------------------
 // wxSocket headers
 // ---------------------------------------------------------------------------
 
 #include "wx/event.h"
 #include "wx/sckaddr.h"
-#include "wx/gsocket.h"
 #include "wx/list.h"
 
+
 // ------------------------------------------------------------------------
 // Types and constants
 // ------------------------------------------------------------------------
 
+
 enum wxSocketNotify
 {
-  wxSOCKET_INPUT = GSOCK_INPUT,
-  wxSOCKET_OUTPUT = GSOCK_OUTPUT,
-  wxSOCKET_CONNECTION = GSOCK_CONNECTION,
-  wxSOCKET_LOST = GSOCK_LOST
+	wxSOCKET_INPUT = 0,					
+	wxSOCKET_INPUT_AVAILABLE = wxSOCKET_INPUT,	///< Notification that data is available to be read (unimplemented)
+	wxSOCKET_OUTPUT,							///< Notification that socket write completed
+	wxSOCKET_CONNECTION,						///< Connection completed (client)/Connection received (server)
+	wxSOCKET_LOST,
+	wxSOCKET_CLOSED = wxSOCKET_LOST,
+	wxSOCKET_WAIT_IDLE_EVENT,					///< Sent during waits
+	wxSOCKET_INPUT_SUCCEEDED					///< Notification that socket read completed
 };
 
+
 enum
 {
-  wxSOCKET_INPUT_FLAG = GSOCK_INPUT_FLAG,
-  wxSOCKET_OUTPUT_FLAG = GSOCK_OUTPUT_FLAG,
-  wxSOCKET_CONNECTION_FLAG = GSOCK_CONNECTION_FLAG,
-  wxSOCKET_LOST_FLAG = GSOCK_LOST_FLAG
+	wxSOCKET_INPUT_FLAG				= 1 << 0, ///< info about data received
+	wxSOCKET_OUTPUT_FLAG			= 1 << 1, ///< info about data transmitted
+	wxSOCKET_CONNECTION_FLAG		= 1 << 2, ///< notification that a connection was attempted or successful
+	wxSOCKET_LOST_FLAG				= 1 << 3, ///< connection lost
+	wxSOCKET_RESOLVE_FLAG			= 1 << 4, ///< info about each potential resolved endpoint when client is connecting
+	wxSOCKET_WAIT_CONNECT_FLAG		= 1 << 5, ///< info about an async WaitOnConnect
+	wxSOCKET_WAIT_IDLE_EVENT_FLAG	= 1 << 6  ///< sends wxSocketWaitEvent regularly during a wait (frequency depends on GUI blocking)
 };
 
-typedef GSocketEventFlags wxSocketEventFlags;
+
+typedef int wxSocketEventFlags;
+
 
 enum wxSocketError
 {
-  // from GSocket
-  wxSOCKET_NOERROR = GSOCK_NOERROR,
-  wxSOCKET_INVOP = GSOCK_INVOP,
-  wxSOCKET_IOERR = GSOCK_IOERR,
-  wxSOCKET_INVADDR = GSOCK_INVADDR,
-  wxSOCKET_INVSOCK = GSOCK_INVSOCK,
-  wxSOCKET_NOHOST = GSOCK_NOHOST,
-  wxSOCKET_INVPORT = GSOCK_INVPORT,
-  wxSOCKET_WOULDBLOCK = GSOCK_WOULDBLOCK,
-  wxSOCKET_TIMEDOUT = GSOCK_TIMEDOUT,
-  wxSOCKET_MEMERR = GSOCK_MEMERR,
+	wxSOCKET_NOERROR = 0,
+	wxSOCKET_INVOP,
+	wxSOCKET_IOERR,
+	wxSOCKET_INVADDR,
+	wxSOCKET_INVSOCK,
+	wxSOCKET_NOHOST,
+	wxSOCKET_INVPORT,
+	wxSOCKET_WOULDBLOCK,
+	wxSOCKET_TIMEDOUT,
+	wxSOCKET_MEMERR,
+	
+	wxSOCKET_ACCESS_DENIED,
+	wxSOCKET_REFUSED,
+	wxSOCKET_NETWORK_DOWN,
+	wxSOCKET_NETWORK_UNREACHABLE,
+	
+	wxSOCKET_NOT_SUPPORTED,
 
   // wxSocket-specific (not yet implemented)
   wxSOCKET_DUMMY
@@ -68,28 +114,102 @@ enum wxSocketError
 enum
 {
   wxSOCKET_NONE = 0,
-  wxSOCKET_NOWAIT = 1,
-  wxSOCKET_WAITALL = 2,
-  wxSOCKET_BLOCK = 4,
-  wxSOCKET_REUSEADDR = 8
+	wxSOCKET_NOWAIT 		= 1 << 0,
+	wxSOCKET_WAITALL 		= 1 << 1,
+	wxSOCKET_BLOCK 			= 1 << 2,
+	wxSOCKET_REUSEADDR 		= 1 << 3,
+	
+	wxSOCKET_DO_NOT_ROUTE	= 1 << 4,
+	wxSOCKET_KEEP_ALIVE		= 1 << 5,
+	
+	wxSOCKET_BROADCAST		= 1 << 6,
+	wxSOCKET_NOBIND			= 1 << 7,	// not implemented
+	
+	wxSOCKET_SPAWN_THREAD 	= 1 << 10,  // not implemented
+	wxSOCKET_SPAWN_PROCESS	= 1 << 11,  // not implemented
+	wxSOCKET_FORK_PROCESS	= 1 << 12   // not implemented
 };
 
 enum wxSocketType
 {
-  wxSOCKET_UNINIT,
-  wxSOCKET_CLIENT,
-  wxSOCKET_SERVER,
-  wxSOCKET_BASE,
-  wxSOCKET_DATAGRAM
+	wxSOCKET_UNINIT, 	///< an uninitialized socket object
+	wxSOCKET_CLIENT, 	///< a TCP client socket
+	wxSOCKET_SERVER, 	///< a TCP connection-accepting server
+	wxSOCKET_BASE,   	///< TCP raw wxSocket object, as returned by wxSocketServer::Accept.
+	wxSOCKET_DATAGRAM	///< UDP socket
 };
 
 typedef int wxSocketFlags;
 
 
+class WXDLLIMPEXP_NET wxSocketServiceHandler : public wxEvtHandler
+{
+protected:
+	class wxIOServiceHelper;
+public:
+	inline	static	asio:: io_service & GetService( void ) { return GetServiceForThread( wxThread::GetMainThreadId() ); }
+	static  asio:: io_service & GetServiceForThread( wxThreadIdType thread = wxThread::GetCurrentId() );
+	static wxIOServiceHelper * GetServiceHelperForThread( wxThreadIdType thread = wxThread::GetCurrentId() );
+	static	bool ServiceExistsForThread( wxThreadIdType thread = wxThread::GetCurrentId() );
+	
+	static	size_t Run(asio::error_code &ec);
+	static	size_t RunOne(asio::error_code &ec);
+	
+	static	size_t Poll(asio::error_code &ec);
+	static	size_t PollOne(asio::error_code &ec);
+	
+	static	bool InitThread( wxThreadIdType thread = wxThread::GetCurrentId() );
+	static	void ShutdownThread( wxThreadIdType thread = wxThread::GetCurrentId() );
+	
+	
+protected:	
+	
+	class wxIOServiceHelper
+	{
+	public:
+		wxIOServiceHelper()
+		: m_Service (  ),
+		m_RetainCount( 0 ),
+		m_pThread( NULL )
+		{}
+				
+		int Retain(void); // returns retain count.  If 1, spawns a helper thread which calls wxIOServiceHelper::RunService.
+		int Release(void);
+		
+	private:
+		friend class wxSocketServiceHandler;
+		
+		inline asio:: io_service & GetService(void)
+		{
+			wxASSERT_MSG( m_RetainCount > 0, wxT("You must initialize sockets on this thread first!") );
+			return m_Service;
+		}
+		
+		
+		void RunService(void);
+		
+	private:
+		asio::io_service 	m_Service;
+		int					m_RetainCount;
+		asio::thread *		m_pThread;
+		wxMutex				m_RetainCountMutex;
+		wxReadWriteMutex	m_ResetMutex; // read/write mutex
+
+		DECLARE_NO_COPY_CLASS( wxIOServiceHelper );
+	};
+	
+	
+protected:
+	static wxMutex										ms_ActiveServicesMutex;
+	static std::map<wxThreadIdType, wxIOServiceHelper*>	ms_ActiveServices;
+};
+
+
 
 // --------------------------------------------------------------------------
 // wxSocketBase
 // --------------------------------------------------------------------------
+class wxIPendpoint;
 
 class WXDLLIMPEXP_NET wxSocketBase : public wxObject
 {
@@ -109,43 +229,49 @@ public:
 
   // state
   inline bool Ok() const { return IsOk(); }
-  inline bool IsOk() const { return (m_socket != NULL); }
+	virtual bool IsOk() const { return IsConnected() || !Error(); }
   inline bool Error() const { return m_error; }
-  inline bool IsConnected() const { return m_connected; }
-  inline bool IsData() { return WaitForRead(0, 0); }
+	virtual bool IsConnected() const { return m_connected; }
+	inline  bool IsData() { return DataReadable() > 0; }
+	virtual size_t	DataReadable() = 0;
   inline bool IsDisconnected() const { return !IsConnected(); }
   inline wxUint32 LastCount() const { return m_lcount; }
-  inline wxSocketError LastError() const { return (wxSocketError)m_socket->GetError(); }
+	inline wxSocketError LastError() const { return m_lasterror; }
+	
+//  inline wxSocketError LastError() const { return (wxSocketError)m_socket->GetError(); }
   void SaveState();
   void RestoreState();
 
   // addresses
-  virtual bool GetLocal(wxSockAddress& addr_man) const;
-  virtual bool GetPeer(wxSockAddress& addr_man) const;
-  virtual bool SetLocal(wxIPV4address& local);
+  virtual bool GetLocal(wxIPendpoint& addr_man) const = 0;
+  virtual bool GetPeer(wxIPendpoint& addr_man) const = 0;
+  virtual bool SetLocal(wxIPendpoint& local) = 0;
 
   // base IO
   virtual bool  Close();
-  wxSocketBase& Discard();
-  wxSocketBase& Peek(void* buffer, wxUint32 nbytes);
-  wxSocketBase& Read(void* buffer, wxUint32 nbytes);
-  wxSocketBase& ReadMsg(void *buffer, wxUint32 nbytes);
-  wxSocketBase& Unread(const void *buffer, wxUint32 nbytes);
-  wxSocketBase& Write(const void *buffer, wxUint32 nbytes);
-  wxSocketBase& WriteMsg(const void *buffer, wxUint32 nbytes);
+  virtual wxSocketBase& Discard();
+  virtual wxSocketBase& Peek(void* buffer, wxUint32 nbytes);
+  virtual wxSocketBase& Read(void* buffer, wxUint32 nbytes);
+  virtual wxSocketBase& ReadMsg(void *buffer, wxUint32 nbytes);
+  virtual wxSocketBase& Unread(const void *buffer, wxUint32 nbytes);
+  virtual wxSocketBase& Write(const void *buffer, wxUint32 nbytes);
+  virtual wxSocketBase& WriteMsg(const void *buffer, wxUint32 nbytes);
 
-  void InterruptWait() { m_interrupt = true; }
-  bool Wait(long seconds = -1, long milliseconds = 0);
+	virtual void InterruptWait();
+	bool Wait(long seconds = -1, long milliseconds = 0, wxSocketEventFlags flags = wxSOCKET_INPUT_FLAG | wxSOCKET_OUTPUT_FLAG | wxSOCKET_CONNECTION_FLAG | wxSOCKET_LOST_FLAG );
   bool WaitForRead(long seconds = -1, long milliseconds = 0);
   bool WaitForWrite(long seconds = -1, long milliseconds = 0);
   bool WaitForLost(long seconds = -1, long milliseconds = 0);
 
   inline wxSocketFlags GetFlags() const { return m_flags; }
-  void SetFlags(wxSocketFlags flags);
+  virtual void SetFlags(wxSocketFlags flags);
   void SetTimeout(long seconds);
 
-  bool GetOption(int level, int optname, void *optval, int *optlen);
-  bool SetOption(int level, int optname, const void *optval, int optlen);
+	/// This function gives you raw access to socket options as defined on your native platform.
+	virtual bool GetOption(int level, int optname, void *optval, size_t *optlen) = 0;
+	/// This function gives you raw access to socket options as defined on your native platform.
+	virtual bool SetOption(int level, int optname, const void *optval, size_t optlen) = 0;
+	
   inline wxUint32 GetLastIOSize() const { return m_lcount; }
 
   // event handling
@@ -164,30 +290,52 @@ public:
   // Implementation from now on
   // --------------------------
 
-  // do not use, should be private (called from GSocket)
-  void OnRequest(wxSocketNotify notify);
-
   // do not use, not documented nor supported
   inline bool IsNoWait() const { return ((m_flags & wxSOCKET_NOWAIT) != 0); }
   inline wxSocketType GetType() const { return m_type; }
 
-private:
+	
+	static inline void DoIdle( void )
+	{
+		if ( wxSocketServiceHandler::ServiceExistsForThread() )
+		{
+			asio::error_code ec;
+			wxSocketServiceHandler::Poll( ec );
+		}
+	}
+	
+																  
+																  
+protected:
   friend class wxSocketClient;
   friend class wxSocketServer;
   friend class wxDatagramSocket;
 
   // low level IO
-  wxUint32 _Read(void* buffer, wxUint32 nbytes);
-  wxUint32 _Write(const void *buffer, wxUint32 nbytes);
-  bool     _Wait(long seconds, long milliseconds, wxSocketEventFlags flags);
+	virtual wxUint32 _Read(void* buffer, wxUint32 nbytes) = 0;
+	virtual wxUint32 _Write(const void *buffer, wxUint32 nbytes) = 0;
+	virtual bool     _DoWait(long milliseconds, wxSocketEventFlags flags);
 
   // pushback buffer
   void     Pushback(const void *buffer, wxUint32 size);
   wxUint32 GetPushback(void *buffer, wxUint32 size, bool peek);
 
+protected:
+	virtual bool InterpretErrorCode		( const asio::error_code& err );
+	virtual bool InterpretErrorCode		( const asio::error_code& err ) const;
+
+	virtual void DoHandleWriteRequest	(const asio::error_code& err, size_t bytes_transferred );
+	virtual void DoHandleReadContent	(const asio::error_code& err, size_t bytes_transferred);
+	
+	virtual void DoHandleWaitTimer		(const asio::error_code& err);
+	
+	
 private:
+	inline void handle_wait_timer(const asio::error_code& err) { DoHandleWaitTimer( err ); }
+
+	
+protected:
   // socket
-  GSocket      *m_socket;           // GSocket
   wxSocketType  m_type;             // wxSocket type
 
   // state
@@ -201,9 +349,10 @@ private:
   wxUint32      m_lcount;           // last IO transaction size
   unsigned long m_timeout;          // IO timeout value
   wxList        m_states;           // stack of states
-  bool          m_interrupt;        // interrupt ongoing wait operations?
+	bool        m_waitComplete;     // conclude ongoing wait operations?
+	bool		m_waitResult;		// result of wait operation
   bool          m_beingDeleted;     // marked for delayed deletion?
-  wxIPV4address m_localAddress;     // bind to local address?
+//  wxIPaddress	m_localAddress;     // bind to local address?
 
   // pushback buffer
   void         *m_unread;           // pushback buffer
@@ -212,7 +361,7 @@ private:
 
   // events
   int           m_id;               // socket id
-  wxEvtHandler *m_handler;          // event handler
+  wxEvtHandler *m_pHandler;          // event handler
   void         *m_clientData;       // client data for events
   bool          m_notify;           // notify events to users?
   wxSocketEventFlags  m_eventmask;  // which events to notify?
@@ -220,81 +369,232 @@ private:
   // the initialization count, GSocket is initialized if > 0
   static size_t m_countInit;
 
+	asio::deadline_timer	m_ReadTimer;
+	asio::deadline_timer	m_WriteTimer;
+
   DECLARE_NO_COPY_CLASS(wxSocketBase)
 };
 
 
+
+
+
+// --------------------------------------------------------------------------
+// wxSocket
+// --------------------------------------------------------------------------
+
+using asio::ip::tcp;
+using asio::ip::udp;
+
+class WXDLLIMPEXP_NET wxSocket : public wxSocketBase
+{
+	DECLARE_CLASS(wxSocket)
+	
+public:
+	wxSocket(wxSocketFlags flags = wxSOCKET_NONE, wxSocketType type = wxSOCKET_UNINIT );
+//	wxSocket(const wxSockAddress& addr, wxSocketFlags flags = wxSOCKET_NONE);
+		
+	// addresses
+	virtual bool GetLocal(wxIPendpoint& addr_man) const;
+	virtual bool GetPeer(wxIPendpoint& addr_man) const;	
+	virtual bool SetLocal(wxIPendpoint& local);
+	
+	virtual bool Close();
+	virtual void InterruptWait();
+	
+	virtual void SetFlags(wxSocketFlags flags);
+
+	virtual wxSocketBase& Peek(void* buffer, wxUint32 nbytes);
+
+	virtual size_t	DataReadable();
+	
+	/// This function gives you raw access to socket options as defined on your native platform.
+	virtual bool GetOption(int level, int optname, void *optval, size_t *optlen);
+	/// This function gives you raw access to socket options as defined on your native platform.
+	virtual bool SetOption(int level, int optname, const void *optval, size_t optlen);
+	
+private:
+	inline 	void handle_wait_timer(const asio::error_code& err) { DoHandleWaitTimer( err ); }
+	
+	inline 	void handle_write_request(const asio::error_code& err, size_t bytes_transferred) { DoHandleWriteRequest( err, bytes_transferred ); }
+	inline 	void handle_read_content(const asio::error_code& err, size_t bytes_transferred) { DoHandleReadContent( err, bytes_transferred ); }
+	
+	inline 	void handle_connect_timer(const asio::error_code& err) { DoHandleConnectTimer( err ); }
+	inline 	void handle_close_timer(const asio::error_code& err) { DoHandleCloseTimer( err ); }
+
+
+protected:
+//	virtual void DoHandleWriteRequest	(const asio::error_code& err);
+//	virtual void DoHandleReadContent	(const asio::error_code& err);
+	
+	virtual void DoHandleConnectTimer	(const asio::error_code& err);
+	virtual void DoHandleCloseTimer		(const asio::error_code& err);
+	
+	// low level IO
+	virtual wxUint32 _Read(void* buffer, wxUint32 nbytes);
+	virtual wxUint32 _Write(const void *buffer, wxUint32 nbytes);
+	
+	virtual bool     _DoWait(long milliseconds, wxSocketEventFlags flags);
+
+	friend class wxSocketServer;
+protected:
+	asio::ip::tcp::socket			m_Socket;
+	
+	asio::streambuf 		m_Outgoing;
+	asio::streambuf 		m_Incoming;
+	
+	asio::deadline_timer	m_ConnectTimer;
+	asio::deadline_timer	m_CloseTimer;
+	
+	wxTCPIPendpoint			m_Peer;
+
+	DECLARE_NO_COPY_CLASS(wxSocket)
+};
+
+
+
+
+
 // --------------------------------------------------------------------------
 // wxSocketServer
 // --------------------------------------------------------------------------
 
-class WXDLLIMPEXP_NET wxSocketServer : public wxSocketBase
+class WXDLLIMPEXP_NET wxSocketServer : public wxSocket
 {
   DECLARE_CLASS(wxSocketServer)
 
 public:
-  wxSocketServer(const wxSockAddress& addr, wxSocketFlags flags = wxSOCKET_NONE);
+	wxSocketServer(const wxTCPIPendpoint& addr, wxSocketFlags flags = wxSOCKET_NONE);
+	wxSocketServer(unsigned short port, wxSockAddress::Addr ip_version = wxSockAddress::IPV4, wxSocketFlags flags = wxSOCKET_NONE);
+
+	virtual void SetFlags(wxSocketFlags flags);
 
-  wxSocketBase* Accept(bool wait = true);
-  bool AcceptWith(wxSocketBase& socket, bool wait = true);
+	wxSocket* Accept(bool wait = true);
+	bool AcceptWith(wxSocket& socket, bool wait = true);
 
   bool WaitForAccept(long seconds = -1, long milliseconds = 0);
 
   DECLARE_NO_COPY_CLASS(wxSocketServer)
+	
+	
+private:
+	inline 	void handle_accept(wxSocket& sock, const asio::error_code& err) { DoHandleAccept( sock, err ); }
+	
+protected:
+	virtual void DoHandleAccept( wxSocket& sock, const asio::error_code& err );
+	
+protected:
+	tcp::acceptor	m_Acceptor;
 };
 
 
 // --------------------------------------------------------------------------
 // wxSocketClient
 // --------------------------------------------------------------------------
+class wxTCPIPendpoint;
 
-class WXDLLIMPEXP_NET wxSocketClient : public wxSocketBase
+class WXDLLIMPEXP_NET wxSocketClient : public wxSocket
 {
   DECLARE_CLASS(wxSocketClient)
 
 public:
   wxSocketClient(wxSocketFlags flags = wxSOCKET_NONE);
+	wxSocketClient(const wxTCPIPendpoint& local, wxSocketFlags flags = wxSOCKET_NONE);
+	
   virtual ~wxSocketClient();
 
-  virtual bool Connect(wxSockAddress& addr, bool wait = true);
-  bool Connect(wxSockAddress& addr, wxSockAddress& local, bool wait = true);
+	virtual bool Connect(wxTCPIPendpoint& addr, bool wait = true);
+			bool Connect(wxTCPIPendpoint& addr, 
+						 wxTCPIPendpoint& local, bool wait = true);
+	
+			bool WaitOnConnect(long seconds = -1, long milliseconds = 0, bool async = false);
+
+	
+protected:
+
+	virtual void DoHandleConnectTimer	(const asio::error_code& err);
+
+//	virtual void DoHandleConnect( const asio::error_code& err,
+//								 tcp::resolver::iterator endpoint_iterator );
 
-  bool WaitOnConnect(long seconds = -1, long milliseconds = 0);
 
 private:
-  virtual bool DoConnect(wxSockAddress& addr, wxSockAddress* local, bool wait = true);
+	inline 	void handle_connect_timer(const asio::error_code& err) { DoHandleConnectTimer( err ); }
+	
+	inline 	void handle_resolve(const asio::error_code& err,
+								tcp::resolver::iterator endpoint_iterator);
+	
+	inline 	void handle_connect(const asio::error_code& err,
+								tcp::resolver::iterator endpoint_iterator);
 
   DECLARE_NO_COPY_CLASS(wxSocketClient)
 };
 
 
+
+
 // --------------------------------------------------------------------------
 // wxDatagramSocket
 // --------------------------------------------------------------------------
 
-// WARNING: still in alpha stage
+class wxUDPIPendpoint;
 
 class WXDLLIMPEXP_NET wxDatagramSocket : public wxSocketBase
 {
   DECLARE_CLASS(wxDatagramSocket)
 
 public:
-  wxDatagramSocket(const wxSockAddress& addr, wxSocketFlags flags = wxSOCKET_NONE);
+	wxDatagramSocket(const wxUDPIPendpoint& addr, wxSocketFlags flags = wxSOCKET_NONE);
 
-  wxDatagramSocket& RecvFrom( wxSockAddress& addr,
+	wxDatagramSocket& RecvFrom( wxUDPIPendpoint& addr,
                               void* buf,
                               wxUint32 nBytes );
-  wxDatagramSocket& SendTo( const wxSockAddress& addr,
+	wxDatagramSocket& SendTo( const wxUDPIPendpoint& addr,
                             const void* buf,
                             wxUint32 nBytes );
 
-/* TODO:
-  bool Connect(wxSockAddress& addr);
-*/
+	// state
+	virtual size_t	DataReadable();
+
+	// addresses
+	virtual bool GetLocal(wxIPendpoint& addr_man) const;
+	virtual bool GetPeer(wxIPendpoint& addr_man) const;
+	virtual bool SetLocal(wxIPendpoint& local);
+
+	// base IO
+	virtual void InterruptWait();
+	virtual void SetFlags(wxSocketFlags flags);
+
+	/// This function gives you raw access to socket options as defined on your native platform.
+	virtual bool GetOption(int level, int optname, void *optval, size_t *optlen);
+	/// This function gives you raw access to socket options as defined on your native platform.
+	virtual bool SetOption(int level, int optname, const void *optval, size_t optlen);
+
+protected:
+	virtual wxUint32 _Read(void* buffer, wxUint32 nbytes) { return _Read(buffer,nbytes,m_Peer); }
+	virtual wxUint32 _Write(const void *buffer, wxUint32 nbytes) { return _Write(buffer,nbytes,m_Peer); }
+	virtual wxUint32 _Read(void* buffer, wxUint32 nbytes, wxUDPIPendpoint & rPeer);
+	virtual wxUint32 _Write(const void *buffer, wxUint32 nbytes, const wxUDPIPendpoint & rPeer);
+
+	using wxSocketBase::DoHandleWriteRequest;
+	using wxSocketBase::DoHandleReadContent;
+	virtual void DoHandleWriteRequest	(const wxUDPIPendpoint & rPeer, const asio::error_code& err, size_t bytes_transferred);
+	virtual void DoHandleReadContent	(wxUDPIPendpoint & rPeer, const asio::error_code& err, size_t bytes_transferred);
+	
+private:
+	inline 	void handle_write_request(const wxUDPIPendpoint & rPeer, const asio::error_code& err, size_t bytes_transferred) { DoHandleWriteRequest( rPeer, err, bytes_transferred ); }
+	inline 	void handle_read_content(wxUDPIPendpoint & rPeer, const asio::error_code& err, size_t bytes_transferred) { DoHandleReadContent( rPeer, err, bytes_transferred ); }
+	
+protected:
+	asio::ip::udp::socket	m_Socket;
+	wxUDPIPendpoint m_Peer;
+
   DECLARE_NO_COPY_CLASS(wxDatagramSocket)
 };
 
 
+
+
 // --------------------------------------------------------------------------
 // wxSocketEvent
 // --------------------------------------------------------------------------
@@ -303,19 +603,26 @@ class WXDLLIMPEXP_NET wxSocketEvent : pu
 {
 public:
   wxSocketEvent(int id = 0)
-      : wxEvent(id, wxEVT_SOCKET)
+	: wxEvent(id, wxEVT_SOCKET),
+	m_clientData ( NULL ),
+	m_success ( true ),
+	m_bytes_transferred( 0 )
       {
       }
 
   wxSocketNotify  GetSocketEvent() const { return m_event; }
   wxSocketBase   *GetSocket() const      { return (wxSocketBase *) GetEventObject(); }
   void           *GetClientData() const  { return m_clientData; }
+	bool			ActionSucceeded() const			{ return m_success; }
+	size_t			GetAmountTransferred() const	{ return m_bytes_transferred; }
 
-  virtual wxEvent *Clone() const { return new wxSocketEvent(*this); }
+	virtual wxSocketEvent *Clone() const { return new wxSocketEvent(*this); }
 
 public:
   wxSocketNotify  m_event;
   void           *m_clientData;
+	bool			m_success;
+	size_t			m_bytes_transferred;
 
   DECLARE_DYNAMIC_CLASS_NO_ASSIGN(wxSocketEvent)
 };
@@ -329,6 +636,54 @@ typedef void (wxEvtHandler::*wxSocketEve
 #define EVT_SOCKET(id, func) \
     wx__DECLARE_EVT1(wxEVT_SOCKET, id, wxSocketEventHandler(func))
 
+
+
+
+// --------------------------------------------------------------------------
+// wxSocketWaitEvent
+// --------------------------------------------------------------------------
+
+class WXDLLIMPEXP_NET wxSocketWaitEvent : public wxEvent
+{
+public:
+	wxSocketWaitEvent(int id = 0)
+	: wxEvent(id, wxEVT_SOCKET_WAIT),
+	m_clientData( NULL ),
+	m_timeout( false )
+	{
+	}
+	
+	wxSocketNotify  GetSocketEvent() const { return m_event; }
+	wxSocketBase   *GetSocket() const      { return (wxSocketBase *) GetEventObject(); }
+	void           *GetClientData() const  { return m_clientData; }
+	bool			TimerDidElapse() const { return m_timeout; }
+	
+	virtual wxSocketWaitEvent *Clone() const { return new wxSocketWaitEvent(*this); }
+	
+public:
+	wxSocketNotify  m_event;
+	void           *m_clientData;
+	bool			m_timeout;
+	
+	DECLARE_DYNAMIC_CLASS_NO_ASSIGN(wxSocketWaitEvent)
+};
+
+
+typedef void (wxEvtHandler::*wxSocketWaitEventFunction)(wxSocketWaitEvent&);
+
+#define wxSocketWaitEventHandler(func) \
+(wxObjectEventFunction)(wxEventFunction)wxStaticCastEvent(wxSocketWaitEventFunction, &func)
+
+#define EVT_SOCKET_WAIT(id, func) \
+wx__DECLARE_EVT1(wxEVT_SOCKET_WAIT, id, wxSocketWaitEventHandler(func))
+
+
+
+
+
+
+
+
 #endif // wxUSE_SOCKETS
 
 #endif // _WX_SOCKET_H_
Index: include/wx/thread.h
===================================================================
--- include/wx/thread.h	(revision 52157)
+++ include/wx/thread.h	(working copy)
@@ -102,18 +102,30 @@ enum
 enum wxMutexType
 {
     // normal mutex: try to always use this one
-    wxMUTEX_DEFAULT,
+    wxMUTEX_DEFAULT				= 0x00,
 
     // recursive mutex: don't use these ones with wxCondition
-    wxMUTEX_RECURSIVE
+    wxMUTEX_RECURSIVE			= 0x01
+	
+#if wxUSE_SHARED_MUTEX
+	,
+	
+	// shared mutex: share with other processes on the same system
+	wxMUTEX_SHARED				= 0x02,
+	
+	wxMUTEX_SHARED_RECURSIVE	= wxMUTEX_SHARED | wxMUTEX_RECURSIVE
+#endif
 };
 
 // forward declarations
-class WXDLLIMPEXP_BASE wxThreadHelper;
-class WXDLLIMPEXP_BASE wxConditionInternal;
-class WXDLLIMPEXP_BASE wxMutexInternal;
-class WXDLLIMPEXP_BASE wxSemaphoreInternal;
-class WXDLLIMPEXP_BASE wxThreadInternal;
+class WXDLLIMPEXP_FWD_BASE wxThreadHelper;
+class WXDLLIMPEXP_FWD_BASE wxConditionInternal;
+class WXDLLIMPEXP_FWD_BASE wxMutexInternal;
+class WXDLLIMPEXP_FWD_BASE wxSemaphoreInternal;
+class WXDLLIMPEXP_FWD_BASE wxThreadInternal;
+#if wxUSE_RW_MUTEX
+class WXDLLIMPEXP_FWD_BASE wxReadWriteMutexInternal;
+#endif
 
 // ----------------------------------------------------------------------------
 // A mutex object is a synchronization object whose state is set to signaled
@@ -192,6 +204,123 @@ private:
     wxMutex& m_mutex;
 };
 
+
+#if wxUSE_RW_MUTEX
+// ----------------------------------------------------------------------------
+// A shared mutex is generally used to allow multiple readers but only one
+// writer.  This is often also referred to as a read/write mutex.
+//
+// This is NOT an upgradable mutex.  It is an error to attempt to aquire a write
+// lock on a thread that owns a read lock.  Likewise, it's an error to attempt
+// to aquire a read lock on a thread that already owns a write lock.
+//
+// Read locks on a shared mutex are always recursive.  Write locks are not
+// recursive.
+// ----------------------------------------------------------------------------
+
+class WXDLLIMPEXP_BASE wxReadWriteMutex
+{
+public:
+    // constructor & destructor
+    // ------------------------
+	
+    // create either default (always safe) or recursive mutex
+    wxReadWriteMutex(wxMutexType mutexType = wxMUTEX_DEFAULT);
+	
+    // destroys the mutex kernel object
+    ~wxReadWriteMutex();
+	
+    // test if the mutex has been created successfully
+    bool IsOk() const;
+	
+    // mutex operations
+    // ----------------
+	
+    // Lock the mutex, blocking on it until it is unlocked by the other thread.
+    // The result of locking a mutex already locked by the current thread
+    // depend on the mutex type.
+    //
+    // The caller must call Unlock() later if ReadLock() returned wxMUTEX_NO_ERROR.
+    wxMutexError ReadLock();
+	
+    // Try to lock the mutex: if it is currently locked, return immediately
+    // with an error. Otherwise the caller must call Unlock().
+    wxMutexError TryReadLock();
+		
+	
+	// The caller must call Unlock() later if WriteLock() returned wxMUTEX_NO_ERROR.
+    wxMutexError WriteLock();
+	
+    // Try to lock the mutex: if it is currently locked, return immediately
+    // with an error. Otherwise the caller must call Unlock().
+    wxMutexError TryWriteLock();
+	
+	
+    // Unlock the mutex. It is an error to unlock an already unlocked mutex
+    wxMutexError Unlock();
+		
+	
+protected:
+    wxReadWriteMutexInternal *m_internal;
+	
+	
+    DECLARE_NO_COPY_CLASS(wxReadWriteMutex)
+};
+
+
+class WXDLLIMPEXP_BASE wxReadMutexLocker
+{
+public:
+    // lock the mutex in the ctor
+    wxReadMutexLocker(wxReadWriteMutex& mutex)
+	: m_isOk(false), m_mutex(mutex)
+	{ m_isOk = ( m_mutex.ReadLock() == wxMUTEX_NO_ERROR ); }
+	
+    // returns true if mutex was successfully locked in ctor
+    bool IsOk() const
+	{ return m_isOk; }
+	
+    // unlock the mutex in dtor
+    ~wxReadMutexLocker()
+	{ if ( IsOk() ) m_mutex.Unlock(); }
+	
+private:
+    // no assignment operator nor copy ctor
+    wxReadMutexLocker(const wxReadMutexLocker&);
+    wxReadMutexLocker& operator=(const wxReadMutexLocker&);
+	
+    bool     m_isOk;
+    wxReadWriteMutex& m_mutex;
+};
+
+
+class WXDLLIMPEXP_BASE wxWriteMutexLocker
+{
+public:
+    // lock the mutex in the ctor
+    wxWriteMutexLocker(wxReadWriteMutex& mutex)
+	: m_isOk(false), m_mutex(mutex)
+	{ m_isOk = ( m_mutex.WriteLock() == wxMUTEX_NO_ERROR ); }
+	
+    // returns true if mutex was successfully locked in ctor
+    bool IsOk() const
+	{ return m_isOk; }
+	
+    // unlock the mutex in dtor
+    ~wxWriteMutexLocker()
+	{ if ( IsOk() ) m_mutex.Unlock(); }
+	
+private:
+    // no assignment operator nor copy ctor
+    wxWriteMutexLocker(const wxWriteMutexLocker&);
+    wxReadMutexLocker& operator=(const wxReadMutexLocker&);
+	
+    bool     m_isOk;
+    wxReadWriteMutex& m_mutex;
+};
+
+#endif // wxUSE_RW_MUTEX
+
 // ----------------------------------------------------------------------------
 // Critical section: this is the same as mutex but is only visible to the
 // threads of the same process. For the platforms which don't have native
@@ -548,6 +677,8 @@ public:
     // identifies a thread inside a process
     wxThreadIdType GetId() const;
 
+	static wxThreadIdType GetMainThreadId();
+
     // called when the thread exits - in the context of this thread
     //
     // NB: this function will not be called if the thread is Kill()ed
Index: include/wx/chkconf.h
===================================================================
--- include/wx/chkconf.h	(revision 52157)
+++ include/wx/chkconf.h	(working copy)
@@ -68,6 +68,21 @@
 #ifdef wxNO_THREADS
 #   undef wxUSE_THREADS
 #   define wxUSE_THREADS 0
+#else
+#	ifdef wxNO_RW_MUTEX
+#		undef wxUSE_RW_MUTEX
+#		define wxUSE_RW_MUTEX 0
+#	else
+#		undef wxUSE_RW_MUTEX
+#		define wxUSE_RW_MUTEX 1
+#	endif
+#	ifdef wxNO_SHARED_MUTEX
+#		undef wxUSE_SHARED_MUTEX
+#		define wxUSE_SHARED_MUTEX 0
+#	else
+#		undef wxUSE_SHARED_MUTEX
+#		define wxUSE_SHARED_MUTEX 1
+#	endif
 #endif /* wxNO_THREADS */
 
 #ifdef wxNO_EXCEPTIONS
Index: include/wx/listimpl.cpp
===================================================================
--- include/wx/listimpl.cpp	(revision 52157)
+++ include/wx/listimpl.cpp	(working copy)
@@ -9,6 +9,9 @@
 // Licence:     wxWindows licence
 /////////////////////////////////////////////////////////////////////////////
 
+#ifndef __WX_LIST_IMPL_CPP__
+#define __WX_LIST_IMPL_CPP__
+
 #if wxUSE_STL
 
 #undef  WX_DEFINE_LIST
@@ -37,3 +40,4 @@
 
 #endif // wxUSE_STL/!wxUSE_STL
 
+#endif // __WX_LIST_IMPL_CPP__
Index: include/wx/sckaddr.h
===================================================================
--- include/wx/sckaddr.h	(revision 52157)
+++ include/wx/sckaddr.h	(working copy)
@@ -16,14 +16,45 @@
 
 #if wxUSE_SOCKETS
 
+#ifdef __DARWIN__
+#    include <Carbon/Carbon.h>
+#endif
+
+#ifndef BOOST_NO_EXCEPTIONS
+#	define BOOST_NO_EXCEPTIONS
+#	include <exception>
+
+namespace boost
+{
+	inline
+#ifdef __DARWIN__
+	__attribute__((noreturn))
+#endif	
+	void throw_exception(std::exception const & e) // user defined
+	{
+		throw e;	
+	}
+}
+
+#	include <boost/throw_exception.hpp>
+#endif
+
+#include <asio.hpp>
+#include <asio/ip/address.hpp>
+#include <asio/ip/basic_endpoint.hpp>
+
+#include "wx/event.h"
 #include "wx/string.h"
-#include "wx/gsocket.h"
 
 
-class WXDLLIMPEXP_NET wxSockAddress : public wxObject {
+
+
+
+class WXDLLIMPEXP_NET wxSockAddress : public wxObject
+{
   DECLARE_ABSTRACT_CLASS(wxSockAddress)
 public:
-  typedef enum { IPV4=1, IPV6=2, UNIX=3 } Addr;
+  typedef enum { IPV4=1, IPV6=2, UNIX=IPV4 } Addr;
 
   wxSockAddress();
   wxSockAddress(const wxSockAddress& other);
@@ -31,136 +62,254 @@ public:
 
   wxSockAddress& operator=(const wxSockAddress& other);
 
-  virtual void Clear();
-  virtual int Type() = 0;
-
-  GAddress *GetAddress() const { return m_address; }
-  void SetAddress(GAddress *address);
+  virtual void Clear() = 0;
+  virtual int Type() const = 0;
 
   // we need to be able to create copies of the addresses polymorphically (i.e.
   // without knowing the exact address class)
   virtual wxSockAddress *Clone() const = 0;
 
-protected:
-  GAddress *m_address;
-
 private:
   void Init();
 };
 
+
+
 // Interface to an IP address (either IPV4 or IPV6)
-class WXDLLIMPEXP_NET wxIPaddress : public wxSockAddress {
-  DECLARE_ABSTRACT_CLASS(wxIPaddress)
+class WXDLLIMPEXP_NET wxIPaddress : public wxSockAddress 
+{
+	DECLARE_DYNAMIC_CLASS(wxIPaddress)
 public:
   wxIPaddress();
   wxIPaddress(const wxIPaddress& other);
+	wxIPaddress(const wxString& name );
+	wxIPaddress(unsigned long addr );
+	
   virtual ~wxIPaddress();
 
-  virtual bool Hostname(const wxString& name) = 0;
-  virtual bool Service(const wxString& name) = 0;
-  virtual bool Service(unsigned short port) = 0;
+	int GetId() const { return m_id; }
+    void SetId(int Id) { m_id = Id; }
 
-  virtual bool LocalHost() = 0;
-  virtual bool IsLocalHost() const = 0;
 
-  virtual bool AnyAddress() = 0;
+	virtual int Type() const
+	{
+		int output = wxSockAddress::IPV4;
+		if ( m_IPAddress.is_v6() )
+			output = wxSockAddress::IPV6;
+		return output;
+	}
 
-  virtual wxString IPAddress() const = 0;
+	virtual void Clear() { *this = wxIPaddress(); }
 
-  virtual wxString Hostname() const = 0;
-  virtual unsigned short Service() const = 0;
-};
+	virtual wxIPaddress *Clone() const { return new wxIPaddress( *this ); }
 
-class WXDLLIMPEXP_NET wxIPV4address : public wxIPaddress {
-  DECLARE_DYNAMIC_CLASS(wxIPV4address)
-public:
-  wxIPV4address();
-  wxIPV4address(const wxIPV4address& other);
-  virtual ~wxIPV4address();
-
-  // IPV4 name formats
-  //
-  //                    hostname
-  // dot format         a.b.c.d
   virtual bool Hostname(const wxString& name);
-  bool Hostname(unsigned long addr);
-  virtual bool Service(const wxString& name);
-  virtual bool Service(unsigned short port);
+	bool Hostname(unsigned long addr); // IPv4 only
+	bool Hostname(unsigned char addr[16]);
+
+	virtual wxString Hostname() const { return m_HostName; }
+	static	wxString LocalHostname();
+
 
-  // localhost (127.0.0.1)
   virtual bool LocalHost();
   virtual bool IsLocalHost() const;
 
-  // any (0.0.0.0)
   virtual bool AnyAddress();
 
-  virtual wxString Hostname() const;
-  wxString OrigHostname() { return m_origHostname; }
-  virtual unsigned short Service() const;
-
-  // a.b.c.d
   virtual wxString IPAddress() const;
 
-  virtual int Type() { return wxSockAddress::IPV4; }
-  virtual wxSockAddress *Clone() const;
 
-  bool operator==(const wxIPV4address& addr) const;
+	// implementation from here on out.
+	asio::ip::address & GetAddress( void ) { return m_IPAddress; }
+	void SetAddress( const asio::ip::address & rAddr ) { m_IPAddress = rAddr; }
 
-private:
-  wxString m_origHostname;
+protected:
+	wxString			m_HostName;
+	asio::ip::address	m_IPAddress;
+	
+	int               	m_id;
 };
 
 
-// the IPv6 code probably doesn't work, untested -- set to 1 at your own risk
-#ifndef wxUSE_IPV6
-    #define wxUSE_IPV6 0
-#endif
 
-#if wxUSE_IPV6
 
-// Experimental Only:
-//
-// IPV6 has not yet been implemented in socket layer
-class WXDLLIMPEXP_NET wxIPV6address : public wxIPaddress {
-  DECLARE_DYNAMIC_CLASS(wxIPV6address)
-private:
-  struct sockaddr_in6 *m_addr;
+
+class WXDLLIMPEXP_NET wxIPendpoint : public wxIPaddress
+{
+	DECLARE_ABSTRACT_CLASS(wxIPendpoint)
 public:
-  wxIPV6address();
-  wxIPV6address(const wxIPV6address& other);
-  virtual ~wxIPV6address();
-
-  // IPV6 name formats
-  //
-  //                          hostname
-  //                          3ffe:ffff:0100:f101:0210:a4ff:fee3:9566
-  // compact (base85)         Itu&-ZQ82s>J%s99FJXT
-  // compressed format        ::1
-  // ipv4 mapped              ::ffff:1.2.3.4
-  virtual bool Hostname(const wxString& name);
 
-  bool Hostname(unsigned char addr[16]);
+	enum wxTransportLayerType
+	{
+		wxUNKNOWN = 0,
+		wxTCP, // connection oriented
+		wxUDP, // connectionless
+		wxDCCP, // unavailable
+		wxSCTP // unavailable
+	};
+	
+public:
+	wxIPendpoint(void);
+	wxIPendpoint(const wxIPendpoint& other);
+
+	virtual wxIPendpoint *Clone() const = 0;
+
+	wxIPendpoint(const wxIPaddress& name, const wxString& service );
+	wxIPendpoint(const wxIPaddress& name, unsigned short port = 0 );
+	
   virtual bool Service(const wxString& name);
+	virtual bool Service(unsigned short port) = 0;
+	virtual unsigned short Service() const { return m_Port; }
+	
+			void Resolve( wxEvtHandler * pHandler, bool bWait = false ) { m_pHandler = pHandler; if ( bWait ) DoSyncResolve(); else DoAsyncResolve(); }
+	
+	virtual wxTransportLayerType		TransportType( void ) const = 0;
+	static	wxIPendpoint *				CreateEndpoint( wxTransportLayerType type );
+	static 	wxIPendpoint *				CreateEndpoint( const wxIPaddress& name, const wxString& service );
+	
+protected:
+	virtual void DoSyncResolve( void ) = 0;
+	virtual void DoAsyncResolve( void ) = 0;
+	
+	wxString							m_ServiceName;
+	unsigned short						m_Port;
+	
+	wxEvtHandler *						m_pHandler;
+};
+
+
+
+
+
+class WXDLLIMPEXP_NET wxTCPIPendpoint : public wxIPendpoint
+{
+	DECLARE_DYNAMIC_CLASS(wxTCPIPendpoint)
+public:
+	wxTCPIPendpoint(void);
+	wxTCPIPendpoint(const wxTCPIPendpoint& other);
+	
+	wxTCPIPendpoint(const wxIPaddress& name, const wxString& service );
+	wxTCPIPendpoint(const wxIPaddress& name, unsigned short port = 0 );
+	
+	wxTCPIPendpoint( const asio::ip::tcp::endpoint & rEndpoint );
+	
+	virtual wxTCPIPendpoint *Clone() const;
+
+	
+	using wxIPendpoint::Service;
   virtual bool Service(unsigned short port);
 
-  // localhost (0000:0000:0000:0000:0000:0000:0000:0001 (::1))
-  virtual bool LocalHost();
-  virtual bool IsLocalHost() const;
+	virtual wxTransportLayerType		TransportType( void ) const { return wxTCP; }
 
-  // any (0000:0000:0000:0000:0000:0000:0000:0000 (::))
-  virtual bool AnyAddress();
 
-  // 3ffe:ffff:0100:f101:0210:a4ff:fee3:9566
-  virtual wxString IPAddress() const;
+	// implementation
+	asio::ip::tcp::endpoint &	GetEndpoint( void ) { return m_Endpoint; }
+	const asio::ip::tcp::endpoint &	GetEndpoint( void ) const { return m_Endpoint; }
+
+protected:
+																			 
+	virtual void DoSyncResolve( void );
+	virtual void DoAsyncResolve( void );
+
+	void handle_resolve(const asio::error_code& err,
+						asio::ip::tcp::resolver::iterator endpoint_iterator);
+	
+	asio::ip::tcp::endpoint		m_Endpoint;
+};
+
+
+wxDEPRECATED( typedef wxTCPIPendpoint wxIPV4address );
+
+
+
+class WXDLLIMPEXP_NET wxUDPIPendpoint : public wxIPendpoint
+{
+	DECLARE_DYNAMIC_CLASS(wxUDPIPendpoint)
+public:
+	wxUDPIPendpoint(void);
+	wxUDPIPendpoint(const wxUDPIPendpoint& other);
+	
+	wxUDPIPendpoint(const wxIPaddress& name, const wxString& service );
+	wxUDPIPendpoint(const wxIPaddress& name, unsigned short port = 0 );
+	
+	wxUDPIPendpoint( const asio::ip::udp::endpoint & rEndpoint );
+
+	virtual wxUDPIPendpoint *Clone() const;
+	
+	
+	using wxIPendpoint::Service;
+	virtual bool Service(unsigned short port);
+	
+	virtual wxTransportLayerType		TransportType( void ) const { return wxUDP; }
+	
+	
+	// implementation
+		  asio::ip::udp::endpoint &	GetEndpoint( void ) { return m_Endpoint; }
+	const asio::ip::udp::endpoint &	GetEndpoint( void ) const { return m_Endpoint; }
+	
+protected:
+	
+	virtual void DoSyncResolve( void );
+	virtual void DoAsyncResolve( void );
+	
+	void handle_resolve(const asio::error_code& err,
+						asio::ip::udp::resolver::iterator endpoint_iterator);
 
-  virtual wxString Hostname() const;
-  virtual unsigned short Service() const;
+	asio::ip::udp::endpoint		m_Endpoint;
+};
+
+
+
+class WXDLLIMPEXP_NET wxResolveEvent : public  wxEvent
+{
+public:
+	wxResolveEvent( int id = wxID_ANY )
+	: wxEvent(id, wxEVT_SOCKET_RESOLVE),
+	m_bContinueResolve ( true )
+	{
+	}
+	
+	
+	
+	wxResolveEvent( const wxResolveEvent & rhs )
+	: wxEvent( rhs ),
+	m_bContinueResolve ( rhs.m_bContinueResolve )
+	{
+	}
+	
+	
+	~wxResolveEvent( void )
+	{
+	}
+	
+	
+	virtual wxResolveEvent *Clone() const { return new wxResolveEvent(*this); }
+	
+	
+	// Clone the endpoint if you need to keep a copy.
+	const wxIPendpoint * GetEndpoint( void ) const { return wxDynamicCast( GetEventObject(), wxIPendpoint ); }
+	
+	bool ShouldContinueResolve( void ) const { return m_bContinueResolve; }
+	void MarkResolveComplete( void ) { m_bContinueResolve = false; }
 
-  virtual int Type() { return wxSockAddress::IPV6; }
-  virtual wxSockAddress *Clone() const { return new wxIPV6address(*this); }
+	
+protected:
+	bool	m_bContinueResolve;
 };
 
-#endif // wxUSE_IPV6
+
+#define wxSocketResolveEventHandler(func) \
+(wxObjectEventFunction)(wxEventFunction)wxStaticCastEvent(wxSocketResolveEventHandler, &func)
+
+#define EVT_SOCKET_RESOLVE(id, func) \
+wx__DECLARE_EVT1(wxEVT_SOCKET_RESOLVE, id, wxSocketResolveEventHandler(func))
+
+
+
+
+
+
+
 
 #if defined(__UNIX__) && !defined(__WINE__) && (!defined(__WXMAC__) || defined(__DARWIN__)) && !defined(__WXMSW__)
 #include <sys/socket.h>
@@ -168,21 +317,34 @@ public:
 # include <sys/un.h>
 #endif
 
-class WXDLLIMPEXP_NET wxUNIXaddress : public wxSockAddress {
-  DECLARE_DYNAMIC_CLASS(wxUNIXaddress)
+// This library is structured around Asio which is a *networking* library.
+// Therefore, even a wxUNIXendpoint is still assumed to be an endpoint
+// on a network.  At the moment, it's assumed to be TCP/IPv4
+
+class WXDLLIMPEXP_NET wxUNIXendpoint : public wxTCPIPendpoint 
+{
+	DECLARE_DYNAMIC_CLASS(wxUNIXendpoint)
 private:
-  struct sockaddr_un *m_addr;
+	friend class wxSocketClient;
+	struct sockaddr_un m_addr;
 public:
-  wxUNIXaddress();
-  wxUNIXaddress(const wxUNIXaddress& other);
-  virtual ~wxUNIXaddress();
+	wxUNIXendpoint();
+	wxUNIXendpoint(const wxUNIXendpoint& other);
+	virtual ~wxUNIXendpoint();
 
   void Filename(const wxString& name);
   wxString Filename();
 
-  virtual int Type() { return wxSockAddress::UNIX; }
-  virtual wxSockAddress *Clone() const { return new wxUNIXaddress(*this); }
+	virtual int Type() const { return wxSockAddress::UNIX; } //IPv4 only at the moment
+	
+	virtual wxUNIXendpoint *Clone() const { return new wxUNIXendpoint(*this); }
 };
+
+wxDEPRECATED( typedef wxUNIXendpoint wxUNIXaddress );
+
+#define WX_HAS_UNIX_ENDPOINT 1
+#else
+#define WX_HAS_UNIX_ENDPOINT 0
 #endif
   // __UNIX__
 
Index: include/wx/apptrait.h
===================================================================
--- include/wx/apptrait.h	(revision 52157)
+++ include/wx/apptrait.h	(working copy)
@@ -107,7 +107,7 @@ public:
     // used in both GUI and base apps). To complicate it further, GUI library
     // ("wxCore") doesn't depend on networking library and so only a functions
     // table can be passed around
-    virtual GSocketGUIFunctionsTable* GetSocketGUIFunctionsTable() = 0;
+//    virtual GSocketGUIFunctionsTable* GetSocketGUIFunctionsTable() = 0;
 #endif
 
     // return information about the (native) toolkit currently used and its
@@ -173,9 +173,9 @@ public:
     virtual wxFontMapper *CreateFontMapper();
 #endif // wxUSE_FONTMAP
     virtual wxRendererNative *CreateRenderer();
-#if wxUSE_SOCKETS
-    virtual GSocketGUIFunctionsTable* GetSocketGUIFunctionsTable();
-#endif
+//#if wxUSE_SOCKETS
+//    virtual GSocketGUIFunctionsTable* GetSocketGUIFunctionsTable();
+//#endif
 
 #ifdef __WXDEBUG__
     virtual bool ShowAssertDialog(const wxString& msg);
@@ -216,9 +216,9 @@ public:
     virtual wxFontMapper *CreateFontMapper();
 #endif // wxUSE_FONTMAP
     virtual wxRendererNative *CreateRenderer();
-#if wxUSE_SOCKETS
-    virtual GSocketGUIFunctionsTable* GetSocketGUIFunctionsTable();
-#endif
+//#if wxUSE_SOCKETS
+//    virtual GSocketGUIFunctionsTable* GetSocketGUIFunctionsTable();
+//#endif
 
 #ifdef __WXDEBUG__
     virtual bool ShowAssertDialog(const wxString& msg);
Index: configure.in
===================================================================
--- configure.in	(revision 52157)
+++ configure.in	(working copy)
@@ -373,6 +373,8 @@ if test $DEBUG_CONFIGURE = 1; then
   DEFAULT_wxUSE_NANOX=no
 
   DEFAULT_wxUSE_THREADS=yes
+  DEFAULT_wxUSE_RW_MUTEX=no
+  DEFAULT_wxUSE_SHARED_MUTEX=no
 
   DEFAULT_wxUSE_SHARED=${DEFAULT_wxUSE_SHARED:-yes}
   DEFAULT_wxUSE_OPTIMISE=no
@@ -598,6 +600,8 @@ else
   DEFAULT_wxUSE_NANOX=no
 
   DEFAULT_wxUSE_THREADS=yes
+  DEFAULT_wxUSE_RW_MUTEX=no
+  DEFAULT_wxUSE_SHARED_MUTEX=no
 
   DEFAULT_wxUSE_SHARED=${DEFAULT_wxUSE_SHARED:-yes}
   DEFAULT_wxUSE_OPTIMISE=yes
@@ -1062,6 +1066,8 @@ dnl "big" options (i.e. those which chan
 dnl ---------------------------------------------------------------------------
 
 WX_ARG_ENABLE(threads,     [  --enable-threads        use threads], wxUSE_THREADS)
+WX_ARG_ENABLE(rw_mutex,    [  --enable-rw_mutex       use read/write mutex], wxUSE_RW_MUTEX)
+WX_ARG_ENABLE(shared_mutex,[  --enable-shared_mutex   use inter-process mutex], wxUSE_SHARED_MUTEX)
 
 if test "$wxUSE_GUI" = "yes"; then
 
@@ -5690,6 +5696,10 @@ if test "$wxUSE_THREADS" = "yes"; then
   AC_DEFINE(wxUSE_THREADS)
 
   SAMPLES_SUBDIRS="$SAMPLES_SUBDIRS thread"
+  
+  if test "$wxUSE_RW_MUTEX" = "yes"; then
+    AC_DEFINE(wxUSE_RW_MUTEX)
+  fi
 else
   dnl on some systems, _REENTRANT should be defined if we want to use any _r()
   dnl functions - add tests for other functions here as well

Property changes on: misc/boost
___________________________________________________________________
Added: svn:ignore
   + *.tar.bz2
boost_1_35_*
asio-1.*


Index: misc/boost/user-config.jam
===================================================================
--- misc/boost/user-config.jam	(revision 0)
+++ misc/boost/user-config.jam	(revision 0)
@@ -0,0 +1,16 @@
+# Boost.Build Configuration
+# Automatically generated by Boost configure 
+
+# Compiler configuration
+using darwin : 8.11 : /usr/bin/g++-4.0 : 
+	<compileflags>"-arch i386 -arch ppc -mmacosx-version-min=10.4 -DMAC_OS_X_VERSION_MIN_REQUIRED=1040 -isysroot /Developer/SDKs/MacOSX10.4u.sdk"
+	<linkflags>"-mmacosx-version-min=10.4 -Wl,-syslibroot,/Developer/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc" ; 
+
+# Python configuration
+using python : 2.5 : /sw ;
+
+using mpi : /usr/bin/mpicxx ;
+
+# project.load ( tools/bcp/Jamfile.v2 ) ;
+# modules.load ( bcp : tools/bcp/Jamfile.v2 ) ;
+# project.use ( bcp : tools/bcp/Jamfile.v2 ) ;
Index: misc/boost/build_boost.sh
===================================================================
--- misc/boost/build_boost.sh	(revision 0)
+++ misc/boost/build_boost.sh	(revision 0)
@@ -0,0 +1,42 @@
+#!/bin/bash
+
+source /sw/bin/init.sh
+
+
+if test ! -d asio-1.0.0
+then
+	if test ! -e asio-1.0.0.tar.bz2
+	then
+		curl -C - -O http://internap.dl.sourceforge.net/sourceforge/asio/asio-1.0.0.tar.bz2
+	fi
+
+	tar -xf asio-1.0.0.tar.bz2
+fi
+
+cd asio-1.0.0
+./configure
+sudo make install
+cd ..
+
+if test ! -d boost_1_35_0
+then
+	if test ! -e boost_1_35_0.tar.bz2
+	then
+		curl -C - -O http://internap.dl.sourceforge.net/sourceforge/boost/boost_1_35_0.tar.bz2
+	fi
+
+	tar -xf boost_1_35_0.tar.bz2
+fi
+
+cp -f user-config.jam boost_1_35_0
+cd boost_1_35_0
+bjam --toolset=darwin --build-type=complete --with-thread --with-date_time --with-filesystem --with-regex --with-system architecture=combined
+sudo bjam --toolset=darwin --build-type=complete --with-thread --with-date_time --with-filesystem --with-regex --with-system architecture=combined install
+#./configure --with-libraries="system thread iostreams serialization signals"
+#make
+#bjam --toolset=darwin
+
+
+
+
+
Index: build/bakefiles/build_cfg.bkl
===================================================================
--- build/bakefiles/build_cfg.bkl	(revision 52157)
+++ build/bakefiles/build_cfg.bkl	(working copy)
@@ -37,6 +37,8 @@
                 @echo MSLU=$(MSLU) >>$(BUILD_CFG_FILE)
                 @echo USE_EXCEPTIONS=$(USE_EXCEPTIONS) >>$(BUILD_CFG_FILE)
                 @echo USE_THREADS=$(USE_THREADS) >>$(BUILD_CFG_FILE)
+                @echo USE_SHARED_MUTEX=$(USE_SHARED_MUTEX) >>$(BUILD_CFG_FILE)
+                @echo USE_RW_MUTEX=$(USE_RW_MUTEX) >>$(BUILD_CFG_FILE)
                 @echo USE_GUI=$(USE_GUI) >>$(BUILD_CFG_FILE)
                 @echo USE_HTML=$(USE_HTML) >>$(BUILD_CFG_FILE)
                 @echo USE_MEDIA=$(USE_MEDIA) >>$(BUILD_CFG_FILE)
Index: build/bakefiles/multilib.bkl
===================================================================
--- build/bakefiles/multilib.bkl	(revision 52157)
+++ build/bakefiles/multilib.bkl	(working copy)
@@ -34,6 +34,8 @@
         <define>WXUSINGDLL</define>
         <define>WXMAKINGDLL_NET</define>
         <sources>$(NET_SRC)</sources>
+        <include>$(SRCDIR)/misc/boost/asio-1.0.0/include</include>
+		<include>$(SRCDIR)/misc/boost/boost_1_35_0/</include>
         <msvc-headers>$(NET_CMN_HDR) $(NET_PLATFORM_HDR)</msvc-headers>
         <library>basedll</library>
     </dll>
@@ -41,6 +43,8 @@
     <lib id="netlib" template="wx_base_lib"
          cond="SHARED=='0' and MONOLITHIC=='0'">
         <sources>$(NET_SRC)</sources>
+        <include>$(SRCDIR)/misc/boost/asio-1.0.0/include</include>
+		<include>$(SRCDIR)/misc/boost/boost_1_35_0/</include>
         <msvc-headers>$(NET_CMN_HDR) $(NET_PLATFORM_HDR)</msvc-headers>
     </lib>
 
@@ -174,12 +178,16 @@
         <library>coredll</library>
         <library>basedll</library>
         <ldlibs>$(EXTRALIBS_HTML)</ldlibs>
+        <include>$(SRCDIR)/misc/boost/asio-1.0.0/include</include>
+		<include>$(SRCDIR)/misc/boost/boost_1_35_0/</include>
         <msvc-headers>$(HTML_HDR)</msvc-headers>
     </dll>
 
     <lib id="htmllib" template="wx_lib"
          cond="SHARED=='0' and USE_GUI=='1' and USE_HTML=='1' and MONOLITHIC=='0'">
         <sources>$(HTML_SRC)</sources>
+        <include>$(SRCDIR)/misc/boost/asio-1.0.0/include</include>
+		<include>$(SRCDIR)/misc/boost/boost_1_35_0/</include>
         <msvc-headers>$(HTML_HDR)</msvc-headers>
     </lib>
 
Index: build/bakefiles/common.bkl
===================================================================
--- build/bakefiles/common.bkl	(revision 52157)
+++ build/bakefiles/common.bkl	(working copy)
@@ -256,6 +256,12 @@
     <set var="THREAD_DEFINE">
         <if cond="USE_THREADS=='0'">wxNO_THREADS</if>
     </set>
+    <set var="RW_MUTEX_DEFINE">
+    	<if cond="USE_RW_MUTEX=='0'">wxNO_RW_MUTEX</if>
+    </set>
+    <set var="SHARED_MUTEX_DEFINE">
+    	<if cond="USE_SHARED_MUTEX=='0'">wxNO_SHARED_MUTEX</if>
+    </set>
 
     <set var="DEBUG_DEFINE">
         <if cond="FORMAT!='autoconf' and BUILD=='debug' and DEBUG_FLAG=='default'">__WXDEBUG__</if>
@@ -480,6 +486,7 @@ $(TAB)$(VC_COMPILER) /EP /nologo "$(DOLL
         <define>$(EXCEPTIONS_DEFINE)</define>
         <define>$(RTTI_DEFINE)</define>
         <define>$(THREAD_DEFINE)</define>
+        <define>$(RW_MUTEX_DEFINE)</define>
         <define>$(UNICODE_DEFINE)</define>
         <define>$(MSLU_DEFINE)</define>
         <if cond="FORMAT!='autoconf'"><define>$(GFXCTX_DEFINE)</define></if>
@@ -756,6 +763,10 @@ $(TAB)$(VC_COMPILER) /EP /nologo "$(DOLL
 
     <!-- Link against one wxWin library. Value must be literal! -->
     <define-tag name="wx-lib" rules="exe,dll,module">
+		<if cond="value=='net'">
+			<include>$(TOP_SRCDIR)/misc/boost/asio-1.0.0/include</include>
+			<include>$(TOP_SRCDIR)/misc/boost/boost_1_35_0/</include>
+        </if>
         <sys-lib>$(wxwin.libToLink(value))</sys-lib>
         <ldlibs>$(wxwin.extraLdflags(value))</ldlibs>
         <if cond="IS_MSVC_PRJ=='1' and MONOLITHIC=='0'">
Index: build/bakefiles/wxpresets/presets/wx_win32.bkl
===================================================================
--- build/bakefiles/wxpresets/presets/wx_win32.bkl	(revision 52157)
+++ build/bakefiles/wxpresets/presets/wx_win32.bkl	(working copy)
@@ -259,7 +259,11 @@ FIXME: this template has (at least) the 
         <if cond="value=='base'"><sys-lib>$(WXLIB_BASE_NAME)</sys-lib></if>
         <if cond="value=='core'"><sys-lib>$(WXLIB_CORE_NAME)</sys-lib></if>
 
-        <if cond="value=='net'"><sys-lib>$(WXLIB_NET_NAME)</sys-lib></if>
+        <if cond="value=='net'">
+			<include>$(WX_DIR)/misc/boost/asio-1.0.0/include</include>
+			<include>$(WX_DIR)/misc/boost/boost_1_35_0/</include>
+        	<sys-lib>$(WXLIB_NET_NAME)</sys-lib>
+        </if>
         <if cond="value=='xml'"><sys-lib>$(WXLIB_XML_NAME)</sys-lib></if>
         <if cond="value=='odbc'"><sys-lib>$(WXLIB_ODBC_NAME)</sys-lib></if>
 
Index: build/bakefiles/wxpresets/presets/wx_unix.bkl
===================================================================
--- build/bakefiles/wxpresets/presets/wx_unix.bkl	(revision 52157)
+++ build/bakefiles/wxpresets/presets/wx_unix.bkl	(working copy)
@@ -119,6 +119,10 @@ Format-specific notes:
                  thus we can now add WX_LIBS to the linker line -->
             <ldflags>$(WX_LIBS)</ldflags>
         </if>
+        <if cond="value=='net'">
+			<include>$(WX_DIR)/misc/boost/asio-1.0.0/include</include>
+			<include>$(WX_DIR)/misc/boost/boost_1_35_0/</include>
+        </if>
         <if cond="FORMAT=='gnu' and value=='base'">
             <!-- all wx libraries should have been already specified, thus
                   $(__liblist) should contain the full list... -->
Index: build/bakefiles/files.bkl
===================================================================
--- build/bakefiles/files.bkl	(revision 52157)
+++ build/bakefiles/files.bkl	(working copy)
@@ -484,18 +484,14 @@ IMPORTANT: please read docs/tech/tn0016.
 <!-- ====================================================================== -->
 
 <set var="NET_UNIX_SRC" hints="files">
-    src/unix/gsocket.cpp
 </set>
 <set var="NET_UNIX_HDR" hints="files">
-    wx/unix/gsockunx.h
 </set>
 
 <set var="NET_WIN32_SRC" hints="files">
-    src/msw/gsocket.cpp
     src/msw/urlmsw.cpp
 </set>
 <set var="NET_WIN32_HDR" hints="files">
-    wx/msw/gsockmsw.h
 </set>
 
 <set var="NET_WINCE_SRC" hints="files">
@@ -506,17 +502,13 @@ IMPORTANT: please read docs/tech/tn0016.
 </set>
 
 <set var="NET_OS2_SRC" hints="files">
-    src/unix/gsocket.cpp
 </set>
 <set var="NET_OS2_HDR" hints="files">
-    wx/unix/gsockunx.h
 </set>
 <!-- Net files used only by CarbonLib (not Classic or OS X) -->
 <set var="NET_MAC_CARBONLIB_SRC" hints="files">
-    src/mac/carbon/gsocket.cpp
 </set>
 <set var="NET_MAC_CARBONLIB_HDR" hints="files">
-    wx/mac/carbon/gsockmac.h
 </set>
 
 <set var="NET_CMN_SRC" hints="files">
@@ -533,7 +525,6 @@ IMPORTANT: please read docs/tech/tn0016.
 </set>
 <set var="NET_CMN_HDR" hints="files">
     wx/fs_inet.h
-    wx/gsocket.h
     wx/protocol/file.h
     wx/protocol/ftp.h
     wx/protocol/http.h
@@ -927,7 +918,6 @@ IMPORTANT: please read docs/tech/tn0016.
     src/gtk/dnd.cpp
     src/gtk/evtloop.cpp
     src/gtk/font.cpp
-    src/gtk/gsockgtk.cpp
     src/gtk/main.cpp
     src/gtk/minifram.cpp
     src/gtk/pen.cpp
@@ -1107,7 +1097,6 @@ IMPORTANT: please read docs/tech/tn0016.
     src/gtk1/dnd.cpp
     src/gtk1/evtloop.cpp
     src/gtk1/font.cpp
-    src/gtk1/gsockgtk.cpp
     src/gtk1/main.cpp
     src/gtk1/minifram.cpp
     src/gtk1/pen.cpp
@@ -1288,7 +1277,6 @@ IMPORTANT: please read docs/tech/tn0016.
     src/motif/font.cpp
     src/motif/frame.cpp
     src/motif/gauge.cpp
-    src/motif/gsockmot.cpp
     src/motif/icon.cpp
     src/motif/listbox.cpp
     src/motif/main.cpp
@@ -1401,7 +1389,6 @@ IMPORTANT: please read docs/tech/tn0016.
 
 <set var="X11_LOWLEVEL_SRC" hints="files">
     $(XWIN_LOWLEVEL_SRC)
-    src/common/socketevtdispatch.cpp
     src/generic/icon.cpp
     src/generic/timer.cpp
     src/x11/app.cpp
@@ -1496,7 +1483,6 @@ IMPORTANT: please read docs/tech/tn0016.
     src/msw/gdiimage.cpp
     src/msw/gdiobj.cpp
     src/msw/graphics.cpp
-    src/msw/gsockmsw.cpp
     src/msw/icon.cpp
     src/msw/imaglist.cpp
     src/msw/minifram.cpp
@@ -1820,7 +1806,6 @@ IMPORTANT: please read docs/tech/tn0016.
 
 <set var="DFB_LOWLEVEL_SRC" hints="files">
     src/common/fontmgrcmn.cpp
-    src/common/socketevtdispatch.cpp
     src/generic/caret.cpp
     src/generic/colour.cpp
     src/generic/icon.cpp
@@ -1930,7 +1915,6 @@ IMPORTANT: please read docs/tech/tn0016.
     src/os2/frame.cpp
     src/os2/gauge.cpp
     src/os2/gdiimage.cpp
-    src/os2/gsockpm.cpp
     src/os2/helpwin.cpp
     src/os2/icon.cpp
     src/os2/iniconf.cpp
@@ -2053,7 +2037,6 @@ IMPORTANT: please read docs/tech/tn0016.
 
 <set var="MAC_OSX_LOWLEVEL_SRC" hints="files">
     <!-- Shared wxMac and wxCocoa files -->
-    src/mac/corefoundation/gsockosx.cpp
     src/mac/corefoundation/hid.cpp
     src/mac/corefoundation/utilsexc_cf.cpp
 </set>
@@ -2205,7 +2188,6 @@ IMPORTANT: please read docs/tech/tn0016.
     wx/mac/frame.h
     wx/mac/gauge.h
     wx/mac/glcanvas.h
-    wx/mac/gsockmac.h
     wx/mac/helpxxxx.h
     wx/mac/icon.h
     wx/mac/imaglist.h
@@ -2213,7 +2195,6 @@ IMPORTANT: please read docs/tech/tn0016.
     wx/mac/listbox.h
     wx/mac/listctrl.h
     wx/mac/macnotfy.h
-    wx/mac/macsock.h
     wx/mac/mdi.h
     wx/mac/menu.h
     wx/mac/menuitem.h
@@ -2291,14 +2272,12 @@ IMPORTANT: please read docs/tech/tn0016.
     wx/mac/carbon/fontdlg.h
     wx/mac/carbon/frame.h
     wx/mac/carbon/gauge.h
-    wx/mac/carbon/gsockmac.h
     wx/mac/carbon/helpxxxx.h
     wx/mac/carbon/icon.h
     wx/mac/carbon/imaglist.h
     wx/mac/carbon/listbox.h
     wx/mac/carbon/listctrl.h
     wx/mac/carbon/macnotfy.h
-    wx/mac/carbon/macsock.h
     wx/mac/carbon/mdi.h
     wx/mac/carbon/menu.h
     wx/mac/carbon/menuitem.h
@@ -2358,7 +2337,6 @@ IMPORTANT: please read docs/tech/tn0016.
 
 <set var="COCOA_LOWLEVEL_SRC" hints="files">
     <!-- Shared wxMac and wxCocoa files -->
-    src/mac/corefoundation/gsockosx.cpp
     src/mac/corefoundation/hid.cpp
     src/mac/corefoundation/utilsexc_cf.cpp
 </set>
Index: build/bakefiles/config.bkl
===================================================================
--- build/bakefiles/config.bkl	(revision 52157)
+++ build/bakefiles/config.bkl	(working copy)
@@ -266,6 +266,22 @@ Acts according to BUILD by default.
         </description>
     </option>
 
+    <option name="USE_SHARED_MUTEX">
+        <values>0,1</values>
+        <default-value>0</default-value>
+        <description>
+            Enable multi-process shared mutex. (USE_THREADS must be 1, only implemented on Mac OS X)
+        </description>
+    </option>
+
+    <option name="USE_RW_MUTEX">
+        <values>0,1</values>
+        <default-value>0</default-value>
+        <description>
+            Enable read/write mutex. (USE_THREADS must be 1, only implemented on Mac OS X)
+        </description>
+    </option>
+
     <if cond="FORMAT!='autoconf'">
         <option name="USE_GDIPLUS">
             <values>0,1</values>
Index: build/bakefiles/monolithic.bkl
===================================================================
--- build/bakefiles/monolithic.bkl	(revision 52157)
+++ build/bakefiles/monolithic.bkl	(working copy)
@@ -17,6 +17,8 @@
         <define>wxUSE_BASE=1</define>
         <define>WXMAKINGDLL</define>
         <sources>$(MONOLIB_SRC) $(PLUGIN_MONOLIB_SRC)</sources>
+        <include>$(SRCDIR)/misc/boost/asio-1.0.0/include</include>
+		<include>$(SRCDIR)/misc/boost/boost_1_35_0/</include>
         <ldlibs>$(EXTRALIBS_XML)</ldlibs>
         <ldlibs>$(EXTRALIBS_HTML)</ldlibs>
         <ldlibs>$(EXTRALIBS_MEDIA)</ldlibs>
@@ -29,6 +31,8 @@
          cond="SHARED=='0' and MONOLITHIC=='1'">
         <define>wxUSE_BASE=1</define>
         <sources>$(MONOLIB_SRC) $(PLUGIN_MONOLIB_SRC)</sources>
+        <include>$(SRCDIR)/misc/boost/asio-1.0.0/include</include>
+		<include>$(SRCDIR)/misc/boost/boost_1_35_0/</include>
         <msvc-headers>$(ALL_HEADERS)</msvc-headers>
         <if cond="FORMAT=='watcom'">
             <set var="LIB_PAGESIZE" overwrite="1">8192</set>
Index: build/aclocal/bakefile-lang.m4
===================================================================
--- build/aclocal/bakefile-lang.m4	(revision 52157)
+++ build/aclocal/bakefile-lang.m4	(working copy)
@@ -1,5 +1,5 @@
 dnl
-dnl  This file is part of Bakefile (http://bakefile.sourceforge.net)
+dnl  This file is part of Bakefile (http://www.bakefile.org)
 dnl
 dnl  Copyright (C) 2003-2007 Vaclav Slavik, David Elliott and others
 dnl
@@ -23,77 +23,15 @@ dnl  DEALINGS IN THE SOFTWARE.
 dnl
 dnl  $Id$
 dnl
-dnl  Compiler detection macros by David Elliott
+dnl  Compiler detection macros by David Elliott and Vadim Zeitlin
 dnl
 
 
 dnl ===========================================================================
-dnl Macros to detect non-GNU compilers (MetroWerks, XLC)
+dnl Macros to detect different C/C++ compilers
 dnl ===========================================================================
 
 dnl Based on autoconf _AC_LANG_COMPILER_GNU
-AC_DEFUN([_AC_BAKEFILE_LANG_COMPILER_MWERKS],
-[AC_CACHE_CHECK([whether we are using the Metrowerks _AC_LANG compiler],
-    [bakefile_cv_[]_AC_LANG_ABBREV[]_compiler_mwerks],
-    [AC_TRY_COMPILE([],[#ifndef __MWERKS__
-       choke me
-#endif
-],
-        [bakefile_compiler_mwerks=yes],
-        [bakefile_compiler_mwerks=no])
-    bakefile_cv_[]_AC_LANG_ABBREV[]_compiler_mwerks=$bakefile_compiler_mwerks
-    ])
-])
-
-dnl Loosely based on autoconf AC_PROG_CC
-dnl TODO: Maybe this should wrap the call to AC_PROG_CC and be used instead.
-AC_DEFUN([AC_BAKEFILE_PROG_MWCC],
-[AC_LANG_PUSH(C)
-_AC_BAKEFILE_LANG_COMPILER_MWERKS
-MWCC=`test $bakefile_cv_c_compiler_mwerks = yes && echo yes`
-AC_LANG_POP(C)
-])
-
-dnl Loosely based on autoconf AC_PROG_CXX
-dnl TODO: Maybe this should wrap the call to AC_PROG_CXX and be used instead.
-AC_DEFUN([AC_BAKEFILE_PROG_MWCXX],
-[AC_LANG_PUSH(C++)
-_AC_BAKEFILE_LANG_COMPILER_MWERKS
-MWCXX=`test $bakefile_cv_cxx_compiler_mwerks = yes && echo yes`
-AC_LANG_POP(C++)
-])
-
-dnl Based on autoconf _AC_LANG_COMPILER_GNU
-AC_DEFUN([_AC_BAKEFILE_LANG_COMPILER_XLC],
-[AC_CACHE_CHECK([whether we are using the IBM xlC _AC_LANG compiler],
-    [bakefile_cv_[]_AC_LANG_ABBREV[]_compiler_xlc],
-    [AC_TRY_COMPILE([],[#ifndef __xlC__
-       choke me
-#endif
-],
-        [bakefile_compiler_xlc=yes],
-        [bakefile_compiler_xlc=no])
-    bakefile_cv_[]_AC_LANG_ABBREV[]_compiler_xlc=$bakefile_compiler_xlc
-    ])
-])
-
-dnl Loosely based on autoconf AC_PROG_CC
-AC_DEFUN([AC_BAKEFILE_PROG_XLCC],
-[AC_LANG_PUSH(C)
-_AC_BAKEFILE_LANG_COMPILER_XLC
-XLCC=`test $bakefile_cv_c_compiler_xlc = yes && echo yes`
-AC_LANG_POP(C)
-])
-
-dnl Loosely based on autoconf AC_PROG_CXX
-AC_DEFUN([AC_BAKEFILE_PROG_XLCXX],
-[AC_LANG_PUSH(C++)
-_AC_BAKEFILE_LANG_COMPILER_XLC
-XLCXX=`test $bakefile_cv_cxx_compiler_xlc = yes && echo yes`
-AC_LANG_POP(C++)
-])
-
-dnl Based on autoconf _AC_LANG_COMPILER_GNU
 dnl _AC_BAKEFILE_LANG_COMPILER(NAME, LANG, SYMBOL, IF-YES, IF-NO)
 AC_DEFUN([_AC_BAKEFILE_LANG_COMPILER],
 [
@@ -113,12 +51,34 @@ AC_DEFUN([_AC_BAKEFILE_LANG_COMPILER],
          )
         ]
     )
-    AC_LANG_POP($2)
     if test "x$bakefile_cv_[]_AC_LANG_ABBREV[]_compiler_[]$3" = "xyes"; then
         :; $4
     else
         :; $5
     fi
+    AC_LANG_POP($2)
+])
+
+dnl CodeWarrior Metrowerks compiler defines __MWERKS__ for both C and C++
+AC_DEFUN([AC_BAKEFILE_PROG_MWCC],
+[
+    _AC_BAKEFILE_LANG_COMPILER(Metrowerks, C, __MWERKS__, MWCC=yes)
+])
+
+AC_DEFUN([AC_BAKEFILE_PROG_MWCXX],
+[
+    _AC_BAKEFILE_LANG_COMPILER(Metrowerks, C++, __MWERKS__, MWCXX=yes)
+])
+
+dnl IBM xlC compiler defines __xlC__ for both C and C++
+AC_DEFUN([AC_BAKEFILE_PROG_XLCC],
+[
+    _AC_BAKEFILE_LANG_COMPILER([IBM xlC], C, __xlC__, XLCC=yes)
+])
+
+AC_DEFUN([AC_BAKEFILE_PROG_XLCXX],
+[
+    _AC_BAKEFILE_LANG_COMPILER([IBM xlC], C++, __xlC__, XLCXX=yes)
 ])
 
 dnl recent versions of SGI mipsPro compiler define _SGI_COMPILER_VERSION
@@ -228,7 +188,12 @@ dnl _AC_BAKEFILE_PROG_COMPILER(LANG)
 AC_DEFUN([_AC_BAKEFILE_PROG_COMPILER],
 [
     AC_PROG_$1
+
+    dnl Intel compiler can be used under several different OS and even
+    dnl different architectures (x86, amd64 and Itanium) so it's easier to just
+    dnl always test for it
     AC_BAKEFILE_PROG_INTEL$1
+
     dnl if we're using gcc, we can't be using any of incompatible compilers
     if test "x$G$1" != "xyes"; then
         if test "x$1" = "xC"; then
@@ -255,6 +220,11 @@ AC_DEFUN([_AC_BAKEFILE_PROG_COMPILER],
                 AC_BAKEFILE_PROG_SGI$1
                 ;;
 
+            Linux*)
+                dnl Sun CC is now available under Linux too
+                AC_BAKEFILE_PROG_SUN$1
+                ;;
+
             HP-UX*)
                 AC_BAKEFILE_PROG_HP$1
                 ;;
Index: build/aclocal/bakefile.m4
===================================================================
--- build/aclocal/bakefile.m4	(revision 52157)
+++ build/aclocal/bakefile.m4	(working copy)
@@ -1,5 +1,5 @@
 dnl
-dnl  This file is part of Bakefile (http://bakefile.sourceforge.net)
+dnl  This file is part of Bakefile (http://www.bakefile.org)
 dnl
 dnl  Copyright (C) 2003-2007 Vaclav Slavik and others
 dnl
@@ -126,8 +126,7 @@ AC_DEFUN([AC_BAKEFILE_PLATFORM],
                 PLATFORM_BEOS=1
             ;;
             * )
-                dnl wxWidgets-specific: allow unknown Unix systems
-                dnl AC_MSG_ERROR([Unknown platform: $BAKEFILE_FORCE_PLATFORM])
+                AC_MSG_ERROR([Unknown platform: $BAKEFILE_FORCE_PLATFORM])
             ;;
         esac
     fi
@@ -309,27 +308,17 @@ AC_DEFUN([AC_BAKEFILE_SHARED_LD],
       ;;
 
       *-*-linux* )
-        if test "x$GCC" != "xyes"; then
-            AC_CACHE_CHECK([for Intel compiler], bakefile_cv_prog_icc,
-            [
-                AC_TRY_COMPILE([],
-                    [
-                        #ifndef __INTEL_COMPILER
-                        This is not ICC
-                        #endif
-                    ],
-                    bakefile_cv_prog_icc=yes,
-                    bakefile_cv_prog_icc=no
-                )
-            ])
-            if test "$bakefile_cv_prog_icc" = "yes"; then
+        if test "$INTELCC" = "yes"; then
+            PIC_FLAG="-KPIC"
+        elif test "x$SUNCXX" = "xyes"; then
+            SHARED_LD_CC="${CC} -G -o"
+            SHARED_LD_CXX="${CXX} -G -o"
                 PIC_FLAG="-KPIC"
-            fi
         fi
       ;;
 
       *-*-solaris2* )
-        if test "x$GCC" != xyes ; then
+        if test "x$SUNCXX" = xyes ; then
             SHARED_LD_CC="${CC} -G -o"
             SHARED_LD_CXX="${CXX} -G -o"
             PIC_FLAG="-KPIC"
@@ -341,7 +330,7 @@ AC_DEFUN([AC_BAKEFILE_SHARED_LD],
         chmod +x shared-ld-sh
 
         SHARED_LD_MODULE_CC="`pwd`/shared-ld-sh -bundle -headerpad_max_install_names -o"
-        SHARED_LD_MODULE_CXX="$SHARED_LD_MODULE_CC"
+        SHARED_LD_MODULE_CXX="CXX=\$(CXX) $SHARED_LD_MODULE_CC"
 
         dnl Most apps benefit from being fully binded (its faster and static
         dnl variables initialized at startup work).
@@ -499,8 +488,13 @@ AC_DEFUN([AC_BAKEFILE_SHARED_VERSIONS],
     SONAME_FLAG=
 
     case "${BAKEFILE_HOST}" in
-      *-*-linux* | *-*-freebsd* | *-*-k*bsd*-gnu )
+      *-*-linux* | *-*-freebsd* | *-*-openbsd* | *-*-netbsd* | \
+      *-*-k*bsd*-gnu | *-*-mirbsd* )
+        if test "x$SUNCXX" = "xyes"; then
+            SONAME_FLAG="-h "
+        else
         SONAME_FLAG="-Wl,-soname,"
+        fi
         USE_SOVERSION=1
         USE_SOVERLINUX=1
         USE_SOSYMLINKS=1
@@ -645,18 +639,21 @@ AC_DEFUN([AC_BAKEFILE_CHECK_BASIC_STUFF]
     AC_CHECK_TOOL(STRIP, strip, :)
     AC_CHECK_TOOL(NM, nm, :)
 
-    case ${BAKEFILE_HOST} in
-        *-hp-hpux* )
-            dnl HP-UX install doesn't handle the "-d" switch so don't
-            dnl use it there
-            INSTALL_DIR="mkdir -p"
-            ;;
-        * )
+    dnl This check is necessary because "install -d" doesn't exist on
+    dnl all platforms (e.g. HP/UX), see http://www.bakefile.org/ticket/80
+    AC_MSG_CHECKING([for command to install directories])
+    INSTALL_TEST_DIR=acbftest$$
+    $INSTALL -d $INSTALL_TEST_DIR > /dev/null 2>&1
+    if test $? = 0 -a -d $INSTALL_TEST_DIR; then
+        rmdir $INSTALL_TEST_DIR
             dnl we must refer to makefile's $(INSTALL) variable and not
             dnl current value of shell variable, hence the single quoting:
             INSTALL_DIR='$(INSTALL) -d'
-            ;;
-    esac
+        AC_MSG_RESULT([$INSTALL -d])
+    else
+        INSTALL_DIR="mkdir -p"
+        AC_MSG_RESULT([mkdir -p])
+    fi
     AC_SUBST(INSTALL_DIR)
 
     LDFLAGS_GUI=
@@ -804,6 +801,12 @@ AC_DEFUN([AC_BAKEFILE],
 [
     AC_PREREQ([2.58])
 
+    dnl We need to always run C/C++ compiler tests, but it's also possible
+    dnl for the user to call these macros manually, hence this instead of
+    dnl simply calling these macros. See http://www.bakefile.org/ticket/64
+    AC_REQUIRE([AC_BAKEFILE_PROG_CC])
+    AC_REQUIRE([AC_BAKEFILE_PROG_CXX])
+
     if test "x$BAKEFILE_HOST" = "x"; then
                if test "x${host}" = "x" ; then
                        AC_MSG_ERROR([You must call the autoconf "CANONICAL_HOST" macro in your configure.ac (or .in) file.])
@@ -824,7 +827,7 @@ AC_DEFUN([AC_BAKEFILE],
     AC_BAKEFILE_DEPS
     AC_BAKEFILE_RES_COMPILERS
 
-    BAKEFILE_BAKEFILE_M4_VERSION="0.2.2"
+    BAKEFILE_BAKEFILE_M4_VERSION="0.2.3"
 
     dnl includes autoconf_inc.m4:
     $1
@@ -852,7 +855,7 @@ D='$'
 cat <<EOF >bk-deps
 #!/bin/sh
 
-# This script is part of Bakefile (http://bakefile.sourceforge.net) autoconf
+# This script is part of Bakefile (http://www.bakefile.org) autoconf
 # script. It is used to track C/C++ files dependencies in portable way.
 #
 # Permission is given to use this file in any way.
@@ -866,10 +869,8 @@ mkdir -p ${D}DEPSDIR
 if test ${D}DEPSMODE = gcc ; then
     ${D}* ${D}{DEPSFLAG}
     status=${D}?
-    if test ${D}{status} != 0 ; then
-        exit ${D}{status}
-    fi
-    # move created file to the location we want it in:
+
+    # determine location of created files:
     while test ${D}# -gt 0; do
         case "${D}1" in
             -o )
@@ -886,6 +887,14 @@ if test ${D}DEPSMODE = gcc ; then
     done
     depfile=\`basename ${D}srcfile | sed -e 's/\\..*${D}/.d/g'\`
     depobjname=\`echo ${D}depfile |sed -e 's/\\.d/.o/g'\`
+    
+    # if the compiler failed, we're done:
+    if test ${D}{status} != 0 ; then
+        rm -f ${D}depfile
+        exit ${D}{status}
+    fi
+
+    # move created file to the location we want it in:
     if test -f ${D}depfile ; then
         sed -e "s,${D}depobjname:,${D}objfile:,g" ${D}depfile >${D}{DEPSDIR}/${D}{objfile}.d
         rm -f ${D}depfile
@@ -975,6 +984,10 @@ objects=""
 linking_flag="-dynamiclib"
 ldargs="-r -keep_private_externs -nostdlib"
 
+if test "x${D}CXX" = "x"; then
+    CXX="c++"
+fi
+
 while test ${D}# -gt 0; do
     case ${D}1 in
 
@@ -988,6 +1001,12 @@ while test ${D}# -gt 0; do
         shift
         ;;
 
+       -arch|-isysroot)
+        # collect these options and values
+        ldargs="${D}{ldargs} ${D}1 ${D}2"
+        shift
+        ;;
+
        -s|-Wl,*)
         # collect these load args
         ldargs="${D}{ldargs} ${D}1"
@@ -1027,9 +1046,9 @@ status=0
 # Link one module containing all the others
 #
 if test ${D}{verbose} = 1; then
-    echo "c++ ${D}{ldargs} ${D}{objects} -o master.${D}${D}.o"
+    echo "${D}CXX ${D}{ldargs} ${D}{objects} -o master.${D}${D}.o"
 fi
-c++ ${D}{ldargs} ${D}{objects} -o master.${D}${D}.o
+${D}CXX ${D}{ldargs} ${D}{objects} -o master.${D}${D}.o
 status=${D}?
 
 #
@@ -1038,9 +1057,9 @@ status=${D}?
 #
 if test ${D}{status} = 0; then
     if test ${D}{verbose} = 1; then
-        echo "c++ ${D}{linking_flag} master.${D}${D}.o ${D}{args}"
+        echo "${D}CXX ${D}{linking_flag} master.${D}${D}.o ${D}{args}"
     fi
-    c++ ${D}{linking_flag} master.${D}${D}.o ${D}{args}
+    ${D}CXX ${D}{linking_flag} master.${D}${D}.o ${D}{args}
     status=${D}?
 fi
 
@@ -1063,7 +1082,7 @@ D='$'
 cat <<EOF >bk-make-pch
 #!/bin/sh
 
-# This script is part of Bakefile (http://bakefile.sourceforge.net) autoconf
+# This script is part of Bakefile (http://www.bakefile.org) autoconf
 # script. It is used to generated precompiled headers.
 #
 # Permission is given to use this file in any way.
Index: samples/sockets/client.cpp
===================================================================
--- samples/sockets/client.cpp	(revision 52157)
+++ samples/sockets/client.cpp	(working copy)
@@ -154,6 +154,8 @@ IMPLEMENT_APP(MyApp)
 
 bool MyApp::OnInit()
 {
+	wxSocketBase::Initialize();
+	
   // Create the main application window
   MyFrame *frame = new MyFrame();
 
@@ -245,6 +247,8 @@ MyFrame::~MyFrame()
 
 void MyFrame::OnQuit(wxCommandEvent& WXUNUSED(event))
 {
+	wxSocketBase::Shutdown();
+
   // true is to force the frame to close
   Close(true);
 }
Index: aclocal.m4
===================================================================
--- aclocal.m4	(revision 52157)
+++ aclocal.m4	(working copy)
@@ -1,7 +1,7 @@
-# generated automatically by aclocal 1.10 -*- Autoconf -*-
+# generated automatically by aclocal 1.10.1 -*- Autoconf -*-
 
 # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
-# 2005, 2006  Free Software Foundation, Inc.
+# 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
