Index: include/wx/mac/bitmap.h
===================================================================
RCS file: /home/wxcvs/wxWindows/include/wx/mac/bitmap.h,v
retrieving revision 1.11
diff -r1.11 bitmap.h
18a19,24
> 
> // Classes defined in this header
> class WXDLLEXPORT wxBitmap;
> class WXDLLEXPORT wxBitmapHandler;
> class WXDLLEXPORT wxMask;
> 
21,28d26
< // Bitmap
< class WXDLLEXPORT wxDC;
< class WXDLLEXPORT wxControl;
< class WXDLLEXPORT wxBitmap;
< class WXDLLEXPORT wxBitmapHandler;
< class WXDLLEXPORT wxIcon;
< class WXDLLEXPORT wxCursor;
< class WXDLLEXPORT wxImage;
66,68d63
< protected:
<   WXHBITMAP m_maskBitmap;
< };
70,79c65,66
< enum { kMacBitmapTypeUnknownType , kMacBitmapTypeGrafWorld, kMacBitmapTypePict , kMacBitmapTypeIcon } ;
< 
< class WXDLLEXPORT wxBitmapRefData: public wxGDIRefData
< {
<     friend class WXDLLEXPORT wxBitmap;
<     friend class WXDLLEXPORT wxIcon;
<     friend class WXDLLEXPORT wxCursor;
< public:
<     wxBitmapRefData();
<     ~wxBitmapRefData();
---
>   protected:
>     WXHBITMAP m_maskBitmap;
81,94c68,69
< public:
<   int           m_width;
<   int           m_height;
<   int           m_depth;
<   bool          m_ok;
<   int           m_numColors;
<   wxPalette     m_bitmapPalette;
<   int           m_quality;
< 
< 	int						m_bitmapType ;
< 	PicHandle			m_hPict ;
< 	WXHBITMAP     m_hBitmap;
< 	WXHICON m_hIcon ;
<   wxMask *      m_bitmapMask; // Optional mask
---
>   private:
>     int m_width, m_height;
97c72,73
< #define M_BITMAPDATA ((wxBitmapRefData *)m_refData)
---
> enum { kMacBitmapTypeUnknownType , kMacBitmapTypeGrafWorld, kMacBitmapTypePict } ;
> 
125d100
< #define M_BITMAPHANDLERDATA ((wxBitmapRefData *)bitmap->GetRefData())
137,138c112
<   inline wxBitmap(const wxBitmap& bitmap)
<   { Ref(bitmap); if ( wxTheBitmapList ) wxTheBitmapList->AddBitmap(this); }
---
>   wxBitmap(const wxBitmap& bitmap);
143,144d116
<   // Initialize with XPM data
<   bool CreateFromXpm(const char **bits);
156a129
> #if wxUSE_IMAGE
159,162c132
<   
<   ~wxBitmap();
<   
<   wxImage ConvertToImage() const;
---
> #endif // wxUSE_IMAGE
164,165c134,137
<   // get the given part of bitmap
<   wxBitmap GetSubBitmap( const wxRect& rect ) const;
---
>   // Convert from wxIcon
>   wxBitmap(const wxIcon &icon);
> 
>   ~wxBitmap();
171a144,150
> #if wxUSE_IMAGE
>   wxImage ConvertToImage() const;
> #endif // wxUSE_IMAGE
> 
>   // get the given part of bitmap
>   wxBitmap GetSubBitmap( const wxRect& rect ) const;
> 
173c152,155
<   virtual bool CopyFromIcon(const wxIcon& icon);
---
>   bool CopyFromIcon(const wxIcon& icon);
> 
>   // copies the contents and mask of the given cursor to the bitmap
>   bool CopyFromCursor(const wxCursor& cursor);  // TODO
179a162
> 
191a175
>   void SetBitmapType(int type);
194,196c178,181
<   inline wxBitmap& operator = (const wxBitmap& bitmap) { if (*this == bitmap) return (*this); Ref(bitmap); return *this; }
<   inline bool operator == (const wxBitmap& bitmap) { return m_refData == bitmap.m_refData; }
<   inline bool operator != (const wxBitmap& bitmap) { return m_refData != bitmap.m_refData; }
---
>   wxBitmap& operator = (const wxBitmap& bitmap);
>   wxBitmap &operator = (const wxIcon &icon);
>   bool operator == (const wxBitmap& bitmap) const;
>   bool operator != (const wxBitmap& bitmap) const;
209d193
< protected:
211c195,206
<   // TODO: Implementation
---
>   protected:
>     // common part of all ctors
>     void Init();
> 
>     // creates the bitmap from XPM data, supposed to be called from ctor
>     bool CreateFromXpm(const char **bits);
> 
> #if wxUSE_IMAGE
>     // creates the bitmap from wxImage, supposed to be called from ctor
>     bool CreateFromImage(const wxImage& image, int depth);
> #endif // wxUSE_IMAGE
> 
216c211
<   inline WXHICON GetHICON() const { return (M_BITMAPDATA ? M_BITMAPDATA->m_hIcon : 0); }
---
>   WXHICON GetHICON() const;
Index: include/wx/mac/cursor.h
===================================================================
RCS file: /home/wxcvs/wxWindows/include/wx/mac/cursor.h,v
retrieving revision 1.3
diff -r1.3 cursor.h
19c19,20
< #include "wx/bitmap.h"
---
> #include "wx/gdiobj.h"
> #include "wx/gdicmn.h"
21,34d21
< class WXDLLEXPORT wxCursorRefData: public wxBitmapRefData
< {
<     friend class WXDLLEXPORT wxBitmap;
<     friend class WXDLLEXPORT wxCursor;
< public:
<     wxCursorRefData();
<     ~wxCursorRefData();
< 
< protected:
<   WXHCURSOR m_hCursor;
< };
< 
< #define M_CURSORDATA ((wxCursorRefData *)m_refData)
< #define M_CURSORHANDLERDATA ((wxCursorRefData *)bitmap->m_refData)
37c24
< class WXDLLEXPORT wxCursor: public wxBitmap
---
> class WXDLLEXPORT wxCursor: public wxGDIObject
56c43,47
<   virtual bool Ok() const { return (m_refData != NULL && M_CURSORDATA->m_hCursor != NULL ) ; }
---
>     virtual bool Ok() const;
> 
>     wxCursor& operator = (const wxCursor& cursor);
>     bool operator == (const wxCursor& cursor);
>     bool operator != (const wxCursor& cursor);
58,60c49,51
<   inline wxCursor& operator = (const wxCursor& cursor) { if (*this == cursor) return (*this); Ref(cursor); return *this; }
<   inline bool operator == (const wxCursor& cursor) { return m_refData == cursor.m_refData; }
<   inline bool operator != (const wxCursor& cursor) { return m_refData != cursor.m_refData; }
---
>     int GetWidth()  const   { return 32; }
>     int GetHeight() const   { return 32; }
>     int GetDepth()  const   { return 8; }
61a53
>     // Implementation from now
64,65c56,57
<   void SetHCURSOR(WXHCURSOR cursor);
<   inline WXHCURSOR GetHCURSOR() const { return (M_CURSORDATA ? M_CURSORDATA->m_hCursor : 0); }
---
>     void SetHCURSOR(WXHCURSOR cursor);
>     WXHCURSOR GetHCURSOR() const;
Index: include/wx/mac/icon.h
===================================================================
RCS file: /home/wxcvs/wxWindows/include/wx/mac/icon.h,v
retrieving revision 1.5
diff -r1.5 icon.h
18a19,20
> #include "wx/gdiobj.h"
> #include "wx/gdicmn.h"
21,27d22
< // Icon
< class WXDLLEXPORT wxIcon: public wxBitmap
< {
<   DECLARE_DYNAMIC_CLASS(wxIcon)
< 
< public:
<   wxIcon();
29,50c24,25
<   // Copy constructors
<   inline wxIcon(const wxIcon& icon) { Ref(icon); }
< 
<   wxIcon( const char **data );
<   wxIcon( char **data );
<   wxIcon(const char bits[], int width, int height);
<   wxIcon(const wxString& name, long flags = wxBITMAP_TYPE_ICON_RESOURCE,
<     int desiredWidth = -1, int desiredHeight = -1);
<   ~wxIcon();
< 
<   bool LoadFile(const wxString& name, long flags /* = wxBITMAP_TYPE_ICON_RESOURCE */ ,
<       int desiredWidth /* = -1 */ , int desiredHeight = -1);
<   bool LoadFile(const wxString& name ,long flags = wxBITMAP_TYPE_ICON_RESOURCE )
<   	{ return LoadFile( name , flags , -1 , -1 ) ; } 
< 
<   inline wxIcon& operator = (const wxIcon& icon) { if (*this == icon) return (*this); Ref(icon); return *this; }
<   inline bool operator == (const wxIcon& icon) { return m_refData == icon.m_refData; }
<   inline bool operator != (const wxIcon& icon) { return m_refData != icon.m_refData; }
< };
< 
< /*
< class WXDLLEXPORT wxICONFileHandler: public wxBitmapHandler
---
> // Icon
> class WXDLLEXPORT wxIcon: public wxGDIObject
52,59c27
<   DECLARE_DYNAMIC_CLASS(wxICONFileHandler)
< public:
<   inline wxICONFileHandler()
<   {
< 	m_name = "ICO icon file";
< 	m_extension = "ico";
< 	m_type = wxBITMAP_TYPE_ICO;
<   };
---
>     DECLARE_DYNAMIC_CLASS(wxIcon)
61,64c29,30
<   virtual bool LoadFile(wxBitmap *bitmap, const wxString& name, long flags,
<       int desiredWidth = -1, int desiredHeight = -1);
< };
< */
---
>   public:
>     wxIcon();
66,75c32,33
< class WXDLLEXPORT wxICONResourceHandler: public wxBitmapHandler
< {
<   DECLARE_DYNAMIC_CLASS(wxICONResourceHandler)
< public:
<   inline wxICONResourceHandler()
<   {
< 	m_name = "ICON resource";
< 	m_extension = "";
< 	m_type = wxBITMAP_TYPE_ICON_RESOURCE;
<   };
---
>     // Copy constructors
>     inline wxIcon(const wxIcon& icon)   { Create(icon); }
77,78c35,75
<   virtual bool LoadFile(wxBitmap *bitmap, const wxString& name, long flags,
<       int desiredWidth = -1, int desiredHeight = -1);
---
>     wxIcon(const char **data);
>     wxIcon(char **data);
>     wxIcon(const char bits[], int width, int height);
>     wxIcon(const wxString& name, long flags = wxBITMAP_TYPE_ICON_RESOURCE,
>            int desiredWidth = -1, int desiredHeight = -1);
> 
>     ~wxIcon();
> 
>     inline bool Create(const wxIcon& icon);
>     bool Create(const char **data);
>     bool Create(const char bits[], int width, int height);
>     bool Create(const wxString& name, long flags = wxBITMAP_TYPE_ICON_RESOURCE,
>                 int desiredWidth = -1, int desiredHeight = -1);
> 
>     bool Ok() const;
> 
>     int GetWidth() const;
>     int GetHeight() const;
>     int GetDepth() const;
>     int GetQuality() const;
> 
>     bool LoadFile(const wxString& name,
>                   long flags /* = wxBITMAP_TYPE_ICON_RESOURCE */ ,
>                   int desiredWidth /* = -1 */ , int desiredHeight = -1);
>     bool LoadFile(const wxString& name,
>                   long flags = wxBITMAP_TYPE_ICON_RESOURCE);
> 
>     wxIcon& operator = (const wxIcon& icon);
>     wxIcon &operator = (const wxBitmap &bitmap);
>     bool operator == (const wxIcon& icon) const;
>     bool operator != (const wxIcon& icon) const;
> 
>     // create from bitmap (which should have a mask unless it's monochrome):
>     // there shouldn't be any implicit bitmap -> icon conversion (i.e. no
>     // ctors, assignment operators...), but it's ok to have such function
>     void CopyFromBitmap(const wxBitmap& bmp);
> 
>   public:
>     // Mac specific implementation
>     void SetHICON(WXHICON icon);
>     WXHICON GetHICON() const;
79a77
>     bool LoadResource(const wxString &name);
82,83c80
< #endif
<     // _WX_ICON_H_
---
> #endif    // _WX_ICON_H_
Index: src/mac/bitmap.cpp
===================================================================
RCS file: /home/wxcvs/wxWindows/src/mac/bitmap.cpp,v
retrieving revision 1.20
diff -r1.20 bitmap.cpp
22a23
> #include "wx/dcmemory.h"
24a26
> 
26c28,30
< IMPLEMENT_DYNAMIC_CLASS(wxBitmap, wxGDIObject)
---
> IMPLEMENT_ABSTRACT_CLASS(wxBitmapBase, wxGDIObject)
> IMPLEMENT_ABSTRACT_CLASS(wxBitmapHandlerBase, wxObject)
> IMPLEMENT_DYNAMIC_CLASS(wxBitmap, wxBitmapBase)
28,29d31
< IMPLEMENT_ABSTRACT_CLASS(wxBitmapBase , wxGDIObject )
< IMPLEMENT_ABSTRACT_CLASS(wxBitmapHandlerBase, wxObject ) 
35c37
<     #include <PictUtils.h>
---
> #include <ApplicationServices/ApplicationServices.h>
38c40,43
< #include "wx/mac/uma.h"
---
> 
> // List of bitmap handlers for loading different image types
> wxList wxBitmapBase::sm_handlers;
> 
43c48
< 	
---
> 
75c80
< 	Rect rect = { 0 , 0 , height , width } ;
---
> 	Rect rect = { 0 , 0 , height, width } ;
88c93
< }
---
> } 
96,132d100
< PicHandle wxMacCreatePict(GWorldPtr wp, GWorldPtr mask)
< {
<    CGrafPtr    origPort ;
<    GDHandle    origDev ;
< 
<    PicHandle      pict;          // this is the Picture we give back
< 
<    RGBColor    gray = { 0xCCCC ,0xCCCC , 0xCCCC } ;
<    RGBColor    white = { 0xffff ,0xffff , 0xffff } ;
<    RGBColor    black = { 0x0000 ,0x0000 , 0x0000 } ;
< 
<    unsigned char *maskimage = NULL ;
<    Rect portRect ;
<    GetPortBounds( wp , &portRect ) ;
<    int width = portRect.right - portRect.left ;
<    int height = portRect.bottom - portRect.top ;
< 
<    LockPixels( GetGWorldPixMap( wp ) ) ;
<    GetGWorld( &origPort , &origDev ) ;
< 
<    if ( mask )
<    {
<       maskimage = (unsigned char*) malloc( width * height ) ;
<       SetGWorld( mask , NULL ) ;
<       LockPixels( GetGWorldPixMap( mask ) ) ;
<       for ( int y = 0 ; y < height ; y++ )
<       {
<          for( int x = 0 ; x < width ; x++ )
<          {
<             RGBColor col ;
< 
<             GetCPixel( x + portRect.left , y + portRect.top , &col ) ;
<             maskimage[y*width + x] = ( col.red == 0 ) ; // for monochrome masks
<          }
<       }
<       UnlockPixels( GetGWorldPixMap( mask ) ) ;
<    }
134c102,104
<    SetGWorld( wp , NULL ) ;
---
> /*
>  * Bitmap data reference class
>  */
136,138c106,108
<    pict = OpenPicture(&portRect);   // open a picture, this disables drawing
<    if(!pict)
<       return NULL;
---
> class WXDLLEXPORT wxBitmapRefData: public wxGDIRefData
> {
>     friend class WXDLLEXPORT wxBitmap;
140,152c110,127
<    if ( maskimage )
<    {
<       RGBForeColor( &black ) ;
<       RGBBackColor( &white ) ;
<       PenMode(transparent);
< 
<       for ( int y = 0 ; y < height ; ++y )
<       {
<          for( int x = 0 ; x < width ; ++x )
<          {
<             if ( maskimage[y*width + x] )
<             {
<                RGBColor col ;
---
>   public:
>     wxBitmapRefData();
>     ~wxBitmapRefData();
> 
>   public:
>     int           m_width;
>     int           m_height;
>     int           m_depth;
>     bool          m_ok;
>     int           m_numColors;
>     wxPalette     m_bitmapPalette;
>     int           m_quality;
> 
>     int           m_bitmapType ;
>     PicHandle     m_hPict ;
>     WXHBITMAP     m_hBitmap;
>     wxMask       *m_bitmapMask; // Optional mask
> };
154,182c129,130
<                GetCPixel( x + portRect.left , y + portRect.top , &col ) ;
<                SetCPixel( x + portRect.left , y + portRect.top , &col ) ;
<             }
<             else {
<                 // With transparency set this sets a blank pixel not a white one
<                 SetCPixel( x + portRect.left , y + portRect.top , &white);
<             }
<          }
<       }
<       free( maskimage ) ;
<       maskimage = NULL ;
<    }
<    else
<    {
<       RGBBackColor( &gray ) ;
<       EraseRect(&portRect);
<       RGBForeColor( &black ) ;
<       RGBBackColor( &white ) ;
< 
<       CopyBits(GetPortBitMapForCopyBits(wp), /* src PixMap - we copy image over
<                                               * itself - */
<                GetPortBitMapForCopyBits(wp), //  dst PixMap - no drawing occurs
<                &portRect,    // srcRect - it will be recorded and compressed -
<                &portRect,    // dstRect - into the picture that is open -
<                srcCopy,NULL); // copyMode and no clip region
<    }
<    ClosePicture();                  // We are done recording the picture
<    UnlockPixels( GetGWorldPixMap( wp ) ) ;
<    SetGWorld( origPort , origDev ) ;
---
> // Helper define for accessing the bitmap data
> #define M_BITMAPDATA ((wxBitmapRefData *)m_refData)
184,185d131
<    return pict;                  // return our groovy pict handle
< }
198d143
<     m_hIcon = NULL ;
224,230d168
< 		case kMacBitmapTypeIcon :
<         	if ( m_hIcon )
<         	{
<         		DisposeCIcon( m_hIcon ) ;
<         		m_hIcon = NULL ;
<         	}
< 		
243c181,184
< wxList wxBitmapBase::sm_handlers;
---
> /* *****************************************
>  * wxBitmap class implementation
>  * *****************************************
>  */
244a186,189
> wxBitmap::wxBitmap()
> {
>     Init();
> }
246c191
< bool wxBitmap::CopyFromIcon(const wxIcon& icon)
---
> wxBitmap::~wxBitmap()
248c193,194
<     Ref(icon) ;
---
>     if (wxTheBitmapList)
>         wxTheBitmapList->DeleteObject(this);
251c197
< wxBitmap::wxBitmap()
---
> wxBitmap::wxBitmap(const wxBitmap &bitmap)
253c199
<     m_refData = NULL;
---
>     Init();
255,256c201
<     if ( wxTheBitmapList )
<         wxTheBitmapList->AddBitmap(this);
---
>     Ref(bitmap);
259c204
< wxBitmap::~wxBitmap()
---
> wxBitmap::wxBitmap(const wxIcon &icon)
261,262c206,208
<     if (wxTheBitmapList)
<         wxTheBitmapList->DeleteObject(this);
---
>     Init();
> 
>     CopyFromIcon(icon);
266a213,214
>     Init();
> 
272a221
> 
275,276c224,226
<         M_BITMAPDATA->m_bitmapType = kMacBitmapTypeGrafWorld ;
<         M_BITMAPDATA->m_hBitmap = wxMacCreateGWorld( the_width , the_height , no_bits ) ;
---
> 	    M_BITMAPDATA->m_bitmapType = kMacBitmapTypeGrafWorld ;
> 	    M_BITMAPDATA->m_hBitmap = wxMacCreateGWorld( the_width , the_height , no_bits ) ;
> 
281c231
< 	
---
> 
284,287c234,238
<         LockPixels( GetGWorldPixMap( M_BITMAPDATA->m_hBitmap ) ) ;
< 	
<         // bits is a char array
< 	
---
>         LockPixels( GetGWorldPixMap( M_BITMAPDATA->m_hBitmap ) );
> 
>         // bits is a word aligned array?? Don't think so
>         // bits is a char array on MAC X however using the benefit of the
>         // doubt I replaced references to 16 with sizeof(unsigned char)*8
293c244
< 	
---
> 
296,299c247,249
<             { 0, 0 , 0 } 
<         } ;
< 	
<         for ( int y = 0 ; y < the_height ; ++y , linestart += linesize )
---
>             { 0, 0 , 0 } };
> 
>         for( int y = 0 ; y < the_height ; ++y , linestart += linesize )
301c251
<             for ( int x = 0 ; x < the_width ; ++x )
---
>             for( int x = 0 ; x < the_width ; ++x )
306,307c256
<                 if ( linestart[index] & mask )
<                 {
---
>                 if ( linestart[index] & mask ) {
310,311c259
<                 else
<                 {
---
>                 else {
316,318c264,266
<         UnlockPixels( GetGWorldPixMap( M_BITMAPDATA->m_hBitmap ) ) ;
< 	
<         SetGWorld( origPort , origDevice ) ;
---
> 		UnlockPixels( GetGWorldPixMap( M_BITMAPDATA->m_hBitmap ) ) ;
> 
> 	   	SetGWorld( origPort , origDevice ) ;
324,327d271
<     
<     if ( wxTheBitmapList ) {
<         wxTheBitmapList->AddBitmap(this);
<     }
332c276
<     (void)Create(w, h, d);
---
>     Init();
334,335c278
<     if ( wxTheBitmapList )
<         wxTheBitmapList->AddBitmap(this);
---
>     Create(w, h, d);
340c283
<     (void) Create(data, type, width, height, depth);
---
>     Init();
342,343c285
<     if ( wxTheBitmapList )
<         wxTheBitmapList->AddBitmap(this);
---
>     Create(data, type, width, height, depth);
347a290,291
>     Init();
> 
348a293,297
> }
> 
> void wxBitmap::Init()
> {
>     m_refData = NULL;
356c305,306
<     wxCHECK_MSG( bits != NULL, FALSE, wxT("invalid bitmap data") )
---
>     wxCHECK_MSG( bits != NULL, FALSE, wxT("invalid bitmap data") );
> 
357a308
> 
359,360c310,311
<     wxCHECK_MSG( img.Ok(), FALSE, wxT("invalid bitmap data") )    
<     *this = wxBitmap(img);   
---
>     wxCHECK_MSG( img.Ok(), FALSE, wxT("invalid bitmap data") );
>     *this = wxBitmap(img);
364a316,384
> bool wxBitmap::CreateFromImage(const wxImage &image, int depth)
> {
>     UnRef();
> 
>     wxCHECK_MSG(image.Ok(), false, wxT("wxBitmap::CreateFromImage  invalid image"));
> 
>     m_refData = new wxBitmapRefData();
> 
>     // width and height of the device-dependent bitmap
>     int width = image.GetWidth();
>     int height = image.GetHeight();
> 
>     // Create picture
> 
>     Create( width , height , wxDisplayDepth() ) ;
>     wxBitmap maskBitmap( width, height, 1);
> 
>     GDHandle origDevice;
>     CGrafPtr origPort ;
> 
>     LockPixels( GetGWorldPixMap(GetHBITMAP()) );
>     LockPixels( GetGWorldPixMap(maskBitmap.GetHBITMAP()) );
> 
>     GetGWorld(&origPort, &origDevice);
>     SetGWorld(GetHBITMAP(), NULL);
> 
>     // Render image
>     wxColour rgb, maskcolor(image.GetMaskRed(), image.GetMaskGreen(),
>                             image.GetMaskBlue());
>     RGBColor color;
>     RGBColor white = { 0xffff, 0xffff, 0xffff };
>     RGBColor black = { 0     , 0     , 0 };
> 
>     register unsigned char* data = image.GetData();
> 
>     int index = 0;
>     for (int y = 0; y < height; y++)
>     {
>         for (int x = 0; x < width; x++)
>         {
>             rgb.Set(data[index++], data[index++], data[index++]);
>             color = rgb.GetPixel();
>             SetCPixel( x , y , &color ) ;
>             if (image.HasMask())
>             {
>                 SetGWorld(maskBitmap.GetHBITMAP(), NULL);
>                 if (rgb == maskcolor) {
>                     SetCPixel(x,y, &white);
>                 }
>                 else {
>                     SetCPixel(x,y, &black);
>                 }
>                 SetGWorld(GetHBITMAP(), NULL);
>             }
>         }
>     }  // for height
> 
>     // Create mask
>     if ( image.HasMask() ) {
>         SetMask(new wxMask( maskBitmap ));
>     }
> 
>     UnlockPixels( GetGWorldPixMap(GetHBITMAP()) );
>     UnlockPixels( GetGWorldPixMap(maskBitmap.GetHBITMAP()) );
>     SetGWorld(origPort, origDevice);
> 
>     return true;
> }
> 
366a387,389
> #ifdef OBSOLETE_XPM_DATA_HANDLER
>     (void) Create((void *)bits, wxBITMAP_TYPE_XPM_DATA, 0, 0, 0);
> #else
367a391
> #endif
371a396,398
> #ifdef OBSOLETE_XPM_DATA_HANDLER
>     (void) Create((void *)bits, wxBITMAP_TYPE_XPM_DATA, 0, 0, 0);
> #else
372a400,472
> #endif
> }
> 
> wxBitmap::wxBitmap(const wxImage& image, int depth)
> {
>     Init();
> 
>     CreateFromImage(image, depth);
> }
> 
> wxImage wxBitmap::ConvertToImage() const
> {
>     wxImage image;
>     
>     wxCHECK_MSG( Ok(), wxNullImage, wxT("invalid bitmap") );
> 
>     // create an wxImage object
>     int width = GetWidth();
>     int height = GetHeight();
>     image.Create( width, height );
> 
>     unsigned char *data = image.GetData();
> 
>     wxCHECK_MSG( data, wxNullImage, wxT("Could not allocate data for image") );
> 
>     WXHBITMAP origPort;
>     int      index;
>     RGBColor color;
>     // background color set to RGB(16,16,16) in consistent with wxGTK
>     unsigned char mask_r=16, mask_g=16, mask_b=16;
>     SInt16   r,g,b;
>     wxMask  *mask = GetMask();
> 
>     GetPort(&origPort);
>     LockPixels(GetGWorldPixMap(GetHBITMAP()));
>     SetPort(GetHBITMAP());
> 
>     // Copy data into image
>     index = 0;
>     for (int yy = 0; yy < height; yy++)
>     {
>         for (int xx = 0; xx < width; xx++)
>         {
>             GetCPixel(xx,yy, &color);
>             r = ((color.red ) >> 8);
>             g = ((color.green ) >> 8);
>             b = ((color.blue ) >> 8);
>             data[index    ] = r;
>             data[index + 1] = g;
>             data[index + 2] = b;
>             if (mask)
>             {
>                 if (mask->PointMasked(xx,yy))
>                 {
>                     data[index    ] = mask_r;
>                     data[index + 1] = mask_g;
>                     data[index + 2] = mask_b;
>                 }
>             }
>             index += 3;
>         }
>     }
>     if (mask)
>     {
>         image.SetMaskColour( mask_r, mask_g, mask_b );
>         image.SetMask( true );
>     }
> 
>     // Free resources
>     UnlockPixels(GetGWorldPixMap(GetHBITMAP()));
>     SetPort(origPort);
> 
>     return image;
383c483
<    
---
> 
463a564,626
> bool wxBitmap::CopyFromIcon(const wxIcon &icon)
> {
>     wxCHECK_MSG(icon.Ok(), false, wxT("wxBitmap::CopyFromIcon  invalid icon"));
> 
>     int iconSize = icon.GetWidth();   // icons always n x n in size
> 
>     Create(iconSize, iconSize, icon.GetDepth());
> 
>     // Draw the icon into the bitmap
>     wxMemoryDC memdc;
> 
>     memdc.SelectObject(*this);
>     memdc.Clear();
>     memdc.DrawIcon(icon, 0,0);
>     memdc.SelectObject(wxNullBitmap);
> 
>     // Now get the CIcon mask and create a wxMask for the bitmap
>     CIconHandle cicon = icon.GetHICON();
>     wxBitmap mask(iconSize, iconSize, 1);
>     RGBColor white = { 0xffff, 0xffff, 0xffff };
>     RGBColor black = { 0x0,    0x0,    0x0 };
> 
>     CGrafPtr    origPort ;
>     GDHandle    origDevice ;
> 
>     GetGWorld( &origPort , &origDevice ) ;
>     SetGWorld( mask.GetHBITMAP(), NULL ) ;
>     LockPixels( GetGWorldPixMap( mask.GetHBITMAP() ) );
> 
>     for(int yy = 0; yy < iconSize; yy++)
>     {
>         for(int xx = 0; xx < iconSize / 16; xx++)
>         {
>             UInt16 bitmask = 0x8000;
>             for(int ii = 0; ii < 16; ii++)
>             {
>                 if((**cicon).iconMaskData[(yy * iconSize / 16) + xx] & bitmask) {
>                     SetCPixel((xx * 16) + ii, yy, &black);
>                 }
>                 else {
>                     SetCPixel((xx * 16) + ii, yy, &white);
>                 }
>                 bitmask = bitmask >> 1;
>             }
>         }
>     }
>     UnlockPixels( GetGWorldPixMap( mask.GetHBITMAP() ) ) ;
>     SetGWorld( origPort , origDevice ) ;
> 
>     wxMask *newmask = new wxMask(mask);
>     if(newmask) {
>         SetMask(newmask);
>     }
>     return true;
> }
> 
> bool CopyFromCursor(const wxCursor &cursor)
> {
>     printf("wxBitmap::CopyFromCursor --- This is not implemented yet\n");
> 
>     return false;
> }
> 
476a640
> 
479a644,650
> void wxBitmap::SetBitmapType(int type)
> {
>    wxCHECK_RET( Ok(), wxT("Invalid bitmap SetBitmapType") );
> 
>    M_BITMAPDATA->m_bitmapType = type;
> }
> 
486a658,688
> wxBitmap &wxBitmap::operator = (const wxBitmap& bitmap)
> {
>     if (*this == bitmap) {
>         return (*this);
>     }
>     Ref(bitmap);
>     return *this;
> }
> 
> wxBitmap &wxBitmap::operator = (const wxIcon &icon)
> {
>     CopyFromIcon(icon);
>     return *this;
> }
> 
> bool wxBitmap::operator == (const wxBitmap& bitmap) const
> {
>     if(Ok() && bitmap.Ok()) {
>         return m_refData == bitmap.m_refData;
>     }
>     return false;
> }
> 
> bool wxBitmap::operator != (const wxBitmap& bitmap) const
> {
>     if(Ok() && bitmap.Ok()) {
>         return m_refData != bitmap.m_refData;
>     }
>     return false;
> }
> 
491c693
< 	M_BITMAPDATA->m_ok = (M_BITMAPDATA->m_hBitmap != NULL ) ;
---
>     M_BITMAPDATA->m_ok = (M_BITMAPDATA->m_hBitmap != NULL ) ;
502c704
<     	m_refData = new wxBitmapRefData;
---
>         m_refData = new wxBitmapRefData;
509c711,712
<         if (loadimage.Ok()) {
---
> 
>         if(loadimage.Ok()) {
535,668d737
< wxBitmap::wxBitmap(const wxImage& image, int depth)
< {
<     wxCHECK_RET( image.Ok(), wxT("invalid image") )
<     wxCHECK_RET( depth == -1, wxT("invalid bitmap depth") )
< 
<     m_refData = new wxBitmapRefData();
<       
<     if (wxTheBitmapList) wxTheBitmapList->AddBitmap(this);
< 
<     // width and height of the device-dependent bitmap
<     int width = image.GetWidth();
<     int height = image.GetHeight();
< 
<     // Create picture
< 
<     Create( width , height , wxDisplayDepth() ) ;
<     wxBitmap maskBitmap( width, height, 1);
<     
<     CGrafPtr origPort ;
<     GDHandle origDevice ;
< 
<     LockPixels( GetGWorldPixMap(GetHBITMAP()) );
<     LockPixels( GetGWorldPixMap(maskBitmap.GetHBITMAP()) );
< 
<     GetGWorld( &origPort , &origDevice ) ;
<     SetGWorld( GetHBITMAP() , NULL ) ;
<     
<     // Render image
<     wxColour rgb, maskcolor(image.GetMaskRed(), image.GetMaskGreen(), image.GetMaskBlue());
<     RGBColor color;
<     RGBColor white = { 0xffff, 0xffff, 0xffff };
<     RGBColor black = { 0     , 0     , 0      };
< 
<     register unsigned char* data = image.GetData();
< 
<     int index = 0;
<     for (int y = 0; y < height; y++)
<     {
<         for (int x = 0; x < width; x++)
<         {
<             rgb.Set(data[index++], data[index++], data[index++]);
<             color = rgb.GetPixel();
<             SetCPixel( x , y , &color ) ;
<             if (image.HasMask())
<             {
<                 SetGWorld(maskBitmap.GetHBITMAP(), NULL);
<                 if (rgb == maskcolor) {
<                     SetCPixel(x,y, &white);
<                 }
<                 else {
<                     SetCPixel(x,y, &black);
<                 }
<                 SetGWorld(GetHBITMAP(), NULL);
<             }
<         }
<     }  // for height
< 
<     // Create mask
<     if ( image.HasMask() ) {
<         SetMask(new wxMask( maskBitmap ));
<     }
<     
<     UnlockPixels( GetGWorldPixMap(GetHBITMAP()) );
<     UnlockPixels( GetGWorldPixMap(maskBitmap.GetHBITMAP()) );
<     SetGWorld( origPort, origDevice );
< }
< 
< wxImage wxBitmap::ConvertToImage() const
< {
<     wxImage image;
<     
<     wxCHECK_MSG( Ok(), wxNullImage, wxT("invalid bitmap") );
< 
<     // create an wxImage object
<     int width = GetWidth();
<     int height = GetHeight();
<     image.Create( width, height );
< 
<     unsigned char *data = image.GetData();
< 
<     wxCHECK_MSG( data, wxNullImage, wxT("Could not allocate data for image") );
< 
<     WXHBITMAP origPort;
<     GDHandle  origDevice;
<     int      index;
<     RGBColor color;
<     // background color set to RGB(16,16,16) in consistent with wxGTK
<     unsigned char mask_r=16, mask_g=16, mask_b=16;
<     SInt16   r,g,b;
<     wxMask  *mask = GetMask();
< 
<     GetGWorld( &origPort, &origDevice );
<     LockPixels(GetGWorldPixMap(GetHBITMAP()));
<     SetGWorld( GetHBITMAP(), NULL);
< 
<     // Copy data into image
<     index = 0;
<     for (int yy = 0; yy < height; yy++)
<     {
<         for (int xx = 0; xx < width; xx++)
<         {
<             GetCPixel(xx,yy, &color);
<             r = ((color.red ) >> 8);
<             g = ((color.green ) >> 8);
<             b = ((color.blue ) >> 8);
<             data[index    ] = r;
<             data[index + 1] = g;
<             data[index + 2] = b;
<             if (mask)
<             {
<                 if (mask->PointMasked(xx,yy))
<                 {
<                     data[index    ] = mask_r;
<                     data[index + 1] = mask_g;
<                     data[index + 2] = mask_b;
<                 }
<             }
<             index += 3;
<         }
<     }
<     if (mask)
<     {
<         image.SetMaskColour( mask_r, mask_g, mask_b );
<         image.SetMask( true );
<     }
< 
<     // Free resources
<     UnlockPixels(GetGWorldPixMap(GetHBITMAP()));
<     SetGWorld(origPort, origDevice);
< 
<     return image;
< }
< 
< 
674c743
<     if ( handler )
---
>     if(handler)
684c753
<     
---
> 
703c772
<    wxCHECK_MSG( Ok(), -1, wxT("invalid bitmap") );
---
>    wxCHECK_MSG( Ok(), -1, wxT("invalid bitmap  GetWidth()") );
789,792d857
<     // Remove existing mask if there is one.
<     if (M_BITMAPDATA->m_bitmapMask)
<         delete M_BITMAPDATA->m_bitmapMask;
< 
846,849d910
< #else
<        RGBBackColor( &gray );
<        EraseRect( &portRect );
<        RGBColor trans = gray;
930c991
< wxBitmapHandler *wxBitmap::FindHandler(const wxString& extension, wxBitmapType type)
---
> wxBitmapHandler *wxBitmap::FindHandler(const wxString& extension, wxBitmapType bitmapType)
937c998
<                     (type == -1 || handler->GetType() == type) )
---
>                     (bitmapType == -1 || handler->GetType() == bitmapType) )
944c1005
< wxBitmapHandler *wxBitmap::FindHandler(wxBitmapType type)
---
> wxBitmapHandler *wxBitmap::FindHandler(wxBitmapType bitmapType)
950c1011
<         if (handler->GetType() == type)
---
>         if (handler->GetType() == bitmapType)
963a1025
>     m_width = m_height = 0;
970a1033
>     m_width = m_height = 0;
978a1042
>     m_width = m_height = 0;
985a1050
>     m_width = m_height = 0;
1025a1091,1093
>    m_height = bitmap.GetHeight();
>    m_width  = bitmap.GetWidth();
> 
1034c1102
<     wxCHECK_MSG( 0, false, wxT("Not implemented"));
---
>    wxCHECK_MSG( 0, false, wxT("Not implemented"));
1046a1115,1117
> 
>     wxCHECK_MSG( bitmap.Ok(), false, wxT("wxMask::Create Invalid bitmap") );
> 
1050,1051d1120
< 	
<     wxCHECK_MSG( bitmap.Ok(), false, wxT("Illigal bitmap"));
1053,1054c1122,1123
< 	m_maskBitmap = wxMacCreateGWorld( bitmap.GetWidth() , bitmap.GetHeight() , 1 );	
< 	LockPixels( GetGWorldPixMap( m_maskBitmap ) );
---
> 	m_maskBitmap = wxMacCreateGWorld(bitmap.GetWidth(), bitmap.GetHeight(), 1);
> 	LockPixels( GetGWorldPixMap( m_maskBitmap ) ) ;
1056c1125
< 	RGBColor maskColor = colour.GetPixel();
---
> 	RGBColor maskColor = colour.GetPixel() ;
1060,1061c1129,1130
< 	CGrafPtr 	origPort ;
< 	GDHandle	origDevice ;
---
> 	CGrafPtr  origPort ;
> 	GDHandle  origDevice ;
1066c1135
< 			
---
> 
1068c1137
< 	for (int w = 0; w < bitmap.GetWidth(); w++)
---
> 	for (int yy = 0; yy < bitmap.GetHeight(); yy++)
1070,1075c1139,1145
<         for (int h = 0; h < bitmap.GetHeight(); h++)
<         {		
< 			SetGWorld( bitmap.GetHBITMAP(), NULL ) ;
< 			GetCPixel( w , h , &col ) ;
< 			SetGWorld( m_maskBitmap , NULL ) ;
<             if (col.red == maskColor.red && col.green == maskColor.green && col.blue == maskColor.blue)
---
>         for (int xx = 0; xx < bitmap.GetWidth(); xx++)
>         {
> 			SetGWorld( bitmap.GetHBITMAP(), NULL );
> 			GetCPixel( xx , yy , &col ) ;
>             SetGWorld( m_maskBitmap , NULL ) ;
>             if (col.red == maskColor.red && col.green == maskColor.green &&
>                 col.blue == maskColor.blue)
1077c1147
< 				SetCPixel( w , h , &colors[0] ) ;
---
> 				SetCPixel( xx , yy , &colors[0] ) ;
1079,1081c1149,1150
<             else
<             {
< 				SetCPixel( w , h , &colors[1] ) ;
---
>             else {
> 				SetCPixel( xx , yy , &colors[1] ) ;
1086c1155
< 	UnlockPixels( GetGWorldPixMap( bitmap.GetHBITMAP() ) ) ;
---
> 	UnlockPixels( GetGWorldPixMap( bitmap.GetHBITMAP() ) );
1088a1158,1160
>     m_height = bitmap.GetHeight();
>     m_width  = bitmap.GetWidth();
> 
1094,1097c1166,1173
<    WXHBITMAP origPort;
<    GDHandle  origDevice;
<    RGBColor  color;
<    bool masked = true;
---
>     if((x < 0) || (x >= m_width) || (y < 0) || (y >= m_height)) {
>         printf("x,y %d %d  width,height  %d %d\n", x,y, m_width, m_height);
>         return true;
>     }
>     WXHBITMAP origPort;
>     GDHandle  origDevice;
>     RGBColor  color;
>     bool masked = true;
1099c1175
<    GetGWorld( &origPort, &origDevice);
---
>     GetGWorld( &origPort, &origDevice);
1101,1106c1177,1182
<    //Set port to mask and see if it masked (1) or not ( 0 )
<    SetGWorld(m_maskBitmap, NULL);
<    LockPixels(GetGWorldPixMap(m_maskBitmap));
<    GetCPixel(x,y, &color);
<    masked = !(color.red == 0 && color.green == 0 && color.blue == 0);
<    UnlockPixels(GetGWorldPixMap(m_maskBitmap));
---
>     //Set port to mask and see if it masked (1) or not ( 0 )
>     SetGWorld(m_maskBitmap, NULL);
>     LockPixels(GetGWorldPixMap(m_maskBitmap));
>     GetCPixel(x,y, &color);
>     masked = !(color.red == 0 && color.green == 0 && color.blue == 0);
>     UnlockPixels(GetGWorldPixMap(m_maskBitmap));
1108c1184
<    SetGWorld( origPort, origDevice);
---
>     SetGWorld( origPort, origDevice);
1110c1186
<    return masked;
---
>     return masked;
1124,1125c1200,1202
< bool wxBitmapHandler::LoadFile(wxBitmap *bitmap, const wxString& name, long flags,
<         int desiredWidth, int desiredHeight)
---
> bool wxBitmapHandler::LoadFile(wxBitmap *bitmap, const wxString& name,
>                                long type,
>                                int desiredWidth, int desiredHeight)
1127c1204
<     return FALSE;
---
>    return FALSE;
1130c1207,1208
< bool wxBitmapHandler::SaveFile(const wxBitmap *bitmap, const wxString& name, int type, const wxPalette *palette)
---
> bool wxBitmapHandler::SaveFile(const wxBitmap *bitmap, const wxString& name, int type,
>                                const wxPalette *palette)
1132c1210
<     return FALSE;
---
>    return FALSE;
1134a1213
> 
1138a1218,1221
> 
> #define M_BITMAPHANDLERDATA ((wxBitmapRefData *)bitmap->GetRefData())
> 
> 
1151c1234
<           int desiredWidth, int desiredHeight);
---
>                           int desiredWidth, int desiredHeight);
1155,1156c1238,1240
< bool  wxPICTResourceHandler::LoadFile(wxBitmap *bitmap, const wxString& name, long flags,
<           int desiredWidth, int desiredHeight)
---
> bool wxPICTResourceHandler::LoadFile(wxBitmap *bitmap, const wxString& name,
>                                      long flags,
>                                      int desiredWidth, int desiredHeight)
1159,1161c1243,1246
< 	
< #if TARGET_CARBON
< 	c2pstrcpy( (StringPtr) theName , name ) ;
---
> 
> #ifndef __UNIX__
> 	strcpy( (char*) theName , name ) ;
> 	c2pstr( (char*) theName ) ;
1163,1164c1248
< 	strcpy( (char *) theName , name ) ;
< 	c2pstr( (char *)theName ) ;
---
>    c2pstrcpy(theName, name);
1178c1262
< 		
---
> 
1209a1294,1357
> #ifdef OBSOLETE_XPM_DATA_HANDLER
> 
> class WXDLLEXPORT wxXPMDataHandler: public wxBitmapHandler
> {
>   DECLARE_DYNAMIC_CLASS(wxXPMDataHandler)
> public:
>   inline wxXPMDataHandler(void)
>   {
>   m_name = "XPM bitmap data";
>   m_extension = "xpm";
>   m_type = wxBITMAP_TYPE_XPM_DATA;
>   };
> 
>   virtual bool Create(wxBitmap *bitmap, void *data, long flags, int width, int height, int depth = 1);
> };
> IMPLEMENT_DYNAMIC_CLASS(wxXPMDataHandler, wxBitmapHandler)
> 
> bool wxXPMDataHandler::Create(wxBitmap *bitmap, void *data, long flags,
>                               int width, int height, int depth)
> {
>  	XImage *		ximage = NULL ;
>  	XImage *		xshapeimage = NULL ;
>   	int     		ErrorStatus;
>   	XpmAttributes 	xpmAttr;
> 
>     xpmAttr.valuemask = XpmReturnInfos; // get infos back
>     ErrorStatus = XpmCreateImageFromData( GetMainDevice() , (char **)data,
>          &ximage, &xshapeimage, &xpmAttr);
> 
>     if (ErrorStatus == XpmSuccess)
>     {
> 			M_BITMAPHANDLERDATA->m_ok = FALSE;
> 			M_BITMAPHANDLERDATA->m_numColors = 0;
> 			M_BITMAPHANDLERDATA->m_hBitmap = ximage->gworldptr ;
> 	  
> 			M_BITMAPHANDLERDATA->m_width = ximage->width;
> 			M_BITMAPHANDLERDATA->m_height = ximage->height;
> 			M_BITMAPHANDLERDATA->m_depth = ximage->depth;
> 			M_BITMAPHANDLERDATA->m_numColors = xpmAttr.npixels;
>             XpmFreeAttributes(&xpmAttr);
>             M_BITMAPHANDLERDATA->m_ok = TRUE;
> 			ximage->gworldptr = NULL ;
> 			XImageFree(ximage); // releases the malloc, but does not detroy
> 		                  // the bitmap
> 			M_BITMAPHANDLERDATA->m_bitmapType = kMacBitmapTypeGrafWorld ;
> 			if ( xshapeimage != NULL )
> 			{
> 				wxMask* m = new wxMask() ;
> 				m->SetMaskBitmap( xshapeimage->gworldptr ) ;
> 				M_BITMAPHANDLERDATA->m_bitmapMask = m ;
> 			}
> 			return TRUE;
>     } 
>     else
>     {
>       M_BITMAPHANDLERDATA->m_ok = FALSE;
>       return FALSE;
>     }
>   return FALSE;
> }
> 
> #endif // OBSOLETE_XPM_DATA_HANDLER
> 
> 
1225,1226c1373,1376
<     AddHandler(new wxPICTResourceHandler) ;
<     AddHandler(new wxICONResourceHandler) ;
---
> 	AddHandler( new wxPICTResourceHandler ) ;
> #ifdef OBSOLETE_XPM_DATA_HANDLER
>   	AddHandler(new wxXPMDataHandler);
> #endif
Index: src/mac/cursor.cpp
===================================================================
RCS file: /home/wxcvs/wxWindows/src/mac/cursor.cpp,v
retrieving revision 1.4
diff -r1.4 cursor.cpp
15a16
> 
17c18
< #include "wx/icon.h"
---
> 
20c21
< IMPLEMENT_DYNAMIC_CLASS(wxCursor, wxBitmap)
---
> IMPLEMENT_DYNAMIC_CLASS(wxCursor, wxGDIObject)
36a38,55
> 
> // Cursor storage class
> class WXDLLEXPORT wxCursorRefData: public wxGDIRefData
> {
>     friend class WXDLLEXPORT wxCursor;
>   public:
>     wxCursorRefData();
>     ~wxCursorRefData();
> 
>   protected:
>     WXHCURSOR m_hCursor;
>     int m_width;
>     int m_height;
> };
> 
> #define M_CURSORDATA ((wxCursorRefData *)m_refData)
> //#define M_CURSORHANDLERDATA ((wxCursorRefData *)bitmap->m_refData)
> 
193a213,236
> bool wxCursor::Ok() const
> {
>     return (m_refData != NULL && M_CURSORDATA->m_hCursor != NULL );
> }
> 
> wxCursor &wxCursor::operator = (const wxCursor& cursor)
> {
>     if (*this == cursor) {
>         return (*this);
>     }
>     Ref(cursor);
>     return *this;
> }
> 
> bool wxCursor::operator == (const wxCursor& cursor)
> {
>     return m_refData == cursor.m_refData;
> }
> 
> bool wxCursor::operator != (const wxCursor& cursor)
> {
>     return m_refData != cursor.m_refData;
> }
> 
212,213c255
< // Global cursor setting
< void wxSetCursor(const wxCursor& cursor)
---
> WXHCURSOR wxCursor::GetHCURSOR() const
215c257
< 	cursor.MacInstall() ;
---
>     return (M_CURSORDATA ? M_CURSORDATA->m_hCursor : 0);
217a260,262
> void wxCursor::SetHCURSOR(WXHCURSOR cursor)
> {
>     UnRef();
218a264,273
>     m_refData = new wxCursorRefData;
> 
>     M_CURSORDATA->m_hCursor = cursor;
> }
> 
> // Global cursor setting
> void wxSetCursor(const wxCursor& cursor)
> {
>     cursor.MacInstall() ;
> }
Index: src/mac/icon.cpp
===================================================================
RCS file: /home/wxcvs/wxWindows/src/mac/icon.cpp,v
retrieving revision 1.7
diff -r1.7 icon.cpp
5c5
< // Modified by:
---
> // Modified by: Mark Newsam
7c7
< // RCS-ID:      $Id: icon.cpp,v 1.7 2001/06/29 16:19:53 SC Exp $
---
> // RCS-ID:      $Id: icon.cpp,v 1.4 2000/08/09 10:10:14 SC Exp $
15a16
> 
16a18,20
> #include "wx/gdiobj.h"
> #include "wx/gdicmn.h"
> #include "wx/dcmemory.h"
19c23
< IMPLEMENT_DYNAMIC_CLASS(wxIcon, wxBitmap)
---
> IMPLEMENT_DYNAMIC_CLASS(wxIcon, wxGDIObject);
26c30,42
< wxIcon::wxIcon()
---
> /*
>  * Icon dimensions
>  */
> 
> #define wxMACICON_DEPTH   8
> #define wxMACICON_COLOURS 256
> 
> 
> // Helper functions
> static CIconHandle ConvertBitmapToCIcon(const wxBitmap &bitmap);
> 
> 
> class WXDLLEXPORT wxIconRefData: public wxGDIRefData
27a44,60
>     friend class WXDLLEXPORT wxIcon;
>   public:
>     wxIconRefData();
>     ~wxIconRefData();
> 
>   public:
>     bool    m_ok;
>     int     m_size;
>     WXHICON m_hIcon;
> };
> 
> #define M_ICONDATA ((wxIconRefData *)m_refData)
> 
> wxIconRefData::wxIconRefData()
> {
>     m_ok = false;
>     m_hIcon = NULL ;
30,31c63
< wxIcon::wxIcon(const char bits[], int width, int height) :
<     wxBitmap(bits,width,height )
---
> wxIconRefData::~wxIconRefData()
33c65,69
<     
---
> 	if ( m_hIcon )
> 	{
> 		DisposeCIcon( m_hIcon ) ;
> 		m_hIcon = NULL ;
> 	}
36,37c72,78
< wxIcon::wxIcon( const char **bits ) :
<     wxBitmap(bits  )
---
> 
> /* ****************************
>  * wxIcon Implementation
>  * ****************************
>  */
> 
> wxIcon::wxIcon()
38a80
>     m_refData = NULL;
41,42c83
< wxIcon::wxIcon( char **bits ) :
<     wxBitmap(bits )
---
> wxIcon::wxIcon(const char **data)
43a85
>     Create(data);
46,47c88,91
< wxIcon::wxIcon(const wxString& icon_file, long flags,
<     int desiredWidth, int desiredHeight)
---
> wxIcon::wxIcon(char **data)
> {
>     Create((const char **)data);
> }
48a93
> wxIcon::wxIcon(const char bits[], int width, int height)
50c95,103
<     LoadFile(icon_file, flags, desiredWidth, desiredHeight);
---
>     Create(bits, width, height);
> }
> 
> wxIcon::wxIcon(const wxString& icon_file, long flags, int desiredWidth, int desiredHeight)
> {
>     if(LoadFile(icon_file, flags, desiredWidth, desiredHeight) == false) {
>         wxString message = wxT("Error: Can't load icon ") + icon_file;
>         wxFAIL_MSG(message);
>     }
57,58c110,205
< bool wxIcon::LoadFile(const wxString& filename, long type,
<     int desiredWidth, int desiredHeight)
---
> bool wxIcon::Create(const wxIcon &icon)
> {
>     Ref(icon);
> 
>     return Ok();
> }
> 
> bool wxIcon::Create(const char **data)
> {
>     wxBitmap bitmap(data);
> 
>     if(bitmap.Ok()) {
>         CopyFromBitmap(bitmap);
> 
>         return Ok();
>     }
>     return false;
> }
> 
> bool wxIcon::Create(const char bits[], int width, int height)
> {
>     wxBitmap bitmap(bits, width, height);
> 
>     if(bitmap.Ok()) {
>         CopyFromBitmap(bitmap);
> 
>         return Ok();
>     }
>     return false;
> }
> 
> bool wxIcon::Ok() const
> {
>     return (m_refData != NULL) ;
> }
> 
> int wxIcon::GetWidth() const
> {
>     wxCHECK_MSG(Ok(), 0, wxT("Invalid wxIcon"));
> 
>     return M_ICONDATA->m_size;
> }
> 
> int wxIcon::GetHeight() const
> {
>     wxCHECK_MSG(Ok(), 0, wxT("Invalid wxIcon"));
> 
>     return M_ICONDATA->m_size;
> }
> 
> int wxIcon::GetDepth() const
> {
>     wxCHECK_MSG(Ok(), 0, wxT("Invalid wxIcon"));
> 
>     return wxMACICON_DEPTH;
> }
> 
> int wxIcon::GetQuality() const
> {
>     wxCHECK_MSG(Ok(), 0, wxT("Invalid wxIcon"));
> 
>     return 1;
> }
> 
> bool wxIcon::LoadFile(const wxString& filename, long type, int desiredWidth, int desiredHeight)
> {
>     UnRef();
> 
>     if(type == wxBITMAP_TYPE_ICON_RESOURCE)
>     {
>         m_refData = new wxIconRefData;
> 
>         if(LoadResource(filename))
>         {
>             M_ICONDATA->m_size = (**M_ICONDATA->m_hIcon).iconMask.bounds.right;
>             return true;
>         }
>     }
>     else
>     {
>         wxBitmap bitmap(filename, type, desiredWidth, desiredHeight);
>         if(bitmap.Ok()) {
>             CopyFromBitmap(bitmap);
> 
>             return Ok();
>         }
>     }
>     return false;
> }
> 
> bool wxIcon::LoadFile(const wxString &name, long flags)
> {
>     return LoadFile( name , flags , -1 , -1 ) ;
> }
> 
> wxIcon &wxIcon::operator = (const wxIcon& icon)
60c207,210
<   UnRef();
---
>     if (*this == icon) return (*this);
>     Ref(icon);
>     return *this;
> }
62c212,216
<   m_refData = new wxBitmapRefData;
---
> wxIcon &wxIcon::operator = (const wxBitmap &bitmap)
> {
>     CopyFromBitmap(bitmap);
>     return *this;
> }
64c218,221
<   wxBitmapHandler *handler = FindHandler((wxBitmapType)type);
---
> bool wxIcon::operator == (const wxIcon& icon) const
> {
>     return m_refData == icon.m_refData;
> }
66,69c223,225
<   if ( handler )
< 	return handler->LoadFile(this, filename, type, desiredWidth, desiredHeight);
<   else
< 	return FALSE;
---
> bool wxIcon::operator != (const wxIcon& icon) const
> {
>     return m_refData != icon.m_refData;
72c228,236
< IMPLEMENT_DYNAMIC_CLASS(wxICONResourceHandler, wxBitmapHandler)
---
> void wxIcon::CopyFromBitmap(const wxBitmap &bitmap)
> {
>     UnRef();
> 
>     wxCHECK_RET(bitmap.Ok(), wxT("wxIcon::Create  Error illegal bitmap"));
> 
>     m_refData = new wxIconRefData;
> 
>     M_ICONDATA->m_hIcon = ConvertBitmapToCIcon(bitmap);
74,75c238,244
< bool  wxICONResourceHandler::LoadFile(wxBitmap *bitmap, const wxString& name, long flags,
<           int desiredWidth, int desiredHeight)
---
>     if(M_ICONDATA->m_hIcon) {
>         M_ICONDATA->m_size = (**M_ICONDATA->m_hIcon).iconMask.bounds.right;
>         M_ICONDATA->m_ok = true;
>     }
> }
> 
> void wxIcon::SetHICON(WXHICON icon)
77c246,261
< 	short theId = -1 ;
---
>     if(Ok()) {
>         M_ICONDATA->m_hIcon = icon;
>     }
> }
> 
> WXHICON wxIcon::GetHICON() const
> {
>     if(Ok()) {
>         return M_ICONDATA->m_hIcon;
>     }
>     return NULL;
> }
> 
> bool wxIcon::LoadResource(const wxString &name)
> {
>     short theId = -1 ;
88,89c272,273
<          theId = kCautionIcon ;
<    }
---
>         theId = kCautionIcon ;
>     }
96,97c280,281
<     	Str255 theName ;
<     	OSType theType ;
---
>         Str255 theName ;
>         OSType theType ;
99,111c283,295
<     #if TARGET_CARBON
<     	c2pstrcpy( (StringPtr) theName , name ) ;
<     #else
<     	strcpy( (char *) theName , name ) ;
<     	c2pstr( (char *) theName ) ;
<     #endif
<     	
<     	Handle resHandle = GetNamedResource( 'cicn' , theName ) ;
<     	if ( resHandle != 0L )
<     	{
<     		GetResInfo( resHandle , &theId , &theType , theName ) ;
<     		ReleaseResource( resHandle ) ;
<     	}
---
> #if TARGET_CARBON
>         c2pstrcpy( (StringPtr) theName , name ) ;
> #else
>         strcpy( (char *) theName , name ) ;
>         c2pstr( (char *) theName ) ;
> #endif
> 
>         Handle resHandle = GetNamedResource( 'cicn' , theName ) ;
>         if ( resHandle != 0L )
>         {
>             GetResInfo( resHandle , &theId , &theType , theName ) ;
>             ReleaseResource( resHandle ) ;
>         }
113,129c297,530
< 	if ( theId != -1 )
< 	{
< 		CIconHandle theIcon = (CIconHandle ) GetCIcon( theId ) ;
< 		if ( theIcon )
< 		{
< 			M_BITMAPHANDLERDATA->m_hIcon = theIcon ;
< 			M_BITMAPHANDLERDATA->m_width =  32 ;
< 			M_BITMAPHANDLERDATA->m_height = 32 ;
< 			
< 			M_BITMAPHANDLERDATA->m_depth = 8 ;
< 			M_BITMAPHANDLERDATA->m_ok = true ;
< 			M_BITMAPHANDLERDATA->m_numColors = 256 ;
< 			M_BITMAPHANDLERDATA->m_bitmapType = kMacBitmapTypeIcon ;
< 			return TRUE ;
< 		}
< 	}
< 	return FALSE ;
---
> 
>     if ( theId == -1 )  return false;
> 
>     CIconHandle theIcon = (CIconHandle ) GetCIcon( theId ) ;
> 
>     if ( theIcon == NULL )  return false;
> 
>     M_ICONDATA->m_hIcon = theIcon ;
>     M_ICONDATA->m_ok = true ;
> 
>     return true ;
> }
> 
> /*
>  * This code is based on an apple example called "icl8 To cicn.c"
>  *
>  * Contains:   This snippet converts a 'icl8' and 'ICN#' resource to a 'cicn' resource.
>  *
>  * Written by: EL
>  *
>  * Modified by: Mark Newsam
>  *
>  * Copyright:  Copyright ? 1992-1999 by Apple Computer, Inc., All Rights Reserved.
>  *
>  * You may incorporate this Apple sample source code into your program(s) without
>  * restriction. This Apple sample source code has been provided "AS IS" and the
>  * responsibility for its operation is yours. You are not permitted to redistribute
>  * this Apple sample source code as "Apple sample source code" after having made
>  * changes. If you're going to re-distribute the source, we require that you make
>  * it clear in the source that the code was descended from Apple sample source
>  * code, but that you've made changes.
>  *
>  * Change History (most recent first):
>  * 08/2000     JM              Carbonized, non-Carbon code is commented out
>  *                             for demonstration purposes.
>  * 7/9/1999    KG              Updated for Metrowerks Codewarror Pro 2.1
>  * 31/5/2001   MIN             Changed the to code to take a wxBitmap and convert it into
>  *                             a CIcon.  Or in apple parlance convert a GWorld into a
>  *                             CIcon.
>  *                             To keep in line with the above license this is based on apple code,
>  *                             but I "min" have made changes.
>  */
> 
> /* To convert from a bitmap (GWorld) to a CIconHandle I do the following:
>  * 1. Copy the bitmap and rescale if nessecary to icon size 32x32
>  * 2. Copy the icon bitmap into a char array to remove boundary padding
>  * 3. Copy the char array into an icl8 structure
>  * 4. Create an empty CIcon structure
>  * 5. Point the CIcon.iconData to the icl8 Handle
>  * 6. Fill in the mask and bitmap information at the end.  NB. The bitmap data is blank
>  *    and this may cause problems although it hasn't for me yet!
>  */
> static CIconHandle ConvertBitmapToCIcon(const wxBitmap &bitmap)
> {
>     CIconHandle gCICN;
>     wxBitmap    icon;
>     wxMemoryDC  memDC;
>     Handle      icl8;           // Handle to the icl8 resource.
>     char        depth;          // Depth of the icl8 pixel image.
>     Rect        destination;    // Bounding rect for the icon.
>     Rect        source;         // Bounding rect of source bitmap
>     long        bitmapSize;     // Size of the icon's bitmap.
>     int ii, iconSize;
>     RGBColor    white = { 0xffff, 0xffff, 0xffff };
>     RGBColor    black = { 0x0, 0x0, 0x0 };
> 
>     RGBForeColor( &black );  // Stops discolouration occuring when using CopyBits.
>     RGBBackColor( &white );
> 
>     // First work out an appropriate size for the icon 16x16 32x32 or 128x128
>     if(bitmap.GetWidth() <= 16) {
>         iconSize = 16;
>     }
>     else if(bitmap.GetWidth() <= 32) {
>         iconSize = 32;
>     }
>     else if(bitmap.GetWidth() <= 64) {
>         iconSize = 64;
>     }
>     else {
> #ifdef __WXMAC_X__
>         iconSize = 128;
> #else
>         iconSize = 32;
> #endif
>     }
> 
>     SetRect( &destination, 0, 0, iconSize, iconSize );   // Set up icon bounds
>     depth = wxMACICON_DEPTH;                             // 8-bit deep pixel image
>     bitmapSize = (iconSize / 8) * iconSize;              // bytesPerRow * number of rows.
>     SetRect( &source, 0,0, bitmap.GetWidth(), bitmap.GetHeight() );
> 
>     icon.Create(iconSize,iconSize, depth);
>     // Clear icon
>     memDC.SelectObject(icon);
>     memDC.Clear();
>     memDC.SelectObject(wxNullBitmap);
> 
>     wxCHECK_MSG(LockPixels(GetGWorldPixMap(bitmap.GetHBITMAP())), NULL,
>                 wxT("MakeCIcon  Unable to lock source pixels"));
>     wxCHECK_MSG(LockPixels(GetGWorldPixMap(icon.GetHBITMAP())), NULL,
>                 wxT("MakeCIcon  Unable to lock destination pixels"));
> 
>     // This copies the source bitmap into an icon rescaling if need be to the icons dimensions
>     CopyBits(GetPortBitMapForCopyBits(bitmap.GetHBITMAP()),
>              GetPortBitMapForCopyBits(icon.GetHBITMAP()),
>              &source, &destination, srcCopy, NULL);
> 
>     // Create the icl8 handle used to build cicn
>     icl8 = NewHandleClear(((iconSize * depth) / 8) * iconSize);
> 
>     HLock( icl8 );
>     HNoPurge( icl8 );
> 
>     char *data = new char[((iconSize * depth) / 8) * iconSize];
>     char *ptr = GetPixBaseAddr( GetGWorldPixMap(icon.GetHBITMAP()) );
> 
>     for(int yy = 0; yy < iconSize; yy++)
>     {
>         for(int xx = 0; xx < iconSize; xx++)
>         {
>             data[(yy * iconSize) + xx] = ptr[xx];
>         }
>         ptr += (*GetGWorldPixMap(icon.GetHBITMAP()))->rowBytes & 0x0fff;
>     }
>     BlockMove(data, *icl8, ((iconSize * depth) / 8) * iconSize);
>     delete []data;
> 
>     // Allocate memory for the 'cicn'.
> 
>     gCICN = (CIconHandle)NewHandleClear( (long)sizeof( CIcon ) );
> 
>     // Fill in the cicn's bitmap fields.
> 
>     (**gCICN).iconBMap.baseAddr          = nil;
>     (**gCICN).iconBMap.rowBytes          = iconSize / 8;
>     (**gCICN).iconBMap.bounds            = destination;
> 
>     // Fill in the cicn's mask bitmap fields.
> 
>     (**gCICN).iconMask.baseAddr          = nil;
>     (**gCICN).iconMask.rowBytes          = iconSize / 8;
>     (**gCICN).iconMask.bounds            = destination;
> 
>     // Fill in the cicn's pixmap fields.
> 
>     (**gCICN).iconPMap.baseAddr          = nil;
>     (**gCICN).iconPMap.rowBytes          = ((iconSize * depth) / 8) | 0x8000;
>     (**gCICN).iconPMap.bounds            = destination;
>     (**gCICN).iconPMap.pmVersion         = 0;
>     (**gCICN).iconPMap.packType          = 0;
>     (**gCICN).iconPMap.packSize          = 0;
>     (**gCICN).iconPMap.hRes              = 72;
>     (**gCICN).iconPMap.vRes              = 72;
>     (**gCICN).iconPMap.pixelSize         = depth;
>     (**gCICN).iconPMap.pixelType         = 0;
>     (**gCICN).iconPMap.cmpCount          = 1;
>     (**gCICN).iconPMap.cmpSize           = depth;
>     (**gCICN).iconPMap.pmTable           = GetCTable( depth );
> 
>     // Set the 'icl8' pixel image to the iconData field.
> 
>     (**gCICN).iconData = icl8;
> 
>     // Resize the 'cicn' for the bitmap image and mask.
> 
>     SetHandleSize( (Handle)gCICN, sizeof( CIcon ) + (bitmapSize * 2) );
> 
>     /* Copy the 'ICN#' data into the iconMaskData array.
>      * Note1: This is an array of shorts, so divide bitmapSize by 2.
>      * Note2: The mask comes before the image.  The is opposite of an 'ICN#'
>      * The 1 bit bitmap image I fill with blanks (It works so why not?)
>      * I also blank the mask first as well (In case the scaling dosn't work which
>      * happens for odd sized bitmaps */
>     for(ii = (bitmapSize / 2); ii < bitmapSize; ii++) {
>         (**gCICN).iconMaskData[ii] = 0x0000;
>     }
>     // Fill in the mask
>     wxMask *mask = bitmap.GetMask();
>     if(mask)
>     {
>         wxBitmap temp(iconSize, iconSize, 1);
>         wxMask   scaledmask;
> 
>         memDC.SelectObject(temp);
>         memDC.Clear();
>         memDC.SelectObject(wxNullBitmap);
> 
>         wxCHECK_MSG(LockPixels(GetGWorldPixMap(mask->GetMaskBitmap())), NULL,
>                     wxT("MakeCIcon  Unable to the destination mask pixels"));
>         wxCHECK_MSG(LockPixels(GetGWorldPixMap(temp.GetHBITMAP())), NULL,
>                     wxT("MakeCIcon  Unable to the destination mask pixels"));
> 
>         CopyBits(GetPortBitMapForCopyBits(mask->GetMaskBitmap()),
>                  GetPortBitMapForCopyBits(temp.GetHBITMAP()),
>                  &source, &destination, srcCopy, NULL);
>         scaledmask.Create(temp);
> 
>         for(int yy = 0; yy < iconSize; yy++)
>         {
>             for(int xx = 0; xx < iconSize / 16; xx++)
>             {
>                 UInt16 bitmask = 0x0000;
>                 UInt16 newmask = 0x8000;
>                 for(int ii = 0; ii < 16; ii++)
>                 {
>                     if(!scaledmask.PointMasked((xx * 16) + ii, yy)) {
>                         bitmask |= newmask;
>                     }
>                     newmask = newmask >> 1;
>                 }
>                 (**gCICN).iconMaskData[(yy * iconSize / 16) + xx] = bitmask;
>             }
>         }
>         UnlockPixels(GetGWorldPixMap(mask->GetMaskBitmap()));
>         UnlockPixels(GetGWorldPixMap(temp.GetHBITMAP()));
>     }
>     else // no mask information, so make whole image appear
>     {
>         for(ii = 0; ii < (bitmapSize / 2); ii++) {
>             (**gCICN).iconMaskData[ii] = 0xffff;
>         }
>     }
>     HPurge( icl8 );
>     HUnlock( icl8 );
> 
>     UnlockPixels(GetGWorldPixMap(bitmap.GetHBITMAP()));
>     UnlockPixels(GetGWorldPixMap(icon.GetHBITMAP()));
> 
>     if(MemError() != noErr) {
>         printf("Error when resizing a CIcon Handle\n");
>     }
> 
>     return gCICN;

 	  	 
