? grid.patch
? docs/latex/wx/grid.tex.ny
? include/wx/setup.h
? include/wx/generic/grid.h.ny
? lib/dmc_lib
? src/generic/grid.cpp.ny
? src/generic/grid.zip
Index: docs/latex/wx/grid.tex
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/docs/latex/wx/grid.tex,v
retrieving revision 1.32
diff -u -r1.32 grid.tex
--- docs/latex/wx/grid.tex	2006/02/11 12:05:52	1.32
+++ docs/latex/wx/grid.tex	2006/06/23 19:49:56
@@ -32,7 +32,6 @@
 
 \wxheading{Derived from}
 
-\helpref{wxScrolledWindow}{wxscrolledwindow}\\
 \helpref{wxWindow}{wxwindow}\\
 \helpref{wxEvtHandler}{wxevthandler}\\
 \helpref{wxObject}{wxobject}
@@ -600,6 +599,7 @@
 
 \constfunc{int}{GetColLeft}{\param{int }{col}}
 
+Returns the (unscrolled) position of the left side of the given column.
 
 
 \membersection{wxGrid::GetColLabelAlignment}\label{wxgridgetcollabelalignment}
@@ -656,6 +656,7 @@
 
 \constfunc{int}{GetColRight}{\param{int }{col}}
 
+Returns the (unscrolled) position of the right side of the given column.
 
 
 \membersection{wxGrid::GetColSize}\label{wxgridgetcolsize}
@@ -921,7 +922,8 @@
 
 \constfunc{int}{GetScrollLineX}{\void}
 
-Returns the number of pixels per horizontal scroll increment. The default is 15.
+Returns the number of pixels per horizontal scroll increment. 0 means that 
+scrolling has been disabled, -1 that scrolling is by whole columns.
 
 \wxheading{See also}
 
@@ -935,7 +937,8 @@
 
 \constfunc{int}{GetScrollLineY}{\void}
 
-Returns the number of pixels per vertical scroll increment. The default is 15.
+Returns the number of pixels per vertical scroll increment. 0 means that 
+scrolling has been disabled, -1 that scrolling is by whole rows.
 
 \wxheading{See also}
 
@@ -1157,15 +1160,26 @@
 
 \membersection{wxGrid::MakeCellVisible}\label{wxgridmakecellvisible}
 
-\func{void}{MakeCellVisible}{\param{int }{row}, \param{int }{col}}
+\func{bool}{MakeCellVisible}{\param{int }{row}, \param{int }{col}}
 
 \func{void}{MakeCellVisible}{\param{const wxGridCellCoords\& }{coords}}
 
 Brings the specified cell into the visible grid cell area with minimal scrolling. Does
-nothing if the cell is already visible.
+nothing if the cell is already visible. Returns true if the cell could be made (or already
+was) visible, otherwise false.
 
+\membersection{wxGrid::MoveCursorToCell}\label{wxgridmovecursortocell}
 
+\func{bool}{MoveCursortoCell}{\param{int }{row}, \param{int }{col}, \param{bool }{expandSelection}}
 
+Moves the grid cursor to the cell indcated by (row, col). If a block of cells was previously selected it
+will expand if the expandSelection argument is true or be cleared if the argument is false.
+
+\wxheading{Keyboard}\\
+This function is called with Ctrl+Home (moves to cell(0,0)) and Ctrl+End (moves to last cell in grid), 
+if shift key is also pressed, selection will be expanded.
+
+
 \membersection{wxGrid::MoveCursorDown}\label{wxgridmovecursordown}
 
 \func{bool}{MoveCursorDown}{\param{bool }{expandSelection}}
@@ -1268,13 +1282,14 @@
 
 \membersection{wxGrid::MovePageDown}\label{wxgridmovepagedown}
 
-\func{bool}{MovePageDown}{\void}
+\func{bool}{MovePageDown}{\param{bool }{expandSelection}}
 
-Moves the grid cursor down by some number of rows so that the previous bottom visible row
-becomes the top visible row.
+If scroll is by pixels: moves the grid cursor down by some number of rows so that the previous bottom visible row
+becomes the top visible row. If vertical scroll is by row: moves the cursor to the bottom row if it is not there already,
+otherwise as with pixel scroll.
 
 \wxheading{Keyboard}\\
-This function is called for PgDn keypresses.
+This function is called for PgDn keypresses. Shift+PgDn expands a selection.
 
 
 
@@ -1282,11 +1297,12 @@
 
 \func{bool}{MovePageUp}{\void}
 
-Moves the grid cursor up by some number of rows so that the previous top visible row
-becomes the bottom visible row.
+If scroll is by pixels: moves the grid cursor up by some number of rows so that the previous top visible row
+becomes the bottom visible row. If vertical scroll is by row: moves the cursor to the top row if it is not there already,
+otherwise as with pixel scroll.
 
 \wxheading{Keyboard}\\
-This function is called for PgUp keypresses.
+This function is called for PgUp keypresses. Shift+PgUp expands a selection.
 
 
 
@@ -1308,7 +1324,36 @@
 any edits to the final cell location will not be saved otherwise.
 
 
+\membersection{wxGrid::Scroll}\label{wxgridscroll}
+
+\func{void}{Scroll}{\param{int}{ x}, \param{int}{ y}}
+
+Scrolls a grid so the view start is at the given point.
+
+\wxheading{Parameters}
 
+\docparam{x}{The x position to scroll to, in scroll units.}
+
+\docparam{y}{The y position to scroll to, in scroll units.}
+
+\wxheading{Remarks}
+
+The positions are in scroll units, not pixels, so to convert to pixels you
+will have to multiply by the number of pixels per scroll increment.
+If either parameter is -1, that position will be ignored (no change in
+that direction).
+If the scroll increment is 0 in a direction, no scrolling will be done.
+If the scroll increment is -1, the parameter refers to column no. or
+row no.
+
+\wxheading{See also}
+
+\helpref{wxGrid::SetScrollLineX}{wxgridsetscrolllinex},\rtfsp
+\helpref{wxGrid::SetScrollLineY}{wxgridsetscrollliney},\rtfsp
+\helpref{wxGrid::GetScrollLineX}{wxgridgetscrolllinex},\rtfsp
+\helpref{wxGrid::GetScrollLineY}{wxgridgetscrollliney}
+
+
 \membersection{wxGrid::SelectAll}\label{wxgridselectall}
 
 \func{void}{SelectAll}{\void}
@@ -1795,11 +1840,14 @@
 
 \membersection{wxGrid::SetScrollLineX}\label{wxgridsetscrolllinex}
 
-\func{void}{SetScrollLineX}{\param{int }{x}}
+\func{bool}{SetScrollLineX}{\param{int }{x}}
 
 Sets the number of pixels per horizontal scroll increment. The default is 15.
 Sometimes wxGrid has trouble setting the scrollbars correctly due to rounding
-errors: setting this to 1 can help.
+errors: setting this to 1 can help. 
+Using parameter WXGRID_SCROLL_DISABLED (0) disables horizontal scrolling, 
+using WXGRID_SCROLL_CELL (-1) set scroll to whole columns.
+Returns false if an invalid parameter value (less than -1) was given.
 
 \wxheading{See also}
 
@@ -1811,11 +1859,14 @@
 
 \membersection{wxGrid::SetScrollLineY}\label{wxgridsetscrollliney}
 
-\func{void}{SetScrollLineY}{\param{int }{y}}
+\func{bool}{SetScrollLineY}{\param{int }{y}}
 
 Sets the number of pixels per vertical scroll increment. The default is 15.
 Sometimes wxGrid has trouble setting the scrollbars correctly due to rounding
 errors: setting this to 1 can help.
+Using parameter WXGRID_SCROLL_DISABLED (0) disables horizontal scrolling, 
+using WXGRID_SCROLL_CELL (-1) set scroll to whole rows.
+Returns false if an parameter invalid value (less than -1) was given.
 
 \wxheading{See also}
 
@@ -1823,6 +1874,25 @@
 \helpref{wxGrid::GetScrollLineY}{wxgridgetscrollliney},\rtfsp
 \helpref{wxGrid::SetScrollLineX}{wxgridsetscrolllinex}
 
+
+\membersection{wxGrid::EnableScrollbar}\label{wxgridenablescrollbar}
+
+\func{void}{EnableScrollbar}{\param{int }{orientation}, \param{bool}{enable}}
+
+Enables (enable==true) or disables scrollbars in the given orientation (use wxHORIZONTAL
+or wxVERTICAL as first parameter). This does not enable or disable scrolling (use SetScrollLineX()
+and SetScrollLineY() for that), which can still be done using e.g. the keyboard. Enabling
+scrollbars does not force scrollbars to appear if they have no use.
+
+
+\membersection{wxGrid::ScrollbarEnabled}\label{wxgridcrollbarenabled}
+
+\func{bool}{ScrollbarEnabled}{\param{int}{orientation}}
+Tells whether scrollbar is enabled for the given orientation (wxHORIZONTAL or wxVERTICAL).
+
+\wxheading{See also}
+
+\helpref{wxGrid::EnableScrollbar}{wxgridenablescrollbar}
 
 
 \membersection{wxGrid::SetSelectionBackground}\label{wxgridsetselectionbackground}
Index: include/wx/generic/grid.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/include/wx/generic/grid.h,v
retrieving revision 1.152
diff -u -r1.152 grid.h
--- include/wx/generic/grid.h	2006/04/09 00:09:35	1.152
+++ include/wx/generic/grid.h	2006/06/23 19:50:02
@@ -45,6 +45,11 @@
 #define WXGRID_MIN_COL_WIDTH                  15
 #define WXGRID_DEFAULT_SCROLLBAR_WIDTH        16
 
+// Scroll modes 
+#define WXGRID_SCROLL_DISABLED                 0
+#define WXGRID_SCROLL_CELL                    -1
+#define WXGRID_SCROLL_INVALID_AMOUNT       -9999
+
 // type names for grid table values
 #define wxGRID_VALUE_STRING     _T("string")
 #define wxGRID_VALUE_BOOL       _T("bool")
@@ -1067,7 +1072,7 @@
 // wxGrid
 // ----------------------------------------------------------------------------
 
-class WXDLLIMPEXP_ADV wxGrid : public wxScrolledWindow
+class WXDLLIMPEXP_ADV wxGrid : public wxWindow
 {
 public:
     wxGrid() ;
@@ -1225,11 +1230,11 @@
     //  coordinates for mouse events etc.
     //
     void XYToCell( int x, int y, wxGridCellCoords& );
-    int  YToRow( int y );
-    int  XToCol( int x );
+    int  YToRow( int y ) const;
+    int  XToCol( int x ) const;
 
-    int  YToEdgeOfRow( int y );
-    int  XToEdgeOfCol( int x );
+    int  YToEdgeOfRow( int y ) const;
+    int  XToEdgeOfCol( int x ) const;
 
     wxRect CellToRect( int row, int col );
     wxRect CellToRect( const wxGridCellCoords& coords )
@@ -1244,9 +1249,9 @@
     bool IsVisible( int row, int col, bool wholeCellVisible = true );
     bool IsVisible( const wxGridCellCoords& coords, bool wholeCellVisible = true )
         { return IsVisible( coords.GetRow(), coords.GetCol(), wholeCellVisible ); }
-    void MakeCellVisible( int row, int col );
-    void MakeCellVisible( const wxGridCellCoords& coords )
-        { MakeCellVisible( coords.GetRow(), coords.GetCol() ); }
+    bool MakeCellVisible( int row, int col );
+    bool MakeCellVisible( const wxGridCellCoords& coords )
+        { return MakeCellVisible( coords.GetRow(), coords.GetCol() ); }
 
 
     // ------ grid cursor movement functions
@@ -1254,12 +1259,13 @@
     void SetGridCursor( int row, int col )
         { SetCurrentCell( wxGridCellCoords(row, col) ); }
 
+    bool MoveCursorToCell( int row , int col , bool expandSelection );
     bool MoveCursorUp( bool expandSelection );
     bool MoveCursorDown( bool expandSelection );
     bool MoveCursorLeft( bool expandSelection );
     bool MoveCursorRight( bool expandSelection );
-    bool MovePageDown();
-    bool MovePageUp();
+    bool MovePageDown( bool expandSelection );
+    bool MovePageUp( bool expandSelection );
     bool MoveCursorUpBlock( bool expandSelection );
     bool MoveCursorDownBlock( bool expandSelection );
     bool MoveCursorLeftBlock( bool expandSelection );
@@ -1269,9 +1275,9 @@
     // ------ label and gridline formatting
     //
     int      GetDefaultRowLabelSize() { return WXGRID_DEFAULT_ROW_LABEL_WIDTH; }
-    int      GetRowLabelSize() { return m_rowLabelWidth; }
+    int      GetRowLabelSize() const { return m_rowLabelWidth; }
     int      GetDefaultColLabelSize() { return WXGRID_DEFAULT_COL_LABEL_HEIGHT; }
-    int      GetColLabelSize() { return m_colLabelHeight; }
+    int      GetColLabelSize() const { return m_colLabelHeight; }
     wxColour GetLabelBackgroundColour() { return m_labelBackgroundColour; }
     wxColour GetLabelTextColour() { return m_labelTextColour; }
     wxFont   GetLabelFont() { return m_labelFont; }
@@ -1339,10 +1345,10 @@
 
     // ------ row and col formatting
     //
-    int      GetDefaultRowSize();
-    int      GetRowSize( int row );
-    int      GetDefaultColSize();
-    int      GetColSize( int col );
+    int      GetDefaultRowSize() const;
+    int      GetRowSize( int row ) const;
+    int      GetDefaultColSize() const;
+    int      GetColSize( int col ) const;
     wxColour GetDefaultCellBackgroundColour();
     wxColour GetCellBackgroundColour( int row, int col );
     wxColour GetDefaultCellTextColour();
@@ -1542,23 +1548,28 @@
     wxWindow* GetGridCornerLabelWindow() { return (wxWindow*)m_cornerLabelWin; }
 
     // Allow adjustment of scroll increment. The default is (15, 15).
-    void SetScrollLineX(int x) { m_scrollLineX = x; }
-    void SetScrollLineY(int y) { m_scrollLineY = y; }
-    int GetScrollLineX() const { return m_scrollLineX; }
-    int GetScrollLineY() const { return m_scrollLineY; }
+    // You can also use special values
+    //      WXGRID_SCROLL_DISABLED           
+    //          (disable all scrolling)
+    //      WXGRID_SCROLL_CELL               
+    //          (use row/column scrolling, scrollbar enabled)
+    bool SetScrollLineX( int x );
+    bool SetScrollLineY( int y );
+
+    // Return scroll amount, when row/column scrolling returns WXGRID_SCROLL_CELL
+    int GetScrollLineX() const;
+    int GetScrollLineY() const;
+
+    // Enables or disables the scrollbar
+    void EnableScrollbar( int orientation, bool enable );
+    // Tells whether scrollbar is enabled
+    bool ScrollbarEnabled( int orientation ) const;
+    
+    // Convert pixels to scroll increments
+    int GetScrollX( int x ) const;
+    int GetScrollY( int y ) const;
 
-    // Implementation
-    int GetScrollX(int x) const
-    {
-        return (x + GetScrollLineX() - 1) / GetScrollLineX();
-    }
 
-    int GetScrollY(int y) const
-    {
-        return (y + GetScrollLineY() - 1) / GetScrollLineY();
-    }
-
-
     // override some base class functions
     virtual bool Enable(bool enable = true);
 
@@ -1576,8 +1587,8 @@
             int x, int y, int w = wxDefaultCoord, int h = wxDefaultCoord,
             long style = wxWANTS_CHARS,
             const wxString& name = wxPanelNameStr )
-        : wxScrolledWindow( parent, wxID_ANY, wxPoint(x,y), wxSize(w,h),
-                            (style|wxWANTS_CHARS), name )
+        : wxWindow( parent, wxID_ANY, wxPoint(x,y), wxSize(w,h),
+                    (style|wxWANTS_CHARS), name )
         {
             Create();
         }
@@ -1742,7 +1753,28 @@
 
     int m_numRows;
     int m_numCols;
+    int m_firstRow, m_firstCol;         // first cell in view, coordinates when cell scrolling
+    
+    // Note: These variables should be set by Scroll() and nobody else
+    int m_firstX,m_firstY;              // upper left corner of view when pixel scrolling
+
+    // Note: these should only be set using SetScrollLineX()/SetScrollLineY()
+    int m_scrollLineX,m_scrollLineY;    // number of pixels to scroll (0 or negative for cell scrolling)
+    
+    bool m_scrollbarXEnabled , m_scrollbarYEnabled; // are scrollbars enabled?
+    
+    // We must be able to recognize the Size Events that are generated by scrollbar adjustments
+    bool m_scrollbarGeneratedSizeEvent;
+    
+    // Returns the Scroll line amount if m_scrollLineX/Y is set to x
+    int GetScrollLine(int x) const;
+    
+
+
+    int GetWinTop() const; // Top of window, unscrolled pixel coordinate
+    int GetWinLeft() const; 
 
+
     wxGridCellCoords m_currentCellCoords;
 
     wxGridCellCoords m_selectingTopLeft;
@@ -1770,16 +1802,34 @@
     int        m_minAcceptableColWidth;
     wxArrayInt m_colWidths;
     wxArrayInt m_colRights;
+    int GetColWidth(int col) const;
 
+public:
     // get the col/row coords
-    int GetColWidth(int col) const;
     int GetColLeft(int col) const;
     int GetColRight(int col) const;
-
-    // this function must be public for compatibility...
-public:
     int GetRowHeight(int row) const;
+
+    virtual void SetScrollbar( int orientation, int position, int thumbSize, int range, bool refresh = true );
+
+    //These functions replace some that came with wxScrolledWindow
+    // wxGrid now inherits directly from wxWindow
+    void CalcScrolledPosition( int x, int y, int *xx, int *yy ) const;
+    void CalcUnscrolledPosition( int x, int y, int *xx, int *yy ) const;
+    virtual void DoPrepareDC( wxDC& dc );
+    void PrepareDC( wxDC& dc ){ DoPrepareDC(dc); }
+    void Scroll( int xPos, int yPos );
+    
 protected:
+    friend class wxGridRowLabelWindow;
+    friend class wxGridColLabelWindow;
+    friend class wxGridWindow;
+    
+    void OnScroll(wxScrollWinEvent& e);
+    int FindPageUp(int row,bool keepOriginVisible=false) const;
+    int FindPageDown(int row,bool keepOriginVisible=false) const;
+    int FindPageLeft(int col,bool findFullyVisible=false) const;
+    int FindPageRight(int col,bool findFullyVisible=false) const;
 
     int GetRowTop(int row) const;
     int GetRowBottom(int row) const;
@@ -1903,9 +1953,6 @@
 
     bool       m_editable;              // applies to whole grid
     bool       m_cellEditCtrlEnabled;   // is in-place edit currently shown?
-
-    int m_scrollLineX; // X scroll increment
-    int m_scrollLineY; // Y scroll increment
 
     void Create();
     void Init();
Index: samples/grid/griddemo.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/samples/grid/griddemo.cpp,v
retrieving revision 1.17
diff -u -r1.17 griddemo.cpp
--- samples/grid/griddemo.cpp	2006/01/07 00:31:32	1.17
+++ samples/grid/griddemo.cpp	2006/06/23 19:50:13
@@ -15,10 +15,10 @@
 // ----------------------------------------------------------------------------
 // headers
 // ----------------------------------------------------------------------------
-
+ 
 // For compilers that support precompilation, includes "wx/wx.h".
 #include "wx/wxprec.h"
-
+ 
 #ifdef __BORLANDC__
 #pragma hdrstop
 #endif
@@ -114,6 +114,11 @@
     EVT_MENU( ID_SET_HIGHLIGHT_WIDTH, GridFrame::OnSetHighlightWidth)
     EVT_MENU( ID_SET_RO_HIGHLIGHT_WIDTH, GridFrame::OnSetROHighlightWidth)
 
+    EVT_MENU( ID_SET_SCROLL_X, GridFrame::SetScrollX )
+    EVT_MENU( ID_SET_SCROLL_Y, GridFrame::SetScrollY )
+    EVT_MENU( ID_TOGGLE_SCROLLBAR_X, GridFrame::ToggleScrollbarX )
+    EVT_MENU( ID_TOGGLE_SCROLLBAR_Y, GridFrame::ToggleScrollbarY )
+
     EVT_GRID_LABEL_LEFT_CLICK( GridFrame::OnLabelLeftClick )
     EVT_GRID_CELL_LEFT_CLICK( GridFrame::OnCellLeftClick )
     EVT_GRID_ROW_SIZE( GridFrame::OnRowSize )
@@ -154,6 +159,8 @@
     viewMenu->Append( ID_AUTOSIZECOLS, _T("&Auto-size cols") );
     viewMenu->Append( ID_CELLOVERFLOW, _T("&Overflow cells"), wxEmptyString, wxITEM_CHECK );
     viewMenu->Append( ID_RESIZECELL, _T("&Resize cell (7,1)"), wxEmptyString, wxITEM_CHECK );
+    viewMenu->Append( ID_TOGGLE_SCROLLBAR_X, _T("&X scrollbar"), wxEmptyString, wxITEM_CHECK );
+    viewMenu->Append( ID_TOGGLE_SCROLLBAR_Y, _T("&Y scrollbar"), wxEmptyString, wxITEM_CHECK );
 
     wxMenu *rowLabelMenu = new wxMenu;
 
@@ -187,6 +194,8 @@
     editMenu->Append( ID_DELETEROW, _T("Delete selected ro&ws") );
     editMenu->Append( ID_DELETECOL, _T("Delete selected co&ls") );
     editMenu->Append( ID_CLEARGRID, _T("Cl&ear grid cell contents") );
+    editMenu->Append( ID_SET_SCROLL_X, _T("Set &horizontal scroll") );
+    editMenu->Append( ID_SET_SCROLL_Y, _T("Set &vertical scroll") );
 
     wxMenu *selectMenu = new wxMenu;
     selectMenu->Append( ID_SELECT_UNSELECT, _T("Add new cells to the selection"),
@@ -249,7 +258,7 @@
     m_logOld = wxLog::SetActiveTarget( logger );
     wxLog::SetTimestamp( NULL );
 #endif // wxUSE_LOG
-
+  
     // this will create a grid and, by default, an associated grid
     // table for strings
     grid->CreateGrid( 0, 0 );
@@ -266,7 +275,7 @@
     grid->SetCellValue( 0, 1, _T("A long piece of text to demonstrate wrapping.") );
     grid->SetCellRenderer(0 , 1, new wxGridCellAutoWrapStringRenderer);
     grid->SetCellEditor( 0,  1 , new wxGridCellAutoWrapStringEditor);
-
+ 
     grid->SetCellValue( 0, 2, _T("Blah") );
     grid->SetCellValue( 0, 3, _T("Read only") );
     grid->SetReadOnly( 0, 3 );
@@ -380,6 +389,8 @@
     GetMenuBar()->Check( ID_TOGGLEGRIDDRAGCELL, false );
     GetMenuBar()->Check( ID_TOGGLEGRIDLINES, true );
     GetMenuBar()->Check( ID_CELLOVERFLOW, true );
+    GetMenuBar()->Check( ID_TOGGLE_SCROLLBAR_X, true );
+    GetMenuBar()->Check( ID_TOGGLE_SCROLLBAR_Y, true );    
 }
 
 
@@ -887,8 +898,8 @@
                     single = _T("column");
                 }
 
-                const wxArrayInt sels(rows ? grid->GetSelectedRows()
-                                           : grid->GetSelectedCols());
+                const wxArrayInt sels=rows ? grid->GetSelectedRows()
+                                           : grid->GetSelectedCols();
                 size_t count = sels.size();
                 wxLogMessage(_T("%lu %s selected:"),
                              (unsigned long)count, plural);
@@ -1041,6 +1052,75 @@
                               wxWANTS_CHARS | wxSIMPLE_BORDER);
     grid->CreateGrid(3,3);
     frame->Show(true);
+}
+
+void GridFrame::ToggleScrollbarX( wxCommandEvent& WXUNUSED(ev) )
+{   
+    grid->EnableScrollbar( wxHORIZONTAL, 
+                           GetMenuBar()->IsChecked( ID_TOGGLE_SCROLLBAR_X ) );
+}
+
+void GridFrame::ToggleScrollbarY( wxCommandEvent& WXUNUSED(ev) )
+{
+    grid->EnableScrollbar( wxVERTICAL, 
+                           GetMenuBar()->IsChecked( ID_TOGGLE_SCROLLBAR_Y ) );
+}
+
+
+void GridFrame::SetScrollX(wxCommandEvent& e)
+{
+    long scrollX = grid->GetScrollLineX();
+
+#ifdef __WXMOTIF__
+    // MB: wxGetNumberFromUser doesn't work properly for wxMotif
+    wxString s;
+    s << scrollX;
+    s = wxGetTextFromUser( _T("Set horizontal scroll:"),
+                           _T("Value:"),
+                           s );
+
+    s.ToLong( &scrollX );
+
+#else
+    // values -2 and -3 are invalid, can be used to test error message from SetScrollLineX()
+    scrollX = wxGetNumberFromUser(_T("Set horizontal scroll"),
+                                     _T("Value: "),
+                                     _T("wxGridDemo question"),
+                                     scrollX,
+                                     -3, 200, this);
+#endif
+
+    grid->SetScrollLineX(scrollX);
+    // if we enable scroll, scrollbars must be turned on if option checked
+    wxLogMessage( _T("Horizontal scroll is now %d"),grid->GetScrollLineX());
+    ToggleScrollbarX(e);
+} 
+
+void GridFrame::SetScrollY(wxCommandEvent& e)
+{
+    long scrollY = grid->GetScrollLineY();
+
+#ifdef __WXMOTIF__
+    // MB: wxGetNumberFromUser doesn't work properly for wxMotif
+    wxString s;
+    s << scrollY;
+    s = wxGetTextFromUser( _T("Set vertical scroll:"),
+                           _T("Value:"),
+                           s ); 
+ 
+    s.ToLong( &scrollY );
+ 
+#else
+    scrollY = wxGetNumberFromUser(_T("Set vertical scroll"),
+                                     _T("Value: "),
+                                     _T("wxGridDemo question"),
+                                     scrollY,
+                                     -3, 200, this);
+#endif 
+ 
+    grid->SetScrollLineY(scrollY);
+    wxLogMessage( _T("Vertical scroll is now %d"),grid->GetScrollLineX());
+    ToggleScrollbarY(e);
 }
 
 void GridFrame::OnVTable(wxCommandEvent& )
Index: samples/grid/griddemo.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/samples/grid/griddemo.h,v
retrieving revision 1.9
diff -u -r1.9 griddemo.h
--- samples/grid/griddemo.h	2006/01/07 00:31:32	1.9
+++ samples/grid/griddemo.h	2006/06/23 19:50:13
@@ -84,6 +84,11 @@
     void OnCellValueChanged( wxGridEvent& );
     void OnCellBeginDrag( wxGridEvent& );
 
+    void SetScrollX(wxCommandEvent &);
+    void SetScrollY(wxCommandEvent &);
+    void ToggleScrollbarX(wxCommandEvent &);
+    void ToggleScrollbarY(wxCommandEvent &);
+
     void OnEditorShown(wxGridEvent&);
     void OnEditorHidden(wxGridEvent&);
 
@@ -147,6 +152,10 @@
         ID_DESELECT_ROW,
         ID_DESELECT_COL,
         ID_DESELECT_CELL,
+        ID_SET_SCROLL_X,
+        ID_SET_SCROLL_Y,
+        ID_TOGGLE_SCROLLBAR_X,
+        ID_TOGGLE_SCROLLBAR_Y,
 
         ID_SET_HIGHLIGHT_WIDTH,
         ID_SET_RO_HIGHLIGHT_WIDTH,
@@ -200,7 +209,7 @@
 };
 
 class BigGridFrame : public wxFrame
-{
+{   
 public:
     BigGridFrame(long sizeGrid);
 
Index: src/generic/grid.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/generic/grid.cpp,v
retrieving revision 1.378
diff -u -r1.378 grid.cpp
--- src/generic/grid.cpp	2006/05/23 02:17:39	1.378
+++ src/generic/grid.cpp	2006/06/23 19:50:34
@@ -414,21 +414,6 @@
 // in these hash tables is the number of rows/columns)
 static const int GRID_HASH_SIZE = 100;
 
-#if 0
-// ----------------------------------------------------------------------------
-// private functions
-// ----------------------------------------------------------------------------
-
-static inline int GetScrollX(int x)
-{
-    return (x + GRID_SCROLL_LINE_X - 1) / GRID_SCROLL_LINE_X;
-}
-
-static inline int GetScrollY(int y)
-{
-    return (y + GRID_SCROLL_LINE_Y - 1) / GRID_SCROLL_LINE_Y;
-}
-#endif
 
 // ============================================================================
 // implementation
@@ -567,9 +552,6 @@
     if ((ctrl || alt) && !(ctrl && alt))
         return false;
 
-    int key = 0;
-    bool keyOk = true;
-
 #ifdef __WXGTK20__
     // If it's a F-Key or other special key then it shouldn't start the
     // editor.
@@ -581,18 +563,13 @@
     // be a function key or etc., the platforms appear to always give us a
     // small value in this case) then fallback to the ASCII key code but
     // don't do anything for function keys or etc.
-    key = event.GetUnicodeKey();
-    if (key <= 127)
-    {
-        key = event.GetKeyCode();
-        keyOk = (key <= 127);
-    }
+    if ( event.GetUnicodeKey() <= 127)
+        return (event.GetKeyCode() <= 127);
+    return true;
 #else
-    key = event.GetKeyCode();
-    keyOk = (key <= 255);
+    return (event.GetKeyCode() <= 255);
 #endif
 
-    return keyOk;
 }
 
 void wxGridCellEditor::StartingKey(wxKeyEvent& event)
@@ -1616,42 +1593,17 @@
             break;
 
         case WXK_HOME:
-        {
-            if ( wholeCellVisible )
-            {
-                // no special processing needed...
-                event.Skip();
-                break;
-            }
-
-            // do special processing for partly visible cell...
-
-            // get the widths of all cells previous to this one
-            int colXPos = 0;
-            for ( int i = 0; i < col; i++ )
-            {
-                colXPos += m_grid->GetColSize(i);
-            }
-
-            int xUnit = 1, yUnit = 1;
-            m_grid->GetScrollPixelsPerUnit(&xUnit, &yUnit);
-            if (col != 0)
-            {
-                m_grid->Scroll(colXPos / xUnit - 1, m_grid->GetScrollPos(wxVERTICAL));
-            }
-            else
-            {
-                m_grid->Scroll(colXPos / xUnit, m_grid->GetScrollPos(wxVERTICAL));
-            }
+            if ( !wholeCellVisible )
+                // MakeCellVisible() makes the left side of column visible
+                m_grid->MakeCellVisible( row, col );
             event.Skip();
             break;
-        }
 
         case WXK_END:
         {
-            if ( wholeCellVisible )
+            if ( wholeCellVisible 
+                 || m_grid->GetScrollLineX() <= 0 ) // cannot show right side
             {
-                // no special processing needed...
                 event.Skip();
                 break;
             }
@@ -1673,27 +1625,22 @@
                 // (m_grid->GetScrollLineX()*2) is a factor for not scrolling to far,
                 // otherwise the last part of the cell content might be hidden below the scroll bar
                 // FIXME: maybe there is a more suitable correction?
-                textWidth -= (client_right - (m_grid->GetScrollLineX() * 2));
+                // textWidth -= (client_right - (m_grid->GetScrollLineX() * 2));
+                // How about this (as GetScrollLineX() may be ANY positive int at this point):
+                textWidth -= (client_right - WXGRID_DEFAULT_SCROLLBAR_WIDTH - 10 );
+                
                 if ( textWidth < 0 )
                 {
                     textWidth = 0;
                 }
             }
 
-            // get the widths of all cells previous to this one
-            int colXPos = 0;
-            for ( int i = 0; i < col; i++ )
-            {
-                colXPos += m_grid->GetColSize(i);
-            }
-
-            // and add the (modified) text width of the cell contents
+            
+            // Left side of column + the (modified) text width of the cell contents
             // as we'd like to see the last part of the cell contents
-            colXPos += textWidth;
-
-            int xUnit = 1, yUnit = 1;
-            m_grid->GetScrollPixelsPerUnit(&xUnit, &yUnit);
-            m_grid->Scroll(colXPos / xUnit - 1, m_grid->GetScrollPos(wxVERTICAL));
+            int colXPos = m_grid->GetColLeft( col ) + textWidth;
+            int xUnit = m_grid->GetScrollLineX();
+            m_grid->Scroll(colXPos / xUnit - 1, -1 );
             event.Skip();
             break;
         }
@@ -3703,9 +3650,7 @@
     //
     // m_owner->PrepareDC( dc );
 
-    int x, y;
-    m_owner->CalcUnscrolledPosition( 0, 0, &x, &y );
-    dc.SetDeviceOrigin( 0, -y );
+    dc.SetDeviceOrigin( 0, -m_owner->GetWinTop() );
 
     wxArrayInt rows = m_owner->CalcRowLabelsExposed( GetUpdateRegion() );
     m_owner->DrawRowLabels( dc, rows );
@@ -3773,9 +3718,7 @@
     //
     // m_owner->PrepareDC( dc );
 
-    int x, y;
-    m_owner->CalcUnscrolledPosition( 0, 0, &x, &y );
-    dc.SetDeviceOrigin( -x, 0 );
+    dc.SetDeviceOrigin( -m_owner->GetWinLeft(), 0 );
 
     wxArrayInt cols = m_owner->CalcColLabelsExposed( GetUpdateRegion() );
     m_owner->DrawColLabels( dc, cols );
@@ -4048,7 +3991,7 @@
 
 wxEND_FLAGS( wxGridStyle )
 
-IMPLEMENT_DYNAMIC_CLASS_XTI(wxGrid, wxScrolledWindow,"wx/grid.h")
+IMPLEMENT_DYNAMIC_CLASS_XTI(wxGrid, wxWindow,"wx/grid.h")
 
 wxBEGIN_PROPERTIES_TABLE(wxGrid)
     wxHIDE_PROPERTY( Children )
@@ -4064,17 +4007,18 @@
  TODO : Expose more information of a list's layout, etc. via appropriate objects (e.g., NotebookPageInfo)
 */
 #else
-IMPLEMENT_DYNAMIC_CLASS( wxGrid, wxScrolledWindow )
+IMPLEMENT_DYNAMIC_CLASS( wxGrid, wxWindow )
 #endif
 
-BEGIN_EVENT_TABLE( wxGrid, wxScrolledWindow )
+BEGIN_EVENT_TABLE( wxGrid, wxWindow )
     EVT_PAINT( wxGrid::OnPaint )
     EVT_SIZE( wxGrid::OnSize )
     EVT_KEY_DOWN( wxGrid::OnKeyDown )
     EVT_KEY_UP( wxGrid::OnKeyUp )
     EVT_CHAR ( wxGrid::OnChar )
     EVT_ERASE_BACKGROUND( wxGrid::OnEraseBackground )
-END_EVENT_TABLE()
+    EVT_SCROLLWIN( wxGrid::OnScroll )
+ END_EVENT_TABLE()
 
 wxGrid::wxGrid()
 {
@@ -4092,7 +4036,7 @@
                  const wxSize& size,
                  long style,
                  const wxString& name )
-  : wxScrolledWindow( parent, id, pos, size, (style | wxWANTS_CHARS), name ),
+  : wxWindow( parent, id, pos, size, (style | wxWANTS_CHARS), name ),
     m_colMinWidths(GRID_HASH_SIZE),
     m_rowMinHeights(GRID_HASH_SIZE)
 {
@@ -4104,8 +4048,8 @@
                           const wxPoint& pos, const wxSize& size,
                           long style, const wxString& name)
 {
-    if (!wxScrolledWindow::Create(parent, id, pos, size,
-                                  style | wxWANTS_CHARS, name))
+    if (!wxWindow::Create(parent, id, pos, size,
+                          style | wxWANTS_CHARS, name))
         return false;
 
     m_colMinWidths = wxLongToLongHashMap(GRID_HASH_SIZE);
@@ -4119,8 +4063,6 @@
 
 wxGrid::~wxGrid()
 {
-    // Must do this or ~wxScrollHelper will pop the wrong event handler
-    SetTargetWindow(this);
     ClearAttrCache();
     wxSafeDecRef(m_defaultCellAttr);
 
@@ -4219,7 +4161,6 @@
                                   wxDefaultPosition,
                                   wxDefaultSize );
 
-    SetTargetWindow( m_gridWin );
 
 #if _USE_VISATTR
     wxColour gfg = gva.colFg;
@@ -4268,6 +4209,469 @@
     return m_created;
 }
 
+bool wxGrid::SetScrollLineX( int x ) 
+{   
+    int scrollTo = -1;
+    int scrollLine = GetScrollLine( x );
+    switch( scrollLine )
+    {
+        case WXGRID_SCROLL_INVALID_AMOUNT:
+            wxLogError( _T("wxGrid::SetScrollLineX(): Invalid value for scroll amount") );    
+            return false;
+        case WXGRID_SCROLL_CELL:
+            if( GetScrollLineX() != WXGRID_SCROLL_CELL )
+                // Changing from pixel to whole column scroll
+                scrollTo=XToCol( GetWinLeft() );
+            break;
+        case WXGRID_SCROLL_DISABLED:
+            // we do not set m_scrollbarXEnabled, would cause scrollbars not to reappear when scroll enabled again
+            // We do not adjust the window when disabling scroll, that is up to user
+            break;
+        default:
+            wxASSERT_MSG( scrollLine > 0 ,
+                // should only happen if there are errors in the wxGrid code
+                wxT("wxGrid::SetScrollLineX(): wxGrid error! Invalid value for scroll amount") );    
+            scrollTo = GetWinLeft() / scrollLine;
+            m_firstCol = -1; // not defined anymore
+    }
+    m_scrollLineX = x;
+    CalcDimensions();
+    Scroll( scrollTo , -1 );
+    return true;
+}
+    
+bool wxGrid::SetScrollLineY( int y ) 
+{
+    int scrollTo = -1;
+    int scrollLine = GetScrollLine( y ) ;
+    switch( scrollLine )
+    {
+        case WXGRID_SCROLL_INVALID_AMOUNT:
+            wxLogError( _T("wxGrid::SetScrollLineY(): Invalid value for scroll amount") );    
+            return false;
+        case WXGRID_SCROLL_CELL:
+            if( GetScrollLineY() != WXGRID_SCROLL_CELL )
+                // Changing from pixel to whole column scroll
+                scrollTo = YToRow( GetWinTop() );
+            break;
+        case WXGRID_SCROLL_DISABLED:
+            break;
+        default:
+            wxASSERT_MSG( scrollLine > 0,
+                // should only happen if there are errors in the wxGrid code
+                wxT("wxGrid::SetScrollLineY(): wxGrid error! Invalid value for scroll amount"));
+            scrollTo = GetWinTop() / scrollLine;
+            m_firstRow = -1;
+    }
+    m_scrollLineY = y;
+    CalcDimensions();
+    Scroll( -1 , scrollTo );
+    return true;
+}
+
+
+// Convert pixels to scroll increments
+int wxGrid::GetScrollX( int x ) const
+{
+    switch( GetScrollLineX() )
+    {
+        case WXGRID_SCROLL_CELL : // Scrolling whole columns
+            // Todo: may have to be rounded up???
+            return XToCol( x );
+        case WXGRID_SCROLL_DISABLED:
+            return 0; 
+        default:
+            return (x + GetScrollLineX() - 1) / GetScrollLineX();
+    }
+}
+
+int wxGrid::GetScrollY( int y ) const
+{
+    switch( GetScrollLineY() )
+    {
+        case WXGRID_SCROLL_CELL : // Scrolling whole rows
+            // Todo: may have to be rounded up???
+            return YToRow( y );
+        case WXGRID_SCROLL_DISABLED:
+            return 0; 
+        default:
+            return (y + GetScrollLineY() - 1) / GetScrollLineY();
+    }
+}
+
+int wxGrid::GetWinLeft() const 
+{
+    return m_firstX;
+}
+
+int wxGrid::GetWinTop() const 
+{
+    return m_firstY;
+}
+
+void wxGrid::CalcScrolledPosition( int x , int y , int *xx , int *yy ) const
+{
+   if ( xx ) *xx = x - GetWinLeft();
+   if ( yy ) *yy = y - GetWinTop();
+}
+
+void wxGrid::CalcUnscrolledPosition( int x , int y , int *xx , int *yy ) const
+{
+   if ( xx ) *xx = x + GetWinLeft();
+   if ( yy ) *yy = y + GetWinTop();
+}
+
+void wxGrid::DoPrepareDC( wxDC& dc )
+{
+   wxPoint pt = dc.GetDeviceOrigin();
+   dc.SetDeviceOrigin( pt.x - GetWinLeft(), pt.y - GetWinTop() );
+}
+
+int wxGrid::FindPageLeft( int col , bool keepOriginVisible ) const
+{   
+    if( col <= 0 ) 
+        return 0;
+    if( col >= m_numCols )
+        col = m_numCols-1;
+    
+    // m_gridWin might not be resized at this point, so we use the grid and subtract label width
+    int cw = GetClientSize().GetWidth();
+    if( m_rowLabelWin->IsShown() ) cw -= GetRowLabelSize();
+      
+    if( keepOriginVisible ) 
+    // Origin must be fully visible,
+    // we want right(right col) - left(left col) <= cw
+    {   
+        int endPoint = GetColRight( col ) - cw;
+        // remember to show all that beautiful extra white space
+        if( col == m_numCols - 1 ) endPoint += m_extraWidth;
+        if( endPoint <= 0 ) 
+            return 0;
+        while( GetColLeft( col ) >= endPoint )
+            --col;
+        return ++col;
+    }
+    else  // we want left(right cell) - left(left cell) < cw
+    {
+        int endPoint = GetColLeft( col ) - cw;
+        if( endPoint < 0 )
+            return 0;
+        int ret = col;
+        while( GetColLeft( ret ) > endPoint )
+            --ret;
+        if( ret < col - 1 ) // scroll at least one column, else we never get anywhere
+            ++ret; 
+        return ret;
+    }
+}
+
+int wxGrid::FindPageUp( int row , bool keepOriginVisible ) const
+{
+    if( row <= 0 ) 
+        return 0;
+    if( row >= m_numRows ) 
+        row = m_numRows-1;
+    
+    int ch = GetClientSize().GetHeight();
+    if( m_colLabelWin->IsShown() ) ch -= GetColLabelSize();
+    
+    if( keepOriginVisible )
+    {
+        int endPoint = GetRowBottom( row ) - ch;
+        if( row == m_numRows - 1 ) endPoint += m_extraHeight;
+        if( endPoint <= 0 ) 
+            return 0;
+        while( GetRowTop( row ) >= endPoint )
+            --row;
+        return ++row;
+    }
+    else
+    {
+        int endPoint = GetRowTop( row ) - ch;
+        if( endPoint < 0 )
+            return 0;
+        int ret = row;
+        while( GetRowTop( ret ) > endPoint )
+            --ret;
+        if( ret < row - 1 ) 
+            ++ret; 
+        return ret;
+    }
+}
+   
+int wxGrid::FindPageRight( int col , bool findFullyVisible ) const
+{
+    if( col >= m_numCols - 1 ) 
+        return m_numCols - 1;
+    if( col < 0 )
+        col = 0;
+      
+    int cw = GetClientSize().GetWidth();
+    if( m_rowLabelWin->IsShown() ) cw -= GetRowLabelSize();
+    int endPoint = GetColLeft(col) + cw;
+
+    if( findFullyVisible )
+    // Find col that is fully visible when start col is to the left
+    // i.e. right(result column) - left(start column) <= cw
+    {
+        // if start column is the one and only, we return that
+        // (if you can't get the one you love, you must love the one you get)
+        if( GetColRight(col) >= endPoint )  
+            return col;
+        ++col;
+        while( GetColRight(col) <= endPoint )
+        {
+            if( col == m_numCols-1 )
+            {
+                // we do not consider this "fully" visible unless we also can see the margin
+                if( GetColRight(col) + m_extraWidth <= endPoint )
+                    return col;
+                else 
+                    break;
+            }
+            ++col;
+        }
+        return --col;
+    }
+    else
+    // Find column that is at least partly visible when start column is to the left
+    // i.e. left(result column) - left(start column) < cw
+    {
+        int ret = col;
+        while( GetColRight( ret ) < endPoint )
+        {
+            if( ret == m_numCols-1 ) 
+                return ret;
+            ++ret;
+        }
+        if( ret == col ) // scroll at least one column
+            ++ret;
+        return ret;
+    }
+}
+   
+int wxGrid::FindPageDown( int row , bool findFullyVisible ) const
+{
+    if( row >= m_numRows - 1 ) 
+        return m_numRows-1;
+    if( row < 0 )
+        row = 0;
+
+    int ch = GetClientSize().GetHeight();
+    if( m_colLabelWin->IsShown() ) ch -= GetColLabelSize();
+    int endPoint = GetRowTop( row ) + ch;
+
+    if( findFullyVisible )
+    {
+        if( GetRowBottom( row ) >= endPoint )
+            return row;
+        ++row;
+        while( GetRowBottom( row ) <= endPoint )
+        {
+            if( row == m_numRows-1 ) 
+            {
+                if( GetRowBottom(row) + m_extraHeight <= endPoint )
+                    return row;
+                else 
+                    break;
+            }
+            ++row;
+        }
+        return --row;
+    }
+    else
+    {
+        int ret = row;
+        while( GetRowBottom( ret ) < endPoint )
+        {
+            if( ret == m_numRows - 1 ) 
+                return ret;
+            ++ret;
+        }
+        if( ret == row ) 
+            ++ret;
+        return ret;
+    }
+}
+
+void wxGrid::Scroll( int x_pos, int y_pos )
+{    
+    if ( ( x_pos >= 0 ) && m_numCols)
+    {
+        int old_x = m_firstX;
+        int maxLeft;
+        if( GetScrollLineX() == WXGRID_SCROLL_CELL )
+        {
+            // do not scroll further than the last whole page
+            maxLeft = FindPageLeft( m_numCols-1 , true );
+            if( maxLeft <= 0 )
+            // this may happen if the programmer calls Scroll() without checking if scrollbar is present
+                m_firstX = 0;
+            else
+            {
+                if( x_pos > maxLeft ) 
+                    x_pos = maxLeft;
+                m_firstCol = x_pos;
+                m_firstX = GetColLeft( x_pos );
+            }
+        }
+        else if( GetScrollLineX() > 0 )
+        {
+            int cw = GetClientSize().GetWidth();
+            if( m_rowLabelWin->IsShown() ) cw -= GetRowLabelSize();
+            int maxRight = GetColRight( m_numCols - 1 ) + m_extraWidth + 1;
+            maxLeft = maxRight - cw;
+            if( maxLeft <= 0 )
+            {
+                wxASSERT_MSG( old_x==0 , _T("ERROR wxGrid::Scroll(2): X position not 0") );
+                m_firstX = 0;
+            }
+            else
+            {
+                m_firstX = x_pos * GetScrollLineX();
+                if( m_firstX > maxLeft )
+                {
+                    m_firstX = maxLeft;
+                    // when using scrollbar, x_pos should be OK, but, you know, programmers...
+                    x_pos = GetScrollRange( wxHORIZONTAL ) - GetScrollThumb( wxHORIZONTAL );
+                }
+            }
+        }
+            
+        if ( old_x != m_firstX ) 
+        {
+            if( ScrollbarEnabled( wxHORIZONTAL ) && maxLeft>0 ) // if scrollbar present
+                SetScrollPos( wxHORIZONTAL, x_pos );
+            // The positions on the scrollbar go up as we move down/right,
+            // but ScrollWindow takes a positive number to scroll up, therefore the sign is opposite
+            m_gridWin->ScrollWindow( old_x-m_firstX , 0 , NULL );
+        }
+    }
+    if ( ( y_pos >= 0 ) && m_numRows )
+    {
+        int old_y = m_firstY;
+        int maxUp;
+        if( GetScrollLineY() == WXGRID_SCROLL_CELL )
+        {
+            maxUp = FindPageUp( m_numRows - 1, true );
+            if( maxUp == 0 )
+            {
+                wxASSERT_MSG( old_y == 0 , _T("ERROR wxGrid::Scroll(3): Y position not 0") );
+                m_firstY = 0;
+            }
+            else
+            {
+                if( y_pos > maxUp ) 
+                    y_pos = maxUp;
+                m_firstRow = y_pos;
+                m_firstY = GetRowTop( y_pos );
+            }
+        }
+        else if( GetScrollLineY() > 0 )
+        {
+            int ch = GetClientSize().GetHeight();
+            if( m_colLabelWin->IsShown() ) ch -= GetColLabelSize();
+            int maxDown=GetRowBottom( m_numRows - 1 ) + m_extraHeight + 1;
+            maxUp = maxDown - ch;
+            if( maxUp <= 0 ) 
+            {
+                wxASSERT_MSG( old_y == 0 , _T("ERROR wxGrid::Scroll(4): Y position not 0") );
+                m_firstY = 0;
+            }
+            else
+            {
+                m_firstY = y_pos * GetScrollLineY() ;
+                if( m_firstY > maxUp )
+                {
+                    m_firstY = maxUp;
+                    y_pos = GetScrollRange(wxVERTICAL) - GetScrollThumb(wxVERTICAL);
+                }
+            }
+        }
+        if ( old_y != m_firstY ) 
+        {
+            if( ScrollbarEnabled( wxVERTICAL ) && maxUp > 0 )
+                SetScrollPos( wxVERTICAL, y_pos );
+            m_gridWin->ScrollWindow( 0, old_y-m_firstY, NULL );
+        }
+    }
+}
+   
+void wxGrid::OnScroll( wxScrollWinEvent &e )
+{
+    int oldPos;
+    if( e.GetOrientation() == wxHORIZONTAL )
+    {
+        if( GetScrollLineX() < 1 )
+            oldPos = m_firstCol;
+        else
+            oldPos = GetScrollX( m_firstX );
+        if( e.GetEventType() == wxEVT_SCROLLWIN_PAGEDOWN )
+        {
+            if( GetScrollLineX() < 1 )
+                Scroll( FindPageRight( m_firstCol ) , -1 );
+            else
+                Scroll( oldPos + GetScrollThumb( wxHORIZONTAL ), -1 );
+        }
+        else if( e.GetEventType() == wxEVT_SCROLLWIN_PAGEUP )
+        {
+            if( GetScrollLineX() < 1 )
+                Scroll( FindPageLeft( m_firstCol ) , -1 );
+            else if( oldPos <= GetScrollThumb( wxHORIZONTAL ) )
+                Scroll( 0 , -1 );
+            else
+                Scroll( oldPos - GetScrollThumb( wxHORIZONTAL ) , -1 );
+        }
+        else if( e.GetEventType() == wxEVT_SCROLLWIN_BOTTOM )
+            // Just scroll too far and let Scroll() handle that
+            Scroll( GetScrollRange( wxHORIZONTAL ) , -1 );
+        else if( e.GetEventType() == wxEVT_SCROLLWIN_TOP )
+            Scroll( 0 , -1 );
+        else if( e.GetEventType() == wxEVT_SCROLLWIN_LINEDOWN )
+            Scroll( oldPos + 1 , -1 );
+        else if( e.GetEventType() == wxEVT_SCROLLWIN_LINEUP )
+            Scroll( oldPos - 1 , -1 );
+        else if( e.GetEventType() == wxEVT_SCROLLWIN_THUMBRELEASE ||
+                 e.GetEventType() == wxEVT_SCROLLWIN_THUMBTRACK )
+            Scroll( e.GetPosition() , -1 );
+    }
+    else
+    {
+        if( GetScrollLineY() < 1 )
+            oldPos = m_firstRow;
+        else
+            oldPos = GetScrollY( m_firstY );
+        if( e.GetEventType() == wxEVT_SCROLLWIN_PAGEDOWN )
+        {
+            if( GetScrollLineY() < 1 )
+                Scroll( -1 , FindPageDown( m_firstRow ) );
+            else
+                Scroll( -1 , oldPos + GetScrollThumb( wxVERTICAL ) );
+        }
+        else if( e.GetEventType() == wxEVT_SCROLLWIN_PAGEUP )
+        {
+            if( GetScrollLineY() < 1 )
+                Scroll( -1 , FindPageUp( m_firstRow ) );
+            else if( oldPos <= GetScrollThumb( wxVERTICAL ) )
+                Scroll( -1, 0 );
+            else
+                Scroll( -1 , oldPos - GetScrollThumb( wxVERTICAL ) );
+        }
+        else if( e.GetEventType() == wxEVT_SCROLLWIN_BOTTOM )
+            // Just scroll too far and let Scroll() handle that
+            Scroll( -1 , GetScrollRange(wxVERTICAL) );
+        else if( e.GetEventType() == wxEVT_SCROLLWIN_TOP )
+            Scroll( -1 , 0 );
+        else if( e.GetEventType() == wxEVT_SCROLLWIN_LINEDOWN )
+            Scroll( -1 , oldPos + 1 );
+        else if( e.GetEventType() == wxEVT_SCROLLWIN_LINEUP )
+            Scroll( -1 , oldPos - 1 );
+        else if( e.GetEventType() == wxEVT_SCROLLWIN_THUMBRELEASE ||
+                 e.GetEventType() == wxEVT_SCROLLWIN_THUMBTRACK )
+            Scroll( -1 , e.GetPosition() );
+    }
+}   
+
 void wxGrid::SetSelectionMode(wxGrid::wxGridSelectionModes selmode)
 {
     wxCHECK_RET( m_created,
@@ -4407,8 +4811,12 @@
     m_extraWidth =
     m_extraHeight = 0;
 
-    m_scrollLineX = GRID_SCROLL_LINE_X;
-    m_scrollLineY = GRID_SCROLL_LINE_Y;
+    m_firstX=0;
+    m_firstY=0;
+    SetScrollLineX(GRID_SCROLL_LINE_X);
+    SetScrollLineY(GRID_SCROLL_LINE_Y);
+    EnableScrollbar(wxHORIZONTAL,true);
+    EnableScrollbar(wxVERTICAL,true);
 }
 
 // ----------------------------------------------------------------------------
@@ -4492,20 +4900,86 @@
                                   : m_rowBottoms[row];
 }
 
-void wxGrid::CalcDimensions()
+void wxGrid::SetScrollbar( int orientation, int position, int thumbSize, int range, bool refresh )
 {
-    int cw, ch;
-    GetClientSize( &cw, &ch );
+    m_scrollbarGeneratedSizeEvent=true;
+    wxWindow::SetScrollbar( orientation, position, thumbSize, range, refresh );
+    m_scrollbarGeneratedSizeEvent=false;
+}
+    
 
-    if ( m_rowLabelWin->IsShown() )
-        cw -= m_rowLabelWidth;
-    if ( m_colLabelWin->IsShown() )
-        ch -= m_colLabelHeight;
+void wxGrid::EnableScrollbar( int orientation , bool enable )
+{
+    switch( orientation )
+    {
+        case wxHORIZONTAL:
+            m_scrollbarXEnabled = enable;
+            break;
+        case wxVERTICAL:
+            m_scrollbarYEnabled = enable;
+            break;            
+        default:
+            wxLogError( _T( "wxGrid::EnableScrollbar(): Invalid scroll orientation" ) );    
+            return;
+    }
+    CalcDimensions();
+}
+
+bool wxGrid::ScrollbarEnabled( int orientation ) const
+{
+    switch( orientation )
+    {
+        case wxHORIZONTAL:
+            return m_scrollbarXEnabled;
+        case wxVERTICAL:
+            return m_scrollbarYEnabled;
+        default:
+            wxLogError( _T("wxGrid::ScrollbarEnabled(): Invalid scroll orientation"));    
+    }
+    return false;
+}
+    
+int wxGrid::GetScrollLine( int x ) const
+{
+    switch( x )
+    {
+        case WXGRID_SCROLL_DISABLED:            
+        case WXGRID_SCROLL_CELL:
+            break;
+        default:
+            if( x < 1 ) 
+                return WXGRID_SCROLL_INVALID_AMOUNT;
+    }
+    return x; 
+}
+
+int wxGrid::GetScrollLineX() const
+{
+    int x = GetScrollLine( m_scrollLineX );
+    wxASSERT_MSG( x != WXGRID_SCROLL_INVALID_AMOUNT,
+                 wxT("wxGrid::GetScrollLineX(): Invalid value for scroll amount") );    
+    return x;
+}
 
+int wxGrid::GetScrollLineY() const
+{
+    int y = GetScrollLine( m_scrollLineY );
+    wxASSERT_MSG( y != WXGRID_SCROLL_INVALID_AMOUNT,
+                 wxT("wxGrid::GetScrollLineY(): Invalid value for scroll amount") );    
+    return y;
+}
+
+void wxGrid::CalcDimensions()
+{
+
     // grid total size
     int w = m_numCols > 0 ? GetColRight(m_numCols - 1) + m_extraWidth + 1 : 0;
     int h = m_numRows > 0 ? GetRowBottom(m_numRows - 1) + m_extraHeight + 1 : 0;
 
+    // Where to scroll when adjusting scrollbars/scroll amount
+    // -1 means: don't even consider scrolling
+    int xpos = -1 , ypos = -1 ; 
+
     // take into account editor if shown
     if ( IsCellEditControlShown() )
     {
@@ -4528,25 +5002,101 @@
         editor->DecRef();
         attr->DecRef();
     }
+    
 
-    // preserve (more or less) the previous position
-    int x, y;
-    GetViewStart( &x, &y );
+    bool hasScrollbarX, hasScrollbarY;
+    do  // repeat this until scrollbars do not appear or disappear anymore
+    {
+        hasScrollbarX = ( GetScrollThumb( wxHORIZONTAL ) < GetScrollRange( wxHORIZONTAL ) );
+        hasScrollbarY = ( GetScrollThumb( wxVERTICAL ) < GetScrollRange( wxVERTICAL ) );
+    
+        // m_gridWin may not be resized at this point, use parent size
+        int gw, gh;
+        GetClientSize( &gw, &gh );    
+        if ( m_rowLabelWin->IsShown() )
+            gw -= m_rowLabelWidth;
+        if ( m_colLabelWin->IsShown() )
+            gh -= m_colLabelHeight;
+    
+        int pos , thumb , range;
+        if( w <= gw ) 
+        {
+            if( hasScrollbarX )
+                SetScrollbar( wxHORIZONTAL , 0 , 0 , 0 , false );
+            // the window is big enough, show first column if not already visible
+            if( GetWinLeft() )
+                xpos=0;
+        }
+        else if( m_scrollLineX == WXGRID_SCROLL_DISABLED )
+        {
+            if( hasScrollbarX )
+                SetScrollbar( wxHORIZONTAL , 0 , 0 , 0 , false );
+        }
+        else
+        {
+            if( m_scrollLineX == WXGRID_SCROLL_CELL )
+            {
+                // Make the thumb so wide that we can scroll exactly to the last row/col
+                thumb = m_numCols - FindPageLeft( m_numCols - 1 , true );
+                range = m_numCols;
+                pos = m_firstCol;
+            }
+            else
+            {
+                thumb = gw / GetScrollLineX() ;
+                range = GetScrollX( w );
+                pos = GetScrollX( m_firstX );
+            }
+            // if last cell is visible, scroll to show as much as possible
+            if( pos > range - thumb )
+                xpos = range - thumb;
+            if( ScrollbarEnabled( wxHORIZONTAL ) )
+                SetScrollbar( wxHORIZONTAL , pos , thumb , range , false );
+            else if( hasScrollbarX )
+                SetScrollbar( wxHORIZONTAL , 0 , 0 , 0 , false );
+        }
+    
+        if( h <= gh )
+        {
+            if( hasScrollbarY ) 
+                SetScrollbar( wxVERTICAL , 0 , 0 , 0 , false);
+            if( GetWinTop() )
+                ypos = 0;
+        }
+        else if( m_scrollLineY == WXGRID_SCROLL_DISABLED )
+        {
+            if( hasScrollbarY )
+                SetScrollbar( wxVERTICAL , 0 , 0 , 0 , false);
+        }
+        else
+        {            
+            if( m_scrollLineY == WXGRID_SCROLL_CELL )
+            {
+                thumb = m_numRows - FindPageUp( m_numRows - 1 , true );
+                range = m_numRows;
+                pos = m_firstRow;
+            }
+            else
+            {
+                thumb = gh / GetScrollLineY();
+                range = GetScrollY( h );
+                pos = GetScrollY( m_firstY );
+            }
+            if( pos > range - thumb )
+                ypos = range - thumb;
+            if( ScrollbarEnabled ( wxVERTICAL ) )
+                SetScrollbar( wxVERTICAL , pos , thumb , range , false );
+            else if( hasScrollbarY )
+                SetScrollbar( wxVERTICAL , 0 , 0 , 0 , false);
+        }
+    } while ( ( hasScrollbarX != ( GetScrollThumb( wxHORIZONTAL ) < GetScrollRange( wxHORIZONTAL ) ) ) ||
+              ( hasScrollbarY != ( GetScrollThumb( wxVERTICAL ) < GetScrollRange( wxVERTICAL ) ) ) );
+    
+    // Reposition the children
+    CalcWindowSizes();
 
-    // ensure the position is valid for the new scroll ranges
-    if ( x >= w )
-        x = wxMax( w - 1, 0 );
-    if ( y >= h )
-        y = wxMax( h - 1, 0 );
-
-    // do set scrollbar parameters
-    SetScrollbars( m_scrollLineX, m_scrollLineY,
-                   GetScrollX(w), GetScrollY(h), x, y,
-                   GetBatchCount() != 0);
+    Scroll( xpos , ypos );
 
-    // if our OnSize() hadn't been called (it would if we have scrollbars), we
-    // still must reposition the children
-    CalcWindowSizes();
 }
 
 void wxGrid::CalcWindowSizes()
@@ -4632,10 +5182,11 @@
 
             if ( m_currentCellCoords == wxGridNoCellCoords )
             {
-                // if we have just inserted cols into an empty grid the current
+                // if we have just inserted rows into an empty grid the current
                 // cell will be undefined...
                 //
                 SetCurrentCell( 0, 0 );
+                m_firstY = 0;
             }
 
             if ( m_selection )
@@ -4677,10 +5228,11 @@
 
             if ( m_currentCellCoords == wxGridNoCellCoords )
             {
-                // if we have just inserted cols into an empty grid the current
+                // if we have just inserted rows into an empty grid the current
                 // cell will be undefined...
                 //
                 SetCurrentCell( 0, 0 );
+                m_firstY = 0;
             }
 
             if ( !GetBatchCount() )
@@ -4777,6 +5329,7 @@
                 // cell will be undefined...
                 //
                 SetCurrentCell( 0, 0 );
+                m_firstX = 0;
             }
 
             if ( m_selection )
@@ -4820,6 +5373,7 @@
                 // cell will be undefined...
                 //
                 SetCurrentCell( 0, 0 );
+                m_firstX = 0;
             }
             if ( !GetBatchCount() )
             {
@@ -4921,9 +5475,8 @@
 
         // logical bounds of update region
         //
-        int dummy;
-        CalcUnscrolledPosition( 0, r.GetTop(), &dummy, &top );
-        CalcUnscrolledPosition( 0, r.GetBottom(), &dummy, &bottom );
+        top = r.GetTop() + GetWinTop();
+        bottom = top + r.GetHeight();
 
         // find the row labels within these bounds
         //
@@ -4972,9 +5525,8 @@
 
         // logical bounds of update region
         //
-        int dummy;
-        CalcUnscrolledPosition( r.GetLeft(), 0, &left, &dummy );
-        CalcUnscrolledPosition( r.GetRight(), 0, &right, &dummy );
+        left = r.GetLeft() + GetWinLeft();
+        right = left + r.GetWidth();
 
         // find the cells within these bounds
         //
@@ -5024,8 +5576,10 @@
 
         // logical bounds of update region
         //
-        CalcUnscrolledPosition( r.GetLeft(), r.GetTop(), &left, &top );
-        CalcUnscrolledPosition( r.GetRight(), r.GetBottom(), &right, &bottom );
+        left = r.GetLeft() + GetWinLeft();
+        right = left + r.GetWidth();
+        top = r.GetTop() + GetWinTop();
+        bottom = top + r.GetHeight();
 
         // find the cells within these bounds
         //
@@ -5077,9 +5631,9 @@
             {
                 case WXGRID_CURSOR_RESIZE_ROW:
                 {
-                    int cw, ch, left, dummy;
+                    int cw, ch, left;
                     m_gridWin->GetClientSize( &cw, &ch );
-                    CalcUnscrolledPosition( 0, 0, &left, &dummy );
+                    left = GetWinLeft();
 
                     wxClientDC dc( m_gridWin );
                     PrepareDC( dc );
@@ -5295,9 +5849,9 @@
             {
                 case WXGRID_CURSOR_RESIZE_COL:
                 {
-                    int cw, ch, dummy, top;
+                    int cw, ch, top;
                     m_gridWin->GetClientSize( &cw, &ch );
-                    CalcUnscrolledPosition( 0, 0, &dummy, &top );
+                    top = GetWinTop();
 
                     wxClientDC dc( m_gridWin );
                     PrepareDC( dc );
@@ -5689,9 +6243,9 @@
         }
         else if ( m_cursorMode == WXGRID_CURSOR_RESIZE_ROW )
         {
-            int cw, ch, left, dummy;
+            int cw, ch, left;
             m_gridWin->GetClientSize( &cw, &ch );
-            CalcUnscrolledPosition( 0, 0, &left, &dummy );
+            left = GetWinLeft();
 
             wxClientDC dc( m_gridWin );
             PrepareDC( dc );
@@ -5707,9 +6261,9 @@
         }
         else if ( m_cursorMode == WXGRID_CURSOR_RESIZE_COL )
         {
-            int cw, ch, dummy, top;
+            int cw, ch, top;
             m_gridWin->GetClientSize( &cw, &ch );
-            CalcUnscrolledPosition( 0, 0, &dummy, &top );
+            top = GetWinTop();
 
             wxClientDC dc( m_gridWin );
             PrepareDC( dc );
@@ -5985,9 +6539,9 @@
     {
         // erase the last line and resize the row
         //
-        int cw, ch, left, dummy;
+        int cw, ch, left;
         m_gridWin->GetClientSize( &cw, &ch );
-        CalcUnscrolledPosition( 0, 0, &left, &dummy );
+        left = GetWinLeft();
 
         wxClientDC dc( m_gridWin );
         PrepareDC( dc );
@@ -6005,7 +6559,7 @@
             // Only needed to get the correct rect.y:
             wxRect rect ( CellToRect( m_dragRowOrCol, 0 ) );
             rect.x = 0;
-            CalcScrolledPosition(0, rect.y, &dummy, &rect.y);
+            rect.y -= GetWinTop();
             rect.width = m_rowLabelWidth;
             rect.height = ch - rect.y;
             m_rowLabelWin->Refresh( true, &rect );
@@ -6025,8 +6579,7 @@
                         if (cell_rows < subtract_rows)
                             subtract_rows = cell_rows;
                     }
-                    rect.y = GetRowTop(m_dragRowOrCol + subtract_rows);
-                    CalcScrolledPosition(0, rect.y, &dummy, &rect.y);
+                    rect.y = GetRowTop( m_dragRowOrCol + subtract_rows ) - GetWinTop();
                     rect.height = ch - rect.y;
                 }
             }
@@ -6044,9 +6597,9 @@
     {
         // erase the last line and resize the col
         //
-        int cw, ch, dummy, top;
+        int cw, ch, top;
         m_gridWin->GetClientSize( &cw, &ch );
-        CalcUnscrolledPosition( 0, 0, &dummy, &top );
+        top = GetWinTop();
 
         wxClientDC dc( m_gridWin );
         PrepareDC( dc );
@@ -6065,7 +6618,7 @@
             // Only needed to get the correct rect.x:
             wxRect rect ( CellToRect( 0, m_dragRowOrCol ) );
             rect.y = 0;
-            CalcScrolledPosition(rect.x, 0, &rect.x, &dummy);
+            rect.x -= GetWinLeft();
             rect.width = cw - rect.x;
             rect.height = m_colLabelHeight;
             m_colLabelWin->Refresh( true, &rect );
@@ -6085,9 +6638,7 @@
                         if (cell_cols < subtract_cols)
                             subtract_cols = cell_cols;
                     }
-
-                    rect.x = GetColLeft(m_dragRowOrCol + subtract_cols);
-                    CalcScrolledPosition(rect.x, 0, &rect.x, &dummy);
+                    rect.x = GetColLeft(m_dragRowOrCol + subtract_cols) - GetWinLeft();
                     rect.width = cw - rect.x;
                 }
             }
@@ -6400,7 +6951,7 @@
     if (! GetBatchCount())
     {
         // Refresh to get correct scrolled position:
-        wxScrolledWindow::Refresh(eraseb, rect);
+        wxWindow::Refresh(eraseb, rect);
 
         if (rect)
         {
@@ -6484,11 +7035,9 @@
 
 void wxGrid::OnSize( wxSizeEvent& event )
 {
-    // position the child windows
-    CalcWindowSizes();
-
-    // don't call CalcDimensions() from here, the base class handles the size
-    // changes itself
+    // some platforms generate a size event when changing scrollbars - don't use that
+    if( m_scrollbarGeneratedSizeEvent ) return;
+    CalcDimensions();
     event.Skip();
 }
 
@@ -6549,15 +7098,9 @@
                 }
                 else
                 {
-                    if ( GetGridCursorRow() < GetNumberRows()-1 )
-                    {
-                        MoveCursorDown( event.ShiftDown() );
-                    }
-                    else
-                    {
+                    if ( !MoveCursorDown( event.ShiftDown() ) )
                         // at the bottom of a column
                         DisableCellEditControl();
-                    }
                 }
                 break;
 
@@ -6568,60 +7111,38 @@
             case WXK_TAB:
                 if (event.ShiftDown())
                 {
-                    if ( GetGridCursorCol() > 0 )
-                    {
-                        MoveCursorLeft( false );
-                    }
-                    else
-                    {
+                    if ( !MoveCursorLeft( false ) )
                         // at left of grid
                         DisableCellEditControl();
-                    }
                 }
                 else
                 {
-                    if ( GetGridCursorCol() < GetNumberCols() - 1 )
-                    {
-                        MoveCursorRight( false );
-                    }
-                    else
-                    {
+                    if ( !MoveCursorRight( false ) )
                         // at right of grid
                         DisableCellEditControl();
-                    }
                 }
                 break;
 
             case WXK_HOME:
                 if ( event.ControlDown() )
-                {
-                    MakeCellVisible( 0, 0 );
-                    SetCurrentCell( 0, 0 );
-                }
+                    MoveCursorToCell( 0, 0 , event.ShiftDown() );
                 else
-                {
                     event.Skip();
-                }
                 break;
 
             case WXK_END:
                 if ( event.ControlDown() )
-                {
-                    MakeCellVisible( m_numRows - 1, m_numCols - 1 );
-                    SetCurrentCell( m_numRows - 1, m_numCols - 1 );
-                }
+                    MoveCursorToCell( m_numRows-1, m_numCols-1 , event.ShiftDown() );
                 else
-                {
                     event.Skip();
-                }
                 break;
 
             case WXK_PAGEUP:
-                MovePageUp();
+                MovePageUp( event.ShiftDown() );
                 break;
 
             case WXK_PAGEDOWN:
-                MovePageDown();
+                MovePageDown( event.ShiftDown() );
                 break;
 
             case WXK_SPACE:
@@ -7228,7 +7749,7 @@
         return;
 
     dc.SetPen( wxPen(GetGridLineColour(), 1, wxSOLID) );
-
+    
     wxRect rect = CellToRect( row, col );
 
     // right hand border
@@ -7378,7 +7899,7 @@
     dc.SetClippingRegion( clippedcells );
 
     dc.SetPen( wxPen(GetGridLineColour(), 1, wxSOLID) );
-
+    
     // horizontal grid lines
     //
     // already declared above - int i;
@@ -7439,12 +7960,10 @@
 
 #ifdef __WXGTK20__
     rect.SetX( 1 );
-    rect.SetY( GetRowTop(row) + 1 );
+    rect.SetY( GetRowTop(row) - GetWinTop() + 1 );
     rect.SetWidth( m_rowLabelWidth - 2 );
     rect.SetHeight( GetRowHeight(row) - 2 );
 
-    CalcScrolledPosition( 0, rect.y, NULL, &rect.y );
-
     wxWindowDC *win_dc = (wxWindowDC*) &dc;
 
     wxRendererNative::Get().DrawHeaderButton( win_dc->m_owner, dc, rect, 0 );
@@ -7746,7 +8265,7 @@
 
 bool wxGrid::Enable(bool enable)
 {
-    if ( !wxScrolledWindow::Enable(enable) )
+    if ( !wxWindow::Enable(enable) )
         return false;
 
     // redraw in the new state
@@ -8129,13 +8648,13 @@
     return i_max;
 }
 
-int wxGrid::YToRow( int y )
+int wxGrid::YToRow( int y ) const
 {
     return CoordToRowOrCol(y, m_defaultRowHeight,
                            m_minAcceptableRowHeight, m_rowBottoms, m_numRows, false);
 }
 
-int wxGrid::XToCol( int x )
+int wxGrid::XToCol( int x ) const
 {
     return CoordToRowOrCol(x, m_defaultColWidth,
                            m_minAcceptableColWidth, m_colRights, m_numCols, false);
@@ -8144,7 +8663,7 @@
 // return the row number that that the y coord is near the edge of, or
 // -1 if not near an edge
 //
-int wxGrid::YToEdgeOfRow( int y )
+int wxGrid::YToEdgeOfRow( int y ) const
 {
     int i;
     i = internalYToRow(y);
@@ -8165,7 +8684,7 @@
 // return the col number that that the x coord is near the edge of, or
 // -1 if not near an edge
 //
-int wxGrid::XToEdgeOfCol( int x )
+int wxGrid::XToEdgeOfCol( int x ) const
 {
     int i;
     i = internalXToCol(x);
@@ -8220,310 +8739,239 @@
 
 bool wxGrid::IsVisible( int row, int col, bool wholeCellVisible )
 {
-    // get the cell rectangle in logical coords
-    //
-    wxRect r( CellToRect( row, col ) );
 
-    // convert to device coords
-    //
-    int left, top, right, bottom;
-    CalcScrolledPosition( r.GetLeft(), r.GetTop(), &left, &top );
-    CalcScrolledPosition( r.GetRight(), r.GetBottom(), &right, &bottom );
-
     // check against the client area of the grid window
     int cw, ch;
     m_gridWin->GetClientSize( &cw, &ch );
 
     if ( wholeCellVisible )
     {
-        // is the cell wholly visible ?
-        return ( left >= 0 && right <= cw &&
-                 top >= 0 && bottom <= ch );
+        if( GetColLeft( col ) < GetWinLeft() ) return false;
+        if( GetRowTop( row ) < GetWinTop() ) return false;
+        if( GetColRight( col ) > GetWinLeft() + cw ) return false;
+        if( GetRowBottom( row ) > GetWinTop() + ch ) return false;
     }
     else
     {
-        // is the cell partly visible ?
-        //
-        return ( ((left >= 0 && left < cw) || (right > 0 && right <= cw)) &&
-                 ((top >= 0 && top < ch) || (bottom > 0 && bottom <= ch)) );
+        if( GetColRight( col ) < GetWinLeft() ) return false;
+        if( GetRowBottom( row ) < GetWinTop() ) return false;
+        if( GetColLeft( col ) > GetWinLeft() + cw ) return false;
+        if( GetRowTop( row ) > GetWinTop() + ch ) return false;
     }
+    return true;
 }
 
 // make the specified cell location visible by doing a minimal amount
 // of scrolling
 //
-void wxGrid::MakeCellVisible( int row, int col )
+bool wxGrid::MakeCellVisible( int row, int col )
 {
-    int i;
+    if( col < 0 ) return false;
+    if( col >= m_numCols ) return false;
+    if( row < 0 ) return false;
+    if( row >= m_numRows ) return false;
+        
     int xpos = -1, ypos = -1;
+    int cw, ch;
+    m_gridWin->GetClientSize( &cw, &ch );
 
-    if ( row >= 0 && row < m_numRows &&
-         col >= 0 && col < m_numCols )
+    if( GetScrollLineX() == WXGRID_SCROLL_DISABLED ) 
     {
-        // get the cell rectangle in logical coords
-        wxRect r( CellToRect( row, col ) );
-
-        // convert to device coords
-        int left, top, right, bottom;
-        CalcScrolledPosition( r.GetLeft(), r.GetTop(), &left, &top );
-        CalcScrolledPosition( r.GetRight(), r.GetBottom(), &right, &bottom );
-
-        int cw, ch;
-        m_gridWin->GetClientSize( &cw, &ch );
-
-        if ( top < 0 )
-        {
-            ypos = r.GetTop();
-        }
-        else if ( bottom > ch )
-        {
-            int h = r.GetHeight();
-            ypos = r.GetTop();
-            for ( i = row - 1; i >= 0; i-- )
-            {
-                int rowHeight = GetRowHeight(i);
-                if ( h + rowHeight > ch )
-                    break;
-
-                h += rowHeight;
-                ypos -= rowHeight;
-            }
-
-            // we divide it later by GRID_SCROLL_LINE, make sure that we don't
-            // have rounding errors (this is important, because if we do,
-            // we might not scroll at all and some cells won't be redrawn)
-            //
-            // Sometimes GRID_SCROLL_LINE / 2 is not enough,
-            // so just add a full scroll unit...
-            ypos += m_scrollLineY;
-        }
-
-        // special handling for wide cells - show always left part of the cell!
-        // Otherwise, e.g. when stepping from row to row, it would jump between
-        // left and right part of the cell on every step!
-//      if ( left < 0 )
-        if ( left < 0 || (right - left) >= cw )
-        {
-            xpos = r.GetLeft();
-        }
-        else if ( right > cw )
+        if( GetColLeft( col ) < GetWinLeft() )
+            return false;
+        // we only accept a partially visible cell if it is wider than the window and exactly left aligned
+        if( GetColSize( col ) <= cw )
         {
-            // position the view so that the cell is on the right
-            int x0, y0;
-            CalcUnscrolledPosition(0, 0, &x0, &y0);
-            xpos = x0 + (right - cw);
-
-            // see comment for ypos above
-            xpos += m_scrollLineX;
+            if( GetColRight( col ) > GetWinLeft() + cw )
+                return false;
         }
+        else if( GetWinLeft() != GetColLeft( col ) )
+            return false;
+    }
+    else if( GetColLeft( col ) < GetWinLeft() || GetColSize( col ) >= cw )
+    {
+        if( GetScrollLineX() == WXGRID_SCROLL_CELL )
+            xpos = col;
+        else
+            xpos = GetColLeft( col ) / GetScrollLineX();
+    }
+    else if( GetColRight( col ) > GetWinLeft() + cw ) 
+    {
+        if( GetScrollLineX() == WXGRID_SCROLL_CELL )
+            xpos = FindPageLeft( col , true );
+        else 
+            xpos = GetScrollX( GetColRight( col ) - cw );
+    }
 
-        if ( xpos != -1 || ypos != -1 )
+    if( GetScrollLineY() == WXGRID_SCROLL_DISABLED ) 
+    {
+        if( GetRowTop( row ) < GetWinTop() )
+            return false;
+        if( GetRowSize( row ) <= ch )
         {
-            if ( xpos != -1 )
-                xpos /= m_scrollLineX;
-            if ( ypos != -1 )
-                ypos /= m_scrollLineY;
-            Scroll( xpos, ypos );
-            AdjustScrollbars();
+            if( GetRowBottom( row ) > GetWinTop() + ch )
+                return false;
         }
+        else if( GetWinTop() != GetRowTop( row ) )
+            return false;
+    }
+    else if( GetRowTop( row ) < GetWinTop() || GetRowSize( row ) > ch )
+    {
+        if( GetScrollLineY() == WXGRID_SCROLL_CELL )
+            ypos = row;
+        else
+            ypos = GetRowTop(row) / GetScrollLineY();
+    }
+    else if( GetRowBottom( row ) > GetWinTop() + ch ) 
+    {
+        if( GetScrollLineY() == WXGRID_SCROLL_CELL )
+            ypos = FindPageUp( row , true );
+        else 
+            ypos = GetScrollY( GetRowBottom( row ) - ch );
     }
+    
+    Scroll( xpos, ypos );
+    return true;
 }
 
 //
 // ------ Grid cursor movement functions
 //
-
-bool wxGrid::MoveCursorUp( bool expandSelection )
+bool wxGrid::MoveCursorToCell( int row, int col , bool expandSelection )
 {
-    if ( m_currentCellCoords != wxGridNoCellCoords &&
-         m_currentCellCoords.GetRow() >= 0 )
+    if ( MakeCellVisible( row , col ) )
     {
         if ( expandSelection )
         {
-            if ( m_selectingKeyboard == wxGridNoCellCoords )
-                m_selectingKeyboard = m_currentCellCoords;
-            if ( m_selectingKeyboard.GetRow() > 0 )
-            {
-                m_selectingKeyboard.SetRow( m_selectingKeyboard.GetRow() - 1 );
-                MakeCellVisible( m_selectingKeyboard.GetRow(),
-                                 m_selectingKeyboard.GetCol() );
-                HighlightBlock( m_currentCellCoords, m_selectingKeyboard );
-            }
+        if ( m_selectingKeyboard == wxGridNoCellCoords )
+            m_selectingKeyboard = m_currentCellCoords;
+        SetCurrentCell( row , col );
+        // current cell coordinates may have been invalid before selecting new cell...
+        if ( m_selectingKeyboard != wxGridNoCellCoords )
+            HighlightBlock( m_currentCellCoords, m_selectingKeyboard );
         }
-        else if ( m_currentCellCoords.GetRow() > 0 )
+        else
         {
-            int row = m_currentCellCoords.GetRow() - 1;
-            int col = m_currentCellCoords.GetCol();
             ClearSelection();
-            MakeCellVisible( row, col );
-            SetCurrentCell( row, col );
+            SetCurrentCell( row , col );
         }
-        else
-            return false;
-
         return true;
     }
-
     return false;
 }
 
-bool wxGrid::MoveCursorDown( bool expandSelection )
+bool wxGrid::MoveCursorUp( bool expandSelection )
 {
-    if ( m_currentCellCoords != wxGridNoCellCoords &&
-         m_currentCellCoords.GetRow() < m_numRows )
-    {
-        if ( expandSelection )
-        {
-            if ( m_selectingKeyboard == wxGridNoCellCoords )
-                m_selectingKeyboard = m_currentCellCoords;
-            if ( m_selectingKeyboard.GetRow() < m_numRows - 1 )
-            {
-                m_selectingKeyboard.SetRow( m_selectingKeyboard.GetRow() + 1 );
-                MakeCellVisible( m_selectingKeyboard.GetRow(),
-                        m_selectingKeyboard.GetCol() );
-                HighlightBlock( m_currentCellCoords, m_selectingKeyboard );
-            }
-        }
-        else if ( m_currentCellCoords.GetRow() < m_numRows - 1 )
-        {
-            int row = m_currentCellCoords.GetRow() + 1;
-            int col = m_currentCellCoords.GetCol();
-            ClearSelection();
-            MakeCellVisible( row, col );
-            SetCurrentCell( row, col );
-        }
-        else
-            return false;
+    return MoveCursorToCell( m_currentCellCoords.GetRow() - 1,
+                             m_currentCellCoords.GetCol() ,
+                             expandSelection );
+}
 
-        return true;
-    }
 
-    return false;
+bool wxGrid::MoveCursorDown( bool expandSelection )
+{
+    return MoveCursorToCell( m_currentCellCoords.GetRow() + 1,
+                             m_currentCellCoords.GetCol() ,
+                             expandSelection );
 }
 
 bool wxGrid::MoveCursorLeft( bool expandSelection )
 {
-    if ( m_currentCellCoords != wxGridNoCellCoords &&
-         m_currentCellCoords.GetCol() >= 0 )
-    {
-        if ( expandSelection )
-        {
-            if ( m_selectingKeyboard == wxGridNoCellCoords )
-                m_selectingKeyboard = m_currentCellCoords;
-            if ( m_selectingKeyboard.GetCol() > 0 )
-            {
-                m_selectingKeyboard.SetCol( m_selectingKeyboard.GetCol() - 1 );
-                MakeCellVisible( m_selectingKeyboard.GetRow(),
-                        m_selectingKeyboard.GetCol() );
-                HighlightBlock( m_currentCellCoords, m_selectingKeyboard );
-            }
-        }
-        else if ( m_currentCellCoords.GetCol() > 0 )
-        {
-            int row = m_currentCellCoords.GetRow();
-            int col = m_currentCellCoords.GetCol() - 1;
-            ClearSelection();
-            MakeCellVisible( row, col );
-            SetCurrentCell( row, col );
-        }
-        else
-            return false;
-
-        return true;
-    }
-
-    return false;
+    return MoveCursorToCell( m_currentCellCoords.GetRow() ,
+                             m_currentCellCoords.GetCol() -1 ,
+                             expandSelection );
 }
 
 bool wxGrid::MoveCursorRight( bool expandSelection )
 {
-    if ( m_currentCellCoords != wxGridNoCellCoords &&
-         m_currentCellCoords.GetCol() < m_numCols )
-    {
-        if ( expandSelection )
-        {
-            if ( m_selectingKeyboard == wxGridNoCellCoords )
-                m_selectingKeyboard = m_currentCellCoords;
-            if ( m_selectingKeyboard.GetCol() < m_numCols - 1 )
-            {
-                m_selectingKeyboard.SetCol( m_selectingKeyboard.GetCol() + 1 );
-                MakeCellVisible( m_selectingKeyboard.GetRow(),
-                        m_selectingKeyboard.GetCol() );
-                HighlightBlock( m_currentCellCoords, m_selectingKeyboard );
-            }
-        }
-        else if ( m_currentCellCoords.GetCol() < m_numCols - 1 )
-        {
-            int row = m_currentCellCoords.GetRow();
-            int col = m_currentCellCoords.GetCol() + 1;
-            ClearSelection();
-            MakeCellVisible( row, col );
-            SetCurrentCell( row, col );
-        }
-        else
-            return false;
-
-        return true;
-    }
-
-    return false;
+    return MoveCursorToCell( m_currentCellCoords.GetRow() ,
+                             m_currentCellCoords.GetCol() + 1 ,
+                             expandSelection );
 }
 
-bool wxGrid::MovePageUp()
+bool wxGrid::MovePageUp( bool expandSelection )
 {
     if ( m_currentCellCoords == wxGridNoCellCoords )
         return false;
 
     int row = m_currentCellCoords.GetRow();
-    if ( row > 0 )
+    if( row == 0 ) return false;
+    int newRow;
+    if ( GetScrollLineY() == WXGRID_SCROLL_CELL )
+    {
+        // if current row is fully visible below the top row visible, just jump up there
+        if( row > m_firstRow && IsVisible( row, m_firstCol, true) )
+            newRow = m_firstRow;
+        else
+            newRow = FindPageUp(row);
+    }
+    else
     {
-        int cw, ch;
-        m_gridWin->GetClientSize( &cw, &ch );
-
-        int y = GetRowTop(row);
-        int newRow = internalYToRow( y - ch + 1 );
-
-        if ( newRow == row )
-        {
-            // row > 0, so newRow can never be less than 0 here.
-            newRow = row - 1;
-        }
-
-        MakeCellVisible( newRow, m_currentCellCoords.GetCol() );
-        SetCurrentCell( newRow, m_currentCellCoords.GetCol() );
-
+        int ch = m_gridWin->GetClientSize().GetHeight();
+        int y = GetRowBottom( row ) - ch;
+        newRow = YToRow( y );
+        if( newRow == wxNOT_FOUND )
+            newRow = 0;
+        else if( newRow == row ) // row may be so high that we did not find a new one
+            --newRow;
+    }
+    if ( newRow == row ) 
+        return false;
+    if( MoveCursorToCell( newRow ,  m_currentCellCoords.GetCol() , expandSelection) )
         return true;
+    else
+    {
+        bool result = false;
+        // we consider it OK if we can move up just one row
+        BeginBatch();
+        while( MoveCursorUp( expandSelection ) ) 
+            result = true;
+        EndBatch();
+        return result;
     }
-
-    return false;
 }
 
-bool wxGrid::MovePageDown()
+bool wxGrid::MovePageDown( bool expandSelection )
 {
     if ( m_currentCellCoords == wxGridNoCellCoords )
         return false;
 
     int row = m_currentCellCoords.GetRow();
-    if ( (row + 1) < m_numRows )
-    {
-        int cw, ch;
-        m_gridWin->GetClientSize( &cw, &ch );
-
-        int y = GetRowTop(row);
-        int newRow = internalYToRow( y + ch );
-        if ( newRow == row )
-        {
-            // row < m_numRows, so newRow can't overflow here.
-            newRow = row + 1;
-        }
-
-        MakeCellVisible( newRow, m_currentCellCoords.GetCol() );
-        SetCurrentCell( newRow, m_currentCellCoords.GetCol() );
-
+    if( row == m_numRows - 1 ) return false;
+   
+    int newRow;
+    if( GetScrollLineY() == WXGRID_SCROLL_CELL )
+    {
+        int bottomRow = FindPageDown( m_firstRow , true );
+        if( row < bottomRow && row >= m_firstRow )
+            newRow = bottomRow;
+        else 
+            newRow = FindPageDown( row );
+    }    
+    else
+    {
+        int ch = m_gridWin->GetClientSize().GetHeight();
+        int y = GetRowTop( row ) + ch;
+        newRow = YToRow( y );
+        if( newRow == wxNOT_FOUND )
+            newRow = m_numRows - 1;
+        else if( newRow == row )
+            ++newRow;
+    }
+    if ( newRow == row ) 
+        return false;
+    if( MoveCursorToCell( newRow ,  m_currentCellCoords.GetCol() , expandSelection ) )
         return true;
+    else
+    {
+        bool result = false;
+        // we consider it OK if we can move down just one row
+        BeginBatch();
+        while( MoveCursorDown( expandSelection ) ) 
+            result = true;
+        EndBatch();
+        return result;
     }
-
-    return false;
 }
 
 bool wxGrid::MoveCursorUpBlock( bool expandSelection )
@@ -8574,21 +9022,21 @@
             }
         }
 
-        MakeCellVisible( row, col );
-        if ( expandSelection )
-        {
-            m_selectingKeyboard = wxGridCellCoords( row, col );
-            HighlightBlock( m_currentCellCoords, m_selectingKeyboard );
-        }
+        if ( row == m_currentCellCoords.GetRow() ) 
+            return false;
+        if( MoveCursorToCell( row ,  m_currentCellCoords.GetCol() , expandSelection ) )
+            return true;
         else
         {
-            ClearSelection();
-            SetCurrentCell( row, col );
+            bool result = false;
+            // we consider it OK if we can move up just one row
+            BeginBatch();
+            while( MoveCursorUp( expandSelection ) ) 
+                result = true;
+            EndBatch();
+            return result;
         }
-
-        return true;
     }
-
     return false;
 }
 
@@ -8640,21 +9088,21 @@
             }
         }
 
-        MakeCellVisible( row, col );
-        if ( expandSelection )
-        {
-            m_selectingKeyboard = wxGridCellCoords( row, col );
-            HighlightBlock( m_currentCellCoords, m_selectingKeyboard );
-        }
+        if ( row == m_currentCellCoords.GetRow() ) 
+            return false;
+        if( MoveCursorToCell( row ,  m_currentCellCoords.GetCol() , expandSelection ) )
+            return true;
         else
         {
-            ClearSelection();
-            SetCurrentCell( row, col );
+            bool result = false;
+            // we consider it OK if we can move down just one row
+            BeginBatch();
+            while( MoveCursorDown( expandSelection ) ) 
+                result = true;
+            EndBatch();
+            return result;
         }
-
-        return true;
     }
-
     return false;
 }
 
@@ -8706,21 +9154,21 @@
             }
         }
 
-        MakeCellVisible( row, col );
-        if ( expandSelection )
-        {
-            m_selectingKeyboard = wxGridCellCoords( row, col );
-            HighlightBlock( m_currentCellCoords, m_selectingKeyboard );
-        }
+        if ( col == m_currentCellCoords.GetCol() ) 
+            return false;
+        if( MoveCursorToCell( m_currentCellCoords.GetRow() , col , expandSelection ) )
+            return true;
         else
         {
-            ClearSelection();
-            SetCurrentCell( row, col );
+            bool result = false;
+            // we consider it OK if we can move up just one row
+            BeginBatch();
+            while( MoveCursorLeft( expandSelection ) ) 
+                result = true;
+            EndBatch();
+            return result;
         }
-
-        return true;
     }
-
     return false;
 }
 
@@ -8772,21 +9220,21 @@
             }
         }
 
-        MakeCellVisible( row, col );
-        if ( expandSelection )
-        {
-            m_selectingKeyboard = wxGridCellCoords( row, col );
-            HighlightBlock( m_currentCellCoords, m_selectingKeyboard );
-        }
+        if ( col == m_currentCellCoords.GetCol() ) 
+            return false;
+        if( MoveCursorToCell( m_currentCellCoords.GetRow() , col , expandSelection ) )
+            return true;
         else
         {
-            ClearSelection();
-            SetCurrentCell( row, col );
+            bool result = false;
+            // we consider it OK if we can move down just one row
+            BeginBatch();
+            while( MoveCursorRight( expandSelection ) ) 
+                result = true;
+            EndBatch();
+            return result;
         }
-
-        return true;
     }
-
     return false;
 }
 
@@ -8862,7 +9310,7 @@
 
         m_rowLabelWidth = width;
         CalcWindowSizes();
-        wxScrolledWindow::Refresh( true );
+        wxWindow::Refresh( true );
     }
 }
 
@@ -8885,7 +9333,7 @@
 
         m_colLabelHeight = height;
         CalcWindowSizes();
-        wxScrolledWindow::Refresh( true );
+        wxWindow::Refresh( true );
     }
 }
 
@@ -9134,24 +9582,24 @@
     }
 }
 
-int wxGrid::GetDefaultRowSize()
+int wxGrid::GetDefaultRowSize() const
 {
     return m_defaultRowHeight;
 }
 
-int wxGrid::GetRowSize( int row )
+int wxGrid::GetRowSize( int row ) const
 {
     wxCHECK_MSG( row >= 0 && row < m_numRows, 0, _T("invalid row index") );
 
     return GetRowHeight(row);
 }
 
-int wxGrid::GetDefaultColSize()
+int wxGrid::GetDefaultColSize() const
 {
     return m_defaultColWidth;
 }
 
-int wxGrid::GetColSize( int col )
+int wxGrid::GetColSize( int col ) const
 {
     wxCHECK_MSG( col >= 0 && col < m_numCols, 0, _T("invalid column index") );
 
@@ -10072,74 +10520,8 @@
 
 void wxGrid::AutoSize()
 {
-    BeginBatch();
-
-    wxSize size(SetOrCalcColumnSizes(false), SetOrCalcRowSizes(false));
-
-    // round up the size to a multiple of scroll step - this ensures that we
-    // won't get the scrollbars if we're sized exactly to this width
-    // CalcDimension adds m_extraWidth + 1 etc. to calculate the necessary
-    // scrollbar steps
-    wxSize sizeFit(
-        GetScrollX(size.x + m_extraWidth + 1) * m_scrollLineX,
-        GetScrollY(size.y + m_extraHeight + 1) * m_scrollLineY );
-
-    // distribute the extra space between the columns/rows to avoid having
-    // extra white space
-
-    // Remove the extra m_extraWidth + 1 added above
-    wxCoord diff = sizeFit.x - size.x + (m_extraWidth + 1);
-    if ( diff && m_numCols )
-    {
-        // try to resize the columns uniformly
-        wxCoord diffPerCol = diff / m_numCols;
-        if ( diffPerCol )
-        {
-            for ( int col = 0; col < m_numCols; col++ )
-            {
-                SetColSize(col, GetColWidth(col) + diffPerCol);
-            }
-        }
-
-        // add remaining amount to the last columns
-        diff -= diffPerCol * m_numCols;
-        if ( diff )
-        {
-            for ( int col = m_numCols - 1; col >= m_numCols - diff; col-- )
-            {
-                SetColSize(col, GetColWidth(col) + 1);
-            }
-        }
-    }
-
-    // same for rows
-    diff = sizeFit.y - size.y - (m_extraHeight + 1);
-    if ( diff && m_numRows )
-    {
-        // try to resize the columns uniformly
-        wxCoord diffPerRow = diff / m_numRows;
-        if ( diffPerRow )
-        {
-            for ( int row = 0; row < m_numRows; row++ )
-            {
-                SetRowSize(row, GetRowHeight(row) + diffPerRow);
-            }
-        }
-
-        // add remaining amount to the last rows
-        diff -= diffPerRow * m_numRows;
-        if ( diff )
-        {
-            for ( int row = m_numRows - 1; row >= m_numRows - diff; row-- )
-            {
-                SetRowSize(row, GetRowHeight(row) + 1);
-            }
-        }
-    }
-
-    EndBatch();
-
-    SetClientSize(sizeFit);
+   wxSize size( SetOrCalcColumnSizes( false ), SetOrCalcRowSizes( false ) );
+   SetClientSize( size );
 }
 
 void wxGrid::AutoSizeRowLabelSize( int row )
@@ -10204,16 +10586,6 @@
         width = 100;
     if (!height)
         height = 80;
-
-    // Round up to a multiple the scroll rate
-    // NOTE: this still doesn't get rid of the scrollbars;
-    // is there any magic incantation for that?
-    int xpu, ypu;
-    GetScrollPixelsPerUnit(&xpu, &ypu);
-    if (xpu)
-        width  += 1 + xpu - (width  % xpu);
-    if (ypu)
-        height += 1 + ypu - (height % ypu);
 
     // limit to 1/4 of the screen size
     int maxwidth, maxheight;

 	  	 
