Index: src/common/graphcmn.cpp
===================================================================
--- src/common/graphcmn.cpp	(revision 63753)
+++ src/common/graphcmn.cpp	(working copy)
@@ -490,6 +490,100 @@
 }
 
 //-----------------------------------------------------------------------------
+// wxGraphicsGradientStops Methods
+//-----------------------------------------------------------------------------
+
+wxGraphicsGradientStops::wxGraphicsGradientStops()
+{
+    SetStartColour(wxNullColour);
+    SetEndColour(wxNullColour);
+}
+
+wxGraphicsGradientStops::wxGraphicsGradientStops(wxColour startCol, wxColour endCol)
+{
+    SetStartColour(startCol);
+    SetEndColour(endCol);
+}
+
+wxGraphicsGradientStops::~wxGraphicsGradientStops()
+{
+    m_stops.clear();
+}
+
+/* Add a stop in correct order. */
+void wxGraphicsGradientStops::Add(wxGraphicsGradientStop stop)
+{
+    wxGraphicsGradientStop                      pst = wxGraphicsGradientStop(stop.col, stop.pos);
+    wxVector<wxGraphicsGradientStop>::iterator  it;
+
+    /* Clamp positions to 0.0 .. 1.0 */
+    if (pst.pos < 0.0)
+        pst.pos = 0.0;
+    if (pst.pos > 1.0)
+        pst.pos = 1.0;
+
+    for (it=m_stops.begin(); it < m_stops.end(); it++)
+    {
+        if (it->pos > pst.pos)
+        {
+            m_stops.insert(it, pst);
+            return;
+        }
+    }
+
+    m_stops.push_back(pst);
+}
+
+/* Add a stop with given colour and position in correct order. */
+void wxGraphicsGradientStops::Add(wxColour col, float pos)
+{
+    wxGraphicsGradientStop  st = wxGraphicsGradientStop(col, pos);
+
+    Add(st);
+}
+
+/* Remove stop at given index */
+void wxGraphicsGradientStops::Remove(int ind)
+{
+    if ((ind >= 0) && (ind < GetCount()))
+    {
+        wxVector<wxGraphicsGradientStop>::iterator  it;
+
+        it = m_stops.begin();
+        it += ind;
+        m_stops.erase(it);
+    }
+}
+
+/* Gets stop at given index.
+    Returns false if index invalid */
+bool wxGraphicsGradientStops::Item(int ind, wxGraphicsGradientStop *pstop) const
+{
+    if ((ind >= 0) && (ind < GetCount()))
+    {
+        if (pstop != NULL)
+        {
+            *pstop = m_stops.at(ind);
+        }
+        return true;
+    }
+
+    return false;
+}
+
+/* Returns count of stops */
+int wxGraphicsGradientStops::GetCount() const
+{
+    return m_stops.size();
+}
+
+/* Clears all stops */
+void wxGraphicsGradientStops::Clear()
+{
+    m_stops.clear();
+}
+
+//-----------------------------------------------------------------------------
 // wxGraphicsContext Convenience Methods
 //-----------------------------------------------------------------------------
 
@@ -760,6 +854,13 @@
     return GetRenderer()->CreateLinearGradientBrush(x1,y1,x2,y2,c1,c2);
 }
 
+// sets the brush to a linear gradient, starting at (x1,y1) to (x2,y2) with colours set by gradient stops
+wxGraphicsBrush wxGraphicsContext::CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
+                                                   wxGraphicsGradientStops &gradientStops) const
+{
+    return GetRenderer()->CreateLinearGradientBrush(x1,y1,x2,y2, gradientStops);
+}
+
 // sets the brush to a radial gradient originating at (xo,yc) with color oColor and ends on a circle around (xc,yc)
 // with radius r and color cColor
 wxGraphicsBrush wxGraphicsContext::CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
@@ -768,6 +869,14 @@
     return GetRenderer()->CreateRadialGradientBrush(xo,yo,xc,yc,radius,oColor,cColor);
 }
 
+// sets the brush to a radial gradient originating at (xo,yc) and ending on a circle around (xc,yc)
+// with radius r and colours set by gradient stops
+wxGraphicsBrush wxGraphicsContext::CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
+                                                   wxGraphicsGradientStops &gradientStops) const
+{
+    return GetRenderer()->CreateRadialGradientBrush(xo,yo,xc,yc,radius, gradientStops);
+}
+
 // sets the font
 wxGraphicsFont wxGraphicsContext::CreateFont( const wxFont &font , const wxColour &col ) const
 {
Index: src/msw/graphics.cpp
===================================================================
--- src/msw/graphics.cpp	(revision 63753)
+++ src/msw/graphics.cpp	(working copy)
@@ -237,8 +237,12 @@
 
     void CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
         const wxColour&c1, const wxColour&c2 );
+    void CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
+        wxGraphicsGradientStops &gradientStops );
     void CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
         const wxColour &oColor, const wxColour &cColor );
+    void CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
+        wxGraphicsGradientStops &gradientStops );
     virtual Brush* GetGDIPlusBrush() { return m_brush; }
 
 protected:
@@ -613,26 +617,190 @@
 
 void wxGDIPlusBrushData::CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2, const wxColour&c1, const wxColour&c2)
 {
+    wxColour    col1;
+    wxColour    col2;
+
+    // NOTE: Test of colours against wxNullColour avoids errors when accessing wxNullColour for
+    //       the stops.  Substitute with a transparent colour
+    col1 = c1;
+    if (col1 == wxNullColour)
+        col1 = wxColour(0,0,0,0);
+    col2 = c2;
+    if (col2 == wxNullColour)
+        col2 = wxColour(0,0,0,0);
+
     m_brush = new LinearGradientBrush( PointF( x1,y1) , PointF( x2,y2),
-        Color( c1.Alpha(), c1.Red(),c1.Green() , c1.Blue() ),
-        Color( c2.Alpha(), c2.Red(),c2.Green() , c2.Blue() ));
+        Color( col1.Alpha(), col1.Red(), col1.Green(), col1.Blue() ),
+        Color( col2.Alpha(), col2.Red(), col2.Green(), col2.Blue() ));
 }
 
+void wxGDIPlusBrushData::CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2, wxGraphicsGradientStops &gradientStops)
+{
+    wxColour                c1;
+    wxColour                c2;
+    Color                   *stopCols;
+    REAL                    *stopPos;
+    int                     nstop;
+    wxGraphicsGradientStop  stop;
+    wxColour                scol;
+    REAL                    spos;
+    LinearGradientBrush     *b;
+
+    // NOTE: Test of colours against wxNullColour avoids errors when accessing wxNullColour for
+    //       the stops.  Substitute with a transparent colour
+    c1 = gradientStops.GetStartColour();
+    if (c1 == wxNullColour)
+        c1 = wxColour(0,0,0,0);
+    c2 = gradientStops.GetEndColour();
+    if (c2 == wxNullColour)
+        c2 = wxColour(0,0,0,0);
+
+    b = new LinearGradientBrush(PointF( x1,y1) , PointF( x2,y2),
+                                Color( c1.Alpha(), c1.Red(), c1.Green(), c1.Blue()),
+                                Color( c2.Alpha(), c2.Red(), c2.Green(), c2.Blue()));
+    m_brush =  b;
+
+    nstop = gradientStops.GetCount();
+
+    if (nstop > 0)
+    {
+        // NOTE: start and end colours have to be included in interpolation colours
+        stopCols = new Color[nstop+2];
+        stopPos = new REAL[nstop+2];
+
+        for (int i = 0; i < nstop + 2; i++)
+        {
+            if (i == 0)
+            {
+                scol = c1;
+                spos = 0.0f;
+            }
+            else
+            if (i == nstop + 1)
+            {
+                scol = c2;
+                spos = 1.0f;
+            }
+            else
+            {
+                gradientStops.Item(i-1, &stop);
+                scol = stop.col;
+                if (scol == wxNullColour)
+                    scol = wxColour(0,0,0,0);
+                spos = stop.pos;
+            }
+            stopCols[i] = Color( scol.Alpha(), scol.Red(), scol.Green(), scol.Blue());
+            stopPos[i] = spos;
+        }
+
+        b->SetInterpolationColors(stopCols, stopPos, nstop+2);
+
+        delete[] stopCols;
+        delete[] stopPos;
+    }
+}
+
 void wxGDIPlusBrushData::CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
                                                const wxColour &oColor, const wxColour &cColor)
 {
     // Create a path that consists of a single circle.
+    wxColour    col1;
+    wxColour    col2;
+
+    // NOTE: Test of colours against wxNullColour avoids errors when accessing wxNullColour for
+    //       the stops.  Substitute with a transparent colour
+    col1 = oColor;
+    if (col1 == wxNullColour)
+        col1 = wxColour(0,0,0,0);
+    col2 = cColor;
+    if (col2 == wxNullColour)
+        col2 = wxColour(0,0,0,0);
+
     m_brushPath = new GraphicsPath();
     m_brushPath->AddEllipse( (REAL)(xc-radius), (REAL)(yc-radius), (REAL)(2*radius), (REAL)(2*radius));
 
     PathGradientBrush *b = new PathGradientBrush(m_brushPath);
     m_brush = b;
     b->SetCenterPoint( PointF(xo,yo));
+    b->SetCenterColor(Color( col1.Alpha(), col1.Red(), col1.Green(), col1.Blue() ));
+
+    Color colors[] = {Color( col2.Alpha(), col2.Red(), col2.Green(), col2.Blue() )};
+    int count = 1;
+    b->SetSurroundColors(colors, &count);
+}
+void wxGDIPlusBrushData::CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
+                                               wxGraphicsGradientStops &gradientStops)
+{
+    // Create a path that consists of a single circle.
+
+    wxColour                oColor;
+    wxColour                cColor;
+    Color                   *stopCols;
+    REAL                    *stopPos;
+    int                     nstop;
+    wxGraphicsGradientStop  stop;
+    wxColour                scol;
+    REAL                    spos;
+
+    // NOTE: Test of colours against wxNullColour avoids errors when accessing wxNullColour for
+    //       the stops.  Substitute with a transparent colour
+    oColor = gradientStops.GetStartColour();
+    if (oColor == wxNullColour)
+        oColor = wxColour(0,0,0,0);
+    cColor = gradientStops.GetEndColour();
+    if (cColor == wxNullColour)
+        cColor = wxColour(0,0,0,0);
+
+    m_brushPath = new GraphicsPath();
+    m_brushPath->AddEllipse( (REAL)(xc-radius), (REAL)(yc-radius), (REAL)(2*radius), (REAL)(2*radius));
+
+    PathGradientBrush *b = new PathGradientBrush(m_brushPath);
+    m_brush = b;
+    b->SetCenterPoint( PointF(xo,yo));
     b->SetCenterColor(Color( oColor.Alpha(), oColor.Red(),oColor.Green() , oColor.Blue() ));
 
     Color colors[] = {Color( cColor.Alpha(), cColor.Red(),cColor.Green() , cColor.Blue() )};
     int count = 1;
     b->SetSurroundColors(colors, &count);
+
+    nstop = gradientStops.GetCount();
+
+    if (nstop > 0)
+    {
+        // NOTE: start and end colours have to be included in interpolation colours
+        stopCols = new Color[nstop+2];
+        stopPos = new REAL[nstop+2];
+
+        for (int i = 0; i < nstop+2; i++)
+        {
+            if (i == 0)
+            {
+                scol = oColor;
+                spos = 0.0f;
+            }
+            else
+            if (i == nstop+1)
+            {
+                scol = cColor;
+                spos = 1.0f;
+            }
+            else
+            {
+                gradientStops.Item(i-1, &stop);
+                scol = stop.col;
+                if (scol == wxNullColour)
+                    scol = wxColour(0,0,0,0);
+                spos = stop.pos;
+            }
+            stopCols[i] = Color( scol.Alpha(), scol.Red(), scol.Green(), scol.Blue());
+            stopPos[i] = spos;
+        }
+
+        b->SetInterpolationColors(stopCols, stopPos, nstop + 2);
+
+        delete[] stopCols;
+        delete[] stopPos;
+    }
 }
 
 //-----------------------------------------------------------------------------
@@ -1584,11 +1752,20 @@
     virtual wxGraphicsBrush CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
         const wxColour&c1, const wxColour&c2) ;
 
+    // sets the brush to a linear gradient, starting at (x1,y1) to (x2,y2) with colours set by gradient stops
+    virtual wxGraphicsBrush CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
+        wxGraphicsGradientStops &gradientStops ) ;
+
     // sets the brush to a radial gradient originating at (xo,yc) with color oColor and ends on a circle around (xc,yc)
     // with radius r and color cColor
     virtual wxGraphicsBrush CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
         const wxColour &oColor, const wxColour &cColor) ;
 
+    // sets the brush to a radial gradient originating at (xo,yc) and ending on a circle around (xc,yc)
+    // with radius r and colours set by gradient stops
+    virtual wxGraphicsBrush CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
+        wxGraphicsGradientStops &gradientStops) ;
+
     // sets the font
     virtual wxGraphicsFont CreateFont( const wxFont &font , const wxColour &col = *wxBLACK ) ;
 
@@ -1597,7 +1774,7 @@
 
     // create a graphics bitmap from a native bitmap
     virtual wxGraphicsBitmap CreateBitmapFromNativeBitmap( void* bitmap );
-    
+
     // create a subimage from a native image representation
     virtual wxGraphicsBitmap CreateSubBitmap( const wxGraphicsBitmap &bitmap, wxDouble x, wxDouble y, wxDouble w, wxDouble h  );
 
@@ -1785,6 +1962,18 @@
     return p;
  }
 
+// sets the brush to a linear gradient, starting at (x1,y1) to (x2,y2) with colours set by gradient stops
+wxGraphicsBrush wxGDIPlusRenderer::CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
+                                                                      wxGraphicsGradientStops &gradientStops)
+{
+    ENSURE_LOADED_OR_RETURN(wxNullGraphicsBrush);
+    wxGraphicsBrush p;
+    wxGDIPlusBrushData* d = new wxGDIPlusBrushData( this );
+    d->CreateLinearGradientBrush(x1, y1, x2, y2, gradientStops);
+    p.SetRefData(d);
+    return p;
+ }
+
 // sets the brush to a radial gradient originating at (xo,yc) with color oColor and ends on a circle around (xc,yc)
 // with radius r and color cColor
 wxGraphicsBrush wxGDIPlusRenderer::CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
@@ -1798,6 +1987,19 @@
     return p;
 }
 
+// sets the brush to a radial gradient originating at (xo,yc) and ending on a circle around (xc,yc)
+// with radius r and colours set by gradient stops
+wxGraphicsBrush wxGDIPlusRenderer::CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
+                                                                      wxGraphicsGradientStops &gradientStops)
+{
+    ENSURE_LOADED_OR_RETURN(wxNullGraphicsBrush);
+    wxGraphicsBrush p;
+    wxGDIPlusBrushData* d = new wxGDIPlusBrushData( this );
+    d->CreateRadialGradientBrush(xo,yo,xc,yc,radius,gradientStops);
+    p.SetRefData(d);
+    return p;
+}
+
 // sets the font
 wxGraphicsFont wxGDIPlusRenderer::CreateFont( const wxFont &font , const wxColour &col )
 {
Index: src/osx/carbon/graphics.cpp
===================================================================
--- src/osx/carbon/graphics.cpp	(revision 63753)
+++ src/osx/carbon/graphics.cpp	(working copy)
@@ -668,8 +668,12 @@
     virtual void Apply( wxGraphicsContext* context );
     void CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
         const wxColour&c1, const wxColour&c2 );
+    void CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
+        wxGraphicsGradientStops &gradientStops );
     void CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
-    const wxColour &oColor, const wxColour &cColor );
+        const wxColour &oColor, const wxColour &cColor );
+    void CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
+        wxGraphicsGradientStops &gradientStops );
 
     virtual bool IsShading() { return m_isShading; }
     CGShadingRef GetShading() { return m_shading; }
@@ -700,6 +704,23 @@
     m_isShading = true ;
 }
 
+void wxMacCoreGraphicsBrushData::CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
+        wxGraphicsGradientStops &gradientStops )
+{
+    // NOTE: gradient stops currently not implemented
+
+    wxColour    c1;
+    wxColour    c2;
+
+    c1 = gradientStops.GetStartColour();
+    c2 = gradientStops.GetEndColour();
+
+    m_gradientFunction = CreateGradientFunction( c1, c2 );
+    m_shading = CGShadingCreateAxial( wxMacGetGenericRGBColorSpace(), CGPointMake((CGFloat) x1, (CGFloat) y1),
+                                        CGPointMake((CGFloat) x2,(CGFloat) y2), m_gradientFunction, true, true ) ;
+    m_isShading = true ;
+}
+
 void wxMacCoreGraphicsBrushData::CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
     const wxColour &oColor, const wxColour &cColor )
 {
@@ -708,7 +729,23 @@
                                         CGPointMake((CGFloat) xc,(CGFloat) yc), (CGFloat) radius, m_gradientFunction, true, true ) ;
     m_isShading = true ;
 }
+void wxMacCoreGraphicsBrushData::CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
+    wxGraphicsGradientStops &gradientStops )
+{
+    // NOTE: gradient stops currently not implemented
 
+    wxColour    oColor;
+    wxColour    cColor;
+
+    oColor = gradientStops.GetStartColour();
+    cColor = gradientStops.GetEndColour();
+
+    m_gradientFunction = CreateGradientFunction( oColor, cColor );
+    m_shading = CGShadingCreateRadial( wxMacGetGenericRGBColorSpace(), CGPointMake((CGFloat) xo,(CGFloat) yo), 0,
+                                        CGPointMake((CGFloat) xc,(CGFloat) yc), (CGFloat) radius, m_gradientFunction, true, true ) ;
+    m_isShading = true ;
+}
+
 wxMacCoreGraphicsBrushData::wxMacCoreGraphicsBrushData(wxGraphicsRenderer* renderer, const wxBrush &brush) : wxGraphicsObjectRefData( renderer ),
     m_cgColor( brush )
 {
@@ -1138,7 +1175,7 @@
     // appends a rectangle as a new closed subpath
     virtual void AddRectangle( wxDouble x, wxDouble y, wxDouble w, wxDouble h );
 
-    // appends a circle as a new closed subpath 
+    // appends a circle as a new closed subpath
     virtual void AddCircle( wxDouble x, wxDouble y, wxDouble r );
 
     // appends an ellipsis as a new closed subpath fitting the passed rectangle
@@ -2622,11 +2659,20 @@
     virtual wxGraphicsBrush CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
         const wxColour&c1, const wxColour&c2) ;
 
+    // sets the brush to a linear gradient, starting at (x1,y1) to (x2,y2) with colours set by gradient stops
+    virtual wxGraphicsBrush CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
+        wxGraphicsGradientStops &gradientStops) ;
+
     // sets the brush to a radial gradient originating at (xo,yc) with color oColor and ends on a circle around (xc,yc)
     // with radius r and color cColor
     virtual wxGraphicsBrush CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
         const wxColour &oColor, const wxColour &cColor) ;
 
+    // sets the brush to a radial gradient originating at (xo,yc) and ending on a circle around (xc,yc)
+    // with radius r and colours set by gradient stops
+    virtual wxGraphicsBrush CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
+        wxGraphicsGradientStops &gradientStops) ;
+
    // sets the font
     virtual wxGraphicsFont CreateFont( const wxFont &font , const wxColour &col = *wxBLACK ) ;
 
@@ -2830,6 +2876,17 @@
     return p;
 }
 
+// sets the brush to a linear gradient, starting at (x1,y1) to (x2,y2) with colours set by gradient stops
+wxGraphicsBrush wxMacCoreGraphicsRenderer::CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
+    wxGraphicsGradientStops &gradientStops)
+{
+    wxGraphicsBrush p;
+    wxMacCoreGraphicsBrushData* d = new wxMacCoreGraphicsBrushData( this );
+    d->CreateLinearGradientBrush(x1, y1, x2, y2, gradientStops);
+    p.SetRefData(d);
+    return p;
+}
+
 // sets the brush to a radial gradient originating at (xo,yc) with color oColor and ends on a circle around (xc,yc)
 // with radius r and color cColor
 wxGraphicsBrush wxMacCoreGraphicsRenderer::CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
@@ -2842,6 +2899,18 @@
     return p;
 }
 
+// sets the brush to a radial gradient originating at (xo,yc) and ending on a circle around (xc,yc)
+// with radius r and colours set by gradient stops
+wxGraphicsBrush wxMacCoreGraphicsRenderer::CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
+    wxGraphicsGradientStops &gradientStops)
+{
+    wxGraphicsBrush p;
+    wxMacCoreGraphicsBrushData* d = new wxMacCoreGraphicsBrushData( this );
+    d->CreateRadialGradientBrush(xo,yo,xc,yc,radius,gradientStops);
+    p.SetRefData(d);
+    return p;
+}
+
 // sets the font
 wxGraphicsFont wxMacCoreGraphicsRenderer::CreateFont( const wxFont &font , const wxColour &col )
 {
Index: src/generic/graphicc.cpp
===================================================================
--- src/generic/graphicc.cpp	(revision 63753)
+++ src/generic/graphicc.cpp	(working copy)
@@ -249,9 +249,13 @@
 
     virtual void Apply( wxGraphicsContext* context );
     void CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
-        const wxColour&c1, const wxColour&c2 );
+        const wxColour&c1, const wxColour&c2);
+    void CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
+        wxGraphicsGradientStops &gradientStops);
     void CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
-        const wxColour &oColor, const wxColour &cColor );
+        const wxColour &oColor, const wxColour &cColor);
+    void CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
+        wxGraphicsGradientStops &gradientStops);
 
 protected:
     virtual void Init();
@@ -684,27 +688,131 @@
 }
 
 void wxCairoBrushData::CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
-        const wxColour&c1, const wxColour&c2 )
+        const wxColour&c1, const wxColour&c2)
 {
+    wxColour                col;
+
     m_brushPattern = cairo_pattern_create_linear(x1,y1,x2,y2);
-    cairo_pattern_add_color_stop_rgba(m_brushPattern,0.0,c1.Red()/255.0,
-        c1.Green()/255.0, c1.Blue()/255.0,c1.Alpha()/255.0);
-    cairo_pattern_add_color_stop_rgba(m_brushPattern,1.0,c2.Red()/255.0,
-        c2.Green()/255.0, c2.Blue()/255.0,c2.Alpha()/255.0);
+
+    // NOTE: Test of colours against wxNullColour avoids errors when accessing wxNullColour for
+    //       the stops.  Substitute with a transparent colour
+    col = c1;
+    if (col == wxNullColour)
+        col = wxColour(0,0,0,0);
+    cairo_pattern_add_color_stop_rgba(m_brushPattern,0.0,col.Red()/255.0,
+        col.Green()/255.0, col.Blue()/255.0,col.Alpha()/255.0);
+
+    col = c2;
+    if (col == wxNullColour)
+        col = wxColour(0,0,0,0);
+    cairo_pattern_add_color_stop_rgba(m_brushPattern,1.0,col.Red()/255.0,
+        col.Green()/255.0, col.Blue()/255.0,col.Alpha()/255.0);
     wxASSERT_MSG(cairo_pattern_status(m_brushPattern) == CAIRO_STATUS_SUCCESS, wxT("Couldn't create cairo pattern"));
 }
 
+void wxCairoBrushData::CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
+        wxGraphicsGradientStops &gradientStops )
+{
+    int                     ss;
+    wxColour                col;
+    wxGraphicsGradientStop  stp;
+
+    m_brushPattern = cairo_pattern_create_linear(x1,y1,x2,y2);
+
+    // NOTE: Test of colours against wxNullColour avoids errors when accessing wxNullColour for
+    //       the stops.  Substitute with a transparent colour
+    col = gradientStops.GetStartColour();
+    if (col == wxNullColour)
+        col = wxColour(0,0,0,0);
+    cairo_pattern_add_color_stop_rgba(m_brushPattern,0.0,col.Red()/255.0,
+        col.Green()/255.0, col.Blue()/255.0,col.Alpha()/255.0);
+
+    if (gradientStops.GetCount() > 0)
+    {
+        for (ss = 0; ss < gradientStops.GetCount(); ss++)
+        {
+            gradientStops.Item(ss, &stp);
+            col = stp.col;
+            if (col == wxNullColour)
+                col = wxColour(0,0,0,0);
+            cairo_pattern_add_color_stop_rgba(m_brushPattern, stp.pos,
+                                    col.Red()/255.0, col.Green()/255.0,
+                                    col.Blue()/255.0,col.Alpha()/255.0);
+        }
+    }
+
+    col = gradientStops.GetEndColour();
+    if (col == wxNullColour)
+        col = wxColour(0,0,0,0);
+    cairo_pattern_add_color_stop_rgba(m_brushPattern,1.0,col.Red()/255.0,
+        col.Green()/255.0, col.Blue()/255.0,col.Alpha()/255.0);
+    wxASSERT_MSG(cairo_pattern_status(m_brushPattern) == CAIRO_STATUS_SUCCESS, wxT("Couldn't create cairo pattern"));
+}
+
 void wxCairoBrushData::CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
-        const wxColour &oColor, const wxColour &cColor )
+        const wxColour &oColor, const wxColour &cColor)
 {
+    wxColour    col;
+
     m_brushPattern = cairo_pattern_create_radial(xo,yo,0.0,xc,yc,radius);
-    cairo_pattern_add_color_stop_rgba(m_brushPattern,0.0,oColor.Red()/255.0,
-        oColor.Green()/255.0, oColor.Blue()/255.0,oColor.Alpha()/255.0);
-    cairo_pattern_add_color_stop_rgba(m_brushPattern,1.0,cColor.Red()/255.0,
-        cColor.Green()/255.0, cColor.Blue()/255.0,cColor.Alpha()/255.0);
+
+    // NOTE: Test of colours against wxNullColour avoids errors when accessing wxNullColour for
+    //       the stops.  Substitute with a transparent colour
+    col = oColor;
+    if (col == wxNullColour)
+        col = wxColour(0,0,0,0);
+    cairo_pattern_add_color_stop_rgba(m_brushPattern,0.0,col.Red()/255.0,
+        col.Green()/255.0, col.Blue()/255.0,col.Alpha()/255.0);
+
+    col = cColor;
+    if (col == wxNullColour)
+        col = wxColour(0,0,0,0);
+    cairo_pattern_add_color_stop_rgba(m_brushPattern,1.0,col.Red()/255.0,
+        col.Green()/255.0, col.Blue()/255.0,col.Alpha()/255.0);
+
     wxASSERT_MSG(cairo_pattern_status(m_brushPattern) == CAIRO_STATUS_SUCCESS, wxT("Couldn't create cairo pattern"));
 }
 
+void wxCairoBrushData::CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
+        wxGraphicsGradientStops &gradientStops )
+{
+    int                     ss;
+    wxColour                col;
+    wxGraphicsGradientStop  stp;
+
+    m_brushPattern = cairo_pattern_create_radial(xo,yo,0.0,xc,yc,radius);
+
+    // NOTE: Test of colours against wxNullColour avoids errors when accessing wxNullColour for
+    //       the stops.  Substitute with a transparent colour
+    col = gradientStops.GetStartColour();
+    if (col == wxNullColour)
+        col = wxColour(0,0,0,0);
+    cairo_pattern_add_color_stop_rgba(m_brushPattern,0.0,col.Red()/255.0,
+        col.Green()/255.0, col.Blue()/255.0,col.Alpha()/255.0);
+
+    if (gradientStops.GetCount() > 0)
+    {
+        for (ss = 0; ss < gradientStops.GetCount(); ss++)
+        {
+            gradientStops.Item(ss, &stp);
+            col = stp.col;
+            if (col == wxNullColour)
+                col = wxColour(0,0,0,0);
+            cairo_pattern_add_color_stop_rgba(m_brushPattern, stp.pos,
+                                    col.Red()/255.0, col.Green()/255.0,
+                                    col.Blue()/255.0,col.Alpha()/255.0);
+        }
+    }
+
+    col = gradientStops.GetEndColour();
+    if (col == wxNullColour)
+        col = wxColour(0,0,0,0);
+    cairo_pattern_add_color_stop_rgba(m_brushPattern,1.0,col.Red()/255.0,
+        col.Green()/255.0, col.Blue()/255.0,col.Alpha()/255.0);
+
+    wxASSERT_MSG(cairo_pattern_status(m_brushPattern) == CAIRO_STATUS_SUCCESS, wxT("Couldn't create cairo pattern"));
+}
+
 void wxCairoBrushData::Init()
 {
     m_brushPattern = NULL;
@@ -1113,10 +1221,10 @@
 {
     if (m_pattern)
         cairo_pattern_destroy(m_pattern);
-    
+
     if (m_surface)
         cairo_surface_destroy(m_surface);
-    
+
     delete [] m_buffer;
 }
 
@@ -1739,11 +1847,20 @@
     virtual wxGraphicsBrush CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
         const wxColour&c1, const wxColour&c2) ;
 
+    // sets the brush to a linear gradient, starting at (x1,y1) to (x2,y2) with colours set by gradient stops
+    virtual wxGraphicsBrush CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
+        wxGraphicsGradientStops &gradientStops) ;
+
     // sets the brush to a radial gradient originating at (xo,yc) with color oColor and ends on a circle around (xc,yc)
     // with radius r and color cColor
     virtual wxGraphicsBrush CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
         const wxColour &oColor, const wxColour &cColor) ;
 
+    // sets the brush to a radial gradient originating at (xo,yc) and ending on a circle around (xc,yc)
+    // with radius r and colours set by gradient stops
+    virtual wxGraphicsBrush CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
+        wxGraphicsGradientStops &gradientStops) ;
+
     // sets the font
     virtual wxGraphicsFont CreateFont( const wxFont &font , const wxColour &col = *wxBLACK ) ;
 
@@ -1885,6 +2002,17 @@
     return p;
 }
 
+// sets the brush to a linear gradient, starting at (x1,y1) to (x2,y2) with colours set by gradient stops
+wxGraphicsBrush wxCairoRenderer::CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
+                                                                      wxGraphicsGradientStops &gradientStops)
+{
+    wxGraphicsBrush p;
+    wxCairoBrushData* d = new wxCairoBrushData( this );
+    d->CreateLinearGradientBrush(x1, y1, x2, y2, gradientStops);
+    p.SetRefData(d);
+    return p;
+}
+
 // sets the brush to a radial gradient originating at (xo,yc) with color oColor and ends on a circle around (xc,yc)
 // with radius r and color cColor
 wxGraphicsBrush wxCairoRenderer::CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
@@ -1897,6 +2025,18 @@
     return p;
 }
 
+// sets the brush to a radial gradient originating at (xo,yc) and ending on a circle around (xc,yc)
+// with radius r and colours set by gradient stops
+wxGraphicsBrush wxCairoRenderer::CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
+                                                                      wxGraphicsGradientStops &gradientStops)
+{
+    wxGraphicsBrush p;
+    wxCairoBrushData* d = new wxCairoBrushData( this );
+    d->CreateRadialGradientBrush(xo,yo,xc,yc,radius, gradientStops);
+    p.SetRefData(d);
+    return p;
+}
+
 // sets the font
 wxGraphicsFont wxCairoRenderer::CreateFont( const wxFont &font , const wxColour &col )
 {
Index: include/wx/graphics.h
===================================================================
--- include/wx/graphics.h	(revision 63753)
+++ include/wx/graphics.h	(working copy)
@@ -19,6 +19,7 @@
 #include "wx/geometry.h"
 #include "wx/dynarray.h"
 #include "wx/dc.h"
+#include "wx/vector.h"
 
 enum wxAntialiasMode
 {
@@ -303,7 +304,53 @@
 
 extern WXDLLIMPEXP_DATA_CORE(wxGraphicsPath) wxNullGraphicsPath;
 
+struct wxGraphicsGradientStop
+{
+    wxGraphicsGradientStop() { col = wxNullColour; pos = 0.0; }
+    wxGraphicsGradientStop(wxColour c, float p) { col = c; pos = p; }
 
+    wxColour   col;
+    float      pos;
+};
+
+class WXDLLIMPEXP_CORE wxGraphicsGradientStops
+{
+public:
+    wxGraphicsGradientStops();
+    wxGraphicsGradientStops(wxColour startCol, wxColour endCol);
+    ~wxGraphicsGradientStops();
+
+    /* Add a stop in correct order. */
+    void Add(wxGraphicsGradientStop stop);
+
+    /* Add a stop with given colour and position in correct order. */
+    void Add(wxColour col, float pos);
+
+    /* Remove stop at given index */
+    void Remove(int ind);
+
+    /* Gets stop at given index.
+        Returns false if index invalid */
+    bool Item(int ind, wxGraphicsGradientStop *pstop) const;
+
+    /* Returns count of stops */
+    int GetCount() const;
+
+    /* Clears all stops */
+    void Clear();
+
+    /* Get/set start and end colours */
+    void SetStartColour(wxColour col) { m_startCol = col; }
+    wxColour GetStartColour() const { return m_startCol; }
+    void SetEndColour(wxColour col) { m_endCol = col; }
+    wxColour GetEndColour() const { return m_endCol; }
+
+private:
+    wxVector<wxGraphicsGradientStop>    m_stops;
+    wxColour                            m_startCol;
+    wxColour                            m_endCol;
+};
+
 class WXDLLIMPEXP_CORE wxGraphicsContext : public wxGraphicsObject
 {
 public:
@@ -352,11 +399,20 @@
     virtual wxGraphicsBrush CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
         const wxColour&c1, const wxColour&c2) const;
 
+    // sets the brush to a linear gradient, starting at (x1,y1) to (x2,y2) with colours set by gradient stops
+    virtual wxGraphicsBrush CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
+        wxGraphicsGradientStops &gradientStops) const;
+
     // sets the brush to a radial gradient originating at (xo,yc) with color oColor and ends on a circle around (xc,yc)
     // with radius r and color cColor
     virtual wxGraphicsBrush CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
         const wxColour &oColor, const wxColour &cColor) const;
 
+    // sets the brush to a radial gradient originating at (xo,yc) and ending on a circle around (xc,yc)
+    // with radius r and colours set by gradient stops
+    virtual wxGraphicsBrush CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
+        wxGraphicsGradientStops &gradientStops) const;
+
     // sets the font
     virtual wxGraphicsFont CreateFont( const wxFont &font , const wxColour &col = *wxBLACK ) const;
 
@@ -648,17 +704,26 @@
     virtual wxGraphicsBrush CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
         const wxColour&c1, const wxColour&c2) = 0;
 
+    // sets the brush to a linear gradient, starting at (x1,y1) to (x2,y2) with colours set by gradient stops
+    virtual wxGraphicsBrush CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
+        wxGraphicsGradientStops &gradientStops) = 0;
+
     // sets the brush to a radial gradient originating at (xo,yc) with color oColor and ends on a circle around (xc,yc)
     // with radius r and color cColor
     virtual wxGraphicsBrush CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
         const wxColour &oColor, const wxColour &cColor) = 0;
 
+    // sets the brush to a radial gradient originating at (xo,yc) and ending on a circle around (xc,yc)
+    // with radius r and colours set by gradient stops
+    virtual wxGraphicsBrush CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
+        wxGraphicsGradientStops &gradientStops) = 0;
+
    // sets the font
     virtual wxGraphicsFont CreateFont( const wxFont &font , const wxColour &col = *wxBLACK ) = 0;
 
     // create a native bitmap representation
     virtual wxGraphicsBitmap CreateBitmap( const wxBitmap &bitmap ) = 0;
-    
+
     // create a graphics bitmap from a native bitmap
     virtual wxGraphicsBitmap CreateBitmapFromNativeBitmap( void* bitmap ) = 0;
 
Index: interface/wx/graphics.h
===================================================================
--- interface/wx/graphics.h	(revision 63753)
+++ interface/wx/graphics.h	(working copy)
@@ -206,14 +206,14 @@
 enum wxAntialiasMode
 {
     /** No anti-aliasing */
-    wxANTIALIAS_NONE, 
-    
+    wxANTIALIAS_NONE,
+
     /** The default anti-aliasing */
     wxANTIALIAS_DEFAULT,
 };
 
 /**
-    Compositing is done using Porter-Duff compositions 
+    Compositing is done using Porter-Duff compositions
     (see http://keithp.com/~keithp/porterduff/p253-porter.pdf) with
     wxGraphicsContext::SetCompositionMode
 
@@ -372,6 +372,20 @@
                                                       const wxColour& c2) const;
 
     /**
+        Creates a native brush, having a linear gradient, in the direction from
+        (@a x1, @a y1) with color @a c1 to (@a x2, @a y2) with colours set from
+        @a gradientStops
+
+        NOTE: For OSX, only the start and end colours of @a gradientStops are currently
+        honoured.
+    */
+    virtual wxGraphicsBrush CreateLinearGradientBrush(wxDouble x1,
+                                                      wxDouble y1,
+                                                      wxDouble x2,
+                                                      wxDouble y2,
+                                                      wxGraphicsGradientStops &gradientStops) = 0;
+
+    /**
         Creates a native affine transformation matrix from the passed in
         values. The default parameters result in an identity matrix.
     */
@@ -402,6 +416,19 @@
                                                       const wxColour& cColor) const;
 
     /**
+        Creates a native brush, having a radial gradient originating at
+        (@a xo, @a yc) and ending on a circle around (@a xc, @a yc) with the given
+        @a radius and colours set from @a gradientStops.
+
+        NOTE: For OSX, only the start and end colours of @a gradientStops are currently
+        honoured.
+    */
+    virtual wxGraphicsBrush CreateRadialGradientBrush(wxDouble xo, wxDouble yo,
+                                                      wxDouble xc, wxDouble yc,
+                                                      wxDouble radius,
+                                                      wxGraphicsGradientStops &gradientStops) = 0;
+
+    /**
         Draws the bitmap. In case of a mono bitmap, this is treated as a mask
         and the current brushed is used for filling.
     */
@@ -611,41 +638,158 @@
     virtual void Translate(wxDouble dx, wxDouble dy) = 0;
 
     /**
-        Redirects all rendering is done into a fully transparent temporary context 
+        Redirects all rendering is done into a fully transparent temporary context
     */
     virtual void BeginLayer(wxDouble opacity) = 0;
 
-    /** 
-        Composites back the drawings into the context with the opacity given at 
+    /**
+        Composites back the drawings into the context with the opacity given at
         the BeginLayer call
     */
     virtual void EndLayer() = 0;
 
-    /** 
+    /**
         Sets the antialiasing mode, returns true if it supported
     */
     virtual bool SetAntialiasMode(wxAntialiasMode antialias) = 0;
 
-    /** 
+    /**
         Returns the current shape antialiasing mode
     */
     virtual wxAntialiasMode GetAntialiasMode() const ;
-    
+
     /**
         Sets the compositing operator, returns true if it supported
     */
     virtual bool SetCompositionMode(wxCompositionMode op) = 0;
 
-    /** 
+    /**
         Returns the current compositing operator
     */
     virtual wxCompositionMode GetCompositionMode() const;
-    
+
 };
 
+/**
+    @struct wxGraphicsGradientStop
 
+    Represents a single gradient stop in a collection of gradient stops as represented
+    by wxGraphicsGradientStops.
 
+    @library{wxcore}
+    @category{gdi}
+*/
+struct wxGraphicsGradientStop
+{
+    /**
+        Creates a wxGraphicsGradientStop with colour wxNullColour and position 0.0
+    */
+    wxGraphicsGradientStop() { col = wxNullColour; pos = 0.0; }
+
+    /**
+        Creates a wxGraphicsGradientStop with colour @a c at position @a p
+    */
+    wxGraphicsGradientStop(wxColour c, float p) { col = c; pos = p; }
+
+    /**
+        The stop colour
+    */
+    wxColour   col;
+
+    /**
+        The stop position
+    */
+    float      pos;
+};
+
 /**
+    @class wxGraphicsGradientStops
+
+    Represents a colection of wxGraphicGradientStop values for use with
+    CreateLinearGradientBrush and CreateRadialGradientBrush
+
+    NOTE: The stops are maintained in order of position.  If two or more stops are
+    added with the same position then the one(s) added later come later.
+    This can be useful for producing discontinuities in the colour gradient.
+
+    NOTE: An colour set to wxNullColour will be applied as a fully transparent colour allowing
+    background to show through.
+
+    NOTE: The alpha values in any colours are honoured thus allowing the background colours
+    to partially show through.
+
+    @library{wxcore}
+    @category{gdi}
+*/
+class WXDLLIMPEXP_CORE wxGraphicsGradientStops
+{
+public:
+    /**
+        Creates a wxGraphicsGradientStops instance with wxNullColour for
+        start and end colours.
+    */
+    wxGraphicsGradientStops();
+
+    /**
+        Creates a wxGraphicsGradientStops instance with start colour given
+        by @a startCol and end colour given by @a endCol
+    */
+    wxGraphicsGradientStops(wxColour startCol, wxColour endCol);
+
+    /**
+        Add a wxGraphicsGradientStop (@a stop) in correct order.
+    */
+    void Add(wxGraphicsGradientStop stop);
+
+    /**
+        Add a stop with given colour (@a col) and position (@a pos) in correct order.
+    */
+    void Add(wxColour col, float pos);
+
+    /**
+        Remove stop at given index (@a ind).  No action if @a ind is out of range.
+    */
+    void Remove(int ind);
+
+    /**
+        Returns (in @a pstop) a wxGraphicsGradientStop stop at given index (@a ind)
+
+        Returns false if index invalid otherwise returns true
+    */
+    bool Item(int ind, wxGraphicsGradientStop *pstop) const;
+
+    /**
+        Returns count of stops
+    */
+    int GetCount() const;
+
+    /**
+        Clears all stops
+    */
+    void Clear();
+
+    /**
+        Set the start colour to @a col
+    */
+    void SetStartColour(wxColour col);
+
+    /**
+        Returns the start colour.
+    */
+    wxColour GetStartColour() const;
+
+    /**
+        Set the end colour to @a col
+    */
+    void SetEndColour(wxColour col);
+
+    /**
+        Returns the end colour.
+    */
+    wxColour GetEndColour() const;
+};
+
+/**
     @class wxGraphicsRenderer
 
     A wxGraphicsRenderer is the instance corresponding to the rendering engine
@@ -707,7 +851,7 @@
     virtual wxGraphicsContext* CreateContextFromNativeWindow(void* window) = 0;
 
     /**
-        Creates a wxGraphicsContext that can be used for measuring texts only. 
+        Creates a wxGraphicsContext that can be used for measuring texts only.
         No drawing commands are allowed.
     */
     virtual wxGraphicsContext * CreateMeasuringContext() = 0;
@@ -719,7 +863,7 @@
                                       const wxColour& col = *wxBLACK) = 0;
 
     /**
-        Creates a native brush, having a linear gradient, starting at
+        Creates a native brush, having a linear gradient, in the direction from
         (@a x1, @a y1) with color @a c1 to (@a x2, @a y2) with color @a c2.
     */
     virtual wxGraphicsBrush CreateLinearGradientBrush(wxDouble x1,
@@ -730,6 +874,20 @@
                                                       const wxColour& c2) = 0;
 
     /**
+        Creates a native brush, having a linear gradient, in the direction from
+        (@a x1, @a y1) with color @a c1 to (@a x2, @a y2) with colours set from
+        @a gradientStops
+
+        NOTE: For OSX, only the start and end colours of @a gradientStops are currently
+        honoured.
+    */
+    virtual wxGraphicsBrush CreateLinearGradientBrush(wxDouble x1,
+                                                      wxDouble y1,
+                                                      wxDouble x2,
+                                                      wxDouble y2,
+                                                      wxGraphicsGradientStops &gradientStops) = 0;
+
+    /**
         Creates a native affine transformation matrix from the passed in
         values. The defaults result in an identity matrix.
     */
@@ -760,6 +918,19 @@
                                                       const wxColour& cColour) = 0;
 
     /**
+        Creates a native brush, having a radial gradient originating at
+        (@a xo, @a yc) and ending on a circle around (@a xc, @a yc) with the given
+        @a radius and colours set from @a gradientStops.
+
+        NOTE: For OSX, only the start and end colours of @a gradientStops are currently
+        honoured.
+    */
+    virtual wxGraphicsBrush CreateRadialGradientBrush(wxDouble xo, wxDouble yo,
+                                                      wxDouble xc, wxDouble yc,
+                                                      wxDouble radius,
+                                                      wxGraphicsGradientStops &gradientStops) = 0;
+
+    /**
         Returns the default renderer on this platform. On OS X this is the Core
         Graphics (a.k.a. Quartz 2D) renderer, on MSW the GDIPlus renderer, and
         on GTK we currently default to the cairo renderer.
Index: samples/drawing/drawing.cpp
===================================================================
--- samples/drawing/drawing.cpp	(revision 63753)
+++ samples/drawing/drawing.cpp	(working copy)
@@ -955,7 +955,7 @@
 {
     wxFont font = wxSystemSettings::GetFont(wxSYS_DEFAULT_GUI_FONT);
     gc->SetFont(font,*wxBLACK);
-    
+
     // make a path that contains a circle and some lines, centered at 0,0
     wxGraphicsPath path = gc->CreatePath() ;
     path.AddCircle( 0, 0, BASE2 );
@@ -965,14 +965,14 @@
     path.AddLineToPoint(BASE2, 0);
     path.CloseSubpath();
     path.AddRectangle(-BASE4, -BASE4/2, BASE2, BASE4);
-    
+
     // Now use that path to demonstrate various capbilites of the grpahics context
-    gc->PushState(); // save current translation/scale/other state 
+    gc->PushState(); // save current translation/scale/other state
     gc->Translate(60, 75); // reposition the context origin
 
     gc->SetPen(wxPen("navy", 1));
     gc->SetBrush(wxBrush("pink"));
-    
+
     for( int i = 0 ; i < 3 ; ++i )
     {
         wxString label;
@@ -1005,11 +1005,11 @@
         }
         gc->Translate(2*BASE, 0);
     }
-            
+
     gc->PopState(); // restore saved state
     gc->PushState(); // save it again
     gc->Translate(60, 200); // offset to the lower part of the window
-        
+
     gc->DrawText("Scale", 0, -BASE2);
     gc->Translate(0, 20);
 
@@ -1017,14 +1017,14 @@
     for( int i = 0 ; i < 8 ; ++i )
     {
         gc->Scale(1.08, 1.08); // increase scale by 8%
-        gc->Translate(5,5);    
+        gc->Translate(5,5);
         gc->DrawPath(path);
     }
 
     gc->PopState(); // restore saved state
     gc->PushState(); // save it again
-    gc->Translate(400, 200); 
-    
+    gc->Translate(400, 200);
+
     gc->DrawText("Rotate", 0, -BASE2);
 
     // Move the origin over to the next location
@@ -1034,16 +1034,16 @@
     // and changing colors as we go
     for ( int angle = 0 ; angle < 360 ; angle += 30 )
     {
-        gc->PushState(); // save this new current state so we can 
+        gc->PushState(); // save this new current state so we can
         //  pop back to it at the end of the loop
         wxImage::RGBValue val = wxImage::HSVtoRGB(wxImage::HSVValue(float(angle)/360, 1, 1));
         gc->SetBrush(wxBrush(wxColour(val.red, val.green, val.blue, 64)));
         gc->SetPen(wxPen(wxColour(val.red, val.green, val.blue, 128)));
-        
+
         // use translate to artfully reposition each drawn path
         gc->Translate(1.5 * BASE2 * cos(DegToRad(angle)),
                      1.5 * BASE2 * sin(DegToRad(angle)));
-                     
+
         // use Rotate to rotate the path
         gc->Rotate(DegToRad(angle));
 
@@ -1231,6 +1231,7 @@
     r.Offset(0, TEXT_HEIGHT);
     dc.GradientFillLinear(r, *wxWHITE, *wxBLUE, wxUP);
 
+    wxRect  gfr = wxRect(r);
 
     // RHS: concentric
     r = wxRect(200, 10, 50, 50);
@@ -1283,6 +1284,112 @@
     dc.DrawRectangle(r4);
     r4.Deflate(1);
     dc.GradientFillLinear(r4, wxColour(0,0,0), wxColour(0,255,0), wxWEST);
+
+#if wxUSE_GRAPHICS_CONTEXT
+    if (m_useContext)
+    {
+        wxGCDC                      &gdc = (wxGCDC&)dc;
+        wxGraphicsContext           *gc = gdc.GetGraphicsContext();
+        wxGraphicsPath              pth;
+        wxGraphicsGradientStops     stops;
+
+        gfr.Offset(0, gfr.height + 10);
+        dc.DrawText(wxT("Linear Gradient with Stops"), gfr.x, gfr.y);
+        gfr.Offset(0, TEXT_HEIGHT);
+
+        stops = wxGraphicsGradientStops(wxColour(255,0,0), wxColour(0,0,255));
+        stops.Add(wxColour(255,255,0), 0.33);
+        stops.Add(wxColour(0,255,0), 0.67);
+
+        gc->SetBrush(gc->CreateLinearGradientBrush(gfr.x, gfr.y, gfr.x + gfr.width, gfr.y + gfr.height, stops));
+        pth = gc->CreatePath();
+        pth.MoveToPoint(gfr.x,gfr.y);
+        pth.AddLineToPoint(gfr.x + gfr.width,gfr.y);
+        pth.AddLineToPoint(gfr.x + gfr.width,gfr.y+gfr.height);
+        pth.AddLineToPoint(gfr.x,gfr.y+gfr.height);
+        pth.CloseSubpath();
+        gc->FillPath(pth);
+
+        gfr.Offset(0, gfr.height + 10);
+        dc.DrawText(wxT("Radial Gradient with Stops"), gfr.x, gfr.y);
+        gfr.Offset(0, TEXT_HEIGHT);
+
+        gc->SetBrush(gc->CreateRadialGradientBrush(gfr.x + gfr.width / 2, gfr.y + gfr.height / 2,
+                gfr.x + gfr.width / 2, gfr.y + gfr.height / 2,
+                gfr.width / 2, stops));
+        pth = gc->CreatePath();
+        pth.MoveToPoint(gfr.x,gfr.y);
+        pth.AddLineToPoint(gfr.x + gfr.width,gfr.y);
+        pth.AddLineToPoint(gfr.x + gfr.width,gfr.y+gfr.height);
+        pth.AddLineToPoint(gfr.x,gfr.y+gfr.height);
+        pth.CloseSubpath();
+        gc->FillPath(pth);
+
+        gfr.Offset(0, gfr.height + 10);
+        dc.DrawText(wxT("Linear Gradient with Stops and Gaps"), gfr.x, gfr.y);
+        gfr.Offset(0, TEXT_HEIGHT);
+
+        stops = wxGraphicsGradientStops(wxColour(255,0,0), wxColour(0,0,255));
+        stops.Add(wxColour(255,255,0), 0.33);
+        stops.Add(wxNullColour, 0.33);
+        stops.Add(wxNullColour, 0.67);
+        stops.Add(wxColour(0,255,0), 0.67);
+
+        gc->SetBrush(gc->CreateLinearGradientBrush(gfr.x, gfr.y + gfr.height, gfr.x + gfr.width, gfr.y, stops));
+        pth = gc->CreatePath();
+        pth.MoveToPoint(gfr.x,gfr.y);
+        pth.AddLineToPoint(gfr.x + gfr.width,gfr.y);
+        pth.AddLineToPoint(gfr.x + gfr.width,gfr.y+gfr.height);
+        pth.AddLineToPoint(gfr.x,gfr.y+gfr.height);
+        pth.CloseSubpath();
+        gc->FillPath(pth);
+
+        gfr.Offset(0, gfr.height + 10);
+        dc.DrawText(wxT("Radial Gradient with Stops and Gaps"), gfr.x, gfr.y);
+        gfr.Offset(0, TEXT_HEIGHT);
+
+        gc->SetBrush(gc->CreateRadialGradientBrush(gfr.x + gfr.width / 2, gfr.y + gfr.height / 2,
+                gfr.x + gfr.width / 2, gfr.y + gfr.height / 2,
+                gfr.width / 2, stops));
+        pth = gc->CreatePath();
+        pth.MoveToPoint(gfr.x,gfr.y);
+        pth.AddLineToPoint(gfr.x + gfr.width,gfr.y);
+        pth.AddLineToPoint(gfr.x + gfr.width,gfr.y+gfr.height);
+        pth.AddLineToPoint(gfr.x,gfr.y+gfr.height);
+        pth.CloseSubpath();
+        gc->FillPath(pth);
+
+        gfr.Offset(0, gfr.height + 10);
+        dc.DrawText(wxT("Gradients with Stops and Transparency"), gfr.x, gfr.y);
+        gfr.Offset(0, TEXT_HEIGHT);
+
+        stops = wxGraphicsGradientStops(wxColour(255,0,0), wxNullColour);
+        stops.Add(wxColour(255,0,0), 0.33);
+        stops.Add(wxNullColour, 0.33);
+        stops.Add(wxNullColour, 0.67);
+        stops.Add(wxColour(0,0,255), 0.67);
+        stops.Add(wxColour(0,0,255), 1.0);
+
+        pth = gc->CreatePath();
+        pth.MoveToPoint(gfr.x,gfr.y);
+        pth.AddLineToPoint(gfr.x + gfr.width,gfr.y);
+        pth.AddLineToPoint(gfr.x + gfr.width,gfr.y+gfr.height);
+        pth.AddLineToPoint(gfr.x,gfr.y+gfr.height);
+        pth.CloseSubpath();
+
+        gc->SetBrush(gc->CreateRadialGradientBrush(gfr.x + gfr.width / 2, gfr.y + gfr.height / 2,
+                gfr.x + gfr.width / 2, gfr.y + gfr.height / 2,
+                gfr.width / 2, stops));
+        gc->FillPath(pth);
+
+        stops = wxGraphicsGradientStops(wxColour(255,0,0, 128), wxColour(0,0,255, 128));
+        stops.Add(wxColour(255,255,0,128), 0.33);
+        stops.Add(wxColour(0,255,0,128), 0.67);
+
+        gc->SetBrush(gc->CreateLinearGradientBrush(gfr.x, gfr.y, gfr.x + gfr.width, gfr.y, stops));
+        gc->FillPath(pth);
+    }
+#endif
 }
 
 void MyCanvas::DrawRegions(wxDC& dc)
@@ -1474,7 +1581,7 @@
         str.Printf( wxT("Current mouse position: %d,%d"), (int)x, (int)y );
         m_owner->SetStatusText( str );
     }
-    
+
     if ( m_rubberBand )
     {
         int x,y, xx, yy ;
@@ -1530,9 +1637,9 @@
         int x,y,xx,yy ;
         event.GetPosition(&x,&y);
         CalcUnscrolledPosition( x, y, &xx, &yy );
-        
+
         wxString str;
-        str.Printf( wxT("Rectangle selection from %d,%d to %d,%d"), 
+        str.Printf( wxT("Rectangle selection from %d,%d to %d,%d"),
             m_anchorpoint.x, m_anchorpoint.y , (int)xx, (int)yy );
         wxMessageBox( str , wxT("Rubber-Banding") );
 
@@ -1658,8 +1765,8 @@
     m_xAxisReversed =
     m_yAxisReversed = false;
     m_backgroundMode = wxSOLID;
-    m_colourForeground = *wxRED;
-    m_colourBackground = *wxBLUE;
+    m_colourForeground = *wxBLACK;
+    m_colourBackground = *wxLIGHT_GREY;
     m_textureBackground = false;
 
     m_canvas = new MyCanvas( this );
