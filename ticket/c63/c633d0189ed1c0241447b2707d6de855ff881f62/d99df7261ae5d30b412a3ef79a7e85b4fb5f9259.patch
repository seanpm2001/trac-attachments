Index: docs/doxygen/overviews/eventhandling.h
===================================================================
--- docs/doxygen/overviews/eventhandling.h	(revision 56945)
+++ docs/doxygen/overviews/eventhandling.h	(working copy)
@@ -524,44 +524,44 @@
 for other purposes). In fact, identifiers do not need to be unique
 across your entire application as long they are unique within the
 particular context you're interested in, such as a frame and its children. You
-may use the @c wxID_OK identifier, for example, on any number of dialogs so
-long as you don't have several within the same dialog.
+may use the @c wxID_OK identifier, for example, on any number of dialogs
+as long as you don't have several within the same dialog.
 
 If you pass @c wxID_ANY to a window constructor, an identifier will be
 generated for you automatically by wxWidgets. This is useful when you don't
 care about the exact identifier either because you're not going to process the
-events from the control being created at all or because you process the events
+events from the control being created or because you process the events
 from all controls in one place (in which case you should specify @c wxID_ANY
 in the event table or wxEvtHandler::Connect call
-as well. The automatically generated identifiers are always negative and so
+as well). The automatically generated identifiers are always negative and so
 will never conflict with the user-specified identifiers which must be always
 positive.
 
 See @ref page_stdevtid for the list of standard identifiers available.
 You can use wxID_HIGHEST to determine the number above which it is safe to
 define your own identifiers. Or, you can use identifiers below wxID_LOWEST.
-Finally, you can allocate identifiers dynamically using wxNewId() function to.
+Finally, you can allocate identifiers dynamically using wxNewId() function too.
 If you use wxNewId() consistently in your application, you can be sure that
-the your identifiers don't conflict accidentally.
+your identifiers don't conflict accidentally.
 
 
 @section overview_eventhandling_custom Custom Event Summary
 
 @subsection overview_eventhandling_custom_general General approach
 
-Since version 2.2.x of wxWidgets, each event type is identified by ID which
-is given to the event type @e at runtime which makes it possible to add
+Since version 2.2.x of wxWidgets, each event type is identified by an ID
+given to the event type @e at runtime that makes it possible to add
 new event types to the library or application without risking ID clashes
 (two different event types mistakingly getting the same event ID).
 This event type ID is stored in a struct of type <b>const wxEventType</b>.
 
 In order to define a new event type, there are principally two choices.
-One is to define a entirely new event class (typically deriving from
+One is to define an entirely new event class (typically deriving from
 wxEvent or wxCommandEvent).
 
-The other is to use the existing event classes and give them an new event
-type. You'll have to define and declare a new event type using either way,
-and this is done using the following macros:
+The other is to use the existing event classes and give them a new event
+type. You'll have to define and declare a new event type either way
+using the following macros:
 
 @code
 // in the header of the source file
@@ -577,7 +577,7 @@
 
 @subsection overview_eventhandling_custom_existing Using Existing Event Classes
 
-If you just want to use a wxCommandEvent with a new event type, you can then use
+If you just want to use a wxCommandEvent with a new event type, use
 one of the generic event table macros listed below, without having to define a
 new event class yourself. This also has the advantage that you won't have to define a
 new wxEvent::Clone() method for posting events between threads etc.
@@ -719,11 +719,11 @@
 @ref group_class_events "event classes group page".
 
 
-@todo for all controls state clearly when calling a member function results in an
-      event being generated and when it doesn't (possibly updating also the
-      'Events generated by the user vs programmatically generated events' paragraph
-      of the 'Event handling overview' with the list of the functions which break
-      that rule).
+@todo For all controls, state clearly when calling a member function results in
+      an event being generated and when it doesn't (possibly updating also the
+      'Events generated by the user versus programmatically-generated events'
+      paragraph of the 'Event Handling Overview' with the list of the functions
+      that break the rule).
 
 */
 
