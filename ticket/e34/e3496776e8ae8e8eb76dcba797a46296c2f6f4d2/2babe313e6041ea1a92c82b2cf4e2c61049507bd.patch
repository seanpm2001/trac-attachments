diff --git docs/doxygen/mainpages/samples.h docs/doxygen/mainpages/samples.h
index 054856c..c025ac6 100644
--- docs/doxygen/mainpages/samples.h
+++ docs/doxygen/mainpages/samples.h
@@ -584,6 +584,8 @@ commands through the menu.
     Arrow keys rotate the cube. Space bar toggles spinning.
 @li @b isosurf Draws a surface by reading coordinates from a DAT file.
 @li @b penguin Draws a rotatable penguin by reading data from a DXF file.
+@li @b pyramid Draws a rotatable tetrahedron and some strings.
+    It uses OpenGL 3.2 Core Profile context.
 
 @sampledir{opengl}
 
diff --git samples/opengl/opengl_samples.bkl samples/opengl/opengl_samples.bkl
index d2873c2..1a789df 100644
--- samples/opengl/opengl_samples.bkl
+++ samples/opengl/opengl_samples.bkl
@@ -13,5 +13,6 @@
     <subproject id="cube" template="sub"/>
     <subproject id="isosurf" template="sub"/>
     <subproject id="penguin" template="sub"/>
+    <subproject id="pyramid" template="sub"/>
 
 </makefile>

diff --git samples/opengl/pyramid/mathstuff.cpp samples/opengl/pyramid/mathstuff.cpp
new file mode 100755
index 0000000..2ceb459
--- /dev/null
+++ samples/opengl/pyramid/mathstuff.cpp
@@ -0,0 +1,269 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        mathstuff.cpp
+// Purpose:     Some maths used for pyramid sample
+// Author:      Manuel Martin
+// Modified by:
+// Created:     2015/01/31
+// Copyright:   (c)
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#include <cmath>
+
+#include "mathstuff.h"
+
+// Overload of "-" operator
+myVec3 operator- (const myVec3& v1, const myVec3& v2)
+{
+    return myVec3(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
+}
+
+// Vector normalization
+myVec3 MyNormalize(const myVec3& v)
+{
+    double mo = sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
+    if ( mo > 1E-20 )
+        return myVec3(v.x / mo, v.y / mo, v.z / mo);
+    else
+        return myVec3();
+}
+
+// Dot product
+double MyDot(const myVec3& v1, const myVec3& v2)
+{
+    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z ;
+}
+
+// Cross product
+myVec3 MyCross(const myVec3& v1, const myVec3& v2)
+{
+    return myVec3( v1.y * v2.z - v2.y * v1.z,
+                   v1.z * v2.x - v2.z * v1.x,
+                   v1.x * v2.y - v2.x * v1.y );
+}
+
+// Distance between two points
+double MyDistance(const myVec3& v1, const myVec3& v2)
+{
+    double rx = v1.x -v2.x;
+    double ry = v1.y -v2.y;
+    double rz = v1.z -v2.z;
+
+    return sqrt(rx*rx + ry*ry + rz*rz);
+}
+
+// Angle between two normalized vectors, in radians
+double AngleBetween(myVec3 v1, myVec3 v2)
+{
+    double angle = MyDot(v1, v2);
+    // Prevent issues due to numerical precision
+    if (angle > 1.0)
+        angle = 1.0;
+    if (angle < -1.0)
+        angle = -1.0;
+
+    return acos(angle);
+}
+
+// Matrix 4x4 by 4x1 multiplication
+// Attention: No bounds check!
+myVec4 MyMatMul4x1(const float *m1, const myVec4& v)
+{
+    myVec4 mmv;
+    mmv.x = (double) m1[0] * v.x + m1[4] * v.y +  m1[8] * v.z + m1[12] * v.w ;
+    mmv.y = (double) m1[1] * v.x + m1[5] * v.y +  m1[9] * v.z + m1[13] * v.w ;
+    mmv.z = (double) m1[2] * v.x + m1[6] * v.y + m1[10] * v.z + m1[14] * v.w ;
+    mmv.w = (double) m1[3] * v.x + m1[7] * v.y + m1[11] * v.z + m1[15] * v.w ;
+
+    return mmv;
+}
+
+// Matrix 4x4 multiplication
+// Attention: No bounds check!
+void MyMatMul4x4(const float *m1, const float *m2, float* mm)
+{
+     mm[0] = (double) m1[0] *  m2[0] + m1[4] *  m2[1] +  m1[8] *  m2[2] + m1[12] *  m2[3] ;
+     mm[1] = (double) m1[1] *  m2[0] + m1[5] *  m2[1] +  m1[9] *  m2[2] + m1[13] *  m2[3] ;
+     mm[2] = (double) m1[2] *  m2[0] + m1[6] *  m2[1] + m1[10] *  m2[2] + m1[14] *  m2[3] ;
+     mm[3] = (double) m1[3] *  m2[0] + m1[7] *  m2[1] + m1[11] *  m2[2] + m1[15] *  m2[3] ;
+     mm[4] = (double) m1[0] *  m2[4] + m1[4] *  m2[5] +  m1[8] *  m2[6] + m1[12] *  m2[7] ;
+     mm[5] = (double) m1[1] *  m2[4] + m1[5] *  m2[5] +  m1[9] *  m2[6] + m1[13] *  m2[7] ;
+     mm[6] = (double) m1[2] *  m2[4] + m1[6] *  m2[5] + m1[10] *  m2[6] + m1[14] *  m2[7] ;
+     mm[7] = (double) m1[3] *  m2[4] + m1[7] *  m2[5] + m1[11] *  m2[6] + m1[15] *  m2[7] ;
+     mm[8] = (double) m1[0] *  m2[8] + m1[4] *  m2[9] +  m1[8] * m2[10] + m1[12] * m2[11] ;
+     mm[9] = (double) m1[1] *  m2[8] + m1[5] *  m2[9] +  m1[9] * m2[10] + m1[13] * m2[11] ;
+    mm[10] = (double) m1[2] *  m2[8] + m1[6] *  m2[9] + m1[10] * m2[10] + m1[14] * m2[11] ;
+    mm[11] = (double) m1[3] *  m2[8] + m1[7] *  m2[9] + m1[11] * m2[10] + m1[15] * m2[11] ;
+    mm[12] = (double) m1[0] * m2[12] + m1[4] * m2[13] +  m1[8] * m2[14] + m1[12] * m2[15] ;
+    mm[13] = (double) m1[1] * m2[12] + m1[5] * m2[13] +  m1[9] * m2[14] + m1[13] * m2[15] ;
+    mm[14] = (double) m1[2] * m2[12] + m1[6] * m2[13] + m1[10] * m2[14] + m1[14] * m2[15] ;
+    mm[15] = (double) m1[3] * m2[12] + m1[7] * m2[13] + m1[11] * m2[14] + m1[15] * m2[15] ;
+}
+
+// Matrix 4x4 inverse. Returns the determinant.
+// Attention: No bounds check!
+// Method used is "adjugate matrix" with "cofactors".
+// A faster method, such as "LU decomposition", isn't much faster than this code.
+double MyMatInverse(const float *m, float *minv)
+{
+    double det;
+    double cof[16], sdt[19];
+
+    // The 2x2 determinants used for cofactors
+    sdt[0]  = (double) m[10] * m[15] - m[14] * m[11] ;
+    sdt[1]  = (double)  m[9] * m[15] - m[13] * m[11] ;
+    sdt[2]  = (double)  m[9] * m[14] - m[13] * m[10] ;
+    sdt[3]  = (double)  m[8] * m[15] - m[12] * m[11] ;
+    sdt[4]  = (double)  m[8] * m[14] - m[12] * m[10] ;
+    sdt[5]  = (double)  m[8] * m[13] - m[12] *  m[9] ;
+    sdt[6]  = (double)  m[6] * m[15] - m[14] *  m[7] ;
+    sdt[7]  = (double)  m[5] * m[15] - m[13] *  m[7] ;
+    sdt[8]  = (double)  m[5] * m[14] - m[13] *  m[6] ;
+    sdt[9]  = (double)  m[4] * m[15] - m[12] *  m[7] ;
+    sdt[10] = (double)  m[4] * m[14] - m[12] *  m[6] ;
+    sdt[11] = (double)  m[5] * m[15] - m[13] *  m[7] ;
+    sdt[12] = (double)  m[4] * m[13] - m[12] *  m[5] ;
+    sdt[13] = (double)  m[6] * m[11] - m[10] *  m[7] ;
+    sdt[14] = (double)  m[5] * m[11] -  m[9] *  m[7] ;
+    sdt[15] = (double)  m[5] * m[10] -  m[9] *  m[6] ;
+    sdt[16] = (double)  m[4] * m[11] -  m[8] *  m[7] ;
+    sdt[17] = (double)  m[4] * m[10] -  m[8] *  m[6] ;
+    sdt[18] = (double)  m[4] *  m[9] -  m[8] *  m[5] ;
+    // The cofactors, transposed
+    cof[0]  =   m[5] *  sdt[0] - m[6] *  sdt[1] + m[7] *  sdt[2] ;
+    cof[1]  = - m[1] *  sdt[0] + m[2] *  sdt[1] - m[3] *  sdt[2] ;
+    cof[2]  =   m[1] *  sdt[6] - m[2] *  sdt[7] + m[3] *  sdt[8] ;
+    cof[3]  = - m[1] * sdt[13] + m[2] * sdt[14] - m[3] * sdt[15] ;
+    cof[4]  = - m[4] *  sdt[0] + m[6] *  sdt[3] - m[7] *  sdt[4] ;
+    cof[5]  =   m[0] *  sdt[0] - m[2] *  sdt[3] + m[3] *  sdt[4] ;
+    cof[6]  = - m[0] *  sdt[6] + m[2] *  sdt[9] - m[3] * sdt[10] ;
+    cof[7]  =   m[0] * sdt[13] - m[2] * sdt[16] + m[3] * sdt[17] ;
+    cof[8]  =   m[4] *  sdt[1] - m[5] *  sdt[3] + m[7] *  sdt[5] ;
+    cof[9]  = - m[0] *  sdt[1] + m[1] *  sdt[3] - m[3] *  sdt[5] ;
+    cof[10] =   m[0] * sdt[11] - m[1] *  sdt[9] + m[3] * sdt[12] ;
+    cof[11] = - m[0] * sdt[14] + m[1] * sdt[16] - m[3] * sdt[18] ;
+    cof[12] = - m[4] *  sdt[2] + m[5] *  sdt[4] - m[6] *  sdt[5] ;
+    cof[13] =   m[0] *  sdt[2] - m[1] *  sdt[4] + m[2] *  sdt[5] ;
+    cof[14] = - m[0] *  sdt[8] + m[1] * sdt[10] - m[2] * sdt[12] ;
+    cof[15] =   m[0] * sdt[15] - m[1] * sdt[17] + m[2] * sdt[18] ;
+
+    det = m[0] * cof[0] + m[1] * cof[4] + m[2] * cof[8] + m[3] * cof[12] ;
+
+    if ( fabs(det) > 10E-9 ) // Some precision value
+    {
+        double invdet = 1.0 / det;
+        for (int i = 0; i < 16; ++i)
+            minv[i] = cof[i] * invdet;
+    }
+    else
+    {
+        // Enable comparison with 0
+        det = 0.0;
+    }
+
+    return det;
+}
+
+// Matrix of rotation around an axis in the origin.
+// angle is positive if follows axis (right-hand rule)
+// Attention: No bounds check!
+void MyRotate(const myVec3& axis, double angle, float *mrot)
+{
+    double c = cos(angle);
+    double s = sin(angle);
+    double t = 1.0 - c;
+
+    // Normalize the axis vector
+    myVec3 uv = MyNormalize(axis);
+
+    // Store the matrix in column order
+    mrot[0]  = t * uv.x * uv.x + c ;
+    mrot[1]  = t * uv.x * uv.y + s * uv.z ;
+    mrot[2]  = t * uv.x * uv.z - s * uv.y ;
+    mrot[3]  = 0.0 ;
+    mrot[4]  = t * uv.y * uv.x - s * uv.z ;
+    mrot[5]  = t * uv.y * uv.y + c ;
+    mrot[6]  = t * uv.y * uv.z + s * uv.x ;
+    mrot[7]  = 0.0 ;
+    mrot[8]  = t * uv.z * uv.x + s * uv.y ;
+    mrot[9]  = t * uv.z * uv.y - s * uv.x ;
+    mrot[10] = t * uv.z * uv.z + c ;
+    mrot[11] = 0.0 ;
+    mrot[12] = mrot[13] = mrot[14] = 0.0 ;
+    mrot[15] = 1.0 ;
+}
+
+// Matrix for defining the viewing transformation
+// Attention: No bounds check!
+// Unchecked conditions:
+//   camPos != targ  && camUp != {0,0,0}
+//   camUo can't be parallel to camPos - targ
+void MyLookAt(const myVec3& camPos, const myVec3& camUp, const myVec3& targ, float *mt)
+{
+    myVec3 tc = MyNormalize(targ - camPos);
+    myVec3 up = MyNormalize(camUp);
+    // Normalize tc x up for the case where up is not perpendicular to tc
+    myVec3  s = MyNormalize(MyCross(tc, up));
+    myVec3  u = MyNormalize(MyCross(s, tc)); //Normalize to improve accuracy
+
+    // Store the matrix in column order
+    mt[0]  = s.x ;
+    mt[1]  = u.x ;
+    mt[2]  = - tc.x ;
+    mt[3]  = 0.0 ;
+    mt[4]  = s.y ;
+    mt[5]  = u.y ;
+    mt[6]  = - tc.y ;
+    mt[7]  = 0.0 ;
+    mt[8]  = s.z ;
+    mt[9]  = u.z ;
+    mt[10] = - tc.z ;
+    mt[11] = 0.0 ;
+    mt[12] = - MyDot(s, camPos) ;
+    mt[13] = - MyDot(u, camPos) ;
+    mt[14] =   MyDot(tc, camPos) ;
+    mt[15] = 1.0 ;
+}
+
+// Matrix for defining the perspective projection with symmetric frustum
+// From camera coordinates to canonical (2x2x2 cube) coordinates.
+// Attention: No bounds check!
+// Unchecked conditions: fov > 0 && zNear > 0 && zFar > zNear && aspect > 0
+void MyPerspective(double fov, double aspect, double zNear, double zFar, float *mp)
+{
+    double f = 1.0 / tan(fov / 2.0);
+
+    // Store the matrix in column order
+    mp[0]  = f / aspect ;
+    mp[1]  = mp[2] = mp[3]  = 0.0 ;
+    mp[4]  = 0.0 ;
+    mp[5]  = f ;
+    mp[6]  = mp[7] = 0.0 ;
+    mp[8]  = mp[9] = 0.0 ;
+    mp[10] = (zNear + zFar) / (zNear - zFar) ;
+    mp[11] = -1.0 ;
+    mp[12] = mp[13] = 0.0 ;
+    mp[14] = 2.0 * zNear * zFar / (zNear - zFar) ;
+    mp[15] = 0.0 ;
+}
+
+// Matrix for defining the orthogonal projection with symmetric frustum
+// From camera coordinates to canonical (2x2x2 cube) coordinates.
+// Attention: No bounds check!
+// Unchecked conditions: left != right && bottom != top && zNear != zFar
+void MyOrtho(double left, double right, double bottom, double top,
+             double zNear, double zFar, float *mo)
+{
+    // Store the matrix in column order
+    mo[0]  = 2.0 / (right - left) ;
+    mo[1]  = mo[2] = mo[3] = mo[4] = 0.0 ;
+    mo[5]  = 2.0 / (top - bottom) ;
+    mo[6]  = mo[7] = mo[8]  = mo[9] = 0.0 ;
+    mo[10] = 2.0 / (zNear - zFar) ;
+    mo[11] = 0.0 ;
+    mo[12] = -(right + left) / (right - left) ;
+    mo[13] = -(top + bottom) / (top - bottom) ;
+    mo[14] = (zNear + zFar) / (zNear - zFar) ;
+    mo[15] = 1.0 ;
+}
+
diff --git samples/opengl/pyramid/mathstuff.h samples/opengl/pyramid/mathstuff.h
new file mode 100755
index 0000000..03b264d
--- /dev/null
+++ samples/opengl/pyramid/mathstuff.h
@@ -0,0 +1,85 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        mathstuff.h
+// Purpose:     Some maths used for pyramid sample
+// Author:      Manuel Martin
+// Modified by:
+// Created:     2015/01/31
+// Copyright:   (c)
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef MATHSTUFF_H
+  #define MATHSTUFF_H
+
+//NOTE:
+// glm library is great handling matrices and vectors in a OpenGL style.
+// http://glm.g-truc.net/
+// But it's too large for this simple sample. I coded on my own the maths needed.
+
+// A vector with 3 components
+class myVec3
+{
+public:
+    myVec3() { x = y = z = 0.0 ;}
+    myVec3(double xd, double yd, double zd) : x(xd), y(yd), z(zd) {}
+    ~myVec3() {}
+
+    double x, y, z;
+};
+
+// A vector with 4 components
+class myVec4
+{
+public:
+    myVec4() { x = y = z = w = 0.0 ;}
+    myVec4(double xd, double yd, double zd, double wd)
+            : x(xd), y(yd), z(zd), w(wd) {}
+    myVec4(const myVec3& v3, double wd = 0.0)
+            : x(v3.x), y(v3.y), z(v3.z), w(wd) {}
+    ~myVec4() {}
+
+    double x, y, z, w;
+};
+
+// Overload of "-" operator
+myVec3 operator- (const myVec3& v1, const myVec3& v2);
+
+// Vector normalization
+myVec3 MyNormalize(const myVec3& v);
+
+// Dot product
+double MyDot(const myVec3& v1, const myVec3& v2);
+
+// Cross product
+myVec3 MyCross(const myVec3& v1, const myVec3& v2);
+
+// Distance between two points
+double MyDistance(const myVec3& v1, const myVec3& v2);
+
+// Angle between two normalized vectors, in radians
+double AngleBetween(myVec3 v1, myVec3 v2);
+
+// Matrix 4x4 by 4x1 multiplication
+myVec4 MyMatMul4x1(const float *m1, const myVec4& v);
+
+// Matrix 4x4 by 4x4 multiplication
+void MyMatMul4x4(const float *m1, const float *m2, float* mm);
+
+// Matrix inverse. Returns the determinant
+double MyMatInverse(const float *m, float *minv);
+
+// Matrix of rotation around an axis in the origin
+void MyRotate(const myVec3& axis, double angle, float *mrot);
+
+// Matrix for defining the viewing transformation
+void MyLookAt(const myVec3& camPos, const myVec3& camUp, const myVec3& targ, float *mt);
+
+// Matrix for defining the perspective projection with symmetric frustum
+void MyPerspective(double fov, double aspect, double zNear, double zFar, float *mp);
+
+// Matrix for defining the orthogonal projection
+void MyOrtho(double left, double right, double bottom, double top,
+             double zNear, double zFar, float *mo);
+
+#endif // MATHSTUFF_H
+
diff --git samples/opengl/pyramid/oglstuff.cpp samples/opengl/pyramid/oglstuff.cpp
new file mode 100755
index 0000000..b484cdc
--- /dev/null
+++ samples/opengl/pyramid/oglstuff.cpp
@@ -0,0 +1,1240 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        oglstuff.cpp
+// Purpose:     OpenGL manager for pyramid sample
+// Author:      Manuel Martin
+// Modified by:
+// Created:     2015/01/31
+// Copyright:   (c)
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#include <cmath>
+
+#include "oglstuff.h"
+
+// External function for GL errors
+myOGLErrHandler* externalMyOGLErrHandler = NULL;
+
+// Allow GL errors to be handled in other part of the app.
+bool MyOnGLError(int err, const GLchar* glMsg = NULL)
+{
+    GLenum GLErrorVal = glGetError();
+
+    if ( err == myoglERR_CLEAR )
+    {
+        // Clear previous errors
+        while ( GLErrorVal != GL_NO_ERROR )
+            GLErrorVal = glGetError();
+        return true;
+    }
+
+    if ( (GLErrorVal == GL_NO_ERROR) && (glMsg == NULL) )
+        return true;
+
+    if ( externalMyOGLErrHandler )
+    {
+        // Use the external error message handler. We pass our err-enum value.
+        externalMyOGLErrHandler(err, GLErrorVal, glMsg);
+    }
+
+    return err == myoglERR_JUSTLOG ? true : false;
+}
+
+// ----------------------------------------------------------------------------
+// Data for a regular tetrahedron with edge length 200, centered at the origin
+// ----------------------------------------------------------------------------
+const GLfloat gVerts[] = { 100.0f, -40.8248f, -57.7350f,
+                             0.0f, -40.8248f, 115.4704f,
+                          -100.0f, -40.8248f, -57.7350f,
+                             0.0f, 122.4745f,   0.0f };
+
+// Transparency (to see also inner faces) is in the last triangle only,
+// so that glEnable(GL_BLEND) works well
+const GLfloat gColours[] = { 0.0f, 1.0f, 0.0f, 1.0f,
+                             1.0f, 0.0f, 0.0f, 1.0f,
+                             0.0f, 0.0f, 1.0f, 1.0f,
+                             1.0f, 1.0f, 0.0f, 0.3f }; //With transparency
+
+// Normals heading outside of the tetrahedron
+const GLfloat gNormals[] = { 0.0f,    -1.0f,      0.0f,     /* face 0 1 2 */
+                            -0.81650f, 0.33333f,  0.47140f, /* face 1 2 3 */
+                             0.0f,     0.33333f, -0.94281f, /* face 2 3 0 */
+                             0.81650f, 0.33333f,  0.47140f  /* face 3 0 1 */ };
+
+// Order would be important if we were using face culling
+const GLushort gIndices[] = { 0, 1, 2, 3, 0, 1 };
+
+
+// ----------------------------------------------------------------------------
+// Shaders
+// ----------------------------------------------------------------------------
+// Note: We use GLSL 1.50 which is the minimum starting with OpenGL >= 3.2 (2009)
+// Apple supports OpenGL 3.2 since OS X 10.7 "Lion" (2011)
+
+// Vertex shader for the triangles
+const GLchar* triangVertexShader =
+{
+    "#version 150 \n"
+
+    "in vec3 in_Position; \n"
+    "in vec4 in_Colour; \n"
+    "in vec3 in_Normal; \n"
+    "uniform mat4 mMVP; \n"
+    "uniform mat4 mToViewSpace; \n"
+
+    "flat out vec4 theColour; \n"
+    "flat out vec3 theNormal; \n"
+    "out vec3 pointPos; \n"
+
+    "void main(void) \n"
+    "{\n"
+    "    gl_Position = mMVP * vec4(in_Position, 1.0); \n"
+    "    theColour = in_Colour; \n"
+
+    "    // Operations in View Space \n"
+    "    vec4 temp4 = mToViewSpace * vec4(in_Position, 1.0); \n"
+    "    pointPos = temp4.xyz; \n"
+    "    temp4 = mToViewSpace * vec4(in_Normal, 0.0); \n"
+    "    theNormal = normalize(temp4.xyz); \n"
+    "}\n"
+};
+
+// Common function for fragment shaders
+const GLchar* illuminationShader =
+{
+    "#version 150 \n"
+
+    "vec3 Illuminate(in vec4 LiProps, in vec3 LiColour, in vec4 PColour, \n"
+    "                in vec3 PNormal, in vec3 PPos) \n"
+    "{\n"
+    "    // Ambient illumination. Hardcoded \n"
+    "    vec3 liAmbient = vec3(0.2, 0.2, 0.2); \n"
+
+    "    // Operations in View Space \n"
+    "    vec3 lightDirec = LiProps.xyz - PPos; \n"
+    "    float lightDist = length(lightDirec); \n"
+    "    // Normalize. Attention: No lightDist > 0 check \n"
+    "    lightDirec = lightDirec / lightDist; \n"
+    "    // Attenuation. Hardcoded for this sample distances \n"
+    "    float attenu = 260.0 / lightDist; \n"
+    "    attenu = attenu * attenu; \n"
+
+    "    // Lambertian diffuse illumination \n"
+    "    float diffuse = dot(lightDirec, PNormal); \n"
+    "    diffuse = max(0.0, diffuse); \n"
+    "    vec3 liDiffuse = LiColour * LiProps.w * diffuse * attenu; \n"
+
+    "    // Gaussian specular illumination. Harcoded values again \n"
+    "    // We avoid it for interior faces \n"
+    "    vec3 viewDir = vec3(0.0, 0.0, 1.0); \n"
+    "    vec3 halfDir = normalize(lightDirec + viewDir); \n"
+    "    float angleHalf = acos(dot(halfDir, PNormal)); \n"
+    "    float exponent = angleHalf / 0.05; \n"
+    "    float specular = 0.0; \n"
+    "    if (diffuse > 0.0) \n"
+    "        specular = exp(-exponent * exponent); \n"
+
+    "    vec3 lightRes = PColour.rgb * ( liAmbient + liDiffuse ); \n"
+    "    // Specular colour is quite similar as light colour \n"
+    "    lightRes += (0.2 * PColour.xyz + 0.8 * LiColour) * specular * attenu; \n"
+    "    lightRes = clamp(lightRes, 0.0, 1.0); \n"
+
+    "     return lightRes; \n"
+    "}\n"
+};
+
+// Fragment shader for the triangles
+const GLchar* triangFragmentShader =
+{
+    "#version 150 \n"
+
+    "uniform vec4 lightProps; // Position in View space, and intensity \n"
+    "uniform vec3 lightColour; \n"
+
+    "flat in vec4 theColour; \n"
+    "flat in vec3 theNormal; \n"
+    "in vec3 pointPos; \n"
+
+    "out vec4 fragColour; \n"
+
+    "// Declare this function \n"
+    "vec3 Illuminate(in vec4 LiProps, in vec3 LiColour, in vec4 PColour, \n"
+    "                in vec3 PNormal, in vec3 PPos); \n"
+
+    "void main(void) \n"
+    "{\n"
+    "    vec3 lightRes = Illuminate(lightProps, lightColour, theColour, \n"
+    "                               theNormal, pointPos); \n "
+
+    "    fragColour = vec4(lightRes, theColour.a); \n"
+    "}\n"
+};
+
+// Vertex shader for strings (textures) with illumination
+const GLchar* stringsVertexShader =
+{
+    "#version 150 \n"
+
+    "in vec3 in_sPosition; \n"
+    "in vec3 in_sNormal; \n"
+    "in vec2 in_TextPos; \n"
+    "uniform mat4 mMVP; \n"
+    "uniform mat4 mToViewSpace; \n"
+
+    "flat out vec3 theNormal; \n"
+    "out vec3 pointPos; \n"
+    "out vec2 textCoord; \n"
+
+    "void main(void) \n"
+    "{\n"
+    "    gl_Position = mMVP * vec4(in_sPosition, 1.0); \n"
+    "    textCoord = in_TextPos; \n"
+
+    "    // Operations in View Space \n"
+    "    vec4 temp4 = mToViewSpace * vec4(in_sPosition, 1.0); \n"
+    "    pointPos = temp4.xyz; \n"
+    "    temp4 = mToViewSpace * vec4(in_sNormal, 0.0); \n"
+    "    theNormal = normalize(temp4.xyz); \n"
+    "}\n"
+};
+
+// Fragment shader for strings (textures) with illumination
+const GLchar* stringsFragmentShader =
+{
+    "#version 150 \n"
+
+    "uniform vec4 lightProps; // Position in View space, and intensity \n"
+    "uniform vec3 lightColour; \n"
+    "uniform sampler2D stringTexture; \n"
+
+    "flat in vec3 theNormal; \n"
+    "in vec3 pointPos; \n"
+    "in vec2 textCoord; \n"
+
+    "out vec4 fragColour; \n"
+
+    "// Declare this function \n"
+    "vec3 Illuminate(in vec4 LiProps, in vec3 LiColour, in vec4 PColour, \n"
+    "                in vec3 PNormal, in vec3 PPos); \n"
+
+    "void main(void) \n"
+    "{\n"
+    "    vec4 colo4 = texture(stringTexture, textCoord); \n"
+    "    vec3 lightRes = Illuminate(lightProps, lightColour, colo4, \n"
+    "                               theNormal, pointPos); \n "
+
+    "    fragColour = vec4(lightRes, colo4.a); \n"
+    "}\n"
+};
+
+// Vertex shader for immutable strings (textures)
+const GLchar* stringsImmutableVS =
+{
+    "#version 150 \n"
+
+    "in vec3 in_sPosition; \n"
+    "in vec2 in_TextPos; \n"
+    "uniform mat4 mMVP; \n"
+    "out vec2 textCoord; \n"
+
+    "void main(void) \n"
+    "{\n"
+    "    gl_Position = mMVP * vec4(in_sPosition, 1.0); \n"
+    "    textCoord = in_TextPos; \n"
+    "}\n"
+};
+
+// Fragment shader for immutable strings (textures)
+const GLchar* stringsImmutableFS =
+{
+    "#version 150 \n"
+
+    "uniform sampler2D stringTexture; \n"
+    "in vec2 textCoord; \n"
+    "out vec4 fragColour; \n"
+
+    "void main(void) \n"
+    "{\n"
+    "    fragColour= texture(stringTexture, textCoord); \n"
+    "}\n"
+};
+
+
+// ----------------------------------------------------------------------------
+// myOGLShaders
+// ----------------------------------------------------------------------------
+
+myOGLShaders::myOGLShaders()
+{
+    m_proId = 0;
+    m_SHAinitializated = false;
+}
+
+myOGLShaders::~myOGLShaders()
+{
+    if ( m_proId )
+        CleanUp();
+}
+
+void myOGLShaders::CleanUp()
+{
+    StopUse();
+
+    glDeleteProgram(m_proId);
+
+    glFlush();
+}
+
+void myOGLShaders::AddCode(const GLchar* shaString, GLenum shaType)
+{
+    // The code is a null-terminated string
+    shaShas sv = {0, shaType, shaString};
+    m_shaCode.push_back(sv);
+}
+
+void myOGLShaders::AddAttrib(std::string name)
+{
+    shaVars sv = {0, name}; //We will set the location later
+    m_shaAttrib.push_back(sv);
+    // We don't check the max number of attribute locations (usually 16)
+}
+
+void myOGLShaders::AddUnif(std::string name)
+{
+    shaVars sv = {0, name};
+    m_shaUnif.push_back(sv);
+}
+
+// Inform GL of the locations in program for the vars for buffers used to feed
+// the shader. We use glBindAttribLocation (before linking the gl program) with
+// the location we want.
+// Since GL 3.3 we could avoid this using in the shader "layout(location=x)...".
+// The same names as in the shader must be previously set with AddAttrib()
+void myOGLShaders::SetAttribLocations()
+{
+    GLuint loc = 0;
+    for(shaVars_v::iterator it = m_shaAttrib.begin(); it != m_shaAttrib.end(); ++it)
+    {
+        it->loc = loc++;
+        glBindAttribLocation(m_proId, it->loc, it->name.c_str());
+    }
+}
+
+GLuint myOGLShaders::GetAttribLoc(std::string name)
+{
+    for (shaVars_v::iterator it = m_shaAttrib.begin(); it != m_shaAttrib.end(); ++it)
+    {
+        if ( it->name == name && it->loc != (GLuint)-1 )
+            return it->loc;
+    }
+
+    return (GLuint) -1;
+}
+
+// Store the locations in program for uniforms vars
+bool myOGLShaders::AskUnifLocations()
+{
+    for (shaVars_v::iterator it = m_shaUnif.begin(); it != m_shaUnif.end(); ++it)
+    {
+        GLint glret = glGetUniformLocation(m_proId, it->name.c_str());
+        if ( glret == -1 )
+        {
+            // Return now, this GPU program can not be used because we will
+            // pass data to unknown/unused uniform locations
+            return false;
+        }
+        it->loc = glret;
+    }
+
+    return true;
+}
+
+GLuint myOGLShaders::GetUnifLoc(std::string name)
+{
+    for (shaVars_v::iterator it = m_shaUnif.begin(); it != m_shaUnif.end(); ++it)
+    {
+        if ( it->name == name && it->loc != (GLuint)-1 )
+            return it->loc;
+    }
+
+    return (GLuint) -1;
+}
+
+// Create a GPU program from the given shaders
+void myOGLShaders::Init()
+{
+    MyOnGLError(myoglERR_CLEAR); //clear error stack
+
+    bool resC = false;
+    bool resL = false;
+
+    // GLSL code load and compilation
+    for (shaShas_v::iterator it = m_shaCode.begin(); it != m_shaCode.end(); ++it)
+    {
+        it->shaId = glCreateShader(it->typeSha);
+        glShaderSource(it->shaId, 1, &(it->scode), NULL);
+        MyOnGLError(myoglERR_SHADERCREATE);
+
+        resC = Compile(it->shaId);
+        if ( !resC )
+            break;
+    }
+
+    if ( resC )
+    {
+        // The program in the GPU
+        m_proId = glCreateProgram();
+        for (shaShas_v::iterator it = m_shaCode.begin(); it != m_shaCode.end(); ++it)
+        {
+            glAttachShader(m_proId, it->shaId);
+        }
+
+        SetAttribLocations(); //Before linking
+
+        resL = LinkProg(m_proId);
+    }
+
+    // We don't need them any more
+    for (shaShas_v::iterator it = m_shaCode.begin(); it != m_shaCode.end(); ++it)
+    {
+        if ( resC && it->shaId )
+        {
+            glDetachShader(m_proId, it->shaId);
+        }
+        glDeleteShader(it->shaId);
+    }
+
+    if ( !resC || !resL )
+        return;
+
+    // Log that shaders are OK
+    MyOnGLError(myoglERR_JUSTLOG, "Shaders successfully compiled and linked.");
+
+    // After linking, we can get locations for uniforms
+    m_SHAinitializated = AskUnifLocations();
+    if ( !m_SHAinitializated )
+        MyOnGLError(myoglERR_SHADERLOCATION, " Unused or unrecognized uniform.");
+}
+
+// Useful while developing: show shader compilation errors
+bool myOGLShaders::Compile(GLuint shaId)
+{
+    glCompileShader(shaId);
+
+    GLint Param = 0;
+    glGetShaderiv(shaId, GL_COMPILE_STATUS, &Param);
+
+    if ( Param == GL_FALSE )
+    {
+        glGetShaderiv(shaId, GL_INFO_LOG_LENGTH, &Param);
+
+        if ( Param > 0 )
+        {
+            GLchar* InfoLog = new GLchar[Param];
+            int nChars = 0;
+            glGetShaderInfoLog(shaId, Param, &nChars, InfoLog);
+            MyOnGLError(myoglERR_SHADERCOMPILE, InfoLog);
+            delete [] InfoLog;
+        }
+        return false;
+    }
+    return true;
+}
+
+// Useful while developing: show shader program linkage errors
+bool myOGLShaders::LinkProg(GLuint proId)
+{
+    glLinkProgram(proId);
+
+    GLint Param = 0;
+    glGetProgramiv(proId, GL_LINK_STATUS, &Param);
+
+    if ( Param == GL_FALSE )
+    {
+        glGetProgramiv(proId, GL_INFO_LOG_LENGTH, &Param);
+
+        if ( Param > 0 )
+        {
+            GLchar* InfoLog = new GLchar[Param];
+            int nChars = 0;
+            glGetProgramInfoLog(proId, Param, &nChars, InfoLog);
+            MyOnGLError(myoglERR_SHADERLINK, InfoLog);
+            delete [] InfoLog;
+        }
+        return false;
+    }
+    return true;
+}
+
+bool myOGLShaders::Use()
+{
+    if ( !m_SHAinitializated )
+        return false;
+
+    glUseProgram(m_proId);
+    return true;
+}
+
+void myOGLShaders::StopUse()
+{
+    glUseProgram(0);
+}
+
+// Disable generic attributes from VAO.
+// This should be needed only for some old card, which uses generic into VAO
+void myOGLShaders::DisableGenericVAA()
+{
+    for(shaVars_v::iterator it = m_shaAttrib.begin(); it != m_shaAttrib.end(); ++it)
+    {
+        glDisableVertexAttribArray(it->loc);
+    }
+}
+
+
+// ----------------------------------------------------------------------------
+// A point light
+// ----------------------------------------------------------------------------
+
+void myLight::Set(const myVec3& position, GLfloat intensity,
+                  GLfloat R, GLfloat G, GLfloat B)
+{
+    m_PosAndIntensisty[0] = position.x;
+    m_PosAndIntensisty[1] = position.y;
+    m_PosAndIntensisty[2] = position.z;
+    m_PosAndIntensisty[3] = intensity;
+    m_Colour[0] = R;
+    m_Colour[1] = G;
+    m_Colour[2] = B;
+}
+
+
+// ----------------------------------------------------------------------------
+// myOGLTriangles
+// ----------------------------------------------------------------------------
+myOGLTriangles::myOGLTriangles()
+{
+    m_triangVAO = m_bufVertId = m_bufColNorId = m_bufIndexId = 0;
+    m_triangShaders = NULL;
+}
+
+myOGLTriangles::~myOGLTriangles()
+{
+    Clear();
+}
+
+void myOGLTriangles::Clear()
+{
+    if ( m_triangShaders )
+        m_triangShaders->DisableGenericVAA();
+
+    // Clear graphics card memory
+    glBindBuffer(GL_ARRAY_BUFFER, 0);
+    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+    if ( m_bufIndexId )
+        glDeleteBuffers(1, &m_bufIndexId);
+    if ( m_bufColNorId )
+        glDeleteBuffers(1, &m_bufColNorId);
+    if ( m_bufVertId )
+        glDeleteBuffers(1, &m_bufVertId);
+
+    // Unbind from context
+    glBindVertexArray(0);
+    if ( m_triangVAO )
+        glDeleteVertexArrays(1, &m_triangVAO);
+
+    glFlush(); //Tell GL to execute those commands now, but we don't wait for them
+
+    m_triangShaders = NULL;
+    m_triangVAO = m_bufIndexId = m_bufColNorId = m_bufVertId = 0;
+}
+
+void myOGLTriangles::SetBuffers(myOGLShaders* theShader,
+                                GLsizei nuPoints, GLsizei nuTriangs,
+                                const GLfloat* vert, const GLfloat* colo,
+                                const GLfloat* norm, const GLushort* indices)
+{
+    MyOnGLError(myoglERR_CLEAR); //clear error stack
+
+    // NOTE: have you realized that I fully trust on parameters being != 0 and != NULL?
+
+    // Part 1: Buffers - - - - - - - - - - - - - - - - - - -
+
+    // Graphics card buffer for vertices.
+    // Not shared buffer with colours and normals, why not? Just for fun.
+    glGenBuffers(1, &m_bufVertId);
+    glBindBuffer(GL_ARRAY_BUFFER, m_bufVertId);
+    // Populate the buffer with the array "vert"
+    GLsizeiptr nBytes = nuPoints * 3 * sizeof(GLfloat); //3 components {x,y,z}
+    glBufferData(GL_ARRAY_BUFFER, nBytes, vert, GL_STATIC_DRAW);
+
+    if ( ! MyOnGLError(myoglERR_BUFFER) )
+    {
+        // Likely the GPU got out of memory
+        Clear();
+        return;
+    }
+
+    // Graphics card buffer for colours and normals.
+    glGenBuffers(1, &m_bufColNorId);
+    glBindBuffer(GL_ARRAY_BUFFER, m_bufColNorId);
+    // Allocate space for both arrays
+    nBytes = (nuPoints * 4 + nuTriangs * 3) * sizeof(GLfloat);
+    glBufferData(GL_ARRAY_BUFFER, nBytes, NULL, GL_STATIC_DRAW);
+    if ( ! MyOnGLError(myoglERR_BUFFER) )
+    {
+        // Likely the GPU got out of memory
+        Clear();
+        return;
+    }
+    // Populate part of the buffer with the array "colo"
+    nBytes = nuPoints * 4 * sizeof(GLfloat); // rgba components
+    glBufferSubData(GL_ARRAY_BUFFER, 0, nBytes, colo);
+    // Add the array "norm" to the buffer
+    GLsizeiptr bufoffset = nBytes;
+    nBytes = nuTriangs * 3 * sizeof(GLfloat);
+    glBufferSubData(GL_ARRAY_BUFFER, bufoffset, nBytes, norm);
+
+    // Graphics card buffer for indices.
+    glGenBuffers(1, &m_bufIndexId);
+    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_bufIndexId);
+    // Populate the buffer with the array "indices"
+    // We use "triangle strip". An index for each additional vertex.
+    nBytes = (3 + nuTriangs - 1) * sizeof(GLushort); //Each triangle needs 3 indices
+    glBufferData(GL_ELEMENT_ARRAY_BUFFER, nBytes, indices, GL_STATIC_DRAW);
+
+    if ( ! MyOnGLError(myoglERR_BUFFER) )
+    {
+        // Likely the GPU got out of memory
+        Clear();
+        return;
+    }
+
+    // Unbind buffers. We will bind them one by one just now, at VAO creation
+    glBindBuffer(GL_ARRAY_BUFFER, 0);
+    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+
+    m_nuTriangs = nuTriangs;
+    m_triangShaders = theShader;
+
+    MyOnGLError(myoglERR_CLEAR); //clear error stack
+
+    // Part 2: VAO - - - - - - - - - - - - - - - - - - -
+
+    // Vertex Array Object (VAO) that stores the relationship between the
+    // buffers and the shader input attributes
+    glGenVertexArrays(1, &m_triangVAO);
+    glBindVertexArray(m_triangVAO);
+
+    // Set the way of reading (blocks of n floats each) from the current bound
+    // buffer and passing data to the shader (through the index of an attribute).
+    // Vertices positions
+    glBindBuffer(GL_ARRAY_BUFFER, m_bufVertId);
+    GLuint loc = m_triangShaders->GetAttribLoc("in_Position");
+    glEnableVertexAttribArray(loc);
+    glVertexAttribPointer(loc, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid *)0);
+    // Colours
+    glBindBuffer(GL_ARRAY_BUFFER, m_bufColNorId);
+    loc = m_triangShaders->GetAttribLoc("in_Colour");
+    glEnableVertexAttribArray(loc);
+    glVertexAttribPointer(loc, 4, GL_FLOAT, GL_FALSE, 0, (GLvoid *)0);
+    // Normals. Their position in buffer starts at bufoffset
+    loc = m_triangShaders->GetAttribLoc("in_Normal");
+    glEnableVertexAttribArray(loc);
+    glVertexAttribPointer(loc, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid *)bufoffset);
+    // Indices
+    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_bufIndexId);
+
+    // Unbind
+    glBindVertexArray(0);
+    glBindBuffer(GL_ARRAY_BUFFER, 0);
+    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+
+    // Some log
+    MyOnGLError(myoglERR_JUSTLOG, "Triangles data loaded into GPU.");
+}
+
+void myOGLTriangles::Draw(const GLfloat* unifMvp, const GLfloat* unifToVw,
+                          const myLight* theLight)
+{
+    if ( !m_triangVAO )
+        return;
+
+    MyOnGLError(myoglERR_CLEAR); //clear error stack
+
+    if ( ! m_triangShaders->Use() )
+        return;
+
+    // Bind the source data for the shader
+    glBindVertexArray(m_triangVAO);
+
+    // Pass matrices to the shader in column-major order
+    glUniformMatrix4fv(m_triangShaders->GetUnifLoc("mMVP"), 1, GL_FALSE, unifMvp);
+    glUniformMatrix4fv(m_triangShaders->GetUnifLoc("mToViewSpace"), 1, GL_FALSE, unifToVw);
+    // Pass the light, in View coordinates in this sample
+    glUniform4fv(m_triangShaders->GetUnifLoc("lightProps"), 1, theLight->GetFLightPos());
+    glUniform3fv(m_triangShaders->GetUnifLoc("lightColour"), 1, theLight->GetFLightColour());
+
+    // We have a flat shading, and we want the first vertex data as the flat value
+    glProvokingVertex(GL_FIRST_VERTEX_CONVENTION);
+
+    // Indexed drawing the triangles in strip mode, using 6 indices
+    glDrawElements(GL_TRIANGLE_STRIP, 6, GL_UNSIGNED_SHORT, (GLvoid *)0);
+
+    MyOnGLError(myoglERR_DRAWING_TRI);
+
+   // Unbind
+    glBindVertexArray(0);
+    m_triangShaders->StopUse();
+}
+
+
+// ----------------------------------------------------------------------------
+// myOGLString
+// ----------------------------------------------------------------------------
+myOGLString::myOGLString()
+{
+    m_bufPosId = m_textureId = m_stringVAO = m_textureUnit = 0;
+    m_stringShaders = NULL;
+}
+
+myOGLString::~myOGLString()
+{
+    Clear();
+}
+
+void myOGLString::Clear()
+{
+    if ( m_stringShaders )
+        m_stringShaders->DisableGenericVAA();
+
+    // Clear graphics card memory
+    glBindBuffer(GL_ARRAY_BUFFER, 0);
+    if ( m_bufPosId )
+        glDeleteBuffers(1, &m_bufPosId);
+
+    // Unbind from context
+    glBindVertexArray(0);
+    glDeleteVertexArrays(1, &m_stringVAO);
+
+    if ( m_textureUnit && m_textureId )
+    {
+        glActiveTexture(GL_TEXTURE0 + m_textureUnit);
+        glBindTexture(GL_TEXTURE_2D, 0);
+        glDeleteTextures(1, &m_textureId);
+    }
+    glActiveTexture(GL_TEXTURE0);
+
+    glFlush(); //Tell GL to execute those commands now, but we don't wait for them
+
+    m_bufPosId = m_textureId = m_stringVAO = m_textureUnit = 0;
+    m_stringShaders = NULL;
+}
+
+void myOGLString::SetStringWithVerts(myOGLShaders* theShader,
+                             const unsigned char* tImage, int tWidth, int tHeigh,
+                             const GLfloat* vert, const GLfloat* norm)
+{
+    MyOnGLError(myoglERR_CLEAR); //clear error stack
+
+    if ( !tImage )
+        return;
+
+    // Part 1: Buffers - - - - - - - - - - - - - - - - - - -
+
+    // Graphics card buffer for vertices, normals, and texture coords
+    glGenBuffers(1, &m_bufPosId);
+    glBindBuffer(GL_ARRAY_BUFFER, m_bufPosId);
+    // (4+4) (vertices + normals) x 3 components + 4 text-vertices x 2 components
+    GLsizeiptr nBytes = (8 * 3 + 4 * 2) * sizeof(GLfloat);
+    glBufferData(GL_ARRAY_BUFFER, nBytes, NULL, GL_STATIC_DRAW);
+
+    if ( ! MyOnGLError(myoglERR_BUFFER) )
+    {
+        // Likely the GPU got out of memory
+        Clear();
+        return;
+    }
+
+    // Populate part of the buffer with the array "vert"
+    nBytes = 12 * sizeof(GLfloat);
+    glBufferSubData(GL_ARRAY_BUFFER, 0, nBytes, vert);
+    // Add the array "norm" to the buffer
+    GLsizeiptr bufoffset = nBytes;
+    if ( norm )
+    {
+        // Just for string on face, not immutable string
+        glBufferSubData(GL_ARRAY_BUFFER, bufoffset, nBytes, norm);
+    }
+
+    // Add the array of texture coordinates to the buffer.
+    // Order is set accordingly with the vertices
+    // See myOGLManager::SetStringOnPyr()
+    GLfloat texcoords[8] = { 0.0, 1.0,  0.0, 0.0,  1.0, 1.0,  1.0, 0.0 };
+    bufoffset += nBytes;
+    nBytes = 8 * sizeof(GLfloat);
+    glBufferSubData(GL_ARRAY_BUFFER, bufoffset, nBytes, texcoords);
+
+    m_stringShaders = theShader;
+
+    MyOnGLError(myoglERR_CLEAR); //clear error stack
+
+    // Part 2: VAO - - - - - - - - - - - - - - - - - - -
+
+    // Vertex Array Object (VAO) that stores the relationship between the
+    // buffers and the shader input attributes
+    glGenVertexArrays(1, &m_stringVAO);
+    glBindVertexArray(m_stringVAO);
+
+    // Set the way of reading (blocks of n floats each) from the current bound
+    // buffer and passing data to the shader (through the index of an attribute).
+    // Vertices positions
+    GLuint loc = m_stringShaders->GetAttribLoc("in_sPosition");
+    glEnableVertexAttribArray(loc);
+    glVertexAttribPointer(loc, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid *)0);
+    // Normals. Their position in buffer starts at bufoffset
+    bufoffset = 12 * sizeof(GLfloat);
+    if ( norm )
+    {
+        // Just for string on face, not immutable string
+        loc = m_stringShaders->GetAttribLoc("in_sNormal");
+        glEnableVertexAttribArray(loc);
+        glVertexAttribPointer(loc, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid *)bufoffset);
+    }
+    // Texture coordinates
+    bufoffset *= 2; //Normals take same amount of space as vertices
+    loc = m_stringShaders->GetAttribLoc("in_TextPos");
+    glEnableVertexAttribArray(loc);
+    glVertexAttribPointer(loc, 2, GL_FLOAT, GL_FALSE, 0, (GLvoid *)bufoffset);
+
+    // Part 3: The texture with the string as an image - - - - - - - -
+
+    // Create the bind for the texture
+    // Same unit for both textures (strings) since their characteristics are the same.
+    m_textureUnit = 1;
+    glActiveTexture(GL_TEXTURE0 + m_textureUnit);
+    glGenTextures(1, &m_textureId); //"Name" of the texture object
+    glBindTexture(GL_TEXTURE_2D, m_textureId);
+    // Avoid some artifacts
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+    // Do this before glTexImage2D because we only have 1 level, no mipmap
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);
+    // For RGBA default alignment (4) is good. In other circumstances, we may
+    // need glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
+    // Load texture into card. No mipmap, so 0-level
+    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
+                 (GLsizei)tWidth, (GLsizei)tHeigh, 0,
+                  GL_RGBA, GL_UNSIGNED_BYTE, tImage);
+    if ( ! MyOnGLError(myoglERR_TEXTIMAGE) )
+    {
+        // Likely the GPU got out of memory
+        Clear();
+        return;
+    }
+
+    // Unbind
+    glBindVertexArray(0);
+    glBindBuffer(GL_ARRAY_BUFFER, 0);
+    glBindTexture(GL_TEXTURE_2D, 0);
+    glActiveTexture(GL_TEXTURE0);
+
+    // Some log
+    MyOnGLError(myoglERR_JUSTLOG, "Texture for string loaded into GPU.");
+}
+
+void myOGLString::Draw(const GLfloat* unifMvp, const GLfloat* unifToVw,
+                       const myLight* theLight)
+{
+    if ( !m_stringVAO )
+        return;
+
+    MyOnGLError(myoglERR_CLEAR); //clear error stack
+
+    if ( ! m_stringShaders->Use() )
+        return;
+
+    // Bind the source data for the shader
+    glBindVertexArray(m_stringVAO);
+
+    // Pass matrices to the shader in column-major order
+    glUniformMatrix4fv(m_stringShaders->GetUnifLoc("mMVP"), 1, GL_FALSE, unifMvp);
+    if ( unifToVw && theLight )
+    {
+        // Just for string on face, not immutable string
+        glUniformMatrix4fv(m_stringShaders->GetUnifLoc("mToViewSpace"), 1, GL_FALSE, unifToVw);
+        // Pass the light, in View coordinates in this sample
+        glUniform4fv(m_stringShaders->GetUnifLoc("lightProps"), 1, theLight->GetFLightPos());
+        glUniform3fv(m_stringShaders->GetUnifLoc("lightColour"), 1, theLight->GetFLightColour());
+
+        // We have a flat shading, and we want the first vertex normal as the flat value
+        glProvokingVertex(GL_FIRST_VERTEX_CONVENTION);
+    }
+
+    // Use our texture unit
+    glActiveTexture(GL_TEXTURE0 + m_textureUnit);
+    glBindTexture(GL_TEXTURE_2D, m_textureId);
+    // The fragment shader will read texture values (pixels) from the texture
+    // currently active
+    glUniform1i(m_stringShaders->GetUnifLoc("stringTexture"), m_textureUnit);
+
+    // Draw the rectangle made up of two triangles
+    glDrawArrays(GL_TRIANGLE_STRIP, 0,  4);
+
+    MyOnGLError(myoglERR_DRAWING_STR);
+
+    // Unbind
+    glBindVertexArray(0);
+    glBindTexture(GL_TEXTURE_2D, 0);
+    glActiveTexture(GL_TEXTURE0);
+
+    m_stringShaders->StopUse();
+}
+
+// ----------------------------------------------------------------------------
+// myOGLImmutString
+// ----------------------------------------------------------------------------
+void myOGLImmutString::SetImmutString(myOGLShaders* theShader,
+                        const unsigned char* tImage, int tWidth, int tHeigh)
+{
+    // Make a rectangle of the same size as the image. Order of vertices matters.
+    // Set a 2 pixels margin
+    GLfloat imaVerts[12];
+    imaVerts[0] = 2.0         ;   imaVerts[1] = 2.0         ; imaVerts[2]  = -1.0;
+    imaVerts[3] = 2.0         ;   imaVerts[4] = 2.0 + tHeigh; imaVerts[5]  = -1.0;
+    imaVerts[6] = 2.0 + tWidth;   imaVerts[7] = 2.0         ; imaVerts[8]  = -1.0;
+    imaVerts[9] = 2.0 + tWidth;  imaVerts[10] = 2.0 + tHeigh; imaVerts[11] = -1.0;
+
+    // Call the base class without normals, it will handle this case
+    SetStringWithVerts(theShader, tImage, tWidth, tHeigh, imaVerts, NULL);
+}
+
+void myOGLImmutString::SetOrtho(int winWidth, int winHeight)
+{
+    // We want an image always of the same size, regardless of window size.
+    // The orthogonal projection with the whole window achieves it.
+    MyOrtho(0.0, winWidth, 0.0, winHeight, -1.0, 1.0, m_fOrtho);
+}
+
+
+// ----------------------------------------------------------------------------
+// myOGLCamera
+// ----------------------------------------------------------------------------
+myOGLCamera::myOGLCamera()
+{
+    m_needMVPUpdate = true; //Matrix must be updated
+    InitPositions();
+}
+
+void myOGLCamera::InitPositions()
+{
+    // We have a tetrahedron centered at origin and edge length = 200
+    m_centerOfWorld.x = m_centerOfWorld.y = m_centerOfWorld.z = 0.0;
+
+    // The radius of the bounding sphere
+    m_radiusOfWorld = 122.4745;
+
+    // From degrees to radians
+    double degToRad = (double) 4.0 * atan(1.0) / 180.0;
+
+    // Angle of the field of view
+    m_fov = 40.0 * degToRad; //radians
+
+    // Position the camera far enough so we can see the whole world.
+    // The camera is between X and Z axis, below the pyramid
+    double tmpv = m_radiusOfWorld / sin(m_fov/2.0);
+    tmpv *= 1.05; // 5% margin
+    m_camPosition.x = m_centerOfWorld.x + tmpv * cos(75.0 * degToRad);
+    m_camPosition.z = m_centerOfWorld.z + tmpv * sin(75.0 * degToRad);
+    m_camPosition.y = m_centerOfWorld.y - m_radiusOfWorld;
+
+    // This camera looks always at center
+    m_camTarget = m_centerOfWorld;
+
+    // A vector perpendicular to Position-Target heading Y+
+    myVec3 vper = MyNormalize(m_camTarget - m_camPosition);
+    m_camUp = myVec3(0.0, 1.0, 0.0);
+    m_camUp = MyCross(m_camUp, vper);
+    m_camUp = MyNormalize( MyCross(vper, m_camUp) );
+
+    tmpv = MyDistance(m_camPosition, m_centerOfWorld);
+    // Calculate distances, not coordinates, with some margins
+    // Near clip-plane distance to the camera
+    m_nearD = tmpv - 1.10 * m_radiusOfWorld - 5.0;
+    // Far clip-plane distance to the camera
+    m_farD = tmpv + 1.10 * m_radiusOfWorld + 5.0;
+
+    // The "View" matrix. We will not change it any more in this sample
+    MyLookAt(m_camPosition, m_camUp, m_camTarget, m_fView);
+
+    // The initial "Model" matrix is the Identity matrix
+    MyRotate(myVec3(0.0, 0.0, 1.0), 0.0, m_fMode);
+
+    // Nothing else. "View" matrix is calculated at ViewSizeChanged()
+}
+
+void myOGLCamera::ViewSizeChanged(int newWidth, int newHeight)
+{
+    // These values are also used for MouseRotation()
+    m_winWidth = newWidth;
+    m_winHeight = newHeight;
+
+    // Calculate the projection matrix
+    double aspect = (double) newWidth / newHeight;
+    MyPerspective(m_fov, aspect, m_nearD, m_farD, m_fProj);
+
+    // Inform we need to calculate MVP matrix
+    m_needMVPUpdate = true;
+}
+
+const GLfloat* myOGLCamera::GetFloatMVP()
+{
+    UpdateMatrices();
+
+    return m_fMVP;
+}
+
+const GLfloat* myOGLCamera::GetFloatToVw()
+{
+    UpdateMatrices();
+
+    return m_fToVw;
+}
+
+void myOGLCamera::UpdateMatrices()
+{
+   if ( m_needMVPUpdate )
+    {
+        MyMatMul4x4(m_fView, m_fMode, m_fToVw);
+        MyMatMul4x4(m_fProj, m_fToVw, m_fMVP);
+        m_needMVPUpdate = false;
+    }
+}
+
+void myOGLCamera::MouseRotation(int fromX, int fromY, int toX, int toY)
+{
+    if ( fromX == toX && fromY == toY )
+        return; //no rotation
+
+    // 1. Obtain axis of rotation and angle simulating a virtual trackball "r"
+
+    // 1.1. Calculate normalized coordinates (2x2x2 box).
+    // The trackball is a part of sphere of radius "r" (the rest is hyperbolic)
+    // Use r= 0.8 for better maximum rotation (more-less 150 degrees)
+    double xw1 = (2.0 * fromX - m_winWidth) / m_winWidth;
+    double yw1 = (2.0 * fromY - m_winHeight) / m_winHeight;
+    double xw2 = (2.0 * toX - m_winWidth) / m_winWidth;
+    double yw2 = (2.0 * toY - m_winHeight) / m_winHeight;
+    double z1 = GetTrackballZ(xw1, yw1, 0.8);
+    double z2 = GetTrackballZ(xw2, yw2, 0.8);
+
+    // 1.2. With normalized vectors, compute axis from 'cross' and angle from 'dot'
+    myVec3 v1(xw1, yw1, z1);
+    myVec3 v2(xw2, yw2, z2);
+    v1 = MyNormalize(v1);
+    v2 = MyNormalize(v2);
+    myVec3 axis(MyCross(v1, v2));
+
+    // 'axis' is in camera coordinates. Transform it to world coordinates.
+    float mtmp[16];
+    MyMatInverse(m_fView, mtmp);
+    myVec4 res = MyMatMul4x1(mtmp, myVec4(axis));
+    axis.x = res.x;
+    axis.y = res.y;
+    axis.z = res.z;
+    axis = MyNormalize(axis);
+
+    double angle = AngleBetween(v1, v2);
+
+    // 2. Compute the model transformation (rotate the model) matrix
+    MyRotate(axis, angle, mtmp);
+    // Update "Model" matrix
+    float mnew[16];
+    MyMatMul4x4(mtmp, m_fMode, mnew);
+    for (size_t i = 0; i<16; ++i)
+        m_fMode[i] = mnew[i];
+
+    // Inform we need to calculate MVP matrix
+    m_needMVPUpdate = true;
+}
+
+// Return the orthogonal projection of (x,y) into a sphere centered on the screen
+// and radius 'r'. This makes some (x,y) to be outside of circle r='r'. We avoid
+// this issue by using a hyperbolic sheet for (x,y) outside of r = 0.707 * 'r'.
+double myOGLCamera::GetTrackballZ(double x, double y, double r)
+{
+    double d = x*x + y*y;
+    double r2 = r*r;
+    return  (d < r2/2.0) ? sqrt(r2 - d) : r2/2.0/sqrt(d);
+}
+
+
+// ----------------------------------------------------------------------------
+// myOGLManager
+// ----------------------------------------------------------------------------
+
+myOGLManager::myOGLManager(myOGLErrHandler* extErrHnd)
+{
+     externalMyOGLErrHandler = extErrHnd;
+}
+
+myOGLManager::~myOGLManager()
+{
+    MyOnGLError(myoglERR_CLEAR); //clear error stack
+
+    // Force GPU finishing before the context is deleted
+    glFinish();
+}
+
+bool myOGLManager::Init()
+{
+    // Init glew.
+    // glew 1.12.0 needs using glewExperimental to force finding pointer functions
+    glewExperimental = GL_TRUE;
+    if ( GLEW_OK != glewInit() )
+    {
+        // Problem: glewInit failed, something is seriously wrong.
+        return false;
+    }
+
+    MyOnGLError(myoglERR_CLEAR); //clear error stack
+
+    return true;
+}
+
+const GLubyte* myOGLManager::GetGLVersion()
+{
+    return glGetString(GL_VERSION);
+}
+
+void myOGLManager::SetShadersAndTriangles()
+{
+    // The shaders attributes and uniforms
+    m_TriangShaders.AddAttrib("in_Position");
+    m_TriangShaders.AddAttrib("in_Colour");
+    m_TriangShaders.AddAttrib("in_Normal");
+    m_TriangShaders.AddUnif("mMVP");
+    m_TriangShaders.AddUnif("mToViewSpace");
+    m_TriangShaders.AddUnif("lightProps");
+    m_TriangShaders.AddUnif("lightColour");
+    m_TriangShaders.AddCode(triangVertexShader, GL_VERTEX_SHADER);
+    m_TriangShaders.AddCode(illuminationShader, GL_FRAGMENT_SHADER);
+    m_TriangShaders.AddCode(triangFragmentShader, GL_FRAGMENT_SHADER);
+    m_TriangShaders.Init();
+    m_StringShaders.AddAttrib("in_sPosition");
+    m_StringShaders.AddAttrib("in_sNormal");
+    m_StringShaders.AddAttrib("in_TextPos");
+    m_StringShaders.AddUnif("mMVP");
+    m_StringShaders.AddUnif("mToViewSpace");
+    m_StringShaders.AddUnif("lightProps");
+    m_StringShaders.AddUnif("lightColour");
+    m_StringShaders.AddUnif("stringTexture");
+    m_StringShaders.AddCode(stringsVertexShader, GL_VERTEX_SHADER);
+    m_StringShaders.AddCode(illuminationShader, GL_FRAGMENT_SHADER);
+    m_StringShaders.AddCode(stringsFragmentShader, GL_FRAGMENT_SHADER);
+    m_StringShaders.Init();
+    m_ImmutStringSha.AddAttrib("in_sPosition");
+    m_ImmutStringSha.AddAttrib("in_TextPos");
+    m_ImmutStringSha.AddUnif("mMVP");
+    m_ImmutStringSha.AddUnif("stringTexture");
+    m_ImmutStringSha.AddCode(stringsImmutableVS, GL_VERTEX_SHADER);
+    m_ImmutStringSha.AddCode(stringsImmutableFS, GL_FRAGMENT_SHADER);
+    m_ImmutStringSha.Init();
+    // The point light. Set its color as full white.
+    // In this sample we set the light position same as the camera position
+    // In View space, camera position is {0, 0, 0}
+    m_Light.Set(myVec3(0.0, 0.0, 0.0), 1.0, 1.0, 1.0, 1.0);
+    // The triangles data
+    m_Triangles.SetBuffers(&m_TriangShaders, 4, 4, gVerts, gColours, gNormals, gIndices);
+}
+
+void myOGLManager::SetStringOnPyr(const unsigned char* strImage, int iWidth, int iHeigh)
+{
+    // Some geometry. We want a rectangle close to face 0-1-2 (X-Z plane).
+    // The rectangle must preserve strImage proportions. If the height of the
+    // rectangle is "h" and we want to locate it with its largest side parallel
+    // to the edge of the face and at distance= h/2, then the rectangle width is
+    // rw = edgeLength - 2 * ((h/2 + h + h/2)/tan60) = edgeLength - 4*h/sqrt(3)
+    // If h/rw = Prop then
+    //    rw = edgeLength / (1+4/sqrt(3)*Prop) and h = Prop * rw
+
+    GLfloat edgeLen = MyDistance(myVec3(gVerts[0], gVerts[1], gVerts[2]),
+                                 myVec3(gVerts[6], gVerts[7], gVerts[8]));
+    GLfloat prop = (double) iHeigh / iWidth;
+    GLfloat rw = (double) edgeLen / (1 + 4.0 * prop / sqrt(3.0));
+    GLfloat h = prop * rw;
+    GLfloat de = 2.0 * h / sqrt(3.0);
+    // A bit of separation of the face so as to avoid z-fighting
+    GLfloat rY = gVerts[1] - 0.01; // Towards outside
+    GLfloat sVerts[12];
+    // The image was created top to bottom, but OpenGL axis are bottom to top.
+    // The image would display upside down. We avoid it choosing the right
+    // order of vertices and texture coords. See myOGLString::SetStringWithVerts()
+    sVerts[0] = gVerts[6] + de;  sVerts[1] = rY;   sVerts[2] = gVerts[8] + h / 2.0;
+    sVerts[3] = sVerts[0]     ;  sVerts[4] = rY;   sVerts[5] = sVerts[2] + h;
+    sVerts[6] = sVerts[0] + rw;  sVerts[7] = rY;   sVerts[8] = sVerts[2];
+    sVerts[9] = sVerts[6]     ; sVerts[10] = rY;  sVerts[11] = sVerts[5];
+
+    // Normals for the rectangle illumination, same for the four vertices
+    const GLfloat strNorms[] = { gNormals[0], gNormals[1], gNormals[2],
+                                 gNormals[0], gNormals[1], gNormals[2],
+                                 gNormals[0], gNormals[1], gNormals[2],
+                                 gNormals[0], gNormals[1], gNormals[2]};
+
+    // The texture data for the string on the face of the pyramid
+    m_StringOnPyr.SetStringWithVerts(&m_StringShaders, strImage, iWidth, iHeigh,
+                                     sVerts, strNorms);
+}
+
+void myOGLManager::SetImmutableString(const unsigned char* strImage,
+                                      int iWidth, int iHeigh)
+{
+    m_ImmString.SetImmutString(&m_ImmutStringSha, strImage, iWidth, iHeigh);
+}
+
+void myOGLManager::SetViewport(int x, int y, int width, int height)
+{
+    if (width < 1) width = 1;
+    if (height < 1) height = 1;
+
+    glViewport(x, y, (GLsizei)width, (GLsizei)height);
+
+    // The camera handles perspective projection
+    m_Camera.ViewSizeChanged(width, height);
+    // And this object handles its own orthogonal projection
+    m_ImmString.SetOrtho(width, height);
+}
+
+void myOGLManager::Render()
+{
+    glEnable(GL_DEPTH_TEST);
+    glDepthFunc(GL_LEQUAL);
+    glEnable(GL_BLEND);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+    glClearColor(0.15, 0.15, 0.0 ,1.0); // Dark, but not black. Isn't it nice?
+    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
+
+    m_Triangles.Draw(m_Camera.GetFloatMVP(), m_Camera.GetFloatToVw(), &m_Light);
+    m_StringOnPyr.Draw(m_Camera.GetFloatMVP(), m_Camera.GetFloatToVw(), &m_Light);
+    // This string is at the very front, whatever z-coords are given
+    glDisable(GL_DEPTH_TEST);
+    m_ImmString.Draw(m_ImmString.GetFloatMVP(), NULL, NULL);
+}
+
+void myOGLManager::OnMouseButDown(int posX, int posY)
+{
+    // Just save mouse position
+    m_mousePrevX = posX;
+    m_mousePrevY = posY;
+}
+
+void myOGLManager::OnMouseRotDragging(int posX, int posY)
+{
+    m_Camera.MouseRotation(m_mousePrevX, m_mousePrevY, posX, posY);
+    m_mousePrevX = posX;
+    m_mousePrevY = posY;
+}
+
diff --git samples/opengl/pyramid/oglstuff.h samples/opengl/pyramid/oglstuff.h
new file mode 100755
index 0000000..626522f
--- /dev/null
+++ samples/opengl/pyramid/oglstuff.h
@@ -0,0 +1,338 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        oglstuff.h
+// Purpose:     OpenGL manager for pyramid sample
+// Author:      Manuel Martin
+// Modified by:
+// Created:     2015/01/31
+// Copyright:   (c)
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef OGLSTUFF_H
+  #define OGLSTUFF_H
+
+#include <string>
+#include <vector>
+
+#include "mathstuff.h"
+
+// This library allows access to OpenGL functions for all OpenGL versions.
+// http://glew.sourceforge.net/index.html
+//
+// Note: Don't forget to set the pre-processor flag GLEW_STATIC
+#include "GLEW/include/GL/glew.h"
+
+/*
+  ************  NOTES  *******************************************************
+  This is not an OGL tutorial, I mean, this is just a sample of how OGL stuff
+  may be arranged. I tried to keep it simple.
+  It's likely that the novice to OGL reads this sample, so here are some brief
+  notes:
+  * Starting with OpenGL >= 2.0 the user defines some special programs that are
+    going to be executed in the GPU, not in the CPU. These programs are called
+    "Shaders". Since OGL >= 3.2, and if a "Core Profile" context is set, the use
+    of shaders is the only way to make an OGL application.
+  * A program consists (at least) of a 'vertex shader' who operates on the
+    vertices that define the primitive (a triangle, a line, etc) and a 'fragment
+    shader' which deals with fragments (points) interpolated from the previously
+    processed vertices in the vertex shader.
+  * Shaders must be compiled and linked, both operations are done on the GPU.
+  * Shaders are written in the GLSL language, that looks like C, but it isn't C.
+  * Data (vertices, textures) are stored in GPU memory, so they don't need to be
+    loaded each time the scene must be redrawn.
+  * Rotations and translations are matrix operations that the GPU may do in the
+    [vertex]shaders. The user must define the needed matrices.
+  * A vertex shader defines special vars ("attributes") used for reading the
+    data from the GPU buffers. Other special vars ("uniforms") are used for
+    values that don't change with each vertex (i.e. the matrices).
+  * The relationship between a data buffer and the input attributes in a vertex
+    shader can be saved in a "Vertex Array Object" (VAO).
+
+  I use several classes for typical OGL jobs: Shaders, Data, Camera.
+  Because different GPU cards may behave on their own, I also use very often
+  an error-helper. It will inform of the point where something went wrong.
+
+  I decided to keep apart all of this from wxWidgets. You won't find anything
+  related to wxWidgets in the oglstuff[.h][.cpp] files.
+  That's why I use std::vector and std:string instead of those provided by wx.
+*/
+
+
+// Define our own GL errors
+enum
+{
+    myoglERR_CLEAR = 0,
+    myoglERR_JUSTLOG,
+
+    myoglERR_SHADERCREATE,
+    myoglERR_SHADERCOMPILE,
+    myoglERR_SHADERLINK,
+    myoglERR_SHADERLOCATION,
+
+    myoglERR_BUFFER,
+    myoglERR_TEXTIMAGE,
+
+    myoglERR_DRAWING_TRI,
+    myoglERR_DRAWING_STR
+};
+
+// Used to handle GL errors in other part of the app.
+typedef void myOGLErrHandler(int err, int glerr, const GLchar* glMsg);
+
+// For shader attributes
+struct shaVars
+{
+    GLuint loc; //The attribute "location", some kind of index in the shader
+    std::string name; //The name of the attribute
+};
+
+typedef std::vector<shaVars> shaVars_v;
+
+// For shader code
+struct shaShas
+{
+    GLuint shaId;
+    GLenum typeSha; //The type of shader
+    const GLchar* scode; //The NULL terminated GLSL code
+};
+
+typedef std::vector<shaShas> shaShas_v;
+
+
+//-----------------------------------------------------------------------------
+// This object builds a GPU program by joining several shaders.
+class myOGLShaders
+{
+public:
+    myOGLShaders();
+    ~myOGLShaders();
+
+    void Init();
+    bool Use();
+    void StopUse();
+    void CleanUp();
+
+    void AddCode(const GLchar* shaString, GLenum shaType);
+    void AddAttrib(std::string name);
+    void AddUnif(std::string name);
+    GLuint GetAttribLoc(std::string name);
+    GLuint GetUnifLoc(std::string name);
+    // Disable generic vertex attribute array
+    void DisableGenericVAA();
+
+private:
+    void SetAttribLocations();
+    bool AskUnifLocations();
+    bool Compile(GLuint shaId);
+    bool LinkProg(GLuint proId);
+
+    shaVars_v m_shaAttrib; // 'attributes' names and locations
+    shaVars_v m_shaUnif; // 'uniforms' names and locations
+    shaShas_v m_shaCode; // shaders code and their types
+    GLuint m_proId; // program Id
+
+    bool m_SHAinitializated;
+};
+
+//-----------------------------------------------------------------------------
+// A "point light"
+class myLight
+{
+public:
+    myLight() {}
+    ~myLight() {}
+
+    void Set(const myVec3& position, GLfloat intensity,
+             GLfloat R, GLfloat G, GLfloat B);
+    // Return position and intensity
+    const GLfloat* GetFLightPos() const
+        { return m_PosAndIntensisty; }
+    // Return colour
+    const GLfloat* GetFLightColour() const
+        { return m_Colour; }
+
+private:
+    // Light position and intensity
+    GLfloat m_PosAndIntensisty[4];
+    // Light colour
+    GLfloat m_Colour[3];
+};
+
+//-----------------------------------------------------------------------------
+// An object for triangles
+class myOGLTriangles
+{
+public:
+    myOGLTriangles();
+    ~myOGLTriangles();
+
+    // Clean up
+    void Clear();
+    // Load data into the GPU
+    void SetBuffers(myOGLShaders* theShader, GLsizei nuPoints, GLsizei nuTriangs,
+                    const GLfloat* vert, const GLfloat* colo,
+                    const GLfloat* norm, const GLushort* indices);
+
+    //Draw the triangles
+    void Draw(const GLfloat* unifMvp, const GLfloat* unifToVw,
+              const myLight* theLight);
+
+private:
+    GLsizei m_nuTriangs;
+    // Buffers ids
+    GLuint m_bufVertId;
+    GLuint m_bufColNorId;
+    GLuint m_bufIndexId;
+    // Vertex Arrays Object
+    GLuint m_triangVAO;
+    // GPU Program used to draw the triangles
+    myOGLShaders* m_triangShaders;
+};
+
+//-----------------------------------------------------------------------------
+// An object for strings
+class myOGLString
+{
+public:
+    myOGLString();
+    ~myOGLString();
+
+    // Clean up
+    void Clear();
+    // Load data into the GPU
+    void SetStringWithVerts(myOGLShaders* theShader,
+                             const unsigned char* tImage, int tWidth, int tHeigh,
+                             const GLfloat* vert, const GLfloat* norm);
+    // Draw the string
+    void Draw(const GLfloat* unifMvp, const GLfloat* unifToVw,
+              const myLight* theLight);
+
+
+private:
+    GLuint m_bufPosId;    // Buffer id
+    GLuint m_stringVAO;   // Vertex Arrays Object
+    GLuint m_textureUnit; // The context unit
+    GLuint m_textureId;   // Texture name
+    // GPU Program used to draw the texture
+    myOGLShaders* m_stringShaders;
+};
+
+//-----------------------------------------------------------------------------
+// An object for the immutable string
+class myOGLImmutString : public myOGLString
+{
+public:
+    myOGLImmutString(){}
+    ~myOGLImmutString(){}
+
+    // Load data into the GPU
+    void SetImmutString(myOGLShaders* theShader,
+                        const unsigned char* tImage, int tWidth, int tHeigh);
+    // Update orthogonal projection matrix
+    void SetOrtho(int winWidth, int winHeight);
+    // The transformation matrix
+    const GLfloat* GetFloatMVP() { return m_fOrtho; }
+
+private:
+    GLfloat m_fOrtho[16]; // The orthogonal projection matrix
+};
+
+//-----------------------------------------------------------------------------
+// The "camera", or the point of view
+class myOGLCamera
+{
+public:
+    myOGLCamera();
+    ~myOGLCamera() {}
+
+    // Initial positions
+    void InitPositions();
+    // When the size of the window changes
+    void ViewSizeChanged(int newWidth, int newHeight);
+    // The whole transformation matrix
+    const GLfloat* GetFloatMVP();
+    // The 'To View Space' transformation matrix
+    const GLfloat* GetFloatToVw();
+    // The camera position
+    myVec3 GetPosition() {return m_camPosition;}
+
+    // Simulates a virtual trackball and rotates the 'world'
+    void MouseRotation(int fromX, int fromY, int toX, int toY);
+    double GetTrackballZ(double x, double y, double r);
+
+    // The used matrices
+    GLfloat m_fMode[16]; // The model matrix, rotation in this sample
+    GLfloat m_fView[16]; // The view matrix
+    GLfloat m_fProj[16]; // The projection matrix
+    GLfloat m_fMVP[16];  // The whole transform matrix
+    GLfloat m_fToVw[16]; // The 'to View' transform matrix
+private:
+    bool m_needMVPUpdate;
+
+    void UpdateMatrices();
+
+    // Coordinates in model space
+    myVec3 m_centerOfWorld;
+    double m_radiusOfWorld;
+    myVec3 m_camPosition;
+    myVec3 m_camTarget;
+    myVec3 m_camUp;
+
+    // Window size in pixels
+    int m_winWidth;
+    int m_winHeight;
+
+    // Parameters for the projection
+    double m_fov;
+    double m_nearD;
+    double m_farD;
+};
+
+//-----------------------------------------------------------------------------
+// General manager
+class myOGLManager
+{
+public:
+    myOGLManager(myOGLErrHandler* extErrHnd = NULL);
+    ~myOGLManager();
+
+    // Glew init
+    bool Init();
+    // A string describing the current GL connection
+    const GLubyte* GetGLVersion();
+
+    // Load data into the GPU
+    void SetShadersAndTriangles();
+    // Load the texture for the string in the pyramid
+    void SetStringOnPyr(const unsigned char* strImage, int iWidth, int iHeigh);
+    // Load the texture for the immutable string
+    void SetImmutableString(const unsigned char* strImage, int iWidth, int iHeigh);
+
+    // For window size change
+    void SetViewport(int x, int y, int width, int height);
+
+    void Render(); // Total rendering
+
+    // Action events in OpenGL win coordinates (bottom is y=0)
+    void OnMouseButDown(int posX, int posY);
+    void OnMouseRotDragging(int posX, int posY);
+
+private:
+    // Members
+    myOGLShaders   m_TriangShaders;
+    myOGLShaders   m_StringShaders;
+    myOGLShaders   m_ImmutStringSha;
+    myLight        m_Light;
+    myOGLCamera    m_Camera;
+
+    myOGLTriangles    m_Triangles;
+    myOGLString       m_StringOnPyr;
+    myOGLImmutString  m_ImmString;
+
+    // For mouse event
+    int m_mousePrevX;
+    int m_mousePrevY;
+};
+
+#endif //OGLSTUFF_H
+
diff --git samples/opengl/pyramid/pyramid.bkl samples/opengl/pyramid/pyramid.bkl
new file mode 100755
index 0000000..f6abc2e
--- /dev/null
+++ samples/opengl/pyramid/pyramid.bkl
@@ -0,0 +1,35 @@
+<?xml version="1.0" ?>
+
+<makefile>
+
+    <include file="../../../build/bakefiles/common_samples.bkl"/>
+
+    <if cond="OUT_OF_TREE_MAKEFILES=='1'">
+        <set var="USE_OPENGL">1</set>
+    </if>
+
+    <exe id="pyramid" template="wx_sample" template_append="wx_append" cond="USE_OPENGL=='1'">
+        <sources>
+            pyramid.cpp
+            oglstuff.cpp
+            mathstuff.cpp
+            GLEW/src/glew.c
+        </sources>
+        <headers>
+            pyramid.h
+            oglstuff.h
+            mathstuff.h
+            GLEW/include/GL/glew.h
+            GLEW/include/GL/glxew.h
+            GLEW/include/GL/wglew.h
+        </headers>
+
+        <define>GLEW_STATIC</define>
+        <include>GLEW/include</include>
+
+        <wx-lib>gl</wx-lib>
+        <wx-lib>core</wx-lib>
+        <wx-lib>base</wx-lib>
+    </exe>
+
+</makefile>
diff --git samples/opengl/pyramid/pyramid.cpp samples/opengl/pyramid/pyramid.cpp
new file mode 100755
index 0000000..bd0aa57
--- /dev/null
+++ samples/opengl/pyramid/pyramid.cpp
@@ -0,0 +1,511 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        pyramid.cpp
+// Purpose:     OpenGL version >= 3.2 sample
+// Author:      Manuel Martin
+// Modified by:
+// Created:     2015/01/31
+// Copyright:   (c)
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+// ============================================================================
+// declarations
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// headers
+// ----------------------------------------------------------------------------
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#ifndef WX_PRECOMP
+    #include "wx/wx.h"
+#endif
+
+#if !wxUSE_GLCANVAS
+    #error "OpenGL required: set wxUSE_GLCANVAS to 1 and rebuild the library"
+#endif
+
+// Due to glew.h needs to be included before gl.h, we include glcanvas.h after oglstuff.h
+#include "oglstuff.h"
+#include "wx/glcanvas.h"
+#include "pyramid.h"
+
+// The application icon (under Windows and OS/2 it is in resources and even
+// though we could still include the XPM here it would be unused)
+#ifndef wxHAS_IMAGES_IN_RESOURCES
+    #include "../sample.xpm"
+#endif
+
+wxBEGIN_EVENT_TABLE(MyFrame, wxFrame)
+    EVT_MENU(Pyramid_Quit,  MyFrame::OnQuit)
+    EVT_MENU(Pyramid_About, MyFrame::OnAbout)
+#if wxUSE_LOGWINDOW
+    EVT_MENU(Pyramid_LogW,  MyFrame::OnLogWindow)
+#endif // wxUSE_LOGWINDOW
+wxEND_EVENT_TABLE()
+
+IMPLEMENT_APP(MyApp)
+
+// ============================================================================
+// implementation
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// the application class
+// ----------------------------------------------------------------------------
+
+// 'Main program' equivalent: the program execution "starts" here
+bool MyApp::OnInit()
+{
+    if ( !wxApp::OnInit() )
+        return false;
+
+    // create the main application window
+    MyFrame* frame = new MyFrame("wxWidgets OpenGL Pyramid Sample");
+
+    // Linux needs the frame to be shown before we call SetCurrent()
+    frame->Show(true);
+    if ( !frame->CanvasInit() )
+        return false; // Some OGL error, likely no Core Profile
+
+    return true;
+}
+
+// ----------------------------------------------------------------------------
+// main frame
+// ----------------------------------------------------------------------------
+
+// frame constructor
+MyFrame::MyFrame(const wxString& title)
+       : wxFrame(NULL, wxID_ANY, title, wxDefaultPosition, wxSize(500, 400))
+{
+    // set the frame icon
+    SetIcon(wxICON(sample));
+
+#if wxUSE_MENUS
+    // create a menu bar
+    wxMenu *fileMenu = new wxMenu;
+
+    // the "About" item should be in the help menu
+    wxMenu *helpMenu = new wxMenu;
+    helpMenu->Append(Pyramid_About, "&About\tF1", "Show about dialog");
+
+#if wxUSE_LOGWINDOW
+    fileMenu->Append(Pyramid_LogW, "&Log window", "Open the log window");
+    fileMenu->AppendSeparator();
+#endif // wxUSE_LOGWINDOW
+    fileMenu->Append(Pyramid_Quit, "E&xit\tAlt-X", "Quit this program");
+
+    // now append the freshly created menu to the menu bar...
+    wxMenuBar *menuBar = new wxMenuBar();
+    menuBar->Append(fileMenu, "&File");
+    menuBar->Append(helpMenu, "&Help");
+
+    // ... and attach this menu bar to the frame
+    SetMenuBar(menuBar);
+#endif // wxUSE_MENUS
+
+#if wxUSE_STATUSBAR
+    // create a status bar just for fun (by default with 1 pane only)
+    CreateStatusBar(2);
+    SetStatusText("Welcome to wxWidgets!");
+#endif // wxUSE_STATUSBAR
+
+#if wxUSE_LOGWINDOW
+    //Open a log window, don't show it though
+    m_LogWin = new wxLogWindow(NULL, "Pyramid log window", false, false);
+#endif // wxUSE_LOGWINDOW
+
+    // The canvas
+    m_mycanvas = new MyGLCanvas(this);
+
+    SetMinSize(wxSize(250, 200));
+}
+
+
+// event handlers
+
+void MyFrame::OnQuit(wxCommandEvent& WXUNUSED(event))
+{
+    // true is to force the frame to close
+    Close(true);
+}
+
+void MyFrame::OnAbout(wxCommandEvent& WXUNUSED(event))
+{
+    wxMessageBox(wxString::Format
+                 (
+                    "Welcome to %s!\n"
+                    "\n"
+                    "This is the wxWidgets OpenGL Pyramid sample.\n"
+                    "%s\n",
+                    wxVERSION_STRING,
+                    m_OGLString
+                 ),
+                 "About wxWidgets pyramid sample",
+                 wxOK | wxICON_INFORMATION,
+                 this);
+}
+
+#if wxUSE_LOGWINDOW
+void MyFrame::OnLogWindow(wxCommandEvent& WXUNUSED(event))
+{
+    if ( m_LogWin->GetFrame()->IsIconized() )
+        m_LogWin->GetFrame()->Restore();
+
+    if ( ! m_LogWin->GetFrame()->IsShown() )
+        m_LogWin->Show();
+
+    m_LogWin->GetFrame()->SetFocus();
+}
+#endif // wxUSE_LOGWINDOW
+
+bool MyFrame::CanvasInit()
+{
+    return m_mycanvas->oglInit();
+}
+
+// ----------------------------------------------------------------------------
+// Function for receiving messages from OGLstuff and passing them to the log window
+// ----------------------------------------------------------------------------
+void fOGLErrHandler(int err, int glerr, const GLchar* glMsg)
+{
+#if wxUSE_LOGWINDOW
+    wxString msg;
+
+    switch (err)
+    {
+    case myoglERR_SHADERCREATE:
+        msg = _("Error in shader creation.");
+        break;
+    case myoglERR_SHADERCOMPILE:
+        msg = _("Error in shader compilation.");
+        break;
+    case myoglERR_SHADERLINK:
+        msg = _("Error in shader linkage.");
+        break;
+    case myoglERR_SHADERLOCATION:
+        msg = _("Error: Can't get uniforms locations.");
+        break;
+    case myoglERR_BUFFER:
+        msg = _("Error: Can't load buffer. Likely out of GPU memory.");
+        break;
+    case myoglERR_TEXTIMAGE:
+        msg = _("Error: Can't load texture. Likely out of GPU memory.");
+        break;
+    case myoglERR_DRAWING_TRI:
+        msg = _("Error: Can't draw the triangles.");
+        break;
+    case myoglERR_DRAWING_STR:
+        msg = _("Error: Can't draw the string.");
+        break;
+    case myoglERR_JUSTLOG:
+        msg = _("Log info: ");
+        break;
+    default:
+        msg = _("Not a GL message.");
+    }
+
+    if ( glerr != GL_NO_ERROR )
+        msg += wxString::Format(_(" GL error %d. "), glerr);
+    else if ( err == 0 )
+        msg = _("Information: ");
+    else if ( err != myoglERR_JUSTLOG )
+        msg += _(" GL reports: ");
+
+    if ( glMsg != NULL )
+        msg += wxString::FromUTF8( reinterpret_cast<const char *>(glMsg) );
+
+    wxLogMessage(msg);
+#endif // wxUSE_LOGWINDOW
+}
+
+// ----------------------------------------------------------------------------
+// These two functions allow us to convert a wxString into a RGBA pixels array
+// ----------------------------------------------------------------------------
+
+// Creates a 4-bytes-per-pixel, RGBA array from a wxImage.
+// If the image has alpha channel, it's used. If not, pixels with 'cTrans' color
+// get 'cAlpha' alpha; an the rest of pixels get alpha=255 (opaque).
+//
+// NOTE: The returned pointer must be deleted somewhere in the app.
+unsigned char* MyImgToArray(const wxImage& img, const wxColour& cTrans, unsigned char cAlpha)
+{
+    int w = img.GetWidth();
+    int h = img.GetHeight();
+    int siz = w * h;
+    unsigned char *resArr = new unsigned char [siz * 4];
+    unsigned char *res = resArr;
+    unsigned char *sdata = img.GetData();
+    unsigned char *alpha = NULL;
+    if ( img.HasAlpha() )
+        alpha = img.GetAlpha();
+    // Pixel by pixel
+    for ( int i = 0; i < siz; i++ )
+    {   //copy the colour
+        res[0] = sdata[0] ;
+        res[1] = sdata[1] ;
+        res[2] = sdata[2] ;
+        if ( alpha != NULL )
+        {   //copy alpha
+            res[3] = alpha[i] ;
+        }
+        else
+        {   // Colour cTrans gets cAlpha transparency
+            if ( res[0] == cTrans.Red() && res[1] == cTrans.Green() && res[2] == cTrans.Blue() )
+                res[3] = cAlpha;
+            else
+                res[3] = 255 ;
+        }
+        sdata += 3 ;
+        res += 4 ;
+    }
+
+    return resArr;
+}
+
+// Creates an array of bytes that defines the pixels of the string.
+// The background color has cAlpha transparency. 0=transparent, 255=opaque
+//
+// NOTE: The returned pointer must be deleted somewhere in the app.
+unsigned char* MyTextToPixels(const wxString& sText,     // The string
+                              const wxFont& sFont,       // Font to use
+                              const wxColour& sForeColo, // Foreground colour
+                              const wxColour& sBackColo, // Background colour
+                              unsigned char cAlpha,      // Background transparency
+                              int* width, int* height)   // Image sizes
+{
+    if ( sText.IsEmpty() )
+        return NULL;
+
+    // The dc where we temporally draw
+    wxMemoryDC mdc;
+
+    mdc.SetFont(sFont);
+
+    // Measure
+    mdc.GetMultiLineTextExtent(sText, width, height);
+
+    /* This code should be used for old graphics cards.
+       But this sample uses OGL Core Profile, so the card is not that old.
+
+    // Adjust sizes to power of two. Needed for old cards.
+    int sizP2 = 4;
+    while ( sizP2 < *width )
+        sizP2 *= 2;
+    *width = sizP2;
+    sizP2 = 4;
+    while ( sizP2 < *height )
+        sizP2 *= 2;
+    *height = sizP2;
+    */
+
+    // Now we know dimensions, let's draw into a memory dc
+    wxBitmap bmp(*width, *height, 24);
+    mdc.SelectObject(bmp);
+    // If we have multiline string, perhaps not all of the bmp is used
+    wxBrush brush(sBackColo);
+    mdc.SetBackground(brush);
+    mdc.Clear(); // Make sure all of bmp is cleared
+    // Colours
+    mdc.SetBackgroundMode(wxPENSTYLE_SOLID);
+    mdc.SetTextBackground(sBackColo);
+    mdc.SetTextForeground(sForeColo);
+    // We draw the string and get it as an image.
+    // NOTE: OpenGL axis are bottom to up. Be aware when setting the texture coords.
+    mdc.DrawText(sText, 0, 0);
+    mdc.SelectObject(wxNullBitmap); // bmp must be detached from wxMemoryDC
+
+    // Bytes from the image. Background pixels become transparent with the
+    // cAlpha transparency value.
+    unsigned char *res = MyImgToArray(bmp.ConvertToImage(), sBackColo, cAlpha);
+
+    return res;
+}
+
+
+// ----------------------------------------------------------------------------
+// The canvas inside the frame. Our OpenGL connection
+// ----------------------------------------------------------------------------
+
+BEGIN_EVENT_TABLE(MyGLCanvas, wxGLCanvas)
+    EVT_PAINT(MyGLCanvas::OnPaint)
+    EVT_SIZE(MyGLCanvas::OnSize)
+    EVT_MOUSE_EVENTS(MyGLCanvas::OnMouse)
+END_EVENT_TABLE()
+
+// GL desired attributes. We ask for OGL >= 3.2 Core Profile
+int OGL_attribs[] =
+  { WX_GL_RGBA,
+    WX_GL_MIN_RED, 8, WX_GL_MIN_GREEN, 8, WX_GL_MIN_BLUE, 8, WX_GL_MIN_ALPHA, 8,
+    WX_GL_DEPTH_SIZE, 24, WX_GL_DOUBLEBUFFER,
+    WX_GL_CORE_PROFILE, WX_GL_MAJOR_VERSION, 3, WX_GL_MINOR_VERSION, 2,
+    0
+  };
+
+MyGLCanvas::MyGLCanvas(MyFrame* parent)
+    : wxGLCanvas(parent, wxID_ANY, OGL_attribs)
+{
+    m_parent = parent;
+
+    m_oglManager = NULL;
+    m_winHeight = 0; // We have not been sized yet
+}
+
+MyGLCanvas::~MyGLCanvas()
+{
+    if ( m_oglContext )
+        SetCurrent(*m_oglContext);
+
+    if ( m_oglManager )
+    {
+        delete m_oglManager;
+        m_oglManager = NULL;
+    }
+
+    if ( m_oglContext )
+    {
+        delete m_oglContext;
+        m_oglContext = NULL;
+    }
+}
+
+bool MyGLCanvas::oglInit()
+{
+    // Explicitly create a new rendering context instance for this canvas.
+    m_oglContext = new wxGLContext(this);
+
+    if ( !m_oglContext || !SetCurrent(*m_oglContext) )
+    {
+        wxMessageBox("GL-context failed.\n",
+                     "Initialization error", wxOK | wxICON_INFORMATION, this);
+        return false;
+    }
+
+    // Create our OGL manager, pass our OGL error handler
+    m_oglManager = new myOGLManager(&fOGLErrHandler);
+
+    // glew needs this window DC
+    SetFocus();
+
+    // Initialize glew, the helper for gl calls
+    if ( !m_oglManager->Init() )
+    {
+        wxMessageBox("Error: OpenGL could not be initialized.\n",
+            "OpenGL initialization error", wxOK | wxICON_INFORMATION, this);
+        return false;
+    }
+
+    // Get the GL version for the current OGL context
+    wxString sglVer = wxString::FromUTF8(
+                reinterpret_cast<const char *>(m_oglManager->GetGLVersion()) );
+    // For the menu "About" info
+    sglVer = "Using OpenGL version:\n" + sglVer;
+    m_parent->SetOGLString(sglVer);
+
+    // Load some data into GPU
+    m_oglManager->SetShadersAndTriangles();
+
+    // This string will be placed on a face of the pyramid
+    int swi = 0, shi = 0;
+    wxString stg("wxWidgets");
+    // Set the font. Use a big pointsize so as to smoothing edges.
+    wxFont font(48, wxFONTFAMILY_MODERN, wxFONTSTYLE_NORMAL, wxFONTWEIGHT_NORMAL);
+    if ( !font.IsOk() )
+        font = *wxSWISS_FONT;
+    wxColour bgrdColo(*wxBLACK);
+    wxColour foreColo(160, 0, 200); // Dark purple
+    // Build an array with the pixels. Background fully transparent
+    unsigned char* sPixels = MyTextToPixels(stg, font, foreColo, bgrdColo, 0,
+                                            &swi, &shi);
+    // Send it to GPU
+    m_oglManager->SetStringOnPyr(sPixels, swi, shi);
+    delete[] sPixels; // That memory was allocated at MyTextToPixels
+
+    // This string is placed at left bottom of the window. Its size doesn't
+    // change with window size.
+    stg = "Rotate the pyramid with\nthe left mouse button";
+    font.SetPointSize(14);
+    bgrdColo = wxColour(40, 40, 255);
+    foreColo = wxColour(*wxWHITE);
+    unsigned char* stPixels = MyTextToPixels(stg, font, foreColo, bgrdColo, 80,
+                                             &swi, &shi);
+    m_oglManager->SetImmutableString(stPixels, swi, shi);
+    delete[] stPixels;
+
+    // Send a size event so that we can set the GL viewport.
+    SendSizeEvent();
+
+    return true;
+}
+
+void MyGLCanvas::OnPaint( wxPaintEvent& WXUNUSED(event) )
+{
+    // This is a dummy, to avoid an endless succession of paint messages.
+    // OnPaint handlers must always create a wxPaintDC.
+    wxPaintDC dc(this);
+
+    // Avoid painting when we have not yet a size
+    if ( m_winHeight < 1 || !m_oglManager )
+        return;
+
+    // This should not be needed, while we have only one canvas
+    SetCurrent(*m_oglContext);
+
+    // Do the magic
+    m_oglManager->Render();
+
+    SwapBuffers();
+}
+
+void MyGLCanvas::OnSize(wxSizeEvent& event)
+{
+    event.Skip();
+
+    // If we are not fully initialized, dismiss this event
+    if ( !m_oglManager || !IsShownOnScreen() )
+        return;
+
+    // This is normally only necessary if there is more than one wxGLCanvas
+    // or more than one wxGLContext in the application.
+    SetCurrent(*m_oglContext);
+
+    // It's up to the application code to update the OpenGL viewport settings.
+    m_winHeight = event.GetSize().y;
+    m_oglManager->SetViewport(0, 0, event.GetSize().x, m_winHeight);
+
+    // Generate paint event without erasing the background.
+    Refresh(false);
+}
+
+void MyGLCanvas::OnMouse(wxMouseEvent& event)
+{
+    event.Skip();
+
+    // GL 0 Y-coordinate is at bottom of the window
+    int oglwinY = m_winHeight - event.GetY();
+
+    if ( event.LeftIsDown() )
+    {
+        if ( ! event.Dragging() )
+        {
+            // Store positions
+            m_oglManager->OnMouseButDown(event.GetX(), oglwinY);
+        }
+        else
+        {
+            // Rotation
+            m_oglManager->OnMouseRotDragging( event.GetX(), oglwinY );
+
+            // Generate paint event without erasing the background.
+            Refresh(false);
+        }
+    }
+}
+
diff --git samples/opengl/pyramid/pyramid.h samples/opengl/pyramid/pyramid.h
new file mode 100755
index 0000000..4e10348
--- /dev/null
+++ samples/opengl/pyramid/pyramid.h
@@ -0,0 +1,86 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        pyramid.h
+// Purpose:     OpenGL version >= 3.2 sample
+// Author:      Manuel Martin
+// Modified by:
+// Created:     2015/01/31
+// Copyright:   (c)
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef PYRSAMLE_H
+  #define PYRSAMLE_H
+
+// Define a new application
+class MyApp: public wxApp
+{
+public:
+    MyApp(){};
+    bool OnInit() wxOVERRIDE;
+};
+
+
+class MyGLCanvas;
+
+// The main frame class
+class MyFrame : public wxFrame
+{
+public:
+    MyFrame(const wxString& title);
+
+
+    void OnAbout(wxCommandEvent& event);
+    void OnQuit(wxCommandEvent& event);
+#if wxUSE_LOGWINDOW
+    void OnLogWindow(wxCommandEvent& event);
+#endif // wxUSE_LOGWINDOW
+    void SetOGLString(const wxString& ogls)
+        { m_OGLString = ogls; }
+    bool CanvasInit();
+
+private:
+#if wxUSE_LOGWINDOW
+    wxLogWindow* m_LogWin;
+#endif // wxUSE_LOGWINDOW
+    wxString     m_OGLString;
+    MyGLCanvas*  m_mycanvas;
+
+    wxDECLARE_EVENT_TABLE();
+};
+
+
+// The canvas window
+class MyGLCanvas : public wxGLCanvas
+{
+public:
+    MyGLCanvas(MyFrame* parent);
+    ~MyGLCanvas();
+
+    //Init the OpenGL stuff
+    bool oglInit();
+
+    void OnPaint(wxPaintEvent& event);
+    void OnSize(wxSizeEvent& event);
+    void OnMouse(wxMouseEvent& event);
+
+private:
+    // Members
+    MyFrame*      m_parent;
+    wxGLContext*  m_oglContext;
+    myOGLManager* m_oglManager;
+    int           m_winHeight; // We use this var to know if we have been sized
+
+    wxDECLARE_EVENT_TABLE();
+};
+
+
+// IDs for the controls and the menu commands
+enum
+{
+    Pyramid_Quit = wxID_EXIT,
+    Pyramid_About = wxID_ABOUT,
+    Pyramid_LogW = wxID_HIGHEST + 10
+};
+
+#endif // PYRSAMLE_H
+
