Index: include/wx/private/textmeasure.h
===================================================================
--- include/wx/private/textmeasure.h	(revisión: 0)
+++ include/wx/private/textmeasure.h	(revisión: 0)
@@ -0,0 +1,99 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        wx/private/textmeasure.h
+// Purpose:     declaration of wxTextMeasure class
+// Author:      Manuel Martin
+// Created:     2012-19-05
+// RCS-ID:
+// Copyright:
+// Licence:     wxWindows licence
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_TEXTMEASURE_H_
+#define _WX_TEXTMEASURE_H_
+
+#include "wx/vector.h"
+
+class wxFont;
+class wxDCImpl;
+class wxWindow;
+
+// ----------------------------------------------------------------------------
+// wxTextMeasure
+// ----------------------------------------------------------------------------
+
+class wxTextMeasureBase
+{
+public:
+    wxTextMeasureBase(const wxDCImpl *dc, const wxFont *theFont);
+    wxTextMeasureBase(const wxWindow *win, const wxFont *theFont);
+    virtual ~wxTextMeasureBase();
+
+    // A wxString dimensions
+    void GetTextExtent(const wxString& string,
+                       wxCoord *width,
+                       wxCoord *height,
+                       wxCoord *descent = NULL,
+                       wxCoord *externalLeading = NULL);
+
+    // A multiline (with '\n') wxString dimensions
+    virtual void GetMultiLineTextExtent(const wxString& text,
+                                        wxCoord *width,
+                                        wxCoord *height,
+                                        wxCoord *heightOneLine = NULL);
+
+    // Widths for each "0-pos to char-pos" substrings of 'text'
+    virtual bool GetPartialTextExtents(const wxString& text,
+                                       wxArrayInt& widths,
+                                       double scaleX);
+
+    // The dimensions for the largest string
+    virtual void GetLargestStringExtent(const wxVector<wxString>& vStrings,
+                                        wxCoord *width,
+                                        wxCoord *height);
+
+protected:
+    virtual void InitCached();
+
+    virtual void RestoreStatus() const;
+
+    virtual void DoGetTextExtent(const wxString& string,
+                                 wxCoord *width,
+                                 wxCoord *height,
+                                 wxCoord *descent = NULL,
+                                 wxCoord *externalLeading = NULL);
+
+    const wxFont   *m_font;
+    const wxDCImpl *m_dc;
+    const wxWindow *m_win;
+
+    wxDECLARE_NO_COPY_CLASS(wxTextMeasureBase);
+};
+
+// ----------------------------------------------------------------
+// the platform dependant class
+
+#if defined(__WXGTK20__)
+    #include "wx/gtk/private/textmeasure.h"
+#elif defined(__WXMSW__)
+    #include "wx/msw/private/textmeasure.h"
+#else
+    // no platform-specific implementation of wxTextMeasure yet
+    class wxTextMeasure : public wxTextMeasureBase
+    {
+     public:
+        wxTextMeasure(const wxDCImpl *dc, const wxFont *theFont)
+            : wxTextMeasureBase(dc, theFont)
+        {
+        }
+
+        wxTextMeasure(const wxWindow *win, const wxFont *theFont)
+            : wxTextMeasureBase(win, theFont)
+        {
+        }
+        ~wxTextMeasure() {}
+        wxDECLARE_NO_COPY_CLASS(wxTextMeasure);
+    };
+#endif
+
+#endif // _WX_TEXTMEASURE_H_
+

Index: include/wx/msw/private/textmeasure.h
===================================================================
--- include/wx/msw/private/textmeasure.h	(revisión: 0)
+++ include/wx/msw/private/textmeasure.h	(revisión: 0)
@@ -0,0 +1,58 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        wx/msw/private/textmeasure.h
+// Purpose:     wxMSW-specific declaration of wxTextMeasure class
+// Author:      Manuel Martin
+// Created:     2012-10-05
+// RCS-ID:
+// Copyright:
+// Licence:     wxWindows licence
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_MSW_TEXTMEASURE_H_
+#define _WX_MSW_TEXTMEASURE_H_
+
+#include "wx/msw/wrapwin.h"
+
+// ----------------------------------------------------------------------------
+// wxTextMeasure
+// ----------------------------------------------------------------------------
+
+#define wxTextMeasureMSW wxTextMeasure
+
+// This class is used to do text measures, mainly GetTextExtend() and friends.
+// It is called from wxWindow and wxDC classes
+class wxTextMeasureMSW : public wxTextMeasureBase
+{
+public:
+    wxTextMeasureMSW(const wxDCImpl *dc, const wxFont *theFont)
+	    : wxTextMeasureBase(dc, theFont) {}
+    wxTextMeasureMSW(const wxWindow *win, const wxFont *theFont)
+	    : wxTextMeasureBase(win, theFont) {}
+
+    virtual ~wxTextMeasureMSW() {}
+
+    virtual void DoGetTextExtent(const wxString& string,
+                               wxCoord *width,
+                               wxCoord *height,
+                               wxCoord *descent = NULL,
+                               wxCoord *externalLeading = NULL);
+
+    virtual bool GetPartialTextExtents(const wxString& text,
+                                       wxArrayInt& widths,
+                                       double scaleX);
+
+protected:
+    void Init();
+
+    void InitCached();
+
+    void RestoreStatus() const;
+
+    HDC       m_hdc;
+    HFONT     m_hfontOld;
+
+    wxDECLARE_NO_COPY_CLASS(wxTextMeasureMSW);
+};
+
+#endif // _WX_MSW_TEXTMEASURE_H_
+

Index: include/wx/gtk/private/textmeasure.h
===================================================================
--- include/wx/gtk/private/textmeasure.h	(revisión: 0)
+++ include/wx/gtk/private/textmeasure.h	(revisión: 0)
@@ -0,0 +1,55 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        wx/gtk/private/textmeasure.h
+// Purpose:     wxGTK-specific declaration of wxTextMeasure class
+// Author:      Manuel Martin
+// Created:     2012-19-05
+// RCS-ID:
+// Copyright:
+// Licence:     wxWindows licence
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_GTK_TEXTMEASURE_H_
+#define _WX_GTK_TEXTMEASURE_H_
+
+// ----------------------------------------------------------------------------
+// wxTextMeasure
+// ----------------------------------------------------------------------------
+
+#define wxTextMeasureGTK wxTextMeasure
+
+class wxWindowDCImpl;
+
+// This class is used to do text measures, mainly GetTextExtend() and friends.
+// It is used from wxWindow and wxDC classes, but can be used anywhere.
+class wxTextMeasureGTK : public wxTextMeasureBase
+{
+public:
+    wxTextMeasureGTK(const wxDCImpl *dc, const wxFont *theFont);
+    wxTextMeasureGTK(const wxWindow *win, const wxFont *theFont);
+
+    virtual void DoGetTextExtent(const wxString& string,
+                               wxCoord *width,
+                               wxCoord *height,
+                               wxCoord *descent = NULL,
+                               wxCoord *externalLeading = NULL);
+
+    virtual bool GetPartialTextExtents(const wxString& text,
+                                       wxArrayInt& widths,
+                                       double scaleX);
+
+protected:
+    void Init();
+
+    void InitCached();
+
+    void RestoreStatus() const;
+
+    wxWindowDCImpl *wdc;
+    PangoContext *m_context;
+    PangoLayout *m_layout;
+
+    wxDECLARE_NO_COPY_CLASS(wxTextMeasureGTK);
+};
+
+#endif // _WX_GTK_TEXTMEASURE_H_
+

Index: build/bakefiles/files.bkl
===================================================================
--- build/bakefiles/files.bkl	(revisión: 72621)
+++ build/bakefiles/files.bkl	(copia de trabajo)
@@ -737,6 +737,7 @@
     src/common/tbarbase.cpp
     src/common/textcmn.cpp
     src/common/textentrycmn.cpp
+    src/common/textmeasurecmn.cpp
     src/common/toplvcmn.cpp
     src/common/treebase.cpp
     src/common/uiactioncmn.cpp
@@ -1082,6 +1083,7 @@
     src/gtk/region.cpp
     src/gtk/renderer.cpp
     src/gtk/settings.cpp
+    src/gtk/textmeasure.cpp
     src/gtk/timer.cpp
     src/gtk/tooltip.cpp
     src/gtk/toplevel.cpp
@@ -1692,6 +1694,7 @@
     src/msw/region.cpp
     src/msw/renderer.cpp
     src/msw/settings.cpp
+    src/msw/textmeasure.cpp
     src/msw/tooltip.cpp
     src/msw/toplevel.cpp
     src/msw/uiaction.cpp
Index: src/msw/dc.cpp
===================================================================
--- src/msw/dc.cpp	(revisión: 72621)
+++ src/msw/dc.cpp	(copia de trabajo)
@@ -51,6 +51,7 @@
 #include <string.h>
 
 #include "wx/msw/private/dc.h"
+#include "wx/private/textmeasure.h"
 
 using namespace wxMSWImpl;
 
@@ -1857,109 +1858,25 @@
     }
 #endif // __WXMICROWIN__
 
-    HFONT hfontOld;
     if ( font )
     {
         wxASSERT_MSG( font->IsOk(), wxT("invalid font in wxMSWDCImpl::GetTextExtent") );
-
-        hfontOld = (HFONT)::SelectObject(GetHdc(), GetHfontOf(*font));
     }
-    else // don't change the font
-    {
-        hfontOld = 0;
-    }
 
-    SIZE sizeRect;
-    const size_t len = string.length();
-    if ( !::GetTextExtentPoint32(GetHdc(), string.t_str(), len, &sizeRect) )
-    {
-        wxLogLastError(wxT("GetTextExtentPoint32()"));
-    }
-
-#if !defined(_WIN32_WCE) || (_WIN32_WCE >= 400)
-    // the result computed by GetTextExtentPoint32() may be too small as it
-    // accounts for under/overhang of the first/last character while we want
-    // just the bounding rect for this string so adjust the width as needed
-    // (using API not available in 2002 SDKs of WinCE)
-    if ( len > 0 )
-    {
-        ABC width;
-        const wxChar chFirst = *string.begin();
-        if ( ::GetCharABCWidths(GetHdc(), chFirst, chFirst, &width) )
-        {
-            if ( width.abcA < 0 )
-                sizeRect.cx -= width.abcA;
-
-            if ( len > 1 )
-            {
-                const wxChar chLast = *string.rbegin();
-                ::GetCharABCWidths(GetHdc(), chLast, chLast, &width);
-            }
-            //else: we already have the width of the last character
-
-            if ( width.abcC < 0 )
-                sizeRect.cx -= width.abcC;
-        }
-        //else: GetCharABCWidths() failed, not a TrueType font?
-    }
-#endif // !defined(_WIN32_WCE) || (_WIN32_WCE >= 400)
-
-    if (x)
-        *x = sizeRect.cx;
-    if (y)
-        *y = sizeRect.cy;
-
-    if ( descent || externalLeading )
-    {
-        DoGetFontMetrics(NULL, NULL, descent, NULL, externalLeading, NULL);
-    }
-
-    if ( hfontOld )
-    {
-        ::SelectObject(GetHdc(), hfontOld);
-    }
+    wxTextMeasure txm(this, font);
+    txm.GetTextExtent(string, x, y, descent, externalLeading);
 }
 
 
 // Each element of the array will be the width of the string up to and
-// including the coresoponding character in text.
+// including the corresponding character in text.
 
 bool wxMSWDCImpl::DoGetPartialTextExtents(const wxString& text, wxArrayInt& widths) const
 {
-    static int maxLenText = -1;
-    static int maxWidth = -1;
-    int fit = 0;
-    SIZE sz = {0,0};
-    int stlen = text.length();
+    wxCHECK_MSG( GetFont().IsOk(), false, wxT("Invalid font") );
 
-    if (maxLenText == -1)
-    {
-        // Win9x and WinNT+ have different limits
-        int version = wxGetOsVersion();
-        maxLenText = version == wxOS_WINDOWS_NT ? 65535 : 8192;
-        maxWidth =   version == wxOS_WINDOWS_NT ? INT_MAX : 32767;
-    }
-
-    widths.Empty();
-    widths.Add(0, stlen);  // fill the array with zeros
-    if (stlen == 0)
-        return true;
-
-    if (!::GetTextExtentExPoint(GetHdc(),
-                                text.c_str(),           // string to check
-                                wxMin(stlen, maxLenText),
-                                maxWidth,
-                                &fit,                   // [out] count of chars
-                                                        // that will fit
-                                &widths[0],             // array to fill
-                                &sz))
-    {
-        // API failed
-        wxLogLastError(wxT("GetTextExtentExPoint"));
-        return false;
-    }
-
-    return true;
+    wxTextMeasure txm(this, NULL); // don't change the font
+    return txm.GetPartialTextExtents(text, widths, 1.0);
 }
 
 namespace
Index: src/msw/window.cpp
===================================================================
--- src/msw/window.cpp	(revisión: 72621)
+++ src/msw/window.cpp	(copia de trabajo)
@@ -81,6 +81,7 @@
 #include "wx/msw/private.h"
 #include "wx/msw/private/keyboard.h"
 #include "wx/msw/dcclient.h"
+#include "wx/private/textmeasure.h"
 
 #if wxUSE_TOOLTIPS
     #include "wx/tooltip.h"
@@ -2164,31 +2165,18 @@
                                   int *externalLeading,
                                   const wxFont *fontToUse) const
 {
-    wxASSERT_MSG( !fontToUse || fontToUse->IsOk(),
-                    wxT("invalid font in GetTextExtent()") );
-
-    HFONT hfontToUse;
-    if ( fontToUse )
-        hfontToUse = GetHfontOf(*fontToUse);
+    // ensure we work with a valid font
+    wxFont font;
+    if ( !fontToUse || !fontToUse->IsOk() )
+        font = GetFont();
     else
-        hfontToUse = GetHfontOf(GetFont());
+        font = *fontToUse;
 
-    WindowHDC hdc(GetHwnd());
-    SelectInHDC selectFont(hdc, hfontToUse);
+    wxCHECK_RET( font.IsOk(), wxT("invalid font in GetTextExtent()") );
 
-    SIZE sizeRect;
-    TEXTMETRIC tm;
-    ::GetTextExtentPoint32(hdc, string.t_str(), string.length(), &sizeRect);
-    GetTextMetrics(hdc, &tm);
-
-    if ( x )
-        *x = sizeRect.cx;
-    if ( y )
-        *y = sizeRect.cy;
-    if ( descent )
-        *descent = tm.tmDescent;
-    if ( externalLeading )
-        *externalLeading = tm.tmExternalLeading;
+    const wxWindow* win = static_cast<const wxWindow*>(this);
+    wxTextMeasure txm(win, &font);
+    txm.GetTextExtent(string, x, y, descent, externalLeading);
 }
 
 // ---------------------------------------------------------------------------
Index: src/msw/textmeasure.cpp
===================================================================
--- src/msw/textmeasure.cpp	(revisión: 0)
+++ src/msw/textmeasure.cpp	(revisión: 0)
@@ -0,0 +1,170 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        src/msw/textmeasure.cpp
+// Purpose:     wxTextMeasure implementation for wxMSW
+// Author:      Manuel Martin
+// Created:     2012-19-05
+// RCS-ID:
+// Copyright:
+// Licence:     wxWindows licence
+///////////////////////////////////////////////////////////////////////////////
+
+// ============================================================================
+// declarations
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// headers
+// ----------------------------------------------------------------------------
+
+// for compilers that support precompilation, includes "wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#include "wx/msw/private.h"
+#include "wx/msw/dc.h"
+
+#ifndef WX_PRECOMP
+    #include "wx/window.h"
+    #include "wx/font.h"
+#endif //WX_PRECOMP
+
+#include "wx/private/textmeasure.h"
+
+// ============================================================================
+// wxTextMeasure implementation
+// ============================================================================
+
+void wxTextMeasureMSW::InitCached()
+{
+    if ( m_dc )
+        m_hdc = (wxDynamicCast(m_dc, wxMSWDCImpl))->GetHDC();
+    else //win
+        m_hdc = ::GetDC(m_win->GetHWND());
+
+    if ( m_font )
+        m_hfontOld = (HFONT)::SelectObject(m_hdc, GetHfontOf(*m_font));
+    else // don't change the font
+        m_hfontOld = 0;
+}
+
+void wxTextMeasureMSW::RestoreStatus() const
+{
+    if ( m_hfontOld )
+        ::SelectObject(m_hdc, m_hfontOld);
+
+    if ( m_win )
+        ::ReleaseDC(m_win->GetHWND(), m_hdc);
+}
+
+// Notice we don't check here the font. It is supposed to be OK before the call.
+void wxTextMeasureMSW::DoGetTextExtent(const wxString& string,
+                                       wxCoord *width,
+                                       wxCoord *height,
+                                       wxCoord *descent,
+                                       wxCoord *externalLeading)
+{
+    if (string.empty())
+    {
+        if (width)
+            *width = 0;
+        if (height)
+            *height = 0;
+        return;
+    }
+
+    SIZE sizeRect;
+    const size_t len = string.length();
+    if ( !::GetTextExtentPoint32(m_hdc, string.t_str(), len, &sizeRect) )
+    {
+        wxLogLastError(wxT("GetTextExtentPoint32()"));
+    }
+
+#if !defined(_WIN32_WCE) || (_WIN32_WCE >= 400)
+    // the result computed by GetTextExtentPoint32() may be too small as it
+    // accounts for under/overhang of the first/last character while we want
+    // just the bounding rect for this string so adjust the width as needed
+    // (using API not available in 2002 SDKs of WinCE)
+    if ( len > 0 )
+    {
+        ABC widthABC;
+        const wxChar chFirst = *string.begin();
+        if ( ::GetCharABCWidths(m_hdc, chFirst, chFirst, &widthABC) )
+        {
+            if ( widthABC.abcA < 0 )
+                sizeRect.cx -= widthABC.abcA;
+
+            if ( len > 1 )
+            {
+                const wxChar chLast = *string.rbegin();
+                ::GetCharABCWidths(m_hdc, chLast, chLast, &widthABC);
+            }
+            //else: we already have the width of the last character
+
+            if ( widthABC.abcC < 0 )
+                sizeRect.cx -= widthABC.abcC;
+        }
+        //else: GetCharABCWidths() failed, not a TrueType font?
+    }
+#endif // !defined(_WIN32_WCE) || (_WIN32_WCE >= 400)
+
+    if (width)
+        *width = sizeRect.cx;
+    if (height)
+        *height = sizeRect.cy;
+
+    if ( descent || externalLeading )
+    {
+        TEXTMETRIC tm;
+        ::GetTextMetrics(m_hdc, &tm);
+        if ( descent )
+            *descent = tm.tmDescent;
+        if ( externalLeading )
+            *externalLeading = tm.tmExternalLeading;
+    }
+}
+
+bool wxTextMeasureMSW::GetPartialTextExtents(const wxString& text,
+                                             wxArrayInt& widths,
+                                             double WXUNUSED(scaleX))
+{
+    static int maxLenText = -1;
+    static int maxWidth = -1;
+    int fit = 0;
+    SIZE sz = {0,0};
+    int stlen = text.length();
+
+    if (maxLenText == -1)
+    {
+        // Win9x and WinNT+ have different limits
+        int version = wxGetOsVersion();
+        maxLenText = version == wxOS_WINDOWS_NT ? 65535 : 8192;
+        maxWidth =   version == wxOS_WINDOWS_NT ? INT_MAX : 32767;
+    }
+
+    widths.Empty();
+    widths.Add(0, stlen);  // fill the array with zeros
+    if (stlen == 0)
+        return true;
+
+    InitCached(); // We must use the right HDC
+
+    bool res = ::GetTextExtentExPoint(m_hdc,
+                                      text.c_str(),     // string to check
+                                      wxMin(stlen, maxLenText),
+                                      maxWidth,
+                                      &fit,             // [out] count of chars
+                                                        // that will fit
+                                      &widths[0],       // array to fill
+                                      &sz);
+    if ( !res )
+    {
+        // API failed
+        wxLogLastError(wxT("GetTextExtentExPoint"));
+    }
+
+    RestoreStatus();
+    return res;
+}
Index: src/gtk/dcclient.cpp
===================================================================
--- src/gtk/dcclient.cpp	(revisión: 72621)
+++ src/gtk/dcclient.cpp	(copia de trabajo)
@@ -25,6 +25,7 @@
 
 #include "wx/gtk/private.h"
 #include "wx/gtk/private/object.h"
+#include "wx/private/textmeasure.h"
 
 //-----------------------------------------------------------------------------
 // local defines
@@ -1532,100 +1533,27 @@
                                  wxCoord *descent, wxCoord *externalLeading,
                                  const wxFont *theFont) const
 {
-    if ( width )
-        *width = 0;
-    if ( height )
-        *height = 0;
-    if ( descent )
-        *descent = 0;
-    if ( externalLeading )
-        *externalLeading = 0;
-
-    if (string.empty())
-        return;
-
-    // ensure that theFont is always non-NULL
+    // ensure we work with a valid font
+    const wxFont *fontToUse;
     if ( !theFont || !theFont->IsOk() )
-        theFont = &m_font;
+        fontToUse = &m_font;
+    else
+        fontToUse = theFont;
 
-    // and use it if it's valid
-    if ( theFont->IsOk() )
-    {
-        pango_layout_set_font_description
-        (
-            m_layout,
-            theFont->GetNativeFontInfo()->description
-        );
-    }
+    wxCHECK_RET( fontToUse->IsOk(), wxT("invalid font") );
 
-    // Set layout's text
-    const wxCharBuffer dataUTF8 = wxGTK_CONV_FONT(string, *theFont);
-    if ( !dataUTF8 )
-    {
-        // hardly ideal, but what else can we do if conversion failed?
-        return;
-    }
-
-    pango_layout_set_text(m_layout, dataUTF8, -1);
-
-    int h;
-    pango_layout_get_pixel_size(m_layout, width, &h);
-    if (descent)
-    {
-        PangoLayoutIter *iter = pango_layout_get_iter(m_layout);
-        int baseline = pango_layout_iter_get_baseline(iter);
-        pango_layout_iter_free(iter);
-        *descent = h - PANGO_PIXELS(baseline);
-    }
-    if (height)
-        *height = h;
-
-    // Reset old font description
-    if (theFont->IsOk())
-        pango_layout_set_font_description( m_layout, m_fontdesc );
+    wxTextMeasure txm(this, fontToUse);
+    txm.GetTextExtent(string, width, height, descent, externalLeading);
 }
 
 
 bool wxWindowDCImpl::DoGetPartialTextExtents(const wxString& text,
                                          wxArrayInt& widths) const
 {
-    const size_t len = text.length();
-    widths.Empty();
-    widths.Add(0, len);
+    wxCHECK_MSG( m_font.IsOk(), false, wxT("Invalid font") );
 
-    if (text.empty())
-        return true;
-
-    // Set layout's text
-    const wxCharBuffer dataUTF8 = wxGTK_CONV_FONT(text, m_font);
-    if ( !dataUTF8 )
-    {
-        // hardly ideal, but what else can we do if conversion failed?
-        wxLogLastError(wxT("DoGetPartialTextExtents"));
-        return false;
-    }
-
-    pango_layout_set_text(m_layout, dataUTF8, -1);
-
-    // Calculate the position of each character based on the widths of
-    // the previous characters
-
-    // Code borrowed from Scintilla's PlatGTK
-    PangoLayoutIter *iter = pango_layout_get_iter(m_layout);
-    PangoRectangle pos;
-    pango_layout_iter_get_cluster_extents(iter, NULL, &pos);
-    size_t i = 0;
-    while (pango_layout_iter_next_cluster(iter))
-    {
-        pango_layout_iter_get_cluster_extents(iter, NULL, &pos);
-        int position = PANGO_PIXELS(pos.x);
-        widths[i++] = position;
-    }
-    while (i < len)
-        widths[i++] = PANGO_PIXELS(pos.x + pos.width);
-    pango_layout_iter_free(iter);
-
-    return true;
+    wxTextMeasure txm(this, &m_font);
+    return txm.GetPartialTextExtents(text, widths, m_scaleX);
 }
 
 
Index: src/gtk/window.cpp
===================================================================
--- src/gtk/window.cpp	(revisión: 72621)
+++ src/gtk/window.cpp	(copia de trabajo)
@@ -43,6 +43,7 @@
 #include "wx/gtk/private/gtk2-compat.h"
 #include "wx/gtk/private/event.h"
 #include "wx/gtk/private/win_gtk.h"
+#include "wx/private/textmeasure.h"
 using namespace wxGTKImpl;
 
 #ifdef GDK_WINDOWING_X11
@@ -3090,52 +3091,18 @@
                                    int *externalLeading,
                                    const wxFont *theFont ) const
 {
-    wxFont fontToUse = theFont ? *theFont : GetFont();
+    // ensure we work with a valid font
+    wxFont fontToUse;
+    if ( !theFont || !theFont->IsOk() )
+        fontToUse = GetFont();
+    else
+        fontToUse = *theFont;
 
     wxCHECK_RET( fontToUse.IsOk(), wxT("invalid font") );
 
-    if (string.empty())
-    {
-        if (x) (*x) = 0;
-        if (y) (*y) = 0;
-        return;
-    }
-
-    PangoContext *context = NULL;
-    if (m_widget)
-        context = gtk_widget_get_pango_context( m_widget );
-
-    if (!context)
-    {
-        if (x) (*x) = 0;
-        if (y) (*y) = 0;
-        return;
-    }
-
-    PangoFontDescription *desc = fontToUse.GetNativeFontInfo()->description;
-    PangoLayout *layout = pango_layout_new(context);
-    pango_layout_set_font_description(layout, desc);
-    {
-        const wxCharBuffer data = wxGTK_CONV( string );
-        if ( data )
-            pango_layout_set_text(layout, data, strlen(data));
-    }
-
-    PangoRectangle rect;
-    pango_layout_get_extents(layout, NULL, &rect);
-
-    if (x) (*x) = (wxCoord) PANGO_PIXELS(rect.width);
-    if (y) (*y) = (wxCoord) PANGO_PIXELS(rect.height);
-    if (descent)
-    {
-        PangoLayoutIter *iter = pango_layout_get_iter(layout);
-        int baseline = pango_layout_iter_get_baseline(iter);
-        pango_layout_iter_free(iter);
-        *descent = *y - PANGO_PIXELS(baseline);
-    }
-    if (externalLeading) (*externalLeading) = 0;  // ??
-
-    g_object_unref (layout);
+    const wxWindow* win = static_cast<const wxWindow*>(this);
+    wxTextMeasure txm(win, &fontToUse);
+    txm.GetTextExtent(string, x, y, descent, externalLeading);
 }
 
 void wxWindowGTK::GTKDisableFocusOutEvent()
Index: src/gtk/textmeasure.cpp
===================================================================
--- src/gtk/textmeasure.cpp	(revisión: 0)
+++ src/gtk/textmeasure.cpp	(revisión: 0)
@@ -0,0 +1,216 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        src/gtk/textmeasure.cpp
+// Purpose:     wxTextMeasure implementation for wxGTK
+// Author:      Manuel Martin
+// Created:     2012-10-05
+// RCS-ID:
+// Copyright:
+// Licence:     wxWindows licence
+///////////////////////////////////////////////////////////////////////////////
+
+// ============================================================================
+// declarations
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// headers
+// ----------------------------------------------------------------------------
+
+// for compilers that support precompilation, includes "wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __WXGTK3__
+    #include "wx/gtk/dc.h"
+#else
+    #include "wx/gtk/dcclient.h"
+#endif
+
+#ifndef WX_PRECOMP
+    #include "wx/window.h"
+#endif //WX_PRECOMP
+
+#include "wx/fontutil.h"
+
+#include <gtk/gtk.h>
+#include "wx/gtk/private.h"
+#include "wx/private/textmeasure.h"
+
+// ============================================================================
+// wxTextMeasure implementation
+// ============================================================================
+
+// For Gtk3 wx uses DCs derived from wxGTKCairoDCImpl, which does not use
+// Pango stuff. But window calls (i.e. wxWindow::GetTextExtent()) does
+// use it. We need context and layout.
+
+wxTextMeasureGTK::wxTextMeasureGTK(const wxDCImpl *dc, const wxFont *theFont)
+                    : wxTextMeasureBase(dc, theFont)
+{
+    Init();
+}
+
+wxTextMeasureGTK::wxTextMeasureGTK(const wxWindow *win, const wxFont *theFont)
+                    : wxTextMeasureBase(win, theFont)
+{
+    Init();
+}
+
+void wxTextMeasureGTK::Init()
+{
+    wxASSERT_MSG( m_font, wxT("wxTextMeasure needs a valid wxFont") );
+
+    wdc = NULL;
+    m_context = NULL;
+    m_layout = NULL;
+}
+
+// Get Gtk needed elements, if we have not them yet.
+void wxTextMeasureGTK::InitCached()
+{
+    if ( m_dc )
+    {
+#ifdef __WXGTK3__
+        // For Gtk3 wxWindowDCImpl derives from wxGTKCairoDCImpl, without Pango
+        // stuff. Allow these lines to compile, but get out of here right now.
+        return;
+#else
+        wdc = wxDynamicCast(m_dc, wxWindowDCImpl);
+        m_context  = wdc->m_context;
+        m_layout   = wdc->m_layout;
+#endif
+    }
+
+    else // win
+    {
+        m_context = gtk_widget_get_pango_context( m_win->GetHandle() );
+        if ( m_context )
+            m_layout = pango_layout_new(m_context);
+    }
+
+    // set the font to use
+    pango_layout_set_font_description(m_layout,
+                                      m_font->GetNativeFontInfo()->description);
+}
+
+void wxTextMeasureGTK::RestoreStatus() const
+{
+    if ( !m_layout )
+        return;
+
+    if ( wdc )
+    {
+#ifdef __WXGTK3__
+        return;
+#else
+        // Reset dc own font description
+        pango_layout_set_font_description( wdc->m_layout, wdc->m_fontdesc );
+#endif
+    }
+    else
+        g_object_unref (m_layout);
+}
+
+// Notice we don't check here the font. It is supposed to be OK before the call.
+void wxTextMeasureGTK::DoGetTextExtent(const wxString& string,
+                                     wxCoord *width,
+                                     wxCoord *height,
+                                     wxCoord *descent,
+                                     wxCoord *externalLeading)
+{
+    if ( string.empty() || !m_context )
+    {
+        if (width)
+            *width = 0;
+        if (height)
+            *height = 0;
+        return;
+    }
+
+    // Set layout's text
+    const wxCharBuffer dataUTF8 = wxGTK_CONV_FONT(string, *m_font);
+    if ( !dataUTF8 )
+    {
+        // hardly ideal, but what else can we do if conversion failed?
+        wxLogLastError(wxT("GetTextExtent"));
+        return;
+    }
+    pango_layout_set_text(m_layout, dataUTF8, -1);
+
+    PangoRectangle rect;
+    int h;
+    if ( m_dc )
+    {
+        // in device units
+        pango_layout_get_pixel_size(m_layout, &rect.width, &h);
+        if (width)
+            *width = (wxCoord) rect.width;
+    }
+    else // win
+    {
+        // the logical rect bounds the ink rect
+        pango_layout_get_extents(m_layout, NULL, &rect);
+        if (width)
+            *width = (wxCoord) PANGO_PIXELS(rect.width);
+        h = PANGO_PIXELS(rect.height);
+    }
+    if (height)
+        *height = (wxCoord) h;
+
+    if (descent)
+    {
+        PangoLayoutIter *iter = pango_layout_get_iter(m_layout);
+        int baseline = pango_layout_iter_get_baseline(iter);
+        pango_layout_iter_free(iter);
+        *descent = (wxCoord) h - PANGO_PIXELS(baseline);
+    }
+
+    if (externalLeading) (*externalLeading) = 0;  // ??
+}
+
+bool wxTextMeasureGTK::GetPartialTextExtents(const wxString& text,
+                                             wxArrayInt& widths,
+                                             double WXUNUSED(scaleX))
+{
+    const size_t len = text.length();
+    widths.Empty();
+    widths.Add(0, len);
+
+    if (text.empty())
+        return true;
+
+    // Set layout's text
+    const wxCharBuffer dataUTF8 = wxGTK_CONV_FONT(text, *m_font);
+    if ( !dataUTF8 )
+    {
+        // hardly ideal, but what else can we do if conversion failed?
+        wxLogLastError(wxT("GetPartialTextExtents"));
+        return false;
+    }
+
+    InitCached();
+
+    pango_layout_set_text(m_layout, dataUTF8, -1);
+
+    // Calculate the position of each character based on the widths of
+    // the previous characters
+
+    // Code borrowed from Scintilla's PlatGTK
+    PangoLayoutIter *iter = pango_layout_get_iter(m_layout);
+    PangoRectangle pos;
+    pango_layout_iter_get_cluster_extents(iter, NULL, &pos);
+    size_t i = 0;
+    while (pango_layout_iter_next_cluster(iter))
+    {
+        pango_layout_iter_get_cluster_extents(iter, NULL, &pos);
+        int position = PANGO_PIXELS(pos.x);
+        widths[i++] = position;
+    }
+    while (i < len)
+        widths[i++] = PANGO_PIXELS(pos.x + pos.width);
+    pango_layout_iter_free(iter);
+
+    RestoreStatus();
+
+    return true;
+}
+

Index: src/common/textmeasurecmn.cpp
===================================================================
--- src/common/textmeasurecmn.cpp	(revisión: 0)
+++ src/common/textmeasurecmn.cpp	(revisión: 0)
@@ -0,0 +1,270 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        src/common/textmeasurecmn.cpp
+// Purpose:     wxTextMeasureBase implementation
+// Author:      Manuel Martin
+// Created:     2012-10-05
+// RCS-ID:
+// Copyright:
+// Licence:     wxWindows licence
+///////////////////////////////////////////////////////////////////////////////
+
+// ============================================================================
+// declarations
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// headers
+// ----------------------------------------------------------------------------
+
+// for compilers that support precompilation, includes "wx.h".
+#include "wx/wxprec.h"
+
+#ifndef WX_PRECOMP
+    #include "wx/dc.h"
+    #include "wx/window.h"
+#endif //WX_PRECOMP
+
+#include "wx/private/textmeasure.h"
+
+
+// ============================================================================
+// wxTextMeasureBase implementation
+// ============================================================================
+
+wxTextMeasureBase::wxTextMeasureBase(const wxDCImpl *dc, const wxFont *theFont)
+{
+    wxASSERT_MSG( dc, wxT("wxTextMeasure needs a valid wxDC") );
+    m_font = theFont;
+    m_dc = dc;
+    m_win = NULL;
+}
+
+wxTextMeasureBase::wxTextMeasureBase(const wxWindow *win, const wxFont *theFont)
+{
+    wxASSERT_MSG( win, wxT("wxTextMeasure needs a valid wxWindow") );
+    m_font = theFont;
+    m_dc = NULL;
+    m_win = win;
+}
+
+wxTextMeasureBase::~wxTextMeasureBase()
+{
+}
+
+// We need these when no platform version has been implemented
+void wxTextMeasureBase::InitCached()
+{
+}
+
+void wxTextMeasureBase::RestoreStatus() const
+{
+}
+
+void wxTextMeasureBase::DoGetTextExtent(const wxString& string,
+                                        wxCoord *width,
+                                        wxCoord *height,
+                                        wxCoord *descent,
+                                        wxCoord *externalLeading)
+{
+    // redirect the call to platform implemention when not using wxTextMeasure
+    if ( m_dc )
+        m_dc->DoGetTextExtent(string, width, height, descent, externalLeading, m_font);
+    else
+        m_win->GetTextExtent(string, width, height, descent, externalLeading, m_font);
+}
+
+// InitCached() and RestoreStatus() are used each time a member is called.
+// We could call them at class ctor and dtor. But instead we want the DC
+// or window to be restored to its status _before_ this class is deleted.
+
+// the not virtual, public call
+void wxTextMeasureBase::GetTextExtent(const wxString& string,
+                                      wxCoord *width,
+                                      wxCoord *height,
+                                      wxCoord *descent,
+                                      wxCoord *externalLeading)
+{
+    InitCached();
+
+    DoGetTextExtent(string, width, height, descent, externalLeading);
+
+    // restore dc or win status
+    RestoreStatus();
+}
+
+void wxTextMeasureBase::GetMultiLineTextExtent(const wxString& text,
+                                               wxCoord *width,
+                                               wxCoord *height,
+                                               wxCoord *heightOneLine)
+{
+    InitCached();
+
+    wxCoord widthTextMax = 0, widthLine,
+            heightTextTotal = 0, heightLineDefault = 0, heightLine = 0;
+
+    wxString curLine;
+    for ( wxString::const_iterator pc = text.begin(); ; ++pc )
+    {
+        if ( pc == text.end() || *pc == wxT('\n') )
+        {
+            if ( curLine.empty() )
+            {
+                // we can't use GetTextExtent - it will return 0 for both width
+                // and height and an empty line should count in height
+                // calculation
+
+                // assume that this line has the same height as the previous
+                // one
+                if ( !heightLineDefault )
+                    heightLineDefault = heightLine;
+
+                if ( !heightLineDefault )
+                {
+                    // but we don't know it yet - choose something reasonable
+                    DoGetTextExtent(wxT("W"), NULL, &heightLineDefault, NULL, NULL);
+                }
+
+                heightTextTotal += heightLineDefault;
+            }
+            else
+            {
+                DoGetTextExtent(curLine, &widthLine, &heightLine, NULL, NULL);
+                if ( widthLine > widthTextMax )
+                    widthTextMax = widthLine;
+                heightTextTotal += heightLine;
+            }
+
+            if ( pc == text.end() )
+            {
+               break;
+            }
+            else // '\n'
+            {
+               curLine.clear();
+            }
+        }
+        else
+        {
+            curLine += *pc;
+        }
+    }
+
+    if ( width )
+        *width = widthTextMax;
+    if ( height )
+        *height = heightTextTotal;
+    if ( heightOneLine )
+        *heightOneLine = heightLine;
+
+    // restore dc or win status
+    RestoreStatus();
+}
+
+// Each element of the widths array will be the width of the string up to and
+// including the corresponding character in text.  This is the generic
+// implementation, the port-specific classes should do this with native APIs
+// if available and if faster.  Note: pango_layout_index_to_pos is much slower
+// than calling GetTextExtent!!
+
+#define FWC_SIZE 256
+
+class FontWidthCache
+{
+public:
+    FontWidthCache() : m_scaleX(1), m_widths(NULL) { }
+    ~FontWidthCache() { delete []m_widths; }
+
+    void Reset()
+    {
+        if (!m_widths)
+            m_widths = new int[FWC_SIZE];
+
+        memset(m_widths, 0, sizeof(int)*FWC_SIZE);
+    }
+
+    wxFont m_font;
+    double m_scaleX;
+    int *m_widths;
+};
+
+static FontWidthCache s_fontWidthCache;
+
+bool wxTextMeasureBase::GetPartialTextExtents(const wxString& text,
+                                              wxArrayInt& widths,
+                                              double scaleX)
+{
+    InitCached();
+
+    int totalWidth = 0;
+
+    const size_t len = text.length();
+    widths.Empty();
+    widths.Add(0, len);
+
+    // reset the cache if font or horizontal scale have changed
+    if ( !s_fontWidthCache.m_widths ||
+         !wxIsSameDouble(s_fontWidthCache.m_scaleX, scaleX) ||
+         (s_fontWidthCache.m_font != *m_font) )
+    {
+        s_fontWidthCache.Reset();
+        s_fontWidthCache.m_font = *m_font;
+        s_fontWidthCache.m_scaleX = scaleX;
+    }
+
+    // Calculate the position of each character based on the widths of
+    // the previous characters. This is inexact for not fixed fonts.
+    int w, h;
+    for ( size_t i = 0; i < len; i++ )
+    {
+        const wxChar c = text[i];
+        unsigned int c_int = (unsigned int)c;
+
+        if ((c_int < FWC_SIZE) && (s_fontWidthCache.m_widths[c_int] != 0))
+        {
+            w = s_fontWidthCache.m_widths[c_int];
+        }
+        else
+        {
+            DoGetTextExtent(c, &w, &h, NULL, NULL);
+            if (c_int < FWC_SIZE)
+                s_fontWidthCache.m_widths[c_int] = w;
+        }
+
+        totalWidth += w;
+        widths[i] = totalWidth;
+    }
+
+    // restore dc or win status
+    RestoreStatus();
+
+    return true;
+}
+
+void wxTextMeasureBase::GetLargestStringExtent(const wxVector<wxString>& vStrings,
+                                               wxCoord *width,
+                                               wxCoord *height)
+{
+    wxCoord w, h, widthMax = 0, heightMax = 0;
+    wxVector<wxString>::const_iterator i;
+
+    InitCached();
+
+    for ( i = vStrings.begin(); i != vStrings.end(); i++ )
+    {
+        DoGetTextExtent(*i, &w, &h, NULL, NULL);
+
+        if ( w > widthMax )
+            widthMax = w;
+        if ( h > heightMax )
+            heightMax = h;
+    }
+
+    if (width)
+        *width = widthMax;
+    if (height)
+        *height = heightMax;
+
+    // restore dc or win status
+    RestoreStatus();
+}
+

Index: src/common/dcbase.cpp
===================================================================
--- src/common/dcbase.cpp	(revisión: 72621)
+++ src/common/dcbase.cpp	(copia de trabajo)
@@ -38,6 +38,8 @@
     #include "wx/window.h"
 #endif
 
+#include "wx/private/textmeasure.h"
+
 #ifdef __WXMSW__
     #include "wx/msw/dcclient.h"
     #include "wx/msw/dcmemory.h"
@@ -487,78 +489,10 @@
     ComputeScaleAndOrigin();
 }
 
-
-// Each element of the widths array will be the width of the string up to and
-// including the corresponding character in text.  This is the generic
-// implementation, the port-specific classes should do this with native APIs
-// if available and if faster.  Note: pango_layout_index_to_pos is much slower
-// than calling GetTextExtent!!
-
-#define FWC_SIZE 256
-
-class FontWidthCache
-{
-public:
-    FontWidthCache() : m_scaleX(1), m_widths(NULL) { }
-    ~FontWidthCache() { delete []m_widths; }
-
-    void Reset()
-    {
-        if (!m_widths)
-            m_widths = new int[FWC_SIZE];
-
-        memset(m_widths, 0, sizeof(int)*FWC_SIZE);
-    }
-
-    wxFont m_font;
-    double m_scaleX;
-    int *m_widths;
-};
-
-static FontWidthCache s_fontWidthCache;
-
 bool wxDCImpl::DoGetPartialTextExtents(const wxString& text, wxArrayInt& widths) const
 {
-    int totalWidth = 0;
-
-    const size_t len = text.length();
-    widths.Empty();
-    widths.Add(0, len);
-
-    // reset the cache if font or horizontal scale have changed
-    if ( !s_fontWidthCache.m_widths ||
-         !wxIsSameDouble(s_fontWidthCache.m_scaleX, m_scaleX) ||
-         (s_fontWidthCache.m_font != GetFont()) )
-    {
-        s_fontWidthCache.Reset();
-        s_fontWidthCache.m_font = GetFont();
-        s_fontWidthCache.m_scaleX = m_scaleX;
-    }
-
-    // Calculate the position of each character based on the widths of
-    // the previous characters
-    int w, h;
-    for ( size_t i = 0; i < len; i++ )
-    {
-        const wxChar c = text[i];
-        unsigned int c_int = (unsigned int)c;
-
-        if ((c_int < FWC_SIZE) && (s_fontWidthCache.m_widths[c_int] != 0))
-        {
-            w = s_fontWidthCache.m_widths[c_int];
-        }
-        else
-        {
-            DoGetTextExtent(c, &w, &h);
-            if (c_int < FWC_SIZE)
-                s_fontWidthCache.m_widths[c_int] = w;
-        }
-
-        totalWidth += w;
-        widths[i] = totalWidth;
-    }
-
-    return true;
+    wxTextMeasure tm(this, &m_font);
+    return tm.GetPartialTextExtents(text, widths, m_scaleX);
 }
 
 void wxDCImpl::GetMultiLineTextExtent(const wxString& text,
@@ -567,64 +501,9 @@
                                       wxCoord *h,
                                       const wxFont *font) const
 {
-    wxCoord widthTextMax = 0, widthLine,
-            heightTextTotal = 0, heightLineDefault = 0, heightLine = 0;
-
-    wxString curLine;
-    for ( wxString::const_iterator pc = text.begin(); ; ++pc )
-    {
-        if ( pc == text.end() || *pc == wxT('\n') )
-        {
-            if ( curLine.empty() )
-            {
-                // we can't use GetTextExtent - it will return 0 for both width
-                // and height and an empty line should count in height
-                // calculation
-
-                // assume that this line has the same height as the previous
-                // one
-                if ( !heightLineDefault )
-                    heightLineDefault = heightLine;
-
-                if ( !heightLineDefault )
-                {
-                    // but we don't know it yet - choose something reasonable
-                    DoGetTextExtent(wxT("W"), NULL, &heightLineDefault,
-                                  NULL, NULL, font);
-                }
-
-                heightTextTotal += heightLineDefault;
-            }
-            else
-            {
-                DoGetTextExtent(curLine, &widthLine, &heightLine,
-                              NULL, NULL, font);
-                if ( widthLine > widthTextMax )
-                    widthTextMax = widthLine;
-                heightTextTotal += heightLine;
-            }
-
-            if ( pc == text.end() )
-            {
-               break;
-            }
-            else // '\n'
-            {
-               curLine.clear();
-            }
-        }
-        else
-        {
-            curLine += *pc;
-        }
-    }
-
-    if ( x )
-        *x = widthTextMax;
-    if ( y )
-        *y = heightTextTotal;
-    if ( h )
-        *h = heightLine;
+    const wxFont *fontToUse = (font && font->IsOk()) ? font : &m_font;
+    wxTextMeasure tm(this, fontToUse);
+    tm.GetMultiLineTextExtent(text, x, y, h);
 }
 
 void wxDCImpl::DoDrawCheckMark(wxCoord x1, wxCoord y1,
