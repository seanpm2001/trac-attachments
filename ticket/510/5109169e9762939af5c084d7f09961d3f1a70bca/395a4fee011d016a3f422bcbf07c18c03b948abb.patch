diff -aburN ../original/build/aclocal/gtk-2.0.m4 ./build/aclocal/gtk-2.0.m4
--- ../original/build/aclocal/gtk-2.0.m4	2007-08-26 12:51:50.000000000 +0200
+++ ./build/aclocal/gtk-2.0.m4	2007-08-26 17:47:40.000000000 +0200
@@ -20,6 +20,11 @@
              pkg_config_args="$pkg_config_args gthread-2.0"
          ;;
       esac
+      case "$module" in
+         gtk+-unix-print) 
+             pkg_config_args="$pkg_config_args gtk+-unix-print-2.0"
+         ;;
+      esac
   done
 
   no_gtk=""
diff -aburN ../original/build/bakefiles/files.bkl ./build/bakefiles/files.bkl
--- ../original/build/bakefiles/files.bkl	2007-08-26 13:07:48.000000000 +0200
+++ ./build/bakefiles/files.bkl	2007-08-26 13:05:46.000000000 +0200
@@ -1049,7 +1049,7 @@
     src/gtk/fontdlg.cpp
     src/gtk/frame.cpp
     src/gtk/gauge.cpp
-    src/gtk/gnome/gprint.cpp
+    src/gtk/print.cpp
     src/gtk/gnome/gvfs.cpp
     src/gtk/listbox.cpp
     src/gtk/mdi.cpp
@@ -1099,7 +1099,7 @@
     wx/gtk/fontdlg.h
     wx/gtk/frame.h
     wx/gtk/gauge.h
-    wx/gtk/gnome/gprint.h
+    wx/gtk/print.h
     wx/gtk/gnome/gvfs.h
     wx/gtk/listbox.h
     wx/gtk/mdi.h
diff -aburN ../original/configure.in ./configure.in
--- ../original/configure.in	2007-08-26 12:54:36.000000000 +0200
+++ ./configure.in	2007-08-26 17:48:01.000000000 +0200
@@ -495,7 +495,6 @@
 WX_ARG_SYS_WITH(libtiff,   [  --with-libtiff          use libtiff (TIFF file format)], wxUSE_LIBTIFF)
 WX_ARG_SYS_WITH(libxpm,    [  --with-libxpm           use libxpm (XPM file format)], wxUSE_LIBXPM)
 WX_ARG_WITH(libmspack,     [  --with-libmspack        use libmspack (CHM help files loading)], wxUSE_LIBMSPACK)
-WX_ARG_WITHOUT(gnomeprint, [  --without-gnomeprint    don't use GNOME printing libraries], wxUSE_LIBGNOMEPRINT)
 WX_ARG_WITH(gnomevfs,      [  --with-gnomevfs         use GNOME VFS for associating MIME types], wxUSE_LIBGNOMEVFS)
 WX_ARG_WITH(hildon,        [  --with-hildon           use Hildon framework for Nokia 770], wxUSE_LIBHILDON)
 WX_ARG_WITH(opengl,        [  --with-opengl           use OpenGL (or Mesa)], wxUSE_OPENGL)
@@ -2740,6 +2739,10 @@
                     GTK_MODULES=gthread
                 fi
 
+                if test "$wxUSE_PRINTING_ARCHITECTURE" = "yes" ; then
+                    GTK_MODULES="gtk+-unix-print $GTK_MODULES"
+                fi
+
                 dnl detect GTK2
                 wx_cv_lib_gtk=
                 if test "x$wxGTK_VERSION" != "x1"
@@ -5481,24 +5484,6 @@
 if test "$WXGTK20" = 1; then
     PKG_PROG_PKG_CONFIG()
 
-    if test "$wxUSE_PRINTING_ARCHITECTURE" = "yes" ; then
-        if test "$wxUSE_LIBGNOMEPRINT" = "yes" ; then
-
-                PKG_CHECK_MODULES(LIBGNOMEPRINTUI,
-                                  [libgnomeprintui-2.2 >= 2.8],
-                    [
-                        CFLAGS="$LIBGNOMEPRINTUI_CFLAGS $CFLAGS"
-                        CXXFLAGS="$LIBGNOMEPRINTUI_CFLAGS $CXXFLAGS"
-                        AC_DEFINE(wxUSE_LIBGNOMEPRINT)
-                    ],
-                    [
-                        AC_MSG_WARN([libgnomeprintui not found, library will use standard PostScript printing])
-                        wxUSE_LIBGNOMEPRINT="no"
-                    ]
-                )
-        fi
-    fi
-
     if test "$wxUSE_MIMETYPE" = "yes" ; then
         if test "$wxUSE_LIBGNOMEVFS" = "yes" ; then
 
@@ -7417,7 +7402,7 @@
 EXTRALIBS_ODBC="$ODBC_LINK"
 EXTRALIBS_STC="-lwxscintilla${lib_debug_suffix}${WX_LIB_FLAVOUR}-${WX_RELEASE}${HOST_SUFFIX}"
 if test "$wxUSE_GUI" = "yes"; then
-    EXTRALIBS_GUI=`echo $GUI_TK_LIBRARY $PNG_LINK $JPEG_LINK $TIFF_LINK $WEBKIT_LINK $EXTRALIBS_HILDON $EXTRALIBS_GNOMEVFS $EXTRALIBS_GNOMEPRINT`
+    EXTRALIBS_GUI=`echo $GUI_TK_LIBRARY $PNG_LINK $JPEG_LINK $TIFF_LINK $WEBKIT_LINK $EXTRALIBS_HILDON $EXTRALIBS_GNOMEVFS`
 fi
 if test "$wxUSE_OPENGL" = "yes"; then
     EXTRALIBS_OPENGL="$LDFLAGS_GL $OPENGL_LIBS"
@@ -7528,7 +7513,6 @@
 AC_SUBST(EXTRALIBS_OPENGL)
 AC_SUBST(EXTRALIBS_SDL)
 AC_SUBST(WITH_PLUGIN_SDL)
-AC_SUBST(EXTRALIBS_GNOMEPRINT)
 AC_SUBST(EXTRALIBS_GNOMEVFS)
 AC_SUBST(EXTRALIBS_HILDON)
 AC_SUBST(UNICODE)
@@ -7549,9 +7533,6 @@
         TOOLKIT_DESC="GTK+"
         if test "$WXGTK20" = 1; then
             TOOLKIT_DESC="$TOOLKIT_DESC 2"
-            if test "$wxUSE_LIBGNOMEPRINT" = "yes" ; then
-                TOOLKIT_EXTRA="$TOOLKIT_EXTRA gnomeprint";
-            fi
             if test "$wxUSE_LIBGNOMEVFS" = "yes" ; then
                 TOOLKIT_EXTRA="$TOOLKIT_EXTRA gnomevfs"
             fi
diff -aburN ../original/docs/latex/wx/dc.tex ./docs/latex/wx/dc.tex
--- ../original/docs/latex/wx/dc.tex	2007-08-26 12:49:12.000000000 +0200
+++ ./docs/latex/wx/dc.tex	2007-08-26 13:10:38.000000000 +0200
@@ -484,6 +484,24 @@
 the rectangle.
 
 
+docs/latex/wx/dc.tex
+
+\membersection{wxDC::DrawScaledBitmap}\label{wxdcdrawscaledbitmap}
+
+\func{void}{DrawScaledBitmap}{\param{const wxBitmap\&}{ bitmap}, \param{wxCoord}{ x}, \param{wxCoord}{ y}, \param{wxCoord}{ w}, \param{wxCoord}{ h}, \param{bool}{ transparent}, \param{int}{ quality = wxIMAGE_QUALITY_NORMAL}}
+
+Draw a bitmap on the device context at the specified point and resize it to the specified size. If {\it transparent} is true and the bitmap has a transparency mask, the bitmap will be drawn transparently.
+
+Under wxGTK, you should use this method with a wxPrinterDC if you want to print an image with a resolution higher than 72 dpi. On every other DC and platform, resizing is done using \helpref{wxImage::Rescale}{wximagerescale}.
+
+For a description of the {\it quality} parameter, see the \helpref{Scale}{wximagescale} function.
+
+When drawing a mono-bitmap, the current text foreground colour will be used to draw the foreground
+of the bitmap (all bits set to 1), and the current text background colour to draw the background
+(all bits set to 0). See also \helpref{SetTextForeground}{wxdcsettextforeground},
+\helpref{SetTextBackground}{wxdcsettextbackground} and \helpref{wxMemoryDC}{wxmemorydc}.
+
+
 \membersection{wxDC::DrawSpline}\label{wxdcdrawspline}
 
 \func{void}{DrawSpline}{\param{int }{n}, \param{wxPoint }{points[]}}
diff -aburN ../original/include/wx/dc.h ./include/wx/dc.h
--- ../original/include/wx/dc.h	2007-08-26 12:51:30.000000000 +0200
+++ ./include/wx/dc.h	2007-08-26 14:10:52.000000000 +0200
@@ -873,6 +873,49 @@
                     bool useMask = false)
         { m_pimpl->DoDrawBitmap(bmp, pt.x, pt.y, useMask); }
 
+    virtual void DrawScaledBitmap(const wxBitmap &bmp, wxCoord x, wxCoord y, wxCoord w, wxCoord h, bool useMask = false, int quality = wxIMAGE_QUALITY_NORMAL)
+        {
+            if (bmp.GetWidth() != w || bmp.GetHeight() != h)
+            {
+                if (quality != wxIMAGE_QUALITY_HIGH)
+                    quality = wxIMAGE_QUALITY_NORMAL;
+                wxImage tmpImg = bmp.ConvertToImage();
+                tmpImg.Rescale( w, h, quality );
+                wxBitmap scaledBmp(tmpImg);
+                m_pimpl->DoDrawBitmap(scaledBmp, x, y, useMask);
+            }
+            else
+                m_pimpl->DoDrawBitmap(bmp, x, y, useMask);
+        }
+    virtual void DrawScaledBitmap(const wxBitmap &bmp, const wxPoint& pt, const wxSize& sz, bool useMask = false, int quality = wxIMAGE_QUALITY_NORMAL)
+        {
+            if (bmp.GetWidth() != sz.x || bmp.GetHeight() != sz.y)
+            {
+                if (quality != wxIMAGE_QUALITY_HIGH)
+                    quality = wxIMAGE_QUALITY_NORMAL;
+                wxImage tmpImg = bmp.ConvertToImage();
+                tmpImg.Rescale( sz.x, sz.y, quality );
+                wxBitmap scaledBmp(tmpImg);
+                m_pimpl->DoDrawBitmap(scaledBmp, pt.x, pt.y, useMask);
+            }
+            else
+                m_pimpl->DoDrawBitmap(bmp, pt.x, pt.y, useMask);
+        }
+    virtual void DrawScaledBitmap(const wxBitmap &bmp, const wxRect& rect, bool useMask = false, int quality = wxIMAGE_QUALITY_NORMAL)
+        {
+            if (bmp.GetWidth() != rect.width || bmp.GetHeight() != rect.height)
+            {
+                if (quality != wxIMAGE_QUALITY_HIGH)
+                    quality = wxIMAGE_QUALITY_NORMAL;
+                wxImage tmpImg = bmp.ConvertToImage();
+                tmpImg.Rescale( rect.width, rect.height, quality );
+                wxBitmap scaledBmp(tmpImg);
+                m_pimpl->DoDrawBitmap(scaledBmp, rect.x, rect.y, useMask);
+            }
+            else
+                m_pimpl->DoDrawBitmap(bmp, rect.x, rect.y, useMask);
+        }
+
     void DrawText(const wxString& text, wxCoord x, wxCoord y)
         { m_pimpl->DoDrawText(text, x, y); }
     void DrawText(const wxString& text, const wxPoint& pt)
@@ -1189,6 +1232,49 @@
                     bool useMask = false)
         { DoDrawBitmap(bmp, pt.x, pt.y, useMask); }
 
+    virtual void DrawScaledBitmap(const wxBitmap &bmp, wxCoord x, wxCoord y, wxCoord w, wxCoord h, bool useMask = false, int quality = wxIMAGE_QUALITY_NORMAL)
+        {
+            if (bmp.GetWidth() != w || bmp.GetHeight() != h)
+            {
+                if (quality != wxIMAGE_QUALITY_HIGH)
+                    quality = wxIMAGE_QUALITY_NORMAL;
+                wxImage tmpImg = bmp.ConvertToImage();
+                tmpImg.Rescale( w, h, quality );
+                wxBitmap scaledBmp(tmpImg);
+                DoDrawBitmap(scaledBmp, x, y, useMask);
+            }
+            else
+                DoDrawBitmap(bmp, x, y, useMask);
+        }
+    virtual void DrawScaledBitmap(const wxBitmap &bmp, const wxPoint& pt, const wxSize& sz, bool useMask = false, int quality = wxIMAGE_QUALITY_NORMAL)
+        {
+            if (bmp.GetWidth() != sz.x || bmp.GetHeight() != sz.y)
+            {
+                if (quality != wxIMAGE_QUALITY_HIGH)
+                    quality = wxIMAGE_QUALITY_NORMAL;
+                wxImage tmpImg = bmp.ConvertToImage();
+                tmpImg.Rescale( sz.x, sz.y, quality );
+                wxBitmap scaledBmp(tmpImg);
+                DoDrawBitmap(scaledBmp, pt.x, pt.y, useMask);
+            }
+            else
+                DoDrawBitmap(bmp, pt.x, pt.y, useMask);
+        }
+    virtual void DrawScaledBitmap(const wxBitmap &bmp, const wxRect& rect, bool useMask = false, int quality = wxIMAGE_QUALITY_NORMAL)
+        {
+            if (bmp.GetWidth() != rect.width || bmp.GetHeight() != rect.height)
+            {
+                if (quality != wxIMAGE_QUALITY_HIGH)
+                    quality = wxIMAGE_QUALITY_NORMAL;
+                wxImage tmpImg = bmp.ConvertToImage();
+                tmpImg.Rescale( rect.width, rect.height, quality );
+                wxBitmap scaledBmp(tmpImg);
+                DoDrawBitmap(scaledBmp, rect.x, rect.y, useMask);
+            }
+            else
+                DoDrawBitmap(bmp, rect.x, rect.y, useMask);
+        }
+
     void DrawText(const wxString& text, wxCoord x, wxCoord y)
         { DoDrawText(text, x, y); }
     void DrawText(const wxString& text, const wxPoint& pt)
diff -aburN ../original/include/wx/gtk/gnome/gprint.h ./include/wx/gtk/gnome/gprint.h
--- ../original/include/wx/gtk/gnome/gprint.h	2007-08-26 12:51:14.000000000 +0200
+++ ./include/wx/gtk/gnome/gprint.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,353 +0,0 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        wx/gtk/gnome/gprint.h
-// Author:      Robert Roebling
-// Purpose:     GNOME printing support
-// Created:     09/20/04
-// RCS-ID:      $Id: gprint.h 46225 2007-05-26 22:27:58Z RR $
-// Copyright:   Robert Roebling
-// Licence:     wxWindows Licence
-/////////////////////////////////////////////////////////////////////////////
-
-#ifndef _WX_GTK_GPRINT_H_
-#define _WX_GTK_GPRINT_H_
-
-#include "wx/defs.h"
-
-#if wxUSE_LIBGNOMEPRINT
-
-#include "wx/print.h"
-#include "wx/printdlg.h"
-#include "wx/dc.h"
-
-typedef struct _GnomePrintJob GnomePrintJob;
-typedef struct _GnomePrintContext GnomePrintContext;
-typedef struct _GnomePrintConfig GnomePrintConfig;
-
-//----------------------------------------------------------------------------
-// wxGnomePrintNativeData
-//----------------------------------------------------------------------------
-
-class wxGnomePrintNativeData: public wxPrintNativeDataBase
-{
-public:
-    wxGnomePrintNativeData();
-    virtual ~wxGnomePrintNativeData();
-
-    virtual bool TransferTo( wxPrintData &data );
-    virtual bool TransferFrom( const wxPrintData &data );
-
-    virtual bool Ok() const { return IsOk(); }
-    virtual bool IsOk() const { return true; }
-
-    GnomePrintConfig* GetPrintConfig() { return m_config; }
-    void SetPrintJob( GnomePrintJob *job ) { m_job = job; }
-    GnomePrintJob* GetPrintJob() { return m_job; }
-
-
-private:
-    GnomePrintConfig  *m_config;
-    GnomePrintJob     *m_job;
-
-    DECLARE_DYNAMIC_CLASS(wxGnomePrintNativeData)
-};
-
-//----------------------------------------------------------------------------
-// wxGnomePrintFactory
-//----------------------------------------------------------------------------
-
-class wxGnomePrintFactory: public wxPrintFactory
-{
-public:
-    virtual wxPrinterBase *CreatePrinter( wxPrintDialogData *data );
-
-    virtual wxPrintPreviewBase *CreatePrintPreview( wxPrintout *preview,
-                                                    wxPrintout *printout = NULL,
-                                                    wxPrintDialogData *data = NULL );
-    virtual wxPrintPreviewBase *CreatePrintPreview( wxPrintout *preview,
-                                                    wxPrintout *printout,
-                                                    wxPrintData *data );
-
-    virtual wxPrintDialogBase *CreatePrintDialog( wxWindow *parent,
-                                                  wxPrintDialogData *data = NULL );
-    virtual wxPrintDialogBase *CreatePrintDialog( wxWindow *parent,
-                                                  wxPrintData *data );
-
-    virtual wxPageSetupDialogBase *CreatePageSetupDialog( wxWindow *parent,
-                                                          wxPageSetupDialogData * data = NULL );
-
-    virtual wxDC* CreatePrinterDC( const wxPrintData& data );
-
-    virtual bool HasPrintSetupDialog();
-    virtual wxDialog *CreatePrintSetupDialog( wxWindow *parent, wxPrintData *data );
-    virtual bool HasOwnPrintToFile();
-    virtual bool HasPrinterLine();
-    virtual wxString CreatePrinterLine();
-    virtual bool HasStatusLine();
-    virtual wxString CreateStatusLine();
-
-    virtual wxPrintNativeDataBase *CreatePrintNativeData();
-};
-
-//----------------------------------------------------------------------------
-// wxGnomePrintDialog
-//----------------------------------------------------------------------------
-
-class wxGnomePrintDialog: public wxPrintDialogBase
-{
-public:
-    wxGnomePrintDialog( wxWindow *parent,
-                         wxPrintDialogData* data = NULL );
-    wxGnomePrintDialog( wxWindow *parent, wxPrintData* data);
-    virtual ~wxGnomePrintDialog();
-
-    wxPrintData& GetPrintData()
-        { return m_printDialogData.GetPrintData(); }
-    wxPrintDialogData& GetPrintDialogData()
-        { return m_printDialogData; }
-
-    wxDC *GetPrintDC();
-
-    virtual int ShowModal();
-
-    virtual bool Validate();
-    virtual bool TransferDataToWindow();
-    virtual bool TransferDataFromWindow();
-
-protected:
-    // Implement some base class methods to do nothing to avoid asserts and
-    // GTK warnings, since this is not a real wxDialog.
-    virtual void DoSetSize(int WXUNUSED(x), int WXUNUSED(y),
-                           int WXUNUSED(width), int WXUNUSED(height),
-                           int WXUNUSED(sizeFlags) = wxSIZE_AUTO) {}
-    virtual void DoMoveWindow(int WXUNUSED(x), int WXUNUSED(y),
-                              int WXUNUSED(width), int WXUNUSED(height)) {}
-
-private:
-    void Init();
-    wxPrintDialogData   m_printDialogData;
-
-    DECLARE_DYNAMIC_CLASS(wxGnomePrintDialog)
-};
-
-//----------------------------------------------------------------------------
-// wxGnomePageSetupDialog
-//----------------------------------------------------------------------------
-
-class wxGnomePageSetupDialog: public wxPageSetupDialogBase
-{
-public:
-    wxGnomePageSetupDialog( wxWindow *parent,
-                            wxPageSetupDialogData* data = NULL );
-    virtual ~wxGnomePageSetupDialog();
-
-    virtual wxPageSetupDialogData& GetPageSetupDialogData();
-
-    virtual int ShowModal();
-
-    virtual bool Validate();
-    virtual bool TransferDataToWindow();
-    virtual bool TransferDataFromWindow();
-
-protected:
-    // Implement some base class methods to do nothing to avoid asserts and
-    // GTK warnings, since this is not a real wxDialog.
-    virtual void DoSetSize(int WXUNUSED(x), int WXUNUSED(y),
-                           int WXUNUSED(width), int WXUNUSED(height),
-                           int WXUNUSED(sizeFlags) = wxSIZE_AUTO) {}
-    virtual void DoMoveWindow(int WXUNUSED(x), int WXUNUSED(y),
-                              int WXUNUSED(width), int WXUNUSED(height)) {}
-
-private:
-    wxPageSetupDialogData   m_pageDialogData;
-
-    DECLARE_DYNAMIC_CLASS(wxGnomePageSetupDialog)
-};
-
-//----------------------------------------------------------------------------
-// wxGnomePrinter
-//----------------------------------------------------------------------------
-
-class wxGnomePrinter: public wxPrinterBase
-{
-public:
-    wxGnomePrinter(wxPrintDialogData *data = NULL);
-    virtual ~wxGnomePrinter();
-
-    virtual bool Print(wxWindow *parent,
-                       wxPrintout *printout,
-                       bool prompt = true);
-    virtual wxDC* PrintDialog(wxWindow *parent);
-    virtual bool Setup(wxWindow *parent);
-
-private:
-    bool               m_native_preview;
-
-private:
-    DECLARE_DYNAMIC_CLASS(wxGnomePrinter)
-    DECLARE_NO_COPY_CLASS(wxGnomePrinter)
-};
-
-//-----------------------------------------------------------------------------
-// wxGnomePrintDC
-//-----------------------------------------------------------------------------
-
-class wxGnomePrintDC: public wxDC
-{
-public:
-    wxGnomePrintDC( const wxPrintData& data );
-    virtual ~wxGnomePrintDC();
-
-    bool Ok() const { return IsOk(); }
-    bool IsOk() const;
-
-    bool CanDrawBitmap() const { return true; }
-    void Clear();
-    void SetFont( const wxFont& font );
-    void SetPen( const wxPen& pen );
-    void SetBrush( const wxBrush& brush );
-    void SetLogicalFunction( int function );
-    void SetBackground( const wxBrush& brush );
-    void DestroyClippingRegion();
-    bool StartDoc(const wxString& message);
-    void EndDoc();
-    void StartPage();
-    void EndPage();
-    wxCoord GetCharHeight() const;
-    wxCoord GetCharWidth() const;
-    bool CanGetTextExtent() const { return true; }
-    wxSize GetPPI() const;
-    void SetAxisOrientation( bool xLeftRight, bool yBottomUp );
-    void SetLogicalOrigin( wxCoord x, wxCoord y );
-    void SetDeviceOrigin( wxCoord x, wxCoord y );
-    virtual int GetDepth() const { return 24; }
-    void SetBackgroundMode(int WXUNUSED(mode)) { }
-    void SetPalette(const wxPalette& WXUNUSED(palette)) { }
-    static void SetResolution(int ppi);
-    static int GetResolution();
-
-protected:
-    bool DoFloodFill(wxCoord x1, wxCoord y1, const wxColour &col, int style=wxFLOOD_SURFACE );
-    bool DoGetPixel(wxCoord x1, wxCoord y1, wxColour *col) const;
-    void DoDrawLine(wxCoord x1, wxCoord y1, wxCoord x2, wxCoord y2);
-    void DoCrossHair(wxCoord x, wxCoord y);
-    void DoDrawArc(wxCoord x1,wxCoord y1,wxCoord x2,wxCoord y2,wxCoord xc,wxCoord yc);
-    void DoDrawEllipticArc(wxCoord x,wxCoord y,wxCoord w,wxCoord h,double sa,double ea);
-    void DoDrawPoint(wxCoord x, wxCoord y);
-    void DoDrawLines(int n, wxPoint points[], wxCoord xoffset = 0, wxCoord yoffset = 0);
-    void DoDrawPolygon(int n, wxPoint points[], wxCoord xoffset = 0, wxCoord yoffset = 0, int fillStyle=wxODDEVEN_RULE);
-    void DoDrawPolyPolygon(int n, int count[], wxPoint points[], wxCoord xoffset = 0, wxCoord yoffset = 0, int fillStyle=wxODDEVEN_RULE);
-    void DoDrawRectangle(wxCoord x, wxCoord y, wxCoord width, wxCoord height);
-    void DoDrawRoundedRectangle(wxCoord x, wxCoord y, wxCoord width, wxCoord height, double radius = 20.0);
-    void DoDrawEllipse(wxCoord x, wxCoord y, wxCoord width, wxCoord height);
-#if wxUSE_SPLINES
-    void DoDrawSpline(wxList *points);
-#endif // wxUSE_SPLINES
-    bool DoBlit(wxCoord xdest, wxCoord ydest, wxCoord width, wxCoord height,
-            wxDC *source, wxCoord xsrc, wxCoord ysrc, int rop = wxCOPY, bool useMask = false,
-            wxCoord xsrcMask = wxDefaultCoord, wxCoord ysrcMask = wxDefaultCoord);
-    void DoDrawIcon( const wxIcon& icon, wxCoord x, wxCoord y );
-    void DoDrawBitmap( const wxBitmap& bitmap, wxCoord x, wxCoord y, bool useMask = false  );
-    void DoDrawText(const wxString& text, wxCoord x, wxCoord y );
-    void DoDrawRotatedText(const wxString& text, wxCoord x, wxCoord y, double angle);
-    void DoSetClippingRegion(wxCoord x, wxCoord y, wxCoord width, wxCoord height);
-    void DoSetClippingRegionAsRegion( const wxRegion &WXUNUSED(clip) ) { }
-    void DoGetTextExtent(const wxString& string, wxCoord *x, wxCoord *y,
-                     wxCoord *descent = (wxCoord *) NULL,
-                     wxCoord *externalLeading = (wxCoord *) NULL,
-                     const wxFont *theFont = (wxFont *) NULL ) const;
-    void DoGetSize(int* width, int* height) const;
-    void DoGetSizeMM(int *width, int *height) const;
-
-    void SetPrintData(const wxPrintData& data);
-    wxPrintData& GetPrintData() { return m_printData; }
-
-private:
-    static float ms_PSScaleFactor;
-
-private:
-    wxPrintData             m_printData;
-    PangoContext           *m_context;
-    PangoLayout            *m_layout;
-    PangoFontDescription   *m_fontdesc;
-
-    unsigned char           m_currentRed;
-    unsigned char           m_currentGreen;
-    unsigned char           m_currentBlue;
-
-    int                     m_deviceOffsetY;
-
-    GnomePrintContext      *m_gpc;
-    GnomePrintJob*          m_job;
-
-    void makeEllipticalPath(wxCoord x, wxCoord y, wxCoord width, wxCoord height);
-
-private:
-    wxCoord XDEV2LOG(wxCoord x) const
-    {
-        return wxRound((double)(x - m_deviceOriginX) / m_scaleX) * m_signX + m_logicalOriginX;
-    }
-    wxCoord XDEV2LOGREL(wxCoord x) const
-    {
-        return wxRound((double)(x) / m_scaleX);
-    }
-    wxCoord YDEV2LOG(wxCoord y) const
-    {
-        return wxRound((double)(y + m_deviceOriginY - m_deviceOffsetY) / m_scaleY) * m_signY + m_logicalOriginY;
-    }
-    wxCoord YDEV2LOGREL(wxCoord y) const
-    {
-        return wxRound((double)(y) / m_scaleY);
-    }
-    wxCoord XLOG2DEV(wxCoord x) const
-    {
-        return wxRound((double)(x - m_logicalOriginX) * m_scaleX) * m_signX + m_deviceOriginX;
-    }
-    wxCoord XLOG2DEVREL(wxCoord x) const
-    {
-        return wxRound((double)(x) * m_scaleX);
-    }
-    wxCoord YLOG2DEV(wxCoord y) const
-    {
-        return wxRound((double)(y - m_logicalOriginY) * m_scaleY) * m_signY - m_deviceOriginY + m_deviceOffsetY;
-    }
-    wxCoord YLOG2DEVREL(wxCoord y) const
-    {
-        return wxRound((double)(y) * m_scaleY);
-    }
-private:
-    DECLARE_DYNAMIC_CLASS(wxGnomePrintDC)
-    DECLARE_NO_COPY_CLASS(wxGnomePrintDC)
-};
-
-// ----------------------------------------------------------------------------
-// wxGnomePrintPreview: programmer creates an object of this class to preview a
-// wxPrintout.
-// ----------------------------------------------------------------------------
-
-class wxGnomePrintPreview : public wxPrintPreviewBase
-{
-public:
-    wxGnomePrintPreview(wxPrintout *printout,
-                             wxPrintout *printoutForPrinting = (wxPrintout *) NULL,
-                             wxPrintDialogData *data = (wxPrintDialogData *) NULL);
-    wxGnomePrintPreview(wxPrintout *printout,
-                             wxPrintout *printoutForPrinting,
-                             wxPrintData *data);
-
-    virtual ~wxGnomePrintPreview();
-
-    virtual bool Print(bool interactive);
-    virtual void DetermineScaling();
-
-private:
-    void Init(wxPrintout *printout, wxPrintout *printoutForPrinting);
-
-private:
-    DECLARE_CLASS(wxGnomePrintPreview)
-};
-
-
-#endif
-    // wxUSE_LIBGNOMEPRINT
-
-#endif
diff -aburN ../original/include/wx/gtk/print.h ./include/wx/gtk/print.h
--- ../original/include/wx/gtk/print.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/wx/gtk/print.h	2007-08-26 16:10:08.000000000 +0200
@@ -0,0 +1,359 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/gtk/print.h
+// Author:      Anthony Bretaudeau
+// Purpose:     GTK printing support
+// Created:     2007-08-25
+// RCS-ID:      $Id: print.h,v 1 2007-08-25 05:44:44 PC Exp $
+// Copyright:   (c) 2007 wxWidgets development team
+// Licence:     wxWindows Licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_GTK_PRINT_H_
+#define _WX_GTK_PRINT_H_
+
+#include "wx/defs.h"
+
+#include "wx/print.h"
+#include "wx/printdlg.h"
+#include "wx/prntbase.h"
+#include "wx/dc.h"
+
+#include <cairo.h>
+
+typedef struct _GtkPrintOperation GtkPrintOperation;
+typedef struct _GtkPrintContext GtkPrintContext;
+typedef struct _GtkPrintSettings GtkPrintSettings;
+typedef struct _GtkPageSetup GtkPageSetup;
+
+//----------------------------------------------------------------------------
+// wxGtkPrintDialog
+//----------------------------------------------------------------------------
+
+class WXDLLIMPEXP_CORE wxGtkPrintDialog: public wxPrintDialogBase
+{
+public:
+    wxGtkPrintDialog( wxWindow *parent,
+                         wxPrintDialogData* data = NULL );
+    wxGtkPrintDialog( wxWindow *parent, wxPrintData* data);
+    virtual ~wxGtkPrintDialog();
+
+    wxPrintData& GetPrintData()
+        { return m_printDialogData.GetPrintData(); }
+    wxPrintDialogData& GetPrintDialogData()
+        { return m_printDialogData; }
+
+    wxDC *GetPrintDC() { return m_dc; }
+    void SetPrintDC(wxDC * printDC) { m_dc = printDC; }
+
+    virtual int ShowModal();
+
+    virtual bool Validate() { return true; }
+    virtual bool TransferDataToWindow() { return true; }
+    virtual bool TransferDataFromWindow() { return true; }
+
+    void SetShowDialog(bool show) { m_showDialog = show; }
+    bool GetShowDialog() { return m_showDialog; }
+
+protected:
+    // Implement some base class methods to do nothing to avoid asserts and
+    // GTK warnings, since this is not a real wxDialog.
+    virtual void DoSetSize(int WXUNUSED(x), int WXUNUSED(y),
+                           int WXUNUSED(width), int WXUNUSED(height),
+                           int WXUNUSED(sizeFlags) = wxSIZE_AUTO) {}
+    virtual void DoMoveWindow(int WXUNUSED(x), int WXUNUSED(y),
+                              int WXUNUSED(width), int WXUNUSED(height)) {}
+
+private:
+    wxPrintDialogData    m_printDialogData;
+    wxWindow            *m_parent;
+    bool                 m_showDialog;
+    wxDC                *m_dc;
+
+    DECLARE_DYNAMIC_CLASS(wxGtkPrintDialog)
+};
+
+//----------------------------------------------------------------------------
+// wxGtkPageSetupDialog
+//----------------------------------------------------------------------------
+
+class WXDLLIMPEXP_CORE wxGtkPageSetupDialog: public wxPageSetupDialogBase
+{
+public:
+    wxGtkPageSetupDialog( wxWindow *parent,
+                            wxPageSetupDialogData* data = NULL );
+    virtual ~wxGtkPageSetupDialog();
+
+    virtual wxPageSetupDialogData& GetPageSetupDialogData() { return m_pageDialogData; }
+
+    virtual int ShowModal();
+
+    virtual bool Validate() { return true; }
+    virtual bool TransferDataToWindow() { return true; }
+    virtual bool TransferDataFromWindow() { return true; }
+
+protected:
+    // Implement some base class methods to do nothing to avoid asserts and
+    // GTK warnings, since this is not a real wxDialog.
+    virtual void DoSetSize(int WXUNUSED(x), int WXUNUSED(y),
+                           int WXUNUSED(width), int WXUNUSED(height),
+                           int WXUNUSED(sizeFlags) = wxSIZE_AUTO) {}
+    virtual void DoMoveWindow(int WXUNUSED(x), int WXUNUSED(y),
+                              int WXUNUSED(width), int WXUNUSED(height)) {}
+
+private:
+    wxPageSetupDialogData    m_pageDialogData;
+    wxWindow                *m_parent;
+
+    DECLARE_DYNAMIC_CLASS(wxGtkPageSetupDialog)
+};
+
+//----------------------------------------------------------------------------
+// wxGtkPrinter
+//----------------------------------------------------------------------------
+
+class WXDLLIMPEXP_CORE wxGtkPrinter : public wxPrinterBase
+{
+public:
+    wxGtkPrinter(wxPrintDialogData *data = NULL);
+    virtual ~wxGtkPrinter();
+
+    virtual bool Print(wxWindow *parent,
+                       wxPrintout *printout,
+                       bool prompt = true);
+    virtual wxDC* PrintDialog(wxWindow *parent);
+    virtual bool Setup(wxWindow *parent);
+
+    GtkPrintContext *GetPrintContext() { return m_gpc; }
+    void SetPrintContext(GtkPrintContext *context) {m_gpc = context;}
+    void BeginPrint(wxPrintout *printout, GtkPrintOperation *operation, GtkPrintContext *context);
+    void DrawPage(wxPrintout *printout, GtkPrintOperation *operation, GtkPrintContext *context, int page_nr);
+
+private:
+    GtkPrintContext *m_gpc;
+    bool             m_showDialog;
+    wxDC            *m_dc;
+
+    DECLARE_DYNAMIC_CLASS(wxGtkPrinter)
+    DECLARE_NO_COPY_CLASS(wxGtkPrinter)
+};
+
+//----------------------------------------------------------------------------
+// wxGtkPrintNativeData
+//----------------------------------------------------------------------------
+
+class WXDLLIMPEXP_CORE wxGtkPrintNativeData : public wxPrintNativeDataBase
+{
+public:
+    wxGtkPrintNativeData();
+    virtual ~wxGtkPrintNativeData();
+
+    virtual bool TransferTo( wxPrintData &data );
+    virtual bool TransferFrom( const wxPrintData &data );
+
+    virtual bool Ok() const { return IsOk(); }
+    virtual bool IsOk() const { return true; }
+
+    GtkPrintSettings* GetPrintConfig() { return m_config; }
+    void SetPrintConfig( GtkPrintSettings * config );
+
+    void SetPrintJob( GtkPrintOperation *job ) { m_job = job; }
+    GtkPrintOperation* GetPrintJob() { return m_job; }
+
+    GtkPrintContext *GetPrintContext() { return m_context; }
+    void SetPrintContext(GtkPrintContext *context) {m_context = context; }
+
+
+    GtkPageSetup* GetPageSetupFromSettings(GtkPrintSettings* settings);
+    void SetPageSetupToSettings(GtkPrintSettings* settings, GtkPageSetup* page_setup);
+
+private:
+    GtkPrintSettings    *m_config;
+    GtkPrintOperation   *m_job;
+    GtkPrintContext     *m_context;
+
+    DECLARE_DYNAMIC_CLASS(wxGtkPrintNativeData)
+};
+
+//-----------------------------------------------------------------------------
+// wxGtkPrintDC
+//-----------------------------------------------------------------------------
+
+class WXDLLIMPEXP_CORE wxGtkPrintDC: public wxDC
+{
+public:
+    wxGtkPrintDC( const wxPrintData& data );
+    virtual ~wxGtkPrintDC();
+
+    bool Ok() const { return IsOk(); }
+    bool IsOk() const;
+
+    bool CanDrawBitmap() const { return true; }
+    void Clear();
+    void SetFont( const wxFont& font );
+    void SetPen( const wxPen& pen );
+    void SetBrush( const wxBrush& brush );
+    void SetLogicalFunction( int function );
+    void SetBackground( const wxBrush& brush );
+    void DestroyClippingRegion();
+    bool StartDoc(const wxString& message);
+    void EndDoc();
+    void StartPage();
+    void EndPage();
+    wxCoord GetCharHeight() const;
+    wxCoord GetCharWidth() const;
+    bool CanGetTextExtent() const { return true; }
+    wxSize GetPPI() const;
+    void SetLogicalOrigin( wxCoord x, wxCoord y );
+    void SetDeviceOrigin( wxCoord x, wxCoord y );
+    virtual int GetDepth() const { return 24; }
+    void SetBackgroundMode(int WXUNUSED(mode));
+    void SetPalette(const wxPalette& WXUNUSED(palette)) { }
+    static void SetResolution(int ppi);
+    static int GetResolution();
+    void DrawScaledBitmap(const wxBitmap &bmp, wxCoord x, wxCoord y, wxCoord w, wxCoord h,
+                    bool useMask = false, int quality = wxIMAGE_QUALITY_NORMAL)
+        { DoDrawScaledBitmap( bmp, x, y, w, h, useMask, quality ); }
+    void DrawScaledBitmap(const wxBitmap &bmp, const wxPoint& pt, const wxSize& sz,
+                    bool useMask = false, int quality = wxIMAGE_QUALITY_NORMAL)
+        { DoDrawScaledBitmap( bmp, pt.x, pt.y, sz.x, sz.y, useMask, quality ); }
+    void DrawScaledBitmap(const wxBitmap &bmp, const wxRect& rect,
+                    bool useMask = false, int quality = wxIMAGE_QUALITY_NORMAL)
+        { DoDrawScaledBitmap( bmp, rect.x, rect.y, rect.width, rect.height, useMask, quality ); }
+
+protected:
+    bool DoFloodFill(wxCoord x1, wxCoord y1, const wxColour &col, int style=wxFLOOD_SURFACE );
+    void DoGradientFillConcentric(const wxRect& rect, const wxColour& initialColour, const wxColour& destColour, const wxPoint& circleCenter);
+    void DoGradientFillLinear(const wxRect& rect, const wxColour& initialColour, const wxColour& destColour, wxDirection nDirection = wxEAST);
+    bool DoGetPixel(wxCoord x1, wxCoord y1, wxColour *col) const;
+    void DoDrawLine(wxCoord x1, wxCoord y1, wxCoord x2, wxCoord y2);
+    void DoCrossHair(wxCoord x, wxCoord y);
+    void DoDrawArc(wxCoord x1,wxCoord y1,wxCoord x2,wxCoord y2,wxCoord xc,wxCoord yc);
+    void DoDrawEllipticArc(wxCoord x,wxCoord y,wxCoord w,wxCoord h,double sa,double ea);
+    void DoDrawPoint(wxCoord x, wxCoord y);
+    void DoDrawLines(int n, wxPoint points[], wxCoord xoffset = 0, wxCoord yoffset = 0);
+    void DoDrawPolygon(int n, wxPoint points[], wxCoord xoffset = 0, wxCoord yoffset = 0, int fillStyle=wxODDEVEN_RULE);
+    void DoDrawPolyPolygon(int n, int count[], wxPoint points[], wxCoord xoffset = 0, wxCoord yoffset = 0, int fillStyle=wxODDEVEN_RULE);
+    void DoDrawRectangle(wxCoord x, wxCoord y, wxCoord width, wxCoord height);
+    void DoDrawRoundedRectangle(wxCoord x, wxCoord y, wxCoord width, wxCoord height, double radius = 20.0);
+    void DoDrawEllipse(wxCoord x, wxCoord y, wxCoord width, wxCoord height);
+#if wxUSE_SPLINES
+    void DoDrawSpline(wxList *points);
+#endif // wxUSE_SPLINES
+    bool DoBlit(wxCoord xdest, wxCoord ydest, wxCoord width, wxCoord height,
+            wxDC *source, wxCoord xsrc, wxCoord ysrc, int rop = wxCOPY, bool useMask = false,
+            wxCoord xsrcMask = wxDefaultCoord, wxCoord ysrcMask = wxDefaultCoord);
+    void DoDrawIcon( const wxIcon& icon, wxCoord x, wxCoord y );
+    void DoDrawBitmap( const wxBitmap& bitmap, wxCoord x, wxCoord y, bool useMask = false  );
+    void DoDrawScaledBitmap( const wxBitmap& bitmap, wxCoord x, wxCoord y, wxCoord w, wxCoord h, bool useMask = false, int quality = wxIMAGE_QUALITY_NORMAL );
+    void DoDrawText(const wxString& text, wxCoord x, wxCoord y );
+    void DoDrawRotatedText(const wxString& text, wxCoord x, wxCoord y, double angle);
+    void DoSetClippingRegion(wxCoord x, wxCoord y, wxCoord width, wxCoord height);
+    void DoSetClippingRegionAsRegion( const wxRegion &WXUNUSED(clip) ) { }
+    void DoGetTextExtent(const wxString& string, wxCoord *x, wxCoord *y,
+                     wxCoord *descent = (wxCoord *) NULL,
+                     wxCoord *externalLeading = (wxCoord *) NULL,
+                     const wxFont *theFont = (wxFont *) NULL ) const;
+    void DoGetSize(int* width, int* height) const;
+    void DoGetSizeMM(int *width, int *height) const;
+
+    wxPrintData& GetPrintData() { return m_printData; }
+    void SetPrintData(const wxPrintData& data);
+
+    void ComputeScaleAndOrigin();
+
+private:
+    static float ms_PSScaleFactor;
+
+    wxPrintData             m_printData;
+    PangoContext           *m_context;
+    PangoLayout            *m_layout;
+    PangoFontDescription   *m_fontdesc;
+    cairo_t                *m_cairo;
+
+    unsigned char           m_currentRed;
+    unsigned char           m_currentGreen;
+    unsigned char           m_currentBlue;
+    unsigned char           m_currentAlpha;
+
+    int                     m_deviceOffsetY;
+    int                     m_deviceOffsetX;
+
+    GtkPrintContext      *m_gpc;
+    static int            ms_resolution;
+
+    wxCoord DeviceToLogicalX(wxCoord x) const
+    {
+        int addValue = 0;
+        if (m_signX == -1) addValue = m_deviceOffsetX - m_deviceOriginX; // right to left
+        else addValue = m_deviceOriginX;// left to right
+        return (wxCoord) ((double)(x - addValue) * m_signX + m_logicalOriginX);
+    }
+    wxCoord DeviceToLogicalXRel(wxCoord x) const
+    {
+        return x;
+    }
+    wxCoord DeviceToLogicalY(wxCoord y) const
+    {
+        int addValue = 0;
+        if (m_signY == -1) addValue = m_deviceOffsetY - m_deviceOriginY; // bottom to up
+        else addValue = m_deviceOriginY;// up to bottom
+        return (wxCoord) ((double)(y - addValue) * m_signY + m_logicalOriginY);
+    }
+    wxCoord DeviceToLogicalYRel(wxCoord y) const
+    {
+        return y;
+    }
+    wxCoord LogicalToDeviceX(wxCoord x) const
+    {
+        int addValue = 0;
+        if (m_signX == -1) addValue = m_deviceOffsetX - m_deviceOriginX; // right to left
+        else addValue = m_deviceOriginX;// left to right
+        return (wxCoord) ((double)(x - m_logicalOriginX) * m_signX + addValue);
+    }
+    wxCoord LogicalToDeviceXRel(wxCoord x) const
+    {
+        return x;
+    }
+    wxCoord LogicalToDeviceY(wxCoord y) const
+    {
+        int addValue = 0;
+        if (m_signY == -1) addValue = m_deviceOffsetY - m_deviceOriginY; // bottom to up
+        else addValue = m_deviceOriginY;// up to bottom
+        return (wxCoord) ((double)(y - m_logicalOriginY)  * m_signY + addValue);
+    }
+    wxCoord LogicalToDeviceYRel(wxCoord y) const
+    {
+        return y;
+    }
+
+    DECLARE_DYNAMIC_CLASS(wxGtkPrintDC)
+    DECLARE_NO_COPY_CLASS(wxGtkPrintDC)
+};
+
+// ----------------------------------------------------------------------------
+// wxGtkPrintPreview: programmer creates an object of this class to preview a
+// wxPrintout.
+// ----------------------------------------------------------------------------
+
+class WXDLLIMPEXP_CORE wxGtkPrintPreview : public wxPrintPreviewBase
+{
+public:
+    wxGtkPrintPreview(wxPrintout *printout,
+                             wxPrintout *printoutForPrinting = (wxPrintout *) NULL,
+                             wxPrintDialogData *data = (wxPrintDialogData *) NULL);
+    wxGtkPrintPreview(wxPrintout *printout,
+                             wxPrintout *printoutForPrinting,
+                             wxPrintData *data);
+
+    virtual ~wxGtkPrintPreview();
+
+    virtual bool Print(bool interactive);
+    virtual void DetermineScaling();
+
+private:
+    void Init(wxPrintout *printout, wxPrintout *printoutForPrinting);
+
+    DECLARE_CLASS(wxGtkPrintPreview)
+};
+
+#endif
diff -aburN ../original/include/wx/print.h ./include/wx/print.h
--- ../original/include/wx/print.h	2007-08-26 12:51:30.000000000 +0200
+++ ./include/wx/print.h	2007-08-26 14:16:40.000000000 +0200
@@ -28,6 +28,10 @@
 
 #include "wx/os2/printos2.h"
 
+#elif defined(__WXGTK20__)
+
+#include "wx/gtk/print.h"
+
 #else
 
 #include "wx/generic/printps.h"
diff -aburN ../original/src/common/prntbase.cpp ./src/common/prntbase.cpp
--- ../original/src/common/prntbase.cpp	2007-08-26 12:47:10.000000000 +0200
+++ ./src/common/prntbase.cpp	2007-08-26 14:14:56.000000000 +0200
@@ -55,6 +55,8 @@
 #elif defined(__WXMAC__)
 #include "wx/mac/printdlg.h"
 #include "wx/mac/private/print.h"
+#elif defined(__WXGTK20__)
+#include "wx/gtk/print.h"
 #else
 #include "wx/generic/prntdlgg.h"
 #include "wx/dcps.h"
@@ -100,6 +102,8 @@
     return new wxMacPrinter( data );
 #elif defined(__WXPM__)
     return new wxOS2Printer( data );
+#elif defined(__WXGTK20__)
+    return new wxGtkPrinter( data );
 #else
     return new wxPostScriptPrinter( data );
 #endif
@@ -114,6 +118,8 @@
     return new wxMacPrintPreview( preview, printout, data );
 #elif defined(__WXPM__)
     return new wxOS2PrintPreview( preview, printout, data );
+#elif defined(__WXGTK20__)
+    return new wxGtkPrintPreview( preview, printout, data );
 #else
     return new wxPostScriptPrintPreview( preview, printout, data );
 #endif
@@ -128,6 +134,8 @@
     return new wxMacPrintPreview( preview, printout, data );
 #elif defined(__WXPM__)
     return new wxOS2PrintPreview( preview, printout, data );
+#elif defined(__WXGTK20__)
+    return new wxGtkPrintPreview( preview, printout, data );
 #else
     return new wxPostScriptPrintPreview( preview, printout, data );
 #endif
@@ -140,6 +148,8 @@
     return new wxWindowsPrintDialog( parent, data );
 #elif defined(__WXMAC__)
     return new wxMacPrintDialog( parent, data );
+#elif defined(__WXGTK20__)
+    return new wxGtkPrintDialog( parent, data );
 #else
     return new wxGenericPrintDialog( parent, data );
 #endif
@@ -152,6 +162,8 @@
     return new wxWindowsPrintDialog( parent, data );
 #elif defined(__WXMAC__)
     return new wxMacPrintDialog( parent, data );
+#elif defined(__WXGTK20__)
+    return new wxGtkPrintDialog( parent, data );
 #else
     return new wxGenericPrintDialog( parent, data );
 #endif
@@ -164,6 +176,8 @@
     return new wxWindowsPageSetupDialog( parent, data );
 #elif defined(__WXMAC__)
     return new wxMacPageSetupDialog( parent, data );
+#elif defined(__WXGTK20__)
+    return new wxGtkPageSetupDialog( parent, data );
 #else
     return new wxGenericPageSetupDialog( parent, data );
 #endif
@@ -175,6 +189,8 @@
     return false;
 #elif defined(__WXMAC__)
     return false;
+#elif defined(__WXGTK20__)
+    return false;
 #else
     // Only here do we need to provide the print setup
     // dialog ourselves, the other platforms either have
@@ -196,6 +212,10 @@
     wxUnusedVar(parent);
     wxUnusedVar(data);
     return NULL;
+#elif defined(__WXGTK20__)
+    wxUnusedVar(parent);
+    wxUnusedVar(data);
+    return NULL;
 #else
     // Only here do we need to provide the print setup
     // dialog ourselves, the other platforms either have
@@ -211,6 +231,8 @@
     return new wxPrinterDC(data);
 #elif defined(__WXMAC__)
     return new wxPrinterDC(data);
+#elif defined(__WXGTK20__)
+    return new wxGtkPrintDC(data);
 #else
     return new wxPostScriptDC(data);
 #endif
@@ -259,6 +281,8 @@
     return new wxWindowsPrintNativeData;
 #elif defined(__WXMAC__)
     return new wxMacCarbonPrintData;
+#elif defined(__WXGTK20__)
+    return new wxGtkPrintNativeData;
 #else
     return new wxPostScriptPrintNativeData;
 #endif
diff -aburN ../original/src/gtk/gnome/gprint.cpp ./src/gtk/gnome/gprint.cpp
--- ../original/src/gtk/gnome/gprint.cpp	2007-08-26 12:45:16.000000000 +0200
+++ ./src/gtk/gnome/gprint.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,2094 +0,0 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        src/gtk/gnome/gprint.cpp
-// Author:      Robert Roebling
-// Purpose:     Implement GNOME printing support
-// Created:     09/20/04
-// RCS-ID:      $Id: gprint.cpp 48272 2007-08-21 10:52:39Z RR $
-// Copyright:   Robert Roebling
-// Licence:     wxWindows Licence
-/////////////////////////////////////////////////////////////////////////////
-
-// For compilers that support precompilation, includes "wx/wx.h".
-#include "wx/wxprec.h"
-
-#ifdef __BORLANDC__
-    #pragma hdrstop
-#endif
-
-#if wxUSE_LIBGNOMEPRINT
-
-#include "wx/gtk/gnome/gprint.h"
-
-#ifndef WX_PRECOMP
-    #include "wx/log.h"
-    #include "wx/dcmemory.h"
-    #include "wx/icon.h"
-    #include "wx/math.h"
-    #include "wx/image.h"
-    #include "wx/module.h"
-#endif
-
-#include "wx/fontutil.h"
-#include "wx/gtk/private.h"
-#include "wx/dynlib.h"
-#include "wx/paper.h"
-
-#include <libgnomeprint/gnome-print.h>
-#include <libgnomeprint/gnome-print-pango.h>
-#include <libgnomeprint/gnome-print-config.h>
-#include <libgnomeprintui/gnome-print-dialog.h>
-#include <libgnomeprintui/gnome-print-job-preview.h>
-#include <libgnomeprintui/gnome-print-paper-selector.h>
-
-static const double RAD2DEG  = 180.0 / M_PI;
-
-#include "wx/link.h"
-wxFORCE_LINK_THIS_MODULE(gnome_print)
-
-//----------------------------------------------------------------------------
-// wxGnomePrintLibrary
-//----------------------------------------------------------------------------
-
-#define wxDL_METHOD_DEFINE( rettype, name, args, shortargs, defret ) \
-    typedef rettype (* name ## Type) args ; \
-    name ## Type pfn_ ## name; \
-    rettype name args \
-    { if (m_ok) return pfn_ ## name shortargs ; return defret; }
-
-#define wxDL_METHOD_LOAD( lib, name, success ) \
-    pfn_ ## name = (name ## Type) lib->GetSymbol( wxT(#name), &success ); \
-    if (!success) return;
-
-class wxGnomePrintLibrary
-{
-public:
-    wxGnomePrintLibrary();
-    ~wxGnomePrintLibrary();
-
-    bool IsOk();
-    void InitializeMethods();
-
-private:
-    bool              m_ok;
-    wxDynamicLibrary *m_gnome_print_lib;
-    wxDynamicLibrary *m_gnome_printui_lib;
-
-public:
-    wxDL_METHOD_DEFINE( gint, gnome_print_newpath,
-        (GnomePrintContext *pc), (pc), 0 )
-    wxDL_METHOD_DEFINE( gint, gnome_print_moveto,
-        (GnomePrintContext *pc, gdouble x, gdouble y), (pc, x, y), 0 )
-    wxDL_METHOD_DEFINE( gint, gnome_print_lineto,
-        (GnomePrintContext *pc, gdouble x, gdouble y), (pc, x, y), 0 )
-    wxDL_METHOD_DEFINE( gint, gnome_print_arcto,
-        (GnomePrintContext *pc, gdouble x, gdouble y, gdouble radius, gdouble angle1, gdouble angle2, gint direction ), (pc, x, y, radius, angle1, angle2, direction), 0 )
-    wxDL_METHOD_DEFINE( gint, gnome_print_curveto,
-        (GnomePrintContext *pc, gdouble x1, gdouble y1, gdouble x2, gdouble y2, gdouble x3, gdouble y3), (pc, x1, y1, x2, y2, x3, y3), 0 )
-    wxDL_METHOD_DEFINE( gint, gnome_print_closepath,
-        (GnomePrintContext *pc), (pc), 0 )
-    wxDL_METHOD_DEFINE( gint, gnome_print_stroke,
-        (GnomePrintContext *pc), (pc), 0 )
-    wxDL_METHOD_DEFINE( gint, gnome_print_fill,
-        (GnomePrintContext *pc), (pc), 0 )
-    wxDL_METHOD_DEFINE( gint, gnome_print_setrgbcolor,
-        (GnomePrintContext *pc, gdouble r, gdouble g, gdouble b), (pc, r, g, b), 0 )
-    wxDL_METHOD_DEFINE( gint, gnome_print_setlinewidth,
-        (GnomePrintContext *pc, gdouble width), (pc, width), 0 )
-    wxDL_METHOD_DEFINE( gint, gnome_print_setdash,
-        (GnomePrintContext *pc, gint n_values, const gdouble *values, gdouble offset), (pc, n_values, values, offset), 0 )
-
-    wxDL_METHOD_DEFINE( gint, gnome_print_rgbimage,
-        (GnomePrintContext *pc, const guchar *data, gint width, gint height, gint rowstride), (pc, data, width, height, rowstride ), 0 )
-    wxDL_METHOD_DEFINE( gint, gnome_print_rgbaimage,
-        (GnomePrintContext *pc, const guchar *data, gint width, gint height, gint rowstride), (pc, data, width, height, rowstride ), 0 )
-
-    wxDL_METHOD_DEFINE( gint, gnome_print_concat,
-        (GnomePrintContext *pc, const gdouble *matrix), (pc, matrix), 0 )
-    wxDL_METHOD_DEFINE( gint, gnome_print_scale,
-        (GnomePrintContext *pc, gdouble sx, gdouble sy), (pc, sx, sy), 0 )
-    wxDL_METHOD_DEFINE( gint, gnome_print_rotate,
-        (GnomePrintContext *pc, gdouble theta), (pc, theta), 0 )
-    wxDL_METHOD_DEFINE( gint, gnome_print_translate,
-        (GnomePrintContext *pc, gdouble x, gdouble y), (pc, x, y), 0 )
-
-    wxDL_METHOD_DEFINE( gint, gnome_print_gsave,
-        (GnomePrintContext *pc), (pc), 0 )
-    wxDL_METHOD_DEFINE( gint, gnome_print_grestore,
-        (GnomePrintContext *pc), (pc), 0 )
-
-    wxDL_METHOD_DEFINE( gint, gnome_print_clip,
-        (GnomePrintContext *pc), (pc), 0 )
-    wxDL_METHOD_DEFINE( gint, gnome_print_eoclip,
-        (GnomePrintContext *pc), (pc), 0 )
-
-    wxDL_METHOD_DEFINE( gint, gnome_print_beginpage,
-        (GnomePrintContext *pc, const guchar* name), (pc, name), 0 )
-    wxDL_METHOD_DEFINE( gint, gnome_print_showpage,
-        (GnomePrintContext *pc), (pc), 0 )
-    wxDL_METHOD_DEFINE( gint, gnome_print_end_doc,
-        (GnomePrintContext *pc), (pc), 0 )
-
-    wxDL_METHOD_DEFINE( PangoLayout*, gnome_print_pango_create_layout,
-        (GnomePrintContext *gpc), (gpc), NULL )
-    wxDL_METHOD_DEFINE( void, gnome_print_pango_layout,
-        (GnomePrintContext *gpc, PangoLayout *layout), (gpc, layout), /**/ )
-
-    wxDL_METHOD_DEFINE( GnomePrintJob*, gnome_print_job_new,
-        (GnomePrintConfig *config), (config), NULL )
-    wxDL_METHOD_DEFINE( GnomePrintContext*, gnome_print_job_get_context,
-        (GnomePrintJob *job), (job), NULL )
-    wxDL_METHOD_DEFINE( gint, gnome_print_job_close,
-        (GnomePrintJob *job), (job), 0 )
-    wxDL_METHOD_DEFINE( gint, gnome_print_job_print,
-        (GnomePrintJob *job), (job), 0 )
-    wxDL_METHOD_DEFINE( gboolean, gnome_print_job_get_page_size,
-        (GnomePrintJob *job, gdouble *width, gdouble *height), (job, width, height), 0 )
-
-    wxDL_METHOD_DEFINE( GnomePrintUnit*, gnome_print_unit_get_by_abbreviation,
-        (const guchar *abbreviation), (abbreviation), NULL )
-    wxDL_METHOD_DEFINE( gboolean, gnome_print_convert_distance,
-        (gdouble *distance, const GnomePrintUnit *from, const GnomePrintUnit *to), (distance, from, to), false )
-
-    wxDL_METHOD_DEFINE( GnomePrintConfig*, gnome_print_config_default,
-        (void), (), NULL )
-    wxDL_METHOD_DEFINE( gboolean, gnome_print_config_set,
-        (GnomePrintConfig *config, const guchar *key, const guchar *value), (config, key, value), false )
-    wxDL_METHOD_DEFINE( gboolean, gnome_print_config_set_double,
-        (GnomePrintConfig *config, const guchar *key, gdouble value), (config, key, value), false )
-    wxDL_METHOD_DEFINE( gboolean, gnome_print_config_set_int,
-        (GnomePrintConfig *config, const guchar *key, gint value), (config, key, value), false )
-    wxDL_METHOD_DEFINE( gboolean, gnome_print_config_set_boolean,
-        (GnomePrintConfig *config, const guchar *key, gboolean value), (config, key, value), false )
-    wxDL_METHOD_DEFINE( gboolean, gnome_print_config_set_length,
-        (GnomePrintConfig *config, const guchar *key, gdouble value, const GnomePrintUnit *unit), (config, key, value, unit), false )
-        
-    wxDL_METHOD_DEFINE( guchar*, gnome_print_config_get,
-        (GnomePrintConfig *config, const guchar *key), (config, key), NULL )
-    wxDL_METHOD_DEFINE( gboolean, gnome_print_config_get_length,
-        (GnomePrintConfig *config, const guchar *key, gdouble *val, const GnomePrintUnit **unit), (config, key, val, unit), false )
-
-    wxDL_METHOD_DEFINE( GtkWidget*, gnome_print_dialog_new,
-        (GnomePrintJob *gpj, const guchar *title, gint flags), (gpj, title, flags), NULL )
-    wxDL_METHOD_DEFINE( void, gnome_print_dialog_construct_range_page,
-        (GnomePrintDialog *gpd, gint flags, gint start, gint end,
-        const guchar *currentlabel, const guchar *rangelabel),
-        (gpd, flags, start, end, currentlabel, rangelabel), /**/ )
-    wxDL_METHOD_DEFINE( void, gnome_print_dialog_get_copies,
-        (GnomePrintDialog *gpd, gint *copies, gboolean *collate), (gpd, copies, collate), /**/ )
-    wxDL_METHOD_DEFINE( void, gnome_print_dialog_set_copies,
-        (GnomePrintDialog *gpd, gint copies, gint collate), (gpd, copies, collate), /**/ )
-    wxDL_METHOD_DEFINE( GnomePrintRangeType, gnome_print_dialog_get_range,
-        (GnomePrintDialog *gpd), (gpd), GNOME_PRINT_RANGETYPE_NONE )
-    wxDL_METHOD_DEFINE( int, gnome_print_dialog_get_range_page,
-        (GnomePrintDialog *gpd, gint *start, gint *end), (gpd, start, end), 0 )
-
-    wxDL_METHOD_DEFINE( GtkWidget*, gnome_paper_selector_new_with_flags,
-        (GnomePrintConfig *config, gint flags), (config, flags), NULL )
-
-    wxDL_METHOD_DEFINE( GtkWidget*, gnome_print_job_preview_new,
-        (GnomePrintJob *gpm, const guchar *title), (gpm, title), NULL )
-
-    DECLARE_NO_COPY_CLASS(wxGnomePrintLibrary)
-};
-
-wxGnomePrintLibrary::wxGnomePrintLibrary()
-{
-    m_gnome_print_lib = NULL;
-    m_gnome_printui_lib = NULL;
-
-    wxLogNull log;
-
-    m_gnome_print_lib = new wxDynamicLibrary( wxT("libgnomeprint-2-2.so.0") );
-    m_ok = m_gnome_print_lib->IsLoaded();
-    if (!m_ok) return;
-
-    m_gnome_printui_lib = new wxDynamicLibrary( wxT("libgnomeprintui-2-2.so.0") );
-    m_ok = m_gnome_printui_lib->IsLoaded();
-    if (!m_ok) return;
-
-    InitializeMethods();
-}
-
-wxGnomePrintLibrary::~wxGnomePrintLibrary()
-{
-    if (m_gnome_print_lib)
-        delete m_gnome_print_lib;
-    if (m_gnome_printui_lib)
-        delete m_gnome_printui_lib;
-}
-
-bool wxGnomePrintLibrary::IsOk()
-{
-    return m_ok;
-}
-
-void wxGnomePrintLibrary::InitializeMethods()
-{
-    m_ok = false;
-    bool success;
-
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_newpath, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_moveto, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_lineto, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_curveto, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_arcto, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_closepath, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_stroke, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_fill, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_setrgbcolor, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_setlinewidth, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_setdash, success )
-
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_rgbimage, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_rgbaimage, success )
-
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_concat, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_scale, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_rotate, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_translate, success )
-
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_gsave, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_grestore, success )
-
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_clip, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_eoclip, success )
-
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_beginpage, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_showpage, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_end_doc, success )
-
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_pango_create_layout, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_pango_layout, success )
-
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_job_new, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_job_get_context, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_job_close, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_job_print, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_job_get_page_size, success )
-
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_unit_get_by_abbreviation, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_convert_distance, success )
-
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_config_default, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_config_set, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_config_set_boolean, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_config_set_double, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_config_set_int, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_config_set_length, success )
-    
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_config_get, success )
-    wxDL_METHOD_LOAD( m_gnome_print_lib, gnome_print_config_get_length, success )
-
-    wxDL_METHOD_LOAD( m_gnome_printui_lib, gnome_print_dialog_new, success )
-    wxDL_METHOD_LOAD( m_gnome_printui_lib, gnome_print_dialog_construct_range_page, success )
-    wxDL_METHOD_LOAD( m_gnome_printui_lib, gnome_print_dialog_get_copies, success )
-    wxDL_METHOD_LOAD( m_gnome_printui_lib, gnome_print_dialog_set_copies, success )
-    wxDL_METHOD_LOAD( m_gnome_printui_lib, gnome_print_dialog_get_range, success )
-    wxDL_METHOD_LOAD( m_gnome_printui_lib, gnome_print_dialog_get_range_page, success )
-
-    wxDL_METHOD_LOAD( m_gnome_printui_lib, gnome_paper_selector_new_with_flags, success )
-
-    wxDL_METHOD_LOAD( m_gnome_printui_lib, gnome_print_job_preview_new, success )
-
-    m_ok = true;
-}
-
-static wxGnomePrintLibrary* gs_lgp = NULL;
-
-//----------------------------------------------------------------------------
-// wxGnomePrintNativeData
-//----------------------------------------------------------------------------
-
-IMPLEMENT_CLASS(wxGnomePrintNativeData, wxPrintNativeDataBase)
-
-wxGnomePrintNativeData::wxGnomePrintNativeData()
-{
-    m_config = gs_lgp->gnome_print_config_default();
-    m_job = gs_lgp->gnome_print_job_new( m_config );
-}
-
-wxGnomePrintNativeData::~wxGnomePrintNativeData()
-{
-    g_object_unref (m_config);
-}
-
-bool wxGnomePrintNativeData::TransferTo( wxPrintData &data )
-{
-    guchar *res = gs_lgp->gnome_print_config_get( m_config,
-            (guchar*)(char*)GNOME_PRINT_KEY_PAGE_ORIENTATION );
-    if (g_ascii_strcasecmp((const gchar *)res,"R90") == 0)
-        data.SetOrientation( wxLANDSCAPE );
-    else
-        data.SetOrientation( wxPORTRAIT );
-    g_free( res );
-    
-    return true;
-}
-
-bool wxGnomePrintNativeData::TransferFrom( const wxPrintData &data )
-{
-    if (data.GetOrientation() == wxLANDSCAPE)
-    {
-        gs_lgp->gnome_print_config_set( m_config,
-            (guchar*)(char*)GNOME_PRINT_KEY_PAGE_ORIENTATION,
-            (guchar*)(char*)"R90" );
-    }
-    else
-    {
-        gs_lgp->gnome_print_config_set( m_config,
-            (guchar*)(char*)GNOME_PRINT_KEY_PAGE_ORIENTATION,
-            (guchar*)(char*)"R0" );
-    }
-
-    if (data.GetCollate())
-    {
-        gs_lgp->gnome_print_config_set_boolean( m_config,
-            (guchar*)(char*)GNOME_PRINT_KEY_COLLATE,
-            TRUE );
-    }
-    else
-    {
-        gs_lgp->gnome_print_config_set_boolean( m_config,
-            (guchar*)(char*)GNOME_PRINT_KEY_COLLATE,
-            FALSE );
-    }
-
-    switch (data.GetPaperId())
-    {
-        case wxPAPER_A3:        gs_lgp->gnome_print_config_set( m_config,
-                                    (guchar*)(char*)GNOME_PRINT_KEY_PAPER_SIZE,
-                                    (guchar*)(char*)"A3" );
-                                break;
-        case wxPAPER_A5:        gs_lgp->gnome_print_config_set( m_config,
-                                    (guchar*)(char*)GNOME_PRINT_KEY_PAPER_SIZE,
-                                    (guchar*)(char*)"A5" );
-                                break;
-        case wxPAPER_B4:        gs_lgp->gnome_print_config_set( m_config,
-                                    (guchar*)(char*)GNOME_PRINT_KEY_PAPER_SIZE,
-                                    (guchar*)(char*)"B4" );
-                                break;
-        case wxPAPER_B5:        gs_lgp->gnome_print_config_set( m_config,
-                                    (guchar*)(char*)GNOME_PRINT_KEY_PAPER_SIZE,
-                                    (guchar*)(char*)"B5" );
-                                break;
-        case wxPAPER_LETTER:        gs_lgp->gnome_print_config_set( m_config,
-                                    (guchar*)(char*)GNOME_PRINT_KEY_PAPER_SIZE,
-                                    (guchar*)(char*)"USLetter" );
-                                break;
-        case wxPAPER_LEGAL:     gs_lgp->gnome_print_config_set( m_config,
-                                    (guchar*)(char*)GNOME_PRINT_KEY_PAPER_SIZE,
-                                    (guchar*)(char*)"USLegal" );
-                                break;
-        case wxPAPER_EXECUTIVE: gs_lgp->gnome_print_config_set( m_config,
-                                    (guchar*)(char*)GNOME_PRINT_KEY_PAPER_SIZE,
-                                    (guchar*)(char*)"Executive" );
-                                break;
-        case wxPAPER_ENV_C5:    gs_lgp->gnome_print_config_set( m_config,
-                                    (guchar*)(char*)GNOME_PRINT_KEY_PAPER_SIZE,
-                                    (guchar*)(char*)"C5" );
-                                break;
-        case wxPAPER_ENV_C6:    gs_lgp->gnome_print_config_set( m_config,
-                                    (guchar*)(char*)GNOME_PRINT_KEY_PAPER_SIZE,
-                                    (guchar*)(char*)"C6" );
-                                break;
-        case wxPAPER_NONE:      break;
-        
-        default:
-        case wxPAPER_A4:        gs_lgp->gnome_print_config_set( m_config,
-                                    (guchar*)(char*)GNOME_PRINT_KEY_PAPER_SIZE,
-                                    (guchar*)(char*)"A4" );
-                                break;
-    }
-
-    return true;
-}
-
-//----------------------------------------------------------------------------
-// wxGnomePrintFactory
-//----------------------------------------------------------------------------
-
-wxPrinterBase* wxGnomePrintFactory::CreatePrinter( wxPrintDialogData *data )
-{
-    return new wxGnomePrinter( data );
-}
-
-wxPrintPreviewBase *wxGnomePrintFactory::CreatePrintPreview( wxPrintout *preview,
-                                                    wxPrintout *printout,
-                                                    wxPrintDialogData *data )
-{
-    return new wxGnomePrintPreview( preview, printout, data );
-}
-
-wxPrintPreviewBase *wxGnomePrintFactory::CreatePrintPreview( wxPrintout *preview,
-                                                    wxPrintout *printout,
-                                                    wxPrintData *data )
-{
-    return new wxGnomePrintPreview( preview, printout, data );
-}
-
-wxPrintDialogBase *wxGnomePrintFactory::CreatePrintDialog( wxWindow *parent,
-                                                  wxPrintDialogData *data )
-{
-    return new wxGnomePrintDialog( parent, data );
-}
-
-wxPrintDialogBase *wxGnomePrintFactory::CreatePrintDialog( wxWindow *parent,
-                                                  wxPrintData *data )
-{
-    return new wxGnomePrintDialog( parent, data );
-}
-
-wxPageSetupDialogBase *wxGnomePrintFactory::CreatePageSetupDialog( wxWindow *parent,
-                                                          wxPageSetupDialogData * data )
-{
-//  The native page setup dialog is broken. It
-//  miscalculates newly entered values for the
-//  margins if you have not chose "points" but
-//  e.g. centimerters.
-//  This has been fixed in GNOME CVS (maybe
-//  fixed in libgnomeprintui 2.8.1)
-
-    return new wxGnomePageSetupDialog( parent, data );
-}
-
-bool wxGnomePrintFactory::HasPrintSetupDialog()
-{
-    return false;
-}
-
-wxDialog *wxGnomePrintFactory::CreatePrintSetupDialog( wxWindow *parent, wxPrintData *data )
-{
-    return NULL;
-}
-
-wxDC* wxGnomePrintFactory::CreatePrinterDC( const wxPrintData& data )
-{
-    return new wxGnomePrintDC(data);
-}
-
-bool wxGnomePrintFactory::HasOwnPrintToFile()
-{
-    return true;
-}
-
-bool wxGnomePrintFactory::HasPrinterLine()
-{
-    return true;
-}
-
-wxString wxGnomePrintFactory::CreatePrinterLine()
-{
-    // redundant now
-    return wxEmptyString;
-}
-
-bool wxGnomePrintFactory::HasStatusLine()
-{
-    // redundant now
-    return true;
-}
-
-wxString wxGnomePrintFactory::CreateStatusLine()
-{
-    // redundant now
-    return wxEmptyString;
-}
-
-wxPrintNativeDataBase *wxGnomePrintFactory::CreatePrintNativeData()
-{
-    return new wxGnomePrintNativeData;
-}
-
-//----------------------------------------------------------------------------
-// wxGnomePrintSetupDialog
-//----------------------------------------------------------------------------
-
-IMPLEMENT_CLASS(wxGnomePrintDialog, wxPrintDialogBase)
-
-wxGnomePrintDialog::wxGnomePrintDialog( wxWindow *parent, wxPrintDialogData *data )
-                    : wxPrintDialogBase(parent, wxID_ANY, _("Print"),
-                               wxPoint(0, 0), wxSize(600, 600),
-                               wxDEFAULT_DIALOG_STYLE |
-                               wxTAB_TRAVERSAL)
-{
-    if (data)
-        m_printDialogData = *data;
-
-    Init();
-}
-
-wxGnomePrintDialog::wxGnomePrintDialog( wxWindow *parent, wxPrintData *data )
-                    : wxPrintDialogBase(parent, wxID_ANY, _("Print"),
-                               wxPoint(0, 0), wxSize(600, 600),
-                               wxDEFAULT_DIALOG_STYLE |
-                               wxTAB_TRAVERSAL)
-{
-    if (data)
-        m_printDialogData = *data;
-
-    Init();
-}
-
-void wxGnomePrintDialog::Init()
-{
-    wxPrintData data = m_printDialogData.GetPrintData();
-    
-    data.ConvertToNative();
-
-    wxGnomePrintNativeData *native =
-      (wxGnomePrintNativeData*) data.GetNativeData();
-
-    m_widget = gs_lgp->gnome_print_dialog_new( native->GetPrintJob(),
-                                       (guchar*)"Print",
-                                       GNOME_PRINT_DIALOG_RANGE|GNOME_PRINT_DIALOG_COPIES );
-
-    int flag = 0;
-    if (m_printDialogData.GetEnableSelection())
-        flag |= GNOME_PRINT_RANGE_SELECTION;
-    if (m_printDialogData.GetEnablePageNumbers())
-        flag |= GNOME_PRINT_RANGE_ALL|GNOME_PRINT_RANGE_RANGE;
-
-    gs_lgp->gnome_print_dialog_construct_range_page( (GnomePrintDialog*) m_widget,
-                                             flag,
-                                             m_printDialogData.GetMinPage(),
-                                             m_printDialogData.GetMaxPage(),
-                                             NULL,
-                                             NULL );
-}
-
-wxGnomePrintDialog::~wxGnomePrintDialog()
-{
-    m_widget = NULL;
-}
-
-int wxGnomePrintDialog::ShowModal()
-{
-    int response = gtk_dialog_run (GTK_DIALOG (m_widget));
-
-    if (response == GNOME_PRINT_DIALOG_RESPONSE_CANCEL)
-    {
-        gtk_widget_destroy(m_widget);
-        m_widget = NULL;
-
-        return wxID_CANCEL;
-    }
-
-    m_printDialogData.GetPrintData().ConvertFromNative();
-
-    gint copies = 1;
-    gboolean collate = false;
-    gs_lgp->gnome_print_dialog_get_copies( (GnomePrintDialog*) m_widget, &copies, &collate );
-    m_printDialogData.SetNoCopies( copies );
-    m_printDialogData.SetCollate( collate );
-
-    switch (gs_lgp->gnome_print_dialog_get_range( (GnomePrintDialog*) m_widget ))
-    {
-        case GNOME_PRINT_RANGE_SELECTION:
-            m_printDialogData.SetSelection( true );
-            break;
-        case GNOME_PRINT_RANGE_ALL:
-            m_printDialogData.SetAllPages( true );
-            m_printDialogData.SetFromPage( 0 );
-            m_printDialogData.SetToPage( 9999 );
-            break;
-        case GNOME_PRINT_RANGE_RANGE:
-        default:
-            gint start,end;
-            gs_lgp->gnome_print_dialog_get_range_page( (GnomePrintDialog*) m_widget, &start, &end );
-            m_printDialogData.SetFromPage( start );
-            m_printDialogData.SetToPage( end );
-            break;
-    }
-
-    gtk_widget_destroy(m_widget);
-    m_widget = NULL;
-
-    if (response == GNOME_PRINT_DIALOG_RESPONSE_PREVIEW)
-        return wxID_PREVIEW;
-
-    return wxID_OK;
-}
-
-wxDC *wxGnomePrintDialog::GetPrintDC()
-{
-    // Later
-    return NULL;
-}
-
-bool wxGnomePrintDialog::Validate()
-{
-    return true;
-}
-
-bool wxGnomePrintDialog::TransferDataToWindow()
-{
-    return true;
-}
-
-bool wxGnomePrintDialog::TransferDataFromWindow()
-{
-    return true;
-}
-
-//----------------------------------------------------------------------------
-// wxGnomePageSetupDialog
-//----------------------------------------------------------------------------
-
-IMPLEMENT_CLASS(wxGnomePageSetupDialog, wxPageSetupDialogBase)
-
-wxGnomePageSetupDialog::wxGnomePageSetupDialog( wxWindow *parent,
-                            wxPageSetupDialogData* data )
-{
-    if (data)
-        m_pageDialogData = *data;
-
-    m_pageDialogData.GetPrintData().ConvertToNative();
-
-    wxGnomePrintNativeData *native =
-      (wxGnomePrintNativeData*) m_pageDialogData.GetPrintData().GetNativeData();
-
-    // This *was* required as the page setup dialog
-    // calculates wrong values otherwise.
-#if 0
-    gs_lgp->gnome_print_config_set( native->GetPrintConfig(),
-                            (const guchar*) GNOME_PRINT_KEY_PREFERED_UNIT,
-                            (const guchar*) "Pts" );
-#endif
-
-    GnomePrintConfig *config = native->GetPrintConfig();
-
-    const GnomePrintUnit *mm_unit = gs_lgp->gnome_print_unit_get_by_abbreviation( (const guchar*) "mm" );
-
-    double ml = (double) m_pageDialogData.GetMarginTopLeft().x;
-    double mt = (double) m_pageDialogData.GetMarginTopLeft().y;
-    double mr = (double) m_pageDialogData.GetMarginBottomRight().x;
-    double mb = (double) m_pageDialogData.GetMarginBottomRight().y;
-    
-    gs_lgp->gnome_print_config_set_length (config,
-            (const guchar*) GNOME_PRINT_KEY_PAGE_MARGIN_LEFT, ml, mm_unit );
-    gs_lgp->gnome_print_config_set_length (config,
-            (const guchar*) GNOME_PRINT_KEY_PAGE_MARGIN_RIGHT, mr, mm_unit );
-    gs_lgp->gnome_print_config_set_length (config,
-            (const guchar*) GNOME_PRINT_KEY_PAGE_MARGIN_TOP, mt, mm_unit );
-    gs_lgp->gnome_print_config_set_length (config,
-            (const guchar*) GNOME_PRINT_KEY_PAGE_MARGIN_BOTTOM, mb, mm_unit );
-
-    m_widget = gtk_dialog_new();
-
-    gtk_window_set_title( GTK_WINDOW(m_widget), wxGTK_CONV( _("Page setup") ) );
-
-    GtkWidget *main = gs_lgp->gnome_paper_selector_new_with_flags( native->GetPrintConfig(),
-        GNOME_PAPER_SELECTOR_MARGINS|GNOME_PAPER_SELECTOR_FEED_ORIENTATION );
-    gtk_container_set_border_width (GTK_CONTAINER (main), 8);
-    gtk_widget_show (main);
-
-    gtk_container_add( GTK_CONTAINER (GTK_DIALOG (m_widget)->vbox), main );
-
-    gtk_dialog_set_has_separator (GTK_DIALOG (m_widget), TRUE);
-
-    gtk_dialog_add_buttons (GTK_DIALOG (m_widget),
-                            GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
-                            GTK_STOCK_OK, GTK_RESPONSE_OK,
-                            NULL);
-
-    gtk_dialog_set_default_response (GTK_DIALOG (m_widget),
-                            GTK_RESPONSE_OK);
-}
-
-wxGnomePageSetupDialog::~wxGnomePageSetupDialog()
-{
-}
-
-wxPageSetupDialogData& wxGnomePageSetupDialog::GetPageSetupDialogData()
-{
-    return m_pageDialogData;
-}
-
-int wxGnomePageSetupDialog::ShowModal()
-{
-    wxGnomePrintNativeData *native =
-      (wxGnomePrintNativeData*) m_pageDialogData.GetPrintData().GetNativeData();
-      
-    GnomePrintConfig *config = native->GetPrintConfig();
-
-
-    int ret = gtk_dialog_run( GTK_DIALOG(m_widget) );
-
-    if (ret == GTK_RESPONSE_OK)
-    {
-        // Transfer data back to m_pageDialogData
-        m_pageDialogData.GetPrintData().ConvertFromNative();
-
-        // I don't know how querying the last parameter works
-        double ml,mr,mt,mb,pw,ph;
-        gs_lgp->gnome_print_config_get_length (config,
-            (const guchar*) GNOME_PRINT_KEY_PAGE_MARGIN_LEFT, &ml, NULL);
-        gs_lgp->gnome_print_config_get_length (config,
-            (const guchar*) GNOME_PRINT_KEY_PAGE_MARGIN_RIGHT, &mr, NULL);
-        gs_lgp->gnome_print_config_get_length (config,
-            (const guchar*) GNOME_PRINT_KEY_PAGE_MARGIN_TOP, &mt, NULL);
-        gs_lgp->gnome_print_config_get_length (config,
-            (const guchar*) GNOME_PRINT_KEY_PAGE_MARGIN_BOTTOM, &mb, NULL);
-        gs_lgp->gnome_print_config_get_length (config,
-            (const guchar*) GNOME_PRINT_KEY_PAPER_WIDTH, &pw, NULL);
-        gs_lgp->gnome_print_config_get_length (config,
-            (const guchar*) GNOME_PRINT_KEY_PAPER_HEIGHT, &ph, NULL);
-
-        // This code converts correctly from what the user chose
-        // as the unit although I query Pts here
-        const GnomePrintUnit *mm_unit = gs_lgp->gnome_print_unit_get_by_abbreviation( (const guchar*) "mm" );
-        const GnomePrintUnit *pts_unit = gs_lgp->gnome_print_unit_get_by_abbreviation( (const guchar*) "Pts" );
-        gs_lgp->gnome_print_convert_distance( &ml, pts_unit, mm_unit );
-        gs_lgp->gnome_print_convert_distance( &mr, pts_unit, mm_unit );
-        gs_lgp->gnome_print_convert_distance( &mt, pts_unit, mm_unit );
-        gs_lgp->gnome_print_convert_distance( &mb, pts_unit, mm_unit );
-        gs_lgp->gnome_print_convert_distance( &pw, pts_unit, mm_unit );
-        gs_lgp->gnome_print_convert_distance( &ph, pts_unit, mm_unit );
-
-        m_pageDialogData.SetMarginTopLeft( wxPoint( (int)(ml+0.5), (int)(mt+0.5)) );
-        m_pageDialogData.SetMarginBottomRight( wxPoint( (int)(mr+0.5), (int)(mb+0.5)) );
-
-        m_pageDialogData.SetPaperSize( wxSize( (int)(pw+0.5), (int)(ph+0.5) ) );
-
-        ret = wxID_OK;
-    }
-    else
-    {
-        ret = wxID_CANCEL;
-    }
-
-    gtk_widget_destroy( m_widget );
-    m_widget = NULL;
-
-    return ret;
-}
-
-bool wxGnomePageSetupDialog::Validate()
-{
-    return true;
-}
-
-bool wxGnomePageSetupDialog::TransferDataToWindow()
-{
-    return true;
-}
-
-bool wxGnomePageSetupDialog::TransferDataFromWindow()
-{
-    return true;
-}
-
-//----------------------------------------------------------------------------
-// wxGnomePrinter
-//----------------------------------------------------------------------------
-
-IMPLEMENT_CLASS(wxGnomePrinter, wxPrinterBase)
-
-wxGnomePrinter::wxGnomePrinter( wxPrintDialogData *data ) :
-    wxPrinterBase( data )
-{
-    m_native_preview = false;
-}
-
-wxGnomePrinter::~wxGnomePrinter()
-{
-}
-
-bool wxGnomePrinter::Print(wxWindow *parent, wxPrintout *printout, bool prompt )
-{
-    if (!printout)
-    {
-        sm_lastError = wxPRINTER_ERROR;
-        return false;
-    }
-
-    wxPrintData printdata = GetPrintDialogData().GetPrintData();
-    
-    wxGnomePrintNativeData *native =
-        (wxGnomePrintNativeData*) printdata.GetNativeData();
-
-    GnomePrintJob *job = gs_lgp->gnome_print_job_new( native->GetPrintConfig() );
-
-    // The GnomePrintJob is temporarily stored in the
-    // native print data as the native print dialog
-    // needs to access it.
-    native->SetPrintJob( job );
-
-
-    printout->SetIsPreview(false);
-
-    if (m_printDialogData.GetMinPage() < 1)
-        m_printDialogData.SetMinPage(1);
-    if (m_printDialogData.GetMaxPage() < 1)
-        m_printDialogData.SetMaxPage(9999);
-
-    wxDC *dc;
-    if (prompt)
-        dc = PrintDialog( parent );
-    else
-        dc = new wxGnomePrintDC( printdata );
-
-    if (m_native_preview)
-        printout->SetIsPreview(true);
-
-    if (!dc)
-    {
-        gs_lgp->gnome_print_job_close( job );
-        g_object_unref (job);
-        if (sm_lastError != wxPRINTER_CANCELLED)
-            sm_lastError = wxPRINTER_ERROR;
-        return false;
-    }
-
-    wxSize ScreenPixels = wxGetDisplaySize();
-    wxSize ScreenMM = wxGetDisplaySizeMM();
-
-    printout->SetPPIScreen( (int) ((ScreenPixels.GetWidth() * 25.4) / ScreenMM.GetWidth()),
-                            (int) ((ScreenPixels.GetHeight() * 25.4) / ScreenMM.GetHeight()) );
-    printout->SetPPIPrinter( wxGnomePrintDC::GetResolution(),
-                             wxGnomePrintDC::GetResolution() );
-
-    printout->SetDC(dc);
-
-    int w, h;
-    dc->GetSize(&w, &h);
-    printout->SetPageSizePixels((int)w, (int)h);
-    printout->SetPaperRectPixels(wxRect(0, 0, w, h));
-    int mw, mh;
-    dc->GetSizeMM(&mw, &mh);
-    printout->SetPageSizeMM((int)mw, (int)mh);
-    printout->OnPreparePrinting();
-
-    // Get some parameters from the printout, if defined
-    int fromPage, toPage;
-    int minPage, maxPage;
-    printout->GetPageInfo(&minPage, &maxPage, &fromPage, &toPage);
-
-    if (maxPage == 0)
-    {
-        gs_lgp->gnome_print_job_close( job );
-        g_object_unref (job);
-        sm_lastError = wxPRINTER_ERROR;
-        return false;
-    }
-
-    printout->OnBeginPrinting();
-
-    int minPageNum = minPage, maxPageNum = maxPage;
-
-    if ( !m_printDialogData.GetAllPages() )
-    {
-        minPageNum = m_printDialogData.GetFromPage();
-        maxPageNum = m_printDialogData.GetToPage();
-    }
-
-
-    int copyCount;
-    for ( copyCount = 1;
-          copyCount <= m_printDialogData.GetNoCopies();
-          copyCount++ )
-    {
-        if (!printout->OnBeginDocument(minPageNum, maxPageNum))
-        {
-            wxLogError(_("Could not start printing."));
-            sm_lastError = wxPRINTER_ERROR;
-            break;
-        }
-
-        int pn;
-        for ( pn = minPageNum;
-              pn <= maxPageNum && printout->HasPage(pn);
-              pn++ )
-        {
-            dc->StartPage();
-            printout->OnPrintPage(pn);
-            dc->EndPage();
-        }
-
-        printout->OnEndDocument();
-        printout->OnEndPrinting();
-    }
-
-    gs_lgp->gnome_print_job_close( job );
-    if (m_native_preview)
-    {
-        const wxCharBuffer title(wxGTK_CONV_SYS(_("Print preview")));
-        GtkWidget *preview = gs_lgp->gnome_print_job_preview_new
-                                     (
-                                        job,
-                                        (const guchar *)title.data()
-                                     );
-        gtk_widget_show(preview);
-    }
-    else
-    {
-        gs_lgp->gnome_print_job_print( job );
-    }
-
-    g_object_unref (job);
-    delete dc;
-
-    return (sm_lastError == wxPRINTER_NO_ERROR);
-}
-
-wxDC* wxGnomePrinter::PrintDialog( wxWindow *parent )
-{
-    wxGnomePrintDialog dialog( parent, &m_printDialogData );
-    int ret = dialog.ShowModal();
-    if (ret == wxID_CANCEL)
-    {
-        sm_lastError = wxPRINTER_CANCELLED;
-        return NULL;
-    }
-
-    m_native_preview = ret == wxID_PREVIEW;
-
-    m_printDialogData = dialog.GetPrintDialogData();
-    return new wxGnomePrintDC( m_printDialogData.GetPrintData() );
-}
-
-bool wxGnomePrinter::Setup( wxWindow *parent )
-{
-    return false;
-}
-
-//-----------------------------------------------------------------------------
-// wxGnomePrintDC
-//-----------------------------------------------------------------------------
-
-IMPLEMENT_CLASS(wxGnomePrintDC, wxDC)
-
-wxGnomePrintDC::wxGnomePrintDC( const wxPrintData& data )
-{
-    m_printData = data;
-
-    wxGnomePrintNativeData *native =
-        (wxGnomePrintNativeData*) m_printData.GetNativeData();
-
-    m_job = native->GetPrintJob();
-    m_gpc = gs_lgp->gnome_print_job_get_context (m_job);
-
-    m_layout = gs_lgp->gnome_print_pango_create_layout( m_gpc );
-    m_fontdesc = pango_font_description_from_string( "Sans 12" );
-    m_context = NULL;
-
-    m_currentRed = 0;
-    m_currentBlue = 0;
-    m_currentGreen = 0;
-
-    m_signX =  1;  // default x-axis left to right
-    m_signY = -1;  // default y-axis bottom up -> top down
-
-    GetSize( NULL, &m_deviceOffsetY );
-}
-
-wxGnomePrintDC::~wxGnomePrintDC()
-{
-}
-
-bool wxGnomePrintDC::IsOk() const
-{
-    return true;
-}
-
-bool wxGnomePrintDC::DoFloodFill(wxCoord x1, wxCoord y1, const wxColour &col, int style )
-{
-    return false;
-}
-
-bool wxGnomePrintDC::DoGetPixel(wxCoord x1, wxCoord y1, wxColour *col) const
-{
-    return false;
-}
-
-void wxGnomePrintDC::DoDrawLine(wxCoord x1, wxCoord y1, wxCoord x2, wxCoord y2)
-{
-    if  (m_pen.GetStyle() == wxTRANSPARENT) return;
-
-    SetPen( m_pen );
-
-    gs_lgp->gnome_print_moveto ( m_gpc, XLOG2DEV(x1), YLOG2DEV(y1) );
-    gs_lgp->gnome_print_lineto ( m_gpc, XLOG2DEV(x2), YLOG2DEV(y2) );
-    gs_lgp->gnome_print_stroke ( m_gpc);
-
-    CalcBoundingBox( x1, y1 );
-    CalcBoundingBox( x2, y2 );
-}
-
-void wxGnomePrintDC::DoCrossHair(wxCoord x, wxCoord y)
-{
-}
-
-void wxGnomePrintDC::DoDrawArc(wxCoord x1,wxCoord y1,wxCoord x2,wxCoord y2,wxCoord xc,wxCoord yc)
-{
-    double dx = x1 - xc;
-    double dy = y1 - yc;
-    double radius = sqrt((double)(dx*dx+dy*dy));
-    double alpha1, alpha2;
-    if (x1 == x2 && y1 == y2)
-    {
-        alpha1 = 0.0;
-        alpha2 = 360.0;
-    }
-    else
-    if (radius == 0.0)
-    {
-        alpha1 = alpha2 = 0.0;
-    }
-    else
-    {
-        alpha1 = (x1 - xc == 0) ?
-            (y1 - yc < 0) ? 90.0 : -90.0 :
-            -atan2(double(y1-yc), double(x1-xc)) * RAD2DEG;
-        alpha2 = (x2 - xc == 0) ?
-            (y2 - yc < 0) ? 90.0 : -90.0 :
-            -atan2(double(y2-yc), double(x2-xc)) * RAD2DEG;
-
-        while (alpha1 <= 0)   alpha1 += 360;
-        while (alpha2 <= 0)   alpha2 += 360; // adjust angles to be between
-        while (alpha1 > 360)  alpha1 -= 360; // 0 and 360 degree
-        while (alpha2 > 360)  alpha2 -= 360;
-    }
-
-    if (m_brush.GetStyle() != wxTRANSPARENT)
-    {
-        SetBrush( m_brush );
-        gs_lgp->gnome_print_moveto ( m_gpc, XLOG2DEV(xc), YLOG2DEV(yc) );
-        gs_lgp->gnome_print_arcto( m_gpc, XLOG2DEV(xc), YLOG2DEV(yc), XLOG2DEVREL((int)radius), alpha1, alpha2, 0 );
-
-        gs_lgp->gnome_print_fill( m_gpc );
-    }
-
-    if (m_pen.GetStyle() != wxTRANSPARENT)
-    {
-        SetPen (m_pen);
-        gs_lgp->gnome_print_newpath( m_gpc );
-        gs_lgp->gnome_print_moveto ( m_gpc, XLOG2DEV(xc), YLOG2DEV(yc) );
-        gs_lgp->gnome_print_arcto( m_gpc, XLOG2DEV(xc), YLOG2DEV(yc), XLOG2DEVREL((int)radius), alpha1, alpha2, 0 );
-        gs_lgp->gnome_print_closepath( m_gpc );
-
-        gs_lgp->gnome_print_stroke( m_gpc );
-    }
-
-    CalcBoundingBox (x1, y1);
-    CalcBoundingBox (x2, y2);
-    CalcBoundingBox (xc, yc);
-}
-
-void wxGnomePrintDC::DoDrawEllipticArc(wxCoord x,wxCoord y,wxCoord w,wxCoord h,double sa,double ea)
-{
-    x += w/2;
-    y += h/2;
-
-    int xx = XLOG2DEV(x);
-    int yy = YLOG2DEV(y);
-
-    gs_lgp->gnome_print_gsave( m_gpc );
-
-    gs_lgp->gnome_print_translate( m_gpc, xx, yy );
-    double scale = (double)YLOG2DEVREL(h) / (double) XLOG2DEVREL(w);
-    gs_lgp->gnome_print_scale( m_gpc, 1.0, scale );
-
-    xx = 0;
-    yy = 0;
-
-    if (m_brush.GetStyle () != wxTRANSPARENT)
-    {
-        SetBrush( m_brush );
-
-        gs_lgp->gnome_print_moveto ( m_gpc, xx, yy );
-        gs_lgp->gnome_print_arcto( m_gpc, xx, yy,
-            XLOG2DEVREL(w)/2, sa, ea, 0 );
-        gs_lgp->gnome_print_moveto ( m_gpc, xx, yy );
-
-        gs_lgp->gnome_print_fill( m_gpc );
-    }
-
-    if (m_pen.GetStyle () != wxTRANSPARENT)
-    {
-        SetPen (m_pen);
-
-        gs_lgp->gnome_print_arcto( m_gpc, xx, yy,
-            XLOG2DEVREL(w)/2, sa, ea, 0 );
-
-        gs_lgp->gnome_print_stroke( m_gpc );
-    }
-
-    gs_lgp->gnome_print_grestore( m_gpc );
-
-    CalcBoundingBox( x, y );
-    CalcBoundingBox( x+w, y+h );
-}
-
-void wxGnomePrintDC::DoDrawPoint(wxCoord x, wxCoord y)
-{
-}
-
-void wxGnomePrintDC::DoDrawLines(int n, wxPoint points[], wxCoord xoffset, wxCoord yoffset)
-{
-    if (m_pen.GetStyle() == wxTRANSPARENT) return;
-
-    if (n <= 0) return;
-
-    SetPen (m_pen);
-
-    int i;
-    for ( i =0; i<n ; i++ )
-        CalcBoundingBox( points[i].x+xoffset, points[i].y+yoffset);
-
-    gs_lgp->gnome_print_moveto ( m_gpc, XLOG2DEV(points[0].x+xoffset), YLOG2DEV(points[0].y+yoffset) );
-
-    for (i = 1; i < n; i++)
-        gs_lgp->gnome_print_lineto ( m_gpc, XLOG2DEV(points[i].x+xoffset), YLOG2DEV(points[i].y+yoffset) );
-
-    gs_lgp->gnome_print_stroke ( m_gpc);
-}
-
-void wxGnomePrintDC::DoDrawPolygon(int n, wxPoint points[], wxCoord xoffset, wxCoord yoffset, int fillStyle)
-{
-    if (n==0) return;
-
-    if (m_brush.GetStyle () != wxTRANSPARENT)
-    {
-        SetBrush( m_brush );
-
-        int x = points[0].x + xoffset;
-        int y = points[0].y + yoffset;
-        CalcBoundingBox( x, y );
-        gs_lgp->gnome_print_newpath( m_gpc );
-        gs_lgp->gnome_print_moveto( m_gpc, XLOG2DEV(x), YLOG2DEV(y) );
-        int i;
-        for (i = 1; i < n; i++)
-        {
-            int x = points[i].x + xoffset;
-            int y = points[i].y + yoffset;
-            gs_lgp->gnome_print_lineto( m_gpc, XLOG2DEV(x), YLOG2DEV(y) );
-            CalcBoundingBox( x, y );
-        }
-        gs_lgp->gnome_print_closepath( m_gpc );
-        gs_lgp->gnome_print_fill( m_gpc );
-    }
-
-    if (m_pen.GetStyle () != wxTRANSPARENT)
-    {
-        SetPen (m_pen);
-
-        int x = points[0].x + xoffset;
-        int y = points[0].y + yoffset;
-        gs_lgp->gnome_print_newpath( m_gpc );
-        gs_lgp->gnome_print_moveto( m_gpc, XLOG2DEV(x), YLOG2DEV(y) );
-        int i;
-        for (i = 1; i < n; i++)
-        {
-            int x = points[i].x + xoffset;
-            int y = points[i].y + yoffset;
-            gs_lgp->gnome_print_lineto( m_gpc, XLOG2DEV(x), YLOG2DEV(y) );
-            CalcBoundingBox( x, y );
-        }
-        gs_lgp->gnome_print_closepath( m_gpc );
-        gs_lgp->gnome_print_stroke( m_gpc );
-    }
-}
-
-void wxGnomePrintDC::DoDrawPolyPolygon(int n, int count[], wxPoint points[], wxCoord xoffset, wxCoord yoffset, int fillStyle)
-{
-    wxDC::DoDrawPolyPolygon( n, count, points, xoffset, yoffset, fillStyle );
-}
-
-void wxGnomePrintDC::DoDrawRectangle(wxCoord x, wxCoord y, wxCoord width, wxCoord height)
-{
-    if (m_brush.GetStyle () != wxTRANSPARENT)
-    {
-        SetBrush( m_brush );
-
-        gs_lgp->gnome_print_newpath( m_gpc );
-        gs_lgp->gnome_print_moveto( m_gpc, XLOG2DEV(x), YLOG2DEV(y) );
-        gs_lgp->gnome_print_lineto( m_gpc, XLOG2DEV(x + width), YLOG2DEV(y) );
-        gs_lgp->gnome_print_lineto( m_gpc, XLOG2DEV(x + width), YLOG2DEV(y + height) );
-        gs_lgp->gnome_print_lineto( m_gpc, XLOG2DEV(x), YLOG2DEV(y + height) );
-        gs_lgp->gnome_print_closepath( m_gpc );
-        gs_lgp->gnome_print_fill( m_gpc );
-
-        CalcBoundingBox( x, y );
-        CalcBoundingBox( x + width, y + height );
-    }
-
-    if (m_pen.GetStyle () != wxTRANSPARENT)
-    {
-        SetPen (m_pen);
-
-        gs_lgp->gnome_print_newpath( m_gpc );
-        gs_lgp->gnome_print_moveto( m_gpc, XLOG2DEV(x), YLOG2DEV(y) );
-        gs_lgp->gnome_print_lineto( m_gpc, XLOG2DEV(x + width), YLOG2DEV(y) );
-        gs_lgp->gnome_print_lineto( m_gpc, XLOG2DEV(x + width), YLOG2DEV(y + height) );
-        gs_lgp->gnome_print_lineto( m_gpc, XLOG2DEV(x), YLOG2DEV(y + height) );
-        gs_lgp->gnome_print_closepath( m_gpc );
-        gs_lgp->gnome_print_stroke( m_gpc );
-
-        CalcBoundingBox( x, y );
-        CalcBoundingBox( x + width, y + height );
-    }
-}
-
-void wxGnomePrintDC::DoDrawRoundedRectangle(wxCoord x, wxCoord y, wxCoord width, wxCoord height, double radius)
-{
-    wxCoord rad = (wxCoord) radius;
-
-    if (m_brush.GetStyle() != wxTRANSPARENT)
-    {
-        SetBrush(m_brush);
-        gs_lgp->gnome_print_newpath(m_gpc);
-        gs_lgp->gnome_print_moveto(m_gpc,XLOG2DEV(x + rad),YLOG2DEV(y));
-        gs_lgp->gnome_print_curveto(m_gpc,
-                                    XLOG2DEV(x + rad),YLOG2DEV(y),
-                                    XLOG2DEV(x),YLOG2DEV(y),
-                                    XLOG2DEV(x),YLOG2DEV(y + rad));
-        gs_lgp->gnome_print_lineto(m_gpc,XLOG2DEV(x),YLOG2DEV(y + height - rad));
-        gs_lgp->gnome_print_curveto(m_gpc,
-                                    XLOG2DEV(x),YLOG2DEV(y + height - rad),
-                                    XLOG2DEV(x),YLOG2DEV(y + height),
-                                    XLOG2DEV(x + rad),YLOG2DEV(y + height));
-        gs_lgp->gnome_print_lineto(m_gpc,XLOG2DEV(x + width - rad),YLOG2DEV(y + height));
-        gs_lgp->gnome_print_curveto(m_gpc,
-                                    XLOG2DEV(x + width - rad),YLOG2DEV(y + height),
-                                    XLOG2DEV(x + width),YLOG2DEV(y + height),
-                                    XLOG2DEV(x + width),YLOG2DEV(y + height - rad));
-        gs_lgp->gnome_print_lineto(m_gpc,XLOG2DEV(x + width),YLOG2DEV(y + rad));
-        gs_lgp->gnome_print_curveto(m_gpc,
-                                    XLOG2DEV(x + width),YLOG2DEV(y + rad),
-                                    XLOG2DEV(x + width),YLOG2DEV(y),
-                                    XLOG2DEV(x + width - rad),YLOG2DEV(y));
-        gs_lgp->gnome_print_lineto(m_gpc,XLOG2DEV(x + rad),YLOG2DEV(y));
-        gs_lgp->gnome_print_closepath(m_gpc);
-        gs_lgp->gnome_print_fill(m_gpc);
-
-        CalcBoundingBox(x,y);
-        CalcBoundingBox(x+width,y+height);
-    }
-
-    if (m_pen.GetStyle() != wxTRANSPARENT)
-    {
-        SetPen(m_pen);
-        gs_lgp->gnome_print_newpath(m_gpc);
-        gs_lgp->gnome_print_moveto(m_gpc,XLOG2DEV(x + rad),YLOG2DEV(y));
-        gs_lgp->gnome_print_curveto(m_gpc,
-                                    XLOG2DEV(x + rad),YLOG2DEV(y),
-                                    XLOG2DEV(x),YLOG2DEV(y),
-                                    XLOG2DEV(x),YLOG2DEV(y + rad));
-        gs_lgp->gnome_print_lineto(m_gpc,XLOG2DEV(x),YLOG2DEV(y + height - rad));
-        gs_lgp->gnome_print_curveto(m_gpc,
-                                    XLOG2DEV(x),YLOG2DEV(y + height - rad),
-                                    XLOG2DEV(x),YLOG2DEV(y + height),
-                                    XLOG2DEV(x + rad),YLOG2DEV(y + height));
-        gs_lgp->gnome_print_lineto(m_gpc,XLOG2DEV(x + width - rad),YLOG2DEV(y + height));
-        gs_lgp->gnome_print_curveto(m_gpc,
-                                    XLOG2DEV(x + width - rad),YLOG2DEV(y + height),
-                                    XLOG2DEV(x + width),YLOG2DEV(y + height),
-                                    XLOG2DEV(x + width),YLOG2DEV(y + height - rad));
-        gs_lgp->gnome_print_lineto(m_gpc,XLOG2DEV(x + width),YLOG2DEV(y + rad));
-        gs_lgp->gnome_print_curveto(m_gpc,
-                                    XLOG2DEV(x + width),YLOG2DEV(y + rad),
-                                    XLOG2DEV(x + width),YLOG2DEV(y),
-                                    XLOG2DEV(x + width - rad),YLOG2DEV(y));
-        gs_lgp->gnome_print_lineto(m_gpc,XLOG2DEV(x + rad),YLOG2DEV(y));
-        gs_lgp->gnome_print_closepath(m_gpc);
-        gs_lgp->gnome_print_stroke(m_gpc);
-
-        CalcBoundingBox(x,y);
-        CalcBoundingBox(x+width,y+height);
-    }
-}
-
-void wxGnomePrintDC::makeEllipticalPath(wxCoord x, wxCoord y,
-                                        wxCoord width, wxCoord height)
-{
-    double r = 4 * (sqrt(2.) - 1) / 3;
-    double  halfW = 0.5 * width,
-            halfH = 0.5 * height,
-            halfWR = r * halfW,
-            halfHR = r * halfH;
-    wxCoord halfWI = (wxCoord) halfW,
-            halfHI = (wxCoord) halfH;
-
-    gs_lgp->gnome_print_newpath( m_gpc );
-
-    // Approximate an ellipse using four cubic splines, clockwise from 0 deg */
-    gs_lgp->gnome_print_moveto( m_gpc,
-                XLOG2DEV(x + width),
-                YLOG2DEV(y + halfHI) );
-    gs_lgp->gnome_print_curveto( m_gpc,
-                XLOG2DEV(x + width),
-                YLOG2DEV(y + (wxCoord) rint (halfH + halfHR)),
-                XLOG2DEV(x + (wxCoord) rint(halfW + halfWR)),
-                YLOG2DEV(y + height),
-                XLOG2DEV(x + halfWI),
-                YLOG2DEV(y + height) );
-    gs_lgp->gnome_print_curveto( m_gpc,
-                XLOG2DEV(x + (wxCoord) rint(halfW - halfWR)),
-                YLOG2DEV(y + height),
-                XLOG2DEV(x),
-                YLOG2DEV(y + (wxCoord) rint (halfH + halfHR)),
-                XLOG2DEV(x), YLOG2DEV(y+halfHI) );
-    gs_lgp->gnome_print_curveto( m_gpc,
-                XLOG2DEV(x),
-                YLOG2DEV(y + (wxCoord) rint (halfH - halfHR)),
-                XLOG2DEV(x + (wxCoord) rint (halfW - halfWR)),
-                YLOG2DEV(y),
-                XLOG2DEV(x+halfWI), YLOG2DEV(y) );
-    gs_lgp->gnome_print_curveto( m_gpc,
-                XLOG2DEV(x + (wxCoord) rint(halfW + halfWR)),
-                YLOG2DEV(y),
-                XLOG2DEV(x + width),
-                YLOG2DEV(y + (wxCoord) rint(halfH - halfHR)),
-                XLOG2DEV(x + width), YLOG2DEV(y + halfHI) );
-
-    gs_lgp->gnome_print_closepath(m_gpc);
-}
-
-void wxGnomePrintDC::DoDrawEllipse(wxCoord x, wxCoord y, wxCoord width, wxCoord height)
-{
-    if (m_brush.GetStyle () != wxTRANSPARENT)
-    {
-        SetBrush( m_brush );
-        makeEllipticalPath( x, y, width, height );
-        gs_lgp->gnome_print_fill( m_gpc );
-        CalcBoundingBox( x, y );
-        CalcBoundingBox( x + width, y + height );
-    }
-
-    if (m_pen.GetStyle () != wxTRANSPARENT)
-    {
-        SetPen (m_pen);
-        makeEllipticalPath( x, y, width, height );
-        gs_lgp->gnome_print_stroke( m_gpc );
-        CalcBoundingBox( x, y );
-        CalcBoundingBox( x + width, y + height );
-    }
-}
-
-#if wxUSE_SPLINES
-void wxGnomePrintDC::DoDrawSpline(wxList *points)
-{
-    SetPen (m_pen);
-
-    double c, d, x1, y1, x2, y2, x3, y3;
-    wxPoint *p, *q;
-
-    wxList::compatibility_iterator node = points->GetFirst();
-    p = (wxPoint *)node->GetData();
-    x1 = p->x;
-    y1 = p->y;
-
-    node = node->GetNext();
-    p = (wxPoint *)node->GetData();
-    c = p->x;
-    d = p->y;
-    x3 =
-         (double)(x1 + c) / 2;
-    y3 =
-         (double)(y1 + d) / 2;
-
-    gs_lgp->gnome_print_newpath( m_gpc );
-    gs_lgp->gnome_print_moveto( m_gpc, XLOG2DEV((wxCoord)x1), YLOG2DEV((wxCoord)y1) );
-    gs_lgp->gnome_print_lineto( m_gpc, XLOG2DEV((wxCoord)x3), YLOG2DEV((wxCoord)y3) );
-
-    CalcBoundingBox( (wxCoord)x1, (wxCoord)y1 );
-    CalcBoundingBox( (wxCoord)x3, (wxCoord)y3 );
-
-    node = node->GetNext();
-    while (node)
-    {
-        q = (wxPoint *)node->GetData();
-
-        x1 = x3;
-        y1 = y3;
-        x2 = c;
-        y2 = d;
-        c = q->x;
-        d = q->y;
-        x3 = (double)(x2 + c) / 2;
-        y3 = (double)(y2 + d) / 2;
-
-        gs_lgp->gnome_print_curveto(m_gpc,
-            XLOG2DEV((wxCoord)x1), YLOG2DEV((wxCoord)y1),
-            XLOG2DEV((wxCoord)x2), YLOG2DEV((wxCoord)y2),
-            XLOG2DEV((wxCoord)x3), YLOG2DEV((wxCoord)y3) );
-
-        CalcBoundingBox( (wxCoord)x1, (wxCoord)y1 );
-        CalcBoundingBox( (wxCoord)x3, (wxCoord)y3 );
-
-        node = node->GetNext();
-    }
-
-    gs_lgp->gnome_print_lineto ( m_gpc, XLOG2DEV((wxCoord)c), YLOG2DEV((wxCoord)d) );
-
-    gs_lgp->gnome_print_stroke( m_gpc );
-}
-#endif // wxUSE_SPLINES
-
-bool wxGnomePrintDC::DoBlit(wxCoord xdest, wxCoord ydest, wxCoord width, wxCoord height,
-            wxDC *source, wxCoord xsrc, wxCoord ysrc, int rop, bool useMask,
-            wxCoord xsrcMask, wxCoord ysrcMask)
-{
-    wxCHECK_MSG( source, false, wxT("invalid source dc") );
-
-    // blit into a bitmap
-    wxBitmap bitmap( width, height );
-    wxMemoryDC memDC;
-    memDC.SelectObject(bitmap);
-    memDC.Blit(0, 0, width, height, source, xsrc, ysrc, rop); /* TODO: Blit transparently? */
-    memDC.SelectObject(wxNullBitmap);
-
-    // draw bitmap. scaling and positioning is done there
-    DrawBitmap( bitmap, xdest, ydest );
-
-    return true;
-}
-
-void wxGnomePrintDC::DoDrawIcon( const wxIcon& icon, wxCoord x, wxCoord y )
-{
-    DoDrawBitmap( icon, x, y, true );
-}
-
-void wxGnomePrintDC::DoDrawBitmap( const wxBitmap& bitmap, wxCoord x, wxCoord y, bool useMask )
-{
-    if (!bitmap.Ok()) return;
-
-    if (bitmap.HasPixbuf())
-    {
-        GdkPixbuf *pixbuf = bitmap.GetPixbuf();
-        guchar *raw_image = gdk_pixbuf_get_pixels( pixbuf );
-        bool has_alpha = gdk_pixbuf_get_has_alpha( pixbuf );
-        int rowstride = gdk_pixbuf_get_rowstride( pixbuf );
-        int height = gdk_pixbuf_get_height( pixbuf );
-        int width = gdk_pixbuf_get_width( pixbuf );
-
-        gs_lgp->gnome_print_gsave( m_gpc );
-        double matrix[6];
-        matrix[0] = XLOG2DEVREL(width);
-        matrix[1] = 0;
-        matrix[2] = 0;
-        matrix[3] = YLOG2DEVREL(height);
-        matrix[4] = XLOG2DEV(x);
-        matrix[5] = YLOG2DEV(y+height);
-        gs_lgp->gnome_print_concat( m_gpc, matrix );
-        gs_lgp->gnome_print_moveto(  m_gpc, 0, 0 );
-        if (has_alpha)
-            gs_lgp->gnome_print_rgbaimage( m_gpc, (guchar *)raw_image, width, height, rowstride );
-        else
-            gs_lgp->gnome_print_rgbimage( m_gpc, (guchar *)raw_image, width, height, rowstride );
-        gs_lgp->gnome_print_grestore( m_gpc );
-    }
-    else
-    {
-        wxImage image = bitmap.ConvertToImage();
-
-        if (!image.Ok()) return;
-
-        gs_lgp->gnome_print_gsave( m_gpc );
-        double matrix[6];
-        matrix[0] = XLOG2DEVREL(image.GetWidth());
-        matrix[1] = 0;
-        matrix[2] = 0;
-        matrix[3] = YLOG2DEVREL(image.GetHeight());
-        matrix[4] = XLOG2DEV(x);
-        matrix[5] = YLOG2DEV(y+image.GetHeight());
-        gs_lgp->gnome_print_concat( m_gpc, matrix );
-        gs_lgp->gnome_print_moveto(  m_gpc, 0, 0 );
-        gs_lgp->gnome_print_rgbimage( m_gpc, (guchar*) image.GetData(), image.GetWidth(), image.GetHeight(), image.GetWidth()*3 );
-        gs_lgp->gnome_print_grestore( m_gpc );
-    }
-}
-
-void wxGnomePrintDC::DoDrawText(const wxString& text, wxCoord x, wxCoord y )
-{
-    DoDrawRotatedText( text, x, y, 0.0 );
-}
-
-void wxGnomePrintDC::DoDrawRotatedText(const wxString& text, wxCoord x, wxCoord y, double angle)
-{
-    x = XLOG2DEV(x);
-    y = YLOG2DEV(y);
-
-    bool underlined = m_font.Ok() && m_font.GetUnderlined();
-
-    // FIXME-UTF8: wouldn't be needed if utf8_str() always returned a buffer
-#if wxUSE_UNICODE_UTF8
-    const char *data = text.utf8_str();
-#else
-    const wxCharBuffer data = text.utf8_str();
-#endif
-
-    size_t datalen = strlen(data);
-    pango_layout_set_text( m_layout, data, datalen);
-
-    if (underlined)
-    {
-        PangoAttrList *attrs = pango_attr_list_new();
-        PangoAttribute *a = pango_attr_underline_new(PANGO_UNDERLINE_SINGLE);
-        a->start_index = 0;
-        a->end_index = datalen;
-        pango_attr_list_insert(attrs, a);
-        pango_layout_set_attributes(m_layout, attrs);
-        pango_attr_list_unref(attrs);
-    }
-
-    if (m_textForegroundColour.Ok())
-    {
-        unsigned char red = m_textForegroundColour.Red();
-        unsigned char blue = m_textForegroundColour.Blue();
-        unsigned char green = m_textForegroundColour.Green();
-
-        if (!(red == m_currentRed && green == m_currentGreen && blue == m_currentBlue))
-        {
-            double redPS = (double)(red) / 255.0;
-            double bluePS = (double)(blue) / 255.0;
-            double greenPS = (double)(green) / 255.0;
-
-            gs_lgp->gnome_print_setrgbcolor( m_gpc, redPS, greenPS, bluePS );
-
-            m_currentRed = red;
-            m_currentBlue = blue;
-            m_currentGreen = green;
-        }
-    }
-
-    int w,h;
-
-    if (fabs(m_scaleY - 1.0) > 0.00001)
-    {
-        // If there is a user or actually any scale applied to
-        // the device context, scale the font.
-
-        // scale font description
-        gint oldSize = pango_font_description_get_size( m_fontdesc );
-        double size = oldSize;
-        size = size * m_scaleY;
-        pango_font_description_set_size( m_fontdesc, (gint)size );
-
-        // actually apply scaled font
-        pango_layout_set_font_description( m_layout, m_fontdesc );
-
-        pango_layout_get_pixel_size( m_layout, &w, &h );
-#if 0
-        if ( m_backgroundMode == wxSOLID )
-        {
-            gdk_gc_set_foreground(m_textGC, m_textBackgroundColour.GetColor());
-            gdk_draw_rectangle(m_window, m_textGC, TRUE, x, y, w, h);
-            gdk_gc_set_foreground(m_textGC, m_textForegroundColour.GetColor());
-        }
-#endif
-        // Draw layout.
-        gs_lgp->gnome_print_moveto (m_gpc, x, y);
-        if (fabs(angle) > 0.00001)
-        {
-            gs_lgp->gnome_print_gsave( m_gpc );
-            gs_lgp->gnome_print_rotate( m_gpc, angle );
-            gs_lgp->gnome_print_pango_layout( m_gpc, m_layout );
-            gs_lgp->gnome_print_grestore( m_gpc );
-        }
-        else
-        {
-            gs_lgp->gnome_print_pango_layout( m_gpc, m_layout );
-        }
-
-        // reset unscaled size
-        pango_font_description_set_size( m_fontdesc, oldSize );
-
-        // actually apply unscaled font
-        pango_layout_set_font_description( m_layout, m_fontdesc );
-    }
-    else
-    {
-        pango_layout_get_pixel_size( m_layout, &w, &h );
-#if 0
-        if ( m_backgroundMode == wxSOLID )
-        {
-            gdk_gc_set_foreground(m_textGC, m_textBackgroundColour.GetColor());
-            gdk_draw_rectangle(m_window, m_textGC, TRUE, x, y, w, h);
-            gdk_gc_set_foreground(m_textGC, m_textForegroundColour.GetColor());
-        }
-#endif
-        // Draw layout.
-        gs_lgp->gnome_print_moveto (m_gpc, x, y);
-        if (fabs(angle) > 0.00001)
-        {
-            gs_lgp->gnome_print_gsave( m_gpc );
-            gs_lgp->gnome_print_rotate( m_gpc, angle );
-            gs_lgp->gnome_print_pango_layout( m_gpc, m_layout );
-            gs_lgp->gnome_print_grestore( m_gpc );
-        }
-        else
-        {
-            gs_lgp->gnome_print_pango_layout( m_gpc, m_layout );
-        }
-    }
-
-    if (underlined)
-    {
-        // undo underline attributes setting:
-        pango_layout_set_attributes(m_layout, NULL);
-    }
-
-    CalcBoundingBox (x + w, y + h);
-}
-
-void wxGnomePrintDC::Clear()
-{
-}
-
-void wxGnomePrintDC::SetFont( const wxFont& font )
-{
-    m_font = font;
-
-    if (m_font.Ok())
-    {
-        if (m_fontdesc)
-            pango_font_description_free( m_fontdesc );
-
-        m_fontdesc = pango_font_description_copy( m_font.GetNativeFontInfo()->description );
-
-        pango_layout_set_font_description( m_layout, m_fontdesc );
-    }
-}
-
-void wxGnomePrintDC::SetPen( const wxPen& pen )
-{
-    if (!pen.Ok()) return;
-
-    m_pen = pen;
-
-    gs_lgp->gnome_print_setlinewidth( m_gpc, XLOG2DEVREL( 1000 * m_pen.GetWidth() ) / 1000.0f );
-
-    static const double dotted[] =  {2.0, 5.0};
-    static const double short_dashed[] = {4.0, 4.0};
-    static const double wxCoord_dashed[] = {4.0, 8.0};
-    static const double dotted_dashed[] = {6.0, 6.0, 2.0, 6.0};
-
-    switch (m_pen.GetStyle())
-    {
-        case wxDOT:           gs_lgp->gnome_print_setdash( m_gpc, 2, dotted, 0 ); break;
-        case wxSHORT_DASH:    gs_lgp->gnome_print_setdash( m_gpc, 2, short_dashed, 0 ); break;
-        case wxLONG_DASH:     gs_lgp->gnome_print_setdash( m_gpc, 2, wxCoord_dashed, 0 ); break;
-        case wxDOT_DASH:      gs_lgp->gnome_print_setdash( m_gpc, 4, dotted_dashed, 0 );  break;
-        case wxUSER_DASH:
-        {
-            // It may be noted that libgnomeprint between at least
-            // versions 2.8.0 and 2.12.1 makes a copy of the dashes
-            // and then leak the memory since it doesn't set the
-            // internal flag "privatedash" to 0.
-            wxDash *wx_dashes;
-            int num = m_pen.GetDashes (&wx_dashes);
-            gdouble *g_dashes = g_new( gdouble, num );
-            int i;
-            for (i = 0; i < num; ++i)
-                g_dashes[i] = (gdouble) wx_dashes[i];
-            gs_lgp -> gnome_print_setdash( m_gpc, num, g_dashes, 0);
-            g_free( g_dashes );
-        }
-        break;
-        case wxSOLID:
-        case wxTRANSPARENT:
-        default:              gs_lgp->gnome_print_setdash( m_gpc, 0, NULL, 0 );   break;
-    }
-
-
-    unsigned char red = m_pen.GetColour().Red();
-    unsigned char blue = m_pen.GetColour().Blue();
-    unsigned char green = m_pen.GetColour().Green();
-
-    if (!(red == m_currentRed && green == m_currentGreen && blue == m_currentBlue))
-    {
-        double redPS = (double)(red) / 255.0;
-        double bluePS = (double)(blue) / 255.0;
-        double greenPS = (double)(green) / 255.0;
-
-        gs_lgp->gnome_print_setrgbcolor( m_gpc, redPS, greenPS, bluePS );
-
-        m_currentRed = red;
-        m_currentBlue = blue;
-        m_currentGreen = green;
-    }
-}
-
-void wxGnomePrintDC::SetBrush( const wxBrush& brush )
-{
-    if (!brush.Ok()) return;
-
-    m_brush = brush;
-
-    // Brush colour
-    unsigned char red = m_brush.GetColour().Red();
-    unsigned char blue = m_brush.GetColour().Blue();
-    unsigned char green = m_brush.GetColour().Green();
-
-    if (!m_colour)
-    {
-        // Anything not white is black
-        if (! (red == (unsigned char) 255 &&
-               blue == (unsigned char) 255 &&
-               green == (unsigned char) 255) )
-        {
-            red = (unsigned char) 0;
-            green = (unsigned char) 0;
-            blue = (unsigned char) 0;
-        }
-        // setgray here ?
-    }
-
-    if (!(red == m_currentRed && green == m_currentGreen && blue == m_currentBlue))
-    {
-        double redPS = (double)(red) / 255.0;
-        double bluePS = (double)(blue) / 255.0;
-        double greenPS = (double)(green) / 255.0;
-
-        gs_lgp->gnome_print_setrgbcolor( m_gpc, redPS, greenPS, bluePS );
-
-        m_currentRed = red;
-        m_currentBlue = blue;
-        m_currentGreen = green;
-    }
-}
-
-void wxGnomePrintDC::SetLogicalFunction( int function )
-{
-}
-
-void wxGnomePrintDC::SetBackground( const wxBrush& brush )
-{
-}
-
-void wxGnomePrintDC::DoSetClippingRegion(wxCoord x, wxCoord y, wxCoord width, wxCoord height)
-{
-    wxDC::DoSetClippingRegion( x, y, width, height );
-    
-    gs_lgp->gnome_print_gsave( m_gpc );
-    
-    gs_lgp->gnome_print_newpath( m_gpc );
-    gs_lgp->gnome_print_moveto( m_gpc, XLOG2DEV(x), YLOG2DEV(y) );
-    gs_lgp->gnome_print_lineto( m_gpc, XLOG2DEV(x + width), YLOG2DEV(y) );
-    gs_lgp->gnome_print_lineto( m_gpc, XLOG2DEV(x + width), YLOG2DEV(y + height) );
-    gs_lgp->gnome_print_lineto( m_gpc, XLOG2DEV(x), YLOG2DEV(y + height) );
-    gs_lgp->gnome_print_closepath( m_gpc );
-    gs_lgp->gnome_print_clip( m_gpc );
-}
-
-void wxGnomePrintDC::DestroyClippingRegion()
-{
-    wxDC::DestroyClippingRegion();
-
-    gs_lgp->gnome_print_grestore( m_gpc );
-    
-#if 0
-    // not needed, we set the values in each
-    // drawing method anyways
-    SetPen( m_pen );
-    SetBrush( m_brush );
-    SetFont( m_font );
-#endif
-}
-
-bool wxGnomePrintDC::StartDoc(const wxString& message)
-{
-    return true;
-}
-
-void wxGnomePrintDC::EndDoc()
-{
-    gs_lgp->gnome_print_end_doc( m_gpc );
-}
-
-void wxGnomePrintDC::StartPage()
-{
-    gs_lgp->gnome_print_beginpage( m_gpc, (const guchar*) "page" );
-}
-
-void wxGnomePrintDC::EndPage()
-{
-    gs_lgp->gnome_print_showpage( m_gpc );
-}
-
-wxCoord wxGnomePrintDC::GetCharHeight() const
-{
-    pango_layout_set_text( m_layout, "H", 1 );
-
-    int w,h;
-    pango_layout_get_pixel_size( m_layout, &w, &h );
-
-    return h;
-}
-
-wxCoord wxGnomePrintDC::GetCharWidth() const
-{
-    pango_layout_set_text( m_layout, "H", 1 );
-
-    int w,h;
-    pango_layout_get_pixel_size( m_layout, &w, &h );
-
-    return w;
-}
-
-void wxGnomePrintDC::DoGetTextExtent(const wxString& string, wxCoord *width, wxCoord *height,
-                     wxCoord *descent,
-                     wxCoord *externalLeading,
-                     const wxFont *theFont ) const
-{
-    if ( width )
-        *width = 0;
-    if ( height )
-        *height = 0;
-    if ( descent )
-        *descent = 0;
-    if ( externalLeading )
-        *externalLeading = 0;
-
-    if (string.empty())
-    {
-        return;
-    }
-
-    // Set layout's text
-
-    // FIXME-UTF8: wouldn't be needed if utf8_str() always returned a buffer
-#if wxUSE_UNICODE_UTF8
-    const char *dataUTF8 = string.utf8_str();
-#else
-    const wxCharBuffer dataUTF8 = string.utf8_str();
-#endif
-
-    PangoFontDescription *desc = (theFont) ? theFont->GetNativeFontInfo()->description : m_fontdesc;
-
-    gint oldSize = pango_font_description_get_size( desc );
-    double size = oldSize;
-    size = size * m_scaleY;
-    pango_font_description_set_size( desc, (gint)size );
-
-    // apply scaled font
-    pango_layout_set_font_description( m_layout, desc );
-
-    pango_layout_set_text( m_layout, dataUTF8, strlen(dataUTF8) );
-
-    int w, h;
-    pango_layout_get_pixel_size( m_layout, &w, &h );
-
-
-    if (width)
-        *width = (wxCoord)(w / m_scaleX);
-    if (height)
-        *height = (wxCoord)(h / m_scaleY);
-
-    if (descent)
-    {
-        PangoLayoutIter *iter = pango_layout_get_iter(m_layout);
-        int baseline = pango_layout_iter_get_baseline(iter);
-        pango_layout_iter_free(iter);
-        *descent = h - PANGO_PIXELS(baseline);
-    }
-
-    // reset unscaled size
-    pango_font_description_set_size( desc, oldSize );
-
-    // reset unscaled font
-    pango_layout_set_font_description( m_layout, m_fontdesc );
-}
-
-void wxGnomePrintDC::DoGetSize(int* width, int* height) const
-{
-    wxGnomePrintNativeData *native =
-      (wxGnomePrintNativeData*) m_printData.GetNativeData();
-
-    // Query page size. This seems to omit the margins
-    double pw,ph;
-    gs_lgp->gnome_print_job_get_page_size( native->GetPrintJob(), &pw, &ph );
-
-    if (width)
-        *width = (int) (pw + 0.5);
-    if (height)
-        *height = (int) (ph + 0.5);
-}
-
-void wxGnomePrintDC::DoGetSizeMM(int *width, int *height) const
-{
-    wxGnomePrintNativeData *native =
-      (wxGnomePrintNativeData*) m_printData.GetNativeData();
-
-    // This code assumes values in Pts.
-
-    double pw,ph;
-    gs_lgp->gnome_print_job_get_page_size( native->GetPrintJob(), &pw, &ph );
-
-    // Convert to mm.
-
-    const GnomePrintUnit *mm_unit = gs_lgp->gnome_print_unit_get_by_abbreviation( (const guchar*) "mm" );
-    const GnomePrintUnit *pts_unit = gs_lgp->gnome_print_unit_get_by_abbreviation( (const guchar*) "Pts" );
-    gs_lgp->gnome_print_convert_distance( &pw, pts_unit, mm_unit );
-    gs_lgp->gnome_print_convert_distance( &ph, pts_unit, mm_unit );
-
-    if (width)
-        *width = (int) (pw + 0.5);
-    if (height)
-        *height = (int) (ph + 0.5);
-}
-
-wxSize wxGnomePrintDC::GetPPI() const
-{
-    return wxSize(72,72);
-}
-
-void wxGnomePrintDC::SetAxisOrientation( bool xLeftRight, bool yBottomUp )
-{
-    m_signX = (xLeftRight ? 1 : -1);
-    m_signY = (yBottomUp  ? 1 : -1);
-
-    ComputeScaleAndOrigin();
-}
-
-void wxGnomePrintDC::SetLogicalOrigin( wxCoord x, wxCoord y )
-{
-    wxDC::SetLogicalOrigin( x, y );
-}
-
-void wxGnomePrintDC::SetDeviceOrigin( wxCoord x, wxCoord y )
-{
-    wxDC::SetDeviceOrigin( x, y );
-}
-
-void wxGnomePrintDC::SetPrintData(const wxPrintData& data)
-{ 
-    m_printData = data;
-    
-    if (m_printData.GetOrientation() == wxPORTRAIT)
-        GetSize( NULL, &m_deviceOffsetY );
-    else
-        GetSize( &m_deviceOffsetY, NULL );
-}
-
-void wxGnomePrintDC::SetResolution(int ppi)
-{
-}
-
-int wxGnomePrintDC::GetResolution()
-{
-    return 72;
-}
-
-
-class wxGnomePrintModule: public wxModule
-{
-public:
-    wxGnomePrintModule() {}
-    bool OnInit();
-    void OnExit();
-
-private:
-    DECLARE_DYNAMIC_CLASS(wxGnomePrintModule)
-};
-
-bool wxGnomePrintModule::OnInit()
-{
-    gs_lgp = new wxGnomePrintLibrary;
-    if (gs_lgp->IsOk())
-        wxPrintFactory::SetPrintFactory( new wxGnomePrintFactory );
-    return true;
-}
-
-void wxGnomePrintModule::OnExit()
-{
-    delete gs_lgp;
-}
-
-IMPLEMENT_DYNAMIC_CLASS(wxGnomePrintModule, wxModule)
-
-// ----------------------------------------------------------------------------
-// Print preview
-// ----------------------------------------------------------------------------
-
-IMPLEMENT_CLASS(wxGnomePrintPreview, wxPrintPreviewBase)
-
-void wxGnomePrintPreview::Init(wxPrintout * WXUNUSED(printout),
-                                    wxPrintout * WXUNUSED(printoutForPrinting))
-{
-    DetermineScaling();
-}
-
-wxGnomePrintPreview::wxGnomePrintPreview(wxPrintout *printout,
-                                                   wxPrintout *printoutForPrinting,
-                                                   wxPrintDialogData *data)
-                        : wxPrintPreviewBase(printout, printoutForPrinting, data)
-{
-    Init(printout, printoutForPrinting);
-}
-
-wxGnomePrintPreview::wxGnomePrintPreview(wxPrintout *printout,
-                                                   wxPrintout *printoutForPrinting,
-                                                   wxPrintData *data)
-                        : wxPrintPreviewBase(printout, printoutForPrinting, data)
-{
-    Init(printout, printoutForPrinting);
-}
-
-wxGnomePrintPreview::~wxGnomePrintPreview()
-{
-}
-
-bool wxGnomePrintPreview::Print(bool interactive)
-{
-    if (!m_printPrintout)
-        return false;
-
-    wxPrinter printer(& m_printDialogData);
-    return printer.Print(m_previewFrame, m_printPrintout, interactive);
-}
-
-void wxGnomePrintPreview::DetermineScaling()
-{
-    wxPaperSize paperType = m_printDialogData.GetPrintData().GetPaperId();
-    if (paperType == wxPAPER_NONE)
-        paperType = wxPAPER_NONE;
-
-    wxPrintPaperType *paper = wxThePrintPaperDatabase->FindPaperType(paperType);
-    if (!paper)
-        paper = wxThePrintPaperDatabase->FindPaperType(wxPAPER_A4);
-
-    if (paper)
-    {
-        wxSize ScreenPixels = wxGetDisplaySize();
-        wxSize ScreenMM = wxGetDisplaySizeMM();
-
-        m_previewPrintout->SetPPIScreen( (int) ((ScreenPixels.GetWidth() * 25.4) / ScreenMM.GetWidth()),
-                                         (int) ((ScreenPixels.GetHeight() * 25.4) / ScreenMM.GetHeight()) );
-        m_previewPrintout->SetPPIPrinter(wxGnomePrintDC::GetResolution(), wxGnomePrintDC::GetResolution());
-
-        wxSize sizeDevUnits(paper->GetSizeDeviceUnits());
-
-        // TODO: get better resolution information from wxGnomePrintDC, if possible.
-
-        sizeDevUnits.x = (wxCoord)((float)sizeDevUnits.x * wxGnomePrintDC::GetResolution() / 72.0);
-        sizeDevUnits.y = (wxCoord)((float)sizeDevUnits.y * wxGnomePrintDC::GetResolution() / 72.0);
-        wxSize sizeTenthsMM(paper->GetSize());
-        wxSize sizeMM(sizeTenthsMM.x / 10, sizeTenthsMM.y / 10);
-
-        // If in landscape mode, we need to swap the width and height.
-        if ( m_printDialogData.GetPrintData().GetOrientation() == wxLANDSCAPE )
-        {
-            m_pageWidth = sizeDevUnits.y;
-            m_pageHeight = sizeDevUnits.x;
-            m_previewPrintout->SetPageSizeMM(sizeMM.y, sizeMM.x);
-        }
-        else
-        {
-            m_pageWidth = sizeDevUnits.x;
-            m_pageHeight = sizeDevUnits.y;
-            m_previewPrintout->SetPageSizeMM(sizeMM.x, sizeMM.y);
-        }
-        m_previewPrintout->SetPageSizePixels(m_pageWidth, m_pageHeight);
-        m_previewPrintout->SetPaperRectPixels(wxRect(0, 0, m_pageWidth, m_pageHeight));
-
-        // At 100%, the page should look about page-size on the screen.
-        m_previewScaleX = (float)0.8 * 72.0 / (float)wxGnomePrintDC::GetResolution();
-        m_previewScaleY = m_previewScaleX;
-    }
-}
-
-#endif
-    // wxUSE_LIBGNOMEPRINT
diff -aburN ../original/src/gtk/print.cpp ./src/gtk/print.cpp
--- ../original/src/gtk/print.cpp	1970-01-01 01:00:00.000000000 +0100
+++ ./src/gtk/print.cpp	2007-08-26 16:13:36.000000000 +0200
@@ -0,0 +1,2273 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/gtk/print.cpp
+// Author:      Anthony Bretaudeau
+// Purpose:     GTK printing support
+// Created:     2007-08-25
+// RCS-ID:      $Id: print.cpp,v 1 2007-08-25 05:44:44 PC Exp $
+// Copyright:   (c) 2007 wxWidgets development team
+// Licence:     wxWindows Licence
+/////////////////////////////////////////////////////////////////////////////
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+
+#include "wx/gtk/print.h"
+
+#ifndef WX_PRECOMP
+#include "wx/log.h"
+#include "wx/dcmemory.h"
+#include "wx/icon.h"
+#include "wx/math.h"
+#include "wx/image.h"
+#include "wx/module.h"
+#endif
+
+#include "wx/fontutil.h"
+#include "wx/gtk/private.h"
+#include "wx/dynlib.h"
+#include "wx/paper.h"
+#include "wx/rawbmp.h"
+
+#include <gtk/gtk.h>
+#include <gtk/gtkpagesetupunixdialog.h>
+
+
+// Usefull to convert angles from/to Rad to/from Deg.
+static const double RAD2DEG  = 180.0 / M_PI;
+static const double DEG2RAD  = M_PI / 180.0;
+
+// We use it to pass usefull objets to gtk printing callback functions.
+typedef struct
+{
+   wxGtkPrinter * printer;
+   wxPrintout * printout;
+}
+wxPrinterToGtkData;
+
+// Callback functions for Gtk Printings.
+extern "C"
+{
+    static void gtk_begin_print_callback (GtkPrintOperation *operation, GtkPrintContext *context, gpointer user_data)
+    {
+        wxPrinterToGtkData *data = (wxPrinterToGtkData *) user_data;
+
+        data->printer->BeginPrint(data->printout, operation, context);
+    }
+
+    static void gtk_draw_page_print_callback (GtkPrintOperation *operation, GtkPrintContext *context, gint page_nr, gpointer user_data)
+    {
+        wxPrinterToGtkData *data = (wxPrinterToGtkData *) user_data;
+
+        data->printer->DrawPage(data->printout, operation, context, page_nr);
+    }
+
+    static void gtk_end_print_callback (GtkPrintOperation *operation, GtkPrintContext *context, gpointer user_data)
+    {
+        wxPrintout *printout = (wxPrintout *) user_data;
+
+        printout->OnEndPrinting();
+    }
+
+    static gboolean gtk_preview_print_callback (GtkPrintOperation *operation, GtkPrintOperationPreview *preview, GtkPrintContext *context, GtkWindow *parent, gpointer user_data)
+    {
+        wxPrintout *printout = (wxPrintout *) user_data;
+
+        printout->SetIsPreview(true);
+
+        /* We create a cairo context with 72dpi resolution. This resolution is only used for positionning. */
+        cairo_t *cairo = gdk_cairo_create(GTK_WIDGET(parent)->window);
+        gtk_print_context_set_cairo_context(context, cairo, 72, 72);
+
+        return false;
+    }
+}
+
+
+//----------------------------------------------------------------------------
+// wxGtkPrintNativeData
+//----------------------------------------------------------------------------
+
+IMPLEMENT_CLASS(wxGtkPrintNativeData, wxPrintNativeDataBase)
+
+wxGtkPrintNativeData::wxGtkPrintNativeData()
+{
+    m_config = gtk_print_settings_new();
+}
+
+wxGtkPrintNativeData::~wxGtkPrintNativeData()
+{
+    g_object_unref (m_config);
+}
+
+// Convert datas stored in m_config to a wxPrintData.
+// Called by wxPrintData::ConvertFromNative().
+bool wxGtkPrintNativeData::TransferTo( wxPrintData &data )
+{
+    if(!m_config)
+        return false;
+
+    GtkPrintQuality quality = gtk_print_settings_get_quality(m_config);
+    if (quality == GTK_PRINT_QUALITY_HIGH)
+        data.SetQuality(wxPRINT_QUALITY_HIGH);
+    else if (quality == GTK_PRINT_QUALITY_LOW)
+        data.SetQuality(wxPRINT_QUALITY_LOW);
+    else if (quality == GTK_PRINT_QUALITY_DRAFT)
+        data.SetQuality(wxPRINT_QUALITY_DRAFT);
+    else
+        data.SetQuality(wxPRINT_QUALITY_MEDIUM);
+
+    data.SetNoCopies(gtk_print_settings_get_n_copies(m_config));
+
+    data.SetColour(gtk_print_settings_get_use_color(m_config));
+
+    switch (gtk_print_settings_get_duplex(m_config))
+    {
+        case GTK_PRINT_DUPLEX_SIMPLEX:      data.SetDuplex (wxDUPLEX_SIMPLEX);
+                                            break;
+
+        case GTK_PRINT_DUPLEX_HORIZONTAL:   data.SetDuplex (wxDUPLEX_HORIZONTAL);
+                                            break;
+
+        default:
+        case GTK_PRINT_DUPLEX_VERTICAL:      data.SetDuplex (wxDUPLEX_VERTICAL);
+                                            break;
+    }
+
+    GtkPageOrientation orientation = gtk_print_settings_get_orientation (m_config);
+    if (orientation == GTK_PAGE_ORIENTATION_PORTRAIT)
+    {
+        data.SetOrientation(wxPORTRAIT);
+        data.SetOrientationReversed(false);
+    }
+    else if (orientation == GTK_PAGE_ORIENTATION_LANDSCAPE)
+    {
+        data.SetOrientation(wxLANDSCAPE);
+        data.SetOrientationReversed(false);
+    }
+    else if (orientation == GTK_PAGE_ORIENTATION_REVERSE_PORTRAIT)
+    {
+        data.SetOrientation(wxPORTRAIT);
+        data.SetOrientationReversed(true);
+    }
+    else if (orientation == GTK_PAGE_ORIENTATION_REVERSE_LANDSCAPE)
+    {
+        data.SetOrientation(wxLANDSCAPE);
+        data.SetOrientationReversed(true);
+    }
+
+    data.SetCollate(gtk_print_settings_get_collate (m_config));
+
+    // Paper formats : these are the most common paper formats.
+    GtkPaperSize *paper_size = gtk_print_settings_get_paper_size (m_config);
+    if (!paper_size)
+        data.SetPaperId(wxPAPER_NONE);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new (GTK_PAPER_NAME_A3)))
+        data.SetPaperId(wxPAPER_A3);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new (GTK_PAPER_NAME_A4)))
+        data.SetPaperId(wxPAPER_A4);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new (GTK_PAPER_NAME_A5)))
+        data.SetPaperId(wxPAPER_A5);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new (GTK_PAPER_NAME_B5)))
+        data.SetPaperId(wxPAPER_B5);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new (GTK_PAPER_NAME_LETTER)))
+        data.SetPaperId(wxPAPER_LETTER);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new (GTK_PAPER_NAME_LEGAL)))
+        data.SetPaperId(wxPAPER_LEGAL);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new (GTK_PAPER_NAME_EXECUTIVE)))
+        data.SetPaperId(wxPAPER_EXECUTIVE);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"na_number-10")))
+        data.SetPaperId(wxPAPER_ENV_10);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"iso-c5")))
+        data.SetPaperId(wxPAPER_ENV_C5);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"iso-c6")))
+        data.SetPaperId(wxPAPER_ENV_C6);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"jis-b5")))
+        data.SetPaperId(wxPAPER_B5_TRANSVERSE);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"iso-b5")))
+        data.SetPaperId(wxPAPER_ENV_B5);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"na_monarch")))
+        data.SetPaperId(wxPAPER_ENV_MONARCH);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"engineering-c")))
+        data.SetPaperId( wxPAPER_CSHEET);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"engineering-d")))
+        data.SetPaperId( wxPAPER_DSHEET);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"engineering-e")))
+        data.SetPaperId( wxPAPER_ESHEET);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"letter")))
+        data.SetPaperId( wxPAPER_LETTERSMALL);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"engineering-b")))
+        data.SetPaperId( wxPAPER_TABLOID);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"ledger")))
+        data.SetPaperId( wxPAPER_LEDGER);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"statement")))
+        data.SetPaperId( wxPAPER_STATEMENT);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( GTK_PAPER_NAME_A4 )))
+        data.SetPaperId( wxPAPER_A4SMALL);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"iso-b4")))
+        data.SetPaperId( wxPAPER_B4);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"folio")))
+        data.SetPaperId( wxPAPER_FOLIO);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"quarto")))
+        data.SetPaperId( wxPAPER_QUARTO);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"10x14")))
+        data.SetPaperId( wxPAPER_10X14);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"ledger")))
+        data.SetPaperId( wxPAPER_11X17);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"letter")))
+        data.SetPaperId( wxPAPER_NOTE);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"na-number-9-envelope")))
+        data.SetPaperId( wxPAPER_ENV_9);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"number-11")))
+        data.SetPaperId( wxPAPER_ENV_11);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"number-12")))
+        data.SetPaperId( wxPAPER_ENV_12);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"number-14")))
+        data.SetPaperId( wxPAPER_ENV_14);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"iso-designated")))
+        data.SetPaperId( wxPAPER_ENV_DL);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"iso-c3")))
+        data.SetPaperId( wxPAPER_ENV_C3);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"iso-c4")))
+        data.SetPaperId( wxPAPER_ENV_C4);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"c6/c5")))
+        data.SetPaperId( wxPAPER_ENV_C65);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"iso-b4")))
+        data.SetPaperId( wxPAPER_ENV_B4);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"iso-b6")))
+            data.SetPaperId( wxPAPER_ENV_B6);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"Italian")))
+        data.SetPaperId( wxPAPER_ENV_ITALY);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"personal")))
+        data.SetPaperId( wxPAPER_ENV_PERSONAL);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"fanfold-us")))
+        data.SetPaperId( wxPAPER_FANFOLD_US);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"fanfold-European")))
+        data.SetPaperId( wxPAPER_FANFOLD_STD_GERMAN);
+    else if (gtk_paper_size_is_equal(paper_size,gtk_paper_size_new ( (const gchar*)"foolscap")))
+        data.SetPaperId( wxPAPER_FANFOLD_LGL_GERMAN);
+    else
+        data.SetPaperId(wxPAPER_NONE);
+    return true;
+}
+
+// Put datas given by the wxPrintData into m_config.
+// Called by wxPrintData::ConvertToNative().
+bool wxGtkPrintNativeData::TransferFrom( const wxPrintData &data )
+{
+    if(!m_config)
+        return false;
+
+    wxPrintQuality quality = data.GetQuality();
+    if (quality == wxPRINT_QUALITY_HIGH)
+        gtk_print_settings_set_quality (m_config, GTK_PRINT_QUALITY_HIGH);
+    else if (quality == wxPRINT_QUALITY_MEDIUM)
+        gtk_print_settings_set_quality (m_config, GTK_PRINT_QUALITY_NORMAL);
+    else if (quality == wxPRINT_QUALITY_LOW)
+        gtk_print_settings_set_quality (m_config, GTK_PRINT_QUALITY_LOW);
+    else if (quality == wxPRINT_QUALITY_DRAFT)
+        gtk_print_settings_set_quality (m_config, GTK_PRINT_QUALITY_DRAFT);
+    else if (quality > 1)
+        gtk_print_settings_set_resolution (m_config, quality);
+    else
+        gtk_print_settings_set_quality (m_config, GTK_PRINT_QUALITY_NORMAL);
+
+    gtk_print_settings_set_n_copies(m_config, data.GetNoCopies());
+
+    gtk_print_settings_set_use_color(m_config, data.GetColour());
+
+    switch (data.GetDuplex())
+    {
+        case wxDUPLEX_SIMPLEX:      gtk_print_settings_set_duplex (m_config, GTK_PRINT_DUPLEX_SIMPLEX);
+                                break;
+
+        case wxDUPLEX_HORIZONTAL:   gtk_print_settings_set_duplex (m_config, GTK_PRINT_DUPLEX_HORIZONTAL);
+                                break;
+
+        default:
+        case wxDUPLEX_VERTICAL:      gtk_print_settings_set_duplex (m_config, GTK_PRINT_DUPLEX_VERTICAL);
+                                break;
+    }
+
+    if (!data.IsOrientationReversed())
+    {
+        if (data.GetOrientation() == wxLANDSCAPE)
+            gtk_print_settings_set_orientation (m_config, GTK_PAGE_ORIENTATION_LANDSCAPE);
+        else
+            gtk_print_settings_set_orientation (m_config, GTK_PAGE_ORIENTATION_PORTRAIT);
+    }
+    else {
+        if (data.GetOrientation() == wxLANDSCAPE)
+            gtk_print_settings_set_orientation (m_config, GTK_PAGE_ORIENTATION_REVERSE_LANDSCAPE);
+        else
+            gtk_print_settings_set_orientation (m_config, GTK_PAGE_ORIENTATION_REVERSE_PORTRAIT);
+    }
+
+    gtk_print_settings_set_collate (m_config, data.GetCollate());
+
+    // Paper formats: these are the most common paper formats.
+    switch (data.GetPaperId())
+    {
+        case wxPAPER_A3:        gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new (GTK_PAPER_NAME_A3));
+                                break;
+        case wxPAPER_A4:        gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new (GTK_PAPER_NAME_A4));
+                                break;
+        case wxPAPER_A5:        gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new (GTK_PAPER_NAME_A5));
+                                break;
+        case wxPAPER_B5_TRANSVERSE:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "jis-b5"));
+                                break;
+        case wxPAPER_B5:        gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new (GTK_PAPER_NAME_B5));
+                                break;
+        case wxPAPER_LETTER:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new (GTK_PAPER_NAME_LETTER));
+                                break;
+        case wxPAPER_LEGAL:     gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new (GTK_PAPER_NAME_LEGAL));
+                                break;
+        case wxPAPER_EXECUTIVE: gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new (GTK_PAPER_NAME_EXECUTIVE));
+                                break;
+        case wxPAPER_ENV_10:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "na_number-10"));
+                                break;
+        case wxPAPER_ENV_C5:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "iso-c5"));
+                                break;
+        case wxPAPER_ENV_C6:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "iso-c6"));
+                                break;
+        case wxPAPER_ENV_B5:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "iso-c5b5"));
+                                break;
+        case wxPAPER_ENV_MONARCH:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "na_monarch"));
+                                break;
+        case wxPAPER_CSHEET:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "engineering-c"));
+                                break;
+        case wxPAPER_DSHEET:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "engineering-d"));
+                                break;
+        case wxPAPER_ESHEET:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "engineering-e"));
+                                break;
+        case wxPAPER_LETTERSMALL:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "letter"));
+                                break;
+        case wxPAPER_TABLOID:   gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "engineering-b"));
+                                break;
+        case wxPAPER_LEDGER:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "ledger"));
+                                break;
+        case wxPAPER_STATEMENT:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "statement"));
+                                break;
+        case wxPAPER_A4SMALL:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new (GTK_PAPER_NAME_A4));
+                                break;
+        case wxPAPER_B4:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "iso-b4"));
+                                break;
+        case wxPAPER_FOLIO:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "folio"));
+                                break;
+        case wxPAPER_QUARTO:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "quarto"));
+                                break;
+        case wxPAPER_10X14:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "10x14"));
+                                break;
+        case wxPAPER_11X17:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "ledger"));
+                                break;
+        case wxPAPER_NOTE:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "letter"));
+                                break;
+        case wxPAPER_ENV_9:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "na-number-9-envelope"));
+                                break;
+        case wxPAPER_ENV_11:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "number-11"));
+                                break;
+        case wxPAPER_ENV_12:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "number-12"));
+                                break;
+        case wxPAPER_ENV_14:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "number-14"));
+                                break;
+        case wxPAPER_ENV_DL:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "iso-designated"));
+                                break;
+        case wxPAPER_ENV_C3:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "iso-c3"));
+                                break;
+        case wxPAPER_ENV_C4:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "iso-c4"));
+                                break;
+        case wxPAPER_ENV_C65:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "c6/c5"));
+                                break;
+        case wxPAPER_ENV_B4:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "iso-b4"));
+                                break;
+        case wxPAPER_ENV_B6:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "iso-b6"));
+                                break;
+        case wxPAPER_ENV_ITALY:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "Italian"));
+                                break;
+        case wxPAPER_ENV_PERSONAL:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "personal"));
+                                break;
+        case wxPAPER_FANFOLD_US:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "fanfold-us"));
+                                break;
+        case wxPAPER_FANFOLD_STD_GERMAN:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "fanfold-European"));
+                                break;
+        case wxPAPER_FANFOLD_LGL_GERMAN:    gtk_print_settings_set_paper_size(m_config, gtk_paper_size_new ((const gchar*) "foolscap"));
+                                break;
+        case wxPAPER_NONE:
+        default:                break;
+    }
+
+    return true;
+}
+
+void wxGtkPrintNativeData::SetPrintConfig( GtkPrintSettings * config )
+{
+    if (config)
+        m_config = gtk_print_settings_copy(config);
+}
+
+// Extract page setup from settings.
+GtkPageSetup* wxGtkPrintNativeData::GetPageSetupFromSettings(GtkPrintSettings* settings)
+{
+    GtkPageSetup* page_setup = gtk_page_setup_new();
+	gtk_page_setup_set_orientation (page_setup, gtk_print_settings_get_orientation (settings));
+
+	GtkPaperSize *paper_size = gtk_print_settings_get_paper_size (settings);
+	if (paper_size != NULL)
+		gtk_page_setup_set_paper_size_and_default_margins (page_setup, paper_size);
+
+    return page_setup;
+}
+
+// Insert page setup into a given GtkPrintSettings.
+void wxGtkPrintNativeData::SetPageSetupToSettings(GtkPrintSettings* settings, GtkPageSetup* page_setup)
+{
+    gtk_print_settings_set_orientation ( settings, gtk_page_setup_get_orientation (page_setup));
+	gtk_print_settings_set_paper_size ( settings, gtk_page_setup_get_paper_size (page_setup));
+}
+
+//----------------------------------------------------------------------------
+// wxGtkPrintDialog
+//----------------------------------------------------------------------------
+
+IMPLEMENT_CLASS(wxGtkPrintDialog, wxPrintDialogBase)
+
+wxGtkPrintDialog::wxGtkPrintDialog( wxWindow *parent, wxPrintDialogData *data )
+                    : wxPrintDialogBase(parent, wxID_ANY, _("Print"),
+                               wxPoint(0, 0), wxSize(600, 600),
+                               wxDEFAULT_DIALOG_STYLE |
+                               wxTAB_TRAVERSAL)
+{
+    if (data)
+        m_printDialogData = *data;
+
+    m_parent = parent;
+    SetShowDialog(true);
+}
+
+wxGtkPrintDialog::wxGtkPrintDialog( wxWindow *parent, wxPrintData *data )
+                    : wxPrintDialogBase(parent, wxID_ANY, _("Print"),
+                               wxPoint(0, 0), wxSize(600, 600),
+                               wxDEFAULT_DIALOG_STYLE |
+                               wxTAB_TRAVERSAL)
+{
+    if (data)
+        m_printDialogData = *data;
+
+    m_parent = parent;
+    SetShowDialog(true);
+}
+
+
+wxGtkPrintDialog::~wxGtkPrintDialog()
+{
+}
+
+// This is called even if we actually don't want the dialog to appear.
+int wxGtkPrintDialog::ShowModal()
+{
+    GtkPrintOperationResult response;
+
+    // We need to restore the settings given in the constructor.
+    wxPrintData data = m_printDialogData.GetPrintData();
+    wxGtkPrintNativeData *native =
+      (wxGtkPrintNativeData*) data.GetNativeData();
+    data.ConvertToNative();
+
+    GtkPrintSettings * settings = native->GetPrintConfig();
+
+    // We have to restore pages to print here because they're stored in a wxPrintDialogData and ConvertToNative only works for wxPrintData.
+    int fromPage = m_printDialogData.GetFromPage();
+    int toPage = m_printDialogData.GetToPage();
+    if (m_printDialogData.GetSelection())
+        gtk_print_settings_set_print_pages(settings, GTK_PRINT_PAGES_CURRENT);
+    else if (m_printDialogData.GetAllPages())
+        gtk_print_settings_set_print_pages(settings, GTK_PRINT_PAGES_ALL);
+    else {
+        gtk_print_settings_set_print_pages(settings, GTK_PRINT_PAGES_RANGES);
+        GtkPageRange *range;
+        range = g_new (GtkPageRange, 1);
+        range[0].start = fromPage-1;
+        range[0].end = (toPage >= fromPage) ? toPage-1 : fromPage-1;
+        gtk_print_settings_set_page_ranges (settings, range, 1);
+    }
+
+    // If the settings are OK, we restore it.
+    if (settings != NULL)
+        gtk_print_operation_set_print_settings (native->GetPrintJob(), settings);
+        gtk_print_operation_set_default_page_setup (native->GetPrintJob(), native->GetPageSetupFromSettings(settings));
+
+    // Show the dialog if needed.
+    GError* gError = NULL;
+    if (GetShowDialog())
+        response = gtk_print_operation_run (native->GetPrintJob(), GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG, GTK_WINDOW(gtk_widget_get_toplevel(m_parent->m_widget) ), &gError);
+    else
+        response = gtk_print_operation_run (native->GetPrintJob(), GTK_PRINT_OPERATION_ACTION_PRINT, (GtkWindow *) m_parent, &gError);
+
+    // Does everything went well?
+    if (response == GTK_PRINT_OPERATION_RESULT_CANCEL)
+    {
+        return wxID_CANCEL;
+    }
+    else if (response == GTK_PRINT_OPERATION_RESULT_ERROR)
+    {
+        g_error_free (gError);
+        wxLogError(_("Error while printing: ") + wxString::Format(_("%s"), gError->message));
+        return wxID_NO; // We use wxID_NO because there is no wxID_ERROR available
+    }
+
+    // Now get the settings and save it.
+    GtkPrintSettings* newSettings = gtk_print_operation_get_print_settings (native->GetPrintJob());
+    native->SetPrintConfig(newSettings);
+    data.ConvertFromNative();
+
+    // Same problem as a few lines before.
+    switch (gtk_print_settings_get_print_pages(newSettings))
+    {
+        case GTK_PRINT_PAGES_CURRENT:
+            m_printDialogData.SetSelection( true );
+            break;
+        case GTK_PRINT_PAGES_ALL:
+            m_printDialogData.SetAllPages( true );
+            m_printDialogData.SetFromPage( 0 );
+            m_printDialogData.SetToPage( 9999 );
+            break;
+        case GTK_PRINT_PAGES_RANGES:
+        default:
+            // wxWidgets doesn't support multiple ranges, so we can only save the first one even if the user wants to print others.
+            // For example, the user enters "1-3;5-7" in the dialog: pages 1-3 and 5-7 will be correctly printed when the user
+            // will hit "OK" button. However we can only save 1-3 in the print data.
+            gint num_ranges = 0;
+            GtkPageRange* range;
+            range = gtk_print_settings_get_page_ranges (newSettings, &num_ranges);
+            m_printDialogData.SetFromPage( range[0].start );
+            m_printDialogData.SetToPage( range[0].end );
+            break;
+    }
+
+    return wxID_OK;
+}
+
+//----------------------------------------------------------------------------
+// wxGtkPageSetupDialog
+//----------------------------------------------------------------------------
+
+IMPLEMENT_CLASS(wxGtkPageSetupDialog, wxPageSetupDialogBase)
+
+wxGtkPageSetupDialog::wxGtkPageSetupDialog( wxWindow *parent,
+                            wxPageSetupDialogData* data )
+{
+    if (data)
+        m_pageDialogData = *data;
+
+    m_parent = parent;
+}
+
+wxGtkPageSetupDialog::~wxGtkPageSetupDialog()
+{
+}
+
+int wxGtkPageSetupDialog::ShowModal()
+{
+    // Get the config.
+    m_pageDialogData.GetPrintData().ConvertToNative();
+    wxGtkPrintNativeData *native = (wxGtkPrintNativeData*) m_pageDialogData.GetPrintData().GetNativeData();
+    GtkPrintSettings* nativeData = native->GetPrintConfig();
+
+    // We only need the pagesetup data which are part of the settings.
+    GtkPageSetup* oldPageSetup = native->GetPageSetupFromSettings(nativeData);
+
+    // If the user used a custom paper format the last time he printed, we have to restore it too.
+    if (m_pageDialogData.GetPrintData().GetPaperId() == wxPAPER_NONE)
+    {
+        wxSize customPaperSize = m_pageDialogData.GetPaperSize();
+        if (customPaperSize.GetWidth() > 0 && customPaperSize.GetHeight() > 0)
+        {
+            wxString title = _("Custom size");
+            GtkPaperSize* customSize = gtk_paper_size_new_custom ("custom", title.mb_str(), (gdouble) customPaperSize.GetWidth(), (gdouble) customPaperSize.GetHeight(), GTK_UNIT_MM);
+            gtk_page_setup_set_paper_size_and_default_margins (oldPageSetup, customSize);
+            g_object_unref(customSize);
+        }
+    }
+
+    // Now show the dialog.
+    GtkPageSetup* newPageSetup = gtk_print_run_page_setup_dialog ((GtkWindow *) m_parent,
+                                                           oldPageSetup,
+                                                           nativeData);
+
+    int ret;
+    if (newPageSetup != oldPageSetup)
+    {
+        native->SetPageSetupToSettings(nativeData, newPageSetup);
+        m_pageDialogData.GetPrintData().ConvertFromNative();
+
+        // Store custom paper format if any.
+        if (m_pageDialogData.GetPrintData().GetPaperId() == wxPAPER_NONE)
+        {
+            gdouble ml,mr,mt,mb,pw,ph;
+            ml = gtk_page_setup_get_left_margin (newPageSetup, GTK_UNIT_MM);
+            mr = gtk_page_setup_get_right_margin (newPageSetup, GTK_UNIT_MM);
+            mt = gtk_page_setup_get_top_margin (newPageSetup, GTK_UNIT_MM);
+            mb = gtk_page_setup_get_bottom_margin (newPageSetup, GTK_UNIT_MM);
+
+            pw = gtk_page_setup_get_paper_width (newPageSetup, GTK_UNIT_MM);
+            ph = gtk_page_setup_get_paper_height (newPageSetup, GTK_UNIT_MM);
+
+            m_pageDialogData.SetMarginTopLeft( wxPoint( (int)(ml+0.5), (int)(mt+0.5)) );
+            m_pageDialogData.SetMarginBottomRight( wxPoint( (int)(mr+0.5), (int)(mb+0.5)) );
+
+            m_pageDialogData.SetPaperSize( wxSize( (int)(pw+0.5), (int)(ph+0.5) ) );
+        }
+
+        ret = wxID_OK;
+    }
+    else
+    {
+        ret = wxID_CANCEL;
+    }
+
+    return ret;
+}
+
+//----------------------------------------------------------------------------
+// wxGtkPrinter
+//----------------------------------------------------------------------------
+
+IMPLEMENT_CLASS(wxGtkPrinter, wxPrinterBase)
+
+wxGtkPrinter::wxGtkPrinter( wxPrintDialogData *data ) :
+    wxPrinterBase( data )
+{
+    m_gpc = NULL;
+
+    if (data)
+        m_printDialogData = *data;
+}
+
+wxGtkPrinter::~wxGtkPrinter()
+{
+}
+
+bool wxGtkPrinter::Print(wxWindow *parent, wxPrintout *printout, bool prompt )
+{
+    if (!printout)
+    {
+        sm_lastError = wxPRINTER_ERROR;
+        return false;
+    }
+
+    // Let's correct the PageInfo just in case the app gives wrong values.
+    int fromPage, toPage;
+    int minPage, maxPage;
+    printout->GetPageInfo(&minPage, &maxPage, &fromPage, &toPage);
+    m_printDialogData.SetAllPages(true);
+
+    if (minPage < 1) minPage = 1;
+    if (maxPage < 1) maxPage = 9999;
+    if (maxPage < minPage) maxPage = minPage;
+
+    m_printDialogData.SetMinPage(minPage);
+    m_printDialogData.SetMaxPage(maxPage);
+    if (fromPage != 0)
+    {
+        if (fromPage < minPage) fromPage = minPage;
+        else if (fromPage > maxPage) fromPage = maxPage;
+        m_printDialogData.SetFromPage(fromPage);
+    }
+    if (toPage != 0)
+    {
+        m_printDialogData.SetToPage(toPage);
+        if (toPage > maxPage) toPage = maxPage;
+        else if (toPage < minPage) toPage = minPage;
+    }
+
+    if (((minPage != fromPage) && fromPage != 0) || ((maxPage != toPage) && toPage != 0)) m_printDialogData.SetAllPages(false);
+
+
+    wxPrintData printdata = GetPrintDialogData().GetPrintData();
+    wxGtkPrintNativeData *native = (wxGtkPrintNativeData*) printdata.GetNativeData();
+
+    GtkPrintOperation *printOp = gtk_print_operation_new ();
+
+    native->SetPrintJob( printOp );
+
+    printout->SetIsPreview(false);
+
+    wxPrinterToGtkData dataToSend;
+    dataToSend.printer = this;
+    dataToSend.printout = printout;
+
+    // These Gtk signals are catched here.
+    g_signal_connect (printOp, "begin-print", G_CALLBACK (gtk_begin_print_callback), &dataToSend);
+    g_signal_connect (printOp, "draw-page", G_CALLBACK (gtk_draw_page_print_callback), &dataToSend);
+    g_signal_connect (printOp, "end-print", G_CALLBACK (gtk_end_print_callback), printout);
+    g_signal_connect (printOp, "preview", G_CALLBACK (gtk_preview_print_callback), printout);
+
+    m_showDialog = true;
+    if (!prompt)
+        m_showDialog = false;
+
+    // PrintDialog returns a wxDC but we created it before so we don't need it anymore: we just delete it.
+    wxDC* uselessdc = PrintDialog( parent );
+    delete uselessdc;
+
+    g_object_unref (printOp);
+
+    return (sm_lastError == wxPRINTER_NO_ERROR);
+}
+
+void wxGtkPrinter::BeginPrint(wxPrintout *printout, GtkPrintOperation *operation, GtkPrintContext *context)
+{
+    wxPrintData printdata = GetPrintDialogData().GetPrintData();
+    wxGtkPrintNativeData *native = (wxGtkPrintNativeData*) printdata.GetNativeData();
+
+    SetPrintContext(context);
+    native->SetPrintContext( context );
+
+    m_dc = new wxGtkPrintDC( printdata );
+
+    if (!m_dc->IsOk())
+    {
+        if (sm_lastError != wxPRINTER_CANCELLED)
+        {
+            sm_lastError = wxPRINTER_ERROR;
+            wxFAIL_MSG(_("The wxGtkPrintDC cannot be used."));
+        }
+        return;
+    }
+    wxSize ScreenPixels = wxGetDisplaySize();
+    wxSize ScreenMM = wxGetDisplaySizeMM();
+
+    printout->SetPPIScreen( (int) ((ScreenPixels.GetWidth() * 25.4) / ScreenMM.GetWidth()),
+                            (int) ((ScreenPixels.GetHeight() * 25.4) / ScreenMM.GetHeight()) );
+    printout->SetPPIPrinter( wxGtkPrintDC::GetResolution(),
+                             wxGtkPrintDC::GetResolution() );
+
+    printout->SetDC(m_dc);
+
+    int w, h;
+    m_dc->GetSize(&w, &h);
+    printout->SetPageSizePixels((int)w, (int)h);
+    printout->SetPaperRectPixels(wxRect(0, 0, w, h));
+    int mw, mh;
+    m_dc->GetSizeMM(&mw, &mh);
+    printout->SetPageSizeMM((int)mw, (int)mh);
+    printout->OnPreparePrinting();
+
+    // Get some parameters from the printout, if defined.
+    int fromPage, toPage;
+    int minPage, maxPage;
+    printout->GetPageInfo(&minPage, &maxPage, &fromPage, &toPage);
+
+    if (maxPage == 0)
+    {
+        sm_lastError = wxPRINTER_ERROR;
+        wxFAIL_MSG(_("wxPrintout::GetPageInfo gives a null maxPage."));
+        return;
+    }
+
+    printout->OnBeginPrinting();
+
+    int numPages = 0;
+
+    // If we're not previewing we need to calculate the number of pages to print.
+    // If we're previewing, Gtk Print will render every pages without wondering about the page ranges the user may
+    // have defined in the dialog. So the number of pages is the maximum available.
+    if (!printout->IsPreview())
+    {
+        GtkPrintSettings * settings = gtk_print_operation_get_print_settings (operation);
+        switch (gtk_print_settings_get_print_pages(settings))
+        {
+            case GTK_PRINT_PAGES_CURRENT:
+                numPages = 1;
+                break;
+            case GTK_PRINT_PAGES_RANGES:
+                {gint num_ranges = 0;
+                GtkPageRange* range;
+                int i;
+                range = gtk_print_settings_get_page_ranges (settings, &num_ranges);
+                for (i=0; i<num_ranges; i++)
+                {
+                    if (range[i].end < range[i].start) range[i].end = range[i].start;
+                    if (range[i].start < minPage-1) range[i].start = minPage-1;
+                    if (range[i].end > maxPage-1) range[i].end = maxPage-1;
+                    if (range[i].start > maxPage-1) range[i].start = maxPage-1;
+                    numPages += range[i].end - range[i].start + 1;
+                }
+                gtk_print_settings_set_page_ranges (settings, range, 1);
+                break;}
+            case GTK_PRINT_PAGES_ALL:
+            default:
+                numPages = maxPage - minPage + 1;
+                break;
+        }
+    }
+    else numPages = maxPage - minPage + 1;
+
+    gtk_print_operation_set_n_pages(operation, numPages);
+}
+
+void wxGtkPrinter::DrawPage(wxPrintout *printout, GtkPrintOperation *operation, GtkPrintContext *context, int page_nr)
+{
+    int fromPage, toPage, minPage, maxPage, startPage, endPage;
+    printout->GetPageInfo(&minPage, &maxPage, &fromPage, &toPage);
+
+    int numPageToDraw = page_nr + minPage;
+    if (numPageToDraw < minPage) numPageToDraw = minPage;
+    if (numPageToDraw > maxPage) numPageToDraw = maxPage;
+
+    GtkPrintSettings * settings = gtk_print_operation_get_print_settings (operation);
+    switch (gtk_print_settings_get_print_pages(settings))
+    {
+        case GTK_PRINT_PAGES_CURRENT:
+            g_object_get_property((GObject*) operation, (const gchar *) "current-page", (GValue*) &startPage);
+            g_object_get_property((GObject*) operation, (const gchar *) "current-page", (GValue*) &endPage);
+            break;
+        case GTK_PRINT_PAGES_RANGES:
+            {gint num_ranges = 0;
+            GtkPageRange* range;
+            range = gtk_print_settings_get_page_ranges (settings, &num_ranges);
+            // We don't need to verify these values as it has already been done in wxGtkPrinter::BeginPrint.
+            startPage = range[0].start + 1;
+            endPage = range[0].end + 1;
+            break;}
+        case GTK_PRINT_PAGES_ALL:
+        default:
+            startPage = minPage;
+            endPage = maxPage;
+            break;
+    }
+
+    if(numPageToDraw == startPage)
+    {
+        if (!printout->OnBeginDocument(startPage, endPage))
+        {
+            wxLogError(_("Could not start printing."));
+            sm_lastError = wxPRINTER_ERROR;
+        }
+    }
+
+    // The app can render the page numPageToDraw.
+    if (printout->HasPage(numPageToDraw))
+    {
+        m_dc->StartPage();
+        printout->OnPrintPage(numPageToDraw);
+        m_dc->EndPage();
+    }
+
+
+    if(numPageToDraw == endPage)
+    {
+        printout->OnEndDocument();
+    }
+}
+
+wxDC* wxGtkPrinter::PrintDialog( wxWindow *parent )
+{
+    wxGtkPrintDialog dialog( parent, &m_printDialogData );
+    int ret;
+
+    dialog.SetPrintDC(m_dc);
+
+    dialog.SetShowDialog(m_showDialog);
+
+    ret = dialog.ShowModal();
+
+    if (ret == wxID_CANCEL)
+    {
+        sm_lastError = wxPRINTER_CANCELLED;
+        return NULL;
+    }
+    if (ret == wxID_NO)
+    {
+        sm_lastError = wxPRINTER_ERROR;
+        wxFAIL_MSG(_("The print dialog returned an error."));
+        return NULL;
+    }
+
+    m_printDialogData = dialog.GetPrintDialogData();
+    return new wxGtkPrintDC( m_printDialogData.GetPrintData() );
+}
+
+bool wxGtkPrinter::Setup( wxWindow *parent )
+{
+    // Obsolete, for backward compatibility.
+    return false;
+}
+
+//-----------------------------------------------------------------------------
+// wxGtkPrintDC
+//-----------------------------------------------------------------------------
+
+IMPLEMENT_CLASS(wxGtkPrintDC, wxDC)
+
+// Define the default resolution for this DC. This resolution is just used for positioning as the cairo context is scalable.
+int wxGtkPrintDC::ms_resolution = 72;
+
+wxGtkPrintDC::wxGtkPrintDC( const wxPrintData& data )
+{
+    m_printData = data;
+
+    wxGtkPrintNativeData *native =
+        (wxGtkPrintNativeData*) m_printData.GetNativeData();
+
+    m_gpc = native->GetPrintContext();
+
+    ms_resolution = (int) gtk_print_context_get_dpi_x(m_gpc);
+    m_context = gtk_print_context_create_pango_context( m_gpc );
+    m_layout = gtk_print_context_create_pango_layout ( m_gpc );
+    m_fontdesc = pango_font_description_from_string( "Sans 12" );
+
+    m_cairo = gtk_print_context_get_cairo_context ( m_gpc );
+
+    m_currentRed = 0;
+    m_currentBlue = 0;
+    m_currentGreen = 0;
+
+    m_signX =  1;  // default x-axis left to right.
+    m_signY = 1;  // default y-axis bottom up -> top down.
+
+    GetSize( &m_deviceOffsetX, &m_deviceOffsetY );
+}
+
+wxGtkPrintDC::~wxGtkPrintDC()
+{
+    g_object_unref(m_context);
+    g_object_unref(m_layout);
+}
+
+bool wxGtkPrintDC::IsOk() const
+{
+    return true;
+}
+
+void wxGtkPrintDC::ComputeScaleAndOrigin()
+{
+    // Called when the scale and/or origin of the context has to be changed.
+    m_scaleX = m_logicalScaleX * m_userScaleX;
+    m_scaleY = m_logicalScaleY * m_userScaleY;
+
+    cairo_translate(m_cairo, m_deviceOriginX, m_deviceOriginY);
+    cairo_scale(m_cairo, m_scaleX, m_scaleY );
+}
+
+bool wxGtkPrintDC::DoFloodFill(wxCoord x1, wxCoord y1, const wxColour &col, int style )
+{
+    // We can't access the given coord as a cairo context is scalable, ie a coord doesn't mean anything in this context.
+    wxFAIL_MSG(_("not implemented"));
+    return false;
+}
+
+void wxGtkPrintDC::DoGradientFillConcentric(const wxRect& rect, const wxColour& initialColour, const wxColour& destColour, const wxPoint& circleCenter)
+{
+    wxCoord xC = circleCenter.x;
+    wxCoord yC = circleCenter.y;
+    wxCoord xR = rect.x;
+    wxCoord yR = rect.y;
+    wxCoord w =  rect.width;
+    wxCoord h = rect.height;
+
+    double radius = sqrt((w/2)*(w/2)+(h/2)*(h/2));
+
+    unsigned char redI = initialColour.Red();
+    unsigned char blueI = initialColour.Blue();
+    unsigned char greenI = initialColour.Green();
+    unsigned char alphaI = initialColour.Alpha();
+    unsigned char redD = destColour.Red();
+    unsigned char blueD = destColour.Blue();
+    unsigned char greenD = destColour.Green();
+    unsigned char alphaD = destColour.Alpha();
+
+    double redIPS = (double)(redI) / 255.0;
+    double blueIPS = (double)(blueI) / 255.0;
+    double greenIPS = (double)(greenI) / 255.0;
+    double alphaIPS = (double)(alphaI) / 255.0;
+    double redDPS = (double)(redD) / 255.0;
+    double blueDPS = (double)(blueD) / 255.0;
+    double greenDPS = (double)(greenD) / 255.0;
+    double alphaDPS = (double)(alphaD) / 255.0;
+
+    // Create a pattern with the gradient.
+    cairo_pattern_t* gradient;
+    gradient = cairo_pattern_create_radial (LogicalToDeviceX(xC+xR), LogicalToDeviceY(yC+yR), 0, LogicalToDeviceX(xC+xR), LogicalToDeviceY(yC+yR), radius);
+    cairo_pattern_add_color_stop_rgba (gradient, 0.0, redIPS, greenIPS, blueIPS, alphaIPS);
+    cairo_pattern_add_color_stop_rgba (gradient, 1.0, redDPS, greenDPS, blueDPS, alphaDPS);
+
+    // Fill the rectangle with this pattern.
+    cairo_set_source(m_cairo, gradient);
+    cairo_rectangle (m_cairo, LogicalToDeviceX(xR), LogicalToDeviceY(yR), LogicalToDeviceXRel(w), LogicalToDeviceYRel(h) );
+    cairo_fill(m_cairo);
+
+    cairo_pattern_destroy(gradient);
+
+    CalcBoundingBox(xR, yR);
+    CalcBoundingBox(xR+w, yR+h);
+}
+
+void wxGtkPrintDC::DoGradientFillLinear(const wxRect& rect, const wxColour& initialColour, const wxColour& destColour, wxDirection nDirection)
+{
+    wxCoord x = rect.x;
+    wxCoord y = rect.y;
+    wxCoord w = rect.width;
+    wxCoord h = rect.height;
+
+    unsigned char redI = initialColour.Red();
+    unsigned char blueI = initialColour.Blue();
+    unsigned char greenI = initialColour.Green();
+    unsigned char alphaI = initialColour.Alpha();
+    unsigned char redD = destColour.Red();
+    unsigned char blueD = destColour.Blue();
+    unsigned char greenD = destColour.Green();
+    unsigned char alphaD = destColour.Alpha();
+
+    double redIPS = (double)(redI) / 255.0;
+    double blueIPS = (double)(blueI) / 255.0;
+    double greenIPS = (double)(greenI) / 255.0;
+    double alphaIPS = (double)(alphaI) / 255.0;
+    double redDPS = (double)(redD) / 255.0;
+    double blueDPS = (double)(blueD) / 255.0;
+    double greenDPS = (double)(greenD) / 255.0;
+    double alphaDPS = (double)(alphaD) / 255.0;
+
+    // Create a pattern with the gradient.
+    cairo_pattern_t* gradient;
+    gradient = cairo_pattern_create_linear (LogicalToDeviceX(x), LogicalToDeviceY(y), LogicalToDeviceX(x+w), LogicalToDeviceY(y));
+
+    if (nDirection == wxWEST)
+    {
+        cairo_pattern_add_color_stop_rgba (gradient, 0.0, redDPS, greenDPS, blueDPS, alphaDPS);
+        cairo_pattern_add_color_stop_rgba (gradient, 1.0, redIPS, greenIPS, blueIPS, alphaIPS);
+    }
+    else {
+        cairo_pattern_add_color_stop_rgba (gradient, 0.0, redIPS, greenIPS, blueIPS, alphaIPS);
+        cairo_pattern_add_color_stop_rgba (gradient, 1.0, redDPS, greenDPS, blueDPS, alphaDPS);
+    }
+
+    // Fill the rectangle with this pattern.
+    cairo_set_source(m_cairo, gradient);
+    cairo_rectangle (m_cairo, LogicalToDeviceX(x), LogicalToDeviceY(y), LogicalToDeviceXRel(w), LogicalToDeviceYRel(h) );
+    cairo_fill(m_cairo);
+
+    cairo_pattern_destroy(gradient);
+
+    CalcBoundingBox(x, y);
+    CalcBoundingBox(x+w, y+h);
+}
+
+bool wxGtkPrintDC::DoGetPixel(wxCoord x1, wxCoord y1, wxColour *col) const
+{
+    // We can't access the given coord as a cairo context is scalable, ie a coord doesn't mean anything in this context.
+    wxFAIL_MSG(_("not implemented"));
+    return false;
+}
+
+void wxGtkPrintDC::DoDrawLine(wxCoord x1, wxCoord y1, wxCoord x2, wxCoord y2)
+{
+    if  (m_pen.GetStyle() == wxTRANSPARENT) return;
+
+    SetPen( m_pen );
+    cairo_move_to ( m_cairo, LogicalToDeviceX(x1), LogicalToDeviceY(y1) );
+    cairo_line_to ( m_cairo, LogicalToDeviceX(x2), LogicalToDeviceY(y2) );
+    cairo_stroke ( m_cairo );
+
+    CalcBoundingBox( x1, y1 );
+    CalcBoundingBox( x2, y2 );
+}
+
+void wxGtkPrintDC::DoCrossHair(wxCoord x, wxCoord y)
+{
+    int *w, *h;
+    w = new int;
+    h = new int;
+    DoGetSize(w, h);
+
+    SetPen(m_pen);
+
+    cairo_move_to (m_cairo, LogicalToDeviceX(x), 0);
+    cairo_line_to (m_cairo, LogicalToDeviceX(x), *h);
+    cairo_move_to (m_cairo, 0, LogicalToDeviceY(y));
+    cairo_line_to (m_cairo, *w, LogicalToDeviceY(y));
+
+    cairo_stroke (m_cairo);
+    CalcBoundingBox( 0, 0 );
+    CalcBoundingBox( *w, *h );
+
+    delete w;
+    delete h;
+}
+
+void wxGtkPrintDC::DoDrawArc(wxCoord x1,wxCoord y1,wxCoord x2,wxCoord y2,wxCoord xc,wxCoord yc)
+{
+    double dx = x1 - xc;
+    double dy = y1 - yc;
+    double radius = sqrt((double)(dx*dx+dy*dy));
+
+    double alpha1, alpha2;
+    if (x1 == x2 && y1 == y2)
+    {
+        alpha1 = 0.0;
+        alpha2 = 360.0;
+    }
+    else
+    if (radius == 0.0)
+    {
+        alpha1 = alpha2 = 0.0;
+    }
+    else
+    {
+        alpha1 = (x1 - xc == 0) ?
+            (y1 - yc < 0) ? 90.0 : -90.0 :
+            atan2(double(y1-yc), double(x1-xc)) * RAD2DEG;
+        alpha2 = (x2 - xc == 0) ?
+            (y2 - yc < 0) ? 90.0 : -90.0 :
+            atan2(double(y2-yc), double(x2-xc)) * RAD2DEG;
+
+        while (alpha1 <= 0)   alpha1 += 360;
+        while (alpha2 <= 0)   alpha2 += 360; // adjust angles to be between.
+        while (alpha1 > 360)  alpha1 -= 360; // 0 and 360 degree.
+        while (alpha2 > 360)  alpha2 -= 360;
+    }
+
+    alpha1 *= DEG2RAD;
+    alpha2 *= DEG2RAD;
+
+    cairo_arc_negative ( m_cairo, LogicalToDeviceX(xc), LogicalToDeviceY(yc), LogicalToDeviceXRel((int)radius), alpha1, alpha2);
+    cairo_line_to(m_cairo, LogicalToDeviceX(xc), LogicalToDeviceY(yc));
+    cairo_close_path (m_cairo);
+
+    SetBrush( m_brush );
+    cairo_fill_preserve( m_cairo );
+
+    SetPen (m_pen);
+    cairo_stroke( m_cairo );
+
+    CalcBoundingBox (x1, y1);
+    CalcBoundingBox (xc, yc);
+    CalcBoundingBox (x2, y2);
+}
+
+void wxGtkPrintDC::DoDrawEllipticArc(wxCoord x,wxCoord y,wxCoord w,wxCoord h,double sa,double ea)
+{
+    cairo_save( m_cairo );
+
+    cairo_translate( m_cairo, LogicalToDeviceX((wxCoord) (x + w / 2.)), LogicalToDeviceX((wxCoord) (y + h / 2.)) );
+    double scale = (double)LogicalToDeviceYRel(h) / (double) LogicalToDeviceXRel(w);
+    cairo_scale( m_cairo, 1.0, scale );
+
+    cairo_arc_negative ( m_cairo, 0, 0, LogicalToDeviceXRel(w/2), -sa*DEG2RAD, -ea*DEG2RAD);
+
+    SetPen (m_pen);
+    cairo_stroke_preserve( m_cairo );
+
+    cairo_line_to(m_cairo, 0,0);
+
+    SetBrush( m_brush );
+    cairo_fill( m_cairo );
+
+    cairo_restore( m_cairo );
+
+    CalcBoundingBox( x, y);
+    CalcBoundingBox( x+w, y+h );
+}
+
+void wxGtkPrintDC::DoDrawPoint(wxCoord x, wxCoord y)
+{
+    if  (m_pen.GetStyle() == wxTRANSPARENT) return;
+
+    SetPen( m_pen );
+
+    cairo_move_to ( m_cairo, LogicalToDeviceX(x), LogicalToDeviceY(y) );
+    cairo_line_to ( m_cairo, LogicalToDeviceX(x), LogicalToDeviceY(y) );
+    cairo_stroke ( m_cairo );
+
+    CalcBoundingBox( x, y );
+}
+
+void wxGtkPrintDC::DoDrawLines(int n, wxPoint points[], wxCoord xoffset, wxCoord yoffset)
+{
+    if (m_pen.GetStyle() == wxTRANSPARENT) return;
+
+    if (n <= 0) return;
+
+    SetPen (m_pen);
+
+    int i;
+    for ( i =0; i<n ; i++ )
+        CalcBoundingBox( points[i].x+xoffset, points[i].y+yoffset);
+
+    cairo_move_to ( m_cairo, LogicalToDeviceX(points[0].x+xoffset), LogicalToDeviceY(points[0].y+yoffset) );
+
+    for (i = 1; i < n; i++)
+        cairo_line_to ( m_cairo, LogicalToDeviceX(points[i].x+xoffset), LogicalToDeviceY(points[i].y+yoffset) );
+
+    cairo_stroke ( m_cairo);
+}
+
+void wxGtkPrintDC::DoDrawPolygon(int n, wxPoint points[], wxCoord xoffset, wxCoord yoffset, int fillStyle)
+{
+    if (n==0) return;
+
+    cairo_save(m_cairo);
+    if (fillStyle == wxWINDING_RULE)
+        cairo_set_fill_rule( m_cairo, CAIRO_FILL_RULE_WINDING);
+    else
+        cairo_set_fill_rule( m_cairo, CAIRO_FILL_RULE_EVEN_ODD);
+
+    int x = points[0].x + xoffset;
+    int y = points[0].y + yoffset;
+    cairo_new_path(m_cairo);
+    cairo_move_to( m_cairo, LogicalToDeviceX(x), LogicalToDeviceY(y) );
+    int i;
+    for (i = 1; i < n; i++)
+    {
+        int x = points[i].x + xoffset;
+        int y = points[i].y + yoffset;
+        cairo_line_to( m_cairo, LogicalToDeviceX(x), LogicalToDeviceY(y) );
+    }
+    cairo_close_path(m_cairo);
+
+    SetBrush( m_brush );
+    cairo_fill_preserve( m_cairo );
+
+    SetPen (m_pen);
+    cairo_stroke( m_cairo );
+
+    CalcBoundingBox( x, y );
+
+    cairo_restore(m_cairo);
+}
+
+void wxGtkPrintDC::DoDrawPolyPolygon(int n, int count[], wxPoint points[], wxCoord xoffset, wxCoord yoffset, int fillStyle)
+{
+    wxDC::DoDrawPolyPolygon( n, count, points, xoffset, yoffset, fillStyle );
+}
+
+void wxGtkPrintDC::DoDrawRectangle(wxCoord x, wxCoord y, wxCoord width, wxCoord height)
+{
+    cairo_rectangle ( m_cairo, LogicalToDeviceX(x), LogicalToDeviceY(y), LogicalToDeviceXRel(width), LogicalToDeviceYRel(height));
+
+    SetBrush( m_brush );
+    cairo_fill_preserve( m_cairo );
+
+    SetPen (m_pen);
+    cairo_stroke( m_cairo );
+
+    CalcBoundingBox( x, y );
+    CalcBoundingBox( x + width, y + height );
+}
+
+void wxGtkPrintDC::DoDrawRoundedRectangle(wxCoord x, wxCoord y, wxCoord width, wxCoord height, double radius)
+{
+    if (radius < 0.0) radius = - radius * ((width < height) ? width : height);
+
+    wxCoord dd = 2 * (wxCoord) radius;
+    if (dd > width) dd = width;
+    if (dd > height) dd = height;
+    radius = dd / 2;
+
+    wxCoord rad = (wxCoord) radius;
+
+    cairo_new_path(m_cairo);
+    cairo_move_to(m_cairo,LogicalToDeviceX(x + rad),LogicalToDeviceY(y));
+    cairo_curve_to(m_cairo,
+                                LogicalToDeviceX(x + rad),LogicalToDeviceY(y),
+                                LogicalToDeviceX(x),LogicalToDeviceY(y),
+                                LogicalToDeviceX(x),LogicalToDeviceY(y + rad));
+    cairo_line_to(m_cairo,LogicalToDeviceX(x),LogicalToDeviceY(y + height - rad));
+    cairo_curve_to(m_cairo,
+                                LogicalToDeviceX(x),LogicalToDeviceY(y + height - rad),
+                                LogicalToDeviceX(x),LogicalToDeviceY(y + height),
+                                LogicalToDeviceX(x + rad),LogicalToDeviceY(y + height));
+    cairo_line_to(m_cairo,LogicalToDeviceX(x + width - rad),LogicalToDeviceY(y + height));
+    cairo_curve_to(m_cairo,
+                                LogicalToDeviceX(x + width - rad),LogicalToDeviceY(y + height),
+                                LogicalToDeviceX(x + width),LogicalToDeviceY(y + height),
+                                LogicalToDeviceX(x + width),LogicalToDeviceY(y + height - rad));
+    cairo_line_to(m_cairo,LogicalToDeviceX(x + width),LogicalToDeviceY(y + rad));
+    cairo_curve_to(m_cairo,
+                                LogicalToDeviceX(x + width),LogicalToDeviceY(y + rad),
+                                LogicalToDeviceX(x + width),LogicalToDeviceY(y),
+                                LogicalToDeviceX(x + width - rad),LogicalToDeviceY(y));
+    cairo_line_to(m_cairo,LogicalToDeviceX(x + rad),LogicalToDeviceY(y));
+    cairo_close_path(m_cairo);
+
+    SetBrush(m_brush);
+    cairo_fill_preserve(m_cairo);
+
+    SetPen(m_pen);
+    cairo_stroke(m_cairo);
+
+    CalcBoundingBox(x,y);
+    CalcBoundingBox(x+width,y+height);
+}
+
+void wxGtkPrintDC::DoDrawEllipse(wxCoord x, wxCoord y, wxCoord width, wxCoord height)
+{
+    cairo_save (m_cairo);
+
+    cairo_translate (m_cairo, LogicalToDeviceX((wxCoord) (x + width / 2.)), LogicalToDeviceY((wxCoord) (y + height / 2.)));
+    cairo_scale(m_cairo, 1, (double)LogicalToDeviceYRel(height)/(double)LogicalToDeviceXRel(width));
+    cairo_arc ( m_cairo, 0, 0, LogicalToDeviceXRel(width/2), 0, 2 * M_PI);
+
+    SetBrush( m_brush );
+    cairo_fill_preserve( m_cairo );
+
+    SetPen (m_pen);
+    cairo_stroke( m_cairo );
+
+    CalcBoundingBox( x, y );
+    CalcBoundingBox( x + width, y + height );
+
+    cairo_restore (m_cairo);
+}
+
+#if wxUSE_SPLINES
+void wxGtkPrintDC::DoDrawSpline(wxList *points)
+{
+    SetPen (m_pen);
+
+    double c, d, x1, y1, x2, y2, x3, y3;
+    wxPoint *p, *q;
+
+    wxList::compatibility_iterator node = points->GetFirst();
+    p = (wxPoint *)node->GetData();
+    x1 = p->x;
+    y1 = p->y;
+
+    node = node->GetNext();
+    p = (wxPoint *)node->GetData();
+    c = p->x;
+    d = p->y;
+    x3 =
+         (double)(x1 + c) / 2;
+    y3 =
+         (double)(y1 + d) / 2;
+
+    cairo_new_path( m_cairo );
+    cairo_move_to( m_cairo, LogicalToDeviceX((wxCoord)x1), LogicalToDeviceY((wxCoord)y1) );
+    cairo_line_to( m_cairo, LogicalToDeviceX((wxCoord)x3), LogicalToDeviceY((wxCoord)y3) );
+
+    CalcBoundingBox( (wxCoord)x1, (wxCoord)y1 );
+    CalcBoundingBox( (wxCoord)x3, (wxCoord)y3 );
+
+    node = node->GetNext();
+    while (node)
+    {
+        q = (wxPoint *)node->GetData();
+
+        x1 = x3;
+        y1 = y3;
+        x2 = c;
+        y2 = d;
+        c = q->x;
+        d = q->y;
+        x3 = (double)(x2 + c) / 2;
+        y3 = (double)(y2 + d) / 2;
+
+        cairo_curve_to(m_cairo,
+            LogicalToDeviceX((wxCoord)x1), LogicalToDeviceY((wxCoord)y1),
+            LogicalToDeviceX((wxCoord)x2), LogicalToDeviceY((wxCoord)y2),
+            LogicalToDeviceX((wxCoord)x3), LogicalToDeviceY((wxCoord)y3) );
+
+        CalcBoundingBox( (wxCoord)x1, (wxCoord)y1 );
+        CalcBoundingBox( (wxCoord)x3, (wxCoord)y3 );
+
+        node = node->GetNext();
+    }
+
+    cairo_line_to ( m_cairo, LogicalToDeviceX((wxCoord)c), LogicalToDeviceY((wxCoord)d) );
+
+    cairo_stroke( m_cairo );
+}
+#endif // wxUSE_SPLINES
+
+bool wxGtkPrintDC::DoBlit(wxCoord xdest, wxCoord ydest, wxCoord width, wxCoord height,
+            wxDC *source, wxCoord xsrc, wxCoord ysrc, int rop, bool useMask,
+            wxCoord xsrcMask, wxCoord ysrcMask)
+{
+    wxCHECK_MSG( source, false, wxT("invalid source dc") );
+
+    // Blit into a bitmap.
+    wxBitmap bitmap( width, height );
+    wxMemoryDC memDC;
+    memDC.SelectObject(bitmap);
+    memDC.Blit(0, 0, width, height, source, xsrc, ysrc, rop);
+    memDC.SelectObject(wxNullBitmap);
+
+    // Draw bitmap. scaling and positioning is done there.
+    DrawBitmap( bitmap, xdest, ydest, useMask );
+
+    return true;
+}
+
+void wxGtkPrintDC::DoDrawIcon( const wxIcon& icon, wxCoord x, wxCoord y )
+{
+    DoDrawBitmap( icon, x, y, true );
+}
+
+void wxGtkPrintDC::DoDrawBitmap( const wxBitmap& bitmap, wxCoord x, wxCoord y, bool useMask )
+{
+    wxCHECK_RET( bitmap.IsOk(), wxT("Invalid bitmap in wxGtkPrintDC::DoDrawBitmap"));
+
+    cairo_surface_t* surface;
+    x = LogicalToDeviceX(x);
+    y = LogicalToDeviceY(y);
+    int bw = bitmap.GetWidth();
+    int bh = bitmap.GetHeight();
+    wxBitmap bmpSource = bitmap;  // we need a non-const instance.
+    unsigned char* buffer = new unsigned char[bw*bh*4];
+    wxUint32* data = (wxUint32*)buffer;
+
+    wxMask *mask = NULL;
+    if (useMask) mask = bmpSource.GetMask();
+
+    // Create a surface object and copy the bitmap pixel data to it. If the image has alpha (or a mask represented as alpha)
+    // then we'll use a different format and iterator than if it doesn't.
+    if (bmpSource.HasAlpha() || mask)
+    {
+        surface = cairo_image_surface_create_for_data(
+            buffer, CAIRO_FORMAT_ARGB32, bw, bh, bw*4);
+        wxAlphaPixelData pixData(bmpSource, wxPoint(0,0), wxSize(bw, bh));
+        wxCHECK_RET( pixData, wxT("Failed to gain raw access to bitmap data."));
+
+        wxAlphaPixelData::Iterator p(pixData);
+        int y, x;
+        for (y=0; y<bh; y++)
+        {
+            wxAlphaPixelData::Iterator rowStart = p;
+            for (x=0; x<bw; x++)
+            {
+                // Each pixel in CAIRO_FORMAT_ARGB32 is a 32-bit quantity,
+                // with alpha in the upper 8 bits, then red, then green, then
+                // blue. The 32-bit quantities are stored native-endian.
+                // Pre-multiplied alpha is used.
+                unsigned char alpha = p.Alpha();
+                if (alpha == 0)
+                    *data = 0;
+                else
+                    *data = ( alpha/255                  << 24
+                              | (p.Red() * alpha/255)    << 16
+                              | (p.Green() * alpha/255)  <<  8
+                              | (p.Blue() * alpha/255) );
+                ++data;
+                ++p;
+            }
+            p = rowStart;
+            p.OffsetY(pixData, 1);
+        }
+    }
+    else  // no alpha
+    {
+        surface = cairo_image_surface_create_for_data(
+            buffer, CAIRO_FORMAT_RGB24, bw, bh, bw*4);
+        wxNativePixelData pixData(bmpSource, wxPoint(0,0), wxSize(bw, bh));
+        wxCHECK_RET( pixData, wxT("Failed to gain raw access to bitmap data."));
+
+        wxNativePixelData::Iterator p(pixData);
+        int y, x;
+        for (y=0; y<bh; y++)
+        {
+            wxNativePixelData::Iterator rowStart = p;
+            for (x=0; x<bw; x++)
+            {
+                // Each pixel in CAIRO_FORMAT_RGB24 is a 32-bit quantity, with
+                // the upper 8 bits unused. Red, Green, and Blue are stored in
+                // the remaining 24 bits in that order.  The 32-bit quantities
+                // are stored native-endian.
+                *data = ( p.Red() << 16 | p.Green() << 8 | p.Blue() );
+                ++data;
+                ++p;
+            }
+            p = rowStart;
+            p.OffsetY(pixData, 1);
+        }
+    }
+
+
+    cairo_save(m_cairo);
+    // In case we're scaling the image by using a width and height different
+    // than the bitmap's size create a pattern transformation on the surface and
+    // draw the transformed pattern.
+    cairo_pattern_t* pattern = cairo_pattern_create_for_surface(surface);
+
+    // Prepare to draw the image.
+    cairo_translate(m_cairo, x, y);
+    cairo_set_source(m_cairo, pattern);
+    // Use the original size here since the context is scaled already.
+    cairo_rectangle(m_cairo, 0, 0, bw, bh);
+    // Fill the rectangle using the pattern.
+    cairo_fill(m_cairo);
+
+    // Clean up.
+    cairo_pattern_destroy(pattern);
+    cairo_surface_destroy(surface);
+    delete [] buffer;
+
+    CalcBoundingBox(0,0);
+    CalcBoundingBox(bw,bh);
+
+    cairo_restore(m_cairo);
+}
+
+// wxGtkPrintDC has a constant resolution of 72dpi. If we want an higher resolution for printing
+// an image, the scaling has to be done by cairo.
+void wxGtkPrintDC::DoDrawScaledBitmap( const wxBitmap& bitmap, wxCoord x, wxCoord y, wxCoord w, wxCoord h, bool useMask, int quality )
+{
+    wxCHECK_RET( bitmap.IsOk(), wxT("Invalid bitmap in wxGtkPrintDC::DoDrawBitmap"));
+
+    cairo_surface_t* surface;
+    int bw = bitmap.GetWidth();
+    int bh = bitmap.GetHeight();
+    x = LogicalToDeviceX(x);
+    y = LogicalToDeviceY(y);
+    w = LogicalToDeviceXRel(w);
+    h = LogicalToDeviceYRel(h);
+    wxBitmap bmpSource = bitmap;  // we need a non-const instance.
+    unsigned char* buffer = new unsigned char[bw*bh*4];
+    wxUint32* data = (wxUint32*)buffer;
+
+    // Create a surface object and copy the bitmap pixel data to it. If the image has alpha (or a mask represented as alpha)
+    // then we'll use a different format and iterator than if it doesn't.
+    if (bmpSource.HasAlpha() || bmpSource.GetMask())
+    {
+        surface = cairo_image_surface_create_for_data(
+            buffer, CAIRO_FORMAT_ARGB32, bw, bh, bw*4);
+        wxAlphaPixelData pixData(bmpSource, wxPoint(0,0), wxSize(bw, bh));
+        wxCHECK_RET( pixData, wxT("Failed to gain raw access to bitmap data."));
+
+        wxAlphaPixelData::Iterator p(pixData);
+        int y, x;
+        for (y=0; y<bh; y++)
+        {
+            wxAlphaPixelData::Iterator rowStart = p;
+            for (x=0; x<bw; x++)
+            {
+                // Each pixel in CAIRO_FORMAT_ARGB32 is a 32-bit quantity,
+                // with alpha in the upper 8 bits, then red, then green, then
+                // blue. The 32-bit quantities are stored native-endian.
+                // Pre-multiplied alpha is used.
+                unsigned char alpha = p.Alpha();
+                if (alpha == 0)
+                    *data = 0;
+                else
+                    *data = ( alpha                  << 24
+                              | (p.Red() * alpha/255)    << 16
+                              | (p.Green() * alpha/255)  <<  8
+                              | (p.Blue() * alpha/255) );
+                ++data;
+                ++p;
+            }
+            p = rowStart;
+            p.OffsetY(pixData, 1);
+        }
+    }
+    else  // no alpha
+    {
+        surface = cairo_image_surface_create_for_data(
+            buffer, CAIRO_FORMAT_RGB24, bw, bh, bw*4);
+        wxNativePixelData pixData(bmpSource, wxPoint(0,0), wxSize(bw, bh));
+        wxCHECK_RET( pixData, wxT("Failed to gain raw access to bitmap data."));
+
+        wxNativePixelData::Iterator p(pixData);
+        int y, x;
+        for (y=0; y<bh; y++)
+        {
+            wxNativePixelData::Iterator rowStart = p;
+            for (x=0; x<bw; x++)
+            {
+                // Each pixel in CAIRO_FORMAT_RGB24 is a 32-bit quantity, with
+                // the upper 8 bits unused. Red, Green, and Blue are stored in
+                // the remaining 24 bits in that order.  The 32-bit quantities
+                // are stored native-endian.
+                *data = ( p.Red() << 16 | p.Green() << 8 | p.Blue() );
+                ++data;
+                ++p;
+            }
+            p = rowStart;
+            p.OffsetY(pixData, 1);
+        }
+    }
+
+
+    cairo_save(m_cairo);
+
+    // Prepare to draw the image.
+    cairo_translate(m_cairo, x, y);
+
+    // In case we're scaling the image by using a width and height different
+    // than the bitmap's size create a pattern transformation on the surface and
+    // draw the transformed pattern.
+    cairo_filter_t filter;
+    if (quality == wxIMAGE_QUALITY_HIGH) filter = CAIRO_FILTER_BILINEAR;
+    else filter = CAIRO_FILTER_GOOD;
+    cairo_pattern_t* pattern = cairo_pattern_create_for_surface(surface);
+    cairo_pattern_set_filter(pattern,filter);
+    wxDouble scaleX = (wxDouble) w / (wxDouble) bw;
+    wxDouble scaleY = (wxDouble) h / (wxDouble) bh;
+    cairo_scale(m_cairo, scaleX, scaleY);
+
+    cairo_set_source(m_cairo, pattern);
+    // Use the original size here since the context is scaled already.
+    cairo_rectangle(m_cairo, 0, 0, bw, bh);
+    // Fill the rectangle using the pattern.
+    cairo_fill(m_cairo);
+
+    // Clean up.
+    cairo_pattern_destroy(pattern);
+    cairo_surface_destroy(surface);
+    delete [] buffer;
+
+    CalcBoundingBox(0,0);
+    CalcBoundingBox(bw,bh);
+
+    cairo_restore(m_cairo);
+}
+
+void wxGtkPrintDC::DoDrawText(const wxString& text, wxCoord x, wxCoord y )
+{
+    DoDrawRotatedText( text, x, y, 0.0 );
+}
+
+void wxGtkPrintDC::DoDrawRotatedText(const wxString& text, wxCoord x, wxCoord y, double angle)
+{
+    x = LogicalToDeviceX(x);
+    y = LogicalToDeviceY(y);
+
+    angle = -angle;
+
+    bool underlined = m_font.Ok() && m_font.GetUnderlined();
+
+// FIXME-UTF8: wouldn't be needed if utf8_str() always returned a buffer
+#if wxUSE_UNICODE_UTF8
+    const char *data = text.utf8_str();
+#else
+    const wxCharBuffer data = text.utf8_str();
+#endif
+
+    size_t datalen = strlen(data);
+    pango_layout_set_text( m_layout, data, datalen);
+
+    if (underlined)
+    {
+        PangoAttrList *attrs = pango_attr_list_new();
+        PangoAttribute *a = pango_attr_underline_new(PANGO_UNDERLINE_SINGLE);
+        a->start_index = 0;
+        a->end_index = datalen;
+        pango_attr_list_insert(attrs, a);
+        pango_layout_set_attributes(m_layout, attrs);
+        pango_attr_list_unref(attrs);
+    }
+
+    if (m_textForegroundColour.Ok())
+    {
+        unsigned char red = m_textForegroundColour.Red();
+        unsigned char blue = m_textForegroundColour.Blue();
+        unsigned char green = m_textForegroundColour.Green();
+        unsigned char alpha = m_textForegroundColour.Alpha();
+
+        if (!(red == m_currentRed && green == m_currentGreen && blue == m_currentBlue && alpha == m_currentAlpha))
+        {
+            double redPS = (double)(red) / 255.0;
+            double bluePS = (double)(blue) / 255.0;
+            double greenPS = (double)(green) / 255.0;
+            double alphaPS = (double)(alpha) / 255.0;
+
+            cairo_set_source_rgba( m_cairo, redPS, greenPS, bluePS, alphaPS );
+
+            m_currentRed = red;
+            m_currentBlue = blue;
+            m_currentGreen = green;
+            m_currentAlpha = alpha;
+        }
+    }
+
+    int w,h;
+
+    if (fabs(m_scaleY - 1.0) > 0.00001)
+    {
+        // If there is a user or actually any scale applied to the device context, scale the font.
+
+        // Scale font description.
+        gint oldSize = pango_font_description_get_size( m_fontdesc );
+        double size = oldSize;
+        size = size * m_scaleY;
+        pango_font_description_set_size( m_fontdesc, (gint)size );
+
+        // Actually apply scaled font.
+        pango_layout_set_font_description( m_layout, m_fontdesc );
+
+        pango_layout_get_pixel_size( m_layout, &w, &h );
+        w = LogicalToDeviceXRel(w);
+        h = LogicalToDeviceYRel(h);
+
+        if ( m_backgroundMode == wxSOLID )
+        {
+            unsigned char red = m_textBackgroundColour.Red();
+            unsigned char blue = m_textBackgroundColour.Blue();
+            unsigned char green = m_textBackgroundColour.Green();
+            unsigned char alpha = m_textBackgroundColour.Alpha();
+
+            double redPS = (double)(red) / 255.0;
+            double bluePS = (double)(blue) / 255.0;
+            double greenPS = (double)(green) / 255.0;
+            double alphaPS = (double)(alpha) / 255.0;
+
+            cairo_save(m_cairo);
+            cairo_translate(m_cairo, x, y);
+            cairo_set_source_rgba( m_cairo, redPS, greenPS, bluePS, alphaPS );
+            cairo_rotate(m_cairo,angle*DEG2RAD);
+            cairo_rectangle(m_cairo, 0, 0, w, h);
+            cairo_fill(m_cairo);
+            cairo_restore(m_cairo);
+        }
+
+        // Draw layout.
+        cairo_move_to (m_cairo, x, y);
+        if (fabs(angle) > 0.00001)
+        {
+            cairo_save( m_cairo );
+            cairo_rotate( m_cairo, angle*DEG2RAD );
+            pango_cairo_update_layout (m_cairo, m_layout);
+            pango_cairo_show_layout (m_cairo, m_layout);
+            cairo_restore( m_cairo );
+        }
+        else
+        {
+            pango_cairo_update_layout (m_cairo, m_layout);
+            pango_cairo_show_layout (m_cairo, m_layout);
+        }
+
+        // Reset unscaled size.
+        pango_font_description_set_size( m_fontdesc, oldSize );
+
+        // Actually apply unscaled font.
+        pango_layout_set_font_description( m_layout, m_fontdesc );
+    }
+    else
+    {
+        pango_layout_get_pixel_size( m_layout, &w, &h );
+
+        if ( m_backgroundMode == wxSOLID )
+        {
+            unsigned char red = m_textBackgroundColour.Red();
+            unsigned char blue = m_textBackgroundColour.Blue();
+            unsigned char green = m_textBackgroundColour.Green();
+            unsigned char alpha = m_textBackgroundColour.Alpha();
+
+            double redPS = (double)(red) / 255.0;
+            double bluePS = (double)(blue) / 255.0;
+            double greenPS = (double)(green) / 255.0;
+            double alphaPS = (double)(alpha) / 255.0;
+
+            cairo_save(m_cairo);
+            cairo_translate(m_cairo, x, y);
+            cairo_set_source_rgba( m_cairo, redPS, greenPS, bluePS, alphaPS );
+            cairo_rotate(m_cairo,angle*DEG2RAD);
+            cairo_rectangle(m_cairo, 0, 0, w, h);
+            cairo_fill(m_cairo);
+            cairo_restore(m_cairo);
+        }
+
+        // Draw layout.
+        cairo_move_to (m_cairo, x, y);
+        if (fabs(angle) > 0.00001)
+        {
+            cairo_save( m_cairo );
+            cairo_rotate( m_cairo, angle*DEG2RAD );
+            pango_cairo_update_layout (m_cairo, m_layout);
+            pango_cairo_show_layout (m_cairo, m_layout);
+            cairo_restore( m_cairo );
+        }
+        else
+        {
+            pango_cairo_update_layout (m_cairo, m_layout);
+            pango_cairo_show_layout (m_cairo, m_layout);
+        }
+    }
+
+    if (underlined)
+    {
+        // Undo underline attributes setting
+        pango_layout_set_attributes(m_layout, NULL);
+    }
+
+    CalcBoundingBox (x,y);
+    CalcBoundingBox (x + w, y + h);
+}
+
+void wxGtkPrintDC::Clear()
+{
+    cairo_save(m_cairo);
+    cairo_set_operator (m_cairo, CAIRO_OPERATOR_SOURCE);
+    SetBrush(m_backgroundBrush);
+    cairo_paint(m_cairo);
+    cairo_restore(m_cairo);
+}
+
+void wxGtkPrintDC::SetFont( const wxFont& font )
+{
+    m_font = font;
+
+    if (m_font.Ok())
+    {
+        if (m_fontdesc)
+            pango_font_description_free( m_fontdesc );
+
+        m_fontdesc = pango_font_description_copy( m_font.GetNativeFontInfo()->description );
+
+        pango_layout_set_font_description( m_layout, m_fontdesc );
+    }
+}
+
+void wxGtkPrintDC::SetPen( const wxPen& pen )
+{
+    if (!pen.Ok()) return;
+
+    m_pen = pen;
+
+    double width = (double) m_pen.GetWidth();
+    if (width == 0) width = 0.1;
+
+    cairo_set_line_width( m_cairo, LogicalToDeviceXRel( (wxCoord) (1000 * width )) / 1000.0f );
+    static const double dotted[] = {2.0, 5.0};
+    static const double short_dashed[] = {4.0, 4.0};
+    static const double long_dashed[] = {4.0, 8.0};
+    static const double dotted_dashed[] = {6.0, 6.0, 2.0, 6.0};
+
+    switch (m_pen.GetStyle())
+    {
+        case wxDOT:           cairo_set_dash( m_cairo, dotted, 1, 0 ); break;
+        case wxSHORT_DASH:    cairo_set_dash( m_cairo, short_dashed, 1, 0 ); break;
+        case wxLONG_DASH:     cairo_set_dash( m_cairo, long_dashed, 1, 0 ); break;
+        case wxDOT_DASH:      cairo_set_dash( m_cairo, dotted_dashed, 3, 0 );  break;
+        case wxUSER_DASH:
+        {
+            wxDash *wx_dashes;
+            int num = m_pen.GetDashes (&wx_dashes) - 1;
+            gdouble *g_dashes = g_new( gdouble, num );
+            int i;
+            for (i = 0; i < num; ++i)
+                g_dashes[i] = (gdouble) wx_dashes[i];
+            cairo_set_dash( m_cairo, g_dashes, num, 0);
+            g_free( g_dashes );
+        }
+        break;
+        case wxSOLID:
+        case wxTRANSPARENT:
+        default:              cairo_set_dash( m_cairo, NULL, 0, 0 );   break;
+    }
+
+    switch (m_pen.GetCap())
+    {
+        case wxCAP_PROJECTING:  cairo_set_line_cap (m_cairo, CAIRO_LINE_CAP_SQUARE); break;
+        case wxCAP_BUTT:        cairo_set_line_cap (m_cairo, CAIRO_LINE_CAP_BUTT); break;
+        case wxCAP_ROUND:
+        default:                cairo_set_line_cap (m_cairo, CAIRO_LINE_CAP_ROUND); break;
+    }
+
+    switch (m_pen.GetJoin())
+    {
+        case wxJOIN_BEVEL:  cairo_set_line_join (m_cairo, CAIRO_LINE_JOIN_BEVEL); break;
+        case wxJOIN_MITER:  cairo_set_line_join (m_cairo, CAIRO_LINE_JOIN_MITER); break;
+        case wxJOIN_ROUND:
+        default:            cairo_set_line_join (m_cairo, CAIRO_LINE_JOIN_ROUND); break;
+    }
+
+    unsigned char red = m_pen.GetColour().Red();
+    unsigned char blue = m_pen.GetColour().Blue();
+    unsigned char green = m_pen.GetColour().Green();
+    unsigned char alpha = m_pen.GetColour().Alpha();
+
+    if (!(red == m_currentRed && green == m_currentGreen && blue == m_currentBlue && alpha == m_currentAlpha))
+    {
+        double redPS = (double)(red) / 255.0;
+        double bluePS = (double)(blue) / 255.0;
+        double greenPS = (double)(green) / 255.0;
+        double alphaPS = (double)(alpha) / 255.0;
+
+        cairo_set_source_rgba( m_cairo, redPS, greenPS, bluePS, alphaPS );
+
+        m_currentRed = red;
+        m_currentBlue = blue;
+        m_currentGreen = green;
+        m_currentAlpha = alpha;
+    }
+}
+
+void wxGtkPrintDC::SetBrush( const wxBrush& brush )
+{
+    if (!brush.Ok()) return;
+
+    m_brush = brush;
+
+    // Brush colour.
+    unsigned char red = m_brush.GetColour().Red();
+    unsigned char blue = m_brush.GetColour().Blue();
+    unsigned char green = m_brush.GetColour().Green();
+    unsigned char alpha = m_brush.GetColour().Alpha();
+
+    double redPS = (double)(red) / 255.0;
+    double bluePS = (double)(blue) / 255.0;
+    double greenPS = (double)(green) / 255.0;
+    double alphaPS = (double)(alpha) / 255.0;
+
+    if (!(red == m_currentRed && green == m_currentGreen && blue == m_currentBlue && alpha == m_currentAlpha))
+    {
+        cairo_set_source_rgba( m_cairo, redPS, greenPS, bluePS, alphaPS );
+
+        m_currentRed = red;
+        m_currentBlue = blue;
+        m_currentGreen = green;
+        m_currentAlpha = alpha;
+    }
+
+    if (m_brush.IsHatch())
+    {
+        cairo_t * cr;
+        cairo_surface_t *surface;
+        surface = cairo_surface_create_similar(cairo_get_target(m_cairo),CAIRO_CONTENT_COLOR_ALPHA,10,10);
+        cr = cairo_create(surface);
+        cairo_set_line_cap(cr, CAIRO_LINE_CAP_SQUARE);
+        cairo_set_line_width(cr, 1);
+        cairo_set_line_join(cr,CAIRO_LINE_JOIN_MITER);
+
+        switch (m_brush.GetStyle())
+        {
+            case wxCROSS_HATCH:
+                cairo_move_to(cr, 5, 0);
+                cairo_line_to(cr, 5, 10);
+                cairo_move_to(cr, 0, 5);
+                cairo_line_to(cr, 10, 5);
+                break;
+            case wxBDIAGONAL_HATCH:
+                cairo_move_to(cr, 0, 10);
+                cairo_line_to(cr, 10, 0);
+                break;
+            case wxFDIAGONAL_HATCH:
+                cairo_move_to(cr, 0, 0);
+                cairo_line_to(cr, 10, 10);
+                break;
+            case wxCROSSDIAG_HATCH:
+                cairo_move_to(cr, 0, 0);
+                cairo_line_to(cr, 10, 10);
+                cairo_move_to(cr, 10, 0);
+                cairo_line_to(cr, 0, 10);
+                break;
+            case wxHORIZONTAL_HATCH:
+                cairo_move_to(cr, 0, 5);
+                cairo_line_to(cr, 10, 5);
+                break;
+            case wxVERTICAL_HATCH:
+                cairo_move_to(cr, 5, 0);
+                cairo_line_to(cr, 5, 10);
+                break;
+            default:
+                wxFAIL_MSG(_("Couldn't get hatch style from wxBrush."));
+        }
+
+        cairo_set_source_rgba(cr, redPS, greenPS, bluePS, alphaPS);
+        cairo_stroke (cr);
+
+        cairo_destroy(cr);
+        cairo_pattern_t * pattern = cairo_pattern_create_for_surface (surface);
+        cairo_surface_destroy(surface);
+        cairo_pattern_set_extend (pattern, CAIRO_EXTEND_REPEAT);
+        cairo_set_source(m_cairo, pattern);
+        cairo_pattern_destroy(pattern);
+    }
+}
+
+void wxGtkPrintDC::SetLogicalFunction( int function )
+{
+    if (function == wxCLEAR)
+        cairo_set_operator (m_cairo, CAIRO_OPERATOR_CLEAR);
+    else if (function == wxOR)
+        cairo_set_operator (m_cairo, CAIRO_OPERATOR_OUT);
+    else if (function == wxNO_OP)
+        cairo_set_operator (m_cairo, CAIRO_OPERATOR_DEST);
+    else if (function == wxAND)
+        cairo_set_operator (m_cairo, CAIRO_OPERATOR_ADD);
+    else if (function == wxSET)
+        cairo_set_operator (m_cairo, CAIRO_OPERATOR_SATURATE);
+    else if (function == wxXOR)
+        cairo_set_operator (m_cairo, CAIRO_OPERATOR_XOR);
+    else // wxCOPY or anything else.
+        cairo_set_operator (m_cairo, CAIRO_OPERATOR_SOURCE);
+}
+
+void wxGtkPrintDC::SetBackground( const wxBrush& brush )
+{
+    m_backgroundBrush = brush;
+    cairo_save(m_cairo);
+    cairo_set_operator (m_cairo, CAIRO_OPERATOR_DEST_OVER);
+
+    SetBrush(m_backgroundBrush);
+    cairo_paint(m_cairo);
+    cairo_restore(m_cairo);
+}
+
+void wxGtkPrintDC::SetBackgroundMode(int mode)
+{
+    if (mode == wxSOLID) m_backgroundMode = wxSOLID;
+    else m_backgroundMode = wxTRANSPARENT;
+}
+
+void wxGtkPrintDC::DoSetClippingRegion(wxCoord x, wxCoord y, wxCoord width, wxCoord height)
+{
+    cairo_rectangle ( m_cairo, LogicalToDeviceX(x), LogicalToDeviceY(y), LogicalToDeviceXRel(width), LogicalToDeviceYRel(height));
+    cairo_clip(m_cairo);
+}
+
+void wxGtkPrintDC::DestroyClippingRegion()
+{
+    cairo_reset_clip(m_cairo);
+}
+
+bool wxGtkPrintDC::StartDoc(const wxString& message)
+{
+    return true;
+}
+
+void wxGtkPrintDC::EndDoc()
+{
+    return;
+}
+
+void wxGtkPrintDC::StartPage()
+{
+    return;
+}
+
+void wxGtkPrintDC::EndPage()
+{
+    return;
+}
+
+wxCoord wxGtkPrintDC::GetCharHeight() const
+{
+    pango_layout_set_text( m_layout, "H", 1 );
+
+    int w,h;
+    pango_layout_get_pixel_size( m_layout, &w, &h );
+
+    return DeviceToLogicalYRel(h);
+}
+
+wxCoord wxGtkPrintDC::GetCharWidth() const
+{
+    pango_layout_set_text( m_layout, "H", 1 );
+
+    int w,h;
+    pango_layout_get_pixel_size( m_layout, &w, &h );
+
+    return DeviceToLogicalXRel(w);
+}
+
+void wxGtkPrintDC::DoGetTextExtent(const wxString& string, wxCoord *width, wxCoord *height,
+                     wxCoord *descent,
+                     wxCoord *externalLeading,
+                     const wxFont *theFont ) const
+{
+    if ( width )
+        *width = 0;
+    if ( height )
+        *height = 0;
+    if ( descent )
+        *descent = 0;
+    if ( externalLeading )
+        *externalLeading = 0;
+
+    if (string.empty())
+    {
+        return;
+    }
+
+    // Set layout's text
+    // FIXME-UTF8: wouldn't be needed if utf8_str() always returned a buffer
+#if wxUSE_UNICODE_UTF8
+    const char *dataUTF8 = string.utf8_str();
+#else
+    const wxCharBuffer dataUTF8 = string.utf8_str();
+#endif
+
+    PangoFontDescription *desc = m_fontdesc;
+    if (theFont) desc = theFont->GetNativeFontInfo()->description;
+
+    gint oldSize = pango_font_description_get_size( desc );
+    double size = oldSize;
+    size = size * m_scaleY;
+    pango_font_description_set_size( desc, (gint)size );
+
+    // apply scaled font
+    pango_layout_set_font_description( m_layout, desc );
+
+    pango_layout_set_text( m_layout, dataUTF8, strlen(dataUTF8) );
+
+    int w, h;
+    pango_layout_get_pixel_size( m_layout, &w, &h );
+
+    if (width)
+        *width = (wxCoord)(w / m_scaleX);
+    if (height)
+        *height = (wxCoord)(h / m_scaleY);
+    if (descent)
+    {
+        PangoLayoutIter *iter = pango_layout_get_iter(m_layout);
+        int baseline = pango_layout_iter_get_baseline(iter);
+        pango_layout_iter_free(iter);
+        *descent = h - PANGO_PIXELS(baseline);
+    }
+
+    // Reset unscaled size.
+    pango_font_description_set_size( desc, oldSize );
+
+    // Reset unscaled font.
+    pango_layout_set_font_description( m_layout, m_fontdesc );
+}
+
+void wxGtkPrintDC::DoGetSize(int* width, int* height) const
+{
+    if (width)
+        *width = (int) (gtk_print_context_get_width( m_gpc ) + 0.5);
+    if (height)
+        *height = (int) (gtk_print_context_get_height( m_gpc ) + 0.5);
+}
+
+void wxGtkPrintDC::DoGetSizeMM(int *width, int *height) const
+{
+    // This function takes margins into consideration.
+    gdouble w = gtk_page_setup_get_page_width( gtk_print_context_get_page_setup( m_gpc ), GTK_UNIT_MM);
+    gdouble h = gtk_page_setup_get_page_height( gtk_print_context_get_page_setup( m_gpc ), GTK_UNIT_MM);
+
+    if (width)
+        *width = (int) (w + 0.5);
+    if (height)
+        *height = (int) (h + 0.5);
+}
+
+wxSize wxGtkPrintDC::GetPPI() const
+{
+    gdouble xDpi = gtk_print_context_get_dpi_x( m_gpc );
+    gdouble yDpi = gtk_print_context_get_dpi_y( m_gpc );
+    return wxSize((int) xDpi,(int) yDpi);
+}
+
+void wxGtkPrintDC::SetLogicalOrigin( wxCoord x, wxCoord y )
+{
+    wxDC::SetLogicalOrigin( x, y );
+}
+
+void wxGtkPrintDC::SetDeviceOrigin( wxCoord x, wxCoord y )
+{
+    wxDC::SetDeviceOrigin( x, y );
+}
+
+void wxGtkPrintDC::SetPrintData(const wxPrintData& data)
+{
+    m_printData = data;
+
+    if (m_printData.GetOrientation() == wxPORTRAIT)
+        GetSize( &m_deviceOffsetX, &m_deviceOffsetY );
+    else
+        GetSize( &m_deviceOffsetY, &m_deviceOffsetX );
+}
+
+void wxGtkPrintDC::SetResolution(int ppi)
+{
+    // We can't change ppi of the GtkPrintContext.
+    ms_resolution = ppi;
+}
+
+int wxGtkPrintDC::GetResolution()
+{
+    return ms_resolution;
+}
+
+// ----------------------------------------------------------------------------
+// Print preview
+// ----------------------------------------------------------------------------
+
+IMPLEMENT_CLASS(wxGtkPrintPreview, wxPrintPreviewBase)
+
+void wxGtkPrintPreview::Init(wxPrintout * WXUNUSED(printout),
+                                    wxPrintout * WXUNUSED(printoutForPrinting))
+{
+    DetermineScaling();
+}
+
+wxGtkPrintPreview::wxGtkPrintPreview(wxPrintout *printout,
+                                                   wxPrintout *printoutForPrinting,
+                                                   wxPrintDialogData *data)
+                        : wxPrintPreviewBase(printout, printoutForPrinting, data)
+{
+    Init(printout, printoutForPrinting);
+}
+
+wxGtkPrintPreview::wxGtkPrintPreview(wxPrintout *printout,
+                                                   wxPrintout *printoutForPrinting,
+                                                   wxPrintData *data)
+                        : wxPrintPreviewBase(printout, printoutForPrinting, data)
+{
+    Init(printout, printoutForPrinting);
+}
+
+wxGtkPrintPreview::~wxGtkPrintPreview()
+{
+}
+
+bool wxGtkPrintPreview::Print(bool interactive)
+{
+    if (!m_printPrintout)
+        return false;
+
+    wxPrinter printer(& m_printDialogData);
+    return printer.Print(m_previewFrame, m_printPrintout, interactive);
+}
+
+void wxGtkPrintPreview::DetermineScaling()
+{
+    wxPaperSize paperType = m_printDialogData.GetPrintData().GetPaperId();
+
+    wxPrintPaperType *paper = wxThePrintPaperDatabase->FindPaperType(paperType);
+    if (!paper)
+        paper = wxThePrintPaperDatabase->FindPaperType(wxPAPER_A4);
+
+    if (paper)
+    {
+        wxSize ScreenPixels = wxGetDisplaySize();
+        wxSize ScreenMM = wxGetDisplaySizeMM();
+
+        m_previewPrintout->SetPPIScreen( (int) ((ScreenPixels.GetWidth() * 25.4) / ScreenMM.GetWidth()),
+                                         (int) ((ScreenPixels.GetHeight() * 25.4) / ScreenMM.GetHeight()) );
+        m_previewPrintout->SetPPIPrinter(wxGtkPrintDC::GetResolution(), wxGtkPrintDC::GetResolution());
+        // Get width and height in points (1/72th of an inch)
+        wxSize sizeDevUnits(paper->GetSizeDeviceUnits());
+
+        sizeDevUnits.x = (wxCoord)((float)sizeDevUnits.x * wxGtkPrintDC::GetResolution() / 72.0);
+        sizeDevUnits.y = (wxCoord)((float)sizeDevUnits.y * wxGtkPrintDC::GetResolution() / 72.0);
+        wxSize sizeTenthsMM(paper->GetSize());
+        wxSize sizeMM(sizeTenthsMM.x / 10, sizeTenthsMM.y / 10);
+
+        // If in landscape mode, we need to swap the width and height.
+        if ( m_printDialogData.GetPrintData().GetOrientation() == wxLANDSCAPE )
+        {
+            m_pageWidth = sizeDevUnits.y;
+            m_pageHeight = sizeDevUnits.x;
+            m_previewPrintout->SetPageSizeMM(sizeMM.y, sizeMM.x);
+        }
+        else
+        {
+            m_pageWidth = sizeDevUnits.x;
+            m_pageHeight = sizeDevUnits.y;
+            m_previewPrintout->SetPageSizeMM(sizeMM.x, sizeMM.y);
+        }
+        m_previewPrintout->SetPageSizePixels(m_pageWidth, m_pageHeight);
+        m_previewPrintout->SetPaperRectPixels(wxRect(0, 0, m_pageWidth, m_pageHeight));
+
+        // At 100%, the page should look about page-size on the screen.
+        m_previewScaleX = (float)0.8 * 72.0 / (float)wxGtkPrintDC::GetResolution();
+        m_previewScaleY = m_previewScaleX;
+    }
+}

 	  	 
