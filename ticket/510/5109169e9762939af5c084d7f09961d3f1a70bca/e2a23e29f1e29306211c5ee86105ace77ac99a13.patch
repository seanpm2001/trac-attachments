diff -aburN ../original/build/bakefiles/config.bkl ./build/bakefiles/config.bkl
--- ../original/build/bakefiles/config.bkl	2007-08-26 12:51:40.000000000 +0200
+++ ./build/bakefiles/config.bkl	2007-08-30 19:22:12.000000000 +0200
@@ -351,6 +351,7 @@
         <option name="EXTRALIBS_GUI"/>
         <option name="EXTRALIBS_OPENGL"/>
         <option name="EXTRALIBS_SDL"/>
+        <option name="EXTRALIBS_GTKPRINT"/>
         <option name="EXTRALIBS_GNOMEPRINT"/>
         <option name="CXXWARNINGS"/>
         <option name="HOST_SUFFIX"/>
@@ -407,6 +408,7 @@
             <if cond="COMPILER=='gcc'">-lopengl32 -lglu32</if>
         </set>
         <set var="EXTRALIBS_SDL"/>
+        <set var="EXTRALIBS_GTKPRINT"/>
         <set var="EXTRALIBS_GNOMEPRINT"/>
 
         <set var="WITH_PLUGIN_SDL">0</set>
diff -aburN ../original/build/bakefiles/files.bkl ./build/bakefiles/files.bkl
--- ../original/build/bakefiles/files.bkl	2007-08-26 13:07:48.000000000 +0200
+++ ./build/bakefiles/files.bkl	2007-08-31 12:21:10.000000000 +0200
@@ -1051,6 +1051,7 @@
     src/gtk/gauge.cpp
     src/gtk/gnome/gprint.cpp
     src/gtk/gnome/gvfs.cpp
+    src/gtk/print.cpp
     src/gtk/listbox.cpp
     src/gtk/mdi.cpp
     src/gtk/menu.cpp
@@ -1101,6 +1102,7 @@
     wx/gtk/gauge.h
     wx/gtk/gnome/gprint.h
     wx/gtk/gnome/gvfs.h
+    wx/gtk/print.h
     wx/gtk/listbox.h
     wx/gtk/mdi.h
     wx/gtk/menu.h
diff -aburN ../original/configure.in ./configure.in
--- ../original/configure.in	2007-08-26 12:54:36.000000000 +0200
+++ ./configure.in	2007-08-30 19:14:58.000000000 +0200
@@ -495,6 +495,7 @@
 WX_ARG_SYS_WITH(libtiff,   [  --with-libtiff          use libtiff (TIFF file format)], wxUSE_LIBTIFF)
 WX_ARG_SYS_WITH(libxpm,    [  --with-libxpm           use libxpm (XPM file format)], wxUSE_LIBXPM)
 WX_ARG_WITH(libmspack,     [  --with-libmspack        use libmspack (CHM help files loading)], wxUSE_LIBMSPACK)
+WX_ARG_WITHOUT(gtkprint,   [  --without-gtkprint      don't use GTK printing support], wxUSE_GTKPRINT)
 WX_ARG_WITHOUT(gnomeprint, [  --without-gnomeprint    don't use GNOME printing libraries], wxUSE_LIBGNOMEPRINT)
 WX_ARG_WITH(gnomevfs,      [  --with-gnomevfs         use GNOME VFS for associating MIME types], wxUSE_LIBGNOMEVFS)
 WX_ARG_WITH(hildon,        [  --with-hildon           use Hildon framework for Nokia 770], wxUSE_LIBHILDON)
@@ -5482,6 +5483,23 @@
     PKG_PROG_PKG_CONFIG()
 
     if test "$wxUSE_PRINTING_ARCHITECTURE" = "yes" ; then
+
+        if test "$wxUSE_GTKPRINT" = "yes" ; then
+
+                PKG_CHECK_MODULES(GTKPRINT,
+                                  [gtk+-unix-print-2.0 >= 2.10],
+                    [
+                        CFLAGS="$GTKPRINT_CFLAGS $CFLAGS"
+                        CXXFLAGS="$GTKPRINT_CFLAGS $CXXFLAGS"
+                        AC_DEFINE(wxUSE_GTKPRINT)
+                    ],
+                    [
+                        AC_MSG_WARN([GTK printing support not found (GTK+ >= 2.10), library will use GNOME printing support or standard PostScript printing])
+                        wxUSE_GTKPRINT="no"
+                    ]
+                )
+        fi
+
         if test "$wxUSE_LIBGNOMEPRINT" = "yes" ; then
 
                 PKG_CHECK_MODULES(LIBGNOMEPRINTUI,
@@ -7417,7 +7435,7 @@
 EXTRALIBS_ODBC="$ODBC_LINK"
 EXTRALIBS_STC="-lwxscintilla${lib_debug_suffix}${WX_LIB_FLAVOUR}-${WX_RELEASE}${HOST_SUFFIX}"
 if test "$wxUSE_GUI" = "yes"; then
-    EXTRALIBS_GUI=`echo $GUI_TK_LIBRARY $PNG_LINK $JPEG_LINK $TIFF_LINK $WEBKIT_LINK $EXTRALIBS_HILDON $EXTRALIBS_GNOMEVFS $EXTRALIBS_GNOMEPRINT`
+    EXTRALIBS_GUI=`echo $GUI_TK_LIBRARY $PNG_LINK $JPEG_LINK $TIFF_LINK $WEBKIT_LINK $EXTRALIBS_HILDON $EXTRALIBS_GNOMEVFS $EXTRALIBS_GNOMEPRINT $EXTRALIBS_GTKPRINT`
 fi
 if test "$wxUSE_OPENGL" = "yes"; then
     EXTRALIBS_OPENGL="$LDFLAGS_GL $OPENGL_LIBS"
@@ -7528,6 +7546,7 @@
 AC_SUBST(EXTRALIBS_OPENGL)
 AC_SUBST(EXTRALIBS_SDL)
 AC_SUBST(WITH_PLUGIN_SDL)
+AC_SUBST(EXTRALIBS_GTKPRINT)
 AC_SUBST(EXTRALIBS_GNOMEPRINT)
 AC_SUBST(EXTRALIBS_GNOMEVFS)
 AC_SUBST(EXTRALIBS_HILDON)
@@ -7549,6 +7568,9 @@
         TOOLKIT_DESC="GTK+"
         if test "$WXGTK20" = 1; then
             TOOLKIT_DESC="$TOOLKIT_DESC 2"
+            if test "$wxUSE_GTKPRINT" = "yes" ; then
+                TOOLKIT_EXTRA="$TOOLKIT_EXTRA GTK+ printing";
+            fi
             if test "$wxUSE_LIBGNOMEPRINT" = "yes" ; then
                 TOOLKIT_EXTRA="$TOOLKIT_EXTRA gnomeprint";
             fi
diff -aburN ../original/docs/latex/wx/dc.tex ./docs/latex/wx/dc.tex
--- ../original/docs/latex/wx/dc.tex	2007-08-26 12:49:12.000000000 +0200
+++ ./docs/latex/wx/dc.tex	2007-08-30 14:24:00.000000000 +0200
@@ -484,6 +484,24 @@
 the rectangle.
 
 
+docs/latex/wx/dc.tex
+
+\membersection{wxDC::DrawScaledBitmap}\label{wxdcdrawscaledbitmap}
+
+\func{void}{DrawScaledBitmap}{\param{const wxBitmap\&}{ bitmap}, \param{wxCoord}{ x}, \param{wxCoord}{ y}, \param{wxCoord}{ w}, \param{wxCoord}{ h}, \param{bool}{ transparent}, \param{int}{ quality = wxIMAGE_QUALITY_NORMAL}}
+
+Draw a bitmap on the device context at the specified point and resize it to the specified size. If {\it transparent} is true and the bitmap has a transparency mask, the bitmap will be drawn transparently.
+
+Under wxGTK with Gtk Printing support, you should use this method with a wxPrinterDC if you want to print an image with a resolution higher than 72 dpi. On every other DC and platform, resizing is done using \helpref{wxImage::Rescale}{wximagerescale}.
+
+For a description of the {\it quality} parameter, see the \helpref{Scale}{wximagescale} function.
+
+When drawing a mono-bitmap, the current text foreground colour will be used to draw the foreground
+of the bitmap (all bits set to 1), and the current text background colour to draw the background
+(all bits set to 0). See also \helpref{SetTextForeground}{wxdcsettextforeground},
+\helpref{SetTextBackground}{wxdcsettextbackground} and \helpref{wxMemoryDC}{wxmemorydc}.
+
+
 \membersection{wxDC::DrawSpline}\label{wxdcdrawspline}
 
 \func{void}{DrawSpline}{\param{int }{n}, \param{wxPoint }{points[]}}
diff -aburN ../original/docs/latex/wx/tprint.tex ./docs/latex/wx/tprint.tex
--- ../original/docs/latex/wx/tprint.tex	2007-08-26 12:49:14.000000000 +0200
+++ ./docs/latex/wx/tprint.tex	2007-08-30 14:31:44.000000000 +0200
@@ -219,6 +219,15 @@
 these libraries).
 
 In version GTK+ 2.10, support for printing has finally been
-added to GTK+ itself. Support for this has yet to be written
-for wxGTK (which requires drawing through Cairo).
+added to GTK+ itself. Beginning with version 2.9.X,
+the GTK+ port of wxWidgets can make use of this feature
+if wxWidgets is configured accordingly and if the GTK+ version is >= 2.10.
+You need to configure wxWidgets with the {\it configure --with-gtkprint}
+switch and your application will then search for the GTK+ print support
+at runtime. If it is found, printing will be done through GTK+, otherwise the
+application will fall back to GNOME printing support if it is available or,
+if it isn't, to the old PostScript printing code.
+Note that the application will not require a GTK+ version >= 2.10
+to be installed in order to run (there will be no dependency on
+this version).
 
diff -aburN ../original/docs/latex/wx/wxusedef.tex ./docs/latex/wx/wxusedef.tex
--- ../original/docs/latex/wx/wxusedef.tex	2007-08-26 12:49:14.000000000 +0200
+++ ./docs/latex/wx/wxusedef.tex	2007-08-30 14:32:16.000000000 +0200
@@ -242,6 +242,7 @@
 \subsection{wxUSE preprocessor symbols used only in wxGTK port}\label{wxusedefgtk}
 \begin{twocollist}\itemsep=0pt
 \twocolitem{wxUSE\_DETECT\_SM}{Use code to detect X11 session manager.}
+\twocolitem{wxUSE\_GTKPRINT}{Use GTK+ printing support.}
 \twocolitem{wxUSE\_LIBGNOMEPRINT}{Use GNOME printing support.}
 \twocolitem{wxUSE\_LIBGNOMEVFS}{Use GNOME VFS support.}
 \twocolitem{wxUSE\_LIBGNOMEVS}{Use GNOME VFS support.}
diff -aburN ../original/include/wx/dc.h ./include/wx/dc.h
--- ../original/include/wx/dc.h	2007-08-26 12:51:30.000000000 +0200
+++ ./include/wx/dc.h	2007-08-26 14:10:52.000000000 +0200
@@ -873,6 +873,49 @@
                     bool useMask = false)
         { m_pimpl->DoDrawBitmap(bmp, pt.x, pt.y, useMask); }
 
+    virtual void DrawScaledBitmap(const wxBitmap &bmp, wxCoord x, wxCoord y, wxCoord w, wxCoord h, bool useMask = false, int quality = wxIMAGE_QUALITY_NORMAL)
+        {
+            if (bmp.GetWidth() != w || bmp.GetHeight() != h)
+            {
+                if (quality != wxIMAGE_QUALITY_HIGH)
+                    quality = wxIMAGE_QUALITY_NORMAL;
+                wxImage tmpImg = bmp.ConvertToImage();
+                tmpImg.Rescale( w, h, quality );
+                wxBitmap scaledBmp(tmpImg);
+                m_pimpl->DoDrawBitmap(scaledBmp, x, y, useMask);
+            }
+            else
+                m_pimpl->DoDrawBitmap(bmp, x, y, useMask);
+        }
+    virtual void DrawScaledBitmap(const wxBitmap &bmp, const wxPoint& pt, const wxSize& sz, bool useMask = false, int quality = wxIMAGE_QUALITY_NORMAL)
+        {
+            if (bmp.GetWidth() != sz.x || bmp.GetHeight() != sz.y)
+            {
+                if (quality != wxIMAGE_QUALITY_HIGH)
+                    quality = wxIMAGE_QUALITY_NORMAL;
+                wxImage tmpImg = bmp.ConvertToImage();
+                tmpImg.Rescale( sz.x, sz.y, quality );
+                wxBitmap scaledBmp(tmpImg);
+                m_pimpl->DoDrawBitmap(scaledBmp, pt.x, pt.y, useMask);
+            }
+            else
+                m_pimpl->DoDrawBitmap(bmp, pt.x, pt.y, useMask);
+        }
+    virtual void DrawScaledBitmap(const wxBitmap &bmp, const wxRect& rect, bool useMask = false, int quality = wxIMAGE_QUALITY_NORMAL)
+        {
+            if (bmp.GetWidth() != rect.width || bmp.GetHeight() != rect.height)
+            {
+                if (quality != wxIMAGE_QUALITY_HIGH)
+                    quality = wxIMAGE_QUALITY_NORMAL;
+                wxImage tmpImg = bmp.ConvertToImage();
+                tmpImg.Rescale( rect.width, rect.height, quality );
+                wxBitmap scaledBmp(tmpImg);
+                m_pimpl->DoDrawBitmap(scaledBmp, rect.x, rect.y, useMask);
+            }
+            else
+                m_pimpl->DoDrawBitmap(bmp, rect.x, rect.y, useMask);
+        }
+
     void DrawText(const wxString& text, wxCoord x, wxCoord y)
         { m_pimpl->DoDrawText(text, x, y); }
     void DrawText(const wxString& text, const wxPoint& pt)
@@ -1189,6 +1232,49 @@
                     bool useMask = false)
         { DoDrawBitmap(bmp, pt.x, pt.y, useMask); }
 
+    virtual void DrawScaledBitmap(const wxBitmap &bmp, wxCoord x, wxCoord y, wxCoord w, wxCoord h, bool useMask = false, int quality = wxIMAGE_QUALITY_NORMAL)
+        {
+            if (bmp.GetWidth() != w || bmp.GetHeight() != h)
+            {
+                if (quality != wxIMAGE_QUALITY_HIGH)
+                    quality = wxIMAGE_QUALITY_NORMAL;
+                wxImage tmpImg = bmp.ConvertToImage();
+                tmpImg.Rescale( w, h, quality );
+                wxBitmap scaledBmp(tmpImg);
+                DoDrawBitmap(scaledBmp, x, y, useMask);
+            }
+            else
+                DoDrawBitmap(bmp, x, y, useMask);
+        }
+    virtual void DrawScaledBitmap(const wxBitmap &bmp, const wxPoint& pt, const wxSize& sz, bool useMask = false, int quality = wxIMAGE_QUALITY_NORMAL)
+        {
+            if (bmp.GetWidth() != sz.x || bmp.GetHeight() != sz.y)
+            {
+                if (quality != wxIMAGE_QUALITY_HIGH)
+                    quality = wxIMAGE_QUALITY_NORMAL;
+                wxImage tmpImg = bmp.ConvertToImage();
+                tmpImg.Rescale( sz.x, sz.y, quality );
+                wxBitmap scaledBmp(tmpImg);
+                DoDrawBitmap(scaledBmp, pt.x, pt.y, useMask);
+            }
+            else
+                DoDrawBitmap(bmp, pt.x, pt.y, useMask);
+        }
+    virtual void DrawScaledBitmap(const wxBitmap &bmp, const wxRect& rect, bool useMask = false, int quality = wxIMAGE_QUALITY_NORMAL)
+        {
+            if (bmp.GetWidth() != rect.width || bmp.GetHeight() != rect.height)
+            {
+                if (quality != wxIMAGE_QUALITY_HIGH)
+                    quality = wxIMAGE_QUALITY_NORMAL;
+                wxImage tmpImg = bmp.ConvertToImage();
+                tmpImg.Rescale( rect.width, rect.height, quality );
+                wxBitmap scaledBmp(tmpImg);
+                DoDrawBitmap(scaledBmp, rect.x, rect.y, useMask);
+            }
+            else
+                DoDrawBitmap(bmp, rect.x, rect.y, useMask);
+        }
+
     void DrawText(const wxString& text, wxCoord x, wxCoord y)
         { DoDrawText(text, x, y); }
     void DrawText(const wxString& text, const wxPoint& pt)
diff -aburN ../original/include/wx/gtk/gnome/gprint.h ./include/wx/gtk/gnome/gprint.h
--- ../original/include/wx/gtk/gnome/gprint.h	2007-08-26 12:51:14.000000000 +0200
+++ ./include/wx/gtk/gnome/gprint.h	2007-08-31 14:15:53.000000000 +0200
@@ -23,6 +23,21 @@
 typedef struct _GnomePrintContext GnomePrintContext;
 typedef struct _GnomePrintConfig GnomePrintConfig;
 
+// ----------------------------------------------------------------------------
+// wxGnomePrintModule
+// ----------------------------------------------------------------------------
+
+class wxGnomePrintModule: public wxModule
+{
+public:
+    wxGnomePrintModule() {}
+    bool OnInit();
+    void OnExit();
+
+private:
+    DECLARE_DYNAMIC_CLASS(wxGnomePrintModule)
+};
+
 //----------------------------------------------------------------------------
 // wxGnomePrintNativeData
 //----------------------------------------------------------------------------
diff -aburN ../original/include/wx/gtk/print.h ./include/wx/gtk/print.h
--- ../original/include/wx/gtk/print.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/wx/gtk/print.h	2007-08-30 11:47:02.000000000 +0200
@@ -0,0 +1,402 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/gtk/print.h
+// Author:      Anthony Bretaudeau
+// Purpose:     GTK printing support
+// Created:     2007-08-25
+// RCS-ID:      $Id: print.h,v 1 2007-08-25 05:44:44 PC Exp $
+// Copyright:   (c) 2007 wxWidgets development team
+// Licence:     wxWindows Licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_GTK_PRINT_H_
+#define _WX_GTK_PRINT_H_
+
+#include "wx/defs.h"
+
+#if wxUSE_GTKPRINT
+
+#include "wx/print.h"
+#include "wx/printdlg.h"
+#include "wx/prntbase.h"
+#include "wx/dc.h"
+
+#include <cairo.h>
+
+typedef struct _GtkPrintOperation GtkPrintOperation;
+typedef struct _GtkPrintContext GtkPrintContext;
+typedef struct _GtkPrintSettings GtkPrintSettings;
+typedef struct _GtkPageSetup GtkPageSetup;
+
+
+//----------------------------------------------------------------------------
+// wxGtkPrintFactory
+//----------------------------------------------------------------------------
+
+class wxGtkPrintFactory: public wxPrintFactory
+{
+public:
+    virtual wxPrinterBase *CreatePrinter( wxPrintDialogData *data );
+
+    virtual wxPrintPreviewBase *CreatePrintPreview( wxPrintout *preview,
+                                                    wxPrintout *printout = NULL,
+                                                    wxPrintDialogData *data = NULL );
+    virtual wxPrintPreviewBase *CreatePrintPreview( wxPrintout *preview,
+                                                    wxPrintout *printout,
+                                                    wxPrintData *data );
+
+    virtual wxPrintDialogBase *CreatePrintDialog( wxWindow *parent,
+                                                  wxPrintDialogData *data = NULL );
+    virtual wxPrintDialogBase *CreatePrintDialog( wxWindow *parent,
+                                                  wxPrintData *data );
+
+    virtual wxPageSetupDialogBase *CreatePageSetupDialog( wxWindow *parent,
+                                                          wxPageSetupDialogData * data = NULL );
+
+    virtual wxDC* CreatePrinterDC( const wxPrintData& data );
+
+    virtual bool HasPrintSetupDialog();
+    virtual wxDialog *CreatePrintSetupDialog( wxWindow *parent, wxPrintData *data );
+    virtual bool HasOwnPrintToFile();
+    virtual bool HasPrinterLine();
+    virtual wxString CreatePrinterLine();
+    virtual bool HasStatusLine();
+    virtual wxString CreateStatusLine();
+
+    virtual wxPrintNativeDataBase *CreatePrintNativeData();
+};
+
+//----------------------------------------------------------------------------
+// wxGtkPrintDialog
+//----------------------------------------------------------------------------
+
+class wxGtkPrintDialog: public wxPrintDialogBase
+{
+public:
+    wxGtkPrintDialog( wxWindow *parent,
+                         wxPrintDialogData* data = NULL );
+    wxGtkPrintDialog( wxWindow *parent, wxPrintData* data);
+    virtual ~wxGtkPrintDialog();
+
+    wxPrintData& GetPrintData()
+        { return m_printDialogData.GetPrintData(); }
+    wxPrintDialogData& GetPrintDialogData()
+        { return m_printDialogData; }
+
+    wxDC *GetPrintDC() { return m_dc; }
+    void SetPrintDC(wxDC * printDC) { m_dc = printDC; }
+
+    virtual int ShowModal();
+
+    virtual bool Validate() { return true; }
+    virtual bool TransferDataToWindow() { return true; }
+    virtual bool TransferDataFromWindow() { return true; }
+
+    void SetShowDialog(bool show) { m_showDialog = show; }
+    bool GetShowDialog() { return m_showDialog; }
+
+protected:
+    // Implement some base class methods to do nothing to avoid asserts and
+    // GTK warnings, since this is not a real wxDialog.
+    virtual void DoSetSize(int WXUNUSED(x), int WXUNUSED(y),
+                           int WXUNUSED(width), int WXUNUSED(height),
+                           int WXUNUSED(sizeFlags) = wxSIZE_AUTO) {}
+    virtual void DoMoveWindow(int WXUNUSED(x), int WXUNUSED(y),
+                              int WXUNUSED(width), int WXUNUSED(height)) {}
+
+private:
+    wxPrintDialogData    m_printDialogData;
+    wxWindow            *m_parent;
+    bool                 m_showDialog;
+    wxDC                *m_dc;
+
+    DECLARE_DYNAMIC_CLASS(wxGtkPrintDialog)
+};
+
+//----------------------------------------------------------------------------
+// wxGtkPageSetupDialog
+//----------------------------------------------------------------------------
+
+class wxGtkPageSetupDialog: public wxPageSetupDialogBase
+{
+public:
+    wxGtkPageSetupDialog( wxWindow *parent,
+                            wxPageSetupDialogData* data = NULL );
+    virtual ~wxGtkPageSetupDialog();
+
+    virtual wxPageSetupDialogData& GetPageSetupDialogData() { return m_pageDialogData; }
+
+    virtual int ShowModal();
+
+    virtual bool Validate() { return true; }
+    virtual bool TransferDataToWindow() { return true; }
+    virtual bool TransferDataFromWindow() { return true; }
+
+protected:
+    // Implement some base class methods to do nothing to avoid asserts and
+    // GTK warnings, since this is not a real wxDialog.
+    virtual void DoSetSize(int WXUNUSED(x), int WXUNUSED(y),
+                           int WXUNUSED(width), int WXUNUSED(height),
+                           int WXUNUSED(sizeFlags) = wxSIZE_AUTO) {}
+    virtual void DoMoveWindow(int WXUNUSED(x), int WXUNUSED(y),
+                              int WXUNUSED(width), int WXUNUSED(height)) {}
+
+private:
+    wxPageSetupDialogData    m_pageDialogData;
+    wxWindow                *m_parent;
+
+    DECLARE_DYNAMIC_CLASS(wxGtkPageSetupDialog)
+};
+
+//----------------------------------------------------------------------------
+// wxGtkPrinter
+//----------------------------------------------------------------------------
+
+class wxGtkPrinter : public wxPrinterBase
+{
+public:
+    wxGtkPrinter(wxPrintDialogData *data = NULL);
+    virtual ~wxGtkPrinter();
+
+    virtual bool Print(wxWindow *parent,
+                       wxPrintout *printout,
+                       bool prompt = true);
+    virtual wxDC* PrintDialog(wxWindow *parent);
+    virtual bool Setup(wxWindow *parent);
+
+    GtkPrintContext *GetPrintContext() { return m_gpc; }
+    void SetPrintContext(GtkPrintContext *context) {m_gpc = context;}
+    void BeginPrint(wxPrintout *printout, GtkPrintOperation *operation, GtkPrintContext *context);
+    void DrawPage(wxPrintout *printout, GtkPrintOperation *operation, GtkPrintContext *context, int page_nr);
+
+private:
+    GtkPrintContext *m_gpc;
+    bool             m_showDialog;
+    wxDC            *m_dc;
+
+    DECLARE_DYNAMIC_CLASS(wxGtkPrinter)
+    DECLARE_NO_COPY_CLASS(wxGtkPrinter)
+};
+
+//----------------------------------------------------------------------------
+// wxGtkPrintNativeData
+//----------------------------------------------------------------------------
+
+class wxGtkPrintNativeData : public wxPrintNativeDataBase
+{
+public:
+    wxGtkPrintNativeData();
+    virtual ~wxGtkPrintNativeData();
+
+    virtual bool TransferTo( wxPrintData &data );
+    virtual bool TransferFrom( const wxPrintData &data );
+
+    virtual bool Ok() const { return IsOk(); }
+    virtual bool IsOk() const { return true; }
+
+    GtkPrintSettings* GetPrintConfig() { return m_config; }
+    void SetPrintConfig( GtkPrintSettings * config );
+
+    void SetPrintJob( GtkPrintOperation *job ) { m_job = job; }
+    GtkPrintOperation* GetPrintJob() { return m_job; }
+
+    GtkPrintContext *GetPrintContext() { return m_context; }
+    void SetPrintContext(GtkPrintContext *context) {m_context = context; }
+
+
+    GtkPageSetup* GetPageSetupFromSettings(GtkPrintSettings* settings);
+    void SetPageSetupToSettings(GtkPrintSettings* settings, GtkPageSetup* page_setup);
+
+private:
+    GtkPrintSettings    *m_config;
+    GtkPrintOperation   *m_job;
+    GtkPrintContext     *m_context;
+
+    DECLARE_DYNAMIC_CLASS(wxGtkPrintNativeData)
+};
+
+//-----------------------------------------------------------------------------
+// wxGtkPrintDC
+//-----------------------------------------------------------------------------
+
+class wxGtkPrintDC: public wxDC
+{
+public:
+    wxGtkPrintDC( const wxPrintData& data );
+    virtual ~wxGtkPrintDC();
+
+    bool Ok() const { return IsOk(); }
+    bool IsOk() const;
+
+    bool CanDrawBitmap() const { return true; }
+    void Clear();
+    void SetFont( const wxFont& font );
+    void SetPen( const wxPen& pen );
+    void SetBrush( const wxBrush& brush );
+    void SetLogicalFunction( int function );
+    void SetBackground( const wxBrush& brush );
+    void DestroyClippingRegion();
+    bool StartDoc(const wxString& message);
+    void EndDoc();
+    void StartPage();
+    void EndPage();
+    wxCoord GetCharHeight() const;
+    wxCoord GetCharWidth() const;
+    bool CanGetTextExtent() const { return true; }
+    wxSize GetPPI() const;
+    void SetLogicalOrigin( wxCoord x, wxCoord y );
+    void SetDeviceOrigin( wxCoord x, wxCoord y );
+    virtual int GetDepth() const { return 24; }
+    void SetBackgroundMode(int WXUNUSED(mode));
+    void SetPalette(const wxPalette& WXUNUSED(palette)) { }
+    static void SetResolution(int ppi);
+    static int GetResolution();
+    void DrawScaledBitmap(const wxBitmap &bmp, wxCoord x, wxCoord y, wxCoord w, wxCoord h,
+                    bool useMask = false, int quality = wxIMAGE_QUALITY_NORMAL)
+        { DoDrawScaledBitmap( bmp, x, y, w, h, useMask, quality ); }
+    void DrawScaledBitmap(const wxBitmap &bmp, const wxPoint& pt, const wxSize& sz,
+                    bool useMask = false, int quality = wxIMAGE_QUALITY_NORMAL)
+        { DoDrawScaledBitmap( bmp, pt.x, pt.y, sz.x, sz.y, useMask, quality ); }
+    void DrawScaledBitmap(const wxBitmap &bmp, const wxRect& rect,
+                    bool useMask = false, int quality = wxIMAGE_QUALITY_NORMAL)
+        { DoDrawScaledBitmap( bmp, rect.x, rect.y, rect.width, rect.height, useMask, quality ); }
+
+protected:
+    bool DoFloodFill(wxCoord x1, wxCoord y1, const wxColour &col, int style=wxFLOOD_SURFACE );
+    void DoGradientFillConcentric(const wxRect& rect, const wxColour& initialColour, const wxColour& destColour, const wxPoint& circleCenter);
+    void DoGradientFillLinear(const wxRect& rect, const wxColour& initialColour, const wxColour& destColour, wxDirection nDirection = wxEAST);
+    bool DoGetPixel(wxCoord x1, wxCoord y1, wxColour *col) const;
+    void DoDrawLine(wxCoord x1, wxCoord y1, wxCoord x2, wxCoord y2);
+    void DoCrossHair(wxCoord x, wxCoord y);
+    void DoDrawArc(wxCoord x1,wxCoord y1,wxCoord x2,wxCoord y2,wxCoord xc,wxCoord yc);
+    void DoDrawEllipticArc(wxCoord x,wxCoord y,wxCoord w,wxCoord h,double sa,double ea);
+    void DoDrawPoint(wxCoord x, wxCoord y);
+    void DoDrawLines(int n, wxPoint points[], wxCoord xoffset = 0, wxCoord yoffset = 0);
+    void DoDrawPolygon(int n, wxPoint points[], wxCoord xoffset = 0, wxCoord yoffset = 0, int fillStyle=wxODDEVEN_RULE);
+    void DoDrawPolyPolygon(int n, int count[], wxPoint points[], wxCoord xoffset = 0, wxCoord yoffset = 0, int fillStyle=wxODDEVEN_RULE);
+    void DoDrawRectangle(wxCoord x, wxCoord y, wxCoord width, wxCoord height);
+    void DoDrawRoundedRectangle(wxCoord x, wxCoord y, wxCoord width, wxCoord height, double radius = 20.0);
+    void DoDrawEllipse(wxCoord x, wxCoord y, wxCoord width, wxCoord height);
+#if wxUSE_SPLINES
+    void DoDrawSpline(wxList *points);
+#endif // wxUSE_SPLINES
+    bool DoBlit(wxCoord xdest, wxCoord ydest, wxCoord width, wxCoord height,
+            wxDC *source, wxCoord xsrc, wxCoord ysrc, int rop = wxCOPY, bool useMask = false,
+            wxCoord xsrcMask = wxDefaultCoord, wxCoord ysrcMask = wxDefaultCoord);
+    void DoDrawIcon( const wxIcon& icon, wxCoord x, wxCoord y );
+    void DoDrawBitmap( const wxBitmap& bitmap, wxCoord x, wxCoord y, bool useMask = false  );
+    void DoDrawScaledBitmap( const wxBitmap& bitmap, wxCoord x, wxCoord y, wxCoord w, wxCoord h, bool useMask = false, int quality = wxIMAGE_QUALITY_NORMAL );
+    void DoDrawText(const wxString& text, wxCoord x, wxCoord y );
+    void DoDrawRotatedText(const wxString& text, wxCoord x, wxCoord y, double angle);
+    void DoSetClippingRegion(wxCoord x, wxCoord y, wxCoord width, wxCoord height);
+    void DoSetClippingRegionAsRegion( const wxRegion &WXUNUSED(clip) ) { }
+    void DoGetTextExtent(const wxString& string, wxCoord *x, wxCoord *y,
+                     wxCoord *descent = (wxCoord *) NULL,
+                     wxCoord *externalLeading = (wxCoord *) NULL,
+                     const wxFont *theFont = (wxFont *) NULL ) const;
+    void DoGetSize(int* width, int* height) const;
+    void DoGetSizeMM(int *width, int *height) const;
+
+    wxPrintData& GetPrintData() { return m_printData; }
+    void SetPrintData(const wxPrintData& data);
+
+    void ComputeScaleAndOrigin();
+
+private:
+    static float ms_PSScaleFactor;
+
+    wxPrintData             m_printData;
+    PangoContext           *m_context;
+    PangoLayout            *m_layout;
+    PangoFontDescription   *m_fontdesc;
+    cairo_t                *m_cairo;
+
+    unsigned char           m_currentRed;
+    unsigned char           m_currentGreen;
+    unsigned char           m_currentBlue;
+    unsigned char           m_currentAlpha;
+
+    int                     m_deviceOffsetY;
+    int                     m_deviceOffsetX;
+
+    GtkPrintContext      *m_gpc;
+    static int            ms_resolution;
+
+    wxCoord DeviceToLogicalX(wxCoord x) const
+    {
+        int addValue = 0;
+        if (m_signX == -1) addValue = m_deviceOffsetX - m_deviceOriginX; // right to left
+        else addValue = m_deviceOriginX;// left to right
+        return (wxCoord) ((double)(x - addValue) * m_signX + m_logicalOriginX);
+    }
+    wxCoord DeviceToLogicalXRel(wxCoord x) const
+    {
+        return x;
+    }
+    wxCoord DeviceToLogicalY(wxCoord y) const
+    {
+        int addValue = 0;
+        if (m_signY == -1) addValue = m_deviceOffsetY - m_deviceOriginY; // bottom to up
+        else addValue = m_deviceOriginY;// up to bottom
+        return (wxCoord) ((double)(y - addValue) * m_signY + m_logicalOriginY);
+    }
+    wxCoord DeviceToLogicalYRel(wxCoord y) const
+    {
+        return y;
+    }
+    wxCoord LogicalToDeviceX(wxCoord x) const
+    {
+        int addValue = 0;
+        if (m_signX == -1) addValue = m_deviceOffsetX - m_deviceOriginX; // right to left
+        else addValue = m_deviceOriginX;// left to right
+        return (wxCoord) ((double)(x - m_logicalOriginX) * m_signX + addValue);
+    }
+    wxCoord LogicalToDeviceXRel(wxCoord x) const
+    {
+        return x;
+    }
+    wxCoord LogicalToDeviceY(wxCoord y) const
+    {
+        int addValue = 0;
+        if (m_signY == -1) addValue = m_deviceOffsetY - m_deviceOriginY; // bottom to up
+        else addValue = m_deviceOriginY;// up to bottom
+        return (wxCoord) ((double)(y - m_logicalOriginY)  * m_signY + addValue);
+    }
+    wxCoord LogicalToDeviceYRel(wxCoord y) const
+    {
+        return y;
+    }
+
+    DECLARE_DYNAMIC_CLASS(wxGtkPrintDC)
+    DECLARE_NO_COPY_CLASS(wxGtkPrintDC)
+};
+
+// ----------------------------------------------------------------------------
+// wxGtkPrintPreview: programmer creates an object of this class to preview a
+// wxPrintout.
+// ----------------------------------------------------------------------------
+
+class wxGtkPrintPreview : public wxPrintPreviewBase
+{
+public:
+    wxGtkPrintPreview(wxPrintout *printout,
+                             wxPrintout *printoutForPrinting = (wxPrintout *) NULL,
+                             wxPrintDialogData *data = (wxPrintDialogData *) NULL);
+    wxGtkPrintPreview(wxPrintout *printout,
+                             wxPrintout *printoutForPrinting,
+                             wxPrintData *data);
+
+    virtual ~wxGtkPrintPreview();
+
+    virtual bool Print(bool interactive);
+    virtual void DetermineScaling();
+
+private:
+    void Init(wxPrintout *printout, wxPrintout *printoutForPrinting);
+
+    DECLARE_CLASS(wxGtkPrintPreview)
+};
+
+#endif
+    // wxUSE_GTKPRINT
+
+#endif
diff -aburN ../original/setup.h.in ./setup.h.in
--- ../original/setup.h.in	2007-08-26 12:54:36.000000000 +0200
+++ ./setup.h.in	2007-08-30 15:13:10.000000000 +0200
@@ -702,6 +702,10 @@
 #define wxUSE_PLUGINS 0
 
 /*
+ * Use GTK print for printing under GTK+ 2.0
+ */
+#define wxUSE_GTKPRINT 0
+/*
  * Use GNOME print for printing under GTK+ 2.0
  */
 #define wxUSE_LIBGNOMEPRINT 0
diff -aburN ../original/setup.h_vms ./setup.h_vms
--- ../original/setup.h_vms	2007-08-26 12:54:36.000000000 +0200
+++ ./setup.h_vms	2007-08-31 14:32:00.000000000 +0200
@@ -690,6 +690,10 @@
  */
 #define wxUSE_LIBSDL 0
 /*
+ * Use GTK print for printing under GTK+ 2.0
+ */
+#define wxUSE_GTKPRINT 0
+/*
  * Use GNOME print for printing under GTK+ 2.0
  */
 #define wxUSE_LIBGNOMEPRINT 0
diff -aburN ../original/src/generic/prntdlgg.cpp ./src/generic/prntdlgg.cpp
--- ../original/src/generic/prntdlgg.cpp	2007-08-26 12:48:14.000000000 +0200
+++ ./src/generic/prntdlgg.cpp	2007-08-31 12:59:04.000000000 +0200
@@ -67,6 +67,11 @@
     wxFORCE_LINK_MODULE(gnome_print)
 #endif
 
+#if wxUSE_GTKPRINT
+    #include "wx/link.h"
+    wxFORCE_LINK_MODULE(gtk_print)
+#endif
+
 // ----------------------------------------------------------------------------
 // global vars
 // ----------------------------------------------------------------------------
diff -aburN ../original/src/gtk/gnome/gprint.cpp ./src/gtk/gnome/gprint.cpp
--- ../original/src/gtk/gnome/gprint.cpp	2007-08-26 12:45:16.000000000 +0200
+++ ./src/gtk/gnome/gprint.cpp	2007-08-31 14:27:44.000000000 +0200
@@ -1972,17 +1972,9 @@
     return 72;
 }
 
-
-class wxGnomePrintModule: public wxModule
-{
-public:
-    wxGnomePrintModule() {}
-    bool OnInit();
-    void OnExit();
-
-private:
-    DECLARE_DYNAMIC_CLASS(wxGnomePrintModule)
-};
+// ----------------------------------------------------------------------------
+// wxGnomePrintModule
+// ----------------------------------------------------------------------------
 
 bool wxGnomePrintModule::OnInit()
 {
diff -aburN ../original/src/gtk/print.cpp ./src/gtk/print.cpp
--- ../original/src/gtk/print.cpp	1970-01-01 01:00:00.000000000 +0100
+++ ./src/gtk/print.cpp	2007-08-31 15:40:12.000000000 +0200
@@ -0,0 +1,2640 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/gtk/print.cpp
+// Author:      Anthony Bretaudeau
+// Purpose:     GTK printing support
+// Created:     2007-08-25
+// RCS-ID:      $Id: print.cpp,v 1 2007-08-25 05:44:44 PC Exp $
+// Copyright:   (c) 2007 wxWidgets development team
+// Licence:     wxWindows Licence
+/////////////////////////////////////////////////////////////////////////////
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+
+#if wxUSE_GTKPRINT
+
+#include "wx/gtk/print.h"
+
+#ifndef WX_PRECOMP
+#include "wx/log.h"
+#include "wx/dcmemory.h"
+#include "wx/icon.h"
+#include "wx/math.h"
+#include "wx/image.h"
+#include "wx/module.h"
+#endif
+
+#include "wx/fontutil.h"
+#include "wx/gtk/private.h"
+#include "wx/dynlib.h"
+#include "wx/paper.h"
+#include "wx/rawbmp.h"
+#include "wx/gtk/gnome/gprint.h"
+
+#include <gtk/gtk.h>
+#include <gtk/gtkpagesetupunixdialog.h>
+
+
+// Usefull to convert angles from/to Rad to/from Deg.
+static const double RAD2DEG  = 180.0 / M_PI;
+static const double DEG2RAD  = M_PI / 180.0;
+
+// We use it to pass usefull objets to gtk printing callback functions.
+typedef struct
+{
+   wxGtkPrinter * printer;
+   wxPrintout * printout;
+}
+wxPrinterToGtkData;
+
+#include "wx/link.h"
+wxFORCE_LINK_THIS_MODULE(gtk_print)
+
+//----------------------------------------------------------------------------
+// wxGtkPrintLibrary
+//----------------------------------------------------------------------------
+
+#define wxDL_METHOD_DEFINE( rettype, name, args, shortargs, defret ) \
+    typedef rettype (* name ## Type) args ; \
+    name ## Type pfn_ ## name; \
+    rettype name args \
+    { if (m_ok) return pfn_ ## name shortargs ; return defret; }
+
+#define wxDL_METHOD_LOAD( lib, name, success ) \
+    pfn_ ## name = (name ## Type) lib->GetSymbol( wxT(#name), &success ); \
+    if (!success) return;
+
+class wxGtkPrintLibrary
+{
+public:
+    wxGtkPrintLibrary();
+    ~wxGtkPrintLibrary();
+
+    bool IsOk();
+    void InitializeMethods();
+
+private:
+    bool              m_ok;
+    wxDynamicLibrary *m_gtk_print_lib;
+
+public:
+    wxDL_METHOD_DEFINE( gdouble, gtk_page_setup_get_bottom_margin,
+        (GtkPageSetup *setup, GtkUnit unit), (setup, unit), 0)
+    wxDL_METHOD_DEFINE( gdouble, gtk_page_setup_get_left_margin,
+        (GtkPageSetup *setup, GtkUnit unit), (setup, unit), 0)
+    wxDL_METHOD_DEFINE( GtkPageOrientation, gtk_page_setup_get_orientation,
+        (GtkPageSetup *setup), (setup), GTK_PAGE_ORIENTATION_PORTRAIT)
+    wxDL_METHOD_DEFINE( gdouble, gtk_page_setup_get_page_height,
+        (GtkPageSetup *setup, GtkUnit unit), (setup, unit), 0)
+    wxDL_METHOD_DEFINE( gdouble, gtk_page_setup_get_page_width,
+        (GtkPageSetup *setup, GtkUnit unit), (setup, unit), 0)
+    wxDL_METHOD_DEFINE( gdouble, gtk_page_setup_get_paper_height,
+        (GtkPageSetup *setup, GtkUnit unit), (setup, unit), 0)
+    wxDL_METHOD_DEFINE( GtkPaperSize*, gtk_page_setup_get_paper_size,
+        (GtkPageSetup *setup), (setup), NULL)
+    wxDL_METHOD_DEFINE( gdouble, gtk_page_setup_get_paper_width,
+        (GtkPageSetup *setup, GtkUnit unit), (setup, unit), 0)
+    wxDL_METHOD_DEFINE( gdouble, gtk_page_setup_get_right_margin,
+        (GtkPageSetup *setup, GtkUnit unit), (setup, unit), 0)
+    wxDL_METHOD_DEFINE( gdouble, gtk_page_setup_get_top_margin,
+        (GtkPageSetup *setup, GtkUnit unit), (setup, unit), 0)
+    wxDL_METHOD_DEFINE( GtkPageSetup*, gtk_page_setup_new,
+        (void), (), NULL)
+    wxDL_METHOD_DEFINE( void, gtk_page_setup_set_orientation,
+        (GtkPageSetup *setup, GtkPageOrientation orientation), (setup, orientation), /**/)
+    wxDL_METHOD_DEFINE( void, gtk_page_setup_set_paper_size_and_default_margins,
+        (GtkPageSetup *setup, GtkPaperSize *size), (setup, size), /**/)
+
+    wxDL_METHOD_DEFINE( gboolean, gtk_paper_size_is_equal,
+        (GtkPaperSize *size1, GtkPaperSize *size2), (size1, size2), false )
+    wxDL_METHOD_DEFINE( GtkPaperSize*, gtk_paper_size_new,
+        (const gchar *name), (name), NULL )
+    wxDL_METHOD_DEFINE( GtkPaperSize*, gtk_paper_size_new_custom,
+        (const gchar *name, const gchar *display_name, gdouble width, gdouble height, GtkUnit unit), (name, display_name, width, height, unit), NULL )
+
+    wxDL_METHOD_DEFINE( PangoContext*, gtk_print_context_create_pango_context,
+        (GtkPrintContext *context), (context), 0 )
+    wxDL_METHOD_DEFINE( PangoLayout*, gtk_print_context_create_pango_layout,
+        (GtkPrintContext *context), (context), 0 )
+    wxDL_METHOD_DEFINE( cairo_t*, gtk_print_context_get_cairo_context,
+        (GtkPrintContext *context), (context), 0 )
+    wxDL_METHOD_DEFINE( gdouble, gtk_print_context_get_dpi_x,
+        (GtkPrintContext *context), (context), 0 )
+    wxDL_METHOD_DEFINE( gdouble, gtk_print_context_get_dpi_y,
+        (GtkPrintContext *context), (context), 0 )
+    wxDL_METHOD_DEFINE( gdouble, gtk_print_context_get_height,
+        (GtkPrintContext *context), (context), 0 )
+    wxDL_METHOD_DEFINE( GtkPageSetup*, gtk_print_context_get_page_setup,
+        (GtkPrintContext *context), (context), 0 )
+    wxDL_METHOD_DEFINE( gdouble, gtk_print_context_get_width,
+        (GtkPrintContext *context), (context), 0 )
+    wxDL_METHOD_DEFINE( void, gtk_print_context_set_cairo_context,
+        (GtkPrintContext *context, cairo_t *cr, double dpi_x, double dpi_y), (context, cr, dpi_x, dpi_y), /**/ )
+
+    wxDL_METHOD_DEFINE( GtkPrintSettings*, gtk_print_operation_get_print_settings,
+        (GtkPrintOperation *op), (op), NULL )
+    wxDL_METHOD_DEFINE( GtkPrintOperation*, gtk_print_operation_new,
+        (void), (), NULL )
+    wxDL_METHOD_DEFINE( GtkPrintOperationResult, gtk_print_operation_run,
+        (GtkPrintOperation *op, GtkPrintOperationAction action, GtkWindow *parent, GError **error), (op, action, parent, error), GTK_PRINT_OPERATION_RESULT_ERROR )
+    wxDL_METHOD_DEFINE( void, gtk_print_operation_set_default_page_setup,
+        (GtkPrintOperation *op, GtkPageSetup *default_page_setup), (op, default_page_setup), /**/ )
+    wxDL_METHOD_DEFINE( void, gtk_print_operation_set_n_pages,
+        (GtkPrintOperation *op, gint n_pages), (op, n_pages), /**/ )
+    wxDL_METHOD_DEFINE( void, gtk_print_operation_set_print_settings,
+        (GtkPrintOperation *op, GtkPrintSettings *print_settings), (op, print_settings), /**/ )
+
+    wxDL_METHOD_DEFINE( GtkPageSetup*, gtk_print_run_page_setup_dialog,
+        (GtkWindow *parent, GtkPageSetup *page_setup, GtkPrintSettings *settings), (parent, page_setup, settings), NULL )
+
+    wxDL_METHOD_DEFINE( GtkPrintSettings*, gtk_print_settings_copy,
+        (GtkPrintSettings *other), (other), NULL )
+    wxDL_METHOD_DEFINE( gboolean, gtk_print_settings_get_collate,
+        (GtkPrintSettings *settings), (settings), false )
+    wxDL_METHOD_DEFINE( GtkPrintDuplex, gtk_print_settings_get_duplex,
+        (GtkPrintSettings *settings), (settings), GTK_PRINT_DUPLEX_SIMPLEX )
+    wxDL_METHOD_DEFINE( gint, gtk_print_settings_get_n_copies,
+        (GtkPrintSettings *settings), (settings), 0 )
+    wxDL_METHOD_DEFINE( GtkPageOrientation, gtk_print_settings_get_orientation,
+        (GtkPrintSettings *settings), (settings), GTK_PAGE_ORIENTATION_PORTRAIT )
+    wxDL_METHOD_DEFINE( GtkPaperSize*, gtk_print_settings_get_paper_size,
+        (GtkPrintSettings *settings), (settings), NULL )
+    wxDL_METHOD_DEFINE( GtkPrintPages, gtk_print_settings_get_print_pages,
+        (GtkPrintSettings *settings), (settings), GTK_PRINT_PAGES_ALL )
+    wxDL_METHOD_DEFINE( GtkPrintQuality, gtk_print_settings_get_quality,
+        (GtkPrintSettings *settings), (settings), GTK_PRINT_QUALITY_NORMAL )
+    wxDL_METHOD_DEFINE( GtkPageRange*, gtk_print_settings_get_page_ranges,
+        (GtkPrintSettings *settings, gint *num_ranges), (settings, num_ranges), NULL )
+    wxDL_METHOD_DEFINE( gboolean, gtk_print_settings_get_use_color,
+        (GtkPrintSettings *settings), (settings), false )
+    wxDL_METHOD_DEFINE( GtkPrintSettings*, gtk_print_settings_new,
+        (void), (), NULL )
+    wxDL_METHOD_DEFINE( void, gtk_print_settings_set_collate,
+        (GtkPrintSettings *settings, gboolean collate), (settings, collate), /**/ )
+    wxDL_METHOD_DEFINE( void, gtk_print_settings_set_duplex,
+        (GtkPrintSettings *settings, GtkPrintDuplex duplex), (settings, duplex), /**/ )
+    wxDL_METHOD_DEFINE( void, gtk_print_settings_set_n_copies,
+        (GtkPrintSettings *settings, gint num_copies), (settings, num_copies), /**/ )
+    wxDL_METHOD_DEFINE( void, gtk_print_settings_set_orientation,
+        (GtkPrintSettings *settings, GtkPageOrientation orientation), (settings, orientation), /**/ )
+    wxDL_METHOD_DEFINE( void, gtk_print_settings_set_page_ranges,
+        (GtkPrintSettings *settings, GtkPageRange *page_ranges, gint num_ranges), (settings, page_ranges, num_ranges), /**/ )
+    wxDL_METHOD_DEFINE( void, gtk_print_settings_set_paper_size,
+        (GtkPrintSettings *settings, GtkPaperSize *paper_size), (settings, paper_size), /**/ )
+    wxDL_METHOD_DEFINE( void, gtk_print_settings_set_print_pages,
+        (GtkPrintSettings *settings, GtkPrintPages pages), (settings, pages), /**/ )
+    wxDL_METHOD_DEFINE( void, gtk_print_settings_set_quality,
+        (GtkPrintSettings *settings, GtkPrintQuality quality), (settings, quality), /**/ )
+    wxDL_METHOD_DEFINE( void, gtk_print_settings_set_resolution,
+        (GtkPrintSettings *settings, gint resolution), (settings, resolution), /**/ )
+    wxDL_METHOD_DEFINE( void, gtk_print_settings_set_use_color,
+        (GtkPrintSettings *settings, gboolean use_color), (settings, use_color), /**/ )
+
+    DECLARE_NO_COPY_CLASS(wxGtkPrintLibrary)
+};
+
+wxGtkPrintLibrary::wxGtkPrintLibrary()
+{
+    m_gtk_print_lib = NULL;
+
+    wxLogNull log;
+    m_gtk_print_lib = new wxDynamicLibrary( wxT("libgtk-x11-2.0.so") );
+    m_ok = m_gtk_print_lib->IsLoaded();
+    if (!m_ok) return;
+
+    InitializeMethods();
+}
+
+wxGtkPrintLibrary::~wxGtkPrintLibrary()
+{
+    if (m_gtk_print_lib)
+        delete m_gtk_print_lib;
+}
+
+bool wxGtkPrintLibrary::IsOk()
+{
+    return m_ok;
+}
+
+void wxGtkPrintLibrary::InitializeMethods()
+{
+    m_ok = false;
+    bool success;
+
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_page_setup_get_bottom_margin, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_page_setup_get_left_margin, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_page_setup_get_orientation, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_page_setup_get_page_height, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_page_setup_get_page_width, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_page_setup_get_paper_height, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_page_setup_get_paper_size, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_page_setup_get_paper_width, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_page_setup_get_right_margin, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_page_setup_get_top_margin, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_page_setup_new, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_page_setup_set_orientation, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_page_setup_set_paper_size_and_default_margins, success )
+
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_paper_size_is_equal, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_paper_size_new, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_paper_size_new_custom, success )
+
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_context_create_pango_context, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_context_create_pango_layout, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_context_get_cairo_context, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_context_get_dpi_x, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_context_get_dpi_y, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_context_get_height, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_context_get_page_setup, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_context_get_width, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_context_set_cairo_context, success )
+
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_operation_get_print_settings, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_operation_new, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_operation_run, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_operation_set_default_page_setup, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_operation_set_n_pages, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_operation_set_print_settings, success )
+
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_run_page_setup_dialog, success )
+
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_settings_copy, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_settings_get_collate, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_settings_get_duplex, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_settings_get_n_copies, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_settings_get_orientation, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_settings_get_paper_size, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_settings_get_print_pages, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_settings_get_page_ranges, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_settings_get_quality, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_settings_get_use_color, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_settings_new, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_settings_set_collate, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_settings_set_duplex, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_settings_set_n_copies, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_settings_set_orientation, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_settings_set_page_ranges, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_settings_set_paper_size, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_settings_set_print_pages, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_settings_set_quality, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_settings_set_resolution, success )
+    wxDL_METHOD_LOAD( m_gtk_print_lib, gtk_print_settings_set_use_color, success )
+
+    m_ok = true;
+}
+
+static wxGtkPrintLibrary* gs_gp = NULL;
+
+//----------------------------------------------------------------------------
+// wxGtkPrintModule
+// Initialized when starting the app : if it successfully load the gtk-print framework,
+// it uses it. If not, it falls back to gnome print (see /gtk/gnome/gprint.cpp) then
+// to postscript if gnomeprint is not available.
+//----------------------------------------------------------------------------
+
+class wxGtkPrintModule: public wxModule
+{
+public:
+    wxGtkPrintModule() {AddDependency(CLASSINFO(wxGnomePrintModule));} // This module must be initialized AFTER gnomeprint's one
+    bool OnInit();
+    void OnExit();
+
+private:
+    DECLARE_DYNAMIC_CLASS(wxGtkPrintModule)
+};
+
+bool wxGtkPrintModule::OnInit()
+{
+    gs_gp = new wxGtkPrintLibrary;
+    if (gs_gp->IsOk())
+        wxPrintFactory::SetPrintFactory( new wxGtkPrintFactory );
+    return true;
+}
+
+void wxGtkPrintModule::OnExit()
+{
+    delete gs_gp;
+}
+
+IMPLEMENT_DYNAMIC_CLASS(wxGtkPrintModule, wxModule)
+
+//----------------------------------------------------------------------------
+// wxGtkPrintFactory
+//----------------------------------------------------------------------------
+
+wxPrinterBase* wxGtkPrintFactory::CreatePrinter( wxPrintDialogData *data )
+{
+    return new wxGtkPrinter( data );
+}
+
+wxPrintPreviewBase *wxGtkPrintFactory::CreatePrintPreview( wxPrintout *preview,
+                                                    wxPrintout *printout,
+                                                    wxPrintDialogData *data )
+{
+    return new wxGtkPrintPreview( preview, printout, data );
+}
+
+wxPrintPreviewBase *wxGtkPrintFactory::CreatePrintPreview( wxPrintout *preview,
+                                                    wxPrintout *printout,
+                                                    wxPrintData *data )
+{
+    return new wxGtkPrintPreview( preview, printout, data );
+}
+
+wxPrintDialogBase *wxGtkPrintFactory::CreatePrintDialog( wxWindow *parent,
+                                                  wxPrintDialogData *data )
+{
+    return new wxGtkPrintDialog( parent, data );
+}
+
+wxPrintDialogBase *wxGtkPrintFactory::CreatePrintDialog( wxWindow *parent,
+                                                  wxPrintData *data )
+{
+    return new wxGtkPrintDialog( parent, data );
+}
+
+wxPageSetupDialogBase *wxGtkPrintFactory::CreatePageSetupDialog( wxWindow *parent,
+                                                          wxPageSetupDialogData * data )
+{
+    return new wxGtkPageSetupDialog( parent, data );
+}
+
+bool wxGtkPrintFactory::HasPrintSetupDialog()
+{
+    return false;
+}
+
+wxDialog *wxGtkPrintFactory::CreatePrintSetupDialog( wxWindow *parent, wxPrintData *data )
+{
+    return NULL;
+}
+
+wxDC* wxGtkPrintFactory::CreatePrinterDC( const wxPrintData& data )
+{
+    return new wxGtkPrintDC(data);
+}
+
+bool wxGtkPrintFactory::HasOwnPrintToFile()
+{
+    return true;
+}
+
+bool wxGtkPrintFactory::HasPrinterLine()
+{
+    return true;
+}
+
+wxString wxGtkPrintFactory::CreatePrinterLine()
+{
+    // redundant now
+    return wxEmptyString;
+}
+
+bool wxGtkPrintFactory::HasStatusLine()
+{
+    // redundant now
+    return true;
+}
+
+wxString wxGtkPrintFactory::CreateStatusLine()
+{
+    // redundant now
+    return wxEmptyString;
+}
+
+wxPrintNativeDataBase *wxGtkPrintFactory::CreatePrintNativeData()
+{
+    return new wxGtkPrintNativeData;
+}
+
+
+// Callback functions for Gtk Printings.
+extern "C"
+{
+    static void gtk_begin_print_callback (GtkPrintOperation *operation, GtkPrintContext *context, gpointer user_data)
+    {
+        wxPrinterToGtkData *data = (wxPrinterToGtkData *) user_data;
+
+        data->printer->BeginPrint(data->printout, operation, context);
+    }
+
+    static void gtk_draw_page_print_callback (GtkPrintOperation *operation, GtkPrintContext *context, gint page_nr, gpointer user_data)
+    {
+        wxPrinterToGtkData *data = (wxPrinterToGtkData *) user_data;
+
+        data->printer->DrawPage(data->printout, operation, context, page_nr);
+    }
+
+    static void gtk_end_print_callback (GtkPrintOperation *operation, GtkPrintContext *context, gpointer user_data)
+    {
+        wxPrintout *printout = (wxPrintout *) user_data;
+
+        printout->OnEndPrinting();
+    }
+
+    static gboolean gtk_preview_print_callback (GtkPrintOperation *operation, GtkPrintOperationPreview *preview, GtkPrintContext *context, GtkWindow *parent, gpointer user_data)
+    {
+        wxPrintout *printout = (wxPrintout *) user_data;
+
+        printout->SetIsPreview(true);
+
+        /* We create a cairo context with 72dpi resolution. This resolution is only used for positionning. */
+        cairo_t *cairo = gdk_cairo_create(GTK_WIDGET(parent)->window);
+        gs_gp->gtk_print_context_set_cairo_context(context, cairo, 72, 72);
+
+        return false;
+    }
+}
+
+
+//----------------------------------------------------------------------------
+// wxGtkPrintNativeData
+//----------------------------------------------------------------------------
+
+IMPLEMENT_CLASS(wxGtkPrintNativeData, wxPrintNativeDataBase)
+
+wxGtkPrintNativeData::wxGtkPrintNativeData()
+{
+    m_config = gs_gp->gtk_print_settings_new();
+}
+
+wxGtkPrintNativeData::~wxGtkPrintNativeData()
+{
+    g_object_unref (m_config);
+}
+
+// Convert datas stored in m_config to a wxPrintData.
+// Called by wxPrintData::ConvertFromNative().
+bool wxGtkPrintNativeData::TransferTo( wxPrintData &data )
+{
+    if(!m_config)
+        return false;
+
+    GtkPrintQuality quality = gs_gp->gtk_print_settings_get_quality(m_config);
+    if (quality == GTK_PRINT_QUALITY_HIGH)
+        data.SetQuality(wxPRINT_QUALITY_HIGH);
+    else if (quality == GTK_PRINT_QUALITY_LOW)
+        data.SetQuality(wxPRINT_QUALITY_LOW);
+    else if (quality == GTK_PRINT_QUALITY_DRAFT)
+        data.SetQuality(wxPRINT_QUALITY_DRAFT);
+    else
+        data.SetQuality(wxPRINT_QUALITY_MEDIUM);
+
+    data.SetNoCopies(gs_gp->gtk_print_settings_get_n_copies(m_config));
+
+    data.SetColour(gs_gp->gtk_print_settings_get_use_color(m_config));
+
+    switch (gs_gp->gtk_print_settings_get_duplex(m_config))
+    {
+        case GTK_PRINT_DUPLEX_SIMPLEX:      data.SetDuplex (wxDUPLEX_SIMPLEX);
+                                            break;
+
+        case GTK_PRINT_DUPLEX_HORIZONTAL:   data.SetDuplex (wxDUPLEX_HORIZONTAL);
+                                            break;
+
+        default:
+        case GTK_PRINT_DUPLEX_VERTICAL:      data.SetDuplex (wxDUPLEX_VERTICAL);
+                                            break;
+    }
+
+    GtkPageOrientation orientation = gs_gp->gtk_print_settings_get_orientation (m_config);
+    if (orientation == GTK_PAGE_ORIENTATION_PORTRAIT)
+    {
+        data.SetOrientation(wxPORTRAIT);
+        data.SetOrientationReversed(false);
+    }
+    else if (orientation == GTK_PAGE_ORIENTATION_LANDSCAPE)
+    {
+        data.SetOrientation(wxLANDSCAPE);
+        data.SetOrientationReversed(false);
+    }
+    else if (orientation == GTK_PAGE_ORIENTATION_REVERSE_PORTRAIT)
+    {
+        data.SetOrientation(wxPORTRAIT);
+        data.SetOrientationReversed(true);
+    }
+    else if (orientation == GTK_PAGE_ORIENTATION_REVERSE_LANDSCAPE)
+    {
+        data.SetOrientation(wxLANDSCAPE);
+        data.SetOrientationReversed(true);
+    }
+
+    data.SetCollate(gs_gp->gtk_print_settings_get_collate (m_config));
+
+    // Paper formats : these are the most common paper formats.
+    GtkPaperSize *paper_size = gs_gp->gtk_print_settings_get_paper_size (m_config);
+    if (!paper_size)
+        data.SetPaperId(wxPAPER_NONE);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new (GTK_PAPER_NAME_A3)))
+        data.SetPaperId(wxPAPER_A3);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new (GTK_PAPER_NAME_A4)))
+        data.SetPaperId(wxPAPER_A4);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new (GTK_PAPER_NAME_A5)))
+        data.SetPaperId(wxPAPER_A5);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new (GTK_PAPER_NAME_B5)))
+        data.SetPaperId(wxPAPER_B5);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new (GTK_PAPER_NAME_LETTER)))
+        data.SetPaperId(wxPAPER_LETTER);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new (GTK_PAPER_NAME_LEGAL)))
+        data.SetPaperId(wxPAPER_LEGAL);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new (GTK_PAPER_NAME_EXECUTIVE)))
+        data.SetPaperId(wxPAPER_EXECUTIVE);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"na_number-10")))
+        data.SetPaperId(wxPAPER_ENV_10);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"iso-c5")))
+        data.SetPaperId(wxPAPER_ENV_C5);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"iso-c6")))
+        data.SetPaperId(wxPAPER_ENV_C6);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"jis-b5")))
+        data.SetPaperId(wxPAPER_B5_TRANSVERSE);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"iso-b5")))
+        data.SetPaperId(wxPAPER_ENV_B5);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"na_monarch")))
+        data.SetPaperId(wxPAPER_ENV_MONARCH);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"engineering-c")))
+        data.SetPaperId( wxPAPER_CSHEET);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"engineering-d")))
+        data.SetPaperId( wxPAPER_DSHEET);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"engineering-e")))
+        data.SetPaperId( wxPAPER_ESHEET);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"letter")))
+        data.SetPaperId( wxPAPER_LETTERSMALL);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"engineering-b")))
+        data.SetPaperId( wxPAPER_TABLOID);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"ledger")))
+        data.SetPaperId( wxPAPER_LEDGER);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"statement")))
+        data.SetPaperId( wxPAPER_STATEMENT);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( GTK_PAPER_NAME_A4 )))
+        data.SetPaperId( wxPAPER_A4SMALL);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"iso-b4")))
+        data.SetPaperId( wxPAPER_B4);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"folio")))
+        data.SetPaperId( wxPAPER_FOLIO);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"quarto")))
+        data.SetPaperId( wxPAPER_QUARTO);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"10x14")))
+        data.SetPaperId( wxPAPER_10X14);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"ledger")))
+        data.SetPaperId( wxPAPER_11X17);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"letter")))
+        data.SetPaperId( wxPAPER_NOTE);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"na-number-9-envelope")))
+        data.SetPaperId( wxPAPER_ENV_9);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"number-11")))
+        data.SetPaperId( wxPAPER_ENV_11);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"number-12")))
+        data.SetPaperId( wxPAPER_ENV_12);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"number-14")))
+        data.SetPaperId( wxPAPER_ENV_14);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"iso-designated")))
+        data.SetPaperId( wxPAPER_ENV_DL);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"iso-c3")))
+        data.SetPaperId( wxPAPER_ENV_C3);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"iso-c4")))
+        data.SetPaperId( wxPAPER_ENV_C4);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"c6/c5")))
+        data.SetPaperId( wxPAPER_ENV_C65);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"iso-b4")))
+        data.SetPaperId( wxPAPER_ENV_B4);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"iso-b6")))
+            data.SetPaperId( wxPAPER_ENV_B6);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"Italian")))
+        data.SetPaperId( wxPAPER_ENV_ITALY);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"personal")))
+        data.SetPaperId( wxPAPER_ENV_PERSONAL);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"fanfold-us")))
+        data.SetPaperId( wxPAPER_FANFOLD_US);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"fanfold-European")))
+        data.SetPaperId( wxPAPER_FANFOLD_STD_GERMAN);
+    else if (gs_gp->gtk_paper_size_is_equal(paper_size,gs_gp->gtk_paper_size_new ( (const gchar*)"foolscap")))
+        data.SetPaperId( wxPAPER_FANFOLD_LGL_GERMAN);
+    else
+        data.SetPaperId(wxPAPER_NONE);
+    return true;
+}
+
+// Put datas given by the wxPrintData into m_config.
+// Called by wxPrintData::ConvertToNative().
+bool wxGtkPrintNativeData::TransferFrom( const wxPrintData &data )
+{
+    if(!m_config)
+        return false;
+
+    wxPrintQuality quality = data.GetQuality();
+    if (quality == wxPRINT_QUALITY_HIGH)
+        gs_gp->gtk_print_settings_set_quality (m_config, GTK_PRINT_QUALITY_HIGH);
+    else if (quality == wxPRINT_QUALITY_MEDIUM)
+        gs_gp->gtk_print_settings_set_quality (m_config, GTK_PRINT_QUALITY_NORMAL);
+    else if (quality == wxPRINT_QUALITY_LOW)
+        gs_gp->gtk_print_settings_set_quality (m_config, GTK_PRINT_QUALITY_LOW);
+    else if (quality == wxPRINT_QUALITY_DRAFT)
+        gs_gp->gtk_print_settings_set_quality (m_config, GTK_PRINT_QUALITY_DRAFT);
+    else if (quality > 1)
+        gs_gp->gtk_print_settings_set_resolution (m_config, quality);
+    else
+        gs_gp->gtk_print_settings_set_quality (m_config, GTK_PRINT_QUALITY_NORMAL);
+
+    gs_gp->gtk_print_settings_set_n_copies(m_config, data.GetNoCopies());
+
+    gs_gp->gtk_print_settings_set_use_color(m_config, data.GetColour());
+
+    switch (data.GetDuplex())
+    {
+        case wxDUPLEX_SIMPLEX:      gs_gp->gtk_print_settings_set_duplex (m_config, GTK_PRINT_DUPLEX_SIMPLEX);
+                                break;
+
+        case wxDUPLEX_HORIZONTAL:   gs_gp->gtk_print_settings_set_duplex (m_config, GTK_PRINT_DUPLEX_HORIZONTAL);
+                                break;
+
+        default:
+        case wxDUPLEX_VERTICAL:      gs_gp->gtk_print_settings_set_duplex (m_config, GTK_PRINT_DUPLEX_VERTICAL);
+                                break;
+    }
+
+    if (!data.IsOrientationReversed())
+    {
+        if (data.GetOrientation() == wxLANDSCAPE)
+            gs_gp->gtk_print_settings_set_orientation (m_config, GTK_PAGE_ORIENTATION_LANDSCAPE);
+        else
+            gs_gp->gtk_print_settings_set_orientation (m_config, GTK_PAGE_ORIENTATION_PORTRAIT);
+    }
+    else {
+        if (data.GetOrientation() == wxLANDSCAPE)
+            gs_gp->gtk_print_settings_set_orientation (m_config, GTK_PAGE_ORIENTATION_REVERSE_LANDSCAPE);
+        else
+            gs_gp->gtk_print_settings_set_orientation (m_config, GTK_PAGE_ORIENTATION_REVERSE_PORTRAIT);
+    }
+
+    gs_gp->gtk_print_settings_set_collate (m_config, data.GetCollate());
+
+    // Paper formats: these are the most common paper formats.
+    switch (data.GetPaperId())
+    {
+        case wxPAPER_A3:        gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new (GTK_PAPER_NAME_A3));
+                                break;
+        case wxPAPER_A4:        gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new (GTK_PAPER_NAME_A4));
+                                break;
+        case wxPAPER_A5:        gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new (GTK_PAPER_NAME_A5));
+                                break;
+        case wxPAPER_B5_TRANSVERSE:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "jis-b5"));
+                                break;
+        case wxPAPER_B5:        gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new (GTK_PAPER_NAME_B5));
+                                break;
+        case wxPAPER_LETTER:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new (GTK_PAPER_NAME_LETTER));
+                                break;
+        case wxPAPER_LEGAL:     gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new (GTK_PAPER_NAME_LEGAL));
+                                break;
+        case wxPAPER_EXECUTIVE: gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new (GTK_PAPER_NAME_EXECUTIVE));
+                                break;
+        case wxPAPER_ENV_10:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "na_number-10"));
+                                break;
+        case wxPAPER_ENV_C5:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "iso-c5"));
+                                break;
+        case wxPAPER_ENV_C6:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "iso-c6"));
+                                break;
+        case wxPAPER_ENV_B5:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "iso-c5b5"));
+                                break;
+        case wxPAPER_ENV_MONARCH:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "na_monarch"));
+                                break;
+        case wxPAPER_CSHEET:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "engineering-c"));
+                                break;
+        case wxPAPER_DSHEET:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "engineering-d"));
+                                break;
+        case wxPAPER_ESHEET:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "engineering-e"));
+                                break;
+        case wxPAPER_LETTERSMALL:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "letter"));
+                                break;
+        case wxPAPER_TABLOID:   gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "engineering-b"));
+                                break;
+        case wxPAPER_LEDGER:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "ledger"));
+                                break;
+        case wxPAPER_STATEMENT:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "statement"));
+                                break;
+        case wxPAPER_A4SMALL:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new (GTK_PAPER_NAME_A4));
+                                break;
+        case wxPAPER_B4:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "iso-b4"));
+                                break;
+        case wxPAPER_FOLIO:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "folio"));
+                                break;
+        case wxPAPER_QUARTO:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "quarto"));
+                                break;
+        case wxPAPER_10X14:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "10x14"));
+                                break;
+        case wxPAPER_11X17:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "ledger"));
+                                break;
+        case wxPAPER_NOTE:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "letter"));
+                                break;
+        case wxPAPER_ENV_9:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "na-number-9-envelope"));
+                                break;
+        case wxPAPER_ENV_11:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "number-11"));
+                                break;
+        case wxPAPER_ENV_12:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "number-12"));
+                                break;
+        case wxPAPER_ENV_14:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "number-14"));
+                                break;
+        case wxPAPER_ENV_DL:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "iso-designated"));
+                                break;
+        case wxPAPER_ENV_C3:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "iso-c3"));
+                                break;
+        case wxPAPER_ENV_C4:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "iso-c4"));
+                                break;
+        case wxPAPER_ENV_C65:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "c6/c5"));
+                                break;
+        case wxPAPER_ENV_B4:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "iso-b4"));
+                                break;
+        case wxPAPER_ENV_B6:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "iso-b6"));
+                                break;
+        case wxPAPER_ENV_ITALY:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "Italian"));
+                                break;
+        case wxPAPER_ENV_PERSONAL:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "personal"));
+                                break;
+        case wxPAPER_FANFOLD_US:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "fanfold-us"));
+                                break;
+        case wxPAPER_FANFOLD_STD_GERMAN:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "fanfold-European"));
+                                break;
+        case wxPAPER_FANFOLD_LGL_GERMAN:    gs_gp->gtk_print_settings_set_paper_size(m_config, gs_gp->gtk_paper_size_new ((const gchar*) "foolscap"));
+                                break;
+        case wxPAPER_NONE:
+        default:                break;
+    }
+
+    return true;
+}
+
+void wxGtkPrintNativeData::SetPrintConfig( GtkPrintSettings * config )
+{
+    if (config)
+        m_config = gs_gp->gtk_print_settings_copy(config);
+}
+
+// Extract page setup from settings.
+GtkPageSetup* wxGtkPrintNativeData::GetPageSetupFromSettings(GtkPrintSettings* settings)
+{
+    GtkPageSetup* page_setup = gs_gp->gtk_page_setup_new();
+	gs_gp->gtk_page_setup_set_orientation (page_setup, gs_gp->gtk_print_settings_get_orientation (settings));
+
+	GtkPaperSize *paper_size = gs_gp->gtk_print_settings_get_paper_size (settings);
+	if (paper_size != NULL)
+		gs_gp->gtk_page_setup_set_paper_size_and_default_margins (page_setup, paper_size);
+
+    return page_setup;
+}
+
+// Insert page setup into a given GtkPrintSettings.
+void wxGtkPrintNativeData::SetPageSetupToSettings(GtkPrintSettings* settings, GtkPageSetup* page_setup)
+{
+    gs_gp->gtk_print_settings_set_orientation ( settings, gs_gp->gtk_page_setup_get_orientation (page_setup));
+	gs_gp->gtk_print_settings_set_paper_size ( settings, gs_gp->gtk_page_setup_get_paper_size (page_setup));
+}
+
+//----------------------------------------------------------------------------
+// wxGtkPrintDialog
+//----------------------------------------------------------------------------
+
+IMPLEMENT_CLASS(wxGtkPrintDialog, wxPrintDialogBase)
+
+wxGtkPrintDialog::wxGtkPrintDialog( wxWindow *parent, wxPrintDialogData *data )
+                    : wxPrintDialogBase(parent, wxID_ANY, _("Print"),
+                               wxPoint(0, 0), wxSize(600, 600),
+                               wxDEFAULT_DIALOG_STYLE |
+                               wxTAB_TRAVERSAL)
+{
+    if (data)
+        m_printDialogData = *data;
+
+    m_parent = parent;
+    SetShowDialog(true);
+}
+
+wxGtkPrintDialog::wxGtkPrintDialog( wxWindow *parent, wxPrintData *data )
+                    : wxPrintDialogBase(parent, wxID_ANY, _("Print"),
+                               wxPoint(0, 0), wxSize(600, 600),
+                               wxDEFAULT_DIALOG_STYLE |
+                               wxTAB_TRAVERSAL)
+{
+    if (data)
+        m_printDialogData = *data;
+
+    m_parent = parent;
+    SetShowDialog(true);
+}
+
+
+wxGtkPrintDialog::~wxGtkPrintDialog()
+{
+}
+
+// This is called even if we actually don't want the dialog to appear.
+int wxGtkPrintDialog::ShowModal()
+{
+    GtkPrintOperationResult response;
+
+    // We need to restore the settings given in the constructor.
+    wxPrintData data = m_printDialogData.GetPrintData();
+    wxGtkPrintNativeData *native =
+      (wxGtkPrintNativeData*) data.GetNativeData();
+    data.ConvertToNative();
+
+    GtkPrintSettings * settings = native->GetPrintConfig();
+
+    // We have to restore pages to print here because they're stored in a wxPrintDialogData and ConvertToNative only works for wxPrintData.
+    int fromPage = m_printDialogData.GetFromPage();
+    int toPage = m_printDialogData.GetToPage();
+    if (m_printDialogData.GetSelection())
+        gs_gp->gtk_print_settings_set_print_pages(settings, GTK_PRINT_PAGES_CURRENT);
+    else if (m_printDialogData.GetAllPages())
+        gs_gp->gtk_print_settings_set_print_pages(settings, GTK_PRINT_PAGES_ALL);
+    else {
+        gs_gp->gtk_print_settings_set_print_pages(settings, GTK_PRINT_PAGES_RANGES);
+        GtkPageRange *range;
+        range = g_new (GtkPageRange, 1);
+        range[0].start = fromPage-1;
+        range[0].end = (toPage >= fromPage) ? toPage-1 : fromPage-1;
+        gs_gp->gtk_print_settings_set_page_ranges (settings, range, 1);
+    }
+
+    // If the settings are OK, we restore it.
+    if (settings != NULL)
+        gs_gp->gtk_print_operation_set_print_settings (native->GetPrintJob(), settings);
+        gs_gp->gtk_print_operation_set_default_page_setup (native->GetPrintJob(), native->GetPageSetupFromSettings(settings));
+
+    // Show the dialog if needed.
+    GError* gError = NULL;
+    if (GetShowDialog())
+        response = gs_gp->gtk_print_operation_run (native->GetPrintJob(), GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG, GTK_WINDOW(gtk_widget_get_toplevel(m_parent->m_widget) ), &gError);
+    else
+        response = gs_gp->gtk_print_operation_run (native->GetPrintJob(), GTK_PRINT_OPERATION_ACTION_PRINT, (GtkWindow *) m_parent, &gError);
+
+    // Does everything went well?
+    if (response == GTK_PRINT_OPERATION_RESULT_CANCEL)
+    {
+        return wxID_CANCEL;
+    }
+    else if (response == GTK_PRINT_OPERATION_RESULT_ERROR)
+    {
+        g_error_free (gError);
+        wxLogError(_("Error while printing: ") + wxString::Format(_("%s"), gError->message));
+        return wxID_NO; // We use wxID_NO because there is no wxID_ERROR available
+    }
+
+    // Now get the settings and save it.
+    GtkPrintSettings* newSettings = gs_gp->gtk_print_operation_get_print_settings (native->GetPrintJob());
+    native->SetPrintConfig(newSettings);
+    data.ConvertFromNative();
+
+    // Same problem as a few lines before.
+    switch (gs_gp->gtk_print_settings_get_print_pages(newSettings))
+    {
+        case GTK_PRINT_PAGES_CURRENT:
+            m_printDialogData.SetSelection( true );
+            break;
+        case GTK_PRINT_PAGES_ALL:
+            m_printDialogData.SetAllPages( true );
+            m_printDialogData.SetFromPage( 0 );
+            m_printDialogData.SetToPage( 9999 );
+            break;
+        case GTK_PRINT_PAGES_RANGES:
+        default:
+            // wxWidgets doesn't support multiple ranges, so we can only save the first one even if the user wants to print others.
+            // For example, the user enters "1-3;5-7" in the dialog: pages 1-3 and 5-7 will be correctly printed when the user
+            // will hit "OK" button. However we can only save 1-3 in the print data.
+            gint num_ranges = 0;
+            GtkPageRange* range;
+            range = gs_gp->gtk_print_settings_get_page_ranges (newSettings, &num_ranges);
+            m_printDialogData.SetFromPage( range[0].start );
+            m_printDialogData.SetToPage( range[0].end );
+            break;
+    }
+
+    return wxID_OK;
+}
+
+//----------------------------------------------------------------------------
+// wxGtkPageSetupDialog
+//----------------------------------------------------------------------------
+
+IMPLEMENT_CLASS(wxGtkPageSetupDialog, wxPageSetupDialogBase)
+
+wxGtkPageSetupDialog::wxGtkPageSetupDialog( wxWindow *parent,
+                            wxPageSetupDialogData* data )
+{
+    if (data)
+        m_pageDialogData = *data;
+
+    m_parent = parent;
+}
+
+wxGtkPageSetupDialog::~wxGtkPageSetupDialog()
+{
+}
+
+int wxGtkPageSetupDialog::ShowModal()
+{
+    // Get the config.
+    m_pageDialogData.GetPrintData().ConvertToNative();
+    wxGtkPrintNativeData *native = (wxGtkPrintNativeData*) m_pageDialogData.GetPrintData().GetNativeData();
+    GtkPrintSettings* nativeData = native->GetPrintConfig();
+
+    // We only need the pagesetup data which are part of the settings.
+    GtkPageSetup* oldPageSetup = native->GetPageSetupFromSettings(nativeData);
+
+    // If the user used a custom paper format the last time he printed, we have to restore it too.
+    if (m_pageDialogData.GetPrintData().GetPaperId() == wxPAPER_NONE)
+    {
+        wxSize customPaperSize = m_pageDialogData.GetPaperSize();
+        if (customPaperSize.GetWidth() > 0 && customPaperSize.GetHeight() > 0)
+        {
+            wxString title = _("Custom size");
+            GtkPaperSize* customSize = gs_gp->gtk_paper_size_new_custom ("custom", title.mb_str(), (gdouble) customPaperSize.GetWidth(), (gdouble) customPaperSize.GetHeight(), GTK_UNIT_MM);
+            gs_gp->gtk_page_setup_set_paper_size_and_default_margins (oldPageSetup, customSize);
+            g_object_unref(customSize);
+        }
+    }
+
+    // Now show the dialog.
+    GtkPageSetup* newPageSetup = gs_gp->gtk_print_run_page_setup_dialog ((GtkWindow *) m_parent,
+                                                           oldPageSetup,
+                                                           nativeData);
+
+    int ret;
+    if (newPageSetup != oldPageSetup)
+    {
+        native->SetPageSetupToSettings(nativeData, newPageSetup);
+        m_pageDialogData.GetPrintData().ConvertFromNative();
+
+        // Store custom paper format if any.
+        if (m_pageDialogData.GetPrintData().GetPaperId() == wxPAPER_NONE)
+        {
+            gdouble ml,mr,mt,mb,pw,ph;
+            ml = gs_gp->gtk_page_setup_get_left_margin (newPageSetup, GTK_UNIT_MM);
+            mr = gs_gp->gtk_page_setup_get_right_margin (newPageSetup, GTK_UNIT_MM);
+            mt = gs_gp->gtk_page_setup_get_top_margin (newPageSetup, GTK_UNIT_MM);
+            mb = gs_gp->gtk_page_setup_get_bottom_margin (newPageSetup, GTK_UNIT_MM);
+
+            pw = gs_gp->gtk_page_setup_get_paper_width (newPageSetup, GTK_UNIT_MM);
+            ph = gs_gp->gtk_page_setup_get_paper_height (newPageSetup, GTK_UNIT_MM);
+
+            m_pageDialogData.SetMarginTopLeft( wxPoint( (int)(ml+0.5), (int)(mt+0.5)) );
+            m_pageDialogData.SetMarginBottomRight( wxPoint( (int)(mr+0.5), (int)(mb+0.5)) );
+
+            m_pageDialogData.SetPaperSize( wxSize( (int)(pw+0.5), (int)(ph+0.5) ) );
+        }
+
+        ret = wxID_OK;
+    }
+    else
+    {
+        ret = wxID_CANCEL;
+    }
+
+    return ret;
+}
+
+//----------------------------------------------------------------------------
+// wxGtkPrinter
+//----------------------------------------------------------------------------
+
+IMPLEMENT_CLASS(wxGtkPrinter, wxPrinterBase)
+
+wxGtkPrinter::wxGtkPrinter( wxPrintDialogData *data ) :
+    wxPrinterBase( data )
+{
+    m_gpc = NULL;
+
+    if (data)
+        m_printDialogData = *data;
+}
+
+wxGtkPrinter::~wxGtkPrinter()
+{
+}
+
+bool wxGtkPrinter::Print(wxWindow *parent, wxPrintout *printout, bool prompt )
+{
+    if (!printout)
+    {
+        sm_lastError = wxPRINTER_ERROR;
+        return false;
+    }
+
+    // Let's correct the PageInfo just in case the app gives wrong values.
+    int fromPage, toPage;
+    int minPage, maxPage;
+    printout->GetPageInfo(&minPage, &maxPage, &fromPage, &toPage);
+    m_printDialogData.SetAllPages(true);
+
+    if (minPage < 1) minPage = 1;
+    if (maxPage < 1) maxPage = 9999;
+    if (maxPage < minPage) maxPage = minPage;
+
+    m_printDialogData.SetMinPage(minPage);
+    m_printDialogData.SetMaxPage(maxPage);
+    if (fromPage != 0)
+    {
+        if (fromPage < minPage) fromPage = minPage;
+        else if (fromPage > maxPage) fromPage = maxPage;
+        m_printDialogData.SetFromPage(fromPage);
+    }
+    if (toPage != 0)
+    {
+        m_printDialogData.SetToPage(toPage);
+        if (toPage > maxPage) toPage = maxPage;
+        else if (toPage < minPage) toPage = minPage;
+    }
+
+    if (((minPage != fromPage) && fromPage != 0) || ((maxPage != toPage) && toPage != 0)) m_printDialogData.SetAllPages(false);
+
+
+    wxPrintData printdata = GetPrintDialogData().GetPrintData();
+    wxGtkPrintNativeData *native = (wxGtkPrintNativeData*) printdata.GetNativeData();
+
+    GtkPrintOperation *printOp = gs_gp->gtk_print_operation_new ();
+
+    native->SetPrintJob( printOp );
+
+    printout->SetIsPreview(false);
+
+    wxPrinterToGtkData dataToSend;
+    dataToSend.printer = this;
+    dataToSend.printout = printout;
+
+    // These Gtk signals are catched here.
+    g_signal_connect (printOp, "begin-print", G_CALLBACK (gtk_begin_print_callback), &dataToSend);
+    g_signal_connect (printOp, "draw-page", G_CALLBACK (gtk_draw_page_print_callback), &dataToSend);
+    g_signal_connect (printOp, "end-print", G_CALLBACK (gtk_end_print_callback), printout);
+    g_signal_connect (printOp, "preview", G_CALLBACK (gtk_preview_print_callback), printout);
+
+    m_showDialog = true;
+    if (!prompt)
+        m_showDialog = false;
+
+    // PrintDialog returns a wxDC but we created it before so we don't need it anymore: we just delete it.
+    wxDC* uselessdc = PrintDialog( parent );
+    delete uselessdc;
+
+    g_object_unref (printOp);
+
+    return (sm_lastError == wxPRINTER_NO_ERROR);
+}
+
+void wxGtkPrinter::BeginPrint(wxPrintout *printout, GtkPrintOperation *operation, GtkPrintContext *context)
+{
+    wxPrintData printdata = GetPrintDialogData().GetPrintData();
+    wxGtkPrintNativeData *native = (wxGtkPrintNativeData*) printdata.GetNativeData();
+
+    SetPrintContext(context);
+    native->SetPrintContext( context );
+
+    m_dc = new wxGtkPrintDC( printdata );
+
+    if (!m_dc->IsOk())
+    {
+        if (sm_lastError != wxPRINTER_CANCELLED)
+        {
+            sm_lastError = wxPRINTER_ERROR;
+            wxFAIL_MSG(_("The wxGtkPrintDC cannot be used."));
+        }
+        return;
+    }
+    wxSize ScreenPixels = wxGetDisplaySize();
+    wxSize ScreenMM = wxGetDisplaySizeMM();
+
+    printout->SetPPIScreen( (int) ((ScreenPixels.GetWidth() * 25.4) / ScreenMM.GetWidth()),
+                            (int) ((ScreenPixels.GetHeight() * 25.4) / ScreenMM.GetHeight()) );
+    printout->SetPPIPrinter( wxGtkPrintDC::GetResolution(),
+                             wxGtkPrintDC::GetResolution() );
+
+    printout->SetDC(m_dc);
+
+    int w, h;
+    m_dc->GetSize(&w, &h);
+    printout->SetPageSizePixels((int)w, (int)h);
+    printout->SetPaperRectPixels(wxRect(0, 0, w, h));
+    int mw, mh;
+    m_dc->GetSizeMM(&mw, &mh);
+    printout->SetPageSizeMM((int)mw, (int)mh);
+    printout->OnPreparePrinting();
+
+    // Get some parameters from the printout, if defined.
+    int fromPage, toPage;
+    int minPage, maxPage;
+    printout->GetPageInfo(&minPage, &maxPage, &fromPage, &toPage);
+
+    if (maxPage == 0)
+    {
+        sm_lastError = wxPRINTER_ERROR;
+        wxFAIL_MSG(_("wxPrintout::GetPageInfo gives a null maxPage."));
+        return;
+    }
+
+    printout->OnBeginPrinting();
+
+    int numPages = 0;
+
+    // If we're not previewing we need to calculate the number of pages to print.
+    // If we're previewing, Gtk Print will render every pages without wondering about the page ranges the user may
+    // have defined in the dialog. So the number of pages is the maximum available.
+    if (!printout->IsPreview())
+    {
+        GtkPrintSettings * settings = gs_gp->gtk_print_operation_get_print_settings (operation);
+        switch (gs_gp->gtk_print_settings_get_print_pages(settings))
+        {
+            case GTK_PRINT_PAGES_CURRENT:
+                numPages = 1;
+                break;
+            case GTK_PRINT_PAGES_RANGES:
+                {gint num_ranges = 0;
+                GtkPageRange* range;
+                int i;
+                range = gs_gp->gtk_print_settings_get_page_ranges (settings, &num_ranges);
+                for (i=0; i<num_ranges; i++)
+                {
+                    if (range[i].end < range[i].start) range[i].end = range[i].start;
+                    if (range[i].start < minPage-1) range[i].start = minPage-1;
+                    if (range[i].end > maxPage-1) range[i].end = maxPage-1;
+                    if (range[i].start > maxPage-1) range[i].start = maxPage-1;
+                    numPages += range[i].end - range[i].start + 1;
+                }
+                gs_gp->gtk_print_settings_set_page_ranges (settings, range, 1);
+                break;}
+            case GTK_PRINT_PAGES_ALL:
+            default:
+                numPages = maxPage - minPage + 1;
+                break;
+        }
+    }
+    else numPages = maxPage - minPage + 1;
+
+    gs_gp->gtk_print_operation_set_n_pages(operation, numPages);
+}
+
+void wxGtkPrinter::DrawPage(wxPrintout *printout, GtkPrintOperation *operation, GtkPrintContext *context, int page_nr)
+{
+    int fromPage, toPage, minPage, maxPage, startPage, endPage;
+    printout->GetPageInfo(&minPage, &maxPage, &fromPage, &toPage);
+
+    int numPageToDraw = page_nr + minPage;
+    if (numPageToDraw < minPage) numPageToDraw = minPage;
+    if (numPageToDraw > maxPage) numPageToDraw = maxPage;
+
+    GtkPrintSettings * settings = gs_gp->gtk_print_operation_get_print_settings (operation);
+    switch (gs_gp->gtk_print_settings_get_print_pages(settings))
+    {
+        case GTK_PRINT_PAGES_CURRENT:
+            g_object_get_property((GObject*) operation, (const gchar *) "current-page", (GValue*) &startPage);
+            g_object_get_property((GObject*) operation, (const gchar *) "current-page", (GValue*) &endPage);
+            break;
+        case GTK_PRINT_PAGES_RANGES:
+            {gint num_ranges = 0;
+            GtkPageRange* range;
+            range = gs_gp->gtk_print_settings_get_page_ranges (settings, &num_ranges);
+            // We don't need to verify these values as it has already been done in wxGtkPrinter::BeginPrint.
+            startPage = range[0].start + 1;
+            endPage = range[0].end + 1;
+            break;}
+        case GTK_PRINT_PAGES_ALL:
+        default:
+            startPage = minPage;
+            endPage = maxPage;
+            break;
+    }
+
+    if(numPageToDraw == startPage)
+    {
+        if (!printout->OnBeginDocument(startPage, endPage))
+        {
+            wxLogError(_("Could not start printing."));
+            sm_lastError = wxPRINTER_ERROR;
+        }
+    }
+
+    // The app can render the page numPageToDraw.
+    if (printout->HasPage(numPageToDraw))
+    {
+        m_dc->StartPage();
+        printout->OnPrintPage(numPageToDraw);
+        m_dc->EndPage();
+    }
+
+
+    if(numPageToDraw == endPage)
+    {
+        printout->OnEndDocument();
+    }
+}
+
+wxDC* wxGtkPrinter::PrintDialog( wxWindow *parent )
+{
+    wxGtkPrintDialog dialog( parent, &m_printDialogData );
+    int ret;
+
+    dialog.SetPrintDC(m_dc);
+
+    dialog.SetShowDialog(m_showDialog);
+
+    ret = dialog.ShowModal();
+
+    if (ret == wxID_CANCEL)
+    {
+        sm_lastError = wxPRINTER_CANCELLED;
+        return NULL;
+    }
+    if (ret == wxID_NO)
+    {
+        sm_lastError = wxPRINTER_ERROR;
+        wxFAIL_MSG(_("The print dialog returned an error."));
+        return NULL;
+    }
+
+    m_printDialogData = dialog.GetPrintDialogData();
+    return new wxGtkPrintDC( m_printDialogData.GetPrintData() );
+}
+
+bool wxGtkPrinter::Setup( wxWindow *parent )
+{
+    // Obsolete, for backward compatibility.
+    return false;
+}
+
+//-----------------------------------------------------------------------------
+// wxGtkPrintDC
+//-----------------------------------------------------------------------------
+
+IMPLEMENT_CLASS(wxGtkPrintDC, wxDC)
+
+// Define the default resolution for this DC. This resolution is just used for positioning as the cairo context is scalable.
+int wxGtkPrintDC::ms_resolution = 72;
+
+wxGtkPrintDC::wxGtkPrintDC( const wxPrintData& data )
+{
+    m_printData = data;
+
+    wxGtkPrintNativeData *native =
+        (wxGtkPrintNativeData*) m_printData.GetNativeData();
+
+    m_gpc = native->GetPrintContext();
+
+    ms_resolution = (int) gs_gp->gtk_print_context_get_dpi_x(m_gpc);
+    m_context = gs_gp->gtk_print_context_create_pango_context( m_gpc );
+    m_layout = gs_gp->gtk_print_context_create_pango_layout ( m_gpc );
+    m_fontdesc = pango_font_description_from_string( "Sans 12" );
+
+    m_cairo = gs_gp->gtk_print_context_get_cairo_context ( m_gpc );
+
+    m_currentRed = 0;
+    m_currentBlue = 0;
+    m_currentGreen = 0;
+
+    m_signX =  1;  // default x-axis left to right.
+    m_signY = 1;  // default y-axis bottom up -> top down.
+
+    GetSize( &m_deviceOffsetX, &m_deviceOffsetY );
+}
+
+wxGtkPrintDC::~wxGtkPrintDC()
+{
+    g_object_unref(m_context);
+    g_object_unref(m_layout);
+}
+
+bool wxGtkPrintDC::IsOk() const
+{
+    return true;
+}
+
+void wxGtkPrintDC::ComputeScaleAndOrigin()
+{
+    // Called when the scale and/or origin of the context has to be changed.
+    m_scaleX = m_logicalScaleX * m_userScaleX;
+    m_scaleY = m_logicalScaleY * m_userScaleY;
+
+    cairo_translate(m_cairo, m_deviceOriginX, m_deviceOriginY);
+    cairo_scale(m_cairo, m_scaleX, m_scaleY );
+}
+
+bool wxGtkPrintDC::DoFloodFill(wxCoord x1, wxCoord y1, const wxColour &col, int style )
+{
+    // We can't access the given coord as a cairo context is scalable, ie a coord doesn't mean anything in this context.
+    wxFAIL_MSG(_("not implemented"));
+    return false;
+}
+
+void wxGtkPrintDC::DoGradientFillConcentric(const wxRect& rect, const wxColour& initialColour, const wxColour& destColour, const wxPoint& circleCenter)
+{
+    wxCoord xC = circleCenter.x;
+    wxCoord yC = circleCenter.y;
+    wxCoord xR = rect.x;
+    wxCoord yR = rect.y;
+    wxCoord w =  rect.width;
+    wxCoord h = rect.height;
+
+    double radius = sqrt((w/2)*(w/2)+(h/2)*(h/2));
+
+    unsigned char redI = initialColour.Red();
+    unsigned char blueI = initialColour.Blue();
+    unsigned char greenI = initialColour.Green();
+    unsigned char alphaI = initialColour.Alpha();
+    unsigned char redD = destColour.Red();
+    unsigned char blueD = destColour.Blue();
+    unsigned char greenD = destColour.Green();
+    unsigned char alphaD = destColour.Alpha();
+
+    double redIPS = (double)(redI) / 255.0;
+    double blueIPS = (double)(blueI) / 255.0;
+    double greenIPS = (double)(greenI) / 255.0;
+    double alphaIPS = (double)(alphaI) / 255.0;
+    double redDPS = (double)(redD) / 255.0;
+    double blueDPS = (double)(blueD) / 255.0;
+    double greenDPS = (double)(greenD) / 255.0;
+    double alphaDPS = (double)(alphaD) / 255.0;
+
+    // Create a pattern with the gradient.
+    cairo_pattern_t* gradient;
+    gradient = cairo_pattern_create_radial (LogicalToDeviceX(xC+xR), LogicalToDeviceY(yC+yR), 0, LogicalToDeviceX(xC+xR), LogicalToDeviceY(yC+yR), radius);
+    cairo_pattern_add_color_stop_rgba (gradient, 0.0, redIPS, greenIPS, blueIPS, alphaIPS);
+    cairo_pattern_add_color_stop_rgba (gradient, 1.0, redDPS, greenDPS, blueDPS, alphaDPS);
+
+    // Fill the rectangle with this pattern.
+    cairo_set_source(m_cairo, gradient);
+    cairo_rectangle (m_cairo, LogicalToDeviceX(xR), LogicalToDeviceY(yR), LogicalToDeviceXRel(w), LogicalToDeviceYRel(h) );
+    cairo_fill(m_cairo);
+
+    cairo_pattern_destroy(gradient);
+
+    CalcBoundingBox(xR, yR);
+    CalcBoundingBox(xR+w, yR+h);
+}
+
+void wxGtkPrintDC::DoGradientFillLinear(const wxRect& rect, const wxColour& initialColour, const wxColour& destColour, wxDirection nDirection)
+{
+    wxCoord x = rect.x;
+    wxCoord y = rect.y;
+    wxCoord w = rect.width;
+    wxCoord h = rect.height;
+
+    unsigned char redI = initialColour.Red();
+    unsigned char blueI = initialColour.Blue();
+    unsigned char greenI = initialColour.Green();
+    unsigned char alphaI = initialColour.Alpha();
+    unsigned char redD = destColour.Red();
+    unsigned char blueD = destColour.Blue();
+    unsigned char greenD = destColour.Green();
+    unsigned char alphaD = destColour.Alpha();
+
+    double redIPS = (double)(redI) / 255.0;
+    double blueIPS = (double)(blueI) / 255.0;
+    double greenIPS = (double)(greenI) / 255.0;
+    double alphaIPS = (double)(alphaI) / 255.0;
+    double redDPS = (double)(redD) / 255.0;
+    double blueDPS = (double)(blueD) / 255.0;
+    double greenDPS = (double)(greenD) / 255.0;
+    double alphaDPS = (double)(alphaD) / 255.0;
+
+    // Create a pattern with the gradient.
+    cairo_pattern_t* gradient;
+    gradient = cairo_pattern_create_linear (LogicalToDeviceX(x), LogicalToDeviceY(y), LogicalToDeviceX(x+w), LogicalToDeviceY(y));
+
+    if (nDirection == wxWEST)
+    {
+        cairo_pattern_add_color_stop_rgba (gradient, 0.0, redDPS, greenDPS, blueDPS, alphaDPS);
+        cairo_pattern_add_color_stop_rgba (gradient, 1.0, redIPS, greenIPS, blueIPS, alphaIPS);
+    }
+    else {
+        cairo_pattern_add_color_stop_rgba (gradient, 0.0, redIPS, greenIPS, blueIPS, alphaIPS);
+        cairo_pattern_add_color_stop_rgba (gradient, 1.0, redDPS, greenDPS, blueDPS, alphaDPS);
+    }
+
+    // Fill the rectangle with this pattern.
+    cairo_set_source(m_cairo, gradient);
+    cairo_rectangle (m_cairo, LogicalToDeviceX(x), LogicalToDeviceY(y), LogicalToDeviceXRel(w), LogicalToDeviceYRel(h) );
+    cairo_fill(m_cairo);
+
+    cairo_pattern_destroy(gradient);
+
+    CalcBoundingBox(x, y);
+    CalcBoundingBox(x+w, y+h);
+}
+
+bool wxGtkPrintDC::DoGetPixel(wxCoord x1, wxCoord y1, wxColour *col) const
+{
+    // We can't access the given coord as a cairo context is scalable, ie a coord doesn't mean anything in this context.
+    wxFAIL_MSG(_("not implemented"));
+    return false;
+}
+
+void wxGtkPrintDC::DoDrawLine(wxCoord x1, wxCoord y1, wxCoord x2, wxCoord y2)
+{
+    if  (m_pen.GetStyle() == wxTRANSPARENT) return;
+
+    SetPen( m_pen );
+    cairo_move_to ( m_cairo, LogicalToDeviceX(x1), LogicalToDeviceY(y1) );
+    cairo_line_to ( m_cairo, LogicalToDeviceX(x2), LogicalToDeviceY(y2) );
+    cairo_stroke ( m_cairo );
+
+    CalcBoundingBox( x1, y1 );
+    CalcBoundingBox( x2, y2 );
+}
+
+void wxGtkPrintDC::DoCrossHair(wxCoord x, wxCoord y)
+{
+    int *w, *h;
+    w = new int;
+    h = new int;
+    DoGetSize(w, h);
+
+    SetPen(m_pen);
+
+    cairo_move_to (m_cairo, LogicalToDeviceX(x), 0);
+    cairo_line_to (m_cairo, LogicalToDeviceX(x), *h);
+    cairo_move_to (m_cairo, 0, LogicalToDeviceY(y));
+    cairo_line_to (m_cairo, *w, LogicalToDeviceY(y));
+
+    cairo_stroke (m_cairo);
+    CalcBoundingBox( 0, 0 );
+    CalcBoundingBox( *w, *h );
+
+    delete w;
+    delete h;
+}
+
+void wxGtkPrintDC::DoDrawArc(wxCoord x1,wxCoord y1,wxCoord x2,wxCoord y2,wxCoord xc,wxCoord yc)
+{
+    double dx = x1 - xc;
+    double dy = y1 - yc;
+    double radius = sqrt((double)(dx*dx+dy*dy));
+
+    double alpha1, alpha2;
+    if (x1 == x2 && y1 == y2)
+    {
+        alpha1 = 0.0;
+        alpha2 = 360.0;
+    }
+    else
+    if (radius == 0.0)
+    {
+        alpha1 = alpha2 = 0.0;
+    }
+    else
+    {
+        alpha1 = (x1 - xc == 0) ?
+            (y1 - yc < 0) ? 90.0 : -90.0 :
+            atan2(double(y1-yc), double(x1-xc)) * RAD2DEG;
+        alpha2 = (x2 - xc == 0) ?
+            (y2 - yc < 0) ? 90.0 : -90.0 :
+            atan2(double(y2-yc), double(x2-xc)) * RAD2DEG;
+
+        while (alpha1 <= 0)   alpha1 += 360;
+        while (alpha2 <= 0)   alpha2 += 360; // adjust angles to be between.
+        while (alpha1 > 360)  alpha1 -= 360; // 0 and 360 degree.
+        while (alpha2 > 360)  alpha2 -= 360;
+    }
+
+    alpha1 *= DEG2RAD;
+    alpha2 *= DEG2RAD;
+
+    cairo_arc_negative ( m_cairo, LogicalToDeviceX(xc), LogicalToDeviceY(yc), LogicalToDeviceXRel((int)radius), alpha1, alpha2);
+    cairo_line_to(m_cairo, LogicalToDeviceX(xc), LogicalToDeviceY(yc));
+    cairo_close_path (m_cairo);
+
+    SetBrush( m_brush );
+    cairo_fill_preserve( m_cairo );
+
+    SetPen (m_pen);
+    cairo_stroke( m_cairo );
+
+    CalcBoundingBox (x1, y1);
+    CalcBoundingBox (xc, yc);
+    CalcBoundingBox (x2, y2);
+}
+
+void wxGtkPrintDC::DoDrawEllipticArc(wxCoord x,wxCoord y,wxCoord w,wxCoord h,double sa,double ea)
+{
+    cairo_save( m_cairo );
+
+    cairo_translate( m_cairo, LogicalToDeviceX((wxCoord) (x + w / 2.)), LogicalToDeviceX((wxCoord) (y + h / 2.)) );
+    double scale = (double)LogicalToDeviceYRel(h) / (double) LogicalToDeviceXRel(w);
+    cairo_scale( m_cairo, 1.0, scale );
+
+    cairo_arc_negative ( m_cairo, 0, 0, LogicalToDeviceXRel(w/2), -sa*DEG2RAD, -ea*DEG2RAD);
+
+    SetPen (m_pen);
+    cairo_stroke_preserve( m_cairo );
+
+    cairo_line_to(m_cairo, 0,0);
+
+    SetBrush( m_brush );
+    cairo_fill( m_cairo );
+
+    cairo_restore( m_cairo );
+
+    CalcBoundingBox( x, y);
+    CalcBoundingBox( x+w, y+h );
+}
+
+void wxGtkPrintDC::DoDrawPoint(wxCoord x, wxCoord y)
+{
+    if  (m_pen.GetStyle() == wxTRANSPARENT) return;
+
+    SetPen( m_pen );
+
+    cairo_move_to ( m_cairo, LogicalToDeviceX(x), LogicalToDeviceY(y) );
+    cairo_line_to ( m_cairo, LogicalToDeviceX(x), LogicalToDeviceY(y) );
+    cairo_stroke ( m_cairo );
+
+    CalcBoundingBox( x, y );
+}
+
+void wxGtkPrintDC::DoDrawLines(int n, wxPoint points[], wxCoord xoffset, wxCoord yoffset)
+{
+    if (m_pen.GetStyle() == wxTRANSPARENT) return;
+
+    if (n <= 0) return;
+
+    SetPen (m_pen);
+
+    int i;
+    for ( i =0; i<n ; i++ )
+        CalcBoundingBox( points[i].x+xoffset, points[i].y+yoffset);
+
+    cairo_move_to ( m_cairo, LogicalToDeviceX(points[0].x+xoffset), LogicalToDeviceY(points[0].y+yoffset) );
+
+    for (i = 1; i < n; i++)
+        cairo_line_to ( m_cairo, LogicalToDeviceX(points[i].x+xoffset), LogicalToDeviceY(points[i].y+yoffset) );
+
+    cairo_stroke ( m_cairo);
+}
+
+void wxGtkPrintDC::DoDrawPolygon(int n, wxPoint points[], wxCoord xoffset, wxCoord yoffset, int fillStyle)
+{
+    if (n==0) return;
+
+    cairo_save(m_cairo);
+    if (fillStyle == wxWINDING_RULE)
+        cairo_set_fill_rule( m_cairo, CAIRO_FILL_RULE_WINDING);
+    else
+        cairo_set_fill_rule( m_cairo, CAIRO_FILL_RULE_EVEN_ODD);
+
+    int x = points[0].x + xoffset;
+    int y = points[0].y + yoffset;
+    cairo_new_path(m_cairo);
+    cairo_move_to( m_cairo, LogicalToDeviceX(x), LogicalToDeviceY(y) );
+    int i;
+    for (i = 1; i < n; i++)
+    {
+        int x = points[i].x + xoffset;
+        int y = points[i].y + yoffset;
+        cairo_line_to( m_cairo, LogicalToDeviceX(x), LogicalToDeviceY(y) );
+    }
+    cairo_close_path(m_cairo);
+
+    SetBrush( m_brush );
+    cairo_fill_preserve( m_cairo );
+
+    SetPen (m_pen);
+    cairo_stroke( m_cairo );
+
+    CalcBoundingBox( x, y );
+
+    cairo_restore(m_cairo);
+}
+
+void wxGtkPrintDC::DoDrawPolyPolygon(int n, int count[], wxPoint points[], wxCoord xoffset, wxCoord yoffset, int fillStyle)
+{
+    wxDC::DoDrawPolyPolygon( n, count, points, xoffset, yoffset, fillStyle );
+}
+
+void wxGtkPrintDC::DoDrawRectangle(wxCoord x, wxCoord y, wxCoord width, wxCoord height)
+{
+    cairo_rectangle ( m_cairo, LogicalToDeviceX(x), LogicalToDeviceY(y), LogicalToDeviceXRel(width), LogicalToDeviceYRel(height));
+
+    SetBrush( m_brush );
+    cairo_fill_preserve( m_cairo );
+
+    SetPen (m_pen);
+    cairo_stroke( m_cairo );
+
+    CalcBoundingBox( x, y );
+    CalcBoundingBox( x + width, y + height );
+}
+
+void wxGtkPrintDC::DoDrawRoundedRectangle(wxCoord x, wxCoord y, wxCoord width, wxCoord height, double radius)
+{
+    if (radius < 0.0) radius = - radius * ((width < height) ? width : height);
+
+    wxCoord dd = 2 * (wxCoord) radius;
+    if (dd > width) dd = width;
+    if (dd > height) dd = height;
+    radius = dd / 2;
+
+    wxCoord rad = (wxCoord) radius;
+
+    cairo_new_path(m_cairo);
+    cairo_move_to(m_cairo,LogicalToDeviceX(x + rad),LogicalToDeviceY(y));
+    cairo_curve_to(m_cairo,
+                                LogicalToDeviceX(x + rad),LogicalToDeviceY(y),
+                                LogicalToDeviceX(x),LogicalToDeviceY(y),
+                                LogicalToDeviceX(x),LogicalToDeviceY(y + rad));
+    cairo_line_to(m_cairo,LogicalToDeviceX(x),LogicalToDeviceY(y + height - rad));
+    cairo_curve_to(m_cairo,
+                                LogicalToDeviceX(x),LogicalToDeviceY(y + height - rad),
+                                LogicalToDeviceX(x),LogicalToDeviceY(y + height),
+                                LogicalToDeviceX(x + rad),LogicalToDeviceY(y + height));
+    cairo_line_to(m_cairo,LogicalToDeviceX(x + width - rad),LogicalToDeviceY(y + height));
+    cairo_curve_to(m_cairo,
+                                LogicalToDeviceX(x + width - rad),LogicalToDeviceY(y + height),
+                                LogicalToDeviceX(x + width),LogicalToDeviceY(y + height),
+                                LogicalToDeviceX(x + width),LogicalToDeviceY(y + height - rad));
+    cairo_line_to(m_cairo,LogicalToDeviceX(x + width),LogicalToDeviceY(y + rad));
+    cairo_curve_to(m_cairo,
+                                LogicalToDeviceX(x + width),LogicalToDeviceY(y + rad),
+                                LogicalToDeviceX(x + width),LogicalToDeviceY(y),
+                                LogicalToDeviceX(x + width - rad),LogicalToDeviceY(y));
+    cairo_line_to(m_cairo,LogicalToDeviceX(x + rad),LogicalToDeviceY(y));
+    cairo_close_path(m_cairo);
+
+    SetBrush(m_brush);
+    cairo_fill_preserve(m_cairo);
+
+    SetPen(m_pen);
+    cairo_stroke(m_cairo);
+
+    CalcBoundingBox(x,y);
+    CalcBoundingBox(x+width,y+height);
+}
+
+void wxGtkPrintDC::DoDrawEllipse(wxCoord x, wxCoord y, wxCoord width, wxCoord height)
+{
+    cairo_save (m_cairo);
+
+    cairo_translate (m_cairo, LogicalToDeviceX((wxCoord) (x + width / 2.)), LogicalToDeviceY((wxCoord) (y + height / 2.)));
+    cairo_scale(m_cairo, 1, (double)LogicalToDeviceYRel(height)/(double)LogicalToDeviceXRel(width));
+    cairo_arc ( m_cairo, 0, 0, LogicalToDeviceXRel(width/2), 0, 2 * M_PI);
+
+    SetBrush( m_brush );
+    cairo_fill_preserve( m_cairo );
+
+    SetPen (m_pen);
+    cairo_stroke( m_cairo );
+
+    CalcBoundingBox( x, y );
+    CalcBoundingBox( x + width, y + height );
+
+    cairo_restore (m_cairo);
+}
+
+#if wxUSE_SPLINES
+void wxGtkPrintDC::DoDrawSpline(wxList *points)
+{
+    SetPen (m_pen);
+
+    double c, d, x1, y1, x2, y2, x3, y3;
+    wxPoint *p, *q;
+
+    wxList::compatibility_iterator node = points->GetFirst();
+    p = (wxPoint *)node->GetData();
+    x1 = p->x;
+    y1 = p->y;
+
+    node = node->GetNext();
+    p = (wxPoint *)node->GetData();
+    c = p->x;
+    d = p->y;
+    x3 =
+         (double)(x1 + c) / 2;
+    y3 =
+         (double)(y1 + d) / 2;
+
+    cairo_new_path( m_cairo );
+    cairo_move_to( m_cairo, LogicalToDeviceX((wxCoord)x1), LogicalToDeviceY((wxCoord)y1) );
+    cairo_line_to( m_cairo, LogicalToDeviceX((wxCoord)x3), LogicalToDeviceY((wxCoord)y3) );
+
+    CalcBoundingBox( (wxCoord)x1, (wxCoord)y1 );
+    CalcBoundingBox( (wxCoord)x3, (wxCoord)y3 );
+
+    node = node->GetNext();
+    while (node)
+    {
+        q = (wxPoint *)node->GetData();
+
+        x1 = x3;
+        y1 = y3;
+        x2 = c;
+        y2 = d;
+        c = q->x;
+        d = q->y;
+        x3 = (double)(x2 + c) / 2;
+        y3 = (double)(y2 + d) / 2;
+
+        cairo_curve_to(m_cairo,
+            LogicalToDeviceX((wxCoord)x1), LogicalToDeviceY((wxCoord)y1),
+            LogicalToDeviceX((wxCoord)x2), LogicalToDeviceY((wxCoord)y2),
+            LogicalToDeviceX((wxCoord)x3), LogicalToDeviceY((wxCoord)y3) );
+
+        CalcBoundingBox( (wxCoord)x1, (wxCoord)y1 );
+        CalcBoundingBox( (wxCoord)x3, (wxCoord)y3 );
+
+        node = node->GetNext();
+    }
+
+    cairo_line_to ( m_cairo, LogicalToDeviceX((wxCoord)c), LogicalToDeviceY((wxCoord)d) );
+
+    cairo_stroke( m_cairo );
+}
+#endif // wxUSE_SPLINES
+
+bool wxGtkPrintDC::DoBlit(wxCoord xdest, wxCoord ydest, wxCoord width, wxCoord height,
+            wxDC *source, wxCoord xsrc, wxCoord ysrc, int rop, bool useMask,
+            wxCoord xsrcMask, wxCoord ysrcMask)
+{
+    wxCHECK_MSG( source, false, wxT("invalid source dc") );
+
+    // Blit into a bitmap.
+    wxBitmap bitmap( width, height );
+    wxMemoryDC memDC;
+    memDC.SelectObject(bitmap);
+    memDC.Blit(0, 0, width, height, source, xsrc, ysrc, rop);
+    memDC.SelectObject(wxNullBitmap);
+
+    // Draw bitmap. scaling and positioning is done there.
+    DrawBitmap( bitmap, xdest, ydest, useMask );
+
+    return true;
+}
+
+void wxGtkPrintDC::DoDrawIcon( const wxIcon& icon, wxCoord x, wxCoord y )
+{
+    DoDrawBitmap( icon, x, y, true );
+}
+
+void wxGtkPrintDC::DoDrawBitmap( const wxBitmap& bitmap, wxCoord x, wxCoord y, bool useMask )
+{
+    wxCHECK_RET( bitmap.IsOk(), wxT("Invalid bitmap in wxGtkPrintDC::DoDrawBitmap"));
+
+    cairo_surface_t* surface;
+    x = LogicalToDeviceX(x);
+    y = LogicalToDeviceY(y);
+    int bw = bitmap.GetWidth();
+    int bh = bitmap.GetHeight();
+    wxBitmap bmpSource = bitmap;  // we need a non-const instance.
+    unsigned char* buffer = new unsigned char[bw*bh*4];
+    wxUint32* data = (wxUint32*)buffer;
+
+    wxMask *mask = NULL;
+    if (useMask) mask = bmpSource.GetMask();
+
+    // Create a surface object and copy the bitmap pixel data to it. If the image has alpha (or a mask represented as alpha)
+    // then we'll use a different format and iterator than if it doesn't.
+    if (bmpSource.HasAlpha() || mask)
+    {
+        surface = cairo_image_surface_create_for_data(
+            buffer, CAIRO_FORMAT_ARGB32, bw, bh, bw*4);
+        wxAlphaPixelData pixData(bmpSource, wxPoint(0,0), wxSize(bw, bh));
+        wxCHECK_RET( pixData, wxT("Failed to gain raw access to bitmap data."));
+
+        wxAlphaPixelData::Iterator p(pixData);
+        int y, x;
+        for (y=0; y<bh; y++)
+        {
+            wxAlphaPixelData::Iterator rowStart = p;
+            for (x=0; x<bw; x++)
+            {
+                // Each pixel in CAIRO_FORMAT_ARGB32 is a 32-bit quantity,
+                // with alpha in the upper 8 bits, then red, then green, then
+                // blue. The 32-bit quantities are stored native-endian.
+                // Pre-multiplied alpha is used.
+                unsigned char alpha = p.Alpha();
+                if (alpha == 0)
+                    *data = 0;
+                else
+                    *data = ( alpha/255                  << 24
+                              | (p.Red() * alpha/255)    << 16
+                              | (p.Green() * alpha/255)  <<  8
+                              | (p.Blue() * alpha/255) );
+                ++data;
+                ++p;
+            }
+            p = rowStart;
+            p.OffsetY(pixData, 1);
+        }
+    }
+    else  // no alpha
+    {
+        surface = cairo_image_surface_create_for_data(
+            buffer, CAIRO_FORMAT_RGB24, bw, bh, bw*4);
+        wxNativePixelData pixData(bmpSource, wxPoint(0,0), wxSize(bw, bh));
+        wxCHECK_RET( pixData, wxT("Failed to gain raw access to bitmap data."));
+
+        wxNativePixelData::Iterator p(pixData);
+        int y, x;
+        for (y=0; y<bh; y++)
+        {
+            wxNativePixelData::Iterator rowStart = p;
+            for (x=0; x<bw; x++)
+            {
+                // Each pixel in CAIRO_FORMAT_RGB24 is a 32-bit quantity, with
+                // the upper 8 bits unused. Red, Green, and Blue are stored in
+                // the remaining 24 bits in that order.  The 32-bit quantities
+                // are stored native-endian.
+                *data = ( p.Red() << 16 | p.Green() << 8 | p.Blue() );
+                ++data;
+                ++p;
+            }
+            p = rowStart;
+            p.OffsetY(pixData, 1);
+        }
+    }
+
+
+    cairo_save(m_cairo);
+    // In case we're scaling the image by using a width and height different
+    // than the bitmap's size create a pattern transformation on the surface and
+    // draw the transformed pattern.
+    cairo_pattern_t* pattern = cairo_pattern_create_for_surface(surface);
+
+    // Prepare to draw the image.
+    cairo_translate(m_cairo, x, y);
+    cairo_set_source(m_cairo, pattern);
+    // Use the original size here since the context is scaled already.
+    cairo_rectangle(m_cairo, 0, 0, bw, bh);
+    // Fill the rectangle using the pattern.
+    cairo_fill(m_cairo);
+
+    // Clean up.
+    cairo_pattern_destroy(pattern);
+    cairo_surface_destroy(surface);
+    delete [] buffer;
+
+    CalcBoundingBox(0,0);
+    CalcBoundingBox(bw,bh);
+
+    cairo_restore(m_cairo);
+}
+
+// wxGtkPrintDC has a constant resolution of 72dpi. If we want an higher resolution for printing
+// an image, the scaling has to be done by cairo.
+void wxGtkPrintDC::DoDrawScaledBitmap( const wxBitmap& bitmap, wxCoord x, wxCoord y, wxCoord w, wxCoord h, bool useMask, int quality )
+{
+    wxCHECK_RET( bitmap.IsOk(), wxT("Invalid bitmap in wxGtkPrintDC::DoDrawBitmap"));
+
+    cairo_surface_t* surface;
+    int bw = bitmap.GetWidth();
+    int bh = bitmap.GetHeight();
+    x = LogicalToDeviceX(x);
+    y = LogicalToDeviceY(y);
+    w = LogicalToDeviceXRel(w);
+    h = LogicalToDeviceYRel(h);
+    wxBitmap bmpSource = bitmap;  // we need a non-const instance.
+    unsigned char* buffer = new unsigned char[bw*bh*4];
+    wxUint32* data = (wxUint32*)buffer;
+
+    // Create a surface object and copy the bitmap pixel data to it. If the image has alpha (or a mask represented as alpha)
+    // then we'll use a different format and iterator than if it doesn't.
+    if (bmpSource.HasAlpha() || bmpSource.GetMask())
+    {
+        surface = cairo_image_surface_create_for_data(
+            buffer, CAIRO_FORMAT_ARGB32, bw, bh, bw*4);
+        wxAlphaPixelData pixData(bmpSource, wxPoint(0,0), wxSize(bw, bh));
+        wxCHECK_RET( pixData, wxT("Failed to gain raw access to bitmap data."));
+
+        wxAlphaPixelData::Iterator p(pixData);
+        int y, x;
+        for (y=0; y<bh; y++)
+        {
+            wxAlphaPixelData::Iterator rowStart = p;
+            for (x=0; x<bw; x++)
+            {
+                // Each pixel in CAIRO_FORMAT_ARGB32 is a 32-bit quantity,
+                // with alpha in the upper 8 bits, then red, then green, then
+                // blue. The 32-bit quantities are stored native-endian.
+                // Pre-multiplied alpha is used.
+                unsigned char alpha = p.Alpha();
+                if (alpha == 0)
+                    *data = 0;
+                else
+                    *data = ( alpha                  << 24
+                              | (p.Red() * alpha/255)    << 16
+                              | (p.Green() * alpha/255)  <<  8
+                              | (p.Blue() * alpha/255) );
+                ++data;
+                ++p;
+            }
+            p = rowStart;
+            p.OffsetY(pixData, 1);
+        }
+    }
+    else  // no alpha
+    {
+        surface = cairo_image_surface_create_for_data(
+            buffer, CAIRO_FORMAT_RGB24, bw, bh, bw*4);
+        wxNativePixelData pixData(bmpSource, wxPoint(0,0), wxSize(bw, bh));
+        wxCHECK_RET( pixData, wxT("Failed to gain raw access to bitmap data."));
+
+        wxNativePixelData::Iterator p(pixData);
+        int y, x;
+        for (y=0; y<bh; y++)
+        {
+            wxNativePixelData::Iterator rowStart = p;
+            for (x=0; x<bw; x++)
+            {
+                // Each pixel in CAIRO_FORMAT_RGB24 is a 32-bit quantity, with
+                // the upper 8 bits unused. Red, Green, and Blue are stored in
+                // the remaining 24 bits in that order.  The 32-bit quantities
+                // are stored native-endian.
+                *data = ( p.Red() << 16 | p.Green() << 8 | p.Blue() );
+                ++data;
+                ++p;
+            }
+            p = rowStart;
+            p.OffsetY(pixData, 1);
+        }
+    }
+
+
+    cairo_save(m_cairo);
+
+    // Prepare to draw the image.
+    cairo_translate(m_cairo, x, y);
+
+    // In case we're scaling the image by using a width and height different
+    // than the bitmap's size create a pattern transformation on the surface and
+    // draw the transformed pattern.
+    cairo_filter_t filter;
+    if (quality == wxIMAGE_QUALITY_HIGH) filter = CAIRO_FILTER_BILINEAR;
+    else filter = CAIRO_FILTER_GOOD;
+    cairo_pattern_t* pattern = cairo_pattern_create_for_surface(surface);
+    cairo_pattern_set_filter(pattern,filter);
+    wxDouble scaleX = (wxDouble) w / (wxDouble) bw;
+    wxDouble scaleY = (wxDouble) h / (wxDouble) bh;
+    cairo_scale(m_cairo, scaleX, scaleY);
+
+    cairo_set_source(m_cairo, pattern);
+    // Use the original size here since the context is scaled already.
+    cairo_rectangle(m_cairo, 0, 0, bw, bh);
+    // Fill the rectangle using the pattern.
+    cairo_fill(m_cairo);
+
+    // Clean up.
+    cairo_pattern_destroy(pattern);
+    cairo_surface_destroy(surface);
+    delete [] buffer;
+
+    CalcBoundingBox(0,0);
+    CalcBoundingBox(bw,bh);
+
+    cairo_restore(m_cairo);
+}
+
+void wxGtkPrintDC::DoDrawText(const wxString& text, wxCoord x, wxCoord y )
+{
+    DoDrawRotatedText( text, x, y, 0.0 );
+}
+
+void wxGtkPrintDC::DoDrawRotatedText(const wxString& text, wxCoord x, wxCoord y, double angle)
+{
+    x = LogicalToDeviceX(x);
+    y = LogicalToDeviceY(y);
+
+    angle = -angle;
+
+    bool underlined = m_font.Ok() && m_font.GetUnderlined();
+
+// FIXME-UTF8: wouldn't be needed if utf8_str() always returned a buffer
+#if wxUSE_UNICODE_UTF8
+    const char *data = text.utf8_str();
+#else
+    const wxCharBuffer data = text.utf8_str();
+#endif
+
+    size_t datalen = strlen(data);
+    pango_layout_set_text( m_layout, data, datalen);
+
+    if (underlined)
+    {
+        PangoAttrList *attrs = pango_attr_list_new();
+        PangoAttribute *a = pango_attr_underline_new(PANGO_UNDERLINE_SINGLE);
+        a->start_index = 0;
+        a->end_index = datalen;
+        pango_attr_list_insert(attrs, a);
+        pango_layout_set_attributes(m_layout, attrs);
+        pango_attr_list_unref(attrs);
+    }
+
+    if (m_textForegroundColour.Ok())
+    {
+        unsigned char red = m_textForegroundColour.Red();
+        unsigned char blue = m_textForegroundColour.Blue();
+        unsigned char green = m_textForegroundColour.Green();
+        unsigned char alpha = m_textForegroundColour.Alpha();
+
+        if (!(red == m_currentRed && green == m_currentGreen && blue == m_currentBlue && alpha == m_currentAlpha))
+        {
+            double redPS = (double)(red) / 255.0;
+            double bluePS = (double)(blue) / 255.0;
+            double greenPS = (double)(green) / 255.0;
+            double alphaPS = (double)(alpha) / 255.0;
+
+            cairo_set_source_rgba( m_cairo, redPS, greenPS, bluePS, alphaPS );
+
+            m_currentRed = red;
+            m_currentBlue = blue;
+            m_currentGreen = green;
+            m_currentAlpha = alpha;
+        }
+    }
+
+    int w,h;
+
+    if (fabs(m_scaleY - 1.0) > 0.00001)
+    {
+        // If there is a user or actually any scale applied to the device context, scale the font.
+
+        // Scale font description.
+        gint oldSize = pango_font_description_get_size( m_fontdesc );
+        double size = oldSize;
+        size = size * m_scaleY;
+        pango_font_description_set_size( m_fontdesc, (gint)size );
+
+        // Actually apply scaled font.
+        pango_layout_set_font_description( m_layout, m_fontdesc );
+
+        pango_layout_get_pixel_size( m_layout, &w, &h );
+        w = LogicalToDeviceXRel(w);
+        h = LogicalToDeviceYRel(h);
+
+        if ( m_backgroundMode == wxSOLID )
+        {
+            unsigned char red = m_textBackgroundColour.Red();
+            unsigned char blue = m_textBackgroundColour.Blue();
+            unsigned char green = m_textBackgroundColour.Green();
+            unsigned char alpha = m_textBackgroundColour.Alpha();
+
+            double redPS = (double)(red) / 255.0;
+            double bluePS = (double)(blue) / 255.0;
+            double greenPS = (double)(green) / 255.0;
+            double alphaPS = (double)(alpha) / 255.0;
+
+            cairo_save(m_cairo);
+            cairo_translate(m_cairo, x, y);
+            cairo_set_source_rgba( m_cairo, redPS, greenPS, bluePS, alphaPS );
+            cairo_rotate(m_cairo,angle*DEG2RAD);
+            cairo_rectangle(m_cairo, 0, 0, w, h);
+            cairo_fill(m_cairo);
+            cairo_restore(m_cairo);
+        }
+
+        // Draw layout.
+        cairo_move_to (m_cairo, x, y);
+        if (fabs(angle) > 0.00001)
+        {
+            cairo_save( m_cairo );
+            cairo_rotate( m_cairo, angle*DEG2RAD );
+            pango_cairo_update_layout (m_cairo, m_layout);
+            pango_cairo_show_layout (m_cairo, m_layout);
+            cairo_restore( m_cairo );
+        }
+        else
+        {
+            pango_cairo_update_layout (m_cairo, m_layout);
+            pango_cairo_show_layout (m_cairo, m_layout);
+        }
+
+        // Reset unscaled size.
+        pango_font_description_set_size( m_fontdesc, oldSize );
+
+        // Actually apply unscaled font.
+        pango_layout_set_font_description( m_layout, m_fontdesc );
+    }
+    else
+    {
+        pango_layout_get_pixel_size( m_layout, &w, &h );
+
+        if ( m_backgroundMode == wxSOLID )
+        {
+            unsigned char red = m_textBackgroundColour.Red();
+            unsigned char blue = m_textBackgroundColour.Blue();
+            unsigned char green = m_textBackgroundColour.Green();
+            unsigned char alpha = m_textBackgroundColour.Alpha();
+
+            double redPS = (double)(red) / 255.0;
+            double bluePS = (double)(blue) / 255.0;
+            double greenPS = (double)(green) / 255.0;
+            double alphaPS = (double)(alpha) / 255.0;
+
+            cairo_save(m_cairo);
+            cairo_translate(m_cairo, x, y);
+            cairo_set_source_rgba( m_cairo, redPS, greenPS, bluePS, alphaPS );
+            cairo_rotate(m_cairo,angle*DEG2RAD);
+            cairo_rectangle(m_cairo, 0, 0, w, h);
+            cairo_fill(m_cairo);
+            cairo_restore(m_cairo);
+        }
+
+        // Draw layout.
+        cairo_move_to (m_cairo, x, y);
+        if (fabs(angle) > 0.00001)
+        {
+            cairo_save( m_cairo );
+            cairo_rotate( m_cairo, angle*DEG2RAD );
+            pango_cairo_update_layout (m_cairo, m_layout);
+            pango_cairo_show_layout (m_cairo, m_layout);
+            cairo_restore( m_cairo );
+        }
+        else
+        {
+            pango_cairo_update_layout (m_cairo, m_layout);
+            pango_cairo_show_layout (m_cairo, m_layout);
+        }
+    }
+
+    if (underlined)
+    {
+        // Undo underline attributes setting
+        pango_layout_set_attributes(m_layout, NULL);
+    }
+
+    CalcBoundingBox (x,y);
+    CalcBoundingBox (x + w, y + h);
+}
+
+void wxGtkPrintDC::Clear()
+{
+    cairo_save(m_cairo);
+    cairo_set_operator (m_cairo, CAIRO_OPERATOR_SOURCE);
+    SetBrush(m_backgroundBrush);
+    cairo_paint(m_cairo);
+    cairo_restore(m_cairo);
+}
+
+void wxGtkPrintDC::SetFont( const wxFont& font )
+{
+    m_font = font;
+
+    if (m_font.Ok())
+    {
+        if (m_fontdesc)
+            pango_font_description_free( m_fontdesc );
+
+        m_fontdesc = pango_font_description_copy( m_font.GetNativeFontInfo()->description );
+
+        pango_layout_set_font_description( m_layout, m_fontdesc );
+    }
+}
+
+void wxGtkPrintDC::SetPen( const wxPen& pen )
+{
+    if (!pen.Ok()) return;
+
+    m_pen = pen;
+
+    double width = (double) m_pen.GetWidth();
+    if (width == 0) width = 0.1;
+
+    cairo_set_line_width( m_cairo, LogicalToDeviceXRel( (wxCoord) (1000 * width )) / 1000.0f );
+    static const double dotted[] = {2.0, 5.0};
+    static const double short_dashed[] = {4.0, 4.0};
+    static const double long_dashed[] = {4.0, 8.0};
+    static const double dotted_dashed[] = {6.0, 6.0, 2.0, 6.0};
+
+    switch (m_pen.GetStyle())
+    {
+        case wxDOT:           cairo_set_dash( m_cairo, dotted, 1, 0 ); break;
+        case wxSHORT_DASH:    cairo_set_dash( m_cairo, short_dashed, 1, 0 ); break;
+        case wxLONG_DASH:     cairo_set_dash( m_cairo, long_dashed, 1, 0 ); break;
+        case wxDOT_DASH:      cairo_set_dash( m_cairo, dotted_dashed, 3, 0 );  break;
+        case wxUSER_DASH:
+        {
+            wxDash *wx_dashes;
+            int num = m_pen.GetDashes (&wx_dashes) - 1;
+            gdouble *g_dashes = g_new( gdouble, num );
+            int i;
+            for (i = 0; i < num; ++i)
+                g_dashes[i] = (gdouble) wx_dashes[i];
+            cairo_set_dash( m_cairo, g_dashes, num, 0);
+            g_free( g_dashes );
+        }
+        break;
+        case wxSOLID:
+        case wxTRANSPARENT:
+        default:              cairo_set_dash( m_cairo, NULL, 0, 0 );   break;
+    }
+
+    switch (m_pen.GetCap())
+    {
+        case wxCAP_PROJECTING:  cairo_set_line_cap (m_cairo, CAIRO_LINE_CAP_SQUARE); break;
+        case wxCAP_BUTT:        cairo_set_line_cap (m_cairo, CAIRO_LINE_CAP_BUTT); break;
+        case wxCAP_ROUND:
+        default:                cairo_set_line_cap (m_cairo, CAIRO_LINE_CAP_ROUND); break;
+    }
+
+    switch (m_pen.GetJoin())
+    {
+        case wxJOIN_BEVEL:  cairo_set_line_join (m_cairo, CAIRO_LINE_JOIN_BEVEL); break;
+        case wxJOIN_MITER:  cairo_set_line_join (m_cairo, CAIRO_LINE_JOIN_MITER); break;
+        case wxJOIN_ROUND:
+        default:            cairo_set_line_join (m_cairo, CAIRO_LINE_JOIN_ROUND); break;
+    }
+
+    unsigned char red = m_pen.GetColour().Red();
+    unsigned char blue = m_pen.GetColour().Blue();
+    unsigned char green = m_pen.GetColour().Green();
+    unsigned char alpha = m_pen.GetColour().Alpha();
+
+    if (!(red == m_currentRed && green == m_currentGreen && blue == m_currentBlue && alpha == m_currentAlpha))
+    {
+        double redPS = (double)(red) / 255.0;
+        double bluePS = (double)(blue) / 255.0;
+        double greenPS = (double)(green) / 255.0;
+        double alphaPS = (double)(alpha) / 255.0;
+
+        cairo_set_source_rgba( m_cairo, redPS, greenPS, bluePS, alphaPS );
+
+        m_currentRed = red;
+        m_currentBlue = blue;
+        m_currentGreen = green;
+        m_currentAlpha = alpha;
+    }
+}
+
+void wxGtkPrintDC::SetBrush( const wxBrush& brush )
+{
+    if (!brush.Ok()) return;
+
+    m_brush = brush;
+
+    // Brush colour.
+    unsigned char red = m_brush.GetColour().Red();
+    unsigned char blue = m_brush.GetColour().Blue();
+    unsigned char green = m_brush.GetColour().Green();
+    unsigned char alpha = m_brush.GetColour().Alpha();
+
+    double redPS = (double)(red) / 255.0;
+    double bluePS = (double)(blue) / 255.0;
+    double greenPS = (double)(green) / 255.0;
+    double alphaPS = (double)(alpha) / 255.0;
+
+    if (!(red == m_currentRed && green == m_currentGreen && blue == m_currentBlue && alpha == m_currentAlpha))
+    {
+        cairo_set_source_rgba( m_cairo, redPS, greenPS, bluePS, alphaPS );
+
+        m_currentRed = red;
+        m_currentBlue = blue;
+        m_currentGreen = green;
+        m_currentAlpha = alpha;
+    }
+
+    if (m_brush.IsHatch())
+    {
+        cairo_t * cr;
+        cairo_surface_t *surface;
+        surface = cairo_surface_create_similar(cairo_get_target(m_cairo),CAIRO_CONTENT_COLOR_ALPHA,10,10);
+        cr = cairo_create(surface);
+        cairo_set_line_cap(cr, CAIRO_LINE_CAP_SQUARE);
+        cairo_set_line_width(cr, 1);
+        cairo_set_line_join(cr,CAIRO_LINE_JOIN_MITER);
+
+        switch (m_brush.GetStyle())
+        {
+            case wxCROSS_HATCH:
+                cairo_move_to(cr, 5, 0);
+                cairo_line_to(cr, 5, 10);
+                cairo_move_to(cr, 0, 5);
+                cairo_line_to(cr, 10, 5);
+                break;
+            case wxBDIAGONAL_HATCH:
+                cairo_move_to(cr, 0, 10);
+                cairo_line_to(cr, 10, 0);
+                break;
+            case wxFDIAGONAL_HATCH:
+                cairo_move_to(cr, 0, 0);
+                cairo_line_to(cr, 10, 10);
+                break;
+            case wxCROSSDIAG_HATCH:
+                cairo_move_to(cr, 0, 0);
+                cairo_line_to(cr, 10, 10);
+                cairo_move_to(cr, 10, 0);
+                cairo_line_to(cr, 0, 10);
+                break;
+            case wxHORIZONTAL_HATCH:
+                cairo_move_to(cr, 0, 5);
+                cairo_line_to(cr, 10, 5);
+                break;
+            case wxVERTICAL_HATCH:
+                cairo_move_to(cr, 5, 0);
+                cairo_line_to(cr, 5, 10);
+                break;
+            default:
+                wxFAIL_MSG(_("Couldn't get hatch style from wxBrush."));
+        }
+
+        cairo_set_source_rgba(cr, redPS, greenPS, bluePS, alphaPS);
+        cairo_stroke (cr);
+
+        cairo_destroy(cr);
+        cairo_pattern_t * pattern = cairo_pattern_create_for_surface (surface);
+        cairo_surface_destroy(surface);
+        cairo_pattern_set_extend (pattern, CAIRO_EXTEND_REPEAT);
+        cairo_set_source(m_cairo, pattern);
+        cairo_pattern_destroy(pattern);
+    }
+}
+
+void wxGtkPrintDC::SetLogicalFunction( int function )
+{
+    if (function == wxCLEAR)
+        cairo_set_operator (m_cairo, CAIRO_OPERATOR_CLEAR);
+    else if (function == wxOR)
+        cairo_set_operator (m_cairo, CAIRO_OPERATOR_OUT);
+    else if (function == wxNO_OP)
+        cairo_set_operator (m_cairo, CAIRO_OPERATOR_DEST);
+    else if (function == wxAND)
+        cairo_set_operator (m_cairo, CAIRO_OPERATOR_ADD);
+    else if (function == wxSET)
+        cairo_set_operator (m_cairo, CAIRO_OPERATOR_SATURATE);
+    else if (function == wxXOR)
+        cairo_set_operator (m_cairo, CAIRO_OPERATOR_XOR);
+    else // wxCOPY or anything else.
+        cairo_set_operator (m_cairo, CAIRO_OPERATOR_SOURCE);
+}
+
+void wxGtkPrintDC::SetBackground( const wxBrush& brush )
+{
+    m_backgroundBrush = brush;
+    cairo_save(m_cairo);
+    cairo_set_operator (m_cairo, CAIRO_OPERATOR_DEST_OVER);
+
+    SetBrush(m_backgroundBrush);
+    cairo_paint(m_cairo);
+    cairo_restore(m_cairo);
+}
+
+void wxGtkPrintDC::SetBackgroundMode(int mode)
+{
+    if (mode == wxSOLID) m_backgroundMode = wxSOLID;
+    else m_backgroundMode = wxTRANSPARENT;
+}
+
+void wxGtkPrintDC::DoSetClippingRegion(wxCoord x, wxCoord y, wxCoord width, wxCoord height)
+{
+    cairo_rectangle ( m_cairo, LogicalToDeviceX(x), LogicalToDeviceY(y), LogicalToDeviceXRel(width), LogicalToDeviceYRel(height));
+    cairo_clip(m_cairo);
+}
+
+void wxGtkPrintDC::DestroyClippingRegion()
+{
+    cairo_reset_clip(m_cairo);
+}
+
+bool wxGtkPrintDC::StartDoc(const wxString& message)
+{
+    return true;
+}
+
+void wxGtkPrintDC::EndDoc()
+{
+    return;
+}
+
+void wxGtkPrintDC::StartPage()
+{
+    return;
+}
+
+void wxGtkPrintDC::EndPage()
+{
+    return;
+}
+
+wxCoord wxGtkPrintDC::GetCharHeight() const
+{
+    pango_layout_set_text( m_layout, "H", 1 );
+
+    int w,h;
+    pango_layout_get_pixel_size( m_layout, &w, &h );
+
+    return DeviceToLogicalYRel(h);
+}
+
+wxCoord wxGtkPrintDC::GetCharWidth() const
+{
+    pango_layout_set_text( m_layout, "H", 1 );
+
+    int w,h;
+    pango_layout_get_pixel_size( m_layout, &w, &h );
+
+    return DeviceToLogicalXRel(w);
+}
+
+void wxGtkPrintDC::DoGetTextExtent(const wxString& string, wxCoord *width, wxCoord *height,
+                     wxCoord *descent,
+                     wxCoord *externalLeading,
+                     const wxFont *theFont ) const
+{
+    if ( width )
+        *width = 0;
+    if ( height )
+        *height = 0;
+    if ( descent )
+        *descent = 0;
+    if ( externalLeading )
+        *externalLeading = 0;
+
+    if (string.empty())
+    {
+        return;
+    }
+
+    // Set layout's text
+    // FIXME-UTF8: wouldn't be needed if utf8_str() always returned a buffer
+#if wxUSE_UNICODE_UTF8
+    const char *dataUTF8 = string.utf8_str();
+#else
+    const wxCharBuffer dataUTF8 = string.utf8_str();
+#endif
+
+    PangoFontDescription *desc = m_fontdesc;
+    if (theFont) desc = theFont->GetNativeFontInfo()->description;
+
+    gint oldSize = pango_font_description_get_size( desc );
+    double size = oldSize;
+    size = size * m_scaleY;
+    pango_font_description_set_size( desc, (gint)size );
+
+    // apply scaled font
+    pango_layout_set_font_description( m_layout, desc );
+
+    pango_layout_set_text( m_layout, dataUTF8, strlen(dataUTF8) );
+
+    int w, h;
+    pango_layout_get_pixel_size( m_layout, &w, &h );
+
+    if (width)
+        *width = (wxCoord)(w / m_scaleX);
+    if (height)
+        *height = (wxCoord)(h / m_scaleY);
+    if (descent)
+    {
+        PangoLayoutIter *iter = pango_layout_get_iter(m_layout);
+        int baseline = pango_layout_iter_get_baseline(iter);
+        pango_layout_iter_free(iter);
+        *descent = h - PANGO_PIXELS(baseline);
+    }
+
+    // Reset unscaled size.
+    pango_font_description_set_size( desc, oldSize );
+
+    // Reset unscaled font.
+    pango_layout_set_font_description( m_layout, m_fontdesc );
+}
+
+void wxGtkPrintDC::DoGetSize(int* width, int* height) const
+{
+    if (width)
+        *width = (int) (gs_gp->gtk_print_context_get_width( m_gpc ) + 0.5);
+    if (height)
+        *height = (int) (gs_gp->gtk_print_context_get_height( m_gpc ) + 0.5);
+}
+
+void wxGtkPrintDC::DoGetSizeMM(int *width, int *height) const
+{
+    // This function takes margins into consideration.
+    gdouble w = gs_gp->gtk_page_setup_get_page_width( gs_gp->gtk_print_context_get_page_setup( m_gpc ), GTK_UNIT_MM);
+    gdouble h = gs_gp->gtk_page_setup_get_page_height( gs_gp->gtk_print_context_get_page_setup( m_gpc ), GTK_UNIT_MM);
+
+    if (width)
+        *width = (int) (w + 0.5);
+    if (height)
+        *height = (int) (h + 0.5);
+}
+
+wxSize wxGtkPrintDC::GetPPI() const
+{
+    gdouble xDpi = gs_gp->gtk_print_context_get_dpi_x( m_gpc );
+    gdouble yDpi = gs_gp->gtk_print_context_get_dpi_y( m_gpc );
+    return wxSize((int) xDpi,(int) yDpi);
+}
+
+void wxGtkPrintDC::SetLogicalOrigin( wxCoord x, wxCoord y )
+{
+    wxDC::SetLogicalOrigin( x, y );
+}
+
+void wxGtkPrintDC::SetDeviceOrigin( wxCoord x, wxCoord y )
+{
+    wxDC::SetDeviceOrigin( x, y );
+}
+
+void wxGtkPrintDC::SetPrintData(const wxPrintData& data)
+{
+    m_printData = data;
+
+    if (m_printData.GetOrientation() == wxPORTRAIT)
+        GetSize( &m_deviceOffsetX, &m_deviceOffsetY );
+    else
+        GetSize( &m_deviceOffsetY, &m_deviceOffsetX );
+}
+
+void wxGtkPrintDC::SetResolution(int ppi)
+{
+    // We can't change ppi of the GtkPrintContext.
+    ms_resolution = ppi;
+}
+
+int wxGtkPrintDC::GetResolution()
+{
+    return ms_resolution;
+}
+
+// ----------------------------------------------------------------------------
+// Print preview
+// ----------------------------------------------------------------------------
+
+IMPLEMENT_CLASS(wxGtkPrintPreview, wxPrintPreviewBase)
+
+void wxGtkPrintPreview::Init(wxPrintout * WXUNUSED(printout),
+                                    wxPrintout * WXUNUSED(printoutForPrinting))
+{
+    DetermineScaling();
+}
+
+wxGtkPrintPreview::wxGtkPrintPreview(wxPrintout *printout,
+                                                   wxPrintout *printoutForPrinting,
+                                                   wxPrintDialogData *data)
+                        : wxPrintPreviewBase(printout, printoutForPrinting, data)
+{
+    Init(printout, printoutForPrinting);
+}
+
+wxGtkPrintPreview::wxGtkPrintPreview(wxPrintout *printout,
+                                                   wxPrintout *printoutForPrinting,
+                                                   wxPrintData *data)
+                        : wxPrintPreviewBase(printout, printoutForPrinting, data)
+{
+    Init(printout, printoutForPrinting);
+}
+
+wxGtkPrintPreview::~wxGtkPrintPreview()
+{
+}
+
+bool wxGtkPrintPreview::Print(bool interactive)
+{
+    if (!m_printPrintout)
+        return false;
+
+    wxPrinter printer(& m_printDialogData);
+    return printer.Print(m_previewFrame, m_printPrintout, interactive);
+}
+
+void wxGtkPrintPreview::DetermineScaling()
+{
+    wxPaperSize paperType = m_printDialogData.GetPrintData().GetPaperId();
+
+    wxPrintPaperType *paper = wxThePrintPaperDatabase->FindPaperType(paperType);
+    if (!paper)
+        paper = wxThePrintPaperDatabase->FindPaperType(wxPAPER_A4);
+
+    if (paper)
+    {
+        wxSize ScreenPixels = wxGetDisplaySize();
+        wxSize ScreenMM = wxGetDisplaySizeMM();
+
+        m_previewPrintout->SetPPIScreen( (int) ((ScreenPixels.GetWidth() * 25.4) / ScreenMM.GetWidth()),
+                                         (int) ((ScreenPixels.GetHeight() * 25.4) / ScreenMM.GetHeight()) );
+        m_previewPrintout->SetPPIPrinter(wxGtkPrintDC::GetResolution(), wxGtkPrintDC::GetResolution());
+        // Get width and height in points (1/72th of an inch)
+        wxSize sizeDevUnits(paper->GetSizeDeviceUnits());
+
+        sizeDevUnits.x = (wxCoord)((float)sizeDevUnits.x * wxGtkPrintDC::GetResolution() / 72.0);
+        sizeDevUnits.y = (wxCoord)((float)sizeDevUnits.y * wxGtkPrintDC::GetResolution() / 72.0);
+        wxSize sizeTenthsMM(paper->GetSize());
+        wxSize sizeMM(sizeTenthsMM.x / 10, sizeTenthsMM.y / 10);
+
+        // If in landscape mode, we need to swap the width and height.
+        if ( m_printDialogData.GetPrintData().GetOrientation() == wxLANDSCAPE )
+        {
+            m_pageWidth = sizeDevUnits.y;
+            m_pageHeight = sizeDevUnits.x;
+            m_previewPrintout->SetPageSizeMM(sizeMM.y, sizeMM.x);
+        }
+        else
+        {
+            m_pageWidth = sizeDevUnits.x;
+            m_pageHeight = sizeDevUnits.y;
+            m_previewPrintout->SetPageSizeMM(sizeMM.x, sizeMM.y);
+        }
+        m_previewPrintout->SetPageSizePixels(m_pageWidth, m_pageHeight);
+        m_previewPrintout->SetPaperRectPixels(wxRect(0, 0, m_pageWidth, m_pageHeight));
+
+        // At 100%, the page should look about page-size on the screen.
+        m_previewScaleX = (float)0.8 * 72.0 / (float)wxGtkPrintDC::GetResolution();
+        m_previewScaleY = m_previewScaleX;
+    }
+}
+
+#endif
+    // wxUSE_GTKPRINT

 	  	 
