diff -rbu2P wxw/contrib/include/wx/resizec/resizec.h wxWindows/contrib/include/wx/resizec/resizec.h
--- wxw/contrib/include/wx/resizec/resizec.h	Thu Jan 01 01:00:00 1970
+++ wxWindows/contrib/include/wx/resizec/resizec.h	Thu Jun 19 13:02:12 2003
@@ -0,0 +1,481 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/resizec.h
+// Purpose:     wxResizeableControl base class and derived classes
+//              for resizeable pictures
+// Author:      Markus Greither
+// Modified by:
+// Created:     11/10/02
+// RCS-ID:      $Id:     1.02 2003/04/30 magr
+// Copyright:   (c) Markus Greither
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef __RESIZECONTROL__
+#define __RESIZECONTROL__
+
+#if defined(__WXMSW__) && wxUSE_METAFILE && wxUSE_ENH_METAFILE
+#include "wx/metafile.h"
+#endif
+
+// ----------------------------------------------------------------------------
+// wxResizeableControl
+// ----------------------------------------------------------------------------
+
+//! Class for zoomable windows
+/*! Stores the original size of the window, so that
+    Zooming is always computed from this data, and thus
+    rounding errors are avoided.
+*/
+class wxZoomData
+{
+    //! Original window size
+    wxSize m_orgSize;
+    //! Original window pos
+    wxPoint m_orgPos;
+    //! Current window size
+    wxRect m_currRect;
+    //! Current zoom factor
+    float m_zoom;
+ public:
+    //! Ctor
+    wxZoomData() : m_zoom(1) {}
+    //! Ctor
+    wxZoomData(const wxSize &size,const wxPoint &pos)
+     : m_orgSize(size),m_orgPos(pos),m_zoom(1) {}
+    //! Set new zoom factor (changes size only)
+    void SetZoomSize(wxWindow *Window,float zoom)
+    {
+        m_zoom = zoom;
+        m_currRect = wxRect(m_currRect.GetPosition(),
+                            wxSize(int(m_orgSize.x*m_zoom),
+                                   int(m_orgSize.y*m_zoom)));
+        Window->SetSize(m_currRect.GetSize());
+    }
+    //! Set new zoom factor (position and size)
+    /*! curxoffs and curyoffs are the current offset values (e. g.
+        scroll position) in absolute size (unzoomed)
+        newxoffs and newyoffs are the new offset values
+    */
+    void SetZoomRect(wxWindow *Window,float zoom,
+                     int curxoffs,int curyoffs,
+                     int newxoffs,int newyoffs);
+    //! Changes zoom factor without resizing the window
+    void SetCurrentZoom(float zoom)
+    {
+        m_zoom = zoom;
+        m_orgPos.x = int(m_orgPos.x/zoom);
+        m_orgPos.y = int(m_orgPos.y/zoom);
+        m_orgSize.x = int(m_orgSize.x/zoom);
+        m_orgSize.y = int(m_orgSize.y/zoom);
+    }
+    //! Returns the current zoom factor
+    float GetZoom() {return m_zoom;}
+    //! Updates the original window size
+    void SetSize(int width,int height);
+    //! Updates the original window position
+    void Move(int xpos,int ypos);
+};
+
+//! Class for moveable and resizable child windows
+/*!
+    This class draws resize rectangles on each side and corner when focused.
+    Dragging these rectangles resizes the window.
+    
+    
+
+    This class needs to be overloaded and Paint() defined with the graphics
+    rendering.
+
+    This would make a perfect abstract class, but the
+    definition of wxDynamicCast() doesn't allow this.
+*/
+class wxResizeableControl : public wxWindow
+{
+ public:
+    //! Flags for resize mode
+    enum SizeMoveModes
+    {
+        Top = 0,
+        Bottom,
+        Left,
+        Right,
+        TopLeft,
+        BottomLeft,
+        TopRight,
+        BottomRight,
+        MoveWin,
+        MaxMode
+    };
+    //! Size box dimension
+    enum SizeRads
+    {
+        SizeXRad = 5,
+        SizeYRad = 5
+    };
+    //! Ctor
+    wxResizeableControl() : wxWindow() {}
+    //! Ctor
+    wxResizeableControl(wxWindow *AParent, int AnId,const wxPoint &pos,
+                        const wxSize &size,long style = 0,
+                        const wxString &name = wxPanelNameStr);
+    //! Dtor
+    virtual ~wxResizeableControl() {}
+    //! Paint function for printing and screen output
+    virtual void Paint(wxDC &dc,bool Printing,wxSize &size) {}
+    //! Returns original size of control
+    virtual wxSize GetOriginalSize() {return wxSize(-1,-1);}
+    //! Returns with/height ratio
+    /*! By overloading this function a fixed with/height
+        ratio can be set. The default is to allow any ratio.
+    */
+    virtual float GetRatio()
+    {
+        return 0;
+    }
+    //! Returns the zoom data object
+    wxZoomData &GetZoomData() {return m_zoomData;}
+    //! Set new zoom factor and resize the window accordingly
+    void SetZoom(float Zoom)
+    {
+        m_zoomData.SetZoomSize(this,Zoom);
+    }
+    //! Set new zoom factor, but do not resize/move
+    void SetCurrentZoom(float Zoom)
+    {
+        m_zoomData.SetCurrentZoom(Zoom);
+    }
+    //! Draw a focus rectangle with the given coordinates
+    inline void DrawFocusRect(wxDC &dc,wxRect rct)
+    {
+        FocusRectCoord(dc,rct.x,rct.y,rct.width,rct.height);
+    }
+    //! Make sure the zoom data gets updated when the window is moved
+    void DoSetSize(int x, int y,int width, int height,
+                   int sizeFlags = wxSIZE_AUTO)
+    {
+        if ((x != -1) || (y != -1))
+            m_zoomData.Move(x,y);
+        if ((width != -1) || (height != -1))
+            m_zoomData.SetSize(width,height);
+        wxWindow::DoSetSize(x,y,width,height,sizeFlags);
+    }
+
+// Event Handlers
+
+    //! Responds to set cursor event
+    /*! Sets the cursor accordingly for size rectangles (SIZE cursors)
+        or main control area (move cursor)
+    */ 
+    void OnSetCursor(wxSetCursorEvent &event);
+    //! Responds to left button up event
+    /*! In case of a drag operation, moves the window to the new position.
+        Mouse capture is released here.
+    */
+    void OnLButtonUp(wxMouseEvent &event);
+    //! Responds to left button down event
+    /*! Stores the current mouse position and determines the move mode
+        If cursor is in size rectangles, according resize mode is selected
+        If cursor is in main control arey, move mode is selected.
+        The mouse is captured here.
+    */
+    void OnLButtonDown(wxMouseEvent &event);
+    //! Responds to mouse move event
+    /*! If mouse is captured and moved wider that the threshold,
+        the resize or move rectangle for the new window size/position is drawn.
+    */
+    void OnMouseMove(wxMouseEvent &event);
+    //! Kill focus event hides the size rectangles
+    void OnKillFocus(wxFocusEvent &event);
+    //! Set focus event draws size rectangles
+    void OnSetFocus(wxFocusEvent &event);
+    //! Cut event deletes the window
+    /*! The parent window receives notification of deletion.
+    */
+    void OnEditCut(wxCommandEvent &ce);
+    //! Key down event of WXK_DELETE deletes the window
+    void OnKeyDown(wxKeyEvent &event);
+    //! Reponds to size event
+    /*! Updates the zoom data and sends parent window notification.
+    */
+    void OnSize(wxSizeEvent &event);
+    //! Reponds to move event
+    /*! Updates the zoom data and sends parent window notification.
+    */
+    void OnMove(wxMoveEvent &event);
+
+ protected:
+    //! Zoom data
+    wxZoomData m_zoomData;
+    //! Flag for mouse capture
+    int m_capt;
+    //! Cached mouse cursor positions
+    wxPoint m_curpos,m_lastcurpos;
+    //! Saved move mode from left button down
+    int m_movemode;
+    //! Flags for focus and move state
+    bool m_hasfocus,m_moved;
+
+    //! Draws a focus rectangle
+    void FocusRectCoord(wxDC &DC,wxCoord x1,wxCoord y1,wxCoord w,wxCoord h);
+    //! Returns window x size
+    int GetSizeX(int Mode);
+    //! Returns window y size
+    int GetSizeY(int Mode);
+    //! Draw ored rectangle of current new size (redraw to remove)
+    void DrawMoveRect(wxPoint hp,int Mode,float Ratio = 0);
+    //! Return new rectangle size, based on mouse position hp
+    wxRect NewRect(wxPoint hp,int Mode,float Ratio = 0);
+    //! Draw size boxes for resize
+    void DrawSizeRect(wxDC &dc);
+    //! Determine in which size box the pouse position hp is if any
+    int PointInSizeRect(wxPoint hp);
+
+    DECLARE_EVENT_TABLE()
+    DECLARE_DYNAMIC_CLASS(wxResizeableControl)
+};
+
+// ----------------------------------------------------------------------------
+// wxPictureControl
+// ----------------------------------------------------------------------------
+
+//! Abstract class for pictures
+/*! This would make a perfect abstract class, but the
+    definition of wxDynamicCast() doesn't allow this.
+*/
+class wxPictureControl : public wxResizeableControl
+{
+ public:
+    //! Ctor
+    wxPictureControl() : wxResizeableControl() {};
+    //! Ctor
+    wxPictureControl(wxWindow *AParent, int AnId,const wxPoint &pos,
+                      const wxSize &size,long style = 0,
+                      const wxString &name = wxPanelNameStr)
+      : wxResizeableControl(AParent,AnId,pos,size,style,name) {}
+    //! Return picture type string
+    virtual const wxChar *GetPictureType() {return wxT("NOTYPE");}
+    //! Return picture data size
+    virtual long GetPictureSize() {return 0;}
+    //! Copy picture data into pt
+    virtual long GetPictureData(char *,long) {return 0;}
+
+// Event handlers
+
+    //! Reset original size if available
+    void OnRevert(wxCommandEvent &event);
+    //! Show context menu
+    void OnRightDown(wxMouseEvent &event);
+    //! Respond to system color palette change event
+    void OnPaletteChanged(wxSysColourChangedEvent &event);
+    //! Cut event
+    void OnEditCut(wxCommandEvent &ce);
+    //! Copy event
+    virtual void OnEditCopy(wxCommandEvent &ce) {}
+    //! Enable cut event
+    void CeEditCut(wxUpdateUIEvent &ce)
+    {
+        ce.Enable(true);
+    }
+    //! Enable copy event
+    void CeEditCopy(wxUpdateUIEvent &ce)
+    {
+        ce.Enable(true);
+    }
+    //! Reponds to size event
+    void OnSize(wxSizeEvent &event);
+    //! Responds to paint event
+    void OnPaint(wxPaintEvent &event);
+
+ protected:
+    DECLARE_EVENT_TABLE()
+    DECLARE_DYNAMIC_CLASS(wxPictureControl)
+};
+
+
+#if defined(__WXMSW__) && wxUSE_METAFILE && wxUSE_ENH_METAFILE
+// ----------------------------------------------------------------------------
+// wxMetafileControl
+// ----------------------------------------------------------------------------
+
+//! Class for EnhMetaFile pictures
+class wxMetafileControl : public wxPictureControl
+{
+ public:
+    //! Ctor
+    wxMetafileControl() : wxPictureControl() {};
+    //! Ctor
+    wxMetafileControl(wxWindow *AParent, int AnId,WXHANDLE Meta,
+                      const wxPoint &pos,
+                      const wxSize &size,long style = 0,
+                      const wxString &name = wxPanelNameStr);
+    //! Ctor with raw picture data
+    wxMetafileControl(wxWindow *AParent, int AnId,char *Data,int Size,
+                      const wxPoint &pos,const wxSize &size,long style = 0,
+                      const wxString &name = wxPanelNameStr);
+    //! Dtor
+    virtual ~wxMetafileControl();
+    //! Return picture type name
+    const wxChar *GetPictureType()
+    {
+        return wxT("EnhMetaFile");
+    }
+    //! Returns picture data size
+    long GetPictureSize();
+    //! Copy picture data into data
+    long GetPictureData(char *data,long n);
+    //! Return the picture in bitmap format
+    const wxEnhMetaFile &GetMetafile() { return m_metafile; }
+    //! Paint function for printing
+    void Paint(wxDC &dc,bool Printing,wxSize &size);
+    //! Returns with/height ratio
+    float GetRatio();
+    //! Returns original size of control
+    wxSize GetOriginalSize();
+
+// Event handlers
+
+    //! Responds to copy event
+    void OnEditCopy(wxCommandEvent &event);
+
+ protected:
+    //! Displayed metafile
+    wxEnhMetaFile m_metafile;
+
+    DECLARE_EVENT_TABLE()
+    DECLARE_DYNAMIC_CLASS(wxMetafileControl)
+};
+
+#endif
+
+// ----------------------------------------------------------------------------
+// wxBitmapControl
+// ----------------------------------------------------------------------------
+
+//! Class for Bitmaps
+class wxBitmapControl : public wxPictureControl
+{
+ public:
+    //! Ctor
+    wxBitmapControl() : wxPictureControl(),m_bitmap(0) {};
+    //! Ctor
+    wxBitmapControl(wxWindow *AParent, int AnId,const wxBitmap &Data,
+                    const wxPoint &pos,
+                    const wxSize &size,long style = 0,
+                    const wxString &name = wxPanelNameStr);
+#ifdef __WXMSW__
+    //! Ctor with raw picture data in DIB format
+    wxBitmapControl(wxWindow *AParent, int AnId,char *Data,int Size,
+                    const wxPoint &pos,const wxSize &size,long style = 0,
+                    const wxString &name = wxPanelNameStr);
+#endif
+    //! Dtor
+    virtual ~wxBitmapControl();
+#ifdef __WXMSW__
+    //! Return picture type name
+    const wxChar *GetPictureType()
+    {
+        return wxT("Dib");
+    }
+    //! Returns picture data size
+    long GetPictureSize();
+    //! Copy picture data into data
+    long GetPictureData(char *data,long n);
+#endif
+    //! Return the picture in bitmap format
+    const wxBitmap &GetBitmap() { return *m_bitmap; }
+    //! Paint function for printing
+    void Paint(wxDC &dc,bool Printing,wxSize &size);
+    //! Returns width/height ratio
+    float GetRatio();
+    //! Returns original size of control
+    wxSize GetOriginalSize();
+
+// Event handlers
+
+    //! Responds to copy event
+    void OnEditCopy(wxCommandEvent &event);
+
+ protected:
+    wxBitmap *m_bitmap;
+
+    DECLARE_EVENT_TABLE()
+    DECLARE_DYNAMIC_CLASS(wxBitmapControl)
+};
+
+// ----------------------------------------------------------------------------
+// wxResizeableControlCanvas
+// ----------------------------------------------------------------------------
+
+//! Parent window class for wxResizableControl child windows.
+/*! This is a demo implementation that shows the typical operations
+    that are necessary to support wxResizableControl child windows.
+*/
+class wxResizeableControlCanvas : public wxScrolledWindow
+{
+  public:
+    //! Ctor
+    wxResizeableControlCanvas() : wxScrolledWindow() {}
+    //! Ctor
+    wxResizeableControlCanvas(wxWindow *AParent, int AnId,
+                              const wxPoint &pos = wxDefaultPosition,
+                              const wxSize &size = wxDefaultSize,long style = 0,
+                              const wxString &name = wxPanelNameStr)
+      : wxScrolledWindow(AParent,AnId,pos,size,style,name) {}
+    //! Recalculate the Scrollbars
+    void UpdateScrollRange();
+    //! Respond to child window notification
+    void OnChildWindowChange(wxCommandEvent &) {UpdateScrollRange();}
+
+    DECLARE_EVENT_TABLE()
+};
+
+// ----------------------------------------------------------------------------
+// Events
+// ----------------------------------------------------------------------------
+
+//! Events from child windows
+/*! These events notify the parent window of changes, so that it can
+    update itself accordingly (recalculate Scrollbars, set document modified
+    flag and so on).
+*/
+BEGIN_DECLARE_EVENT_TYPES()
+    DECLARE_EVENT_TYPE(wxEVT_COMMAND_CHILD_MOVED, 520)
+    DECLARE_EVENT_TYPE(wxEVT_COMMAND_CHILD_CLOSED, 521)
+    DECLARE_EVENT_TYPE(wxEVT_COMMAND_CHILD_RESIZED, 522)
+    DECLARE_EVENT_TYPE(wxEVT_COMMAND_CHILD_CREATED, 523)
+END_DECLARE_EVENT_TYPES()
+
+#define EVT_CHILD_MOVED(id, fn) \
+    DECLARE_EVENT_TABLE_ENTRY( \
+        wxEVT_COMMAND_CHILD_MOVED, id, -1, \
+        (wxObjectEventFunction)(wxEventFunction)(wxCommandEventFunction) \
+        & fn, \
+        (wxObject *) NULL \
+    ),
+
+#define EVT_CHILD_CLOSED(id, fn) \
+    DECLARE_EVENT_TABLE_ENTRY( \
+        wxEVT_COMMAND_CHILD_CLOSED, id, -1, \
+        (wxObjectEventFunction)(wxEventFunction)(wxCommandEventFunction) \
+        & fn, \
+        (wxObject *) NULL \
+    ),
+
+#define EVT_CHILD_RESIZED(id, fn) \
+    DECLARE_EVENT_TABLE_ENTRY( \
+        wxEVT_COMMAND_CHILD_RESIZED, id, -1, \
+        (wxObjectEventFunction)(wxEventFunction)(wxCommandEventFunction) \
+        & fn, \
+        (wxObject *) NULL \
+    ),
+
+#define EVT_CHILD_CREATED(id, fn) \
+    DECLARE_EVENT_TABLE_ENTRY( \
+        wxEVT_COMMAND_CHILD_CREATED, id, -1, \
+        (wxObjectEventFunction)(wxEventFunction)(wxCommandEventFunction) \
+        & fn, \
+        (wxObject *) NULL \
+    ),
+
+#endif // __RESIZECONTROL__
+
diff -rbu2P wxw/contrib/samples/resizec/Makefile.in wxWindows/contrib/samples/resizec/Makefile.in
--- wxw/contrib/samples/resizec/Makefile.in	Thu Jan 01 01:00:00 1970
+++ wxWindows/contrib/samples/resizec/Makefile.in	Thu Jun 19 15:16:24 2003
@@ -0,0 +1,21 @@
+###############################################################################
+# Purpose: Makefile.in for resizeable controls sample for Unix with autoconf
+# Created: 17.09.00
+# Author:  VS
+# Version: $Id: Makefile.in,v 1.2.2.2 2002/11/18 23:02:33 VS Exp $
+###############################################################################
+
+top_srcdir = $(HOME)/wxGTK-2.4.0
+top_builddir = $(HOME)/wxGTK-2.4.0/buildgtk
+program_dir = contrib/samples/resizec
+
+PROGRAM=resizecd
+
+OBJECTS=$(PROGRAM).o \
+	myframe.o \
+        ownerrnd.o \
+        resizec.o
+
+include $(top_builddir)/src/makeprog.env
+
+
Binary files wxw/contrib/samples/resizec/builtwithwx.gif and wxWindows/contrib/samples/resizec/builtwithwx.gif differ
diff -rbu2P wxw/contrib/samples/resizec/makefile.b32 wxWindows/contrib/samples/resizec/makefile.b32
--- wxw/contrib/samples/resizec/makefile.b32	Thu Jan 01 01:00:00 1970
+++ wxWindows/contrib/samples/resizec/makefile.b32	Thu Jun 19 15:40:30 2003
@@ -0,0 +1,22 @@
+#
+# File:		makefile.b32
+# Author:	Julian Smart
+# Created:	1999
+# Updated:	
+# Copyright:
+#
+# Makefile : Builds sample for 32-bit BC++
+
+WXDIR = $(WXWIN)
+
+TARGET=resizecd
+
+EXTRALIBS=$(WXDIR)\lib\resizec.lib
+
+OBJECTS = $(TARGET).obj \
+	myframe.obj \
+                ownerrnd.obj 
+
+!include $(WXDIR)\src\makeprog.b32
+
+
diff -rbu2P wxw/contrib/samples/resizec/makefile.g95 wxWindows/contrib/samples/resizec/makefile.g95
--- wxw/contrib/samples/resizec/makefile.g95	Thu Jan 01 01:00:00 1970
+++ wxWindows/contrib/samples/resizec/makefile.g95	Thu Jun 19 15:41:18 2003
@@ -0,0 +1,18 @@
+# File:     makefile.g95
+# Author:	Robin Dunn
+# Created:	1-Feb-2000
+# Updated:
+
+WXDIR = ../../..
+
+TARGET = resizecd
+OBJECTS = $(TARGET).o \
+	myframe.o \
+                ownerrnd.o
+
+EXTRAINC = -I$(WXDIR)/contrib/include
+EXTRALIBS = -lresizec
+
+include $(WXDIR)/src/makeprog.g95
+
+
diff -rbu2P wxw/contrib/samples/resizec/makefile.vc wxWindows/contrib/samples/resizec/makefile.vc
--- wxw/contrib/samples/resizec/makefile.vc	Thu Jan 01 01:00:00 1970
+++ wxWindows/contrib/samples/resizec/makefile.vc	Thu Jun 19 15:40:56 2003
@@ -0,0 +1,16 @@
+# File:		makefile.vc  For stectrl
+# Author:	Robin Dunn
+# Created:	1-Feb-2000
+# Updated:
+
+WXDIR = $(WXWIN)
+PROGRAM = resizecd
+
+OBJECTS = $(PROGRAM).obj myframe.obj ownerrnd.obj
+
+EXTRALIBS = $(WXDIR)\lib\resizec$(LIBEXT).lib
+EXTRAINC = -I$(WXDIR)\contrib\include
+
+!include $(WXDIR)\src\makeprog.vc
+
+
diff -rbu2P wxw/contrib/samples/resizec/myframe.cpp wxWindows/contrib/samples/resizec/myframe.cpp
--- wxw/contrib/samples/resizec/myframe.cpp	Thu Jan 01 01:00:00 1970
+++ wxWindows/contrib/samples/resizec/myframe.cpp	Thu Jun 19 15:33:36 2003
@@ -0,0 +1,278 @@
+//-----------------------------------------------------------------------------
+// Name:        myframe.cpp
+// Purpose:     resizeable controls sample: A derived frame, called MyFrame
+// Author:      Markus Greither
+// RCS-ID:      
+// Copyright:   (c) Markus Greither
+// Licence:     wxWindows licence
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// GCC implementation
+//-----------------------------------------------------------------------------
+
+#ifdef __GNUG__
+    #pragma implementation "myframe.h"
+#endif
+
+//-----------------------------------------------------------------------------
+// Standard wxWindows headers
+//-----------------------------------------------------------------------------
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+// For all others, include the necessary headers (this file is usually all you
+// need because it includes almost all "standard" wxWindows headers)
+#ifndef WX_PRECOMP
+    #include "wx/wx.h"
+#endif
+
+//-----------------------------------------------------------------------------
+// Header of this .cpp file
+//-----------------------------------------------------------------------------
+
+#include "myframe.h"
+
+//-----------------------------------------------------------------------------
+// Remaining headers: Needed wx headers, then wx/contrib headers, then application headers
+//-----------------------------------------------------------------------------
+
+// Since setting an icon
+#include "wx/image.h"
+
+#include "wx/clipbrd.h"
+
+#include "wx/print.h"
+
+#include "myprintout.h"
+
+//-----------------------------------------------------------------------------
+// Regular resources (the non-XRC kind).
+//-----------------------------------------------------------------------------
+
+// The application icon
+// All non-MSW platforms use an xpm. MSW uses an .ico file
+#if defined(__WXGTK__) || defined(__WXX11__) || defined(__WXMOTIF__) || defined(__WXMAC__) || defined(__WXMGL__)
+    #include "rc/appicon.xpm"
+#endif
+
+//-----------------------------------------------------------------------------
+// Resizeable controls
+//-----------------------------------------------------------------------------
+
+#include "wx/resizec/resizec.h"
+
+//-----------------------------------------------------------------------------
+// User rendered resizeable controls
+//-----------------------------------------------------------------------------
+
+#include "ownerrnd.h"
+
+//-----------------------------------------------------------------------------
+// Event table: connect the events to the handler functions to process them
+//-----------------------------------------------------------------------------
+
+
+BEGIN_EVENT_TABLE(MyFrame, wxFrame)
+    EVT_MENU(wxID_CLOSE,  MyFrame::OnQuit)
+    EVT_MENU(wxID_ABOUT, MyFrame::OnAbout)
+    EVT_MENU(wxID_PASTE, MyFrame::OnPaste)
+    EVT_UPDATE_UI(wxID_PASTE, MyFrame::OnPasteEnable)
+    EVT_MENU(wxID_COPY, MyFrame::OnCopy)
+    EVT_UPDATE_UI(wxID_COPY, MyFrame::OnCopyEnable)
+    EVT_MENU(wxID_PRINT, MyFrame::OnPrint)
+END_EVENT_TABLE()
+
+//-----------------------------------------------------------------------------
+// Public methods
+//-----------------------------------------------------------------------------
+
+// Constructor
+MyFrame::MyFrame(wxWindow* parent)
+ : wxFrame(parent,-1,_T("Resizeable controls sample"),
+           wxPoint(50, 50), wxSize(450, 340))
+{
+    // Set the icon for the frame.
+    SetIcon(wxICON(appicon));
+
+#if wxUSE_MENUS
+    // create a menu bar
+    wxMenu *menuFile = new wxMenu;
+    menuFile->Append(wxID_PRINT, _T("&Print"), _T("Print active control"));
+    menuFile->Append(wxID_CLOSE, _T("E&xit\tAlt-X"), _T("Quit this program"));
+
+    // the "About" item should be in the help menu
+    wxMenu *helpMenu = new wxMenu;
+    helpMenu->Append(wxID_ABOUT, _T("&About...\tF1"), _T("Show about dialog"));
+
+    wxMenu *menuEdit = new wxMenu;
+    menuEdit->Append(wxID_PASTE, _T("&Paste"), _T("Paste new Control"));
+    menuEdit->Append(wxID_COPY, _T("&Copy"), _T("Copy Control"));
+
+    // now append the freshly created menu to the menu bar...
+    wxMenuBar *menuBar = new wxMenuBar();
+    menuBar->Append(menuFile, _T("&File"));
+    menuBar->Append(menuEdit, _T("&Edit"));
+    menuBar->Append(helpMenu, _T("&Help"));
+
+    // ... and attach this menu bar to the frame
+    SetMenuBar(menuBar);
+#endif // wxUSE_MENUS
+
+#if wxUSE_STATUSBAR
+    CreateStatusBar(2);
+    SetStatusText(_T("Welcome to wxWindows!"));
+#endif // wxUSE_STATUSBAR
+
+    // Create a canvas on which the resizeable controls are supported
+    m_resizecanvas = new wxResizeableControlCanvas(this,-1);
+
+    // Now create some resizeable controls
+    wxBitmapControl *tmp;
+    wxBitmap bitmap;
+    if (!bitmap.LoadFile(_T("builtwithwx.gif"),wxBITMAP_TYPE_GIF))
+        wxMessageBox(_T("Couldn't load 'builtwithwx.gif' bitmap!"),
+                     _T("Error"));
+    
+    // This one shows in the original size of the bitmap
+    tmp = new wxBitmapControl((wxResizeableControlCanvas *)m_resizecanvas,
+                              0,bitmap,wxPoint(10,10),
+                              wxSize(bitmap.GetWidth(),bitmap.GetHeight()),
+                              wxCLIP_SIBLINGS);
+    // This one is enlarged and hanging half out of the canvas
+    // Notice that the canvas scrollbars are set correcty
+    // Try moving this around and see that the canvas scrollbars
+    // are automatically updated
+    tmp = new wxBitmapControl((wxResizeableControlCanvas *)m_resizecanvas,
+                              0,bitmap,wxPoint(300,200),
+                              wxSize(200,100),
+                              wxCLIP_SIBLINGS);
+    // This one has its own paint routine. Notice that the same routine
+    // is used for both screen and printing
+    new OwnerRenderedControl((wxResizeableControlCanvas *)m_resizecanvas,
+                             0,wxPoint(10,100),
+                             wxSize(250,200),
+                             wxCLIP_SIBLINGS);
+}
+
+
+//-----------------------------------------------------------------------------
+// event handlers
+//-----------------------------------------------------------------------------
+
+void MyFrame::OnQuit(wxCommandEvent& WXUNUSED(event))
+{
+    // TRUE is to force the frame to close
+    Close(TRUE);
+}
+
+void MyFrame::OnAbout(wxCommandEvent& WXUNUSED(event))
+{
+    wxString msg;
+    msg.Printf( _T("Sample application for resizeable controls.\n\n")
+                _T("Demonstrates\n")
+                _T(" resizing, moving, cutting, pasting and printing\n")
+                _T("of resizeable bitmap and custom controls.\n\n")
+                _T("Build with %s"), wxVERSION_STRING);
+
+    wxMessageBox(msg, _T("About RESIZECD"), wxOK | wxICON_INFORMATION, this);
+}
+
+void MyFrame::OnPaste(wxCommandEvent& WXUNUSED(event))
+{
+#ifdef __WXGTK__
+    if (wxTheClipboard->IsOpened())
+        return;
+#endif
+
+    if (wxTheClipboard->Open())
+    {
+        // If there is a bitmap in the clipboard, paste it into a new control
+        if (wxTheClipboard->IsSupported(wxDF_BITMAP))
+        {
+            wxBitmapDataObject cdo;
+            wxTheClipboard->GetData(cdo);
+            wxSize sz(cdo.GetBitmap().GetWidth(),cdo.GetBitmap().GetHeight());
+            wxBitmapControl *bmp = new wxBitmapControl((wxResizeableControlCanvas *)m_resizecanvas,
+                                                       0,cdo.GetBitmap(),
+                                                       wxPoint(10,10),sz,
+                                                       wxCLIP_SIBLINGS);
+            bmp->Clear();
+            bmp->SetFocus();
+        }    
+        wxTheClipboard->Close();
+    }
+}
+
+void MyFrame::OnPasteEnable(wxUpdateUIEvent& event)
+{
+#ifdef __WXGTK__
+    if (wxTheClipboard->IsOpened())
+        return;
+#endif
+
+    wxTheClipboard->Open();
+    event.Enable(wxTheClipboard->IsSupported(wxDF_BITMAP));
+    wxTheClipboard->Close();
+}
+
+void MyFrame::OnCopy(wxCommandEvent& event)
+{
+    wxPictureControl *bmp = wxDynamicCast(FindFocus(),wxPictureControl);
+    if (bmp)
+        bmp->OnEditCopy(event);
+}
+
+void MyFrame::OnCopyEnable(wxUpdateUIEvent& event)
+{
+    wxPictureControl *ctr = wxDynamicCast(FindFocus(),wxPictureControl);
+    event.Enable(ctr);
+}
+
+void MyFrame::OnPrint(wxCommandEvent& event)
+{
+    // Create printouts for both previewing and printing
+    MyPrintOut *printout = new MyPrintOut(_T("Test Print"),FindFocus());
+    MyPrintOut *printout2 = new MyPrintOut(_T("Test Print"),FindFocus());
+
+    // Create a print preview
+    wxPrintPreview *preview = new wxPrintPreview(printout,printout2,(wxPrintData *)0);
+
+    // Now create and show the preview in a preview frame
+    wxPreviewFrame *frm = new wxPreviewFrame(preview,this,_T("Print preview"),
+                                             wxPoint(10,10),wxSize(640,400));
+    frm->Initialize();
+    frm->Show();
+}
+
+//-----------------------------------------------------------------------------
+// MyPrintOut for Resizeable Controls
+//-----------------------------------------------------------------------------
+
+bool MyPrintOut::OnPrintPage(int pagenum)
+{
+    // Get the device context
+    wxDC *dc = GetDC();
+
+    wxSize sz = dc->GetSize();
+
+    // Print with border 1/10 of the page size
+    dc->SetDeviceOrigin(sz.x/10,sz.y/10);
+    sz.x = sz.x*8/10;
+    sz.y = sz.y*8/10;
+
+    // Make sure we have a wxResizeableControl
+    wxResizeableControl *tmp = wxDynamicCast(m_Control,wxResizeableControl);
+    if (tmp)
+        tmp->Paint(*dc,true,sz);
+
+    dc->SetDeviceOrigin(0,0);
+
+    return true;
+}
+
diff -rbu2P wxw/contrib/samples/resizec/myframe.h wxWindows/contrib/samples/resizec/myframe.h
--- wxw/contrib/samples/resizec/myframe.h	Thu Jan 01 01:00:00 1970
+++ wxWindows/contrib/samples/resizec/myframe.h	Thu Jun 19 15:16:24 2003
@@ -0,0 +1,64 @@
+//-----------------------------------------------------------------------------
+// Name:        myframe.h
+// Purpose:     Resizeable controls sample: A derived frame, called MyFrame
+// Author:      Markus Greither
+// RCS-ID:      
+// Copyright:   (c) Markus Greither
+// Licence:     wxWindows licence
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// Begin single inclusion of this .h file condition
+//-----------------------------------------------------------------------------
+
+#ifndef _MYFRAME_H_
+#define _MYFRAME_H_
+
+//-----------------------------------------------------------------------------
+// GCC interface
+//-----------------------------------------------------------------------------
+
+#if defined(__GNUG__) && !defined(__APPLE__)
+    #pragma interface "myframe.h"
+#endif
+
+//-----------------------------------------------------------------------------
+// Headers
+//-----------------------------------------------------------------------------
+
+#include "wx/frame.h"
+
+//-----------------------------------------------------------------------------
+// Class definition: MyFrame
+//-----------------------------------------------------------------------------
+
+// Define a new frame type: this is going to be our main frame
+class MyFrame : public wxFrame
+{
+    wxWindow *m_resizecanvas;
+public:
+
+    // ctor(s)
+    MyFrame(wxWindow *wnd = (wxWindow *)NULL);
+
+private:
+
+    // Event handlers (these functions should _not_ be virtual)
+    void OnAbout(wxCommandEvent& event);
+    void OnQuit(wxCommandEvent& event);
+    void OnPaste(wxCommandEvent& event);
+    void OnPasteEnable(wxUpdateUIEvent& event);
+    void OnCopy(wxCommandEvent& event);
+    void OnCopyEnable(wxUpdateUIEvent& event);
+    void OnPrint(wxCommandEvent& event);
+
+    // Any class wishing to process wxWindows events must use this macro
+    DECLARE_EVENT_TABLE()
+
+};
+
+//-----------------------------------------------------------------------------
+// End single inclusion of this .h file condition
+//-----------------------------------------------------------------------------
+
+#endif  // _MYFRAME_H_
diff -rbu2P wxw/contrib/samples/resizec/myprintout.h wxWindows/contrib/samples/resizec/myprintout.h
--- wxw/contrib/samples/resizec/myprintout.h	Thu Jan 01 01:00:00 1970
+++ wxWindows/contrib/samples/resizec/myprintout.h	Thu Jun 19 15:16:24 2003
@@ -0,0 +1,34 @@
+//-----------------------------------------------------------------------------
+// Name:        myprintout.h
+// Purpose:     Resizeable controls sample: Printout for resizeable controls
+// Author:      Markus Greither
+// RCS-ID:
+// Copyright:   (c) Markus Greither
+// Licence:     wxWindows licence
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// Begin single inclusion of this .h file condition
+//-----------------------------------------------------------------------------
+
+#ifndef _MYPRINTOUT_H_
+#define _MYPRINTOUT_H_
+
+//-----------------------------------------------------------------------------
+// Class definition: MyPrintOut for printing resizeable controls
+//-----------------------------------------------------------------------------
+
+class MyPrintOut : public wxPrintout
+{
+  wxWindow *m_Control;
+public:
+    //! Ctor
+    MyPrintOut(const wxString &title, wxWindow *ctrl)
+     : wxPrintout(title) {m_Control = ctrl;}
+
+    //! Page rendering
+    bool OnPrintPage(int pagenum);
+};
+
+
+#endif // _MYPRINTOUT_H_
diff -rbu2P wxw/contrib/samples/resizec/ownerrnd.cpp wxWindows/contrib/samples/resizec/ownerrnd.cpp
--- wxw/contrib/samples/resizec/ownerrnd.cpp	Thu Jan 01 01:00:00 1970
+++ wxWindows/contrib/samples/resizec/ownerrnd.cpp	Thu Jun 19 15:16:24 2003
@@ -0,0 +1,83 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        ownerrnd.cpp - Owner rendered resizeable control
+// Purpose:     wxResizeableControl
+// Author:      Markus Greither
+// Modified by:
+// Created:     11/11/02
+// RCS-ID:      $Id:     1.04 2003/06/14 magr
+// Copyright:   (c) Markus Greither
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+
+//-----------------------------------------------------------------------------
+// GCC implementation
+//-----------------------------------------------------------------------------
+
+#ifdef __GNUG__
+    #pragma implementation "ownerrnd.h"
+#endif
+
+//-----------------------------------------------------------------------------
+// Standard wxWindows headers
+//-----------------------------------------------------------------------------
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+// For all others, include the necessary headers (this file is usually all you
+// need because it includes almost all "standard" wxWindows headers)
+#ifndef WX_PRECOMP
+    #include "wx/wx.h"
+#endif
+
+//-----------------------------------------------------------------------------
+// Header of this .cpp file
+//-----------------------------------------------------------------------------
+
+#include "wx/image.h"
+#include "wx/resizec/resizec.h"
+#include "ownerrnd.h"
+
+//-----------------------------------------------------------------------------
+// Remaining headers: Needed wx headers, then wx/contrib headers, then application headers
+//-----------------------------------------------------------------------------
+
+// Since setting an icon
+#include "wx/image.h"
+
+#if wxUSE_CLIPBOARD
+#include "wx/clipbrd.h"
+#endif
+
+IMPLEMENT_DYNAMIC_CLASS(OwnerRenderedControl,wxResizeableControl)
+
+BEGIN_EVENT_TABLE(OwnerRenderedControl,wxResizeableControl)
+    EVT_PAINT(OwnerRenderedControl::OnPaint)
+END_EVENT_TABLE()
+
+void OwnerRenderedControl::OnPaint(wxPaintEvent &)
+{
+    wxPaintDC dc(this);
+    wxSize size = GetClientSize();
+    Paint(dc,false,size);
+    if (m_hasfocus)
+        DrawSizeRect(dc);
+}
+
+void OwnerRenderedControl::Paint(wxDC &dc,bool printing,wxSize &size)
+{
+    dc.SetPen(*wxRED_PEN);
+    dc.SetBrush(wxNullBrush);
+    dc.DrawRectangle(10,10,200,100);
+    dc.DrawText(_("Owner Drawn control!"),10,10);
+    if (printing)
+        dc.DrawText(_("Yes we can also be printed!"),10,30);
+    dc.SetPen(wxNullPen);
+}
+
+
+
diff -rbu2P wxw/contrib/samples/resizec/ownerrnd.h wxWindows/contrib/samples/resizec/ownerrnd.h
--- wxw/contrib/samples/resizec/ownerrnd.h	Thu Jan 01 01:00:00 1970
+++ wxWindows/contrib/samples/resizec/ownerrnd.h	Thu Jun 19 15:16:24 2003
@@ -0,0 +1,43 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        ownerrnd.h - Owner rendered resizeable control
+// Purpose:     wxResizeableControl sample
+// Author:      Markus Greither
+// Modified by:
+// Created:     
+// RCS-ID:
+// Copyright:   (c) Markus Greither
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+
+//-----------------------------------------------------------------------------
+// Begin single inclusion of this .h file condition
+//-----------------------------------------------------------------------------
+
+#ifndef _OWNERRND_H_
+#define _OWNERRND_H_
+
+class OwnerRenderedControl : public wxResizeableControl
+{
+   public:
+    //! Ctor
+    OwnerRenderedControl() : wxResizeableControl() {}
+    //! Ctor
+    OwnerRenderedControl(wxWindow *AParent, int AnId,const wxPoint &pos,
+                          const wxSize &size,long style = 0,
+                          const wxString &name = wxPanelNameStr)
+      : wxResizeableControl(AParent,AnId,pos,size,style,name) {}
+
+// Event handlers
+    //! Paint handler
+    void OnPaint(wxPaintEvent &event);
+
+    //! Print or screen output routine
+    void Paint(wxDC &dc,bool,wxSize &size);
+
+ protected:
+    DECLARE_EVENT_TABLE()
+    DECLARE_DYNAMIC_CLASS(OwnerRenderedControl)
+};
+
+#endif // _OWNERRND_H_
+
Binary files wxw/contrib/samples/resizec/rc/appicon.ico and wxWindows/contrib/samples/resizec/rc/appicon.ico differ
diff -rbu2P wxw/contrib/samples/resizec/rc/appicon.xpm wxWindows/contrib/samples/resizec/rc/appicon.xpm
--- wxw/contrib/samples/resizec/rc/appicon.xpm	Thu Jan 01 01:00:00 1970
+++ wxWindows/contrib/samples/resizec/rc/appicon.xpm	Thu Jun 19 10:22:10 2003
@@ -0,0 +1,39 @@
+/* XPM */
+static char *appicon[] = {
+/* width height num_colors chars_per_pixel */
+"    16    16       16            1",
+/* colors */
+"` c #000000",
+". c #000080",
+"# c #008000",
+"a c #008080",
+"b c #800000",
+"c c #800080",
+"d c #808000",
+"e c #c0c0c0",
+"f c #808080",
+"g c #0000ff",
+"h c #00ff00",
+"i c #00ffff",
+"j c #ff0000",
+"k c #ff00ff",
+"l c #ffff00",
+"m c #ffffff",
+/* pixels */
+"mmmmmmmmmmmmmmmm",
+"m```````````mmmm",
+"m``mm``mmm``mmmm",
+"m`mfmffmffm`fmfm",
+"m`mfmmmmmmm`mmmm",
+"m``mmmmmmm``mmfm",
+"m``fmmmmmm``mmfm",
+"m`mfmmmmmmm`mmmm",
+"m`mmmmmmmmm`mmfm",
+"m``fm``mmm``mmfm",
+"m```````````mmmm",
+"mmmmmmmmmmmmmmfm",
+"mmmfmmmmmmmmmmfm",
+"mmmfmmmmmmmmmmmm",
+"mmmfmffmffmffmfm",
+"mmmmmmmmmmmmmmmm"
+};
diff -rbu2P wxw/contrib/samples/resizec/resizec.cpp wxWindows/contrib/samples/resizec/resizec.cpp
--- wxw/contrib/samples/resizec/resizec.cpp	Thu Jan 01 01:00:00 1970
+++ wxWindows/contrib/samples/resizec/resizec.cpp	Thu Jun 19 11:06:52 2003
@@ -0,0 +1,942 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        resizec.cpp
+// Purpose:     wxResizeableControl
+// Author:      Markus Greither
+// Modified by:
+// Created:     11/11/02
+// RCS-ID:      $Id:     1.04 2003/06/14 magr
+// Copyright:   (c) Markus Greither
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+
+#ifdef __GNUG__
+    #pragma implementation "resizec.h"
+#endif
+
+// For compilers that support precompilation, includes "wx.h".
+#include "wx/wxprec.h"
+
+#if defined(__BORLANDC__)
+    #pragma hdrstop
+#endif
+
+#ifndef WX_PRECOMP
+#include "wx/wx.h"
+#endif
+
+#include "wx/image.h"
+#include "wx/metafile.h"
+#include "wx/clipbrd.h"
+#include "wx/resizec/resizec.h"
+
+#ifdef __WXMSW__
+#include <windows.h>
+#include "wx/msw/winundef.h"
+#include "wx/msw/dib.h"
+#include "wx/msw/private.h"
+#endif
+
+// ----------------------------------------------------------------------------
+// Events
+// ----------------------------------------------------------------------------
+
+DEFINE_EVENT_TYPE(wxEVT_COMMAND_CHILD_CREATED)
+DEFINE_EVENT_TYPE(wxEVT_COMMAND_CHILD_MOVED)
+DEFINE_EVENT_TYPE(wxEVT_COMMAND_CHILD_CLOSED)
+DEFINE_EVENT_TYPE(wxEVT_COMMAND_CHILD_RESIZED)
+
+// ----------------------------------------------------------------------------
+// wxZoomData
+// ----------------------------------------------------------------------------
+
+void wxZoomData::SetSize(int width,int height)
+{
+    if ((m_currRect.width != width) ||
+        (m_currRect.height != height))
+    {
+        m_orgSize = wxSize(int(width/m_zoom),
+                           int(height/m_zoom));
+        m_currRect.width = width;
+        m_currRect.height = height;
+    }
+}
+
+void wxZoomData::Move(int xpos,int ypos)
+{
+    if ((m_currRect.x != xpos) ||
+        (m_currRect.x != ypos))
+    {
+        m_orgPos = wxPoint(int(xpos/m_zoom),
+                           int(ypos/m_zoom));
+        m_currRect.x = xpos;
+        m_currRect.y = ypos;
+    }
+}
+
+void wxZoomData::SetZoomRect(wxWindow *Window,float zoom,
+                 int curxoffs,int curyoffs,
+                 int newxoffs,int newyoffs)
+{
+    m_currRect = wxRect(int((m_orgPos.x+curxoffs-newxoffs)*zoom),
+                        int((m_orgPos.y+curyoffs-newyoffs)*zoom),
+                        int(m_orgSize.x*zoom),int(m_orgSize.y*zoom));
+    m_zoom = zoom;
+    Window->SetSize(m_currRect);
+}
+
+// ----------------------------------------------------------------------------
+// wxResizeableControl
+// ----------------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(wxResizeableControl, wxWindow)
+
+wxResizeableControl::wxResizeableControl(wxWindow *AParent,
+                                         int AnId,const wxPoint &pos,
+                                         const wxSize &size,long style,
+                                         const wxString &name)
+ : wxWindow(AParent,AnId,pos,size,style,name),m_zoomData(size,pos),
+   m_capt(0),m_movemode(wxResizeableControl::MoveWin),m_hasfocus(false)
+{
+    wxCommandEvent cevent(wxEVT_COMMAND_CHILD_CREATED,GetId());
+    if (GetParent())
+        GetParent()->AddPendingEvent(cevent);
+}
+
+void wxResizeableControl::FocusRectCoord(wxDC &DC,wxCoord x1,wxCoord y1,
+                                         wxCoord w,wxCoord h)
+{
+    wxPen pen(*wxBLACK,1,wxDOT);
+    wxBrush &OldBr = DC.GetBrush();
+    DC.SetBrush(*wxTRANSPARENT_BRUSH);
+    DC.SetPen(pen);
+    DC.SetLogicalFunction(wxINVERT);
+    DC.DrawRectangle(x1,y1,w,h);
+    DC.SetBrush(OldBr);
+    DC.SetPen(wxNullPen);
+    DC.SetLogicalFunction(wxCOPY);
+}
+
+// Draws the current window size
+void wxResizeableControl::DrawMoveRect(wxPoint hp,int Mode,float Ratio)
+{
+    wxScreenDC dc;
+    wxRect rect = NewRect(hp,Mode,Ratio);
+    DrawFocusRect(dc,rect);
+}
+
+// FIXME: This doesn't work properly for windows that are
+// very small and the size rectangles overlap
+int wxResizeableControl::PointInSizeRect(wxPoint hp)
+{
+    for (int i = 0;i < 8;i++)
+    {
+        int x = 6+GetSizeX(i)*(GetClientSize().x-11)/2;
+        int y = 6+GetSizeY(i)*(GetClientSize().y-11)/2;
+        wxRect rect(wxPoint(x-SizeXRad,y-SizeYRad),
+                    wxPoint(x+SizeXRad,y+SizeYRad));
+        if ((hp.x >= rect.x) && (hp.x <= rect.x+rect.width) &&
+            (hp.y >= rect.y) && (hp.y <= rect.y+rect.height))
+            return i;
+    }
+    return MoveWin;
+}
+
+// Calculates the current window size (Parent coordinates)
+wxRect wxResizeableControl::NewRect(wxPoint hp,int Mode,float Ratio)
+{
+    wxSize size = GetClientSize();
+    wxPoint pt(0,0);
+    ClientToScreen(&pt.x,&pt.y);
+    wxRect rect(pt,size);
+    wxRect rect1(rect);
+    wxPoint delta(hp.x-m_curpos.x,hp.y-m_curpos.y);
+    switch (Mode)
+    {
+        case MoveWin : {rect.x += delta.x; rect.y += delta.y;}; break;
+        case Top : rect.y += delta.y; rect.height -= delta.y; break;
+        case Bottom : rect.height += delta.y; break;
+        case Left : rect.x += delta.x; rect.width -= delta.x; break;
+        case Right : rect.width += delta.x; break;
+        case TopLeft :
+            rect.x += delta.x;
+            rect.y += delta.y;
+            rect.width -= delta.x;
+            rect.height -= delta.y;
+            if (Ratio)
+            {
+              if (rect.GetWidth() < rect.GetHeight()*Ratio)
+              {
+                  int tmp = int(rect.GetHeight()*Ratio);
+                  rect.x = rect.GetRight()-tmp+1;
+                  rect.width = tmp;
+              }
+              else
+              {
+                  int tmp = int(rect.GetWidth()/Ratio);
+                  rect.y = rect.GetBottom()-tmp+1;
+                  rect.height = tmp;
+              }
+            }
+            break;
+        case TopRight :
+            rect.width += delta.x;
+            rect.y += delta.y;
+            rect.height -= delta.y;
+            if (Ratio)
+            {
+                if (rect.GetWidth() < rect.GetHeight()*Ratio)
+                    rect.width = int(rect.GetHeight()*Ratio);
+                else
+                {
+                    int tmp = int(rect.GetWidth()/Ratio);
+                    rect.y = rect.GetBottom()-tmp+1;
+                    rect.height = tmp;
+                }
+            }
+            break;
+        case BottomLeft :
+            rect.x += delta.x;
+            rect.width -= delta.x;
+            rect.height += delta.y;
+            if (Ratio)
+            {
+                if (rect.GetWidth() < rect.GetHeight()*Ratio)
+                {
+                    int tmp = int(rect.GetHeight()*Ratio);
+                    rect.x = rect.GetRight()-tmp+1;
+                    rect.width = tmp;
+                }
+                else
+                    rect.height = int(rect.GetWidth()/Ratio);
+            }
+            break;
+        case BottomRight :
+            rect.width += delta.x;
+            rect.height += delta.y;
+            if (Ratio)
+            {
+                if (rect.GetWidth() < rect.GetHeight()*Ratio)
+                    rect.width = int(rect.GetHeight()*Ratio);
+                else
+                    rect.height = int(rect.GetWidth()/Ratio);
+            }
+            break;
+    }
+    wxSize size1 = GetParent()->GetClientSize();
+    wxPoint pt1(0,0);
+    GetParent()->ClientToScreen(&pt1.x,&pt1.y);
+    wxRect prect(pt1,size1);
+    prect.Inflate(-30,-30);
+    if ((((rect.x <= prect.GetRight()) &&
+          (prect.x <= rect.GetRight())) &&
+         ((rect.y <= prect.GetBottom()) &&
+          (prect.y <= rect.GetBottom()))) &&
+         (rect.GetWidth() >= 20) && (rect.GetHeight() >= 20))
+        return rect;
+    else
+        return rect1;
+}
+
+// Draws the size rectangles
+void wxResizeableControl::DrawSizeRect(wxDC &dc)
+{
+    int AltROP = dc.GetLogicalFunction();
+    dc.SetLogicalFunction(wxXOR);
+    wxBrush brs(wxSystemSettings::GetSystemColour(wxSYS_COLOUR_WINDOW),wxSOLID);
+    wxBrush &OldBr = dc.GetBrush();
+    dc.SetBrush(brs);
+    wxPen pen(wxSystemSettings::GetSystemColour(wxSYS_COLOUR_WINDOW),1,wxSOLID);
+    dc.SetPen(pen);
+    for (int i = 0;i < 8;i++)
+    {
+        int x = 0,y = 0;
+        switch (GetSizeX(i))
+        {
+            case 0 : x = SizeXRad; break;
+            case 1 : x = GetClientSize().x/2; break;
+            case 2 : x = GetClientSize().x-SizeXRad; break;
+        }
+        switch (GetSizeY(i))
+        {
+            case 0 : y = SizeYRad; break;
+            case 1 : y = GetClientSize().y/2; break;
+            case 2 : y = GetClientSize().y-SizeYRad; break;
+        }
+        dc.DrawRectangle(x-SizeXRad,y-SizeYRad,2*SizeXRad,2*SizeYRad);
+    }
+    dc.SetPen(wxNullPen);
+    dc.SetBrush(OldBr);
+    dc.SetLogicalFunction(AltROP);
+}
+
+void wxResizeableControl::OnSetCursor(wxSetCursorEvent &event)
+{
+  static wxCursor csr;
+  if (m_hasfocus)
+  {
+      wxPoint hp(event.GetX(),event.GetY()),point = hp;
+      switch (PointInSizeRect(point))
+      {
+          case MoveWin :
+              event.SetCursor(csr = wxCursor(wxCURSOR_SIZING));
+              break;
+          case Top :
+          case Bottom :
+              event.SetCursor(csr = wxCursor(wxCURSOR_SIZENS));
+              break;
+          case Left :
+          case Right :
+              event.SetCursor(csr = wxCursor(wxCURSOR_SIZEWE));
+              break;
+          case TopRight :
+          case BottomLeft :
+              event.SetCursor(csr = wxCursor(wxCURSOR_SIZENESW));
+              break;
+          case BottomRight :
+          case TopLeft :
+              event.SetCursor(csr = wxCursor(wxCURSOR_SIZENWSE));
+              break;
+          default :
+              event.SetCursor(*wxSTANDARD_CURSOR);
+      }
+  }
+  else
+      event.SetCursor(csr = wxCursor(wxCURSOR_SIZING));
+}
+
+void wxResizeableControl::OnLButtonDown(wxMouseEvent &event)
+{
+    wxPoint hp;
+    hp.x = event.GetX();
+    hp.y = event.GetY();
+    ScreenToClient(hp);
+    m_curpos = hp;
+    m_lastcurpos = hp;
+    if (!m_hasfocus)
+    {
+        SetFocus();
+        m_hasfocus = true;
+        m_movemode = MoveWin;
+    }
+    else
+    {
+        m_movemode = PointInSizeRect(hp);
+    }
+    CaptureMouse();
+    m_capt = true;
+    m_moved = false;
+}
+
+void wxResizeableControl::OnMouseMove(wxMouseEvent &event)
+{
+    wxPoint hp;
+    hp.x = event.GetX();
+    hp.y = event.GetY();
+    ScreenToClient(hp);
+    if (hp != m_lastcurpos)
+    {
+        if (m_capt)
+        {
+            if (m_moved)
+                DrawMoveRect(m_lastcurpos,m_movemode,GetRatio());
+            m_moved |= ((abs(m_curpos.x-hp.x) > 10) ||
+                        (abs(m_curpos.y-hp.y) > 10));
+            if (m_moved)
+                DrawMoveRect(hp,m_movemode,GetRatio());
+        }
+        m_lastcurpos = hp;
+    }
+#ifdef __WXGTK__
+    wxSetCursorEvent evt(hp.x,hp.y);
+    OnSetCursor(evt);
+    SetCursor(evt.GetCursor());
+#endif
+}
+
+void wxResizeableControl::OnLButtonUp(wxMouseEvent &event)
+{
+    wxPoint point;
+    point.x = event.GetX();
+    point.y = event.GetY();
+    ScreenToClient(point);
+    if (m_capt)
+    {
+        ReleaseMouse();
+        m_capt = false;
+        if (m_moved)
+        {
+            DrawMoveRect(m_lastcurpos,m_movemode,GetRatio());
+            wxRect rect = NewRect(point,m_movemode,GetRatio());
+            wxPoint pt = rect.GetPosition();
+            GetParent()->ScreenToClient(&pt.x,&pt.y);
+            rect.x = pt.x;
+            rect.y = pt.y;
+            SetSize(rect);
+            Refresh();
+        }
+    }
+    m_movemode = MoveWin;
+}
+
+int wxResizeableControl::GetSizeX(int Mode)
+{
+    int Pos = -1;
+    switch (Mode)
+    {
+        case Bottom :
+        case Top : Pos = 1; break;
+        case TopLeft :
+        case BottomLeft :
+        case Left : Pos = 0; break;
+        case TopRight :
+        case BottomRight :
+        case Right : Pos = 2; break;
+    }
+    return Pos;
+}
+
+int wxResizeableControl::GetSizeY(int Mode)
+{
+  int Pos = -1;
+  switch (Mode)
+  {
+      case TopRight :
+      case TopLeft :
+      case Top : Pos = 0; break;
+      case Left :
+      case Right : Pos = 1; break;
+      case BottomRight :
+      case BottomLeft :
+      case Bottom : Pos = 2; break;
+  }
+  return Pos;
+}
+
+void wxResizeableControl::OnKillFocus(wxFocusEvent &)
+{
+    if (m_hasfocus)
+    {
+        m_hasfocus = false;
+        wxClientDC DC(this);
+        DrawSizeRect(DC);
+    }
+}
+
+void wxResizeableControl::OnSetFocus(wxFocusEvent &)
+{
+    if (!m_hasfocus)
+    {
+        Raise();
+        Update();
+        wxClientDC DC(this);
+        DrawSizeRect(DC);
+        m_hasfocus = true;
+    }
+}
+
+void wxResizeableControl::OnKeyDown(wxKeyEvent &event)
+{
+    if (event.AltDown())
+    {
+        event.Skip();
+        return;
+    }
+    switch (event.GetKeyCode())
+    {
+        case WXK_DELETE :
+        {
+            wxCommandEvent cevent(wxEVT_COMMAND_CHILD_CLOSED,GetId());
+            if (GetParent())
+                GetParent()->AddPendingEvent(cevent);
+            Destroy();
+            break;
+        }
+        case WXK_LEFT :
+          if (event.ControlDown())
+              if (event.ShiftDown())
+                  SetSize(GetPosition().x,GetPosition().y,
+                          GetSize().x-1,GetSize().y);
+              else
+                  Move(GetPosition().x-1,GetPosition().y);
+          break;
+        case WXK_RIGHT :
+          if (event.ControlDown())
+              if (event.ShiftDown())
+                  SetSize(GetPosition().x,GetPosition().y,
+                          GetSize().x+1,GetSize().y);
+              else
+                  Move(GetPosition().x+1,GetPosition().y);
+          break;
+        case WXK_UP :
+          if (event.ControlDown())
+              if (event.ShiftDown())
+                  SetSize(GetPosition().x,GetPosition().y,
+                          GetSize().x,GetSize().y-1);
+              else
+                  Move(GetPosition().x,GetPosition().y-1);
+          break;
+        case WXK_DOWN :
+          if (event.ControlDown())
+              if (event.ShiftDown())
+                  SetSize(GetPosition().x,GetPosition().y,
+                          GetSize().x,GetSize().y+1);
+              else
+                  Move(GetPosition().x,GetPosition().y+1);
+          break;
+        default:
+          event.Skip();
+    }
+}
+
+void wxResizeableControl::OnEditCut(wxCommandEvent &)
+{
+    wxCommandEvent cevent(wxEVT_COMMAND_CHILD_CLOSED,GetId());
+    if (GetParent())
+        GetParent()->AddPendingEvent(cevent);
+    Destroy();
+}
+
+void wxResizeableControl::OnSize(wxSizeEvent &event)
+{
+    wxCommandEvent cevent(wxEVT_COMMAND_CHILD_RESIZED,GetId());
+    if (GetParent())
+        GetParent()->AddPendingEvent(cevent);
+    m_zoomData.SetSize(event.GetSize().x,event.GetSize().y);
+}
+
+void wxResizeableControl::OnMove(wxMoveEvent &event)
+{
+    wxCommandEvent cevent(wxEVT_COMMAND_CHILD_MOVED,GetId());
+    if (GetParent())
+        GetParent()->AddPendingEvent(cevent);
+    m_zoomData.Move(event.GetPosition().x,event.GetPosition().y);
+}
+
+BEGIN_EVENT_TABLE(wxResizeableControl,wxWindow)
+    EVT_MENU(wxID_CUT,wxResizeableControl::OnEditCut)
+    EVT_SET_FOCUS(wxResizeableControl::OnSetFocus)
+    EVT_KILL_FOCUS(wxResizeableControl::OnKillFocus)
+    EVT_MOTION(wxResizeableControl::OnMouseMove)
+    EVT_SET_CURSOR(wxResizeableControl::OnSetCursor)
+    EVT_LEFT_UP(wxResizeableControl::OnLButtonUp)
+    EVT_LEFT_DOWN(wxResizeableControl::OnLButtonDown)
+    EVT_KEY_DOWN(wxResizeableControl::OnKeyDown)
+    EVT_SIZE(wxResizeableControl::OnSize)
+    EVT_MOVE(wxResizeableControl::OnMove)
+END_EVENT_TABLE()
+
+// ----------------------------------------------------------------------------
+// wxPictureControl
+// ----------------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(wxPictureControl,wxResizeableControl)
+
+void wxPictureControl::OnEditCut(wxCommandEvent &event)
+{
+    OnEditCopy(event);
+    event.Skip();
+}
+
+void wxPictureControl::OnRightDown(wxMouseEvent &event)
+{
+    wxMenu *context_menu = new wxMenu;
+
+    context_menu->Append(wxID_COPY, _("Copy"));
+    context_menu->Append(wxID_CUT, _("Cut"));
+    context_menu->Append(wxID_REVERT, _("Set to original size"));
+
+    wxPoint hp;
+    hp = event.GetPosition();
+    PopupMenu(context_menu,hp);
+    delete context_menu;
+}
+
+void wxPictureControl::OnPaletteChanged(wxSysColourChangedEvent &)
+{
+    Refresh();
+}
+
+void wxPictureControl::OnSize(wxSizeEvent &event)
+{
+    Refresh();
+    event.Skip();
+}
+
+void wxPictureControl::OnPaint(wxPaintEvent &)
+{
+    wxPaintDC dc(this);
+    wxSize size = GetClientSize();
+    Paint(dc,false,size);
+    if (m_hasfocus)
+        DrawSizeRect(dc);
+}
+
+void wxPictureControl::OnRevert(wxCommandEvent &)
+{
+    wxSize orgs = GetOriginalSize();
+    SetClientSize(orgs.x != -1 ? orgs.x : GetClientSize().x,
+                  orgs.y != -1 ? orgs.y : GetClientSize().y);
+}
+
+BEGIN_EVENT_TABLE(wxPictureControl,wxResizeableControl)
+    EVT_MENU(wxID_REVERT,wxPictureControl::OnRevert)
+    EVT_PAINT(wxPictureControl::OnPaint)
+    EVT_RIGHT_DOWN(wxPictureControl::OnRightDown)
+    EVT_SIZE(wxPictureControl::OnSize)
+    EVT_UPDATE_UI(wxID_COPY,wxPictureControl::CeEditCopy)
+    EVT_UPDATE_UI(wxID_CUT,wxPictureControl::CeEditCut)
+    EVT_SYS_COLOUR_CHANGED(wxPictureControl::OnPaletteChanged)
+END_EVENT_TABLE()
+
+#if defined(__WXMSW__) && wxUSE_METAFILE && wxUSE_ENH_METAFILE
+
+// ----------------------------------------------------------------------------
+// wxMetafileControl
+// ----------------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(wxMetafileControl, wxPictureControl)
+
+wxMetafileControl::wxMetafileControl(wxWindow *AParent, int AnId,WXHANDLE Meta,
+                                     const wxPoint &pos,const wxSize &size,
+                                     long style,const wxString &name)
+ : wxPictureControl(AParent,AnId,pos,size,style,name)
+{
+    m_metafile.SetHENHMETAFILE(Meta);
+    wxSize msize = m_metafile.GetSize();
+    SetSize(msize.x,msize.y);
+}
+
+wxMetafileControl::wxMetafileControl(wxWindow *AParent, int AnId,char *Data,
+                                     int Size,
+                                     const wxPoint &pos,const wxSize &size,
+                                     long style,const wxString &name)
+ : wxPictureControl(AParent,AnId,pos,size,style,name)
+{
+    m_metafile.SetHENHMETAFILE((WXHANDLE)
+                               ::SetEnhMetaFileBits(Size,(unsigned char *)Data));
+}
+
+wxMetafileControl::~wxMetafileControl()
+{
+}
+
+void wxMetafileControl::OnEditCopy(wxCommandEvent &)
+{
+    if (wxTheClipboard->Open())
+    {
+        wxTheClipboard->Clear();
+        m_metafile.SetClipboard(1,1);
+        wxTheClipboard->Close();
+    }
+}
+
+void wxMetafileControl::Paint(wxDC &dc,bool,wxSize &size)
+{
+    wxRect rct(wxPoint(0,0),size);
+    if (m_metafile.Ok())
+        m_metafile.Play(&dc,&rct);
+}
+
+wxSize wxMetafileControl::GetOriginalSize()
+{
+    return wxSize(m_metafile.GetWidth(),m_metafile.GetHeight());
+}
+
+float wxMetafileControl::GetRatio()
+{
+    if (m_metafile.GetHeight())
+        return float(m_metafile.GetWidth())/m_metafile.GetHeight();
+    else
+        return 0;
+}
+
+long wxGetEnhMetaFileBits(HENHMETAFILE metafile,UINT size,LPBYTE data)
+{
+#ifdef __BORLANDC__
+    return ::GetEnhMetaFileBits(metafile,size,(unsigned char *)data);
+#else // some MinGW versions do not have GetEnhMetaFileBits in the headers
+    HINSTANCE gdi = ::LoadLibrary(wxT("GDI32.DLL"));
+    UINT (WINAPI *metab)(HENHMETAFILE,UINT,LPBYTE) = 0;
+    long ret = 0;
+    if (gdi)
+        metab = (UINT (WINAPI *)(HENHMETAFILE,UINT,LPBYTE))
+                ::GetProcAddress(gdi,"GetEnhMetaFileBits");
+    if (metab)
+        ret = metab(metafile,size,(unsigned char *)data);
+    if (gdi)
+        ::FreeLibrary(gdi);
+    return ret;
+#endif
+}
+
+long wxMetafileControl::GetPictureSize()
+{
+    return wxGetEnhMetaFileBits((HENHMETAFILE)m_metafile.GetHENHMETAFILE(),0,0);
+}
+
+long wxMetafileControl::GetPictureData(char *data,long n)
+{
+    return wxGetEnhMetaFileBits((HENHMETAFILE)m_metafile.GetHENHMETAFILE(),
+                                n,(unsigned char *)data);
+}
+
+BEGIN_EVENT_TABLE(wxMetafileControl,wxPictureControl)
+    EVT_MENU(wxID_CUT, wxMetafileControl::OnEditCut)
+    EVT_MENU(wxID_COPY, wxMetafileControl::OnEditCopy)
+END_EVENT_TABLE()
+
+#endif // __WXMSW__
+
+// ----------------------------------------------------------------------------
+// wxBitmapControl
+// ----------------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(wxBitmapControl, wxPictureControl)
+
+wxBitmapControl::wxBitmapControl(wxWindow *AParent, int AnId,
+                                 const wxBitmap &bitmap,
+                                 const wxPoint &pos,const wxSize &size,
+                                 long style,const wxString &name)
+ : wxPictureControl(AParent,AnId,pos,size,style,name)
+{
+    m_bitmap = new wxBitmap(bitmap);
+}
+
+#ifdef __WXMSW__
+
+static size_t wxGetNumOfBitmapColors(size_t bitsPerPixel)
+{
+    switch ( bitsPerPixel )
+    {
+        case 1:
+            // monochrome bitmap, 2 entries
+            return 2;
+
+        case 4:
+            return 16;
+
+        case 8:
+            return 256;
+
+        case 24:
+            // may be used with 24bit bitmaps, but we don't use it here - fall
+            // through
+
+        case 16:
+        case 32:
+            // bmiColors not used at all with these bitmaps
+            return 0;
+
+        default:
+            wxFAIL_MSG( wxT("unknown bitmap format") );
+            return 0;
+    }
+}
+
+wxBitmapControl::wxBitmapControl(wxWindow *AParent, int AnId,char *Data,
+                                 int /*Size*/,const wxPoint &pos,
+                                 const wxSize &size,
+                                 long style,const wxString &name)
+ : wxPictureControl(AParent,AnId,pos,size,style,name)
+{
+    const LPBITMAPINFO pbmi = (const LPBITMAPINFO)Data;
+    const BITMAPINFOHEADER *pbmih = &pbmi->bmiHeader;
+
+    // biClrUsed has the number of colors, unless it's 0
+    int numColors = pbmih->biClrUsed;
+    if (numColors==0)
+    {
+        numColors = wxGetNumOfBitmapColors(pbmih->biBitCount);
+    }
+
+    // offset of image from the beginning of the header
+    DWORD ofs = numColors * sizeof(RGBQUAD);
+    void *image = (char *)pbmih + sizeof(BITMAPINFOHEADER) + ofs;
+
+    ScreenHDC hdc;
+    HBITMAP hbmp = CreateDIBitmap(hdc, pbmih, CBM_INIT,
+                                  image, pbmi, DIB_RGB_COLORS);
+    if ( !hbmp )
+    {
+        wxLogLastError(wxT("CreateDIBitmap"));
+    }
+
+    wxBitmap bitmap(pbmih->biWidth, pbmih->biHeight, pbmih->biBitCount);
+    bitmap.SetHBITMAP((WXHBITMAP)hbmp);
+
+    m_bitmap = new wxBitmap(bitmap);
+}
+
+#endif
+
+wxBitmapControl::~wxBitmapControl()
+{
+    delete m_bitmap;
+}
+
+void wxBitmapControl::Paint(wxDC &dc,bool,wxSize &size)
+{
+    if (m_bitmap)
+    {
+        wxImage img = m_bitmap->ConvertToImage();
+        img.Rescale(size.x,size.y);
+        wxBitmap bmp(img);
+        dc.DrawBitmap(bmp,0,0);
+    }
+}
+
+void wxBitmapControl::OnEditCopy(wxCommandEvent &)
+{
+    if (wxTheClipboard->Open())
+    {
+        wxTheClipboard->Clear();
+        wxBitmapDataObject *bdo = new wxBitmapDataObject;
+        wxBitmap *ClBitmap = new wxBitmap(*m_bitmap);
+        bdo->SetBitmap(*ClBitmap);
+        wxTheClipboard->SetData(bdo);
+        wxTheClipboard->Close();
+    }
+}
+
+#ifdef __WXMSW__
+
+size_t wxConvertBitmapToDIB(LPBITMAPINFO pbi, const wxBitmap& bitmap)
+{
+    wxASSERT_MSG( bitmap.Ok(), wxT("invalid bmp can't be converted to DIB") );
+
+    // shouldn't be selected into a DC or GetDIBits() would fail
+    wxASSERT_MSG( !bitmap.GetSelectedInto(),
+                  wxT("can't copy bitmap selected into wxMemoryDC") );
+
+    // prepare all the info we need
+    BITMAP bm;
+    HBITMAP hbmp = (HBITMAP)bitmap.GetHBITMAP();
+    if ( !GetObject(hbmp, sizeof(bm), &bm) )
+    {
+        wxLogLastError(wxT("GetObject(bitmap)"));
+
+        return 0;
+    }
+
+    // calculate the number of bits per pixel and the number of items in
+    // bmiColors array (whose meaning depends on the bitmap format)
+    WORD biBits = bm.bmPlanes * bm.bmBitsPixel;
+    WORD biColors = (WORD)wxGetNumOfBitmapColors(biBits);
+
+    BITMAPINFO bi2;
+
+    bool wantSizeOnly = pbi == NULL;
+    if ( wantSizeOnly )
+        pbi = &bi2;
+
+    // just for convenience
+    BITMAPINFOHEADER& bi = pbi->bmiHeader;
+
+    bi.biSize = sizeof(BITMAPINFOHEADER);
+    bi.biWidth = bm.bmWidth;
+    bi.biHeight = bm.bmHeight;
+    bi.biPlanes = 1;
+    bi.biBitCount = biBits;
+    bi.biCompression = BI_RGB;
+    bi.biSizeImage = 0;
+    bi.biXPelsPerMeter = 0;
+    bi.biYPelsPerMeter = 0;
+    bi.biClrUsed = 0;
+    bi.biClrImportant = 0;
+
+    // memory we need for BITMAPINFO only
+    DWORD dwLen = bi.biSize + biColors * sizeof(RGBQUAD);
+
+    // first get the image size
+    ScreenHDC hdc;
+    if ( !GetDIBits(hdc, hbmp, 0, bi.biHeight, NULL, pbi, DIB_RGB_COLORS) )
+    {
+        wxLogLastError(wxT("GetDIBits(NULL)"));
+
+        return 0;
+    }
+
+    if ( wantSizeOnly )
+    {
+        // size of the header + size of the image
+        return dwLen + bi.biSizeImage;
+    }
+
+    // and now copy the bits
+    void *image = (char *)pbi + dwLen;
+    if ( !GetDIBits(hdc, hbmp, 0, bi.biHeight, image, pbi, DIB_RGB_COLORS) )
+    {
+        wxLogLastError(wxT("GetDIBits"));
+
+        return 0;
+    }
+
+    return dwLen + bi.biSizeImage;
+}
+
+long wxBitmapControl::GetPictureData(char *data,long /*n*/)
+{
+    wxConvertBitmapToDIB((LPBITMAPINFO)data,*m_bitmap);
+    return GetPictureSize();
+}
+
+long wxBitmapControl::GetPictureSize()
+{
+    return wxConvertBitmapToDIB(0,*m_bitmap);
+}
+
+#endif
+
+wxSize wxBitmapControl::GetOriginalSize()
+{
+    return wxSize(m_bitmap->GetWidth(),m_bitmap->GetHeight());
+}
+
+float wxBitmapControl::GetRatio()
+{
+    if (m_bitmap->GetHeight())
+        return float(m_bitmap->GetWidth())/m_bitmap->GetHeight();
+    else
+        return 0;
+}
+
+BEGIN_EVENT_TABLE(wxBitmapControl,wxPictureControl)
+    EVT_MENU(wxID_CUT, wxBitmapControl::OnEditCut)
+    EVT_MENU(wxID_COPY, wxBitmapControl::OnEditCopy)
+END_EVENT_TABLE()
+
+// ----------------------------------------------------------------------------
+// wxResizeableControlCanvas
+// ----------------------------------------------------------------------------
+
+void wxResizeableControlCanvas::UpdateScrollRange()
+{
+    wxWindowListNode *Child = GetChildren().GetFirst();
+    wxSize GesSize;
+    while (Child)
+    {
+        wxWindow *chw = wxDynamicCast(Child->GetData(),wxResizeableControl);
+        if (chw)
+        {
+            wxRect rect = chw->GetRect();
+            rect.x += GetScrollPos(wxHORIZONTAL);
+            rect.y += GetScrollPos(wxVERTICAL);
+            if (rect.GetBottom() > GesSize.y)
+                GesSize.y = rect.GetBottom();
+            if (rect.GetRight() > GesSize.x)
+                GesSize.x = rect.GetRight();
+        }
+        Child = Child->GetNext();
+    }
+    SetScrollbars(1,1,GesSize.x,GesSize.y,
+                  GetScrollPos(wxHORIZONTAL),GetScrollPos(wxVERTICAL),true);
+}
+
+BEGIN_EVENT_TABLE(wxResizeableControlCanvas,wxScrolledWindow)
+    EVT_CHILD_CREATED(-1, wxResizeableControlCanvas::OnChildWindowChange)
+    EVT_CHILD_MOVED(-1, wxResizeableControlCanvas::OnChildWindowChange)
+    EVT_CHILD_RESIZED(-1, wxResizeableControlCanvas::OnChildWindowChange)
+    EVT_CHILD_CLOSED(-1, wxResizeableControlCanvas::OnChildWindowChange)
+END_EVENT_TABLE()
+
+
diff -rbu2P wxw/contrib/samples/resizec/resizecd.cpp wxWindows/contrib/samples/resizec/resizecd.cpp
--- wxw/contrib/samples/resizec/resizecd.cpp	Thu Jan 01 01:00:00 1970
+++ wxWindows/contrib/samples/resizec/resizecd.cpp	Thu Jun 19 16:18:58 2003
@@ -0,0 +1,88 @@
+//-----------------------------------------------------------------------------
+// Name:        resizecdd.cpp
+// Purpose:     resizeable controls sample: Main application file
+// Author:      Markus Greither
+// RCS-ID:      
+// Copyright:   (c) Markus Greither
+// Licence:     wxWindows licence
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// GCC implementation
+//-----------------------------------------------------------------------------
+
+#ifdef __GNUG__
+    #pragma implementation "resizecd.h"
+#endif
+
+//-----------------------------------------------------------------------------
+// Standard wxWindows headers
+//-----------------------------------------------------------------------------
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+// For all others, include the necessary headers (this file is usually all you
+// need because it includes almost all "standard" wxWindows headers)
+#ifndef WX_PRECOMP
+    #include "wx/wx.h"
+#endif
+
+//-----------------------------------------------------------------------------
+// Header of this .cpp file
+//-----------------------------------------------------------------------------
+
+#include "resizecd.h"
+
+//-----------------------------------------------------------------------------
+// Remaining headers: Needed wx headers, then wx/contrib headers, then application headers
+//-----------------------------------------------------------------------------
+
+#include "wx/image.h"               // wxImage
+
+//-----------------------------------------------------------------------------
+
+#include "myframe.h"
+
+//-----------------------------------------------------------------------------
+// wxWindows macro: Declare the application.
+//-----------------------------------------------------------------------------
+
+// Create a new application object: this macro will allow wxWindows to create
+// the application object during program execution (it's better than using a
+// static object for many reasons) and also declares the accessor function
+// wxGetApp() which will return the reference of the right type (i.e. the_app and
+// not wxApp).
+IMPLEMENT_APP(MyApp)
+
+//-----------------------------------------------------------------------------
+// Public methods
+//-----------------------------------------------------------------------------
+
+// 'Main program' equivalent: the program execution "starts" here
+bool MyApp::OnInit()
+{
+    // This example uses GIFs, but if
+    // you want PNGs, then add a PNG handler, etc. See wxImage::AddHandler()
+    // documentation for the types of image handlers available.
+#ifdef __WXGTK__
+    wxImage::AddHandler(new wxPNGHandler); // required for GTK clipboard
+#endif
+    wxImage::AddHandler(new wxGIFHandler);
+
+    // Make an instance of your derived frame. Passing NULL (the default value
+    // of MyFrame's constructor is NULL) as the frame doesn't have a frame
+    // since it is the first window.
+    MyFrame *frame = new MyFrame();
+
+    // Show the frame.
+    frame->Show(TRUE);
+    
+    // Return TRUE to tell program to continue (FALSE would terminate).
+    return TRUE;
+}
+
diff -rbu2P wxw/contrib/samples/resizec/resizecd.h wxWindows/contrib/samples/resizec/resizecd.h
--- wxw/contrib/samples/resizec/resizecd.h	Thu Jan 01 01:00:00 1970
+++ wxWindows/contrib/samples/resizec/resizecd.h	Thu Jun 19 15:16:24 2003
@@ -0,0 +1,54 @@
+//-----------------------------------------------------------------------------
+// Name:        resizecd.cpp
+// Purpose:     resizeable controls sample: Main application file
+// Author:      Markus Greither
+// RCS-ID:
+// Copyright:   (c) Markus Greither
+// Licence:     wxWindows licence
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// Begin single inclusion of this .h file condition
+//-----------------------------------------------------------------------------
+
+#ifndef _RESIZEDEMO_H_
+#define _RESIZEDEMO_H_
+
+//-----------------------------------------------------------------------------
+// GCC interface
+//-----------------------------------------------------------------------------
+
+#if defined(__GNUG__) && !defined(__APPLE__)
+    #pragma interface "resizecd.h"
+#endif
+
+//-----------------------------------------------------------------------------
+// Headers
+//-----------------------------------------------------------------------------
+
+#include "wx/app.h"             // wxApp
+
+//-----------------------------------------------------------------------------
+// Class definition: MyApp
+//-----------------------------------------------------------------------------
+
+// Define a new application type, each program should derive a class from wxApp
+class MyApp : public wxApp
+{
+
+public:
+
+    // Override base class virtuals:
+    // wxApp::OnInit() is called on application startup and is a good place 
+    // for the app initialization (doing it here and not in the ctor 
+    // allows to have an error return: if OnInit() returns false, the 
+    // application terminates)
+    virtual bool OnInit();
+    
+};
+
+//-----------------------------------------------------------------------------
+// End single inclusion of this .h file condition
+//-----------------------------------------------------------------------------
+
+#endif  //_RESIZEDEMO_H_
diff -rbu2P wxw/contrib/samples/resizec/resizecd.rc wxWindows/contrib/samples/resizec/resizecd.rc
--- wxw/contrib/samples/resizec/resizecd.rc	Thu Jan 01 01:00:00 1970
+++ wxWindows/contrib/samples/resizec/resizecd.rc	Sun Jun 10 00:15:30 2001
@@ -0,0 +1,2 @@
+appicon ICON   "rc/appicon.ico"
+#include "wx/msw/wx.rc"
diff -rbu2P wxw/contrib/samples/resizec/wxResizeableControl.txt wxWindows/contrib/samples/resizec/wxResizeableControl.txt
--- wxw/contrib/samples/resizec/wxResizeableControl.txt	Thu Jan 01 01:00:00 1970
+++ wxWindows/contrib/samples/resizec/wxResizeableControl.txt	Thu Jun 19 13:11:52 2003
@@ -0,0 +1,65 @@
+Documentation for wxResizeableControl and derived classes
+
+
+More detailed information is available in the sources. Use Doxygen to extract.
+
+
+Purpose:
+
+Create a base class for controls that the user can resize, move, copy, paste and print and that has a simple programming interface. Derive controls for display of resizeable and moveable Metafiles and bitmaps.
+
+
+Implementation:
+
+
+wxResizeableControl:
+
+Abstract base class. Defines function members to provide a common interface for printing, setting the with/height ratio and zoom.
+
+
+wxPictureControl:
+
+Abstract base class for pictures, derived from wxResizeableControl. Defines function members to provide a common interface for getting/setting picture data, picture type.
+
+
+wxEnhancedMetafileControl:
+
+Derived from wxPictureControl, implements resizeable Metafile controls. wxMSW only.
+
+
+wxBitmapControl:
+
+Derived from wxPictureControl, implements resizeable bitmap controls.
+
+
+wxResizeableControlCanvas:
+
+Parent window for wxResizeableControls. Responds to child window notifications by recalculation of scrollbars.
+
+
+Build:
+
+Requires wxWindows 2.4.1 and up. wxMSW and wxGTK are been tested.
+
+
+Borland:
+
+type 
+
+make -f Makefile.b32
+
+and resizecd for running the sample
+
+
+MinGW:
+
+type 
+
+make -f Makefile.g95
+
+and resizecd for running the sample
+
+
+More makefiles are provided, but are untested.
+
+
Binary files wxw/contrib/samples/resizec.zip and wxWindows/contrib/samples/resizec.zip differ
diff -rbu2P wxw/contrib/src/resizec/Makefile.in wxWindows/contrib/src/resizec/Makefile.in
--- wxw/contrib/src/resizec/Makefile.in	Thu Jan 01 01:00:00 1970
+++ wxWindows/contrib/src/resizec/Makefile.in	Thu Jun 19 10:02:24 2003
@@ -0,0 +1,26 @@
+# $Id: Makefile.in,v 1.7 2003/04/24 22:15:21 MBN Exp $
+
+top_srcdir = @top_srcdir@/..
+top_builddir = ../../..
+
+
+TARGET_LIBNAME=lib@WX_LIBRARY_BASENAME@_resizec-@WX_RELEASE@
+
+LIBVERSION_CURRENT=@WX_CURRENT@
+LIBVERSION_REVISION=@WX_REVISION@
+LIBVERSION_AGE=@WX_AGE@
+
+HEADER_PATH=$(top_srcdir)/contrib/include/wx
+HEADER_SUBDIR=resizec
+
+HEADERS=resizec.h
+
+OBJECTS=resizeco
+
+DEPFILES=$(OBJECTS:.o=.d)
+
+APPEXTRADEFS=-I$(top_srcdir)/contrib/include $(EXPAT_DEFS)
+
+include $(top_builddir)/src/makelib.env
+
+-include $(DEPFILES)
diff -rbu2P wxw/contrib/src/resizec/makefile.b32 wxWindows/contrib/src/resizec/makefile.b32
--- wxw/contrib/src/resizec/makefile.b32	Thu Jan 01 01:00:00 1970
+++ wxWindows/contrib/src/resizec/makefile.b32	Thu Jun 19 10:23:18 2003
@@ -0,0 +1,20 @@
+#
+# File:		makefile.b32
+# Author:	Julian Smart
+# Created:	2000
+# Updated:	
+# Copyright:
+#
+# Makefile : Builds BC++ library for 32-bit BC++
+
+WXDIR = $(WXWIN)
+
+!include $(WXDIR)\src\makeb32.env
+
+LIBTARGET=$(WXDIR)\lib\resizec
+
+OBJECTS=  $(OBJ_PATH)\resizec.obj
+
+!include $(WXDIR)\src\makelib.b32
+
+$(OBJ_PATH)\resizec.obj: resizec.cpp
diff -rbu2P wxw/contrib/src/resizec/makefile.g95 wxWindows/contrib/src/resizec/makefile.g95
--- wxw/contrib/src/resizec/makefile.g95	Thu Jan 01 01:00:00 1970
+++ wxWindows/contrib/src/resizec/makefile.g95	Thu Jun 19 10:01:00 2003
@@ -0,0 +1,16 @@
+#
+# File:         makefile.g95
+# Author:       Julian Smart
+# Created:      2000
+# Updated:
+# Copyright:    (c) Julian Smart, 2000
+#
+# Makefile for wxWindows resizeable controls library (Cygwin/Mingw32).
+
+WXDIR = ../../..
+
+LIBTARGET=$(WXDIR)/lib/libresizec.a
+
+OBJECTS= resizec.o
+include $(WXDIR)/src/makelib.g95
+
diff -rbu2P wxw/contrib/src/resizec/makefile.vc wxWindows/contrib/src/resizec/makefile.vc
--- wxw/contrib/src/resizec/makefile.vc	Thu Jan 01 01:00:00 1970
+++ wxWindows/contrib/src/resizec/makefile.vc	Thu Jun 19 10:09:38 2003
@@ -0,0 +1,38 @@
+
+# File:		makefile.vc
+# Author:	Julian Smart
+# Created:	1993
+# Updated:
+# Copyright:	
+#
+# "%W% %G%"
+#
+# Makefile : Builds resizeable controls classes library (MS VC++).
+# Use FINAL=1 argument to nmake to build final version with no debugging
+# info
+
+# Set WXDIR for your system
+WXDIR = $(WXWIN)
+THISDIR = $(WXDIR)\contrib\src\xrc
+
+!if "$(RM)" == ""
+RM= erase
+!endif
+
+NOPCH=1
+
+# Unfortunately we need this _before_ we include makelib.vc
+!if "$(FINAL)" == "1"
+D=Release
+!else
+D=Debug
+LIBEXT=d
+!endif
+
+LIBTARGET=$(WXDIR)\lib\resizec$(LIBEXT).lib
+EXTRATARGETS=$(D)
+
+OBJECTS=$(D)\resizec.obj
+
+!include $(WXDIR)\src\makelib.vc
+
diff -rbu2P wxw/contrib/src/resizec/resizec.cpp wxWindows/contrib/src/resizec/resizec.cpp
--- wxw/contrib/src/resizec/resizec.cpp	Thu Jan 01 01:00:00 1970
+++ wxWindows/contrib/src/resizec/resizec.cpp	Thu Jun 19 11:06:52 2003
@@ -0,0 +1,942 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        resizec.cpp
+// Purpose:     wxResizeableControl
+// Author:      Markus Greither
+// Modified by:
+// Created:     11/11/02
+// RCS-ID:      $Id:     1.04 2003/06/14 magr
+// Copyright:   (c) Markus Greither
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+
+#ifdef __GNUG__
+    #pragma implementation "resizec.h"
+#endif
+
+// For compilers that support precompilation, includes "wx.h".
+#include "wx/wxprec.h"
+
+#if defined(__BORLANDC__)
+    #pragma hdrstop
+#endif
+
+#ifndef WX_PRECOMP
+#include "wx/wx.h"
+#endif
+
+#include "wx/image.h"
+#include "wx/metafile.h"
+#include "wx/clipbrd.h"
+#include "wx/resizec/resizec.h"
+
+#ifdef __WXMSW__
+#include <windows.h>
+#include "wx/msw/winundef.h"
+#include "wx/msw/dib.h"
+#include "wx/msw/private.h"
+#endif
+
+// ----------------------------------------------------------------------------
+// Events
+// ----------------------------------------------------------------------------
+
+DEFINE_EVENT_TYPE(wxEVT_COMMAND_CHILD_CREATED)
+DEFINE_EVENT_TYPE(wxEVT_COMMAND_CHILD_MOVED)
+DEFINE_EVENT_TYPE(wxEVT_COMMAND_CHILD_CLOSED)
+DEFINE_EVENT_TYPE(wxEVT_COMMAND_CHILD_RESIZED)
+
+// ----------------------------------------------------------------------------
+// wxZoomData
+// ----------------------------------------------------------------------------
+
+void wxZoomData::SetSize(int width,int height)
+{
+    if ((m_currRect.width != width) ||
+        (m_currRect.height != height))
+    {
+        m_orgSize = wxSize(int(width/m_zoom),
+                           int(height/m_zoom));
+        m_currRect.width = width;
+        m_currRect.height = height;
+    }
+}
+
+void wxZoomData::Move(int xpos,int ypos)
+{
+    if ((m_currRect.x != xpos) ||
+        (m_currRect.x != ypos))
+    {
+        m_orgPos = wxPoint(int(xpos/m_zoom),
+                           int(ypos/m_zoom));
+        m_currRect.x = xpos;
+        m_currRect.y = ypos;
+    }
+}
+
+void wxZoomData::SetZoomRect(wxWindow *Window,float zoom,
+                 int curxoffs,int curyoffs,
+                 int newxoffs,int newyoffs)
+{
+    m_currRect = wxRect(int((m_orgPos.x+curxoffs-newxoffs)*zoom),
+                        int((m_orgPos.y+curyoffs-newyoffs)*zoom),
+                        int(m_orgSize.x*zoom),int(m_orgSize.y*zoom));
+    m_zoom = zoom;
+    Window->SetSize(m_currRect);
+}
+
+// ----------------------------------------------------------------------------
+// wxResizeableControl
+// ----------------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(wxResizeableControl, wxWindow)
+
+wxResizeableControl::wxResizeableControl(wxWindow *AParent,
+                                         int AnId,const wxPoint &pos,
+                                         const wxSize &size,long style,
+                                         const wxString &name)
+ : wxWindow(AParent,AnId,pos,size,style,name),m_zoomData(size,pos),
+   m_capt(0),m_movemode(wxResizeableControl::MoveWin),m_hasfocus(false)
+{
+    wxCommandEvent cevent(wxEVT_COMMAND_CHILD_CREATED,GetId());
+    if (GetParent())
+        GetParent()->AddPendingEvent(cevent);
+}
+
+void wxResizeableControl::FocusRectCoord(wxDC &DC,wxCoord x1,wxCoord y1,
+                                         wxCoord w,wxCoord h)
+{
+    wxPen pen(*wxBLACK,1,wxDOT);
+    wxBrush &OldBr = DC.GetBrush();
+    DC.SetBrush(*wxTRANSPARENT_BRUSH);
+    DC.SetPen(pen);
+    DC.SetLogicalFunction(wxINVERT);
+    DC.DrawRectangle(x1,y1,w,h);
+    DC.SetBrush(OldBr);
+    DC.SetPen(wxNullPen);
+    DC.SetLogicalFunction(wxCOPY);
+}
+
+// Draws the current window size
+void wxResizeableControl::DrawMoveRect(wxPoint hp,int Mode,float Ratio)
+{
+    wxScreenDC dc;
+    wxRect rect = NewRect(hp,Mode,Ratio);
+    DrawFocusRect(dc,rect);
+}
+
+// FIXME: This doesn't work properly for windows that are
+// very small and the size rectangles overlap
+int wxResizeableControl::PointInSizeRect(wxPoint hp)
+{
+    for (int i = 0;i < 8;i++)
+    {
+        int x = 6+GetSizeX(i)*(GetClientSize().x-11)/2;
+        int y = 6+GetSizeY(i)*(GetClientSize().y-11)/2;
+        wxRect rect(wxPoint(x-SizeXRad,y-SizeYRad),
+                    wxPoint(x+SizeXRad,y+SizeYRad));
+        if ((hp.x >= rect.x) && (hp.x <= rect.x+rect.width) &&
+            (hp.y >= rect.y) && (hp.y <= rect.y+rect.height))
+            return i;
+    }
+    return MoveWin;
+}
+
+// Calculates the current window size (Parent coordinates)
+wxRect wxResizeableControl::NewRect(wxPoint hp,int Mode,float Ratio)
+{
+    wxSize size = GetClientSize();
+    wxPoint pt(0,0);
+    ClientToScreen(&pt.x,&pt.y);
+    wxRect rect(pt,size);
+    wxRect rect1(rect);
+    wxPoint delta(hp.x-m_curpos.x,hp.y-m_curpos.y);
+    switch (Mode)
+    {
+        case MoveWin : {rect.x += delta.x; rect.y += delta.y;}; break;
+        case Top : rect.y += delta.y; rect.height -= delta.y; break;
+        case Bottom : rect.height += delta.y; break;
+        case Left : rect.x += delta.x; rect.width -= delta.x; break;
+        case Right : rect.width += delta.x; break;
+        case TopLeft :
+            rect.x += delta.x;
+            rect.y += delta.y;
+            rect.width -= delta.x;
+            rect.height -= delta.y;
+            if (Ratio)
+            {
+              if (rect.GetWidth() < rect.GetHeight()*Ratio)
+              {
+                  int tmp = int(rect.GetHeight()*Ratio);
+                  rect.x = rect.GetRight()-tmp+1;
+                  rect.width = tmp;
+              }
+              else
+              {
+                  int tmp = int(rect.GetWidth()/Ratio);
+                  rect.y = rect.GetBottom()-tmp+1;
+                  rect.height = tmp;
+              }
+            }
+            break;
+        case TopRight :
+            rect.width += delta.x;
+            rect.y += delta.y;
+            rect.height -= delta.y;
+            if (Ratio)
+            {
+                if (rect.GetWidth() < rect.GetHeight()*Ratio)
+                    rect.width = int(rect.GetHeight()*Ratio);
+                else
+                {
+                    int tmp = int(rect.GetWidth()/Ratio);
+                    rect.y = rect.GetBottom()-tmp+1;
+                    rect.height = tmp;
+                }
+            }
+            break;
+        case BottomLeft :
+            rect.x += delta.x;
+            rect.width -= delta.x;
+            rect.height += delta.y;
+            if (Ratio)
+            {
+                if (rect.GetWidth() < rect.GetHeight()*Ratio)
+                {
+                    int tmp = int(rect.GetHeight()*Ratio);
+                    rect.x = rect.GetRight()-tmp+1;
+                    rect.width = tmp;
+                }
+                else
+                    rect.height = int(rect.GetWidth()/Ratio);
+            }
+            break;
+        case BottomRight :
+            rect.width += delta.x;
+            rect.height += delta.y;
+            if (Ratio)
+            {
+                if (rect.GetWidth() < rect.GetHeight()*Ratio)
+                    rect.width = int(rect.GetHeight()*Ratio);
+                else
+                    rect.height = int(rect.GetWidth()/Ratio);
+            }
+            break;
+    }
+    wxSize size1 = GetParent()->GetClientSize();
+    wxPoint pt1(0,0);
+    GetParent()->ClientToScreen(&pt1.x,&pt1.y);
+    wxRect prect(pt1,size1);
+    prect.Inflate(-30,-30);
+    if ((((rect.x <= prect.GetRight()) &&
+          (prect.x <= rect.GetRight())) &&
+         ((rect.y <= prect.GetBottom()) &&
+          (prect.y <= rect.GetBottom()))) &&
+         (rect.GetWidth() >= 20) && (rect.GetHeight() >= 20))
+        return rect;
+    else
+        return rect1;
+}
+
+// Draws the size rectangles
+void wxResizeableControl::DrawSizeRect(wxDC &dc)
+{
+    int AltROP = dc.GetLogicalFunction();
+    dc.SetLogicalFunction(wxXOR);
+    wxBrush brs(wxSystemSettings::GetSystemColour(wxSYS_COLOUR_WINDOW),wxSOLID);
+    wxBrush &OldBr = dc.GetBrush();
+    dc.SetBrush(brs);
+    wxPen pen(wxSystemSettings::GetSystemColour(wxSYS_COLOUR_WINDOW),1,wxSOLID);
+    dc.SetPen(pen);
+    for (int i = 0;i < 8;i++)
+    {
+        int x = 0,y = 0;
+        switch (GetSizeX(i))
+        {
+            case 0 : x = SizeXRad; break;
+            case 1 : x = GetClientSize().x/2; break;
+            case 2 : x = GetClientSize().x-SizeXRad; break;
+        }
+        switch (GetSizeY(i))
+        {
+            case 0 : y = SizeYRad; break;
+            case 1 : y = GetClientSize().y/2; break;
+            case 2 : y = GetClientSize().y-SizeYRad; break;
+        }
+        dc.DrawRectangle(x-SizeXRad,y-SizeYRad,2*SizeXRad,2*SizeYRad);
+    }
+    dc.SetPen(wxNullPen);
+    dc.SetBrush(OldBr);
+    dc.SetLogicalFunction(AltROP);
+}
+
+void wxResizeableControl::OnSetCursor(wxSetCursorEvent &event)
+{
+  static wxCursor csr;
+  if (m_hasfocus)
+  {
+      wxPoint hp(event.GetX(),event.GetY()),point = hp;
+      switch (PointInSizeRect(point))
+      {
+          case MoveWin :
+              event.SetCursor(csr = wxCursor(wxCURSOR_SIZING));
+              break;
+          case Top :
+          case Bottom :
+              event.SetCursor(csr = wxCursor(wxCURSOR_SIZENS));
+              break;
+          case Left :
+          case Right :
+              event.SetCursor(csr = wxCursor(wxCURSOR_SIZEWE));
+              break;
+          case TopRight :
+          case BottomLeft :
+              event.SetCursor(csr = wxCursor(wxCURSOR_SIZENESW));
+              break;
+          case BottomRight :
+          case TopLeft :
+              event.SetCursor(csr = wxCursor(wxCURSOR_SIZENWSE));
+              break;
+          default :
+              event.SetCursor(*wxSTANDARD_CURSOR);
+      }
+  }
+  else
+      event.SetCursor(csr = wxCursor(wxCURSOR_SIZING));
+}
+
+void wxResizeableControl::OnLButtonDown(wxMouseEvent &event)
+{
+    wxPoint hp;
+    hp.x = event.GetX();
+    hp.y = event.GetY();
+    ScreenToClient(hp);
+    m_curpos = hp;
+    m_lastcurpos = hp;
+    if (!m_hasfocus)
+    {
+        SetFocus();
+        m_hasfocus = true;
+        m_movemode = MoveWin;
+    }
+    else
+    {
+        m_movemode = PointInSizeRect(hp);
+    }
+    CaptureMouse();
+    m_capt = true;
+    m_moved = false;
+}
+
+void wxResizeableControl::OnMouseMove(wxMouseEvent &event)
+{
+    wxPoint hp;
+    hp.x = event.GetX();
+    hp.y = event.GetY();
+    ScreenToClient(hp);
+    if (hp != m_lastcurpos)
+    {
+        if (m_capt)
+        {
+            if (m_moved)
+                DrawMoveRect(m_lastcurpos,m_movemode,GetRatio());
+            m_moved |= ((abs(m_curpos.x-hp.x) > 10) ||
+                        (abs(m_curpos.y-hp.y) > 10));
+            if (m_moved)
+                DrawMoveRect(hp,m_movemode,GetRatio());
+        }
+        m_lastcurpos = hp;
+    }
+#ifdef __WXGTK__
+    wxSetCursorEvent evt(hp.x,hp.y);
+    OnSetCursor(evt);
+    SetCursor(evt.GetCursor());
+#endif
+}
+
+void wxResizeableControl::OnLButtonUp(wxMouseEvent &event)
+{
+    wxPoint point;
+    point.x = event.GetX();
+    point.y = event.GetY();
+    ScreenToClient(point);
+    if (m_capt)
+    {
+        ReleaseMouse();
+        m_capt = false;
+        if (m_moved)
+        {
+            DrawMoveRect(m_lastcurpos,m_movemode,GetRatio());
+            wxRect rect = NewRect(point,m_movemode,GetRatio());
+            wxPoint pt = rect.GetPosition();
+            GetParent()->ScreenToClient(&pt.x,&pt.y);
+            rect.x = pt.x;
+            rect.y = pt.y;
+            SetSize(rect);
+            Refresh();
+        }
+    }
+    m_movemode = MoveWin;
+}
+
+int wxResizeableControl::GetSizeX(int Mode)
+{
+    int Pos = -1;
+    switch (Mode)
+    {
+        case Bottom :
+        case Top : Pos = 1; break;
+        case TopLeft :
+        case BottomLeft :
+        case Left : Pos = 0; break;
+        case TopRight :
+        case BottomRight :
+        case Right : Pos = 2; break;
+    }
+    return Pos;
+}
+
+int wxResizeableControl::GetSizeY(int Mode)
+{
+  int Pos = -1;
+  switch (Mode)
+  {
+      case TopRight :
+      case TopLeft :
+      case Top : Pos = 0; break;
+      case Left :
+      case Right : Pos = 1; break;
+      case BottomRight :
+      case BottomLeft :
+      case Bottom : Pos = 2; break;
+  }
+  return Pos;
+}
+
+void wxResizeableControl::OnKillFocus(wxFocusEvent &)
+{
+    if (m_hasfocus)
+    {
+        m_hasfocus = false;
+        wxClientDC DC(this);
+        DrawSizeRect(DC);
+    }
+}
+
+void wxResizeableControl::OnSetFocus(wxFocusEvent &)
+{
+    if (!m_hasfocus)
+    {
+        Raise();
+        Update();
+        wxClientDC DC(this);
+        DrawSizeRect(DC);
+        m_hasfocus = true;
+    }
+}
+
+void wxResizeableControl::OnKeyDown(wxKeyEvent &event)
+{
+    if (event.AltDown())
+    {
+        event.Skip();
+        return;
+    }
+    switch (event.GetKeyCode())
+    {
+        case WXK_DELETE :
+        {
+            wxCommandEvent cevent(wxEVT_COMMAND_CHILD_CLOSED,GetId());
+            if (GetParent())
+                GetParent()->AddPendingEvent(cevent);
+            Destroy();
+            break;
+        }
+        case WXK_LEFT :
+          if (event.ControlDown())
+              if (event.ShiftDown())
+                  SetSize(GetPosition().x,GetPosition().y,
+                          GetSize().x-1,GetSize().y);
+              else
+                  Move(GetPosition().x-1,GetPosition().y);
+          break;
+        case WXK_RIGHT :
+          if (event.ControlDown())
+              if (event.ShiftDown())
+                  SetSize(GetPosition().x,GetPosition().y,
+                          GetSize().x+1,GetSize().y);
+              else
+                  Move(GetPosition().x+1,GetPosition().y);
+          break;
+        case WXK_UP :
+          if (event.ControlDown())
+              if (event.ShiftDown())
+                  SetSize(GetPosition().x,GetPosition().y,
+                          GetSize().x,GetSize().y-1);
+              else
+                  Move(GetPosition().x,GetPosition().y-1);
+          break;
+        case WXK_DOWN :
+          if (event.ControlDown())
+              if (event.ShiftDown())
+                  SetSize(GetPosition().x,GetPosition().y,
+                          GetSize().x,GetSize().y+1);
+              else
+                  Move(GetPosition().x,GetPosition().y+1);
+          break;
+        default:
+          event.Skip();
+    }
+}
+
+void wxResizeableControl::OnEditCut(wxCommandEvent &)
+{
+    wxCommandEvent cevent(wxEVT_COMMAND_CHILD_CLOSED,GetId());
+    if (GetParent())
+        GetParent()->AddPendingEvent(cevent);
+    Destroy();
+}
+
+void wxResizeableControl::OnSize(wxSizeEvent &event)
+{
+    wxCommandEvent cevent(wxEVT_COMMAND_CHILD_RESIZED,GetId());
+    if (GetParent())
+        GetParent()->AddPendingEvent(cevent);
+    m_zoomData.SetSize(event.GetSize().x,event.GetSize().y);
+}
+
+void wxResizeableControl::OnMove(wxMoveEvent &event)
+{
+    wxCommandEvent cevent(wxEVT_COMMAND_CHILD_MOVED,GetId());
+    if (GetParent())
+        GetParent()->AddPendingEvent(cevent);
+    m_zoomData.Move(event.GetPosition().x,event.GetPosition().y);
+}
+
+BEGIN_EVENT_TABLE(wxResizeableControl,wxWindow)
+    EVT_MENU(wxID_CUT,wxResizeableControl::OnEditCut)
+    EVT_SET_FOCUS(wxResizeableControl::OnSetFocus)
+    EVT_KILL_FOCUS(wxResizeableControl::OnKillFocus)
+    EVT_MOTION(wxResizeableControl::OnMouseMove)
+    EVT_SET_CURSOR(wxResizeableControl::OnSetCursor)
+    EVT_LEFT_UP(wxResizeableControl::OnLButtonUp)
+    EVT_LEFT_DOWN(wxResizeableControl::OnLButtonDown)
+    EVT_KEY_DOWN(wxResizeableControl::OnKeyDown)
+    EVT_SIZE(wxResizeableControl::OnSize)
+    EVT_MOVE(wxResizeableControl::OnMove)
+END_EVENT_TABLE()
+
+// ----------------------------------------------------------------------------
+// wxPictureControl
+// ----------------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(wxPictureControl,wxResizeableControl)
+
+void wxPictureControl::OnEditCut(wxCommandEvent &event)
+{
+    OnEditCopy(event);
+    event.Skip();
+}
+
+void wxPictureControl::OnRightDown(wxMouseEvent &event)
+{
+    wxMenu *context_menu = new wxMenu;
+
+    context_menu->Append(wxID_COPY, _("Copy"));
+    context_menu->Append(wxID_CUT, _("Cut"));
+    context_menu->Append(wxID_REVERT, _("Set to original size"));
+
+    wxPoint hp;
+    hp = event.GetPosition();
+    PopupMenu(context_menu,hp);
+    delete context_menu;
+}
+
+void wxPictureControl::OnPaletteChanged(wxSysColourChangedEvent &)
+{
+    Refresh();
+}
+
+void wxPictureControl::OnSize(wxSizeEvent &event)
+{
+    Refresh();
+    event.Skip();
+}
+
+void wxPictureControl::OnPaint(wxPaintEvent &)
+{
+    wxPaintDC dc(this);
+    wxSize size = GetClientSize();
+    Paint(dc,false,size);
+    if (m_hasfocus)
+        DrawSizeRect(dc);
+}
+
+void wxPictureControl::OnRevert(wxCommandEvent &)
+{
+    wxSize orgs = GetOriginalSize();
+    SetClientSize(orgs.x != -1 ? orgs.x : GetClientSize().x,
+                  orgs.y != -1 ? orgs.y : GetClientSize().y);
+}
+
+BEGIN_EVENT_TABLE(wxPictureControl,wxResizeableControl)
+    EVT_MENU(wxID_REVERT,wxPictureControl::OnRevert)
+    EVT_PAINT(wxPictureControl::OnPaint)
+    EVT_RIGHT_DOWN(wxPictureControl::OnRightDown)
+    EVT_SIZE(wxPictureControl::OnSize)
+    EVT_UPDATE_UI(wxID_COPY,wxPictureControl::CeEditCopy)
+    EVT_UPDATE_UI(wxID_CUT,wxPictureControl::CeEditCut)
+    EVT_SYS_COLOUR_CHANGED(wxPictureControl::OnPaletteChanged)
+END_EVENT_TABLE()
+
+#if defined(__WXMSW__) && wxUSE_METAFILE && wxUSE_ENH_METAFILE
+
+// ----------------------------------------------------------------------------
+// wxMetafileControl
+// ----------------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(wxMetafileControl, wxPictureControl)
+
+wxMetafileControl::wxMetafileControl(wxWindow *AParent, int AnId,WXHANDLE Meta,
+                                     const wxPoint &pos,const wxSize &size,
+                                     long style,const wxString &name)
+ : wxPictureControl(AParent,AnId,pos,size,style,name)
+{
+    m_metafile.SetHENHMETAFILE(Meta);
+    wxSize msize = m_metafile.GetSize();
+    SetSize(msize.x,msize.y);
+}
+
+wxMetafileControl::wxMetafileControl(wxWindow *AParent, int AnId,char *Data,
+                                     int Size,
+                                     const wxPoint &pos,const wxSize &size,
+                                     long style,const wxString &name)
+ : wxPictureControl(AParent,AnId,pos,size,style,name)
+{
+    m_metafile.SetHENHMETAFILE((WXHANDLE)
+                               ::SetEnhMetaFileBits(Size,(unsigned char *)Data));
+}
+
+wxMetafileControl::~wxMetafileControl()
+{
+}
+
+void wxMetafileControl::OnEditCopy(wxCommandEvent &)
+{
+    if (wxTheClipboard->Open())
+    {
+        wxTheClipboard->Clear();
+        m_metafile.SetClipboard(1,1);
+        wxTheClipboard->Close();
+    }
+}
+
+void wxMetafileControl::Paint(wxDC &dc,bool,wxSize &size)
+{
+    wxRect rct(wxPoint(0,0),size);
+    if (m_metafile.Ok())
+        m_metafile.Play(&dc,&rct);
+}
+
+wxSize wxMetafileControl::GetOriginalSize()
+{
+    return wxSize(m_metafile.GetWidth(),m_metafile.GetHeight());
+}
+
+float wxMetafileControl::GetRatio()
+{
+    if (m_metafile.GetHeight())
+        return float(m_metafile.GetWidth())/m_metafile.GetHeight();
+    else
+        return 0;
+}
+
+long wxGetEnhMetaFileBits(HENHMETAFILE metafile,UINT size,LPBYTE data)
+{
+#ifdef __BORLANDC__
+    return ::GetEnhMetaFileBits(metafile,size,(unsigned char *)data);
+#else // some MinGW versions do not have GetEnhMetaFileBits in the headers
+    HINSTANCE gdi = ::LoadLibrary(wxT("GDI32.DLL"));
+    UINT (WINAPI *metab)(HENHMETAFILE,UINT,LPBYTE) = 0;
+    long ret = 0;
+    if (gdi)
+        metab = (UINT (WINAPI *)(HENHMETAFILE,UINT,LPBYTE))
+                ::GetProcAddress(gdi,"GetEnhMetaFileBits");
+    if (metab)
+        ret = metab(metafile,size,(unsigned char *)data);
+    if (gdi)
+        ::FreeLibrary(gdi);
+    return ret;
+#endif
+}
+
+long wxMetafileControl::GetPictureSize()
+{
+    return wxGetEnhMetaFileBits((HENHMETAFILE)m_metafile.GetHENHMETAFILE(),0,0);
+}
+
+long wxMetafileControl::GetPictureData(char *data,long n)
+{
+    return wxGetEnhMetaFileBits((HENHMETAFILE)m_metafile.GetHENHMETAFILE(),
+                                n,(unsigned char *)data);
+}
+
+BEGIN_EVENT_TABLE(wxMetafileControl,wxPictureControl)
+    EVT_MENU(wxID_CUT, wxMetafileControl::OnEditCut)
+    EVT_MENU(wxID_COPY, wxMetafileControl::OnEditCopy)
+END_EVENT_TABLE()
+
+#endif // __WXMSW__
+
+// ----------------------------------------------------------------------------
+// wxBitmapControl
+// ----------------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(wxBitmapControl, wxPictureControl)
+
+wxBitmapControl::wxBitmapControl(wxWindow *AParent, int AnId,
+                                 const wxBitmap &bitmap,
+                                 const wxPoint &pos,const wxSize &size,
+                                 long style,const wxString &name)
+ : wxPictureControl(AParent,AnId,pos,size,style,name)
+{
+    m_bitmap = new wxBitmap(bitmap);
+}
+
+#ifdef __WXMSW__
+
+static size_t wxGetNumOfBitmapColors(size_t bitsPerPixel)
+{
+    switch ( bitsPerPixel )
+    {
+        case 1:
+            // monochrome bitmap, 2 entries
+            return 2;
+
+        case 4:
+            return 16;
+
+        case 8:
+            return 256;
+
+        case 24:
+            // may be used with 24bit bitmaps, but we don't use it here - fall
+            // through
+
+        case 16:
+        case 32:
+            // bmiColors not used at all with these bitmaps
+            return 0;
+
+        default:
+            wxFAIL_MSG( wxT("unknown bitmap format") );
+            return 0;
+    }
+}
+
+wxBitmapControl::wxBitmapControl(wxWindow *AParent, int AnId,char *Data,
+                                 int /*Size*/,const wxPoint &pos,
+                                 const wxSize &size,
+                                 long style,const wxString &name)
+ : wxPictureControl(AParent,AnId,pos,size,style,name)
+{
+    const LPBITMAPINFO pbmi = (const LPBITMAPINFO)Data;
+    const BITMAPINFOHEADER *pbmih = &pbmi->bmiHeader;
+
+    // biClrUsed has the number of colors, unless it's 0
+    int numColors = pbmih->biClrUsed;
+    if (numColors==0)
+    {
+        numColors = wxGetNumOfBitmapColors(pbmih->biBitCount);
+    }
+
+    // offset of image from the beginning of the header
+    DWORD ofs = numColors * sizeof(RGBQUAD);
+    void *image = (char *)pbmih + sizeof(BITMAPINFOHEADER) + ofs;
+
+    ScreenHDC hdc;
+    HBITMAP hbmp = CreateDIBitmap(hdc, pbmih, CBM_INIT,
+                                  image, pbmi, DIB_RGB_COLORS);
+    if ( !hbmp )
+    {
+        wxLogLastError(wxT("CreateDIBitmap"));
+    }
+
+    wxBitmap bitmap(pbmih->biWidth, pbmih->biHeight, pbmih->biBitCount);
+    bitmap.SetHBITMAP((WXHBITMAP)hbmp);
+
+    m_bitmap = new wxBitmap(bitmap);
+}
+
+#endif
+
+wxBitmapControl::~wxBitmapControl()
+{
+    delete m_bitmap;
+}
+
+void wxBitmapControl::Paint(wxDC &dc,bool,wxSize &size)
+{
+    if (m_bitmap)
+    {
+        wxImage img = m_bitmap->ConvertToImage();
+        img.Rescale(size.x,size.y);
+        wxBitmap bmp(img);
+        dc.DrawBitmap(bmp,0,0);
+    }
+}
+
+void wxBitmapControl::OnEditCopy(wxCommandEvent &)
+{
+    if (wxTheClipboard->Open())
+    {
+        wxTheClipboard->Clear();
+        wxBitmapDataObject *bdo = new wxBitmapDataObject;
+        wxBitmap *ClBitmap = new wxBitmap(*m_bitmap);
+        bdo->SetBitmap(*ClBitmap);
+        wxTheClipboard->SetData(bdo);
+        wxTheClipboard->Close();
+    }
+}
+
+#ifdef __WXMSW__
+
+size_t wxConvertBitmapToDIB(LPBITMAPINFO pbi, const wxBitmap& bitmap)
+{
+    wxASSERT_MSG( bitmap.Ok(), wxT("invalid bmp can't be converted to DIB") );
+
+    // shouldn't be selected into a DC or GetDIBits() would fail
+    wxASSERT_MSG( !bitmap.GetSelectedInto(),
+                  wxT("can't copy bitmap selected into wxMemoryDC") );
+
+    // prepare all the info we need
+    BITMAP bm;
+    HBITMAP hbmp = (HBITMAP)bitmap.GetHBITMAP();
+    if ( !GetObject(hbmp, sizeof(bm), &bm) )
+    {
+        wxLogLastError(wxT("GetObject(bitmap)"));
+
+        return 0;
+    }
+
+    // calculate the number of bits per pixel and the number of items in
+    // bmiColors array (whose meaning depends on the bitmap format)
+    WORD biBits = bm.bmPlanes * bm.bmBitsPixel;
+    WORD biColors = (WORD)wxGetNumOfBitmapColors(biBits);
+
+    BITMAPINFO bi2;
+
+    bool wantSizeOnly = pbi == NULL;
+    if ( wantSizeOnly )
+        pbi = &bi2;
+
+    // just for convenience
+    BITMAPINFOHEADER& bi = pbi->bmiHeader;
+
+    bi.biSize = sizeof(BITMAPINFOHEADER);
+    bi.biWidth = bm.bmWidth;
+    bi.biHeight = bm.bmHeight;
+    bi.biPlanes = 1;
+    bi.biBitCount = biBits;
+    bi.biCompression = BI_RGB;
+    bi.biSizeImage = 0;
+    bi.biXPelsPerMeter = 0;
+    bi.biYPelsPerMeter = 0;
+    bi.biClrUsed = 0;
+    bi.biClrImportant = 0;
+
+    // memory we need for BITMAPINFO only
+    DWORD dwLen = bi.biSize + biColors * sizeof(RGBQUAD);
+
+    // first get the image size
+    ScreenHDC hdc;
+    if ( !GetDIBits(hdc, hbmp, 0, bi.biHeight, NULL, pbi, DIB_RGB_COLORS) )
+    {
+        wxLogLastError(wxT("GetDIBits(NULL)"));
+
+        return 0;
+    }
+
+    if ( wantSizeOnly )
+    {
+        // size of the header + size of the image
+        return dwLen + bi.biSizeImage;
+    }
+
+    // and now copy the bits
+    void *image = (char *)pbi + dwLen;
+    if ( !GetDIBits(hdc, hbmp, 0, bi.biHeight, image, pbi, DIB_RGB_COLORS) )
+    {
+        wxLogLastError(wxT("GetDIBits"));
+
+        return 0;
+    }
+
+    return dwLen + bi.biSizeImage;
+}
+
+long wxBitmapControl::GetPictureData(char *data,long /*n*/)
+{
+    wxConvertBitmapToDIB((LPBITMAPINFO)data,*m_bitmap);
+    return GetPictureSize();
+}
+
+long wxBitmapControl::GetPictureSize()
+{
+    return wxConvertBitmapToDIB(0,*m_bitmap);
+}
+
+#endif
+
+wxSize wxBitmapControl::GetOriginalSize()
+{
+    return wxSize(m_bitmap->GetWidth(),m_bitmap->GetHeight());
+}
+
+float wxBitmapControl::GetRatio()
+{
+    if (m_bitmap->GetHeight())
+        return float(m_bitmap->GetWidth())/m_bitmap->GetHeight();
+    else
+        return 0;
+}
+
+BEGIN_EVENT_TABLE(wxBitmapControl,wxPictureControl)
+    EVT_MENU(wxID_CUT, wxBitmapControl::OnEditCut)
+    EVT_MENU(wxID_COPY, wxBitmapControl::OnEditCopy)
+END_EVENT_TABLE()
+
+// ----------------------------------------------------------------------------
+// wxResizeableControlCanvas
+// ----------------------------------------------------------------------------
+
+void wxResizeableControlCanvas::UpdateScrollRange()
+{
+    wxWindowListNode *Child = GetChildren().GetFirst();
+    wxSize GesSize;
+    while (Child)
+    {
+        wxWindow *chw = wxDynamicCast(Child->GetData(),wxResizeableControl);
+        if (chw)
+        {
+            wxRect rect = chw->GetRect();
+            rect.x += GetScrollPos(wxHORIZONTAL);
+            rect.y += GetScrollPos(wxVERTICAL);
+            if (rect.GetBottom() > GesSize.y)
+                GesSize.y = rect.GetBottom();
+            if (rect.GetRight() > GesSize.x)
+                GesSize.x = rect.GetRight();
+        }
+        Child = Child->GetNext();
+    }
+    SetScrollbars(1,1,GesSize.x,GesSize.y,
+                  GetScrollPos(wxHORIZONTAL),GetScrollPos(wxVERTICAL),true);
+}
+
+BEGIN_EVENT_TABLE(wxResizeableControlCanvas,wxScrolledWindow)
+    EVT_CHILD_CREATED(-1, wxResizeableControlCanvas::OnChildWindowChange)
+    EVT_CHILD_MOVED(-1, wxResizeableControlCanvas::OnChildWindowChange)
+    EVT_CHILD_RESIZED(-1, wxResizeableControlCanvas::OnChildWindowChange)
+    EVT_CHILD_CLOSED(-1, wxResizeableControlCanvas::OnChildWindowChange)
+END_EVENT_TABLE()
+
+

 	  	 
