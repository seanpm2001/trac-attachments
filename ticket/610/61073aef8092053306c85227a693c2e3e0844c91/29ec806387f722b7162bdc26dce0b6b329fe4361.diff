
Index: include/wx/mimetype.h
===================================================================
RCS file: /home/wxcvs/wxWindows/include/wx/mimetype.h,v
retrieving revision 1.17
diff -w -r1.17 mimetype.h
34a35,44
> 
> // these define constants for UNIX managers
> // pass them in in initialize
> #define wxWMNETSCAPE  1
> #define wxWMBASE      2
> #define wxWMKDE       4
> #define wxWMGNOME     8
> //define next as  16;
> 
> 
77a88,93
>     // code works for either
> 	// mimetype, openCmd, printCmd, desc, ext1, ext2, ext3 ...
> 	// mimetype, openCmd, printCmd, desc, ext1 ext2 ext3 ...
>     wxFileTypeInfo(const wxArrayString& sArray) ;
>     
>     
107a124
>     int GetExtensionsCount() const {return m_exts.GetCount(); }
124a142
> 
212a231,238
>     // set an arbitrary command, ask confirmation if it already exists and
>     // overwriteprompt is TRUE
>     bool SetCommand(const wxString& cmd, const wxString& verb,
>         bool overwriteprompt = TRUE);
> 
>     bool SetDefaultIcon(const wxString& cmd = wxEmptyString, int index = 0);
> 
> 
266a293,301
>     // an Initilaise function for Unix only
>     // this loads data from standard files according to the 
>     // manager system specified. 
>     // wxWMBASE, wxKDE or wxGNOME are other possibilities
>     // use the sExtraDir parameter if you want to look for files in another directory
>     void Initialize(int wxWM = wxWMNETSCAPE, const wxString & sExtraDir = wxEmptyString) ;
>     // and this function clears all the data from the manager    
>     void ClearData () ;
>     
285a321,322
> 
>     // These ought to be private ??
289a327
> 
308a347
>         // if the other fields are empty, the existing values should be left alone
312c351
<     bool Unassociate(wxFileType *ft) { return ft->Unassociate(); }
---
>     bool Unassociate(wxFileType *ft) ;
331a371,373
> 
> 
> 
345,346d386
< 
< /* vi: set cin tw=80 ts=4 sw=4: */
cvs server: Diffing include/wx/generic
cvs server: Diffing include/wx/gtk
cvs server: Diffing include/wx/html
cvs server: Diffing include/wx/html/msw
cvs server: Diffing include/wx/mac
cvs server: Diffing include/wx/motif
cvs server: Diffing include/wx/msw
Index: include/wx/msw/mimetype.h
===================================================================
RCS file: /home/wxcvs/wxWindows/include/wx/msw/mimetype.h,v
retrieving revision 1.4
diff -w -r1.4 mimetype.h
56,59c56,57
< 
<     // these methods are not publicly accessible (as wxMimeTypesManager
<     // doesn't know about them), and generally not very useful - they could be
<     // removed in the (near) future
---
>     // set an arbitrary command, ask confirmation if it already exists and
>     // overwriteprompt is TRUE
61,62c59,60
<                     bool overwriteprompt = true);
<     bool SetMimeType(const wxString& mimeType);
---
>         bool overwriteprompt = TRUE) ;
> 
65,68c63,64
<     bool RemoveOpenCommand();
<     bool RemoveCommand(const wxString& verb);
<     bool RemoveMimeType();
<     bool RemoveDefaultIcon();
---
>     // this is called  by Associate
>     bool SetDescription (const wxString& desc) ;
83a80,91
> 
>     // these methods are not publicly accessible (as wxMimeTypesManager
>     // doesn't know about them), and should only be called by Unassociate
> 
>     bool RemoveOpenCommand();
>     bool RemoveCommand(const wxString& verb);
>     bool RemoveMimeType();
>     bool RemoveDefaultIcon();
>     bool RemoveDescription();
> 
> 
> 
Index: include/wx/unix/mimetype.h
===================================================================
RCS file: /home/wxcvs/wxWindows/include/wx/unix/mimetype.h,v
retrieving revision 1.4
diff -w -r1.4 mimetype.h
24,28c24,30
< class MailCapEntry;
< class wxMimeTypeIconHandler;
< 
< WX_DEFINE_ARRAY(wxMimeTypeIconHandler *, ArrayIconHandlers);
< WX_DEFINE_ARRAY(MailCapEntry *, ArrayTypeEntries);
---
> //class MailCapEntry;
> //class wxMimeTypeIconHandler;
> class wxMimeArrayString  ;
> 
> //WX_DEFINE_ARRAY(wxMimeTypeIconHandler *, ArrayIconHandlers);
> //WX_DEFINE_ARRAY(MailCapEntry *, ArrayTypeEntries);
> WX_DEFINE_ARRAY(wxMimeArrayString *, ArrayTypeEntries);
39c41,43
<     void Initialize();
---
>     void Initialize(int wxWM = wxWMNETSCAPE, const wxString & sExtraDir = wxEmptyString);  // wxBASE, wxKDE or wxGNOME are other possibilities
>     // and delete the data here 
>     void ClearData () ;
63a68,69
>     // remove association
>     bool Unassociate(wxFileType *ft) ;											   
70,72d75
<         // get the array of icon handlers
<     static ArrayIconHandlers& GetIconHandlers();
< 
85,86c88,92
<                   m_aExtensions;    // space separated list of extensions
<     ArrayTypeEntries m_aEntries;    // commands and tests for this file type
---
>                   m_aExtensions,     // space separated list of extensions
>                   m_aIcons ;        // Icon filenames
>     //verb=command pairs for this file type
>     ArrayTypeEntries m_aEntries;    
> 
89a96,97
>     // keep track of the window managers wxWMBASE, wxKDE etc
>     int m_win_managers ;
92c100,153
<     static ArrayIconHandlers ms_iconHandlers;
---
> //    static ArrayIconHandlers ms_iconHandlers;
> 
>     wxString GetCommand(const wxString & verb, size_t nIndex) const ;
> 
>    	//read Gnome files
> 	void LoadGnomeDataFromKeyFile(const wxString& filename);
> 	void LoadGnomeMimeTypesFromMimeFile(const wxString& filename);
> 	void LoadGnomeMimeFilesFromDir(const wxString& dirbase);
> 	void GetGnomeMimeInfo(const wxString& sExtraDir) ;
> 
> 	//write gnome files
> 	bool CheckGnomeDirsExist ();
>     bool WriteGnomeKeyFile(int index, bool delete_index);
>     bool WriteGnomeMimeFile(int index, bool delete_index);
> 	
> 	//read KDE
> 	void LoadKDELinksForMimeSubtype(const wxString& dirbase,
>                                                const wxString& subdir,
>                                                const wxString& filename,
>                                                const wxArrayString& icondirs);
> 	void LoadKDELinksForMimeType(const wxString& dirbase,
>                                             const wxString& subdir,
>                                             const wxArrayString& icondirs) ;
> 	void LoadKDELinkFilesFromDir(const wxString& dirbase,
>                                             const wxArrayString& icondirs) ;
> 	void GetKDEMimeInfo(const wxString& sExtraDir) ;
> 
> 	//write KDE
> 	bool WriteKDEMimeFile(int index, bool delete_index);
> 	bool CheckKDEDirsExist ( const wxString & sOK, const wxString & sTest ) ;
> 	
> 	//read write Netscape and MetaMail formats
> 	void GetMimeInfo (const wxString& sExtraDir);	
> 	bool WriteToMailCap (int index, bool delete_index);
> 	bool WriteToMimeTypes (int index, bool delete_index);
> 	bool WriteToNSMimeTypes (int index, bool delete_index);
> 	
> 	//functions used to do associations
> 
>     int AddToMimeData(const wxString & strType,
>     	const  wxString & strIcon,
>     	wxMimeArrayString * entry,
>     	const  wxArrayString & strExtensions,
>     	const  wxString & strDesc,
>     	bool   ReplaceExisting = TRUE ) ;
> 	
>     bool DoAssociation(const wxString & strType,
>                        const  wxString & strIcon,
>                        wxMimeArrayString * entry,
>                        const  wxArrayString & strExtensions,
>                        const  wxString & strDesc ) ;
> 
>     bool WriteMimeInfo(int nIndex, bool delete_mime ) ;
> 										
103a165,170
>     // this is used to construct a list of mimetypes which match;
>     // if built with GetFileTypeFromMimetype index 0 has the exact match and
>     // index 1 the type / * match
>     // if built with GetFileTypeFromExtension, index 0 has the mimetype for
>     // the first extension found, index 1 for the second and so on
> 
112c179,181
<     bool GetIcon(wxIcon *icon) const;
---
>     bool GetIcon(wxIcon *icon, wxString *iconFile = NULL,
>                  int *iconIndex = NULL) const;
> 
119c188,189
<         return GetExpandedCommand(openCmd, params, TRUE);
---
>         *openCmd = GetExpandedCommand(wxT("open"), params);
>         return (! openCmd -> IsEmpty() );
125c195,196
<         return GetExpandedCommand(printCmd, params, FALSE);
---
>         *printCmd = GetExpandedCommand(wxT("print"), params);
>         return (! printCmd -> IsEmpty() );
127a199,203
>         // return the number of commands defined for this file type, 0 if none
>     size_t GetAllCommands(wxArrayString *verbs, wxArrayString *commands,
>                           const wxFileType::MessageParameters& params) const;
> 
> 
129c205,216
<     bool Unassociate();
---
>     // probably a mistake to come here, use wxMimeTypesManager.Unassociate (ft) instead
>     bool Unassociate(wxFileType * ft)
>         {
>         return m_manager -> Unassociate(ft) ;
>         }
>     
>     
>     // set an arbitrary command, ask confirmation if it already exists and
>     // overwriteprompt is TRUE
>     bool SetCommand(const wxString& cmd, const wxString& verb, bool overwriteprompt = TRUE) ;
>     bool SetDefaultIcon(const wxString& strIcon = wxEmptyString, int index = 0) ;
>  
133c220
<     MailCapEntry *GetEntry(const wxFileType::MessageParameters& params) const;
---
> //    MailCapEntry *GetEntry(const wxFileType::MessageParameters& params) const;
136,138c223,228
<     bool GetExpandedCommand(wxString *expandedCmd,
<                             const wxFileType::MessageParameters& params,
<                             bool open) const;
---
> //    wxString wxFileTypeImpl::GetCommand(const wxString verb) ;
> //    bool GetExpandedCommand(wxString *expandedCmd,
> //                            const wxFileType::MessageParameters& params,
> //                            bool open) const;
>     wxString GetExpandedCommand(const wxString & verb, 
>               const wxFileType::MessageParameters& params) const ;

Index: src/common/mimecmn.cpp
===================================================================
RCS file: /home/wxcvs/wxWindows/src/common/mimecmn.cpp,v
retrieving revision 1.11
diff -w -r1.11 mimecmn.cpp
8c8
< // RCS-ID:      $Id: mimecmn.cpp,v 1.11 2001/04/01 20:42:03 GD Exp $
---
> // RCS-ID:      $Id: mimecmn.cpp,v 1.10 2001/01/31 14:50:02 georgetasker Exp $
101a102,115
> 
> wxFileTypeInfo::wxFileTypeInfo(const wxArrayString& sArray)
> {
>     m_mimeType = sArray [0u];
>     m_openCmd  = sArray [1u];
>     m_printCmd = sArray [2u];
>     m_desc     = sArray [3u];
>     size_t i ;
>     for ( i = 4; i < sArray.GetCount(); i ++)
>         {
>             m_exts.Add(sArray[i]);
>         }
> }
> 
184a199,200
>     
>     // test now carried out on reading file so test should never get here
274c290
< #ifdef __WXMSW__
---
> #if defined(__WXMSW__) || defined(__UNIX__)
337c353
< #ifdef __WXMSW__
---
> #if defined (__WXMSW__)  || (__UNIX__)
339c355
< #else // !__WXMSW__
---
> #else // !__WXMSW__ || Unix
364c380
< #endif // __WXMSW__/!__WXMSW__
---
> #endif // __WXMSW__/| __UNIX__
369c385
< #if defined(__WXMSW__) || defined(__UNIX__)
---
> #if defined(__WXMSW__)
371c387,392
< #else
---
> #endif
> 
> #if defined(__UNIX__)
>     return m_impl->Unassociate(this);
> #endif
> 
373a395,426
> 
> }
> 
> bool wxFileType::SetCommand(const wxString& cmd, const wxString& verb,
> bool overwriteprompt)
> {
> #if defined (__WXMSW__)  || (__UNIX__)
>     return m_impl->SetCommand(cmd, verb, overwriteprompt);
> #else
>     wxFAIL_MSG(_T("not implemented"));
> 
>     return FALSE;
> #endif
> }
> 
> bool wxFileType::SetDefaultIcon(const wxString& cmd, int index)
> {
>     wxString sTmp = cmd;
> #ifdef __WXMSW__
>     // VZ: should we do this?
>     // chris elliott : only makes sense in MS windows
>     if ( sTmp.empty() )
>         GetOpenCommand(&sTmp, wxFileType::MessageParameters("", ""));
> #endif
>     wxCHECK_MSG( !sTmp.empty(), FALSE, _T("need the icon file") );
> 
> #if defined (__WXMSW__) || (__UNIX__)
>     return m_impl->SetDefaultIcon (cmd, index);
> #else
>     wxFAIL_MSG(_T("not implemented"));
> 
>     return FALSE;
376a430
> 
420a475,484
> bool wxMimeTypesManager::Unassociate(wxFileType *ft) 
> {
> #if defined(__UNIX__)
>     return m_impl->Unassociate(ft);
> #else
>     return ft->Unassociate();
> #endif
> }
> 
> 
519a584,606
> // an Initilaise function for Unix only
> // wxBASE, wxKDE or wxGNOME are other possibilities
> void wxMimeTypesManager::Initialize(int wxWM /*= wxWMNETSCAPE*/, const wxString & sExtraDir /*= wxEmptyString*/)
>     {
>     #ifndef __UNIX__
>     return;
>     #else
>     EnsureImpl();
>     return m_impl -> Initialize ( wxWM, sExtraDir );
>     #endif
>     }
> // and this function clears all the data from the manager    
> void wxMimeTypesManager::ClearData () 
>     {
>     #ifndef __UNIX__
>     return;
>     #else
>     EnsureImpl();
>     return m_impl -> ClearData ()  ;
>     #endif
>     }
>     
> 
549d635
< 

Index: src/msw/mimetype.cpp
===================================================================
RCS file: /home/wxcvs/wxWindows/src/msw/mimetype.cpp,v
retrieving revision 1.11
diff -w -r1.11 mimetype.cpp
455a456
> /*
467c468
< 
---
> */
518c519,524
<     const wxString& ext = ftInfo.GetExtensions()[0u];
---
>     bool ok = FALSE ;
>     int iExtCount = 0 ;
>     wxString filetype;
>     wxString extWithDot;
> 
>     wxString ext = ftInfo.GetExtensions()[iExtCount];
523d528
<     wxString extWithDot;
527a533,536
>     // start by setting the HKCR\\.ext entries
>     // default is filetype; content type is mimetype
>     const wxString& filetypeOrig = ftInfo.GetShortDesc();
> 
529d537
<     wxFileType *ft = NULL;
532,533d539
<         wxString filetype;
< 
535c541
<         bool ok = key.Create();
---
>         ok = key.Create();
538c544
<             const wxString& filetypeOrig = ftInfo.GetShortDesc();
---
> 
542c548
<                 filetype << extWithDot.c_str() + 1 << _T("_auto_file");
---
>                 filetype << extWithDot.c_str() + 1 << _T("_file");
552c558,572
< 
---
>         }
>         else
>         {
>             // key already exists, maybe we want to change it ??
>             if (!filetypeOrig.empty())
>                 {
>                     filetype = filetypeOrig;
>                     ok = key.SetValue(_T(""), filetype);
>                 }
>             else
>                 {
>                     ok = key.QueryValue(_T(""), filetype);
>                 }
>         }
>         // now set a mimetypeif we have it, but ignore it if none
554c574
<         if ( ok && !mimetype.empty() )
---
>         if ( !mimetype.empty() )
574a595,615
> 
>     // now make other extensions have the same filetype
>     
>     for (iExtCount=1; iExtCount < ftInfo.GetExtensionsCount(); iExtCount++ )
>         {
>             ext = ftInfo.GetExtensions()[iExtCount];
>             if ( ext[0u] != _T('.') )
>                extWithDot = _T('.');
>             extWithDot += ext;
> 
>             wxRegKey key(wxRegKey::HKCR, extWithDot);
>             if ( !key.Exists() ) ok = key.Create();
>             ok = key.SetValue(_T(""), filetype);
> 
>         // now set any mimetypes we may have, but ignore it if none
>         const wxString& mimetype = ftInfo.GetMimeType();
>         if ( !mimetype.empty() )
>         {
>             // set the MIME type
>             ok = key.SetValue(_T("Content Type"), mimetype);
> 
577,581c618,622
<             // create the filetype key itself (it will be empty for now, but
<             // SetCommand(), SetDefaultIcon() &c will use it later)
<             wxRegKey keyFT(wxRegKey::HKCR, filetype);
<             ok = keyFT.Create();
<         }
---
>                 // create the MIME key
>                 wxString strKey = MIME_DATABASE_KEY;
>                 strKey << mimetype;
>                 wxRegKey keyMIME(wxRegKey::HKCR, strKey);
>                 ok = keyMIME.Create();
585,586c626,627
<             // ok, we've created everything correctly
<             ft = CreateFileType(filetype, extWithDot);
---
>                     // and provide a back link to the extension
>                     ok = keyMIME.SetValue(_T("Extension"), extWithDot);
588,591d628
<         else
<         {
<            // one of the registry operations failed
<             wxLogError(_("Failed to register extension '%s'."), ext.c_str());
594c631,643
<     else // key already exists
---
> 
> 
>     } // end of for loop; all extensions now point to HKCR\.ext\Default
> 
>     // create the filetype key itself (it will be empty for now, but
>     // SetCommand(), SetDefaultIcon() &c will use it later)
>     wxRegKey keyFT(wxRegKey::HKCR, filetype);
>     ok = keyFT.Create();
>     
>     wxFileType *ft = NULL; 
>     ft = CreateFileType(filetype, extWithDot);
> 
>     if (ft)
596,597c645,649
<         // FIXME we probably should return an existing file type then?
<     }
---
>             if (! ftInfo.GetOpenCommand ().IsEmpty() ) ft->SetCommand (ftInfo.GetOpenCommand (), wxT("open"  ) );
>             if (! ftInfo.GetPrintCommand().IsEmpty() ) ft->SetCommand (ftInfo.GetPrintCommand(), wxT("print" ) );
>             // chris: I don't like the ->m_impl-> here FIX this ??
>             if (! ftInfo.GetDescription ().IsEmpty() ) ft->m_impl->SetDescription (ftInfo.GetDescription ()) ;
>             if (! ftInfo.GetIconFile().IsEmpty() ) ft->SetDefaultIcon (ftInfo.GetIconFile(), ftInfo.GetIconIndex() );
598a651
>         }
613c666
< 
---
> #if 0
623,624c676,677
<                       "files with extension \"%s\" (current value is '%s', "
<                       "new value is '%s')?"),
---
>                       "files with extension \"%s\" ?\nCurrent value is \n%s, "
>                       "\nNew value is \n%s %1"), // bug here FIX need %1 ??
638c691
< 
---
> #endif
644a698
> /* // no longer used
668a723
> */
672,673c727,730
<     wxCHECK_MSG( !m_ext.IsEmpty(), FALSE, _T("SetMimeType() needs extension") );
<     wxCHECK_MSG( wxFileExists(cmd), FALSE, _T("Icon file not found.") );
---
>     wxCHECK_MSG( !m_ext.IsEmpty(), FALSE, _T("SetDefaultIcon() needs extension") );
>     wxCHECK_MSG( !m_strFileType.IsEmpty(), FALSE, _T("File key not found") );
> //    the next line fails on a SMBshare, I think because it is case mangled
> //    wxCHECK_MSG( !wxFileExists(cmd), FALSE, _T("Icon file not found.") );
684a742,755
> bool wxFileTypeImpl::SetDescription (const wxString& desc)
> {
>     wxCHECK_MSG( !m_strFileType.IsEmpty(), FALSE, _T("File key not found") );
>     wxCHECK_MSG( !desc.IsEmpty(), FALSE, _T("No file description supplied") );
> 
>     if ( !EnsureExtKeyExists() )
>         return FALSE;
> 
>     wxRegKey rkey(wxRegKey::HKCR, m_strFileType );
> 
>     return rkey.Create() &&
>            rkey.SetValue(_T(""), desc);
> }
> 
697a769,770
>    if ( !RemoveDescription() )
>         result = FALSE;
698a772,773
> /*
>     //this might hold other keys, eg some have CSLID keys
706c781
< 
---
> */
740a816,824
>     return !rkey.Exists() || rkey.DeleteSelf();
> }
> 
> bool wxFileTypeImpl::RemoveDescription()
> {
>     wxCHECK_MSG( !m_ext.IsEmpty(), FALSE,
>                  _T("RemoveDescription() needs extension") );
> 
>     wxRegKey rkey (wxRegKey::HKCR, m_strFileType );

cvs server: Diffing src/unix
Index: src/unix/mimetype.cpp
===================================================================
RCS file: /home/wxcvs/wxWindows/src/unix/mimetype.cpp,v
retrieving revision 1.14
diff -w -r1.14 mimetype.cpp
0a1
> 
11a13,30
> // known bugs; there may be others!! chris elliott, biol75@york.ac.uk 27 Mar 01
> 
> // 1) .mailcap and .mimetypes can be either in a netscape or metamail format
> //    and entries may get confused during writing (I've tried to fix this; please let me know
> //    any files that fail)
> // 2) KDE and Gnome do not yet fully support international read/write
> // 3) Gnome key lines like open.latex."LaTeX this file"=latex %f will have odd results
> // 4) writing to files comments out the existing data; I hope this avoids losing 
> //    any data which we could not read, and data which we did not store like test=
> // 5) results from reading files with multiple entries (especially matches with type/* )
> //    may (or may not) work for getXXX commands
> // 6) Loading the png icons in Gnome doesn't work for me...
> // 7) In Gnome, if keys.mime exists but keys.users does not, there is 
> //    an error message in debug mode, but the file is still written OK
> // 8) Deleting entries is only allowed from the user file; sytem wide entries 
> //    will be preserved during unassociate
> // 9) KDE does not yet handle multiple actions; Netscape mode n??ever will
> 
40a60
>     
61a82,213
> // this is a class to extend wxArrayString...
> class wxMimeArrayString : public wxArrayString
> {
>     public:
>     wxMimeArrayString ()
>     {  
>         wxArrayString () ;
>     }
> 
>     size_t pIndexOf (const wxString & verb)
>     {
>     size_t i = 0 ;
>     wxString sTmp = verb ; 
>     // avoid a problem with modifying const parameter
>     sTmp.MakeLower();
>     while ( (i < GetCount()) && (! Item(i).MakeLower().Contains(sTmp)) )
>         {        
>         i++ ;
>         }
>     if ( i==GetCount() ) i = (size_t)wxNOT_FOUND ;    
>     return i ;
>     }
> 
>     bool ReplaceOrAddLineCmd (const wxString verb, const wxString & cmd)
>     {
>     size_t nIndex = pIndexOf (verb);
>     if (nIndex == (size_t)wxNOT_FOUND) 
>         Add(verb + wxT("=") + cmd);
>     else 
>         Item(nIndex) = verb + wxT("=") + cmd ;
>     return TRUE ;
>     }
> 
>     wxString GetVerb (size_t i)
>     {
>     if (i < 0) return wxEmptyString ;
>     if (i > GetCount() ) return wxEmptyString ;
>     wxString sTmp = Item(i).BeforeFirst(wxT('=')) ;
>     return sTmp ;
>     }
> 
>     wxString GetCmd (size_t i)
>     {
>     if (i < 0) return wxEmptyString ;
>     if (i > GetCount() ) return wxEmptyString ;
>     wxString sTmp = Item(i).AfterFirst(wxT('=')) ;
>     return sTmp ;
>     }
>     
> } ;
> 
> //this class extends wxTextFile
> class wxMimeTextFile : public wxTextFile
> {
>   
>     public:
>     // constructors
>     wxMimeTextFile () : wxTextFile () {} ;
>     wxMimeTextFile (const wxString& strFile) : wxTextFile (strFile)  {  };
> 
>      
>     int pIndexOf(const wxString & sSearch, bool bIncludeComments = FALSE, int iStart = 0)
>     {
>     size_t i = iStart ;
>     int nResult = wxNOT_FOUND ;
>     if (i>=GetLineCount()) return wxNOT_FOUND;
>     
>     wxString sTest = sSearch ;
>     sTest.MakeLower();
>     wxString sLine ;
>     
>     if (bIncludeComments)
>         {
>         while ( (i < GetLineCount())   )
>            {
>            sLine = GetLine (i) ;
>            sLine.MakeLower() ;
>            if (sLine.Contains(sTest)) nResult = (int) i;
>            i++ ;
>            } 
>         }
>     else
>         {      
>         while ( (i < GetLineCount())   )
>            {
>            sLine = GetLine (i) ;
>            sLine.MakeLower() ;
>            if ( ! sLine.StartsWith(wxT("#")))
>                {
>                if (sLine.Contains(sTest)) nResult = (int) i;
>                }
>            i++ ;
>            } 
>        }  
>     return  nResult ;
>     } 
>     
>     bool CommentLine(int nIndex)
>     {
>     if (nIndex <0) return FALSE;
>     if (nIndex >= (int)GetLineCount() ) return FALSE;
>     GetLine(nIndex) = GetLine(nIndex).Prepend(wxT("#")) ;
>     return TRUE;
>     }
> 
>     bool CommentLine(const wxString & sTest)
>     {
>     int nIndex = pIndexOf(sTest) ;
>     if (nIndex <0) return FALSE;
>     if (nIndex >= (int)GetLineCount() ) return FALSE;
>     GetLine(nIndex) = GetLine(nIndex).Prepend(wxT("#")) ;
>     return TRUE;
>     }
> 
>     wxString GetVerb (size_t i)
>     {
>     if (i < 0) return wxEmptyString ;
>     if (i > GetLineCount() ) return wxEmptyString ;
>     wxString sTmp = GetLine(i).BeforeFirst(wxT('=')) ;
>     return sTmp ;
>     }
> 
>     wxString GetCmd (size_t i)
>     {
>     if (i < 0) return wxEmptyString ;
>     if (i > GetLineCount() ) return wxEmptyString ;
>     wxString sTmp = GetLine(i).AfterFirst(wxT('=')) ;
>     return sTmp ;
>     }
> 
> } ;
> 
84a237,238
> 
> 
157,310d310
< class MailCapEntry
< {
< public:
<     // ctor
<     MailCapEntry(const wxString& openCmd,
<                  const wxString& printCmd,
<                  const wxString& testCmd)
<         : m_openCmd(openCmd), m_printCmd(printCmd), m_testCmd(testCmd)
<     {
<         m_next = NULL;
<     }
<     
<     ~MailCapEntry()
<     {
<         if (m_next) delete m_next;
<     }
< 
<     // accessors
<     const wxString& GetOpenCmd()  const { return m_openCmd;  }
<     const wxString& GetPrintCmd() const { return m_printCmd; }
<     const wxString& GetTestCmd()  const { return m_testCmd;  }
< 
<     MailCapEntry *GetNext() const { return m_next; }
< 
<     // operations
<         // prepend this element to the list
<     void Prepend(MailCapEntry *next) { m_next = next; }
<         // insert into the list at given position
<     void Insert(MailCapEntry *next, size_t pos)
<     {
<         // FIXME slooow...
<         MailCapEntry *cur;
<         size_t n = 0;
<         for ( cur = next; cur != NULL; cur = cur->m_next, n++ ) {
<             if ( n == pos )
<                 break;
<         }
< 
<         wxASSERT_MSG( n == pos, wxT("invalid position in MailCapEntry::Insert") );
< 
<         m_next = cur->m_next;
<         cur->m_next = this;
<     }
<         // append this element to the list
<     void Append(MailCapEntry *next)
<     {
<         wxCHECK_RET( next != NULL, wxT("Append()ing to what?") );
< 
<         // FIXME slooow...
<         MailCapEntry *cur;
<         for ( cur = next; cur->m_next != NULL; cur = cur->m_next )
<             ;
< 
<         cur->m_next = this;
< 
<         wxASSERT_MSG( !m_next, wxT("Append()ing element already in the list?") );
<     }
< 
< private:
<     wxString m_openCmd,         // command to use to open/view the file
<              m_printCmd,        //                     print
<              m_testCmd;         // only apply this entry if test yields
<                                 // true (i.e. the command returns 0)
< 
<     MailCapEntry *m_next;       // in the linked list
< };
< 
< 
< // the base class which may be used to find an icon for the MIME type
< class wxMimeTypeIconHandler
< {
< public:
<     virtual bool GetIcon(const wxString& mimetype, wxIcon *icon) = 0;
< 
<     // this function fills manager with MIME types information gathered
<     // (as side effect) when searching for icons. This may be particularly
<     // useful if mime.types is incomplete (e.g. RedHat distributions).
<     virtual void GetMimeInfoRecords(wxMimeTypesManagerImpl *manager) = 0;
< };
< 
< 
< // the icon handler which uses GNOME MIME database
< class wxGNOMEIconHandler : public wxMimeTypeIconHandler
< {
< public:
<     virtual bool GetIcon(const wxString& mimetype, wxIcon *icon);
<     virtual void GetMimeInfoRecords(wxMimeTypesManagerImpl *manager);
< 
< private:
<     void Init();
<     void LoadIconsFromKeyFile(const wxString& filename);
<     void LoadKeyFilesFromDir(const wxString& dirbase);
< 
<     void LoadMimeTypesFromMimeFile(const wxString& filename, wxMimeTypesManagerImpl *manager);
<     void LoadMimeFilesFromDir(const wxString& dirbase, wxMimeTypesManagerImpl *manager);
< 
<     static bool m_inited;
< 
<     static wxSortedArrayString ms_mimetypes;
<     static wxArrayString       ms_icons;
< };
< 
< // the icon handler which uses KDE MIME database
< class wxKDEIconHandler : public wxMimeTypeIconHandler
< {
< public:
<     virtual bool GetIcon(const wxString& mimetype, wxIcon *icon);
<     virtual void GetMimeInfoRecords(wxMimeTypesManagerImpl *manager);
< 
< private:
<     void LoadLinksForMimeSubtype(const wxString& dirbase,
<                                  const wxString& subdir,
<                                  const wxString& filename,
<                                  const wxArrayString& icondirs);
<     void LoadLinksForMimeType(const wxString& dirbase,
<                               const wxString& subdir,
<                               const wxArrayString& icondirs);
<     void LoadLinkFilesFromDir(const wxString& dirbase,
<                               const wxArrayString& icondirs);
<     void Init();
< 
<     static bool m_inited;
< 
<     static wxSortedArrayString ms_mimetypes;
<     static wxArrayString       ms_icons;
< 
<     static wxArrayString       ms_infoTypes;
<     static wxArrayString       ms_infoDescriptions;
<     static wxArrayString       ms_infoExtensions;
< };
< 
< 
< 
< // ----------------------------------------------------------------------------
< // various statics
< // ----------------------------------------------------------------------------
< 
< static wxGNOMEIconHandler gs_iconHandlerGNOME;
< static wxKDEIconHandler gs_iconHandlerKDE;
< 
< bool wxGNOMEIconHandler::m_inited = FALSE;
< wxSortedArrayString wxGNOMEIconHandler::ms_mimetypes;
< wxArrayString       wxGNOMEIconHandler::ms_icons;
< 
< bool wxKDEIconHandler::m_inited = FALSE;
< wxSortedArrayString wxKDEIconHandler::ms_mimetypes;
< wxArrayString       wxKDEIconHandler::ms_icons;
< 
< wxArrayString       wxKDEIconHandler::ms_infoTypes;
< wxArrayString       wxKDEIconHandler::ms_infoDescriptions;
< wxArrayString       wxKDEIconHandler::ms_infoExtensions;
< 
< 
< ArrayIconHandlers wxMimeTypesManagerImpl::ms_iconHandlers;
313c313
< // wxGNOMEIconHandler
---
> // wxGNOME
332,339d331
< void wxGNOMEIconHandler::LoadIconsFromKeyFile(const wxString& filename)
< {
<     wxTextFile textfile(filename);
<     if ( !textfile.Open() )
<         return;
< 
<     // values for the entry being parsed
<     wxString curMimeType, curIconFile;
341,343c333
<     const wxChar *pc;
<     size_t nLineCount = textfile.GetLineCount();
<     for ( size_t nLine = 0; ; nLine++ )
---
> bool wxMimeTypesManagerImpl::CheckGnomeDirsExist ()
345c335,339
<         if ( nLine < nLineCount )
---
>     wxString gnomedir;
>     wxGetHomeDir( &gnomedir );
>     wxString sTmp = gnomedir ;
>     sTmp = sTmp + "/.gnome"  ;
>     if (! wxDir::Exists ( sTmp ) )
347,348c341
<             pc = textfile[nLine].c_str();
<             if ( *pc == _T('#') )
---
>         if (!wxMkdir ( sTmp ))
350,351c343,344
<                 // skip comments
<                 continue;
---
>             wxFAIL_MSG (wxString ("Failed to create directory\n.gnome in \nCheckGnomeDirsExist") + sTmp );
>             return FALSE ;
354c347,348
<         else
---
>     sTmp = sTmp + "/mime-info" ;
>     if (! wxDir::Exists ( sTmp ) )
356,357c350,353
<             // so that we will fall into the "if" below
<             pc = NULL;
---
>         if (!wxMkdir ( sTmp ))
>         {
>             wxFAIL_MSG (wxString ("Failed to create directory\nmime-info in \nCheckGnomeDirsExist") + sTmp );
>             return FALSE ;
358a355,356
>     }
>     return TRUE ;
360,367c358,362
<         if ( !pc || !*pc )
<         {
<             // end of the entry
<             if ( !!curMimeType && !!curIconFile )
<             {
<                 // do we already know this mimetype?
<                 int i = ms_mimetypes.Index(curMimeType);
<                 if ( i == wxNOT_FOUND )
---
> }
> 
> 
> 
> bool wxMimeTypesManagerImpl::WriteGnomeKeyFile(int index, bool delete_index)
369,371c364,397
<                     // add a new entry
<                     size_t n = ms_mimetypes.Add(curMimeType);
<                     ms_icons.Insert(curIconFile, n);
---
>     wxString gnomedir;
>     wxGetHomeDir( &gnomedir );
> 
>     wxMimeTextFile outfile ( gnomedir + "/.gnome/mime-info/user.keys");
>     // if this fails probably Gnome is not installed ??
>     // create it anyway as a private mime store
> 
>     if (! outfile.Open () )
>     {
>         if (delete_index) return FALSE ;
>         if (!CheckGnomeDirsExist() ) return FALSE ;
>         outfile.Create () ;
>     }
> 
>     wxString sTmp, strType = m_aTypes[index] ;
>     int nIndex = outfile.pIndexOf(strType) ;
>     if ( nIndex == wxNOT_FOUND )
>         { 
>         outfile.AddLine ( strType + wxT(':') );
>         // see file:/usr/doc/gnome-libs-devel-1.0.40/devel-docs/mime-type-handling.txt
>         // as this does not deal with internationalisation
>         //        wxT( "\t[en_US]") + verb + wxT ('=') + cmd + wxT(" %f");
>         wxMimeArrayString * entries = m_aEntries[index] ;
>         size_t i ;
>         for (i=0; i < entries->GetCount(); i++)
>             {
>             sTmp = entries->Item(i) ;
>             sTmp.Replace( wxT("%s"), wxT("%f") );
>             sTmp = wxT ( "\t") + sTmp ;
>             outfile.AddLine ( sTmp );
>             }
>         //for international use do something like this
>         //outfile.AddLine ( wxString( "\t[en_US]icon-filename=") + cmd );
>         outfile.AddLine ( wxT( "\ticon-filename=") + m_aIcons[index] );
375,377c401,414
<                     // replace the existing one (this means that the directories
<                     // should be searched in order of increased priority!)
<                     ms_icons[(size_t)i] = curIconFile;
---
>         if (delete_index) outfile.CommentLine(nIndex);
>         wxMimeArrayString sOld ;
>         size_t nOld = nIndex + 1;
>         bool oldEntryEnd = FALSE;
>         while ( (nOld < outfile.GetLineCount() )&& (oldEntryEnd == FALSE )) 
>             {
>             sTmp = outfile.GetLine(nOld) ;
>             if ( (sTmp[0u] == wxT('\t')) || (sTmp[0u] == wxT('#')) )                
>                 {
>                 // we have another line to deal with
>                 outfile.CommentLine(nOld) ;
>                 nOld ++ ;
>                 // add the line to our store
>                 if ((!delete_index) && (sTmp[0u] == wxT('\t'))) sOld.Add(sTmp); 
378a416,417
>             // next mimetpye ??or blank line    
>             else oldEntryEnd = TRUE;
380,381c419,421
< 
<             if ( !pc )
---
>         // list of entries in our data; these should all be in sOld, 
>         // though sOld may also contain other entries , eg flags
>         if (!delete_index) 
383,384c423,428
<                 // the end - this can only happen if nLine == nLineCount
<                 break;
---
>             wxMimeArrayString * entries = m_aEntries[index] ;
>             size_t i ;
>             for (i=0; i < entries->GetCount(); i++)
>                 {
>                 // replace any entries in sold that match verbs we know
>                 sOld.ReplaceOrAddLineCmd ( entries->GetVerb(i), entries->GetCmd (i) );
385a430,432
>             //sOld should also contain the icon
>             if ( !m_aIcons[index].IsEmpty() )    
>                 sOld.ReplaceOrAddLineCmd ( wxT( "icon-filename"), m_aIcons[index] );
387,389c434,445
<             curIconFile.Empty();
< 
<             continue;
---
>             for (i=0; i < sOld.GetCount(); i++)
>                 {
>                 sTmp = sOld.Item(i) ;
>                 sTmp.Replace( wxT("%s"), wxT("%f") );
>                 sTmp = wxT ( "\t") + sTmp ;
>                 nIndex ++ ;
>                 outfile.InsertLine ( sTmp, nIndex );
>                 }
>             }    
>         }
>     bool bTmp = outfile.Write () ;
>     return bTmp ;
392,396d447
<         // what do we have here?
<         if ( *pc == _T('\t') )
<         {
<             // this is a field=value ling
<             pc++; // skip leading TAB
398,401c449
<             // skip optional "[lang]"
<             if ( *pc == _T('[') )
<             {
<                 while ( *pc )
---
> bool wxMimeTypesManagerImpl::WriteGnomeMimeFile(int index, bool delete_index)
403,406c451,452
<                     if ( *pc++ == _T(']') )
<                         break;
<                 }
<             }
---
>     wxString gnomedir;
>     wxGetHomeDir( &gnomedir );
408,409c454,465
<             static const int lenField = 13; // strlen("icon-filename")
<             if ( wxStrncmp(pc, _T("icon-filename"), lenField) == 0 )
---
>     wxMimeTextFile outfile ( gnomedir + "/.gnome/mime-info/user.mime");
>     // if this fails probably Gnome is not installed ??
>     // create it anyway as a private mime store
>     if (! outfile.Open () )
>     {
>         if (delete_index) return FALSE ;        
>         if (!CheckGnomeDirsExist() ) return FALSE ;
>         outfile.Create () ;
>     }
>     wxString strType = m_aTypes[index] ;
>     int nIndex = outfile.pIndexOf(strType) ;
>     if ( nIndex == wxNOT_FOUND )
411,413c467,468
<                 // skip '=' which follows and take everything left until the end
<                 // of line
<                 curIconFile = pc + lenField + 1;
---
>         outfile.AddLine ( strType );
>         outfile.AddLine ( wxT( "\text:") + m_aExtensions.Item(index) );
415c470,475
<             //else: some other field, we don't care
---
>     else 
>         {
>         if (delete_index)
>             {
>             outfile.CommentLine(nIndex);
>             outfile.CommentLine(nIndex+1);
417a478,480
>             {// check for next line being the right one to replace ??
>             wxString sOld = outfile.GetLine(nIndex+1) ;
>             if (sOld.Contains(wxT("\text: ")))
419,422c482,484
<             // this is the start of the new section
<             curMimeType.Empty();
< 
<             while ( *pc != _T(':') && *pc != _T('\0') )
---
>                 outfile.GetLine(nIndex+1) = wxT( "\text: ") + m_aExtensions.Item(index) ;
>                 }
>             else
424c486
<                 curMimeType += *pc++;
---
>                 outfile.InsertLine(wxT( "\text: ") + m_aExtensions.Item(index), nIndex + 1 );
427a490,491
>     bool bTmp = outfile.Write () ;
>     return bTmp ;
430c494,495
< void wxGNOMEIconHandler::LoadKeyFilesFromDir(const wxString& dirbase)
---
> 
> void wxMimeTypesManagerImpl::LoadGnomeDataFromKeyFile(const wxString& filename)
432,433c497,501
<     wxASSERT_MSG( !!dirbase && !wxEndsWithPathSeparator(dirbase),
<                   _T("base directory shouldn't end with a slash") );
---
>     wxTextFile textfile(filename);
>     if ( !textfile.Open() )
>         return;
>     wxLogTrace(TRACE_MIME, wxT("--- Opened Gnome file %s  ---"), 
>                  filename.c_str());
435,436c503,505
<     wxString dirname = dirbase;
<     dirname << _T("/mime-info");
---
>     // values for the entry being parsed
>     wxString curMimeType, curIconFile;
>     wxMimeArrayString * entry = new wxMimeArrayString ;
438,439c507,509
<     if ( !wxDir::Exists(dirname) )
<         return;
---
>     // these are always empty in this file
>     wxArrayString strExtensions ;
>     wxString strDesc ;
441,443c511,518
<     wxDir dir(dirname);
<     if ( !dir.IsOpened() )
<         return;
---
>     const wxChar *pc;
>     size_t nLineCount = textfile.GetLineCount();
>     size_t nLine = 0; 
>     while ( nLine < nLineCount)
>         {
>         pc = textfile[nLine].c_str();
>         if ( *pc != _T('#') )
>             {
445,446c520,521
<     // we will concatenate it with filename to get the full path below
<     dirname += _T('/');
---
>             wxLogTrace(TRACE_MIME, wxT("--- Reading from Gnome file %s '%s' ---"), 
>                  filename.c_str(),pc);
448,450c523,530
<     wxString filename;
<     bool cont = dir.GetFirst(&filename, _T("*.keys"), wxDIR_FILES);
<     while ( cont )
---
>             wxString sTmp(pc);
>             if (sTmp.Contains(wxT("=")) )     
>             {
>             if (sTmp.Contains( wxT("icon-filename=") ) )
>                 {
>                 curIconFile = sTmp.AfterFirst(wxT('='));
>                 }            
>             else //: some other field,            
452c532,536
<         LoadIconsFromKeyFile(dirname + filename);
---
>                 //may contain lines like this (RH7)
>                 // \t[lang]open.tex."TeX this file"=tex %f
>                 // \tflags.tex.flags=needsterminal
>                 // \topen.latex."LaTeX this file"=latex %f
>                 // \tflags.latex.flags=needsterminal
454c538,567
<         cont = dir.GetNext(&filename);
---
>                 // \topen=xdvi %f
>                 // \tview=xdvi %f
>                 // \topen.convert.Convert file to Postscript=dvips %f -o `basename %f .dvi`.ps
>                 
>                 // for now ignore lines with flags in...FIX
>                 sTmp = sTmp.AfterLast(wxT(']'));
>                 sTmp = sTmp.AfterLast(wxT('\t'));
>                 sTmp.Trim(FALSE).Trim();
>                 if (0 == sTmp.Replace ( wxT("%f"), wxT("%s") )) sTmp = sTmp + wxT(" %s");
>                 entry->Add(sTmp);
> 
>                 }
>  
>             } // emd of has an equals sign
>             else
>                 {
>                 // not a comment and not an equals sign
>                 if (sTmp.Contains(wxT('/')))
>                     {
>                     // this is the start of the new mimetype
>                     // overwrite any existing data
>                     if (! curMimeType.IsEmpty())
>                         {
>                         AddToMimeData ( curMimeType, curIconFile, entry, strExtensions, strDesc) ;
> 
>                         // now get ready for next bit                        
>                         entry = new wxMimeArrayString ;
>                         }
>                     curMimeType = sTmp.BeforeFirst(wxT(':')) ;
>                     }
455a569,577
>         } // end of not a comment 
>     // ignore blank lines    
>     nLine ++ ; 
>     } // end of while, save any data
>     if (! curMimeType.IsEmpty())
>         {
>         AddToMimeData ( curMimeType, curIconFile, entry, strExtensions, strDesc) ;
>         }
> 
459c581,582
< void wxGNOMEIconHandler::LoadMimeTypesFromMimeFile(const wxString& filename, wxMimeTypesManagerImpl *manager)
---
> 
> void wxMimeTypesManagerImpl::LoadGnomeMimeTypesFromMimeFile(const wxString& filename)
463a587,588
>     wxLogTrace(TRACE_MIME, wxT("--- Opened Gnome file %s  ---"), 
>                  filename.c_str());
492c617,620
<                  manager -> AddMimeTypeInfo(curMimeType, curExtList, wxEmptyString);
---
>                  wxLogTrace(TRACE_MIME, wxT("--- At end of Gnome file  finding mimetype %s  ---"), 
>                  curMimeType.c_str());
> 
>                  AddMimeTypeInfo(curMimeType, curExtList, wxEmptyString);
523a652,656
>             wxLogTrace(TRACE_MIME, wxT("--- In Gnome file  finding mimetype %s  ---"), 
>                  curMimeType.c_str());
> 
>             if (! curMimeType.IsEmpty()) AddMimeTypeInfo(curMimeType, curExtList, wxEmptyString);
> 
535c668
< void wxGNOMEIconHandler::LoadMimeFilesFromDir(const wxString& dirbase, wxMimeTypesManagerImpl *manager)
---
> void wxMimeTypesManagerImpl::LoadGnomeMimeFilesFromDir(const wxString& dirbase)
557c690,698
<         LoadMimeTypesFromMimeFile(dirname + filename, manager);
---
>         LoadGnomeMimeTypesFromMimeFile(dirname + filename);
> 
>         cont = dir.GetNext(&filename);
>     }
> 
>     cont = dir.GetFirst(&filename, _T("*.keys"), wxDIR_FILES);
>     while ( cont )
>     {
>         LoadGnomeDataFromKeyFile(dirname + filename);
564c705,707
< void wxGNOMEIconHandler::Init()
---
> 
> 
> void wxMimeTypesManagerImpl::GetGnomeMimeInfo(const wxString& sExtraDir)
565a709
>     
573a718
>     if (!sExtraDir.IsEmpty()) dirs.Add( sExtraDir );
578c723
<         LoadKeyFilesFromDir(dirs[nDir]);
---
>         LoadGnomeMimeFilesFromDir(dirs[nDir]);
580,581d724
< 
<     m_inited = TRUE;
585,590d727
< void wxGNOMEIconHandler::GetMimeInfoRecords(wxMimeTypesManagerImpl *manager)
< {
<     if ( !m_inited )
<     {
<         Init();
<     }
592,594d728
<     wxArrayString dirs;
<     dirs.Add(_T("/usr/share"));
<     dirs.Add(_T("/usr/local/share"));
596,599c730,749
<     wxString gnomedir;
<     wxGetHomeDir( &gnomedir );
<     gnomedir += _T("/.gnome");
<     dirs.Add( gnomedir );
---
> // end of gnome
> 
> // ----------------------------------------------------------------------------
> // wxKDE
> // ----------------------------------------------------------------------------
> 
> // KDE stores the icon info in its .kdelnk files. The file for mimetype/subtype
> // may be found in either of the following locations
> //
> //  1. $KDEDIR/share/mimelnk/mimetype/subtype.kdelnk
> //  2. ~/.kde/share/mimelnk/mimetype/subtype.kdelnk
> //
> // The format of a .kdelnk file is almost the same as the one used by
> // wxFileConfig, i.e. there are groups, comments and entries. The icon is the
> // value for the entry "Type"
> 
> // kde writing; see http://webcvs.kde.org/cgi-bin/cvsweb.cgi/~checkout~/kdelibs/kio/DESKTOP_ENTRY_STANDARD
> // for now write to .kdelnk but should eventually do .desktop instead (in preference??)
> 
> bool wxMimeTypesManagerImpl::CheckKDEDirsExist ( const wxString & sOK, const wxString & sTest )
601,602d750
<     size_t nDirs = dirs.GetCount();
<     for ( size_t nDir = 0; nDir < nDirs; nDir++ )
604c752,762
<         LoadMimeFilesFromDir(dirs[nDir], manager);
---
>     if (sTest.IsEmpty())
>         {
>             if (wxDir::Exists(sOK)) return TRUE;
>             else return FALSE;
>         }
>     else
>         {
>             wxString sStart = sOK + wxT("/") + sTest.BeforeFirst(wxT('/')) ;
>             if (!wxDir::Exists(sStart))  wxMkdir(sStart);
>             wxString sEnd = sTest.AfterFirst(wxT('/')) ;
>             return CheckKDEDirsExist(sStart, sEnd) ;
608,612d765
< #if wxUSE_GUI
<     #define WXUNUSED_UNLESS_GUI(p)  p
< #else
<     #define WXUNUSED_UNLESS_GUI(p)
< #endif
614,615c767,768
< bool wxGNOMEIconHandler::GetIcon(const wxString& mimetype,
<                                  wxIcon * WXUNUSED_UNLESS_GUI(icon))
---
> 
> bool wxMimeTypesManagerImpl::WriteKDEMimeFile(int index, bool delete_index)
617c770,780
<     if ( !m_inited )
---
>     wxMimeTextFile appoutfile, mimeoutfile ;
>     wxString sHome = wxGetHomeDir() ;
>     wxString sTmp = wxT(".kde/share/mimelnk/");
>     wxString sMime = m_aTypes[index]  ;
>     CheckKDEDirsExist (sHome, sTmp + sMime.BeforeFirst(wxT('/')) ) ;
>     sTmp = sHome + wxT('/') + sTmp + sMime + wxT(".kdelnk") ;
>     
>     bool bTemp ;
>     bool bMimeExists;
>     bMimeExists = mimeoutfile.Open (sTmp);
>     if (!bMimeExists) 
619c782,784
<         Init();
---
>        bTemp = mimeoutfile.Create (sTmp);
>        // some unknown error eg out of disk space
>        if (!bTemp) return FALSE;
622,624c787,789
<     int index = ms_mimetypes.Index(mimetype);
<     if ( index == wxNOT_FOUND )
<         return FALSE;
---
>     sTmp = wxT(".kde/share/applnk/");
>     CheckKDEDirsExist (sHome, sTmp + sMime.AfterFirst(wxT('/')) ) ;
>     sTmp = sHome + wxT('/') + sTmp + sMime.AfterFirst(wxT('/')) + wxT(".kdelnk") ;
626c791,798
<     wxString iconname = ms_icons[(size_t)index];
---
>     bool bAppExists;
>     bAppExists = appoutfile.Open (sTmp);
>     if (!bAppExists) 
>        {
>        bTemp = appoutfile.Create (sTmp);
>        // some unknown error eg out of disk space
>        if (!bTemp) return FALSE;
>        }
628,636c800,804
< #if wxUSE_GUI
<     wxLogNull nolog;
<     wxIcon icn;
<     if (iconname.Right(4).MakeUpper() == _T(".XPM"))
<         icn = wxIcon(iconname);
<     else
<         icn = wxIcon(iconname, wxBITMAP_TYPE_ANY);
<     if ( !icn.Ok() )
<         return FALSE;
---
>     // fixed data; write if new file
>     if (!bMimeExists) mimeoutfile.AddLine(wxT("[Desktop Entry]"));
>     if (!bMimeExists) mimeoutfile.AddLine(wxT("Version=1.0"));
>     if (!bMimeExists) mimeoutfile.AddLine(wxT("Type=MimeType"));
>     if (!bMimeExists) mimeoutfile.AddLine(wxT("MimeType=") + sMime);
638,644c806,809
<     if ( icon )
<         *icon = icn;
< #else
<     // helpful for testing in console mode
<     wxLogTrace(TRACE_MIME, _T("Found GNOME icon for '%s': '%s'\n"),
<                mimetype.c_str(), iconname.c_str());
< #endif
---
>     if (!bAppExists) appoutfile.AddLine(wxT("[Desktop Entry]"));
>     if (!bAppExists) appoutfile.AddLine(wxT("Version=1.0"));
>     if (!bAppExists) appoutfile.AddLine(wxT("Type=Application"));
>     if (!bAppExists) appoutfile.AddLine(wxT("MimeType=") + sMime);
646c811,834
<     return TRUE;
---
> 
>     // variable data
>     // ignore locale
>     mimeoutfile.CommentLine(wxT("Comment="));
>     if (!delete_index) mimeoutfile.AddLine(wxT("Comment=") + m_aDescriptions[index]);
> 
>     sTmp = m_aIcons[index] ;
>     // we can either give the full path, or the shortfilename if its in
>     // one of the directories we search
>     mimeoutfile.CommentLine(wxT("Icon=") );
>     if (!delete_index) mimeoutfile.AddLine(wxT("Icon=") + sTmp );
>     appoutfile.CommentLine(wxT("Icon=")  );
>     if (!delete_index) appoutfile.AddLine(wxT("Icon=") + sTmp );
> 
>     sTmp = wxT(" ") + m_aExtensions[index] ;
> 
>     wxStringTokenizer tokenizer(sTmp, _T(" "));
>     sTmp = wxT("Patterns=") ;
>     mimeoutfile.CommentLine(sTmp);
>     while ( tokenizer.HasMoreTokens() )
>     {
>         // holds an extension; need to change it to *.ext;
>         wxString e = wxT("*.") + tokenizer.GetNextToken() + wxT(";");
>         sTmp = sTmp + e ;
647a836
>     if (!delete_index) mimeoutfile.AddLine(sTmp);
649,651c838,862
< // ----------------------------------------------------------------------------
< // wxKDEIconHandler
< // ----------------------------------------------------------------------------
---
>     wxMimeArrayString * entries = m_aEntries[index] ;
>     // if we don't find open just have an empty string ... FIX this
>     size_t iOpen = entries -> pIndexOf(wxT("open")) ;
>     sTmp = entries -> GetCmd(iOpen);
>     sTmp.Replace( wxT("%s"), wxT("%f") );
> 
>     mimeoutfile.CommentLine(wxT("DefaultApp=") );
>     if (!delete_index) mimeoutfile.AddLine(wxT("DefaultApp=") + sTmp);
>     
>     sTmp.Replace( wxT("%f"), wxT("") );
>     appoutfile.CommentLine(wxT("Exec="));
>     if (!delete_index) appoutfile.AddLine(wxT("Exec=") + sTmp);
> 
>     if (entries->GetCount() > 1)
>         {
>             //other actions as well as open
> 
>         }
>     bTemp = FALSE ;
>     if (mimeoutfile.Write ()) bTemp = TRUE ;
>     mimeoutfile.Close ();
>     if (appoutfile.Write ()) bTemp = TRUE ;
>     appoutfile.Close ();
> 
>     return bTemp ;
653,661d863
< // KDE stores the icon info in its .kdelnk files. The file for mimetype/subtype
< // may be found in either of the following locations
< //
< //  1. $KDEDIR/share/mimelnk/mimetype/subtype.kdelnk
< //  2. ~/.kde/share/mimelnk/mimetype/subtype.kdelnk
< //
< // The format of a .kdelnk file is almost the same as the one used by
< // wxFileConfig, i.e. there are groups, comments and entries. The icon is the
< // value for the entry "Type"
663c865,867
< void wxKDEIconHandler::LoadLinksForMimeSubtype(const wxString& dirbase,
---
> }
> 
> void wxMimeTypesManagerImpl::LoadKDELinksForMimeSubtype(const wxString& dirbase,
668,670c872,873
<     wxFFile file(dirbase + filename);
<     if ( !file.IsOpened() )
<         return;
---
>     wxMimeTextFile file;
>     if ( !file.Open(dirbase + filename) ) return ;
671a875,881
>     wxMimeArrayString * entry = new wxMimeArrayString ;
>     wxArrayString sExts ;
>     wxString mimetype, mime_desc, strIcon ;
>     
>     int nIndex = file.pIndexOf ("MimeType=");
>     if (nIndex == wxNOT_FOUND)
>         {
674d883
<     wxString mimetype;
676,680c885,886
< 
<     // these files are small, slurp the entire file at once
<     wxString text;
<     if ( !file.ReadAll(&text) )
<         return;
---
>         }
>     else mimetype = file.GetCmd (nIndex);
684c890
<     int posComment = wxNOT_FOUND;
---
>     nIndex = wxNOT_FOUND;
693,694c899
< 
<         posComment = text.Find(comment);
---
>         nIndex = file.pIndexOf(comment);
698c903
<     if ( posComment == wxNOT_FOUND )
---
>     if ( nIndex == wxNOT_FOUND )
701,702c906
< 
<         posComment = text.Find(comment);
---
>         nIndex = file.pIndexOf(comment);
705,714c909
<     wxString mime_desc;
<     if ( posComment != wxNOT_FOUND )
<     {
<         // found desc: it follows the comment until the end of line
<         const wxChar *pc = text.c_str() + posComment + comment.length();
<         while ( *pc && *pc != _T('\n') )
<         {
<             mime_desc += *pc++;
<         }
<     }
---
>     if ( nIndex != wxNOT_FOUND ) mime_desc = file.GetCmd(nIndex) ;
720,725c915,916
<     int posExts = text.Find(_T("Patterns="));
<     if ( posExts != wxNOT_FOUND )
<     {
<         wxString exts;
<         const wxChar *pc = text.c_str() + posExts + 9; // strlen("Patterns=")
<         while ( *pc && *pc != _T('\n') )
---
>     nIndex = file.pIndexOf(_T("Patterns="));
>     if ( nIndex != wxNOT_FOUND )
727,728c918
<             exts += *pc++;
<         }
---
>         wxString exts = file.GetCmd (nIndex) ;;
745a936
>     sExts.Add(mime_extension) ;
747,749d937
<     ms_infoTypes.Add(mimetype);
<     ms_infoDescriptions.Add(mime_desc);
<     ms_infoExtensions.Add(mime_extension);
753,754c941,942
<     int posIcon = text.Find(_T("Icon="));
<     if ( posIcon == wxNOT_FOUND )
---
>     nIndex = file.pIndexOf(_T("Icon="));
>     if ( nIndex != wxNOT_FOUND )
756,763c944,946
<         // no icon info
<         return;
<     }
< 
<     wxString icon;
< 
<     const wxChar *pc = text.c_str() + posIcon + 5;  // 5 == strlen("Icon=")
<     while ( *pc && *pc != _T('\n') )
---
>         strIcon = file.GetCmd(nIndex) ;
>         //it could be the real path, but more often a short name
>         if (!wxFileExists(strIcon))
765,768c948,949
<         icon += *pc++;
<     }
< 
<     if ( !!icon )
---
>             // icon is just the short name
>             if ( !strIcon.IsEmpty() )
774c955
<             if (wxFileExists(icondirs[nDir] + icon))
---
>                     if (wxFileExists(icondirs[nDir] + strIcon))
776c957
<                 icon.Prepend(icondirs[nDir]);
---
>                         strIcon.Prepend(icondirs[nDir]);
779c960,966
<         if (nDir == nDirs) return; //does not exist
---
>                 }
>             }
>          }
>     // now look for lines which know about the application
>     // exec= or DefaultApp=
> 
>     nIndex = file.pIndexOf(wxT("DefaultApp")) ;
781,783c968
<         // do we already have this MIME type?
<         int i = ms_mimetypes.Index(mimetype);
<         if ( i == wxNOT_FOUND )
---
>     if ( nIndex == wxNOT_FOUND )
785,787c970,971
<             // add it
<             size_t n = ms_mimetypes.Add(mimetype);
<             ms_icons.Insert(icon, n);
---
>         // no entry try exec
>         nIndex = file.pIndexOf(wxT("Exec"));
789c973,974
<         else
---
>     
>     if ( nIndex != wxNOT_FOUND )
791,793c976,979
<             // replace the old value
<             ms_icons[(size_t)i] = icon;
<         }
---
>         wxString sTmp = file.GetCmd(nIndex) ;
>         // we expect %f; others including  %F and %U and %u are possible
>         if (0 == sTmp.Replace ( wxT("%f"), wxT("%s") )) sTmp = sTmp + wxT(" %s");        
>         entry -> ReplaceOrAddLineCmd (wxString(wxT("open")), sTmp );
794a981,984
>     
>     AddToMimeData (mimetype, strIcon, entry, sExts, mime_desc) ;
> 
>     
797c987
< void wxKDEIconHandler::LoadLinksForMimeType(const wxString& dirbase,
---
> void wxMimeTypesManagerImpl::LoadKDELinksForMimeType(const wxString& dirbase,
813c1003,1011
<         LoadLinksForMimeSubtype(dirname, subdir, filename, icondirs);
---
>         LoadKDELinksForMimeSubtype(dirname, subdir, filename, icondirs);
> 
>         cont = dir.GetNext(&filename);
>     }
>     // new standard for Gnome and KDE
>     cont = dir.GetFirst(&filename, _T("*.desktop"), wxDIR_FILES);
>     while ( cont )
>     {
>         LoadKDELinksForMimeSubtype(dirname, subdir, filename, icondirs);
819c1017
< void wxKDEIconHandler::LoadLinkFilesFromDir(const wxString& dirbase,
---
> void wxMimeTypesManagerImpl::LoadKDELinkFilesFromDir(const wxString& dirbase,
842c1040
<         LoadLinksForMimeType(dirname, subdir, icondirs);
---
>         LoadKDELinksForMimeType(dirname, subdir, icondirs);
848c1046
< void wxKDEIconHandler::Init()
---
> void wxMimeTypesManagerImpl::GetKDEMimeInfo(const wxString& sExtraDir)
873a1072,1074
>     if (!sExtraDir.IsEmpty()) dirs.Add (sExtraDir);
>     icondirs.Add(sExtraDir + wxT("/icons"));
>     
877c1078
<         LoadLinkFilesFromDir(dirs[nDir], icondirs);
---
>         LoadKDELinkFilesFromDir(dirs[nDir], icondirs);
880c1081
<     m_inited = TRUE;
---
> 
883,884c1084,1091
< bool wxKDEIconHandler::GetIcon(const wxString& mimetype,
<                                wxIcon * WXUNUSED_UNLESS_GUI(icon))
---
> // end of KDE
> 
> // ----------------------------------------------------------------------------
> // wxFileTypeImpl (Unix)
> // ----------------------------------------------------------------------------
>               
> 
> wxString wxFileTypeImpl::GetExpandedCommand(const wxString & verb, const wxFileType::MessageParameters& params) const
886c1093,1095
<     if ( !m_inited )
---
>     wxString sTmp ;
>     size_t i = 0;
>     while ( (i < m_index.GetCount() ) && sTmp.IsEmpty() )
888c1097,1098
<         Init();
---
>             sTmp = m_manager -> GetCommand ( verb, m_index[i] ); 
>             i ++ ;
891,893c1101,1102
<     int index = ms_mimetypes.Index(mimetype);
<     if ( index == wxNOT_FOUND )
<         return FALSE;
---
>     return wxFileType::ExpandCommand(sTmp, params);
> }
895c1104,1115
<     wxString iconname = ms_icons[(size_t)index];
---
> bool wxFileTypeImpl::GetIcon(wxIcon *icon, wxString *iconFile /*= NULL */,
>                  int *iconIndex /*= NULL*/) const
> 
> {
>     wxString sTmp ;
>     size_t i = 0;
>     while ( (i < m_index.GetCount() ) && sTmp.IsEmpty() )
>         {
>             sTmp = m_manager->m_aIcons[m_index[i]] ;
>             i ++ ;
>         }
>     if ( sTmp.IsEmpty () ) return FALSE ;    
897,898d1116
< #if wxUSE_GUI
<     wxLogNull nolog;
900,901c1118,1120
<     if (iconname.Right(4).MakeUpper() == _T(".XPM"))
<         icn = wxIcon(iconname);
---
>         
>     if (sTmp.Right(4).MakeUpper() == _T(".XPM"))
>         icn = wxIcon(sTmp);
903c1122
<         icn = wxIcon(iconname, wxBITMAP_TYPE_ANY);
---
>         icn = wxIcon(sTmp, wxBITMAP_TYPE_ANY);
905c1124,1130
<     if ( !icn.Ok() )
---
>     if ( icn.Ok() )
>       {
>       *icon = icn ;
>       if (iconFile) *iconFile = sTmp ;
>       if (iconIndex) *iconIndex = 0 ;
>       return TRUE;
>       }
906a1132
>     }
908,914c1134,1219
<     if ( icon )
<         *icon = icn;
< #else
<     // helpful for testing in console mode
<     wxLogTrace(TRACE_MIME, _T("Found KDE icon for '%s': '%s'\n"),
<                mimetype.c_str(), iconname.c_str());
< #endif
---
> 
> bool 
> wxFileTypeImpl::GetMimeTypes(wxArrayString& mimeTypes) const
> {
>     mimeTypes.Clear();
>     for (size_t i = 0; i < m_index.GetCount(); i++)
>         mimeTypes.Add(m_manager->m_aTypes[m_index[i]]);
>     return TRUE;
> }
> 
> 
> size_t wxFileTypeImpl::GetAllCommands(wxArrayString *verbs,
>                                   wxArrayString *commands,
>                                   const wxFileType::MessageParameters& params) const
> {
> 
>     wxString vrb, cmd, sTmp; 
>     size_t count = 0;
>     wxMimeArrayString * sPairs ;
>     
>     // verbs and commands have been cleared already in mimecmn.cpp...
>     // if we find no entries in the exact match, try the inexact match
>     for (size_t n = 0; ((count ==0) && (n < m_index.GetCount())); n++)
>     {
>         // list of verb = command pairs for this mimetype
>         sPairs = m_manager->m_aEntries [m_index[n]];
>         size_t i ;
>         for ( i = 0; i < sPairs -> GetCount () ; i++ )
>             {
>                 vrb = sPairs -> GetVerb(i) ;
>                 // some gnome entries have . inside
>                 vrb = vrb.AfterLast(wxT('.')) ;
>                 cmd = sPairs -> GetCmd (i) ;
>                 if (! cmd.IsEmpty() )
>                      {
>                      cmd = wxFileType::ExpandCommand(cmd, params);
>                      count ++;
>                      if ( vrb.IsSameAs (wxT("open")))
>                          {
>                          verbs -> Insert(vrb,0u);
>                          commands ->Insert(cmd,0u);
>                          }
>                      else
>                          {
>                          verbs->Add (vrb) ;
>                          commands -> Add (cmd) ;
>                          }
>                      }
>                 
>         }
> 
>     }
>     return count;
> 
> }
> 
> bool wxFileTypeImpl::GetExtensions(wxArrayString& extensions)
> {
>     wxString strExtensions = m_manager->GetExtension(m_index[0]);
>     extensions.Empty();
> 
>     // one extension in the space or comma delimitid list
>     wxString strExt;
>     for ( const wxChar *p = strExtensions; ; p++ ) {
>         if ( *p == wxT(' ') || *p == wxT(',') || *p == wxT('\0') ) {
>             if ( !strExt.IsEmpty() ) {
>                 extensions.Add(strExt);
>                 strExt.Empty();
>             }
>             //else: repeated spaces (shouldn't happen, but it's not that
>             //      important if it does happen)
> 
>             if ( *p == wxT('\0') )
>                 break;
>         }
>         else if ( *p == wxT('.') ) {
>             // remove the dot from extension (but only if it's the first char)
>             if ( !strExt.IsEmpty() ) {
>                 strExt += wxT('.');
>             }
>             //else: no, don't append it
>         }
>         else {
>             strExt += *p;
>         }
>     }
918a1224,1507
> // set an arbitrary command, 
> // could adjust the code to ask confirmation if it already exists and
> // overwriteprompt is TRUE, but this is currently ignored as *Associate* has
> // no overwrite prompt
> bool wxFileTypeImpl::SetCommand(const wxString& cmd, const wxString& verb, bool overwriteprompt /*= TRUE*/)
>     {
>     wxArrayString strExtensions ;
>     wxString strDesc, strIcon  ;
> 
>     wxMimeArrayString *entry = new wxMimeArrayString ();
>     entry -> Add(verb + wxT("=")  + cmd + wxT(" %s ")); 
> 
>     wxArrayString strTypes ;
>     GetMimeTypes (strTypes) ; 
>     if (strTypes.GetCount() < 1) return FALSE ;
>     
>     size_t i ;
>     bool Ok = TRUE ;
>     for (i = 0; i < strTypes.GetCount(); i++)
>         {
>         if (!m_manager -> DoAssociation (strTypes[i], strIcon, entry, strExtensions, strDesc))
>         Ok = FALSE;
>         }
>      
>     return Ok ; 
>     }
> 
> // ignore index on the grouds that we only have one icon in a Unix file 
> bool wxFileTypeImpl::SetDefaultIcon(const wxString& strIcon /*= wxEmptyString*/, int /*index = 0*/)
>     {
>     if (strIcon.IsEmpty()) return FALSE ;
>     wxArrayString strExtensions ;
>     wxString strDesc ;
> 
>     wxMimeArrayString *entry = new wxMimeArrayString ();
> 
>     wxArrayString strTypes ;
>     GetMimeTypes (strTypes) ; 
>     if (strTypes.GetCount() < 1) return FALSE ;
>     
>     size_t i ;
>     bool Ok = TRUE ;
>     for (i = 0; i < strTypes.GetCount(); i++)
>         {
>         if (!m_manager -> DoAssociation (strTypes[i], strIcon, entry, strExtensions, strDesc))
>         Ok = FALSE;
>         }
>      
>     return Ok ; 
>     }
> // ----------------------------------------------------------------------------
> // wxMimeTypesManagerImpl (Unix)
> // ----------------------------------------------------------------------------
> 
> 
> wxMimeTypesManagerImpl::wxMimeTypesManagerImpl()
> {
>     m_initialized = FALSE;
>     m_win_managers = 0 ;
> }
> 
> // read system and user mailcaps and other files
> // by default wxWMNETSCAPE; wxWMBASE, wxKDE or wxGNOME are other possibilities
> void wxMimeTypesManagerImpl::Initialize(int wxWM /*= wxWMNETSCAPE*/, const wxString & sExtraDir /*= wxEmptyString*/) 
> {
> 
>     // read mimecap amd mime.types
>     if ( ( wxWM & wxWMNETSCAPE) || ( wxWM & wxWMBASE) ) GetMimeInfo(sExtraDir) ;
>     // read GNOME tables
>     if ( wxWM & wxWMGNOME) GetGnomeMimeInfo(sExtraDir) ;
>     // read KDE tables
>     if ( wxWM & wxWMKDE) GetKDEMimeInfo(sExtraDir) ;
> 
>     m_win_managers = m_win_managers | wxWM ;
> }
> 
> // clear data so you can read another group of WM files
> void wxMimeTypesManagerImpl::ClearData ()
> {
>     m_aTypes.Clear ();
>     m_aIcons.Clear ();
>     m_aExtensions.Clear ();
>     m_aDescriptions.Clear ();
> 
>     size_t cnt = m_aTypes.GetCount();
>     for (size_t i = 0; i < cnt; i++)
>         {
>             m_aEntries[i] -> Clear () ;
>         }
>     m_aEntries.Clear ();    
>     m_win_managers = 0;     
> }
> 
> wxMimeTypesManagerImpl::~wxMimeTypesManagerImpl()
> {
>     ClearData () ; // do we need to delete the ArrayStrings too to avoid a leak
>     
> //    delete m_aEntries //fix a leak here ?;
> }
> 
> 
> void wxMimeTypesManagerImpl::GetMimeInfo (const wxString& sExtraDir)
>     {
>     // read this for netscape or Metamail formats
>         
>     // directories where we look for mailcap and mime.types by default
>     // used by netscape and pine and other mailers, using 2 different formats!
>         
>     // (taken from metamail(1) sources)
>     //
>     // although RFC 1524 specifies the search path of
>     // /etc/:/usr/etc:/usr/local/etc only, it doesn't hurt to search in more
>     // places - OTOH, the RFC also says that this path can be changed with
>     // MAILCAPS environment variable (containing the colon separated full
>     // filenames to try) which is not done yet (TODO?)
> 
>     wxString strHome = wxGetenv(wxT("HOME"));
> 
>     wxArrayString dirs;
>     dirs.Add ( wxT("/etc/") ) ;
>     dirs.Add ( wxT("/usr/etc/") );
>     dirs.Add ( wxT("/usr/local/etc/") );
>     dirs.Add ( wxT("/etc/mail/") );
>     dirs.Add ( wxT("/usr/public/lib/") );
>     dirs.Add ( strHome + wxT("/.") );
>     if (!sExtraDir.IsEmpty()) dirs.Add ( sExtraDir + wxT("/") );
> 
>     size_t nDirs = dirs.GetCount();
>     for ( size_t nDir = 0; nDir < nDirs; nDir++ )
>     {
>         wxString file = dirs[nDir] + wxT("mailcap");
>         if ( wxFile::Exists(file) ) {
>             ReadMailcap(file);
>         }
> 
>         file = dirs[nDir] + wxT("mime.types");
>         if ( wxFile::Exists(file) ) {
>             ReadMimeTypes(file);
>         }
>     }
> 
>   } // end of wxWMNETSCAPE or wxWMBASE
> 
> 
> 
> bool wxMimeTypesManagerImpl::WriteToMimeTypes (int index, bool delete_index)
> {   
> //check we have the right manager
> if (! ( m_win_managers & wxWMBASE) ) return FALSE ;
> 
>     bool bTemp ;
>     wxString strHome = wxGetenv(wxT("HOME"));
> 
>     // and now the users mailcap
>     wxString strUserMailcap = strHome + wxT("/.mime.types");
> 
>     wxMimeTextFile file ;
>     if ( wxFile::Exists(strUserMailcap) ) 
>         { 
>         bTemp =  file.Open(strUserMailcap);
>         }
>     else 
>         {
>         if (delete_index) return FALSE;
>         bTemp = file.Create(strUserMailcap);
>         }    
>     if (bTemp)
>         {
>         int nIndex ;
>         // test for netscape's header and return FALSE if its found
>         nIndex = file.pIndexOf (wxT("#--Netscape")) ;
>         if (nIndex != wxNOT_FOUND) 
>             {
>             wxASSERT_MSG(FALSE,wxT("Error in .mime.types \nTrying to mix Netscape and Metamail formats\nFile not modiifed"));
>             return FALSE ;
>             }
>         // write it in alternative format
>         // get rid of unwanted entries
>         wxString strType = m_aTypes[index] ;
>         nIndex = file.pIndexOf (strType);
>         // get rid of all the unwanted entries...
>         if (nIndex != wxNOT_FOUND) file.CommentLine (nIndex) ;
>         
>         if (!delete_index) 
>             {
>             // add the new entries in
>             wxString sTmp = strType.Append (wxT(' '), 40-strType.Len() );
>             sTmp = sTmp + m_aExtensions[index] ;
>             file.AddLine (sTmp);
>             }
> 
> 
>         bTemp = file.Write ();
>         file.Close ();
>         }
>     return bTemp ;
> }
> 
> bool wxMimeTypesManagerImpl::WriteToNSMimeTypes (int index, bool delete_index)
> {   
> //check we have the right managers
> if (! ( m_win_managers & wxWMNETSCAPE) ) return FALSE ;
> 
>     bool bTemp ;
>     wxString strHome = wxGetenv(wxT("HOME"));
> 
>     // and now the users mailcap
>     wxString strUserMailcap = strHome + wxT("/.mime.types");
> 
>     wxMimeTextFile file ;
>     if ( wxFile::Exists(strUserMailcap) ) 
>         { 
>         bTemp =  file.Open(strUserMailcap);
>         }
>     else 
>         {
>         if (delete_index) return FALSE;
>         bTemp = file.Create(strUserMailcap);
>         }    
>     if (bTemp)
>         {
> 
>         // write it in the format that Netscape uses    
>         int nIndex ;
>         // test for netscape's header and insert if required...
>         // this is a comment so use TRUE
>         nIndex = file.pIndexOf (wxT("#--Netscape"), TRUE) ;
>         if (nIndex == wxNOT_FOUND) 
>             {
>             // either empty file or metamail format
>             // at present we can't cope with mixed formats, so exit to preseve 
>             // metamail entreies
>             if (file.GetLineCount () > 0)
>                 {
>                 wxASSERT_MSG(FALSE, wxT(".mime.types File not in Netscape format\nNo entries written to\n.mime.types or to .mailcap"));
>                 return FALSE;
>                 }
>             file.InsertLine (wxT( "#--Netscape Communications Corporation MIME Information" ), 0) ;
>             nIndex = 0 ;
>             }
> 
>         wxString strType = wxT("type=") + m_aTypes[index] ;
>         nIndex = file.pIndexOf (strType);
>         // get rid of all the unwanted entries...
>         if (nIndex != wxNOT_FOUND)
>             {
>             wxString sOld = file[nIndex] ;
>             while ( (sOld.Contains(wxT("\\"))) && (nIndex < (int) file.GetLineCount()) )
>                 {
>                 file.CommentLine(nIndex) ;
>                 sOld = file[nIndex] ;
>                 wxLogTrace(TRACE_MIME, wxT("--- Deleting from mime.types line '%d %s' ---"), nIndex, sOld.c_str());
>                 nIndex ++ ;
>                 }
>             if (nIndex < (int) file.GetLineCount()) file.CommentLine (nIndex) ;
>             }
>         else nIndex = (int) file.GetLineCount() ;
> 
>         wxString sTmp = strType + wxT(" \\") ;
>         if (!delete_index) file.InsertLine (sTmp, nIndex);
>         if ( ! m_aDescriptions.Item(index).IsEmpty() )
>             {
>             sTmp =     wxT("desc=\"") + m_aDescriptions[index]+ wxT("\" \\") ; //.trim ??
>             if (!delete_index) 
>                 {
>                 nIndex ++ ;
>                 file.InsertLine (sTmp, nIndex);
>                 }
>             }
>         wxString sExts =  m_aExtensions.Item(index) ;   
>         sTmp =     wxT("exts=\"") + sExts.Trim(FALSE).Trim() + wxT("\"") ;
>         if (!delete_index) 
>                 {
>                 nIndex ++ ;
>                 file.InsertLine (sTmp, nIndex);
>                 }
> 
>         bTemp = file.Write ();
>         file.Close ();
>         }
>     return bTemp ;
> }
> 
> 
920c1509
< void wxKDEIconHandler::GetMimeInfoRecords(wxMimeTypesManagerImpl *manager)
---
> bool wxMimeTypesManagerImpl::WriteToMailCap (int index, bool delete_index)
922c1511,1512
<     if ( !m_inited ) Init();
---
> //check we have the right managers
> if (! ( ( m_win_managers & wxWMNETSCAPE) || ( m_win_managers & wxWMBASE) ) ) return FALSE ;
924,926c1514,1523
<     size_t cnt = ms_infoTypes.GetCount();
<     for (unsigned i = 0; i < cnt; i++)
<         manager -> AddMimeTypeInfo(ms_infoTypes[i], ms_infoExtensions[i], ms_infoDescriptions[i]);
---
>     bool bTemp ;
>     wxString strHome = wxGetenv(wxT("HOME"));
> 
>     // and now the users mailcap
>     wxString strUserMailcap = strHome + wxT("/.mailcap");
> 
>     wxMimeTextFile file ;
>     if ( wxFile::Exists(strUserMailcap) ) 
>         { 
>         bTemp =  file.Open(strUserMailcap);
927a1525,1559
>     else 
>         {
>         if (delete_index) return FALSE;
>         bTemp = file.Create(strUserMailcap);
>         }    
>     if (bTemp)
>         {
>         // now got a file we can write to ....
>         wxMimeArrayString * entries = m_aEntries[index] ;
>         size_t iOpen = entries -> pIndexOf(wxT("open")) ;
>         wxString sCmd = entries -> GetCmd(iOpen);
>         wxString sTmp ;
> 
>         sTmp = m_aTypes[index];
>         wxString sOld ;
>         int nIndex = file.pIndexOf(sTmp);
>         // get rid of all the unwanted entries...
>         if (nIndex == wxNOT_FOUND)
>             {
>                 nIndex = (int) file.GetLineCount() ;
>             }
>         else    
>             {
>             sOld = file[nIndex] ;
>             wxLogTrace(TRACE_MIME, wxT("--- Deleting from mailcap line '%d' ---"), nIndex);
> 
>             while ( (sOld.Contains(wxT("\\"))) && (nIndex < (int) file.GetLineCount()) )
>                 {
>                 file.CommentLine(nIndex) ;
>                 if (nIndex < (int) file.GetLineCount()) sOld = sOld + file[nIndex] ;
>                 }
>             if (nIndex < (int) file.GetLineCount()) file.CommentLine (nIndex) ;
>             }
>             
>         sTmp = sTmp + wxT(";") + sCmd ; //includes wxT(" %s ") ;
928a1561,1566
>         // write it in the format that Netscape uses (default)
>         if (! ( m_win_managers & wxWMBASE  ) )
>             {
>             if (! delete_index) file.InsertLine (sTmp, nIndex);
>             nIndex ++ ;
>             }
930,932c1568,1574
< // ----------------------------------------------------------------------------
< // wxFileTypeImpl (Unix)
< // ----------------------------------------------------------------------------
---
>         // write extended format
>         else
>             {
>             // todo FIX this code; 
>             // ii) lost entries
>             // sOld holds all the entries, but our data store only has some
>             // eg test= is not stored
934,935c1576,1578
< MailCapEntry *
< wxFileTypeImpl::GetEntry(const wxFileType::MessageParameters& params) const
---
>             // so far we have written the mimetype and command out
>             wxStringTokenizer sT (sOld, wxT(";\\"));
>             if (sT.CountTokens () > 2)
937,941c1580,1583
<     wxString command;
<     MailCapEntry *entry = m_manager->m_aEntries[m_index[0]];
<     while ( entry != NULL ) {
<         // get the command to run as the test for this entry
<         command = wxFileType::ExpandCommand(entry->GetTestCmd(), params);
---
>                 // first one mimetype; second one command, rest unknown...
>                 wxString s ;
>                 s = sT.GetNextToken();
>                 s = sT.GetNextToken();
943,944c1585,1587
<         // don't trace the test result if there is no test at all
<         if ( command.IsEmpty() )
---
>                 // first unknown
>                 s = sT.GetNextToken();
>                 while ( ! s.IsEmpty() )
946,947c1589,1595
<             // no test at all, ok
<             break;
---
>                     bool bKnownToken = FALSE ;
>                     if (s.Contains(wxT("description="))) bKnownToken = TRUE ;
>                     if (s.Contains(wxT("x11-bitmap="))) bKnownToken = TRUE ;
>                     size_t i ;
>                     for (i=0; i < entries -> GetCount(); i++)
>                         {
>                         if (s.Contains(entries->GetVerb(i))) bKnownToken = TRUE ;
949,955c1597,1601
< 
<         if ( wxSystem(command) == 0 ) {
<             // ok, test passed
<             wxLogTrace(TRACE_MIME,
<                        wxT("Test '%s' for mime type '%s' succeeded."),
<                        command.c_str(), params.GetMimeType().c_str());
<             break;
---
>                     if (!bKnownToken)
>                         {
>                         sTmp = sTmp + wxT("; \\");
>                         file.InsertLine (sTmp, nIndex);
>                         sTmp = s ;    
957,960c1603
<         else {
<             wxLogTrace(TRACE_MIME,
<                        wxT("Test '%s' for mime type '%s' failed."),
<                        command.c_str(), params.GetMimeType().c_str());
---
>                     s = sT.GetNextToken ();
963d1605
<         entry = entry->GetNext();
966c1608,1613
<     return entry;
---
>             if (! m_aDescriptions[index].IsEmpty() ) 
>                 {
>                 sTmp = sTmp + wxT("; \\");
>                 file.InsertLine (sTmp, nIndex);
>                 nIndex ++ ;
>                 sTmp = wxT("       description=\"") + m_aDescriptions[index] + wxT("\"");
969c1616
< bool wxFileTypeImpl::GetIcon(wxIcon *icon) const
---
>             if (! m_aIcons[index].IsEmpty() ) 
971,972c1618,1623
<     wxArrayString mimetypes;
<     GetMimeTypes(mimetypes);
---
>                 sTmp = sTmp + wxT("; \\");
>                 file.InsertLine (sTmp, nIndex);
>                 nIndex ++ ;
>                 sTmp = wxT("       x11-bitmap=\"") + m_aIcons[index] + wxT("\"");
>                 }
>             if ( entries->GetCount() > 1 )
974,977d1624
<     ArrayIconHandlers& handlers = m_manager->GetIconHandlers();
<     size_t count = handlers.GetCount();
<     size_t counttypes = mimetypes.GetCount();
<     for ( size_t n = 0; n < count; n++ )
979c1626,1628
<         for ( size_t n2 = 0; n2 < counttypes; n2++ )
---
>                 size_t i ;
>                 for (i=0; i < entries -> GetCount(); i++)
>                    if ( i != iOpen )
981,982c1630,1633
<             if ( handlers[n]->GetIcon(mimetypes[n2], icon) )
<                 return TRUE;
---
>                    sTmp = sTmp + wxT("; \\");
>                    file.InsertLine (sTmp, nIndex);
>                    nIndex ++ ;
>                    sTmp = wxT("       ") + entries->Item(i) ; 
986c1637,1644
<     return FALSE;
---
>              file.InsertLine (sTmp, nIndex);
>              nIndex ++ ;
> 
>         }
>         bTemp = file.Write ();
>         file.Close ();
>         }
>     return bTemp ;
990,991c1648,1651
< bool 
< wxFileTypeImpl::GetMimeTypes(wxArrayString& mimeTypes) const
---
> 
> 
> wxFileType *
> wxMimeTypesManagerImpl::Associate(const wxFileTypeInfo& ftInfo)
993,997c1653
<     mimeTypes.Clear();
<     for (size_t i = 0; i < m_index.GetCount(); i++)
<         mimeTypes.Add(m_manager->m_aTypes[m_index[i]]);
<     return TRUE;
< }
---
>     InitIfNeeded();
998a1655,1657
>     wxString strType = ftInfo.GetMimeType () ; 
>     wxString strDesc = ftInfo.GetDescription ();
>     wxString strIcon = ftInfo.GetIconFile () ;
1000,1008c1659,1679
< bool
< wxFileTypeImpl::GetExpandedCommand(wxString *expandedCmd,
<                                    const wxFileType::MessageParameters& params,
<                                    bool open) const
< {
<     MailCapEntry *entry = GetEntry(params);
<     if ( entry == NULL ) {
<         // all tests failed...
<         return FALSE;
---
>     wxMimeArrayString *entry = new wxMimeArrayString ();
> 
>     if ( ! ftInfo.GetOpenCommand().IsEmpty())
>         entry -> Add(wxT("open=")  + ftInfo.GetOpenCommand  () + wxT(" %s ")); 
>     if ( ! ftInfo.GetPrintCommand  ().IsEmpty())
>         entry -> Add(wxT("print=") + ftInfo.GetPrintCommand () + wxT(" %s ")); 
> 
>     // now find where these extensions are in the data store and remove them
>     wxArrayString sA_Exts = ftInfo.GetExtensions ();    
>     wxString sExt, sExtStore ;
>     size_t i, nIndex;
>     for (i=0; i < sA_Exts.GetCount(); i++)
>         {
>         sExt = sA_Exts.Item(i) ;
>         //clean up to just a space before and after
>         sExt.Trim().Trim(FALSE);
>         sExt = wxT(' ') + sExt + wxT(' ') ;
>         for (nIndex = 0; nIndex < m_aExtensions.GetCount(); nIndex ++)
>             {
>             sExtStore = m_aExtensions.Item(nIndex) ;
>             if (sExtStore.Replace(sExt, wxT(" ") ) > 0) m_aExtensions.Item(nIndex) = sExtStore  ;
1011,1014d1681
<     wxString cmd = open ? entry->GetOpenCmd() : entry->GetPrintCmd();
<     if ( cmd.IsEmpty() ) {
<         // may happen, especially for "print"
<         return FALSE;
1017,1018c1684,1686
<     *expandedCmd = wxFileType::ExpandCommand(cmd, params);
<     return TRUE;
---
>     if (DoAssociation (strType, strIcon, entry, sA_Exts, strDesc))
>         return GetFileTypeFromMimeType(strType) ;
>     else return NULL ;
1021c1689,1694
< bool wxFileTypeImpl::GetExtensions(wxArrayString& extensions)
---
> 
> bool wxMimeTypesManagerImpl::DoAssociation(const wxString & strType,
>     const  wxString & strIcon,
>     wxMimeArrayString * entry,
>     const  wxArrayString & strExtensions,
>     const  wxString & strDesc )
1023,1024d1695
<     wxString strExtensions = m_manager->GetExtension(m_index[0]);
<     extensions.Empty();
1026,1035c1697
<     // one extension in the space or comma delimitid list
<     wxString strExt;
<     for ( const wxChar *p = strExtensions; ; p++ ) {
<         if ( *p == wxT(' ') || *p == wxT(',') || *p == wxT('\0') ) {
<             if ( !strExt.IsEmpty() ) {
<                 extensions.Add(strExt);
<                 strExt.Empty();
<             }
<             //else: repeated spaces (shouldn't happen, but it's not that
<             //      important if it does happen)
---
>     int nIndex = AddToMimeData (strType, strIcon, entry, strExtensions, strDesc, TRUE);
1037,1050c1699
<             if ( *p == wxT('\0') )
<                 break;
<         }
<         else if ( *p == wxT('.') ) {
<             // remove the dot from extension (but only if it's the first char)
<             if ( !strExt.IsEmpty() ) {
<                 strExt += wxT('.');
<             }
<             //else: no, don't append it
<         }
<         else {
<             strExt += *p;
<         }
<     }
---
>     if ( nIndex == wxNOT_FOUND ) return FALSE ;
1052,1053c1701
<     return TRUE;
< }
---
>     return WriteMimeInfo (nIndex, FALSE);
1055,1057c1703
< // ----------------------------------------------------------------------------
< // wxMimeTypesManagerImpl (Unix)
< // ----------------------------------------------------------------------------
---
> }    
1059,1062c1705
< /* static */
< ArrayIconHandlers& wxMimeTypesManagerImpl::GetIconHandlers()
< {
<     if ( ms_iconHandlers.GetCount() == 0 )
---
> bool wxMimeTypesManagerImpl::WriteMimeInfo(int nIndex, bool delete_mime )
1064,1066c1707
<         ms_iconHandlers.Add(&gs_iconHandlerGNOME);
<         ms_iconHandlers.Add(&gs_iconHandlerKDE);
<     }
---
>     bool result = FALSE ;
1068c1709,1713
<     return ms_iconHandlers;
---
>     if ( m_win_managers & wxWMBASE ) 
>         {
>         // write in metamail  format; 
>         if (WriteToMimeTypes (nIndex, delete_mime) ) 
>               if ( WriteToMailCap   (nIndex, delete_mime) ) result = TRUE ;
1070,1071c1715
< 
< wxMimeTypesManagerImpl::wxMimeTypesManagerImpl()
---
>     if ( m_win_managers & wxWMNETSCAPE ) 
1073c1717,1719
<     m_initialized = FALSE;
---
>         // write in netsacpe format; 
>         if (WriteToNSMimeTypes (nIndex, delete_mime) ) 
>               if ( WriteToMailCap   (nIndex, delete_mime) ) result = TRUE ;
1075,1077c1721
< 
< // read system and user mailcaps and other files
< void wxMimeTypesManagerImpl::Initialize()
---
>     if (m_win_managers & wxWMGNOME)
1079,1087c1723,1727
<     // directories where we look for mailcap and mime.types by default
<     // (taken from metamail(1) sources)
<     //
<     // although RFC 1524 specifies the search path of
<     // /etc/:/usr/etc:/usr/local/etc only, it doesn't hurt to search in more
<     // places - OTOH, the RFC also says that this path can be changed with
<     // MAILCAPS environment variable (containing the colon separated full
<     // filenames to try) which is not done yet (TODO?)
<     static const wxChar *aStandardLocations[] =
---
>         // write in Gnome format;
>         if (WriteGnomeMimeFile (nIndex, delete_mime) ) 
>               if (WriteGnomeKeyFile   (nIndex, delete_mime) ) result = TRUE ;
>         }
>     if (m_win_managers & wxWMKDE)
1089,1094c1729,1731
<         wxT("/etc"),
<         wxT("/usr/etc"),
<         wxT("/usr/local/etc"),
<         wxT("/etc/mail"),
<         wxT("/usr/public/lib")
<     };
---
>         // write in KDE format;
>         if (WriteKDEMimeFile (nIndex, delete_mime) ) result = TRUE ;
>         }
1096,1099d1732
<     // first read the system wide file(s)
<     size_t n;
<     for ( n = 0; n < WXSIZEOF(aStandardLocations); n++ ) {
<         wxString dir = aStandardLocations[n];
1101,1103c1734
<         wxString file = dir + wxT("/mailcap");
<         if ( wxFile::Exists(file) ) {
<             ReadMailcap(file);
---
>     return result ;
1106,1110c1737,1744
<         file = dir + wxT("/mime.types");
<         if ( wxFile::Exists(file) ) {
<             ReadMimeTypes(file);
<         }
<     }
---
> int wxMimeTypesManagerImpl::AddToMimeData(const wxString & strType,
>     const  wxString & strIcon,
>     wxMimeArrayString * entry,
>     const  wxArrayString & strExtensions,
>     const  wxString & strDesc,
>     bool   ReplaceExisting )
> {
>     InitIfNeeded();
1112c1746,1747
<     wxString strHome = wxGetenv(wxT("HOME"));
---
> wxLogTrace(TRACE_MIME, wxT("In Add to Mime data '%s' with %d entries and %d exts ---"),
>                strType.c_str(), entry->GetCount(), strExtensions.GetCount() );
1114,1117c1749,1765
<     // and now the users mailcap
<     wxString strUserMailcap = strHome + wxT("/.mailcap");
<     if ( wxFile::Exists(strUserMailcap) ) {
<         ReadMailcap(strUserMailcap);
---
>     // ensure mimetype is always lower case
>     wxString mimeType = strType ;
>     mimeType.MakeLower() ;
>     int nIndex = m_aTypes.Index(mimeType);
>     if ( nIndex == wxNOT_FOUND ) 
>         {
>         // new file type
>         m_aTypes.Add(mimeType);
>         m_aIcons.Add(strIcon);
>         m_aEntries.Add(entry);
>         size_t i ;
>         // change nIndex so we can add to the correct line
>     nIndex = m_aExtensions.Add(wxT(' '));
>     for (i = 0; i < strExtensions.GetCount(); i ++) 
>             {
>             if (! m_aExtensions.Item(nIndex).Contains(wxT(' ') + strExtensions.Item(i) + wxT(' ')))
>                 m_aExtensions.Item(nIndex) +=  strExtensions.Item(i) + wxT(' ') ;
1118a1767
>         m_aDescriptions.Add(strDesc);
1120,1123d1768
<     // read the users mime.types
<     wxString strUserMimeTypes = strHome + wxT("/.mime.types");
<     if ( wxFile::Exists(strUserMimeTypes) ) {
<         ReadMimeTypes(strUserMimeTypes);
1124a1770,1783
>     else {
>         // nIndex has the existing data
>     // always add the extensions to this mimetype
>     size_t i;
>     for (i = 0; i < strExtensions.GetCount(); i ++) 
>             {
>             if (! m_aExtensions.Item(nIndex).Contains(wxT(' ') + strExtensions.Item(i) + wxT(' ')))
>                 m_aExtensions.Item(nIndex) +=  strExtensions.Item(i) + wxT(' ') ;
>             }
>     if (ReplaceExisting)
>         {    
>             // if new description change it
>         if ( ! strDesc.IsEmpty())
>             m_aDescriptions[nIndex] = strDesc ;
1126,1130c1785,1793
<     // read KDE/GNOME tables
<     ArrayIconHandlers& handlers = GetIconHandlers();
<     size_t count = handlers.GetCount();
<     for ( size_t hn = 0; hn < count; hn++ )
<         handlers[hn]->GetMimeInfoRecords(this);
---
>             // if new icon change it
>         if ( ! strIcon.IsEmpty())
>             m_aIcons[nIndex] = strIcon ;
> 
>         wxMimeArrayString *entryOld  =  m_aEntries[nIndex]; 
>             // replace any matching entries...
>             for (i=0; i < entry -> GetCount(); i++)
>                 entryOld->ReplaceOrAddLineCmd (entry -> GetVerb(i), 
>                                           entry -> GetCmd (i) );
1131a1795,1800
>         else 
>         {
>             // add data we don't already have ...
>             // if new description add only if none
>         if ( ! strDesc.IsEmpty() && m_aDescriptions.Item(i).IsEmpty() )
>             m_aDescriptions[nIndex] = strDesc ;
1132a1802,1804
>             // if new icon and no existing icon
>         if ( ! strIcon.IsEmpty() && m_aIcons.Item(i). IsEmpty () )
>             m_aIcons[nIndex] = strIcon ;
1134c1806,1808
< wxMimeTypesManagerImpl::~wxMimeTypesManagerImpl()
---
>         wxMimeArrayString *entryOld  =  m_aEntries[nIndex]; 
>             // add any new entries...
>             for (i=0; i < entry -> GetCount(); i++)
1136,1138c1810,1812
<     size_t cnt = m_aEntries.GetCount();
<     for (size_t i = 0; i < cnt; i++)
<         delete m_aEntries[i];
---
>                 wxString sVerb = entry -> GetVerb(i) ;
>                 if ( entryOld -> pIndexOf ( sVerb ) == (size_t) wxNOT_FOUND )
>                     entryOld->Add (entry -> Item(i)) ; 
1139a1814,1820
>         }
>     }
>     // check data integrity 
>     wxASSERT( m_aTypes.Count() == m_aEntries.Count() &&
>       m_aTypes.Count() == m_aExtensions.Count() &&
>       m_aTypes.Count() == m_aIcons.Count() &&
>       m_aTypes.Count() == m_aDescriptions.Count() );
1141,1144c1822
< wxFileType *
< wxMimeTypesManagerImpl::Associate(const wxFileTypeInfo& ftInfo)
< {
<     wxFAIL_MSG( _T("unimplemented") ); // TODO
---
>      return nIndex;   
1146d1823
<     return NULL;
1148a1826
> 
1151a1830
>     if (ext.IsEmpty() ) return NULL;
1156c1835,1836
<     for ( size_t n = 0; n < count; n++ ) {
---
>     for ( size_t n = 0; n < count; n++ ) 
>         {
1163c1843,1844
<             if ( field.IsSameAs(ext, FALSE /* no case */) ) {
---
>             if ( field.IsSameAs(ext, FALSE /* no case */) ) 
>                 {
1179a1861
>     wxFileType * fileType = NULL ;
1186c1868,1873
<     if ( index == wxNOT_FOUND ) {
---
>     if ( index != wxNOT_FOUND ) 
>         {
>         fileType = new wxFileType;
>         fileType->m_impl->Init(this, index);
>         }
> 
1189a1877,1878
> 
>     index = wxNOT_FOUND ;
1199c1888
<         }
---
>     
1202,1203c1891,1893
<     if ( index != wxNOT_FOUND ) {
<         wxFileType *fileType = new wxFileType;
---
>     if ( index != wxNOT_FOUND )
>         {
>         fileType = new wxFileType;
1205c1895
< 
---
>         }
1208,1210c1898,1911
<     else {
<         // not found...
<         return NULL;
---
> 
> 
> wxString wxMimeTypesManagerImpl::GetCommand(const wxString & verb, size_t nIndex) const
> {
>     wxString command, testcmd, sV, sTmp;
>     sV = verb + wxT("="); 
>     // list of verb = command pairs for this mimetype
>     wxMimeArrayString * sPairs = m_aEntries [nIndex];
> 
>     size_t i ;
>     for ( i = 0; i < sPairs -> GetCount () ; i++ )
>         {
>             sTmp = sPairs -> Item (i) ;       
>             if ( sTmp.Contains(sV) ) command = sTmp.AfterFirst(wxT('=')) ;
1211a1913
>     return command ;
1243d1944
<     InitIfNeeded();
1245,1258c1946,1959
<     int index = m_aTypes.Index(strMimeType);
<     if ( index == wxNOT_FOUND ) {
<         // add a new entry
<         m_aTypes.Add(strMimeType);
<         m_aEntries.Add(NULL);
<         m_aExtensions.Add(strExtensions);
<         m_aDescriptions.Add(strDesc);
<     }
<     else {
<         // modify an existing one
<         if ( !strDesc.IsEmpty() ) {
<             m_aDescriptions[index] = strDesc;   // replace old value
<         }
<         m_aExtensions[index] += ' ' + strExtensions;
---
> // reading mailcap may find image/* , while
> // reading mime.types finds image/gif and no match is made
> // this means all the get functions don't work  fix this 
>     wxString strIcon ;
>     wxString sTmp = strExtensions ;
>     wxMimeArrayString * entry = new wxMimeArrayString ()  ;
>     
>     wxArrayString sExts;
>     sTmp.Trim().Trim(FALSE);
>     
>     while (!sTmp.IsEmpty())
>         {
>         sExts.Add (sTmp.AfterLast(wxT(' '))) ;
>         sTmp = sTmp.BeforeLast(wxT(' ')) ;
1259a1961,1962
>     
>     AddToMimeData (strMimeType, strIcon, entry, sExts, strDesc, (bool)TRUE);
1270c1973,1976
<     MailCapEntry *entry = new MailCapEntry(strOpenCmd, strPrintCmd, strTest);
---
>     wxMimeArrayString *entry = new wxMimeArrayString ;
>     entry -> Add(wxT("open=")  + strOpenCmd);
>     entry -> Add(wxT("print=") + strPrintCmd);
>     entry -> Add(wxT("test=")  + strTest);
1272,1275c1978,1981
<     int nIndex = m_aTypes.Index(strType);
<     if ( nIndex == wxNOT_FOUND ) {
<         // new file type
<         m_aTypes.Add(strType);
---
>     wxString strIcon ;
>     wxArrayString strExtensions ;
> 
>     AddToMimeData (strType, strIcon, entry, strExtensions, strDesc, TRUE);
1277,1289d1982
<         m_aEntries.Add(entry);
<         m_aExtensions.Add(wxT(""));
<         m_aDescriptions.Add(strDesc);
<     }
<     else {
<         // always append the entry in the tail of the list - info added with
<         // this function can only come from AddFallbacks()
<         MailCapEntry *entryOld = m_aEntries[nIndex];
<         if ( entryOld )
<             entry->Append(entryOld);
<         else
<             m_aEntries[nIndex] = entry;
<     }
1432a2126,2128
>     wxLogTrace(TRACE_MIME, wxT("--- Found Mimetype '%s' ---"),
>                strMimeType.c_str());
> 
1439,1443d2134
<     // check our data integriry
<     wxASSERT( m_aTypes.Count() == m_aEntries.Count() &&
<               m_aTypes.Count() == m_aExtensions.Count() &&
<               m_aTypes.Count() == m_aDescriptions.Count() );
< 
1449a2141
> //    wxLog::AddTraceMask (TRACE_MIME);
1463c2155
<     wxArrayInt aLastIndices;
---
>   //  wxArrayInt aLastIndices;
1492a2185,2186
>         wxMimeArrayString *entry ;
> 
1495c2189
<                  strPrintCmd,
---
>                  strIcon,
1499a2194
>         bool test_passed = TRUE;
1560a2256,2257
>                             entry = new wxMimeArrayString ();
>                             entry -> Add(wxT("open=")  + strOpenCmd);
1569a2267,2268
>                                 if ( IsKnownUnimportantField(curField) ) ok = FALSE ;
>                                 
1572c2271,2274
<                                 if ( pEq != NULL ) {
---
>                                 if (ok) 
>                                 {
>                                 if ( pEq != NULL ) 
>                                     {
1579,1583d2280
<                                     if ( lhs == wxT("print") )
<                                         strPrintCmd = rhs;
<                                     else if ( lhs == wxT("test") )
<                                         strTest = rhs;
<                                     else if ( lhs == wxT("description") ) {
1585,1588c2282,2298
<                                         if ( rhs[0u] == wxT('"') &&
<                                              rhs.Last() == wxT('"') ) {
<                                             strDesc = wxString(rhs.c_str() + 1,
<                                                                rhs.Len() - 2);
---
>                                     if ( rhs[0u] == wxT('"') && rhs.Last() == wxT('"') ) 
>                                         {
>                                         wxString sTmp = wxString(rhs.c_str() + 1, rhs.Len() - 2);
>                                         rhs = sTmp ;
>                                         }
>                                     bool verbfound = TRUE ;    
>                                     if ( lhs.Contains (wxT("test")))
>                                         {
>                                         if ( ! rhs.IsEmpty() )
>                                             {
>                                             if ( wxSystem(rhs) == 0 ) {
>                                                 // ok, test passed
>                                                 test_passed = TRUE ;
>                                                 wxLogTrace(TRACE_MIME,
>                                                            wxT("Test '%s' for mime type '%s' succeeded."),
>                                                            rhs.c_str(), strType.c_str());
> 
1590a2301,2310
>                                                 test_passed = FALSE ;
>                                                 wxLogTrace(TRACE_MIME,
>                                                            wxT("Test '%s' for mime type '%s' failed."),
>                                                            rhs.c_str(), strType.c_str());
>                                             }   
>                                         }    
>                                         verbfound = FALSE ;
>                                         }     
>                                     if ( lhs.Contains (wxT("desc"))) 
>                                         {
1591a2312
>                                         verbfound = FALSE ;
1592a2314,2317
>                                     if ( lhs.Contains (wxT("x11-bitmap"))) 
>                                         {
>                                         strIcon = rhs ;
>                                         verbfound = FALSE ;
1594,1601c2319,2322
<                                     else if ( lhs == wxT("compose") ||
<                                               lhs == wxT("composetyped") ||
<                                               lhs == wxT("notes") ||
<                                               lhs == wxT("edit") )
<                                         ;   // ignore
<                                     else
<                                         ok = FALSE;
< 
---
>                                     if ( lhs.Contains (wxT("notes"))) 
>                                         {
>                                         // ignore    
>                                         verbfound = FALSE ;
1603c2324,2328
<                                 else {
---
>                                     if (verbfound) entry -> Add ( lhs + wxT('=') + rhs );
>                                     ok = TRUE ;
>                                     }
>                                   else
>                                     {
1605c2330
<                                     if ( curField == wxT("needsterminal") )
---
>                                         if ( curField == wxT("needsterminal") ) {
1607c2332,2334
<                                     else if ( curField == wxT("copiousoutput")) {
---
>                                             ok = TRUE ;
>                                             }
>                                         if ( curField == wxT("copiousoutput")) {
1611,1617c2338,2339
<                                         copiousoutput = TRUE;
<                                     }
<                                     else {
<                                         // unknown flag
<                                         ok = FALSE;
<                                     }
<                                 }
---
>                                             copiousoutput = 
>                                             ok = TRUE;
1621,1622d2342
<                                     if ( !IsKnownUnimportantField(curField) )
<                                     {
1637a2358,2362
> 
>                                             }
> 
>                                         }
>                                     
1638a2364
>                                 
1639a2366
>                                 
1641c2368
<                             //else: the field is empty, ignore silently
---
> 
1678c2405,2406
<             if ( copiousoutput ) {
---
>             if ( copiousoutput ) 
>                {
1680a2409,2411
>     wxLogTrace(TRACE_MIME, wxT("Replacing .(for pager)...") + entry->Item(0u) + wxT("with") + strOpenCmd );
>                 
>                 entry -> ReplaceOrAddLineCmd (wxString(wxT("open")), strOpenCmd );
1683c2414,2415
<             if ( needsterminal ) {
---
>             if ( needsterminal ) 
>                 {
1686c2418
<             }
---
>     wxLogTrace(TRACE_MIME, wxT("Replacing .(for needs term)...") + entry->Item(0u) + wxT("with") + strOpenCmd );
1688,1690c2420,2421
<             MailCapEntry *entry = new MailCapEntry(strOpenCmd,
<                                                    strPrintCmd,
<                                                    strTest);
---
>                 entry -> ReplaceOrAddLineCmd (wxString(wxT("open")), strOpenCmd );
>                 }
1691a2423
> //
1693a2426,2427
>             if ( test_passed )
>                 {
1695,1720c2429,2432
<             int nIndex = m_aTypes.Index(strType);
<             if ( nIndex == wxNOT_FOUND ) {
<                 // new file type
<                 m_aTypes.Add(strType);
< 
<                 m_aEntries.Add(entry);
<                 m_aExtensions.Add(wxT(""));
<                 m_aDescriptions.Add(strDesc);
<             }
<             else {
<                 // modify the existing entry: the entries in one and the same
<                 // file are read in top-to-bottom order, i.e. the entries read
<                 // first should be tried before the entries below. However,
<                 // the files read later should override the settings in the
<                 // files read before (except if fallback is TRUE), thus we
<                 // Insert() the new entry to the list if it has already
<                 // occured in _this_ file, but Prepend() it if it occured in
<                 // some of the previous ones and Append() to it in the
<                 // fallback case
< 
<                 if ( fallback ) {
<                     // 'fallback' parameter prevents the entries from this
<                     // file from overriding the other ones - always append
<                     MailCapEntry *entryOld = m_aEntries[nIndex];
<                     if ( entryOld )
<                         entry->Append(entryOld);
---
>                 bool overwrite = TRUE ;
>                 int entryIndex  ;
>                 if (fallback) 
>                     overwrite = FALSE ;
1722,1727c2434,2442
<                         m_aEntries[nIndex] = entry;
<                 }
<                 else {
<                     int entryIndex = aEntryIndices.Index(nIndex);
<                     if ( entryIndex == wxNOT_FOUND ) {
<                         // first time in this file
---
>                     {
>                     int nIndex = m_aTypes.Index(strType);
>                     entryIndex = aEntryIndices.Index(nIndex);
>                     if ( entryIndex == wxNOT_FOUND ) 
>                        {
>       //check this fix
>                         // first time in this file, so replace the icons, entries
>                         // and description (no extensions to replace so ignore these
>                         overwrite = TRUE;
1729,1732c2444
<                         aLastIndices.Add(0);
< 
<                         entry->Prepend(m_aEntries[nIndex]);
<                         m_aEntries[nIndex] = entry;
---
>                         //aLastIndices.Add(0);
1736,1742c2448,2450
<                         size_t nEntryIndex = (size_t)entryIndex;
<                         MailCapEntry *entryOld = m_aEntries[nIndex];
<                         if ( entryOld )
<                             entry->Insert(entryOld, aLastIndices[nEntryIndex]);
<                         else
<                             m_aEntries[nIndex] = entry;
< 
---
>                         // so we don't want to overwrite 
>                         // existing entries,but want to add to them
>                         // so we don't alter the mimetype
1744,1745c2452
<                         aLastIndices[nEntryIndex]++;
<                     }
---
>                         overwrite = FALSE ;
1748,1750c2455
<                 if ( !strDesc.IsEmpty() ) {
<                     // replace the old one - what else can we do??
<                     m_aDescriptions[nIndex] = strDesc;
---
> 
1751a2457,2459
>                 wxArrayString strExtensions ;  
>                 AddToMimeData (strType, strIcon, entry, strExtensions, strDesc, !overwrite );                
>                 test_passed = TRUE ;
1755,1758d2462
<         // check our data integriry
<         wxASSERT( m_aTypes.Count() == m_aEntries.Count() &&
<                   m_aTypes.Count() == m_aExtensions.Count() &&
<                   m_aTypes.Count() == m_aDescriptions.Count() );
1789c2493
< bool wxFileTypeImpl::Unassociate()
---
> bool wxMimeTypesManagerImpl::Unassociate(wxFileType *ft) 
1791c2495,2496
<     wxFAIL_MSG( _T("unimplemented") ); // TODO
---
>    wxArrayString sMimeTypes ;
>    ft -> GetMimeTypes (sMimeTypes) ;
1792a2498,2506
>    wxString sMime ;
>    size_t i;
>    for (i = 0; i < sMimeTypes.GetCount(); i ++)
>    {
>        sMime = sMimeTypes.Item(i) ;
>        int nIndex = m_aTypes.Index (sMime) ;
>        if ( nIndex == wxNOT_FOUND)
>             {
>             // error if we get here ??
1793a2508,2525
>             }
>        else 
>             { 
>             WriteMimeInfo(nIndex, TRUE ) ;
>             m_aTypes.Remove (nIndex);
>             m_aEntries.Remove (nIndex);
>             m_aExtensions.Remove (nIndex);
>             m_aDescriptions.Remove (nIndex);
>             m_aIcons.Remove (nIndex);
>             }
>     }
>         // check data integrity 
>     wxASSERT( m_aTypes.Count() == m_aEntries.Count() &&
>       m_aTypes.Count() == m_aExtensions.Count() &&
>       m_aTypes.Count() == m_aIcons.Count() &&
>       m_aTypes.Count() == m_aDescriptions.Count() );
> 
>     return TRUE;


 	  	 
