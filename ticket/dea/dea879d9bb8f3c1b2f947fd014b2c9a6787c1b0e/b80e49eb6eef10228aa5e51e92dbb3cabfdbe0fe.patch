Index: build/bakefiles/files.bkl
===================================================================
--- build/bakefiles/files.bkl	(revision 53156)
+++ build/bakefiles/files.bkl	(working copy)
@@ -2815,6 +2815,7 @@
 
 <set var="ADVANCED_CMN_SRC" hints="files">
     src/common/animatecmn.cpp
+    src/common/bmpcboxcmn.cpp
     src/common/calctrlcmn.cpp
     src/common/datavcmn.cpp
     src/common/hyperlnkcmn.cpp
@@ -2897,11 +2898,13 @@
 
 <!-- not used with wxUniv -->
 <set var="ADVANCED_MSW_NATIVE_SRC" hints="files">
+    src/msw/bmpcbox.cpp
     src/msw/calctrl.cpp
     src/msw/datecontrols.cpp
     src/msw/datectrl.cpp
 </set>
 <set var="ADVANCED_MSW_NATIVE_HDR" hints="files">
+    wx/msw/bmpcbox.h
     wx/msw/calctrl.h
     wx/msw/datecontrols.h
     wx/msw/datectrl.h
Index: src/common/bmpcboxcmn.cpp
===================================================================
--- src/common/bmpcboxcmn.cpp	(revision 0)
+++ src/common/bmpcboxcmn.cpp	(revision 0)
@@ -0,0 +1,247 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        src/common/bmpcboxcmn.cpp
+// Purpose:     wxBitmapComboBox
+// Author:      Jaakko Salli
+// Modified by:
+// Created:     Apr-9-2008
+// RCS-ID:      $Id:
+// Copyright:   (c) Jaakko Salli
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+// ============================================================================
+// declarations
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// headers
+// ----------------------------------------------------------------------------
+
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#include "wx/bmpcbox.h"
+
+#if wxUSE_BITMAPCOMBOBOX
+
+#ifndef WX_PRECOMP
+    #include "wx/log.h"
+#endif
+
+#include "wx/settings.h"
+
+// For wxODCB_XXX flags
+#include "wx/odcombo.h"
+
+
+const wxChar wxBitmapComboBoxNameStr[] = wxT("bitmapComboBox");
+
+#if defined(wxBITMAPCOMBOBOX_OWNERDRAWN_BASED)
+
+#define IMAGE_SPACING_RIGHT         4  // Space left of image
+
+#define IMAGE_SPACING_LEFT          4  // Space right of image, left of text
+
+#define EXTRA_FONT_HEIGHT           0  // Add to increase min. height of list items
+
+#define wxBCB_DEFAULT_ITEM_HEIGHT  13
+
+
+// This macros allows wxArrayPtrVoid to be used in more convenient manner
+#define GetBitmapPtr(n)     ((wxBitmap*)m_bitmaps[n])
+
+
+// ----------------------------------------------------------------------------
+// Initialization
+// ----------------------------------------------------------------------------
+
+void wxBitmapComboBoxBase::Init()
+{
+    m_fontHeight = 0;
+    m_imgAreaWidth = 0;
+    m_indent = 0;
+    m_usedImgSize = wxSize(-1, -1);
+}
+
+void wxBitmapComboBoxBase::UpdateInternals()
+{
+    m_fontHeight = GetControl()->GetCharHeight() + EXTRA_FONT_HEIGHT;
+
+    while ( m_bitmaps.GetCount() < GetItemContainer()->GetCount() )
+        m_bitmaps.Add( new wxBitmap() );
+}
+
+// ----------------------------------------------------------------------------
+// Item manipulation
+// ----------------------------------------------------------------------------
+
+void wxBitmapComboBoxBase::DoSetItemBitmap(unsigned int n, const wxBitmap& bitmap)
+{
+    wxCHECK_RET( n < m_bitmaps.size(), wxT("invalid item index") );
+    *GetBitmapPtr(n) = bitmap;
+}
+
+wxBitmap wxBitmapComboBoxBase::GetItemBitmap(unsigned int n) const
+{
+    wxCHECK_MSG( n < m_bitmaps.size(), wxNullBitmap, wxT("invalid item index") );
+    return *GetBitmapPtr(n);
+}
+
+// ----------------------------------------------------------------------------
+// wxItemContainer methods
+// ----------------------------------------------------------------------------
+
+void wxBitmapComboBoxBase::BCBDoClear()
+{
+    unsigned int i;
+
+    for ( i=0; i<m_bitmaps.size(); i++ )
+        delete GetBitmapPtr(i);
+
+    m_bitmaps.Empty();
+
+    m_usedImgSize.x = -1;
+    m_usedImgSize.y = -1;
+
+    DetermineIndent();
+}
+
+void wxBitmapComboBoxBase::BCBDoDeleteOneItem(unsigned int n)
+{
+    delete GetBitmapPtr(n);
+    m_bitmaps.RemoveAt(n);
+}
+
+// ----------------------------------------------------------------------------
+// Preparation and Calculations
+// ----------------------------------------------------------------------------
+
+bool wxBitmapComboBoxBase::OnAddBitmap(const wxBitmap& bitmap)
+{
+    if ( bitmap.Ok() )
+    {
+        int width = bitmap.GetWidth();
+        int height = bitmap.GetHeight();
+
+        if ( m_usedImgSize.x < 0 )
+        {
+            //
+            // If size not yet determined, get it from this image.
+            m_usedImgSize.x = width;
+            m_usedImgSize.y = height;
+
+            // Adjust control size to vertically fit the bitmap
+            wxWindow* ctrl = GetControl();
+            ctrl->InvalidateBestSize();
+            wxSize newSz = ctrl->GetBestSize();
+            wxSize sz = ctrl->GetSize();
+            if ( newSz.y > sz.y )
+                ctrl->SetSize(sz.x, newSz.y);
+            else
+                DetermineIndent();
+        }
+
+        wxCHECK_MSG(width == m_usedImgSize.x && height == m_usedImgSize.y,
+                    false,
+                    wxT("you can only add images of same size"));
+
+        return true;
+    }
+
+    return false;
+}
+
+int wxBitmapComboBoxBase::DetermineIndent()
+{
+    //
+    // Recalculate amount of empty space needed in front of
+    // text in control itself.
+    int indent = m_imgAreaWidth = 0;
+
+    if ( m_usedImgSize.x > 0 )
+    {
+        indent = m_usedImgSize.x + IMAGE_SPACING_LEFT + IMAGE_SPACING_RIGHT;
+        m_imgAreaWidth = indent;
+
+        indent -= 3;
+    }
+
+    return indent;
+}
+
+// ----------------------------------------------------------------------------
+// Item drawing and measuring
+// ----------------------------------------------------------------------------
+
+void wxBitmapComboBoxBase::DrawBackground(wxDC& dc,
+                                          const wxRect& rect,
+                                          int WXUNUSED(item),
+                                          int flags) const
+{
+    if ( flags & wxODCB_PAINTING_SELECTED )
+    {
+        const int vSizeDec = 0;  // Vertical size reduction of selection rectangle edges
+
+        dc.SetTextForeground(wxSystemSettings::GetColour(wxSYS_COLOUR_HIGHLIGHTTEXT));
+
+        wxColour selCol = wxSystemSettings::GetColour(wxSYS_COLOUR_HIGHLIGHT);
+        dc.SetPen(selCol);
+        dc.SetBrush(selCol);
+        dc.DrawRectangle(rect.x,
+                         rect.y+vSizeDec,
+                         rect.width,
+                         rect.height-(vSizeDec*2));
+    }
+    else
+    {
+        dc.SetTextForeground(wxSystemSettings::GetColour(wxSYS_COLOUR_WINDOWTEXT));
+
+        wxColour selCol = wxSystemSettings::GetColour(wxSYS_COLOUR_WINDOW);
+        dc.SetPen(selCol);
+        dc.SetBrush(selCol);
+        dc.DrawRectangle(rect);
+    }
+}
+
+void wxBitmapComboBoxBase::DrawItem(wxDC& dc,
+                                    const wxRect& rect,
+                                    int item,
+                                    const wxString& text,
+                                    int WXUNUSED(flags)) const
+{
+    const wxBitmap& bmp = *GetBitmapPtr(item);
+    if ( bmp.Ok() )
+    {
+        wxCoord w = bmp.GetWidth();
+        wxCoord h = bmp.GetHeight();
+
+        // Draw the image centered
+        dc.DrawBitmap(bmp,
+                      rect.x + (m_usedImgSize.x-w)/2 + IMAGE_SPACING_LEFT,
+                      rect.y + (rect.height-h)/2,
+                      true);
+    }
+
+    if ( text.length() )
+        dc.DrawText(text,
+                    rect.x + m_imgAreaWidth + 1,
+                    rect.y + (rect.height-dc.GetCharHeight())/2);
+}
+
+wxCoord wxBitmapComboBoxBase::MeasureItem(size_t WXUNUSED(item)) const
+{
+    if ( m_usedImgSize.y >= 0 )
+    {
+        int imgHeightArea = m_usedImgSize.y + 2;
+        return imgHeightArea > m_fontHeight ? imgHeightArea : m_fontHeight;
+    }
+    
+    return wxBCB_DEFAULT_ITEM_HEIGHT;
+}
+
+#endif // wxBITMAPCOMBOBOX_OWNERDRAWN_BASED
+
+#endif // wxUSE_BITMAPCOMBOBOX
Index: src/msw/bmpcbox.cpp
===================================================================
--- src/msw/bmpcbox.cpp	(revision 0)
+++ src/msw/bmpcbox.cpp	(revision 0)
@@ -0,0 +1,388 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        src/msw/bmpcboxg.cpp
+// Purpose:     wxBitmapComboBox
+// Author:      Jaakko Salli
+// Modified by:
+// Created:     Apr-06-2008
+// RCS-ID:      $Id:
+// Copyright:   (c) Jaakko Salli
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+// ============================================================================
+// declarations
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// headers
+// ----------------------------------------------------------------------------
+
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#if wxUSE_BITMAPCOMBOBOX
+
+#include "wx/bmpcbox.h"
+
+#ifndef WX_PRECOMP
+    #include "wx/log.h"
+#endif
+
+#include "wx/settings.h"
+
+#include "wx/msw/dcclient.h"
+#include "wx/msw/private.h"
+
+// For wxODCB_XXX flags
+#include "wx/odcombo.h"
+
+
+#define IMAGE_SPACING_CTRL_VERTICAL 7  // Spacing used in control size calculation
+
+
+// ============================================================================
+// implementation
+// ============================================================================
+
+
+BEGIN_EVENT_TABLE(wxBitmapComboBox, wxComboBox)
+    EVT_SIZE(wxBitmapComboBox::OnSize)
+END_EVENT_TABLE()
+
+
+IMPLEMENT_DYNAMIC_CLASS(wxBitmapComboBox, wxComboBox)
+
+
+// ----------------------------------------------------------------------------
+// wxBitmapComboBox creation
+// ----------------------------------------------------------------------------
+
+void wxBitmapComboBox::Init()
+{
+    m_inResize = false;
+}
+
+wxBitmapComboBox::wxBitmapComboBox(wxWindow *parent,
+                                  wxWindowID id,
+                                  const wxString& value,
+                                  const wxPoint& pos,
+                                  const wxSize& size,
+                                  const wxArrayString& choices,
+                                  long style,
+                                  const wxValidator& validator,
+                                  const wxString& name)
+    : wxComboBox(),
+      wxBitmapComboBoxBase()
+{
+    Init();
+
+    Create(parent,id,value,pos,size,choices,style,validator,name);
+}
+
+bool wxBitmapComboBox::Create(wxWindow *parent,
+                              wxWindowID id,
+                              const wxString& value,
+                              const wxPoint& pos,
+                              const wxSize& size,
+                              const wxArrayString& choices,
+                              long style,
+                              const wxValidator& validator,
+                              const wxString& name)
+{
+    wxCArrayString chs(choices);
+    return Create(parent, id, value, pos, size, chs.GetCount(),
+                  chs.GetStrings(), style, validator, name);
+}
+
+bool wxBitmapComboBox::Create(wxWindow *parent,
+                              wxWindowID id,
+                              const wxString& value,
+                              const wxPoint& pos,
+                              const wxSize& size,
+                              int n,
+                              const wxString choices[],
+                              long style,
+                              const wxValidator& validator,
+                              const wxString& name)
+{
+    if ( !wxComboBox::Create(parent, id, value, pos, size,
+                             n, choices, style, validator, name) )
+        return false;
+
+    UpdateInternals();
+
+    return true;
+}
+
+WXDWORD wxBitmapComboBox::MSWGetStyle(long style, WXDWORD *exstyle) const
+{
+    return wxComboBox::MSWGetStyle(style, exstyle) | CBS_OWNERDRAWFIXED | CBS_HASSTRINGS;
+}
+
+void wxBitmapComboBox::RecreateControl()
+{
+    //
+    // Recreate control so that WM_MEASUREITEM gets called again.
+    // Can't use CBS_OWNERDRAWVARIABLE because it has odd
+    // mouse-wheel behaviour.
+    //
+    wxString value = GetValue();
+    wxPoint pos = GetPosition();
+    wxSize size = GetSize();
+    wxArrayString strings = GetStrings();
+
+    wxComboBox::DoClear();
+
+    HWND hwnd = GetHwnd();
+    DissociateHandle();
+    ::DestroyWindow(hwnd);
+
+    if ( !MSWCreateControl(wxT("COMBOBOX"), value, pos, size) )
+        return;
+
+    // initialize the controls contents
+    for ( unsigned int i = 0; i < strings.size(); i++ )
+    {
+        wxComboBox::Append(strings[i]);
+    }
+
+    // and make sure it has the same attributes as before
+    if ( m_hasFont )
+    {
+        // calling SetFont(m_font) would do nothing as the code would
+        // notice that the font didn't change, so force it to believe
+        // that it did
+        wxFont font = m_font;
+        m_font = wxNullFont;
+        SetFont(font);
+    }
+
+    if ( m_hasFgCol )
+    {
+        wxColour colFg = m_foregroundColour;
+        m_foregroundColour = wxNullColour;
+        SetForegroundColour(colFg);
+    }
+
+    if ( m_hasBgCol )
+    {
+        wxColour colBg = m_backgroundColour;
+        m_backgroundColour = wxNullColour;
+        SetBackgroundColour(colBg);
+    }
+    else
+    {
+        SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_WINDOW));
+    }
+}
+
+wxBitmapComboBox::~wxBitmapComboBox()
+{
+    Clear();
+}
+
+// ----------------------------------------------------------------------------
+// Item manipulation
+// ----------------------------------------------------------------------------
+
+void wxBitmapComboBox::SetItemBitmap(unsigned int n, const wxBitmap& bitmap)
+{
+    OnAddBitmap(bitmap);
+    DoSetItemBitmap(n, bitmap);
+
+    if ( (int)n == GetSelection() )
+        Refresh();
+}
+
+int wxBitmapComboBox::Append(const wxString& item, const wxBitmap& bitmap)
+{
+    OnAddBitmap(bitmap);
+    const int n = wxComboBox::Append(item);
+    if(n != wxNOT_FOUND)
+        DoSetItemBitmap(n, bitmap);
+    return n;
+}
+
+int wxBitmapComboBox::Append(const wxString& item, const wxBitmap& bitmap,
+                             void *clientData)
+{
+    OnAddBitmap(bitmap);
+    const int n = wxComboBox::Append(item, clientData);
+    if(n != wxNOT_FOUND)
+        DoSetItemBitmap(n, bitmap);
+    return n;
+}
+
+int wxBitmapComboBox::Append(const wxString& item, const wxBitmap& bitmap,
+                             wxClientData *clientData)
+{
+    OnAddBitmap(bitmap);
+    const int n = wxComboBox::Append(item, clientData);
+    if(n != wxNOT_FOUND)
+        DoSetItemBitmap(n, bitmap);
+    return n;
+}
+
+int wxBitmapComboBox::Insert(const wxString& item,
+                             const wxBitmap& bitmap,
+                             unsigned int pos)
+{
+    OnAddBitmap(bitmap);
+    const int n = wxComboBox::Insert(item, pos);
+    if(n != wxNOT_FOUND)
+        DoSetItemBitmap(n, bitmap);
+    return n;
+}
+
+int wxBitmapComboBox::Insert(const wxString& item, const wxBitmap& bitmap,
+                             unsigned int pos, wxClientData *clientData)
+{
+    OnAddBitmap(bitmap);
+    const int n = wxComboBox::Insert(item, pos, clientData);
+    if(n != wxNOT_FOUND)
+        DoSetItemBitmap(n, bitmap);
+    return n;
+}
+
+int wxBitmapComboBox::DoInsertItems(const wxArrayStringsAdapter & items,
+                                    unsigned int pos,
+                                    void **clientData, wxClientDataType type)
+{
+    const unsigned int numItems = items.GetCount();
+    const unsigned int countNew = GetCount() + numItems;
+
+    m_bitmaps.Alloc(countNew);
+
+    for ( unsigned int i = 0; i < numItems; i++ )
+    {
+        m_bitmaps.Insert(new wxBitmap(wxNullBitmap), pos + i);
+    }
+
+    const int index = wxComboBox::DoInsertItems(items, pos,
+                                                clientData, type);
+
+    if ( index == wxNOT_FOUND )
+    {
+        for ( int i = (numItems-1); i >= 0; i-- )
+            BCBDoDeleteOneItem(pos + i);
+    }
+
+    return index;
+}
+
+bool wxBitmapComboBox::OnAddBitmap(const wxBitmap& bitmap)
+{
+    if ( wxBitmapComboBoxBase::OnAddBitmap(bitmap) )
+    {
+        // Need to recreate control for a new measureitem call?
+        int prevItemHeight = ::SendMessage(GetHwnd(), CB_GETITEMHEIGHT, 0, 0);
+
+        if ( prevItemHeight != MeasureItem(0) )
+            RecreateControl();
+
+        return true;
+    }
+    
+    return false;
+}
+
+void wxBitmapComboBox::DoClear()
+{
+    wxComboBox::DoClear();
+    wxBitmapComboBoxBase::BCBDoClear();
+}
+
+void wxBitmapComboBox::DoDeleteOneItem(unsigned int n)
+{
+    wxComboBox::DoDeleteOneItem(n);
+    wxBitmapComboBoxBase::BCBDoDeleteOneItem(n);
+}
+
+// ----------------------------------------------------------------------------
+// wxBitmapComboBox event handlers and such
+// ----------------------------------------------------------------------------
+
+void wxBitmapComboBox::OnSize(wxSizeEvent& event)
+{
+    // Prevent infinite looping
+    if ( !m_inResize )
+    {
+        m_inResize = true;
+        DetermineIndent();
+        m_inResize = false;
+    }
+
+    event.Skip();
+}
+
+// ----------------------------------------------------------------------------
+// wxBitmapComboBox miscellaneous
+// ----------------------------------------------------------------------------
+
+bool wxBitmapComboBox::SetFont(const wxFont& font)
+{
+    bool res = wxComboBox::SetFont(font);
+    UpdateInternals();
+    return res;
+}
+
+// ----------------------------------------------------------------------------
+// wxBitmapComboBox item drawing and measuring
+// ----------------------------------------------------------------------------
+
+bool wxBitmapComboBox::MSWOnDraw(WXDRAWITEMSTRUCT *item)
+{
+    LPDRAWITEMSTRUCT lpDrawItem = (LPDRAWITEMSTRUCT) item;
+    int pos = lpDrawItem->itemID;
+
+    // Draw default for item -1, which means 'focus rect only'
+    if ( pos == -1 )
+        return FALSE;
+
+    int flags = 0;                
+    if ( lpDrawItem->itemState & ODS_COMBOBOXEDIT )
+        flags |= wxODCB_PAINTING_CONTROL;
+    if ( lpDrawItem->itemState & ODS_SELECTED )
+        flags |= wxODCB_PAINTING_SELECTED;
+
+    wxString text;
+
+    if ( flags & wxODCB_PAINTING_CONTROL )
+    {
+        text = GetValue();
+        if ( !HasFlag(wxCB_READONLY) )
+            text.clear();
+    }
+    else
+    {
+        text = GetString(pos);
+    }
+
+    wxPaintDCEx dc(this, lpDrawItem->hDC);
+    wxRect rect = wxRectFromRECT(lpDrawItem->rcItem);
+    wxBitmapComboBoxBase::DrawBackground(dc, rect, pos, flags);
+    wxBitmapComboBoxBase::DrawItem(dc, rect, pos, text, flags);
+
+    // If the item has the focus, draw focus rectangle.
+    // Commented out since regular combo box doesn't
+    // seem to do it either.
+    //if ( lpDrawItem->itemState & ODS_FOCUS )
+    //    DrawFocusRect(lpDrawItem->hDC, &lpDrawItem->rcItem);
+
+    return TRUE;
+}
+
+bool wxBitmapComboBox::MSWOnMeasure(WXMEASUREITEMSTRUCT *item)
+{
+    LPMEASUREITEMSTRUCT lpMeasureItem = (LPMEASUREITEMSTRUCT) item;
+    int pos = lpMeasureItem->itemID;
+
+    lpMeasureItem->itemHeight = wxBitmapComboBoxBase::MeasureItem(pos);
+
+    return TRUE;
+}
+
+#endif // wxUSE_BITMAPCOMBOBOX
Index: src/generic/bmpcboxg.cpp
===================================================================
--- src/generic/bmpcboxg.cpp	(revision 53156)
+++ src/generic/bmpcboxg.cpp	(working copy)
@@ -42,24 +42,9 @@
 #endif
 
 
-const wxChar wxBitmapComboBoxNameStr[] = wxT("bitmapComboBox");
-
-
-// These macros allow wxArrayPtrVoid to be used in more convenient manner
-#define GetBitmapPtr(n)     ((wxBitmap*)m_bitmaps[n])
-
-
-#define IMAGE_SPACING_RIGHT         4  // Space left of image
-
-#define IMAGE_SPACING_LEFT          4  // Space right of image, left of text
-
-#define IMAGE_SPACING_VERTICAL      2  // Space top and bottom of image
-
 #define IMAGE_SPACING_CTRL_VERTICAL 7  // Spacing used in control size calculation
 
-#define EXTRA_FONT_HEIGHT           0  // Add to increase min. height of list items
 
-
 // ============================================================================
 // implementation
 // ============================================================================
@@ -74,8 +59,6 @@
 
 void wxBitmapComboBox::Init()
 {
-    m_fontHeight = 0;
-    m_imgAreaWidth = 0;
     m_inResize = false;
 }
 
@@ -114,7 +97,7 @@
         return false;
     }
 
-    PostCreate();
+    UpdateInternals();
 
     return true;
 }
@@ -138,19 +121,11 @@
         return false;
     }
 
-    PostCreate();
+    UpdateInternals();
 
     return true;
 }
 
-void wxBitmapComboBox::PostCreate()
-{
-    m_fontHeight = GetCharHeight() + EXTRA_FONT_HEIGHT;
-
-    while ( m_bitmaps.GetCount() < GetCount() )
-        m_bitmaps.Add( new wxBitmap() );
-}
-
 wxBitmapComboBox::~wxBitmapComboBox()
 {
     Clear();
@@ -162,20 +137,13 @@
 
 void wxBitmapComboBox::SetItemBitmap(unsigned int n, const wxBitmap& bitmap)
 {
-    wxCHECK_RET( n < GetCount(), wxT("invalid item index") );
     OnAddBitmap(bitmap);
-    *GetBitmapPtr(n) = bitmap;
+    DoSetItemBitmap(n, bitmap);
 
     if ( (int)n == GetSelection() )
         Refresh();
 }
 
-wxBitmap wxBitmapComboBox::GetItemBitmap(unsigned int n) const
-{
-    wxCHECK_MSG( n < GetCount(), wxNullBitmap, wxT("invalid item index") );
-    return *GetBitmapPtr(n);
-}
-
 int wxBitmapComboBox::DoInsertItems(const wxArrayStringsAdapter & items,
                                     unsigned int pos,
                                     void **clientData, wxClientDataType type)
@@ -185,7 +153,7 @@
 
     m_bitmaps.Alloc(countNew);
 
-    for ( unsigned int i = 0; i < numItems; ++i )
+    for ( unsigned int i = 0; i < numItems; i++ )
     {
         m_bitmaps.Insert(new wxBitmap(wxNullBitmap), pos + i);
     }
@@ -195,13 +163,10 @@
 
     if ( index == wxNOT_FOUND )
     {
-        for ( int i = countNew - GetCount(); i > 0; --i )
-        {
-            wxBitmap *bmp = GetBitmapPtr(pos);
-            m_bitmaps.RemoveAt(pos);
-            delete bmp;
-        }
+        for ( int i = (numItems-1); i >= 0; i-- )
+            BCBDoDeleteOneItem(pos + i);
     }
+
     return index;
 }
 
@@ -259,83 +224,22 @@
     return n;
 }
 
-bool wxBitmapComboBox::OnAddBitmap(const wxBitmap& bitmap)
-{
-    if ( bitmap.Ok() )
-    {
-        int width = bitmap.GetWidth();
-        int height = bitmap.GetHeight();
-
-        if ( m_usedImgSize.x <= 0 )
-        {
-            //
-            // If size not yet determined, get it from this image.
-            m_usedImgSize.x = width;
-            m_usedImgSize.y = height;
-
-            InvalidateBestSize();
-            wxSize newSz = GetBestSize();
-            wxSize sz = GetSize();
-            if ( newSz.y > sz.y )
-                SetSize(sz.x, newSz.y);
-            else
-                DetermineIndent();
-        }
-
-        wxCHECK_MSG(width == m_usedImgSize.x && height == m_usedImgSize.y,
-                    false,
-                    wxT("you can only add images of same size"));
-    }
-
-    return true;
-}
-
 void wxBitmapComboBox::DoClear()
 {
     wxOwnerDrawnComboBox::DoClear();
-
-    unsigned int i;
-
-    for ( i=0; i<m_bitmaps.size(); i++ )
-        delete GetBitmapPtr(i);
-
-    m_bitmaps.Empty();
-
-    m_usedImgSize.x = 0;
-    m_usedImgSize.y = 0;
-
-    DetermineIndent();
+    wxBitmapComboBoxBase::BCBDoClear();
 }
 
 void wxBitmapComboBox::DoDeleteOneItem(unsigned int n)
 {
     wxOwnerDrawnComboBox::DoDeleteOneItem(n);
-    delete GetBitmapPtr(n);
-    m_bitmaps.RemoveAt(n);
+    wxBitmapComboBoxBase::BCBDoDeleteOneItem(n);
 }
 
 // ----------------------------------------------------------------------------
 // wxBitmapComboBox event handlers and such
 // ----------------------------------------------------------------------------
 
-void wxBitmapComboBox::DetermineIndent()
-{
-    //
-    // Recalculate amount of empty space needed in front of
-    // text in control itself.
-    int indent = m_imgAreaWidth = 0;
-
-    if ( m_usedImgSize.x > 0 )
-    {
-        indent = m_usedImgSize.x + IMAGE_SPACING_LEFT + IMAGE_SPACING_RIGHT;
-        m_imgAreaWidth = indent;
-
-        indent -= 3;
-    }
-
-    SetCustomPaintWidth(indent);
-}
-
 void wxBitmapComboBox::OnSize(wxSizeEvent& event)
 {
     // Prevent infinite looping
@@ -353,13 +257,17 @@
 {
     wxSize sz = wxOwnerDrawnComboBox::DoGetBestSize();
 
-    // Scale control to match height of highest image.
-    int h2 = m_usedImgSize.y + IMAGE_SPACING_CTRL_VERTICAL;
+    if ( HasFlag(wxCB_READONLY) )
+    {
+        // Scale control to match height of highest image.
+        int h2 = m_usedImgSize.y + IMAGE_SPACING_CTRL_VERTICAL;
 
-    if ( h2 > sz.y )
-        sz.y = h2;
+        if ( h2 > sz.y )
+            sz.y = h2;
 
-    CacheBestSize(sz);
+        CacheBestSize(sz);
+    }
+
     return sz;
 }
 
@@ -370,7 +278,7 @@
 bool wxBitmapComboBox::SetFont(const wxFont& font)
 {
     bool res = wxOwnerDrawnComboBox::SetFont(font);
-    m_fontHeight = GetCharHeight() + EXTRA_FONT_HEIGHT;
+    UpdateInternals();
     return res;
 }
 
@@ -392,28 +300,7 @@
         return;
     }
 
-    //
-    // Just paint simple selection background under where is text
-    // (ie. emulate what MSW image choice does).
-    //
-
-    int xPos = 0;  // Starting x of selection rectangle
-    const int vSizeDec = 1;  // Vertical size reduction of selection rectangle edges
-
-    xPos = GetCustomPaintWidth() + 2;
-
-    wxCoord x, y;
-    GetTextExtent(GetString(item), &x, &y, 0, 0);
-
-    dc.SetTextForeground(wxSystemSettings::GetColour(wxSYS_COLOUR_HIGHLIGHTTEXT));
-
-    wxColour selCol = wxSystemSettings::GetColour(wxSYS_COLOUR_HIGHLIGHT);
-    dc.SetPen(selCol);
-    dc.SetBrush(selCol);
-    dc.DrawRectangle(rect.x+xPos,
-                     rect.y+vSizeDec,
-                     x + 4,
-                     rect.height-(vSizeDec*2));
+    wxBitmapComboBoxBase::DrawBackground(dc, rect, item, flags);
 }
 
 void wxBitmapComboBox::OnDrawItem(wxDC& dc,
@@ -423,7 +310,6 @@
 {
     wxString text;
     int imgAreaWidth = m_imgAreaWidth;
-    bool drawText;
 
     if ( imgAreaWidth == 0 )
     {
@@ -434,40 +320,20 @@
     if ( flags & wxODCB_PAINTING_CONTROL )
     {
         text = GetValue();
-        if ( HasFlag(wxCB_READONLY) )
-            drawText = true;
-        else
-            drawText = false;
+        if ( !HasFlag(wxCB_READONLY) )
+            text.clear();
     }
     else
     {
         text = GetString(item);
-        drawText = true;
     }
-
-    const wxBitmap& bmp = *GetBitmapPtr(item);
-    if ( bmp.Ok() )
-    {
-        wxCoord w = bmp.GetWidth();
-        wxCoord h = bmp.GetHeight();
-
-        // Draw the image centered
-        dc.DrawBitmap(bmp,
-                      rect.x + (m_usedImgSize.x-w)/2 + IMAGE_SPACING_LEFT,
-                      rect.y + (rect.height-h)/2,
-                      true);
-    }
-
-    if ( drawText )
-        dc.DrawText(GetString(item),
-                    rect.x + imgAreaWidth + 1,
-                    rect.y + (rect.height-dc.GetCharHeight())/2);
+    
+    wxBitmapComboBoxBase::DrawItem(dc, rect, item, text, flags);
 }
 
-wxCoord wxBitmapComboBox::OnMeasureItem(size_t WXUNUSED(item)) const
+wxCoord wxBitmapComboBox::OnMeasureItem(size_t item) const
 {
-    int imgHeightArea = m_usedImgSize.y + 2;
-    return imgHeightArea > m_fontHeight ? imgHeightArea : m_fontHeight;
+    return wxBitmapComboBoxBase::MeasureItem(item);
 }
 
 wxCoord wxBitmapComboBox::OnMeasureItemWidth(size_t item) const
Index: include/wx/msw/bmpcbox.h
===================================================================
--- include/wx/msw/bmpcbox.h	(revision 0)
+++ include/wx/msw/bmpcbox.h	(revision 0)
@@ -0,0 +1,137 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/msw/bmpcbox.h
+// Purpose:     wxBitmapComboBox
+// Author:      Jaakko Salli
+// Modified by:
+// Created:     Apr-6-2008
+// RCS-ID:      $Id:
+// Copyright:   (c) Jaakko Salli
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_MSW_BMPCBOX_H_
+#define _WX_MSW_BMPCBOX_H_
+
+
+#include "wx/combobox.h"
+
+
+// ----------------------------------------------------------------------------
+// wxBitmapComboBox: a wxComboBox that allows images to be shown
+// in front of string items.
+// ----------------------------------------------------------------------------
+
+class WXDLLIMPEXP_ADV wxBitmapComboBox : public wxComboBox,
+                                         public wxBitmapComboBoxBase
+{
+public:
+
+    // ctors and such
+    wxBitmapComboBox() : wxComboBox(), wxBitmapComboBoxBase()
+    {
+        Init();
+    }
+
+    wxBitmapComboBox(wxWindow *parent,
+                     wxWindowID id = wxID_ANY,
+                     const wxString& value = wxEmptyString,
+                     const wxPoint& pos = wxDefaultPosition,
+                     const wxSize& size = wxDefaultSize,
+                     int n = 0,
+                     const wxString choices[] = NULL,
+                     long style = 0,
+                     const wxValidator& validator = wxDefaultValidator,
+                     const wxString& name = wxBitmapComboBoxNameStr)
+        : wxComboBox(),
+          wxBitmapComboBoxBase()
+    {
+        Init();
+
+        (void)Create(parent, id, value, pos, size, n,
+                     choices, style, validator, name);
+    }
+
+    wxBitmapComboBox(wxWindow *parent,
+                     wxWindowID id,
+                     const wxString& value,
+                     const wxPoint& pos,
+                     const wxSize& size,
+                     const wxArrayString& choices,
+                     long style,
+                     const wxValidator& validator = wxDefaultValidator,
+                     const wxString& name = wxBitmapComboBoxNameStr);
+
+    bool Create(wxWindow *parent,
+                wxWindowID id,
+                const wxString& value,
+                const wxPoint& pos,
+                const wxSize& size,
+                int n,
+                const wxString choices[],
+                long style = 0,
+                const wxValidator& validator = wxDefaultValidator,
+                const wxString& name = wxBitmapComboBoxNameStr);
+
+    bool Create(wxWindow *parent,
+                wxWindowID id,
+                const wxString& value,
+                const wxPoint& pos,
+                const wxSize& size,
+                const wxArrayString& choices,
+                long style = 0,
+                const wxValidator& validator = wxDefaultValidator,
+                const wxString& name = wxBitmapComboBoxNameStr);
+
+    virtual ~wxBitmapComboBox();
+
+    // Sets the image for the given item.
+    virtual void SetItemBitmap(unsigned int n, const wxBitmap& bitmap);
+
+    // Adds item with image to the end of the combo box.
+    int Append(const wxString& item, const wxBitmap& bitmap = wxNullBitmap);
+    int Append(const wxString& item, const wxBitmap& bitmap, void *clientData);
+    int Append(const wxString& item, const wxBitmap& bitmap, wxClientData *clientData);
+
+    // Inserts item with image into the list before pos. Not valid for wxCB_SORT
+    // styles, use Append instead.
+    int Insert(const wxString& item, const wxBitmap& bitmap, unsigned int pos);
+    int Insert(const wxString& item, const wxBitmap& bitmap,
+               unsigned int pos, void *clientData);
+    int Insert(const wxString& item, const wxBitmap& bitmap,
+               unsigned int pos, wxClientData *clientData);
+
+protected:
+
+    WXDWORD MSWGetStyle(long style, WXDWORD *exstyle) const;
+    virtual bool MSWOnDraw(WXDRAWITEMSTRUCT *item);
+    virtual bool MSWOnMeasure(WXMEASUREITEMSTRUCT *item);
+
+    // Event handlers
+    void OnSize(wxSizeEvent& event);
+
+    virtual bool SetFont(const wxFont& font);
+
+    virtual wxItemContainer* GetItemContainer() { return this; }
+    virtual wxWindow* GetControl() { return this; }
+
+    // wxItemContainer implementation
+    virtual int DoInsertItems(const wxArrayStringsAdapter & items,
+                              unsigned int pos,
+                              void **clientData, wxClientDataType type);
+    virtual void DoClear();
+    virtual void DoDeleteOneItem(unsigned int n);
+
+    virtual bool OnAddBitmap(const wxBitmap& bitmap);
+    void RecreateControl();
+
+private:
+    void Init();
+
+    bool                m_inResize;
+
+    DECLARE_EVENT_TABLE()
+
+    DECLARE_DYNAMIC_CLASS(wxBitmapComboBox)
+};
+
+#endif // _WX_MSW_BMPCBOX_H_
Index: include/wx/bmpcbox.h
===================================================================
--- include/wx/bmpcbox.h	(revision 53156)
+++ include/wx/bmpcbox.h	(working copy)
@@ -19,6 +19,13 @@
 
 #include "wx/bitmap.h"
 
+//
+// Define wxBITMAPCOMBOBOX_OWNERDRAWN_BASED for platforms which
+// wxBitmapComboBox implementation utilizes ownerdrawn combobox
+// (either native or generic).
+#if 1
+    #define wxBITMAPCOMBOBOX_OWNERDRAWN_BASED
+#endif
 
 extern WXDLLIMPEXP_DATA_ADV(const wxChar) wxBitmapComboBoxNameStr[];
 
@@ -27,22 +34,85 @@
 {
 public:
     // ctors and such
-    wxBitmapComboBoxBase() { }
+    wxBitmapComboBoxBase() { Init(); }
 
     virtual ~wxBitmapComboBoxBase() { }
 
+    // Sets the image for the given item.
+    virtual void SetItemBitmap(unsigned int n, const wxBitmap& bitmap) = 0;
+
+#if !defined(wxBITMAPCOMBOBOX_OWNERDRAWN_BASED)
+
     // Returns the image of the item with the given index.
     virtual wxBitmap GetItemBitmap(unsigned int n) const = 0;
 
-    // Sets the image for the given item.
-    virtual void SetItemBitmap(unsigned int n, const wxBitmap& bitmap) = 0;
+    // Returns size of the image used in list
+    virtual wxSize GetBitmapSize() const = 0;
 
+private:
+    void Init() {}
+
+#else
+
+    // Returns the image of the item with the given index.
+    virtual wxBitmap GetItemBitmap(unsigned int n) const;
+
     // Returns size of the image used in list
-    virtual wxSize GetBitmapSize() const = 0;
+    virtual wxSize GetBitmapSize() const
+    {
+        return m_usedImgSize;
+    }
+
+protected:
+
+    // Returns pointer to the combobox item container
+    virtual wxItemContainer* GetItemContainer() = 0;
+
+    // Return pointer to the owner-drawn combobox control
+    virtual wxWindow* GetControl() = 0;
+
+    // wxItemContainer functions
+    void BCBDoClear();
+    void BCBDoDeleteOneItem(unsigned int n);
+
+    void DoSetItemBitmap(unsigned int n, const wxBitmap& bitmap);
+
+    void DrawBackground(wxDC& dc, const wxRect& rect, int item, int flags) const;
+    void DrawItem(wxDC& dc, const wxRect& rect, int item, const wxString& text,
+                  int flags) const;
+    wxCoord MeasureItem(size_t item) const;
+
+    // Returns true if image size was affected
+    virtual bool OnAddBitmap(const wxBitmap& bitmap);
+
+    // Recalculates amount of empty space needed in front of text
+    // in control itself. Returns number that can be passed to
+    // wxOwnerDrawnComboBox::SetCustomPaintWidth() and similar
+    // functions.
+    virtual int DetermineIndent();
+
+    void UpdateInternals();
+
+    wxArrayPtrVoid      m_bitmaps;  // Images associated with items
+    wxSize              m_usedImgSize;  // Size of bitmaps
+
+    int                 m_imgAreaWidth;  // Width and height of area next to text field
+    int                 m_fontHeight;
+    int                 m_indent;
+
+private:
+    void Init();
+#endif // wxBITMAPCOMBOBOX_OWNERDRAWN_BASED
 };
 
 
-#include "wx/generic/bmpcbox.h"
+#if defined(__WXUNIVERSAL__)
+    #include "wx/generic/bmpcbox.h"
+#elif defined(__WXMSW__)
+    #include "wx/msw/bmpcbox.h"
+#else
+    #include "wx/generic/bmpcbox.h"
+#endif
 
 #endif // wxUSE_BITMAPCOMBOBOX
 
Index: include/wx/generic/bmpcbox.h
===================================================================
--- include/wx/generic/bmpcbox.h	(revision 53156)
+++ include/wx/generic/bmpcbox.h	(working copy)
@@ -98,21 +98,9 @@
     int Insert(const wxString& item, const wxBitmap& bitmap,
                unsigned int pos, wxClientData *clientData);
 
-    // Returns size of image used in list.
-    virtual wxSize GetBitmapSize() const
-    {
-        return m_usedImgSize;
-    }
-
-    // Returns the image of the item with the given index.
-    virtual wxBitmap GetItemBitmap(unsigned int n) const;
-
     // Sets the image for the given item.
     virtual void SetItemBitmap(unsigned int n, const wxBitmap& bitmap);
 
-    virtual void DoClear();
-    virtual void DoDeleteOneItem(unsigned int n);
-
 protected:
 
     virtual void OnDrawBackground(wxDC& dc, const wxRect& rect, int item, int flags) const;
@@ -120,38 +108,26 @@
     virtual wxCoord OnMeasureItem(size_t item) const;
     virtual wxCoord OnMeasureItemWidth(size_t item) const;
 
-    virtual int DoInsertItems(const wxArrayStringsAdapter & items,
-                              unsigned int pos,
-                              void **clientData, wxClientDataType type);
-
-    virtual bool SetFont(const wxFont& font);
-
-    virtual wxSize DoGetBestSize() const;
-
     // Event handlers
     void OnSize(wxSizeEvent& event);
 
-    // Recalculates amount of empty space needed in front of
-    // text in control itself.
-    void DetermineIndent();
+    virtual wxSize DoGetBestSize() const;
+    virtual bool SetFont(const wxFont& font);
 
-    bool OnAddBitmap(const wxBitmap& bitmap);
+    virtual wxItemContainer* GetItemContainer() { return this; }
+    virtual wxWindow* GetControl() { return this; }
 
-    // Adds image to position - called in Append/Insert before
-    // string is added.
-    bool DoInsertBitmap(const wxBitmap& image, unsigned int pos);
+    // wxItemContainer implementation
+    virtual int DoInsertItems(const wxArrayStringsAdapter & items,
+                              unsigned int pos,
+                              void **clientData, wxClientDataType type);
+    virtual void DoClear();
+    virtual void DoDeleteOneItem(unsigned int n);
 
-
-    wxArrayPtrVoid      m_bitmaps;  // Images associated with items
-    wxSize              m_usedImgSize;  // Size of bitmaps
-
 private:
-    int                 m_imgAreaWidth;  // Width and height of area next to text field
-    int                 m_fontHeight;
     bool                m_inResize;
 
     void Init();
-    void PostCreate();
 
     DECLARE_EVENT_TABLE()
 

 	  	 
