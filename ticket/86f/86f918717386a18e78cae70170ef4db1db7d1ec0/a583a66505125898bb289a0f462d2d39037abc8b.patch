Index: include/wx/gbsizer.h
===================================================================
--- include/wx/gbsizer.h	(revision 53980)
+++ include/wx/gbsizer.h	(working copy)
@@ -4,7 +4,7 @@
 //              with items at specified cells, and with the option of row
 //              and/or column spanning
 //
-// Author:      Robin Dunn
+// Author:      Robin Dunn, contributions by Dustin Spicuzza
 // Created:     03-Nov-2003
 // RCS-ID:      $Id$
 // Copyright:   (c) Robin Dunn
@@ -16,65 +16,11 @@
 
 #include "wx/sizer.h"
 
+// compatibility
+typedef wxGridPosition wxGBPosition;
+typedef wxGridSpan wxGBSpan;
 
-//---------------------------------------------------------------------------
-// Classes to represent a position in the grid and a size of an item in the
-// grid, IOW, the number of rows and columns it occupies.  I chose to use these
-// instead of wxPoint and wxSize because they are (x,y) and usually pixel
-// oriented while grids and tables are usually thought of as (row,col) so some
-// confusion would definitely result in using wxPoint...
-//
-// NOTE: This should probably be refactored to a common RowCol data type which
-// is used for this and also for wxGridCellCoords.
-//---------------------------------------------------------------------------
 
-class WXDLLIMPEXP_CORE wxGBPosition
-{
-public:
-    wxGBPosition() : m_row(0), m_col(0) {}
-    wxGBPosition(int row, int col) : m_row(row), m_col(col) {}
-
-    // default copy ctor and assignment operator are okay.
-
-    int GetRow() const { return m_row; }
-    int GetCol() const { return m_col; }
-    void SetRow(int row) { m_row = row; }
-    void SetCol(int col) { m_col = col; }
-
-    bool operator==(const wxGBPosition& p) const { return m_row == p.m_row && m_col == p.m_col; }
-    bool operator!=(const wxGBPosition& p) const { return !(*this == p); }
-
-private:
-    int m_row;
-    int m_col;
-};
-
-
-class WXDLLIMPEXP_CORE wxGBSpan
-{
-public:
-    wxGBSpan() : m_rowspan(1), m_colspan(1) {}
-    wxGBSpan(int rowspan, int colspan) : m_rowspan(rowspan), m_colspan(colspan) {}
-
-    // default copy ctor and assignment operator are okay.
-
-    int GetRowspan() const { return m_rowspan; }
-    int GetColspan() const { return m_colspan; }
-    void SetRowspan(int rowspan) { m_rowspan = rowspan; }
-    void SetColspan(int colspan) { m_colspan = colspan; }
-
-    bool operator==(const wxGBSpan& o) const { return m_rowspan == o.m_rowspan && m_colspan == o.m_colspan; }
-    bool operator!=(const wxGBSpan& o) const { return !(*this == o); }
-
-private:
-    int m_rowspan;
-    int m_colspan;
-};
-
-
-extern WXDLLIMPEXP_DATA_CORE(const wxGBSpan) wxDefaultSpan;
-
-
 //---------------------------------------------------------------------------
 // wxGBSizerItem
 //---------------------------------------------------------------------------
@@ -89,7 +35,7 @@
     wxGBSizerItem( int width,
                    int height,
                    const wxGBPosition& pos,
-                   const wxGBSpan& span,
+                   const wxGridSpan& span,
                    int flag,
                    int border,
                    wxObject* userData);
@@ -97,7 +43,7 @@
     // window
     wxGBSizerItem( wxWindow *window,
                    const wxGBPosition& pos,
-                   const wxGBSpan& span,
+                   const wxGridSpan& span,
                    int flag,
                    int border,
                    wxObject* userData );
@@ -105,7 +51,7 @@
     // subsizer
     wxGBSizerItem( wxSizer *sizer,
                    const wxGBPosition& pos,
-                   const wxGBSpan& span,
+                   const wxGridSpan& span,
                    int flag,
                    int border,
                    wxObject* userData );
@@ -118,9 +64,9 @@
     wxGBPosition GetPos() const { return m_pos; }
     void GetPos(int& row, int& col) const;
 
-    // Get the row and column spanning of the item
-    wxGBSpan GetSpan() const { return m_span; }
+    // compatability: Get the row and column spanning of the item
     void GetSpan(int& rowspan, int& colspan) const;
+    virtual bool SetSpan( const wxGridSpan& span );
 
     // If the item is already a member of a sizer then first ensure that there
     // is no other item that would intersect with this one at the new
@@ -128,17 +74,14 @@
     // successful and after the next Layout the item will be moved.
     bool SetPos( const wxGBPosition& pos );
 
-    // If the item is already a member of a sizer then first ensure that there
-    // is no other item that would intersect with this one with its new
-    // spanning size, then set the new spanning.  Returns true if the change
-    // is successful and after the next Layout the item will be resized.
-    bool SetSpan( const wxGBSpan& span );
 
+
+
     // Returns true if this item and the other item instersect
     bool Intersects(const wxGBSizerItem& other);
 
     // Returns true if the given pos/span would intersect with this item.
-    bool Intersects(const wxGBPosition& pos, const wxGBSpan& span);
+    bool Intersects(const wxGBPosition& pos, const wxGridSpan& span);
 
     // Get the row and column of the endpoint of this item
     void GetEndPos(int& row, int& col);
@@ -150,7 +93,6 @@
 
 protected:
     wxGBPosition    m_pos;
-    wxGBSpan        m_span;
     wxGridBagSizer* m_gbsizer;  // so SetPos/SetSpan can check for intersects
 
 
@@ -169,25 +111,27 @@
 {
 public:
     wxGridBagSizer(int vgap = 0, int hgap = 0 );
+    ~wxGridBagSizer(){ if (m_emptyCell) delete m_emptyCell; }
 
     // The Add methods return true if the item was successfully placed at the
-    // given position, false if something was already there.
+    // given position, false if something was already there. This only
+    // checks items placed with absolute positions
     wxSizerItem* Add( wxWindow *window,
                       const wxGBPosition& pos,
-                      const wxGBSpan& span = wxDefaultSpan,
+                      const wxGridSpan& span = wxDefaultSpan,
                       int flag = 0,
                       int border = 0,
                       wxObject* userData = NULL );
     wxSizerItem* Add( wxSizer *sizer,
                       const wxGBPosition& pos,
-                      const wxGBSpan& span = wxDefaultSpan,
+                      const wxGridSpan& span = wxDefaultSpan,
                       int flag = 0,
                       int border = 0,
                       wxObject* userData = NULL );
     wxSizerItem* Add( int width,
                       int height,
                       const wxGBPosition& pos,
-                      const wxGBSpan& span = wxDefaultSpan,
+                      const wxGridSpan& span = wxDefaultSpan,
                       int flag = 0,
                       int border = 0,
                       wxObject* userData = NULL );
@@ -198,15 +142,6 @@
     wxSize GetEmptyCellSize() const          { return m_emptyCellSize; }
     void SetEmptyCellSize(const wxSize& sz)  { m_emptyCellSize = sz; }
 
-    // Get the size of the specified cell, including hgap and vgap.  Only
-    // valid after a Layout.
-    wxSize GetCellSize(int row, int col) const;
-
-    // Get the grid position of the specified item (non-recursive)
-    wxGBPosition GetItemPosition(wxWindow *window);
-    wxGBPosition GetItemPosition(wxSizer *sizer);
-    wxGBPosition GetItemPosition(size_t index);
-
     // Set the grid position of the specified item.  Returns true on success.
     // If the move is not allowed (because an item is already there) then
     // false is returned.   (non-recursive)
@@ -214,25 +149,10 @@
     bool SetItemPosition(wxSizer *sizer, const wxGBPosition& pos);
     bool SetItemPosition(size_t index, const wxGBPosition& pos);
 
-    // Get the row/col spanning of the specified item (non-recursive)
-    wxGBSpan GetItemSpan(wxWindow *window);
-    wxGBSpan GetItemSpan(wxSizer *sizer);
-    wxGBSpan GetItemSpan(size_t index);
+    // these are deprecated, use GetItem() instead
+    wxDEPRECATED( wxGBSizerItem* FindItem(wxWindow* window) { return wxDynamicCast(GetItem(window),wxGBSizerItem); } )
+    wxDEPRECATED( wxGBSizerItem* FindItem(wxSizer* sizer) { return wxDynamicCast(GetItem(sizer),wxGBSizerItem); } )
 
-    // Set the row/col spanning of the specified item. Returns true on
-    // success.  If the move is not allowed (because an item is already there)
-    // then false is returned. (non-recursive)
-    bool SetItemSpan(wxWindow *window, const wxGBSpan& span);
-    bool SetItemSpan(wxSizer *sizer, const wxGBSpan& span);
-    bool SetItemSpan(size_t index, const wxGBSpan& span);
-
-
-    // Find the sizer item for the given window or subsizer, returns NULL if
-    // not found. (non-recursive)
-    wxGBSizerItem* FindItem(wxWindow* window);
-    wxGBSizerItem* FindItem(wxSizer* sizer);
-
-
     // Return the sizer item for the given grid cell, or NULL if there is no
     // item at that position. (non-recursive)
     wxGBSizerItem* FindItemAtPosition(const wxGBPosition& pos);
@@ -249,46 +169,22 @@
     // pointer values) or NULL if not found. (non-recursive)
     wxGBSizerItem* FindItemWithData(const wxObject* userData);
 
-
-    // These are what make the sizer do size calculations and layout
-    virtual void RecalcSizes();
-    virtual wxSize CalcMin();
-
-
     // Look at all items and see if any intersect (or would overlap) the given
     // item.  Returns true if so, false if there would be no overlap.  If an
     // excludeItem is given then it will not be checked for intersection, for
-    // example it may be the item we are checking the position of.
+    // example it may be the item we are checking the position of. This only 
+    // checks items that are absolutely positioned
     bool CheckForIntersection(wxGBSizerItem* item, wxGBSizerItem* excludeItem = NULL);
-    bool CheckForIntersection(const wxGBPosition& pos, const wxGBSpan& span, wxGBSizerItem* excludeItem = NULL);
+    bool CheckForIntersection(const wxGBPosition& pos, const wxGridSpan& span, wxGBSizerItem* excludeItem = NULL);
 
 
-    // The Add base class virtuals should not be used with this class, but
-    // we'll try to make them automatically select a location for the item
-    // anyway.
-    virtual wxSizerItem* Add( wxWindow *window, int proportion = 0, int flag = 0, int border = 0, wxObject* userData = NULL );
-    virtual wxSizerItem* Add( wxSizer *sizer, int proportion = 0, int flag = 0, int border = 0, wxObject* userData = NULL );
-    virtual wxSizerItem* Add( int width, int height, int proportion = 0, int flag = 0, int border = 0, wxObject* userData = NULL );
-
-    // The Insert and Prepend base class virtuals that are not appropriate for
-    // this class and should not be used.  Their implementation in this class
-    // simply fails.
-    virtual wxSizerItem* Add( wxSizerItem *item );
-    virtual wxSizerItem* Insert( size_t index, wxWindow *window, int proportion = 0, int flag = 0, int border = 0, wxObject* userData = NULL );
-    virtual wxSizerItem* Insert( size_t index, wxSizer *sizer, int proportion = 0, int flag = 0, int border = 0, wxObject* userData = NULL );
-    virtual wxSizerItem* Insert( size_t index, int width, int height, int proportion = 0, int flag = 0, int border = 0, wxObject* userData = NULL );
-    virtual wxSizerItem* Insert( size_t index, wxSizerItem *item );
-    virtual wxSizerItem* Prepend( wxWindow *window, int proportion = 0, int flag = 0, int border = 0, wxObject* userData = NULL );
-    virtual wxSizerItem* Prepend( wxSizer *sizer, int proportion = 0, int flag = 0, int border = 0, wxObject* userData = NULL );
-    virtual wxSizerItem* Prepend( int width,  int height,  int proportion = 0,  int flag = 0,  int border = 0,  wxObject* userData = NULL );
-    virtual wxSizerItem* Prepend( wxSizerItem *item );
-
-
 protected:
-    wxGBPosition FindEmptyCell();
-    void AdjustForOverflow();
 
+    virtual int CalcRowsCols();
+    virtual void PopulateGrid();
+
     wxSize m_emptyCellSize;
+    wxSizerItem * m_emptyCell;
 
 
 private:
Index: include/wx/sizer.h
===================================================================
--- include/wx/sizer.h	(revision 53980)
+++ include/wx/sizer.h	(working copy)
@@ -2,7 +2,7 @@
 // Name:        wx/sizer.h
 // Purpose:     provide wxSizer class for layout
 // Author:      Robert Roebling and Robin Dunn
-// Modified by: Ron Lee, Vadim Zeitlin (wxSizerFlags)
+// Modified by: Ron Lee, Vadim Zeitlin (wxSizerFlags), Dustin Spicuzza
 // Created:
 // RCS-ID:      $Id$
 // Copyright:   (c) Robin Dunn, Robert Roebling
@@ -34,7 +34,70 @@
     #endif
 #endif
 
+
+//---------------------------------------------------------------------------
+// Classes to represent a position in the grid and a size of an item in the
+// grid, IOW, the number of rows and columns it occupies.  I chose to use these
+// instead of wxPoint and wxSize because they are (x,y) and usually pixel
+// oriented while grids and tables are usually thought of as (row,col) so some
+// confusion would definitely result in using wxPoint...
+//
+// NOTE: This should probably be refactored to a common RowCol data type which
+// is used for this and also for wxGridCellCoords.
+//---------------------------------------------------------------------------
+
+class WXDLLIMPEXP_CORE wxGridPosition
+{
+public:
+    wxGridPosition() : m_row(0), m_col(0) {}
+    wxGridPosition(int row, int col) : m_row(row), m_col(col) {}
+
+    // default copy ctor and assignment operator are okay.
+
+    int GetRow() const { return m_row; }
+    int GetCol() const { return m_col; }
+    void SetRow(int row) { m_row = row; }
+    void SetCol(int col) { m_col = col; }
+
+    bool operator==(const wxGridPosition& p) const { return m_row == p.m_row && m_col == p.m_col; }
+    bool operator!=(const wxGridPosition& p) const { return !(*this == p); }
+
+private:
+    int m_row;
+    int m_col;
+};
+
 // ----------------------------------------------------------------------------
+// wxGridSpan
+// ----------------------------------------------------------------------------
+
+class WXDLLIMPEXP_CORE wxGridSpan
+{
+public:
+    wxGridSpan() : m_rowspan(1), m_colspan(1) {}
+    wxGridSpan(int rowspan, int colspan) : 
+        m_rowspan(rowspan < 1 ? 1 : rowspan), m_colspan(colspan < 1 ? 1 : colspan) {}
+
+    // default copy ctor and assignment operator are okay.
+
+    int GetRowspan() const { return m_rowspan; }
+    int GetColspan() const { return m_colspan; }
+    void SetRowspan(int rowspan) { m_rowspan = rowspan < 1 ? 1 : rowspan; }
+    void SetColspan(int colspan) { m_colspan = colspan < 1 ? 1 : colspan; }
+
+    bool operator==(const wxGridSpan& o) const { return m_rowspan == o.m_rowspan && m_colspan == o.m_colspan; }
+    bool operator!=(const wxGridSpan& o) const { return !(*this == o); }
+
+private:
+    int m_rowspan;
+    int m_colspan;
+};
+
+extern WXDLLIMPEXP_DATA_CORE(const wxGridSpan) wxDefaultSpan;
+
+
+
+// ----------------------------------------------------------------------------
 // wxSizerFlags: flags used for an item in the sizer
 // ----------------------------------------------------------------------------
 
@@ -183,15 +246,47 @@
         return *this;
     }
 
+
+    // wxGridSizer derived classes only
+    wxSizerFlags& ColSpan(int cols) 
+    {
+        m_span.SetColspan(cols);
+        return *this;
+    }
+
+    wxSizerFlags& RowSpan(int rows)
+    {
+        m_span.SetRowspan(rows);
+        return *this;
+    }
+
+    wxSizerFlags& Span(wxGridSpan span)
+    {
+        m_span = span;
+        return *this;
+    }
+
+    // setter for wxGridBagSizer
+    wxSizerFlags& SetFlags(int flags) 
+    { 
+        m_flags = flags; 
+        return *this;
+    }
+
+
+
     // accessors for wxSizer only
     int GetProportion() const { return m_proportion; }
     int GetFlags() const { return m_flags; }
     int GetBorderInPixels() const { return m_borderInPixels; }
+    wxGridSpan GetSpan() const { return m_span; }
 
+
 private:
     int m_proportion;
     int m_flags;
     int m_borderInPixels;
+    wxGridSpan m_span;
 };
 
 
@@ -230,10 +325,11 @@
                  int proportion,
                  int flag,
                  int border,
-                 wxObject* userData );
+                 wxObject* userData);
 
     // window with flags
-    wxSizerItem(wxWindow *window, const wxSizerFlags& flags)
+    wxSizerItem(wxWindow *window, const wxSizerFlags& flags, wxObject* userData = NULL) :
+        m_userData(userData)
     {
         Init(flags);
 
@@ -248,7 +344,8 @@
                  wxObject* userData );
 
     // sizer with flags
-    wxSizerItem(wxSizer *sizer, const wxSizerFlags& flags)
+    wxSizerItem(wxSizer *sizer, const wxSizerFlags& flags, wxObject* userData = NULL) :
+        m_userData(userData)
     {
         Init(flags);
 
@@ -264,7 +361,8 @@
                  wxObject* userData);
 
     // spacer with flags
-    wxSizerItem(int width, int height, const wxSizerFlags& flags)
+    wxSizerItem(int width, int height, const wxSizerFlags& flags, wxObject* userData = NULL) :
+        m_userData(userData)
     {
         Init(flags);
 
@@ -345,6 +443,13 @@
         { return m_kind == Item_Sizer ? m_sizer : NULL; }
     wxSize GetSpacer() const;
 
+    // virtual for compatibility with wxGBSizer.. the return value is actually
+    // meaningless
+    virtual bool SetSpan(const wxGridSpan& span)
+        { m_span = span; return true; }
+    wxGridSpan GetSpan() const
+        { return m_span; }
+
     // This function behaves obviously for the windows and spacers but for the
     // sizers it returns true if any sizer element is shown and only returns
     // false if all of them are hidden. Also, it always returns true if
@@ -445,12 +550,16 @@
 
     wxObject    *m_userData;
 
+    // wxGridSizer specific
+    wxGridSpan  m_span;
+
 private:
     DECLARE_CLASS(wxSizerItem)
     DECLARE_NO_COPY_CLASS(wxSizerItem)
 };
 
 WX_DECLARE_EXPORTED_LIST( wxSizerItem, wxSizerItemList );
+WX_DEFINE_EXPORTED_ARRAY_PTR( wxSizerItem*, wxSizerItemPtrArray );
 
 
 //---------------------------------------------------------------------------
@@ -690,6 +799,9 @@
     DECLARE_CLASS(wxSizer)
 };
 
+
+
+
 //---------------------------------------------------------------------------
 // wxGridSizer
 //---------------------------------------------------------------------------
@@ -703,8 +815,8 @@
     virtual void RecalcSizes();
     virtual wxSize CalcMin();
 
-    void SetCols( int cols )    { m_cols = cols; }
-    void SetRows( int rows )    { m_rows = rows; }
+    void SetCols( int cols )    { m_cols = m_user_cols = cols; }
+    void SetRows( int rows )    { m_rows = m_user_rows = rows; }
     void SetVGap( int gap )     { m_vgap = gap; }
     void SetHGap( int gap )     { m_hgap = gap; }
     int GetCols() const         { return m_cols; }
@@ -712,17 +824,80 @@
     int GetVGap() const         { return m_vgap; }
     int GetHGap() const         { return m_hgap; }
 
+    // Get the size of the specified cell, including hgap and vgap.  Only
+    // valid after a Layout.
+    wxSize GetCellSize(int row, int col) const;
+
+    // Get the grid position of the specified item (non-recursive)
+    wxGridPosition GetItemPosition(wxWindow *window);
+    wxGridPosition GetItemPosition(wxSizer *sizer);
+    wxGridPosition GetItemPosition(size_t index);
+
+     // Get the row/col spanning of the specified item (non-recursive)
+    wxGridSpan GetItemSpan(wxWindow *window);
+    wxGridSpan GetItemSpan(wxSizer *sizer);
+    wxGridSpan GetItemSpan(size_t index);
+
+    // Set the row/col spanning of the specified item. Returns true on
+    // success.  If the move is not allowed (because an item is already there)
+    // then false is returned. (non-recursive)
+    bool SetItemSpan(wxWindow *window, const wxGridSpan& span);
+    bool SetItemSpan(wxSizer *sizer, const wxGridSpan& span);
+    bool SetItemSpan(size_t index, const wxGridSpan& span);
+
+
 protected:
-    int    m_rows;
-    int    m_cols;
+    // these two are only used by CalcRowsCols() to determine the real
+    // number of rows and/or columns
+    int    m_user_rows, m_user_cols;
+
+    // these are used by everything else
+    int    m_rows, m_cols;
     int    m_vgap;
     int    m_hgap;
 
     // return the number of total items and the number of columns and rows
-    int CalcRowsCols(int& rows, int& cols) const;
+    
 
+    // helper function
+    wxSize wxGridSizer::CalcMaxWH() const;
+
     void SetItemBounds( wxSizerItem *item, int x, int y, int w, int h );
 
+    // helper functions to handle the grid correctly: call them
+    // in the order listed only!
+
+    // figures out how many rows and columns there are, sets m_rows/m_cols
+    virtual int CalcRowsCols();
+    // fills in the grid -- called by CalcRowsCols
+    virtual void PopulateGrid();
+    // fills in m_rowHeights and m_colWidths
+    virtual void CalcGridWidthsAndHeights();
+    // fills in m_rowPts and m_colPts
+    void CalcGridPoints();
+
+    // iterates over the grid and returns useful information
+    wxSizerItem* BeginIterateGrid(int *row, int *col, wxGridSpan *span);
+    wxSizerItem* IterateGrid(int *row, int *col, wxGridSpan *span);
+
+    // the gridtable is calculated by PopulateGrid(). This is an array that
+    // is m_cols*m_rows long, denoting each cell. It contains either a pointer
+    // to that item, a NULL (empty cell), or a 1 (last parts of spanning item)
+    wxSizerItemPtrArray m_gridTable;
+
+    // keeps track of stuff for the IterateGrid related functions
+    int m_grid_cur_col,
+        m_grid_cur_row;
+    
+    // points rows/columns located at
+    wxArrayInt m_rowPts,
+               m_colPts;
+
+    // the heights/widths of all rows/columns
+    wxArrayInt  m_rowHeights,
+                m_colWidths;
+
+
 private:
     DECLARE_CLASS(wxGridSizer)
 };
@@ -778,18 +953,13 @@
     const wxArrayInt& GetRowHeights() const { return m_rowHeights; }
     const wxArrayInt& GetColWidths() const  { return m_colWidths; }
 
-    // implementation
-    virtual void RecalcSizes();
+    // implementaion details
     virtual wxSize CalcMin();
 
 protected:
-    void AdjustForFlexDirection();
-    void AdjustForGrowables(const wxSize& sz);
-    void FindWidthsAndHeights(int nrows, int ncols);
+    virtual void CalcGridWidthsAndHeights();
 
-    // the heights/widths of all rows/columns
-    wxArrayInt  m_rowHeights,
-                m_colWidths;
+    void CalcMaxRowColSz(bool calcMin);
 
     // indices of the growable columns and rows
     wxArrayInt  m_growableRows,
Index: include/wx/xrc/xh_sizer.h
===================================================================
--- include/wx/xrc/xh_sizer.h	(revision 53980)
+++ include/wx/xrc/xh_sizer.h	(working copy)
@@ -51,7 +51,7 @@
 
     void SetGrowables(wxFlexGridSizer* fsizer, const wxChar* param, bool rows);
     wxGBPosition GetGBPos(const wxString& param);
-    wxGBSpan GetGBSpan(const wxString& param);
+    wxGridSpan GetGridSpan(const wxString& param);
     wxSizerItem* MakeSizerItem();
     void SetSizerItemAttributes(wxSizerItem* sitem);
     void AddSizerItem(wxSizerItem* sitem);
Index: interface/gbsizer.h
===================================================================
--- interface/gbsizer.h	(revision 53980)
+++ interface/gbsizer.h	(working copy)
@@ -1,74 +1,29 @@
 /////////////////////////////////////////////////////////////////////////////
 // Name:        gbsizer.h
-// Purpose:     interface of wxGBPosition
+// Purpose:     interface of wxGridPosition
 // Author:      wxWidgets team
 // RCS-ID:      $Id$
 // Licence:     wxWindows license
 /////////////////////////////////////////////////////////////////////////////
 
-/**
-    @class wxGBPosition
-    @wxheader{gbsizer.h}
 
-    This class represents the position of an item in a virtual grid of rows and
-    columns managed by a wxGridBagSizer.
-
-    @library{wxcore}
-    @category{winlayout}
-*/
-class wxGBPosition
-{
-public:
-    /**
-        Default constructor, setting the row and column to (0,0).
-    */
-    wxGBPosition();
-    /**
-        Construct a new wxGBPosition, setting the row and column.
-    */
-    wxGBPosition(int row, int col);
-
-    /**
-        Get the current column value.
-    */
-    int GetCol() const;
-
-    /**
-        Get the current row value.
-    */
-    int GetRow() const;
-
-    /**
-        Set a new column value.
-    */
-    void SetCol(int col);
-
-    /**
-        Set a new row value.
-    */
-    void SetRow(int row);
-
-    /**
-        Checks if the position is valid. An invalid position is (-1,-1).
-    */
-    bool operator!(const wxGBPosition& p) const;
-
-    /**
-        Compare equality of two wxGBPositions.
-    */
-    bool operator==(const wxGBPosition& p) const;
-};
-
-
-
 /**
     @class wxGridBagSizer
     @wxheader{gbsizer.h}
 
     A wxSizer that can lay out items in a virtual grid like a wxFlexGridSizer
     but in this case explicit positioning of the items is allowed using
-    wxGBPosition, and items can optionally span more than one row and/or column
-    using wxGBSpan.
+    wxGridPosition. Items can optionally span more than one row and/or column
+    using wxGridSpan (formerly wxGBSpan) or (since wxWidgets 2.9.0) wxSizerFlags.
+    
+    Since wxWidgets 2.9.0, wxGridSizer and wxFlexGridSizer also support spanning
+    items across columns and rows, and may be easier to use. wxFlexGridSizer is
+    now mostly identical to wxGridBagSizer, except that wxGridBagSizer supports
+    explicitly positioning items in the grid.
+    
+    Additionally, since 2.9.0 wxGridBagSizer supports adding items to it using the
+    "normal" wxSizer Add/Insert/Prepend functions, and can correctly handle
+    items added to it that do not have an absolute position specified.
 
     @library{wxcore}
     @category{winlayout}
@@ -89,23 +44,18 @@
         @return A valid pointer if the item was successfully placed at the
                  given position, or @NULL if something was already there.
     */
-    wxSizerItem* Add(wxWindow* window, const wxGBPosition& pos,
-                     const wxGBSpan& span = wxDefaultSpan,
+    wxSizerItem* Add(wxWindow* window, const wxGridPosition& pos,
+                     const wxGridSpan& span = wxDefaultSpan,
                      int flag = 0, int border = 0, wxObject* userData = NULL);
-    wxSizerItem* Add(wxSizer* sizer, const wxGBPosition& pos,
-                     const wxGBSpan& span = wxDefaultSpan,
+    wxSizerItem* Add(wxSizer* sizer, const wxGridPosition& pos,
+                     const wxGridSpan& span = wxDefaultSpan,
                      int flag = 0, int border = 0, wxObject* userData = NULL);
-    wxSizerItem* Add(int width, int height, const wxGBPosition& pos,
-                     const wxGBSpan& span = wxDefaultSpan,
+    wxSizerItem* Add(int width, int height, const wxGridPosition& pos,
+                     const wxGridSpan& span = wxDefaultSpan,
                      int flag = 0, int border = 0, wxObject* userData = NULL);
     wxSizerItem* Add(wxGBSizerItem* item);
     //@}
 
-    /**
-        Called when the managed size of the sizer is needed or when layout
-        needs done.
-    */
-    wxSize CalcMin();
 
     //@{
     /**
@@ -116,7 +66,7 @@
     */
     bool CheckForIntersection(wxGBSizerItem* item,
                               wxGBSizerItem* excludeItem = NULL);
-    bool CheckForIntersection(const wxGBPosition& pos, const wxGBSpan& span,
+    bool CheckForIntersection(const wxGridPosition& pos, const wxGridSpan& span,
                               wxGBSizerItem* excludeItem = NULL);
     //@}
 
@@ -124,6 +74,8 @@
     /**
         Find the sizer item for the given window or subsizer, returns @NULL if
         not found. (non-recursive)
+        
+        @deprecated Use wxSizer::GetItem() instead
     */
     wxGBSizerItem* FindItem(wxWindow* window);
     wxGBSizerItem* FindItem(wxSizer* sizer);
@@ -134,57 +86,33 @@
         there is no item at that point. The (x,y) coordinates in @a pt
         correspond to the client coordinates of the window using the sizer for
         layout. (non-recursive)
+        
+        @note   This only finds items that were positioned absolutely
     */
     wxGBSizerItem* FindItemAtPoint(const wxPoint& pt);
 
     /**
         Return the sizer item for the given grid cell, or @NULL if there is no
         item at that position. (non-recursive)
+        
+        @note   This only finds items that were positioned absolutely
     */
-    wxGBSizerItem* FindItemAtPosition(const wxGBPosition& pos);
+    wxGBSizerItem* FindItemAtPosition(const wxGridPosition& pos);
 
     /**
         Return the sizer item that has a matching user data (it only compares
         pointer values) or @NULL if not found. (non-recursive)
+        
+        @note   This only finds items that were positioned absolutely
     */
     wxGBSizerItem* FindItemWithData(const wxObject* userData);
 
     /**
-        Get the size of the specified cell, including hgap and vgap. Only valid
-        after window layout has been performed.
-    */
-    wxSize GetCellSize(int row, int col) const;
-
-    /**
         Get the size used for cells in the grid with no item.
     */
     wxSize GetEmptyCellSize() const;
 
-    //@{
     /**
-        Get the grid position of the specified item.
-    */
-    wxGBPosition GetItemPosition(wxWindow* window);
-    wxGBPosition GetItemPosition(wxSizer* sizer);
-    wxGBPosition GetItemPosition(size_t index);
-    //@}
-
-    //@{
-    /**
-        Get the row/col spanning of the specified item.
-    */
-    wxGBSpan GetItemSpan(wxWindow* window);
-    wxGBSpan GetItemSpan(wxSizer* sizer);
-    wxGBSpan GetItemSpan(size_t index);
-    //@}
-
-    /**
-        Called when the managed size of the sizer is needed or when layout
-        needs done.
-    */
-    void RecalcSizes();
-
-    /**
         Set the size used for cells in the grid with no item.
     */
     void SetEmptyCellSize(const wxSize& sz);
@@ -195,21 +123,10 @@
         If the move is not allowed (because an item is already there) then
         @false is returned.
     */
-    bool SetItemPosition(wxWindow* window, const wxGBPosition& pos);
-    bool SetItemPosition(wxSizer* sizer, const wxGBPosition& pos);
-    bool SetItemPosition(size_t index, const wxGBPosition& pos);
+    bool SetItemPosition(wxWindow* window, const wxGridPosition& pos);
+    bool SetItemPosition(wxSizer* sizer, const wxGridPosition& pos);
+    bool SetItemPosition(size_t index, const wxGridPosition& pos);
     //@}
-
-    //@{
-    /**
-        Set the row/col spanning of the specified item. Returns @true on
-        success. If the move is not allowed (because an item is already there)
-        then @false is returned.
-    */
-    bool SetItemSpan(wxWindow* window, const wxGBSpan& span);
-    bool SetItemSpan(wxSizer* sizer, const wxGBSpan& span);
-    bool SetItemSpan(size_t index, const wxGBSpan& span);
-    //@}
 };
 
 
@@ -220,7 +137,7 @@
 
     The wxGBSizerItem class is used by the wxGridBagSizer for tracking the
     items in the sizer. It adds grid position and spanning information to the
-    normal wxSizerItem by adding wxGBPosition and wxGBSpan attrbibutes. Most of
+    normal wxSizerItem by adding wxGridPosition and wxGridSpan attrbibutes. Most of
     the time you will not need to use a wxGBSizerItem directly in your code,
     but there are a couple of cases where it is handy.
 
@@ -233,20 +150,20 @@
     /**
         Construct a sizer item for tracking a spacer.
     */
-    wxGBSizerItem(int width, int height, const wxGBPosition& pos,
-                  const wxGBSpan& span, int flag, int border,
+    wxGBSizerItem(int width, int height, const wxGridPosition& pos,
+                  const wxGridSpan& span, int flag, int border,
                   wxObject* userData);
     /**
         Construct a sizer item for tracking a window.
     */
-    wxGBSizerItem(wxWindow* window, const wxGBPosition& pos,
-                  const wxGBSpan& span, int flag, int border,
+    wxGBSizerItem(wxWindow* window, const wxGridPosition& pos,
+                  const wxGridSpan& span, int flag, int border,
                   wxObject* userData);
     /**
         Construct a sizer item for tracking a subsizer.
     */
-    wxGBSizerItem(wxSizer* sizer, const wxGBPosition& pos,
-                  const wxGBSpan& span, int flag, int border,
+    wxGBSizerItem(wxSizer* sizer, const wxGridPosition& pos,
+                  const wxGridSpan& span, int flag, int border,
                   wxObject* userData);
 
     /**
@@ -254,21 +171,15 @@
     */
     void GetEndPos(int& row, int& col);
 
-    //@{
     /**
         Get the grid position of the item.
     */
-    wxGBPosition GetPos() const;
     void GetPos(int& row, int& col) const;
-    //@}
 
-    //@{
     /**
         Get the row and column spanning of the item.
     */
-    wxGBSpan GetSpan() const;
     void GetSpan(int& rowspan, int& colspan) const;
-    //@}
 
     /**
         Returns @true if this item and the @a other item instersect.
@@ -277,7 +188,7 @@
     /**
         Returns @true if the given pos/span would intersect with this item.
     */
-    bool Intersects(const wxGBPosition& pos, const wxGBSpan& span);
+    bool Intersects(const wxGridPosition& pos, const wxGridSpan& span);
 
     /**
         If the item is already a member of a sizer then first ensure that there
@@ -285,70 +196,13 @@
         position, then set the new position. Returns @true if the change is
         successful and after the next Layout the item will be moved.
     */
-    bool SetPos(const wxGBPosition& pos);
+    bool SetPos(const wxGridPosition& pos);
 
-    /**
-        If the item is already a member of a sizer then first ensure that there
-        is no other item that would intersect with this one with its new
-        spanning size, then set the new spanning. Returns @true if the change
-        is successful and after the next Layout the item will be resized.
-    */
-    bool SetSpan(const wxGBSpan& span);
+
 };
 
 
 
-/**
-    @class wxGBSpan
-    @wxheader{gbsizer.h}
 
-    This class is used to hold the row and column spanning attributes of items
-    in a wxGridBagSizer.
 
-    @library{wxcore}
-    @category{winlayout}
-*/
-class wxGBSpan
-{
-public:
-    /**
-        Default constructor, setting the rowspan and colspan to (1,1) meaning
-        that the item occupies one cell in each direction.
-    */
-    wxGBSpan();
-    /**
-        Construct a new wxGBSpan, setting the @a rowspan and @a colspan.
-    */
-    wxGBSpan(int rowspan, int colspan);
 
-    /**
-        Get the current colspan value.
-    */
-    int GetColspan() const;
-
-    /**
-        Get the current rowspan value.
-    */
-    int GetRowspan() const;
-
-    /**
-        Set a new colspan value.
-    */
-    void SetColspan(int colspan);
-
-    /**
-        Set a new rowspan value.
-    */
-    void SetRowspan(int rowspan);
-
-    /**
-        Checks if the span is valid. An invalid span is (-1,-1).
-    */
-    bool operator!(const wxGBSpan& o) const;
-
-    /**
-        Compare equality of two wxGBSpans.
-    */
-    bool operator==(const wxGBSpan& o) const;
-};
-
Index: interface/sizer.h
===================================================================
--- interface/sizer.h	(revision 53980)
+++ interface/sizer.h	(working copy)
@@ -109,16 +109,18 @@
     /**
         Construct a sizer item for tracking a subsizer.
     */
-    wxSizerItem(int width, int height, int proportion, int flag,
-                int border, wxObject* userData);
-    wxSizerItem(wxWindow* window, const wxSizerFlags& flags);
     wxSizerItem(wxWindow* window, int proportion, int flag,
                 int border,
                 wxObject* userData);
-    wxSizerItem(wxSizer* window, const wxSizerFlags& flags);
+    wxSizerItem(wxWindow* window, const wxSizerFlags& flags, 
+                wxObject* userData = NULL);
     wxSizerItem(wxSizer* sizer, int proportion, int flag,
                 int border,
                 wxObject* userData);
+    wxSizerItem(wxSizer* sizer, const wxSizerFlags& flags,
+                wxObject* userData = NULL);
+    wxSizerItem(int width, int height, int proportion, int flag,
+                int border, wxObject* userData);
     //@}
 
     /**
@@ -314,6 +316,26 @@
         window then it is shown or hidden as needed.
     */
     void Show(bool show);
+    
+    /**
+        Sets the row and column span of an item, which will be applied after 
+        the next Layout. The return value is meaningless, and is only 
+        retained for compatibility reasons with wxGBSizerItem. 
+        
+        @since  2.9.0
+        
+        @note   Only supported by wxGridSpan derived classes
+    */
+    bool SetSpan(const wxGridSpan& span);
+    
+    /**
+        Gets the row and column span of an item. 
+        
+        @since  2.9.0
+        
+        @note   Only supported by wxGridSpan derived classes
+    */
+    wxGridSpan GetSpan() const;
 };
 
 
@@ -405,6 +427,15 @@
         Center() for people with the other dialect of English.
     */
     wxSizerFlags& Centre();
+    
+    /**
+        Sets how many columns the item spans.
+        
+        @since  2.9.0
+        
+        @note   Only supported by wxGridSizer derived classes
+    */
+    wxSizerFlags& ColSpan(int cols);
 
     /**
         Sets the border in the given @a direction having twice the default
@@ -464,12 +495,33 @@
         @see Align()
     */
     wxSizerFlags& Right();
+    
+    
+    /**
+        Sets how many rows the item spans.
+        
+        @since  2.9.0
+        
+        @note   Only supported by wxGridSizer derived classes
+    */
+    wxSizerFlags& RowSpan(int rows);
 
     /**
         Set the @c wx_SHAPED flag which indicates that the elements should
         always keep the fixed width to height ratio equal to its original value.
     */
     wxSizerFlags& Shaped();
+    
+    /**
+        Sets row and column spanning for an item simultaneously.
+        
+        @since  2.9.0
+        
+        @note   Only supported by wxGridSizer derived classes
+        
+        @see    ColSpan(), RowSpan()
+    */
+    wxSizerFlags& Span(wxGridSpan span);
 
     /**
         Aligns the object to the top, shortcut for @c Align(wxALIGN_TOP)
@@ -543,7 +595,20 @@
     direction in order to fill the available space. The
     wxFlexGridSizer::SetNonFlexibleGrowMode method
     serves this purpose.
+    
+    Since wxWidgets 2.9.0, wxFlexGridSizer supports spanning items to 
+    multiple rows or columns using wxGridSpan and wxSizerFlags. 
 
+    @note   When one or more items span an entire row or column, that row
+            or column may appear to collapse into only one row or column and 
+            each item in it will be its normal size instead of some 
+            multiple thereof. Despite that in some instances this may seem 
+            non-intuitive andincorrect, there are also many other instances 
+            where this would be a desired behavior. Therefore, the collapsing 
+            behavior is by design, and should not be reported as a bug. Refer 
+            to the "complex wxFlexGridSizer" example in the Layout sample 
+            for examples of this. 
+    
     @library{wxcore}
     @category{winlayout}
 
@@ -1518,10 +1583,14 @@
     @class wxGridSizer
     @wxheader{sizer.h}
 
-    A grid sizer is a sizer which lays out its children in a two-dimensional
-    table with all table fields having the same size,
+    A grid sizer is a wxSizer which lays out its children in a 
+    two-dimensional table with all table fields having the same size,
     i.e. the width of each field is the width of the widest child,
     the height of each field is the height of the tallest child.
+    
+    Since wxWidgets 2.9.0, wxGridSizer and all derived classes such as
+    wxFlexGridSizer now support spanning items to multiple rows or columns 
+    using wxGridSpan and wxSizerFlags.
 
     @library{wxcore}
     @category{winlayout}
@@ -1582,6 +1651,55 @@
         Sets the vertical gap (in pixels) between the cells in the sizer.
     */
     void SetVGap(int gap);
+    
+    /**
+        Get the size of the specified cell, including hgap and vgap.  Only
+        valid after a layout.
+        
+        @since 2.9.0
+    */
+    wxSize GetCellSize(int row, int col) const;
+
+    //@{
+    /**
+        Get the grid position of the specified item (non-recursive). Only
+        valid after a layout. 
+        
+        @since 2.9.0
+    */
+    wxGridPosition GetItemPosition(wxWindow *window);
+    wxGridPosition GetItemPosition(wxSizer *sizer);
+    wxGridPosition GetItemPosition(size_t index);
+    //@}
+
+    //@{
+    /** 
+        Get the row/column spanning of the specified item (non-recursive).
+        
+        @since 2.9.0
+    */
+    wxGridSpan GetItemSpan(wxWindow *window);
+    wxGridSpan GetItemSpan(wxSizer *sizer);
+    wxGridSpan GetItemSpan(size_t index);
+    //@}
+    
+    
+    //@{
+    /**
+        Set the row/column spanning of the specified item. Returns @true on
+        success (non-recursive).
+        
+        @since 2.9.0
+        
+        @note   wxGridSizer always returns @true, only some derived classes 
+                will return @false (such as wxGBSizer).
+                
+        @see    wxSizerFlags::RowSpan(), wxSizerFlags::ColSpan()
+    */
+    bool SetItemSpan(wxWindow *window, const wxGridSpan& span);
+    bool SetItemSpan(wxSizer *sizer, const wxGridSpan& span);
+    bool SetItemSpan(size_t index, const wxGridSpan& span);
+    //@}
 };
 
 
@@ -1672,3 +1790,117 @@
     void RecalcSizes();
 };
 
+/**
+    @class wxGridPosition
+    @wxheader{sizer.h}
+
+    This class represents the position of an item in a virtual grid of rows and
+    columns managed by a wxGridSizer.
+
+    @library{wxcore}
+    @category{winlayout}
+*/
+class wxGridPosition
+{
+public:
+    /**
+        Default constructor, setting the row and column to (0,0).
+    */
+    wxGridPosition();
+    /**
+        Construct a new wxGridPosition, setting the row and column.
+    */
+    wxGridPosition(int row, int col);
+
+    /**
+        Get the current column value.
+    */
+    int GetCol() const;
+
+    /**
+        Get the current row value.
+    */
+    int GetRow() const;
+
+    /**
+        Set a new column value.
+    */
+    void SetCol(int col);
+
+    /**
+        Set a new row value.
+    */
+    void SetRow(int row);
+
+    /**
+        Checks if the position is valid. An invalid position is (-1,-1).
+    */
+    bool operator!(const wxGridPosition& p) const;
+
+    /**
+        Compare equality of two wxGridPositions.
+    */
+    bool operator==(const wxGridPosition& p) const;
+};
+
+
+/**
+    @class wxGridSpan
+    @wxheader{sizer.h}
+
+    This class is used to hold the row and column spanning attributes of items
+    in a wxGridSizer.
+
+    @library{wxcore}
+    @category{winlayout}
+*/
+class wxGridSpan
+{
+public:
+    /**
+        Default constructor, setting the rowspan and colspan to (1,1) meaning
+        that the item occupies one cell in each direction.
+    */
+    wxGridSpan();
+    /**
+        Construct a new wxGridSpan, setting the @a rowspan and @a colspan.
+    */
+    wxGridSpan(int rowspan, int colspan);
+
+    /**
+        Get the current colspan value.
+    */
+    int GetColspan() const;
+
+    /**
+        Get the current rowspan value.
+    */
+    int GetRowspan() const;
+
+    /**
+        Set a new colspan value.
+    */
+    void SetColspan(int colspan);
+
+    /**
+        Set a new rowspan value.
+    */
+    void SetRowspan(int rowspan);
+
+    /**
+        Checks if the span is valid. An invalid span is (-1,-1).
+    */
+    bool operator!(const wxGridSpan& o) const;
+
+    /**
+        Compare equality of two wxGridSpans.
+    */
+    bool operator==(const wxGridSpan& o) const;
+};
+
+
+
+
+
+
+
Index: samples/layout/layout.cpp
===================================================================
--- samples/layout/layout.cpp	(revision 53980)
+++ samples/layout/layout.cpp	(working copy)
@@ -2,7 +2,7 @@
 // Name:        layout.cpp
 // Purpose:     Layout sample
 // Author:      Julian Smart
-// Modified by: Robin Dunn, Vadim Zeitlin
+// Modified by: Robin Dunn, Vadim Zeitlin, Dustin Spicuzza
 // Created:     04/01/98
 // RCS-ID:      $Id$
 // Copyright:   (c) 1998 Julian Smart
@@ -27,6 +27,7 @@
 
 #include "wx/sizer.h"
 #include "wx/gbsizer.h"
+#include "wx/wrapsizer.h"
 #include "wx/statline.h"
 #include "wx/notebook.h"
 #include "wx/spinctrl.h"
@@ -62,12 +63,14 @@
   EVT_MENU(LAYOUT_QUIT, MyFrame::OnQuit)
 
   EVT_MENU(LAYOUT_TEST_PROPORTIONS, MyFrame::TestProportions)
-  EVT_MENU(LAYOUT_TEST_SIZER, MyFrame::TestFlexSizers)
+  EVT_MENU(LAYOUT_TEST_FLEX_SIZER, MyFrame::TestFlexSizers)
   EVT_MENU(LAYOUT_TEST_NB_SIZER, MyFrame::TestNotebookSizers)
   EVT_MENU(LAYOUT_TEST_GB_SIZER, MyFrame::TestGridBagSizer)
   EVT_MENU(LAYOUT_TEST_SET_MINIMAL, MyFrame::TestSetMinimal)
   EVT_MENU(LAYOUT_TEST_NESTED, MyFrame::TestNested)
   EVT_MENU(LAYOUT_TEST_WRAP, MyFrame::TestWrap)
+  EVT_MENU(LAYOUT_TEST_COMPLEX_GRID_SIZER, MyFrame::TestComplexGridSizers)
+  EVT_MENU(LAYOUT_TEST_COMPLEX_FLEX_GRID_SIZER, MyFrame::TestComplexFlexGridSizers)
 END_EVENT_TABLE()
 
 // Define my frame constructor
@@ -80,12 +83,14 @@
   wxMenu *file_menu = new wxMenu;
 
   file_menu->Append(LAYOUT_TEST_PROPORTIONS, _T("&Proportions demo...\tF1"));
-  file_menu->Append(LAYOUT_TEST_SIZER, _T("Test wx&FlexSizer...\tF2"));
+  file_menu->Append(LAYOUT_TEST_FLEX_SIZER, _T("Test wx&FlexGridSizer...\tF2"));
   file_menu->Append(LAYOUT_TEST_NB_SIZER, _T("Test &notebook sizers...\tF3"));
   file_menu->Append(LAYOUT_TEST_GB_SIZER, _T("Test &gridbag sizer...\tF4"));
   file_menu->Append(LAYOUT_TEST_SET_MINIMAL, _T("Test Set&ItemMinSize...\tF5"));
   file_menu->Append(LAYOUT_TEST_NESTED, _T("Test nested sizer in a wxPanel...\tF6"));
-  file_menu->Append(LAYOUT_TEST_WRAP, _T("Test wrap sizers...\tF6"));
+  file_menu->Append(LAYOUT_TEST_WRAP, _T("Test wrap sizers...\tF7"));
+  file_menu->Append(LAYOUT_TEST_COMPLEX_GRID_SIZER, _T("Test complex wx&GridSizer...\tF8"));
+  file_menu->Append(LAYOUT_TEST_COMPLEX_FLEX_GRID_SIZER, _T("Test complex wx&FlexGridSizer...\tF9"));
 
   file_menu->AppendSeparator();
   file_menu->Append(LAYOUT_QUIT, _T("E&xit"), _T("Quit program"));
@@ -189,6 +194,18 @@
     (new MyProportionsFrame(this))->Show();
 }
 
+void MyFrame::TestComplexGridSizers(wxCommandEvent& WXUNUSED(event) )
+{
+    MyGridSizerFrame *newFrame = new MyGridSizerFrame(_T("Complex Grid Sizer Test Frame"), 50, 50);
+    newFrame->Show(true);
+}
+
+void MyFrame::TestComplexFlexGridSizers(wxCommandEvent& WXUNUSED(event) )
+{
+    MyComplexFlexGridSizer *newFrame = new MyComplexFlexGridSizer(_T("Complex Flex Sizer Test Frame"), 50, 50);
+    newFrame->Show(true);
+}
+
 void MyFrame::TestFlexSizers(wxCommandEvent& WXUNUSED(event) )
 {
     MyFlexSizerFrame *newFrame = new MyFlexSizerFrame(_T("Flex Sizer Test Frame"), 50, 50);
@@ -292,6 +309,56 @@
 }
 
 // ----------------------------------------------------------------------------
+//  MyGridSizerFrame
+// ----------------------------------------------------------------------------
+
+void MyGridSizerFrame::AddCtrl(wxGridSizer* sizer, wxWindow* parent, int row, int col, int rowspan, int colspan)
+{
+    sizer->Add(new wxButton
+                   (
+                    parent,
+                    wxID_ANY,
+                    wxString::Format(_T("(%d, %d) rs=%d cs=%d"), row, col, rowspan, colspan),
+                    wxDefaultPosition,
+                    wxDefaultSize
+                   ),
+                wxSizerFlags().Expand().Border(wxALL, 3).RowSpan(rowspan).ColSpan(colspan)
+    );
+}
+
+MyGridSizerFrame::MyGridSizerFrame(const wxString &title, int x, int y )
+            : wxFrame(NULL, wxID_ANY, title, wxPoint(x, y) )
+{
+    wxPanel* p = new wxPanel(this, wxID_ANY);
+    wxBoxSizer * sz = new wxBoxSizer(wxVERTICAL);
+
+    // create grids
+    wxGridSizer *sizer = new wxGridSizer(5, 0, 20);
+    AddCtrl(sizer, p, 0, 0, 2, 2);
+    AddCtrl(sizer, p, 0, 2, 2, 3);
+    AddCtrl(sizer, p, 2, 0, 3, 2);
+    AddCtrl(sizer, p, 2, 2, 1, 1);
+    AddCtrl(sizer, p, 2, 3, 1, 2);
+    AddCtrl(sizer, p, 3, 2, 2, 1);
+    AddCtrl(sizer, p, 3, 3, 1, 1);
+    AddCtrl(sizer, p, 3, 4, 1, 1);
+    AddCtrl(sizer, p, 4, 3, 1, 1);
+    AddCtrl(sizer, p, 4, 4, 1, 1);
+    sz->Add(sizer, wxSizerFlags(1).Expand());
+
+    sizer = new wxGridSizer(3, 0, 20);
+    AddCtrl(sizer, p, 0, 0, 1, 1);
+    AddCtrl(sizer, p, 0, 1, 1, 2);
+    AddCtrl(sizer, p, 1, 0, 2, 1);
+    AddCtrl(sizer, p, 1, 1, 2, 2);
+    sz->Add(sizer, wxSizerFlags(1).Expand());
+
+    p->SetSizer(sz);
+    sz->SetSizeHints(this);
+}
+
+
+// ----------------------------------------------------------------------------
 //  MyFlexSizerFrame
 // ----------------------------------------------------------------------------
 
@@ -301,7 +368,18 @@
     {
         for ( int j = 0; j < 3; j++ )
         {
-            sizer->Add(new wxStaticText
+            // I think this is a better test, personally
+           sizer->Add(new wxButton
+               (
+                parent,
+                wxID_ANY,
+                wxString::Format(_T("(%d, %d)"), i, j),
+                wxDefaultPosition,
+                wxDefaultSize
+               ),
+                wxSizerFlags().Expand().Border(wxALL, 3)
+            );
+            /*sizer->Add(new wxStaticText
                            (
                             parent,
                             wxID_ANY,
@@ -311,6 +389,7 @@
                             wxALIGN_CENTER
                            ),
                        0, wxEXPAND | wxALIGN_CENTER_VERTICAL | wxALL, 3);
+            */
         }
     }
 }
@@ -319,79 +398,197 @@
             : wxFrame(NULL, wxID_ANY, title, wxPoint(x, y) )
 {
     wxFlexGridSizer *sizerFlex;
+    wxBoxSizer *sizerBox;
+
     wxPanel* p = new wxPanel(this, wxID_ANY);
 
-    // consttuct the first column
-    wxSizer *sizerCol1 = new wxBoxSizer(wxVERTICAL);
-    sizerCol1->Add(new wxStaticText(p, wxID_ANY, _T("Ungrowable:")), 0, wxCENTER | wxTOP, 20);
+    wxSizer *sizer = new wxGridSizer(2, 5, 5);
+
+    sizerBox = new wxBoxSizer(wxVERTICAL);
+    sizerBox->Add(new wxStaticText(p, wxID_ANY, _T("Ungrowable:")), wxSizerFlags(0).Center().Border(wxTOP, 20));
     sizerFlex = new wxFlexGridSizer(3, 3);
     InitFlexSizer(sizerFlex, p);
-    sizerCol1->Add(sizerFlex, 1, wxALL | wxEXPAND, 10);
+    sizerBox->Add(sizerFlex, wxSizerFlags(1).Expand().Border(10));
+    sizer->Add(sizerBox, wxSizerFlags(1).Expand());
 
-    sizerCol1->Add(new wxStaticText(p, wxID_ANY, _T("Growable middle column:")), 0, wxCENTER | wxTOP, 20);
+    sizerBox = new wxBoxSizer(wxVERTICAL);
+    sizerBox->Add(new wxStaticText(p, wxID_ANY, _T("Growable middle row and column:")), wxSizerFlags(0).Center().Border(wxTOP, 20));
     sizerFlex = new wxFlexGridSizer(3, 3);
     InitFlexSizer(sizerFlex, p);
     sizerFlex->AddGrowableCol(1);
-    sizerCol1->Add(sizerFlex, 1, wxALL | wxEXPAND, 10);
-
-    sizerCol1->Add(new wxStaticText(p, wxID_ANY, _T("Growable middle row:")), 0, wxCENTER | wxTOP, 20);
-    sizerFlex = new wxFlexGridSizer(3, 3);
-    InitFlexSizer(sizerFlex, p);
     sizerFlex->AddGrowableRow(1);
-    sizerCol1->Add(sizerFlex, 1, wxALL | wxEXPAND, 10);
+    sizerBox->Add(sizerFlex, wxSizerFlags(1).Expand().Border(10));
+    sizer->Add(sizerBox, wxSizerFlags(1).Expand());
 
-    sizerCol1->Add(new wxStaticText(p, wxID_ANY, _T("All growable columns:")), 0, wxCENTER | wxTOP, 20);
+    sizerBox = new wxBoxSizer(wxVERTICAL);
+    sizerBox->Add(new wxStaticText(p, wxID_ANY, _T("Growable middle column:")), wxSizerFlags(0).Center().Border(wxTOP, 20));
     sizerFlex = new wxFlexGridSizer(3, 3);
     InitFlexSizer(sizerFlex, p);
-    sizerFlex->AddGrowableCol(0, 1);
-    sizerFlex->AddGrowableCol(1, 2);
-    sizerFlex->AddGrowableCol(2, 3);
-    sizerCol1->Add(sizerFlex, 1, wxALL | wxEXPAND, 10);
+    sizerFlex->AddGrowableCol(1);
+    sizerBox->Add(sizerFlex, wxSizerFlags(1).Expand().Border(10));
+    sizer->Add(sizerBox, wxSizerFlags(1).Expand());
 
-    // the second one
-    wxSizer *sizerCol2 = new wxBoxSizer(wxVERTICAL);
-    sizerCol2->Add(new wxStaticText(p, wxID_ANY, _T("Growable middle row and column:")), 0, wxCENTER | wxTOP, 20);
+    sizerBox = new wxBoxSizer(wxVERTICAL);
+    sizerBox->Add(new wxStaticText(p, wxID_ANY, _T("Same with horz flex direction")), wxSizerFlags(0).Center().Border(wxTOP, 20));
     sizerFlex = new wxFlexGridSizer(3, 3);
     InitFlexSizer(sizerFlex, p);
     sizerFlex->AddGrowableCol(1);
     sizerFlex->AddGrowableRow(1);
-    sizerCol2->Add(sizerFlex, 1, wxALL | wxEXPAND, 10);
+    sizerFlex->SetFlexibleDirection(wxHORIZONTAL);
+    sizerBox->Add(sizerFlex, wxSizerFlags(1).Expand().Border(10));
+    sizer->Add(sizerBox, wxSizerFlags(1).Expand());
 
-    sizerCol2->Add(new wxStaticText(p, wxID_ANY, _T("Same with horz flex direction")), 0, wxCENTER | wxTOP, 20);
+    sizerBox = new wxBoxSizer(wxVERTICAL);
+    sizerBox->Add(new wxStaticText(p, wxID_ANY, _T("Growable middle row:")), wxSizerFlags(0).Center().Border(wxTOP, 20));
     sizerFlex = new wxFlexGridSizer(3, 3);
     InitFlexSizer(sizerFlex, p);
-    sizerFlex->AddGrowableCol(1);
     sizerFlex->AddGrowableRow(1);
-    sizerFlex->SetFlexibleDirection(wxHORIZONTAL);
-    sizerCol2->Add(sizerFlex, 1, wxALL | wxEXPAND, 10);
+    sizerBox->Add(sizerFlex, wxSizerFlags(1).Expand().Border(10));
+    sizer->Add(sizerBox, wxSizerFlags(1).Expand());
 
-    sizerCol2->Add(new wxStaticText(p, wxID_ANY, _T("Same with grow mode == \"none\"")), 0, wxCENTER | wxTOP, 20);
+    sizerBox = new wxBoxSizer(wxVERTICAL);
+    sizerBox->Add(new wxStaticText(p, wxID_ANY, _T("Same with grow mode == \"none\"")), wxSizerFlags(0).Center().Border(wxTOP, 20));
     sizerFlex = new wxFlexGridSizer(3, 3);
     InitFlexSizer(sizerFlex, p);
     sizerFlex->AddGrowableCol(1);
     sizerFlex->AddGrowableRow(1);
     sizerFlex->SetFlexibleDirection(wxHORIZONTAL);
     sizerFlex->SetNonFlexibleGrowMode(wxFLEX_GROWMODE_NONE);
-    sizerCol2->Add(sizerFlex, 1, wxALL | wxEXPAND, 10);
+    sizerBox->Add(sizerFlex, wxSizerFlags(1).Expand().Border(10));
+    sizer->Add(sizerBox, wxSizerFlags(1).Expand());
 
-    sizerCol2->Add(new wxStaticText(p, wxID_ANY, _T("Same with grow mode == \"all\"")), 0, wxCENTER | wxTOP, 20);
+    sizerBox = new wxBoxSizer(wxVERTICAL);
+    sizerBox->Add(new wxStaticText(p, wxID_ANY, _T("All growable columns (proportions: 1, 2, 3):")), wxSizerFlags(0).Center().Border(wxTOP, 20));
     sizerFlex = new wxFlexGridSizer(3, 3);
     InitFlexSizer(sizerFlex, p);
+    sizerFlex->AddGrowableCol(0, 1);
+    sizerFlex->AddGrowableCol(1, 2);
+    sizerFlex->AddGrowableCol(2, 3);
+    sizerBox->Add(sizerFlex, wxSizerFlags(1).Expand().Border(10));
+    sizer->Add(sizerBox, wxSizerFlags(1).Expand());
+
+    sizerBox = new wxBoxSizer(wxVERTICAL);
+    sizerBox->Add(new wxStaticText(p, wxID_ANY, _T("Same with grow mode == \"all\"")), wxSizerFlags(0).Center().Border(wxTOP, 20));
+    sizerFlex = new wxFlexGridSizer(3, 3);
+    InitFlexSizer(sizerFlex, p);
     sizerFlex->AddGrowableCol(1);
     sizerFlex->AddGrowableRow(1);
     sizerFlex->SetFlexibleDirection(wxHORIZONTAL);
     sizerFlex->SetNonFlexibleGrowMode(wxFLEX_GROWMODE_ALL);
-    sizerCol2->Add(sizerFlex, 1, wxALL | wxEXPAND, 10);
+    sizerBox->Add(sizerFlex, wxSizerFlags(1).Expand().Border(10));
+    sizer->Add(sizerBox, wxSizerFlags(1).Expand());
+    
 
-    // add both columns to grid sizer
-    wxGridSizer *sizerTop = new wxGridSizer(2, 0, 20);
-    sizerTop->Add(sizerCol1, 1, wxEXPAND);
-    sizerTop->Add(sizerCol2, 1, wxEXPAND);
+    p->SetSizer(sizer);
+    sizer->SetSizeHints(this);
+}
 
-    p->SetSizer(sizerTop);
-    sizerTop->SetSizeHints(this);
+
+// ----------------------------------------------------------------------------
+//  MyComplexFlexGridSizer
+// ----------------------------------------------------------------------------
+
+// important to note that row,col aren't actually used to position the item,
+// its only used to display to the user so that we know its being displayed 
+// correctly. 
+void MyComplexFlexGridSizer::AddButton(wxGridSizer* sizer, wxWindow* parent, int row, int col, int rowspan, int colspan)
+{
+    sizer->Add(new wxButton
+                   (
+                    parent,
+                    wxID_ANY,
+                    wxString::Format(_T("(%d, %d) rs=%d cs=%d"), row, col, rowspan, colspan),
+                    wxDefaultPosition,
+                    wxDefaultSize
+                   ),
+                wxSizerFlags().Expand().Border(wxALL, 3).RowSpan(rowspan).ColSpan(colspan)
+    );
 }
 
+void MyComplexFlexGridSizer::AddPanel(wxGridSizer* sizer, wxWindow* parent, int w, int h, int rowspan, int colspan, const wxColor * color)
+{
+    wxPanel *p = new wxPanel
+       (
+        parent,
+        wxID_ANY,
+        wxDefaultPosition,
+        wxSize(w,h)
+       );
+
+    p->SetBackgroundColour(*color);
+
+    sizer->Add(p, wxSizerFlags().Expand().RowSpan(rowspan).ColSpan(colspan));
+}
+
+MyComplexFlexGridSizer::MyComplexFlexGridSizer(const wxString &title, int x, int y )
+            : wxFrame(NULL, wxID_ANY, title, wxPoint(x, y) )
+{
+    wxFlexGridSizer *sizerFlex;
+    wxPanel* p = new wxPanel(this, wxID_ANY);
+
+    wxSizer *sizer = new wxBoxSizer(wxVERTICAL);
+
+    // try to show any special cases here
+
+    // handled incorrectly, can cause the table to be bigger than it should
+    sizer->Add(new wxStaticText(p, wxID_ANY, _T("1x3 grid\n(bottom should be: 10%, 90%)")), wxSizerFlags(0).Align(wxCENTER).Center().Border(wxTOP, 20));
+    sizerFlex = new wxFlexGridSizer(3, 1, 1);
+    AddPanel(sizerFlex, p, 200, 10, 1, 3, wxRED); 
+    AddPanel(sizerFlex, p, 20, 10, 1, 1, wxGREEN);
+    AddPanel(sizerFlex, p, 180, 10, 1, 2, wxBLUE);
+    sizer->Add(sizerFlex);
+
+    // this one IS bigger than it should be
+    sizer->Add(new wxStaticText(p, wxID_ANY, _T("incorrectly rendered 1x5 grid with overflow\n(bottom should be: 50%, 40%, 10%)")), wxSizerFlags(0).Align(wxCENTER).Center().Border(wxTOP, 20));
+    sizerFlex = new wxFlexGridSizer(5, 1, 1);
+    AddPanel(sizerFlex, p, 200, 10, 1, 5, wxRED); 
+    AddPanel(sizerFlex, p, 100, 10, 1, 1, wxBLUE);
+    AddPanel(sizerFlex, p, 80, 10, 1, 2, wxGREEN);
+    AddPanel(sizerFlex, p, 20, 10, 1, 2, wxWHITE);
+    sizer->Add(sizerFlex);
+
+    // this illustrates the collapsing behavior, which could be alternatively
+    // considered a bug or a feature
+    sizer->Add(new wxStaticText(p, wxID_ANY, _T("3x3 grid with collapsing spans")), wxSizerFlags(0).Center().Border(wxTOP, 20));
+    sizerFlex = new wxFlexGridSizer(3, 5, 5);
+    AddButton(sizerFlex, p, 0, 0, 1, 1);
+    AddButton(sizerFlex, p, 0, 1, 1, 2);
+    AddButton(sizerFlex, p, 1, 0, 2, 1);
+    AddButton(sizerFlex, p, 1, 1, 2, 2);
+    sizer->Add(sizerFlex);
+
+    // special overflow II, imperfect grid, either a bug or a feature
+    sizer->Add(new wxStaticText(p, wxID_ANY, _T("Almost filled 5x3 collapsing grid")), wxSizerFlags(0).Center().Border(wxTOP, 20));
+    sizerFlex = new wxFlexGridSizer(5, 5, 5);
+    AddButton(sizerFlex, p, 0, 0, 1, 5);
+    AddButton(sizerFlex, p, 1, 0, 1, 3);
+    AddButton(sizerFlex, p, 1, 3, 1, 2);
+    AddButton(sizerFlex, p, 2, 0, 1, 1);
+    AddButton(sizerFlex, p, 2, 1, 1, 2);
+    sizer->Add(sizerFlex);
+
+    // similar to the complex gridsizer example, shows that complex layouts
+    // will work correctly. 
+    sizer->Add(new wxStaticText(p, wxID_ANY, _T("4x4 multi-spanned grid")), wxSizerFlags(0).Center().Border(wxTOP, 20));
+    sizerFlex = new wxFlexGridSizer(4, 5, 5);
+    AddButton(sizerFlex, p, 0, 0, 1, 4);
+    AddButton(sizerFlex, p, 1, 0, 3, 1);
+    AddButton(sizerFlex, p, 1, 1, 1, 1);
+    AddButton(sizerFlex, p, 1, 2, 1, 2);
+    AddButton(sizerFlex, p, 2, 1, 2, 1);
+    AddButton(sizerFlex, p, 2, 2, 1, 1);
+    AddButton(sizerFlex, p, 2, 3, 1, 1);
+    AddButton(sizerFlex, p, 3, 2, 1, 2);
+    sizerFlex->AddGrowableCol(2);
+    sizerFlex->AddGrowableRow(2);
+    sizer->Add(sizerFlex, wxSizerFlags(1).Expand());
+
+    p->SetSizer(sizer);
+    sizer->SetSizeHints(this);
+}
+
+
+
 // ----------------------------------------------------------------------------
 // MySizerDialog
 // ----------------------------------------------------------------------------
@@ -444,8 +641,8 @@
 #define SPAN(r, c)       wxGBSpan(r,c)
 
 const wxChar gbsDescription[] =_T("\
-The wxGridBagSizer is similar to the wxFlexGridSizer except the items are explicitly positioned\n\
-in a virtual cell of the layout grid, and column or row spanning is allowed.  For example, this\n\
+The wxGridBagSizer is mostly identical to the wxFlexGridSizer except the items\n\
+are explicitly positioned in a virtual cell of the layout grid. For example, this\n\
 static text is positioned at (0,0) and it spans 7 columns.");
 
 
@@ -686,6 +883,7 @@
 
     // A number of checkboxes inside a wrap sizer 
     wxSizer *ps_mid = new wxStaticBoxSizer( wxVERTICAL, this, "Wrapping check-boxes" );
+    // WrapSizer not implemented for some reason... 
     wxSizer *ps_mid_wrap = new wxWrapSizer(wxHORIZONTAL);
     ps_mid->Add( ps_mid_wrap, 100, wxEXPAND );
     for( int ix=0; ix<6; ix++ )
@@ -700,9 +898,11 @@
     ps_bottom_box->Add( 10,10 );
     ps_bottom_box->Add( new wxCheckBox(this,wxID_ANY,"A much longer option..."), 100, 0, 5 );
     
-    root->Add( ps_bottom, 1, wxEXPAND | wxALL, 5 );
+    root->Add( ps_bottom, wxSizerFlags(1).Expand().Border(wxALL,5));
         
     // Set sizer for window
     SetSizerAndFit( root );
 }
 
+
+
Index: samples/layout/layout.h
===================================================================
--- samples/layout/layout.h	(revision 53980)
+++ samples/layout/layout.h	(working copy)
@@ -2,7 +2,7 @@
 // Name:        layout.h
 // Purpose:     Layout sample
 // Author:      Julian Smart
-// Modified by:
+// Modified by:    Dustin Spicuzza
 // Created:     04/01/98
 // RCS-ID:      $Id$
 // Copyright:   (c) Julian Smart
@@ -31,6 +31,9 @@
     void TestSetMinimal(wxCommandEvent& event);
     void TestWrap(wxCommandEvent& event);
 
+    void TestComplexGridSizers(wxCommandEvent& event);
+    void TestComplexFlexGridSizers(wxCommandEvent& event);
+
     void OnAbout(wxCommandEvent& event);
     void OnQuit(wxCommandEvent& event);
 
@@ -54,17 +57,41 @@
     wxSizer *m_sizer;
 };
 
+// a frame using grid sizers for layout
+class MyGridSizerFrame : public wxFrame
+{
+public:
+    MyGridSizerFrame(const wxString &title, int x, int y );
+
+private:
+    void AddCtrl(wxGridSizer* sizer, wxWindow* parent, int row, int col, int rowspan, int colspan);
+};
+
+
 // a frame using flex sizers for layout
 class MyFlexSizerFrame : public wxFrame
 {
 public:
-    MyFlexSizerFrame(const wxString &title, int x, int y );
+    MyFlexSizerFrame(const wxString &title, int x, int y);
 
 private:
     void InitFlexSizer(wxFlexGridSizer *sizer, wxWindow* parent);
 };
 
+// a frame to test edge cases for flex sizers
+class MyComplexFlexGridSizer : public wxFrame
+{
+public:
+    MyComplexFlexGridSizer(const wxString &title, int x, int y);
 
+private:
+    void AddButton(wxGridSizer* sizer, wxWindow* parent, int row, int col, int rowspan, int colspan);
+    void AddPanel(wxGridSizer* sizer, wxWindow* parent, int w, int h, int rowspan, int colspan, const wxColor * color);
+
+    void InitFlexSizer(wxFlexGridSizer *sizer, wxWindow* parent);
+};
+
+
 // a dialog using notebook sizer for layout
 class MySizerDialog : public wxDialog
 {
@@ -138,14 +165,18 @@
 // controls and menu constants
 enum
 {
-    LAYOUT_TEST_SIZER = 101,
+    LAYOUT_TEST_PROPORTIONS = 101,
+    LAYOUT_TEST_FLEX_SIZER,
     LAYOUT_TEST_NB_SIZER,
     LAYOUT_TEST_GB_SIZER,
-    LAYOUT_TEST_PROPORTIONS,
     LAYOUT_TEST_SET_MINIMAL,
     LAYOUT_TEST_NESTED,
     LAYOUT_TEST_WRAP,
+    LAYOUT_TEST_COMPLEX_GRID_SIZER,
+    LAYOUT_TEST_COMPLEX_FLEX_GRID_SIZER,
     LAYOUT_QUIT = wxID_EXIT,
     LAYOUT_ABOUT = wxID_ABOUT
 };
 
+
+
Index: src/common/gbsizer.cpp
===================================================================
--- src/common/gbsizer.cpp	(revision 53980)
+++ src/common/gbsizer.cpp	(working copy)
@@ -4,7 +4,7 @@
 //              with items at specified cells, and with the option of row
 //              and/or column spanning
 //
-// Author:      Robin Dunn
+// Author:      Robin Dunn, contributions by Dustin Spicuzza
 // Created:     03-Nov-2003
 // RCS-ID:      $Id$
 // Copyright:   (c) Robin Dunn
@@ -25,8 +25,6 @@
 IMPLEMENT_DYNAMIC_CLASS(wxGBSizerItem, wxSizerItem)
 IMPLEMENT_CLASS(wxGridBagSizer, wxFlexGridSizer)
 
-const wxGBSpan wxDefaultSpan;
-
 //---------------------------------------------------------------------------
 // wxGBSizerItem
 //---------------------------------------------------------------------------
@@ -34,13 +32,12 @@
 wxGBSizerItem::wxGBSizerItem( int width,
                               int height,
                               const wxGBPosition& pos,
-                              const wxGBSpan& span,
+                              const wxGridSpan& span,
                               int flag,
                               int border,
                               wxObject* userData)
-    : wxSizerItem(width, height, 0, flag, border, userData),
+    : wxSizerItem(width, height, wxSizerFlags().Border(0,border).Span(span).SetFlags(flag), userData),
       m_pos(pos),
-      m_span(span),
       m_gbsizer(NULL)
 {
 }
@@ -48,13 +45,12 @@
 
 wxGBSizerItem::wxGBSizerItem( wxWindow *window,
                               const wxGBPosition& pos,
-                              const wxGBSpan& span,
+                              const wxGridSpan& span,
                               int flag,
                               int border,
                               wxObject* userData )
-    : wxSizerItem(window, 0, flag, border, userData),
+    : wxSizerItem(window, wxSizerFlags().Border(0,border).Span(span).SetFlags(flag), userData),
       m_pos(pos),
-      m_span(span),
       m_gbsizer(NULL)
 {
 }
@@ -62,13 +58,12 @@
 
 wxGBSizerItem::wxGBSizerItem( wxSizer *sizer,
                               const wxGBPosition& pos,
-                              const wxGBSpan& span,
+                              const wxGridSpan& span,
                               int flag,
                               int border,
-                              wxObject* userData )
-    : wxSizerItem(sizer, 0, flag, border, userData),
+                              wxObject* userData)
+    : wxSizerItem(sizer, wxSizerFlags().Border(0,border).Span(span).SetFlags(flag), userData),
       m_pos(pos),
-      m_span(span),
       m_gbsizer(NULL)
 {
 }
@@ -76,7 +71,6 @@
 wxGBSizerItem::wxGBSizerItem()
     : wxSizerItem(),
       m_pos(-1,-1),
-      m_span(-1,-1),
       m_gbsizer(NULL)
 {
 }
@@ -108,7 +102,7 @@
     return true;
 }
 
-bool wxGBSizerItem::SetSpan( const wxGBSpan& span )
+bool wxGBSizerItem::SetSpan( const wxGridSpan& span )
 {
     if (m_gbsizer)
     {
@@ -127,10 +121,10 @@
 
 bool wxGBSizerItem::Intersects(const wxGBSizerItem& other)
 {
-    return Intersects(other.GetPos(), other.GetSpan());
+    return Intersects(other.GetPos(), other.wxSizerItem::GetSpan());
 }
 
-bool wxGBSizerItem::Intersects(const wxGBPosition& pos, const wxGBSpan& span)
+bool wxGBSizerItem::Intersects(const wxGBPosition& pos, const wxGridSpan& span)
 {
 
     int row, col, endrow, endcol;
@@ -171,14 +165,14 @@
 
 wxGridBagSizer::wxGridBagSizer(int vgap, int hgap )
     : wxFlexGridSizer(1, vgap, hgap),
-      m_emptyCellSize(10,20)
-
+      m_emptyCellSize(10,20),
+      m_emptyCell(NULL)
 {
 }
 
 
 wxSizerItem* wxGridBagSizer::Add( wxWindow *window,
-                                  const wxGBPosition& pos, const wxGBSpan& span,
+                                  const wxGBPosition& pos, const wxGridSpan& span,
                                   int flag, int border,  wxObject* userData )
 {
     wxGBSizerItem* item = new wxGBSizerItem(window, pos, span, flag, border, userData);
@@ -192,7 +186,7 @@
 }
 
 wxSizerItem* wxGridBagSizer::Add( wxSizer *sizer,
-                          const wxGBPosition& pos, const wxGBSpan& span,
+                          const wxGBPosition& pos, const wxGridSpan& span,
                           int flag, int border,  wxObject* userData )
 {
     wxGBSizerItem* item = new wxGBSizerItem(sizer, pos, span, flag, border, userData);
@@ -206,7 +200,7 @@
 }
 
 wxSizerItem* wxGridBagSizer::Add( int width, int height,
-                          const wxGBPosition& pos, const wxGBSpan& span,
+                          const wxGBPosition& pos, const wxGridSpan& span,
                           int flag, int border,  wxObject* userData )
 {
     wxGBSizerItem* item = new wxGBSizerItem(width, height, pos, span, flag, border, userData);
@@ -231,160 +225,154 @@
     return item;
 }
 
-
-
 //---------------------------------------------------------------------------
+// These functions do the work of deciding where each item is placed. Relies
+// on base implementation of CalcMin and RecalcSizes
+//---------------------------------------------------------------------------
 
-wxSize wxGridBagSizer::GetCellSize(int row, int col) const
+int wxGridBagSizer::CalcRowsCols()
 {
-    wxCHECK_MSG( (row < m_rows) && (col < m_cols),
-                 wxDefaultSize,
-                 wxT("Invalid cell."));
-    return wxSize( m_colWidths[col], m_rowHeights[row] );
-}
+    int nitems = m_children.GetCount();
 
+    if (nitems)
+    {
+        wxSizerItemList::compatibility_iterator node = m_children.GetFirst();
+        m_cols = m_user_cols;
+        m_rows = m_user_rows;
 
-wxGBPosition wxGridBagSizer::GetItemPosition(wxWindow *window)
-{
-    wxGBPosition badpos(-1,-1);
-    wxGBSizerItem* item = FindItem(window);
-    wxCHECK_MSG(item, badpos, wxT("Failed to find item."));
-    return item->GetPos();
-}
+        // first decide what the minimum colsize is, we can override what 
+        // the user specified (for compatibility: if they didn't specify sz)
+        do {
+            const wxSizerItem * item = node->GetData();
+            const wxGridSpan span = node->GetData()->GetSpan();
+            
+            // add to the total number of items, to determine the min size
+            nitems += (span.GetRowspan() * span.GetColspan() - 1);
 
+            // determine how wide this should be rendered
+            if (item->IsKindOf(CLASSINFO(wxGBSizerItem)))
+            {
+                const wxGBPosition pos = ((wxGBSizerItem*)item)->GetPos();
+                const int t_rows = pos.GetRow() + span.GetRowspan();
+                const int t_cols = pos.GetCol() + span.GetColspan();
 
-wxGBPosition wxGridBagSizer::GetItemPosition(wxSizer *sizer)
-{
-    wxGBPosition badpos(-1,-1);
-    wxGBSizerItem* item = FindItem(sizer);
-    wxCHECK_MSG(item, badpos, wxT("Failed to find item."));
-    return item->GetPos();
-}
+                m_rows = wxMax(m_rows, t_rows );
+                m_cols = wxMax(m_cols, t_cols );
+            }
 
+        } while (node = node->GetNext());
 
-wxGBPosition wxGridBagSizer::GetItemPosition(size_t index)
-{
-    wxGBPosition badpos(-1,-1);
-    wxSizerItemList::compatibility_iterator node = m_children.Item( index );
-    wxCHECK_MSG( node, badpos, _T("Failed to find item.") );
-    wxGBSizerItem* item = (wxGBSizerItem*)node->GetData();
-    return item->GetPos();
-}
+        // now calculate another number
+        int _m_rows = (nitems + m_cols - 1) / m_cols;
 
+        // and ensure that it is >= the biggest absolutely positioned item
+        m_rows = wxMax(_m_rows, m_rows);
 
+        // populate the grid
+        PopulateGrid();
+    }
 
-bool wxGridBagSizer::SetItemPosition(wxWindow *window, const wxGBPosition& pos)
-{
-    wxGBSizerItem* item = FindItem(window);
-    wxCHECK_MSG(item, false, wxT("Failed to find item."));
-    return item->SetPos(pos);
+    return nitems;
 }
 
-
-bool wxGridBagSizer::SetItemPosition(wxSizer *sizer, const wxGBPosition& pos)
+// helper function, populates all the appropriate grid items
+static inline
+void DoPopulateSpans(wxSizerItem *item, const int r, const int c, 
+                     const int nrows, const int ncols, wxSizerItemPtrArray &gridTable)
 {
-    wxGBSizerItem* item = FindItem(sizer);
-    wxCHECK_MSG(item, false, wxT("Failed to find item."));
-    return item->SetPos(pos);
-}
+        // determine if it spans
+    const wxGridSpan span = item->GetSpan();
+    int cs = span.GetColspan();
+    int rs = span.GetRowspan();
+    
+    if (cs > 1 || rs > 1)
+    {
+        // since it spans, fill out its places in the array
+        wxASSERT_MSG(c + cs <= ncols, _T("An item is overflowing its column"));
+        wxASSERT_MSG(r + rs <= nrows, _T("An item is overflowing its row"));
 
+        cs = c + cs > ncols ? ncols : c + cs;
+        rs = r + rs > nrows ? nrows : r + rs;
 
-bool wxGridBagSizer::SetItemPosition(size_t index, const wxGBPosition& pos)
-{
-    wxSizerItemList::compatibility_iterator node = m_children.Item( index );
-    wxCHECK_MSG( node, false, _T("Failed to find item.") );
-    wxGBSizerItem* item = (wxGBSizerItem*)node->GetData();
-    return item->SetPos(pos);
+        for (int t_r = r; t_r < rs; t_r++)
+        {
+            int t_offset = t_r*ncols;
+            for (int t_c = c; t_c < cs; t_c++)
+            {
+                wxASSERT_MSG(!gridTable[t_offset + t_c], _T("An item is spanning over another item!"));
+                gridTable[t_offset + t_c] = (wxSizerItem*)1;
+            }
+        }
+    }
 }
 
-
-
-wxGBSpan wxGridBagSizer::GetItemSpan(wxWindow *window)
+void wxGridBagSizer::PopulateGrid()
 {
-    wxGBSpan badspan(-1,-1);
-    wxGBSizerItem* item = FindItem(window);
-    wxCHECK_MSG( item, badspan, _T("Failed to find item.") );
-    return item->GetSpan();
-}
+    // ok, so what happens here is we first iterate through the children,
+    // and place anyone who desires to be placed absolutely. Next, we go
+    // through and place the rest of them. Hopefully there aren't
+    // any conflicts
 
+    wxSizerItemList::const_iterator i = m_children.begin();
+    const wxSizerItemList::const_iterator end = m_children.end();
 
-wxGBSpan wxGridBagSizer::GetItemSpan(wxSizer *sizer)
-{
-    wxGBSpan badspan(-1,-1);
-    wxGBSizerItem* item = FindItem(sizer);
-    wxCHECK_MSG( item, badspan, _T("Failed to find item.") );
-    return item->GetSpan();
-}
+    // initialize the table
+    m_gridTable.Clear();
+    m_gridTable.Add(NULL, m_rows*m_cols);
 
+    // absolute items first
+    do {
+        
+        if (!(*i)->IsKindOf(CLASSINFO(wxGBSizerItem)))
+            continue; 
 
-wxGBSpan wxGridBagSizer::GetItemSpan(size_t index)
-{
-    wxGBSpan badspan(-1,-1);
-    wxSizerItemList::compatibility_iterator node = m_children.Item( index );
-    wxCHECK_MSG( node, badspan, _T("Failed to find item.") );
-    wxGBSizerItem* item = (wxGBSizerItem*)node->GetData();
-    return item->GetSpan();
-}
+        wxGBPosition pos = ((wxGBSizerItem*)(*i))->GetPos();
+        
+        DoPopulateSpans(*i, pos.GetRow() , pos.GetCol(), m_rows, m_cols, m_gridTable);
+        m_gridTable[pos.GetRow()*m_cols + pos.GetCol()] = *i;
 
+    } while (++i != end);
 
+    // anything else next.. restart iteration
+    i = m_children.begin();
 
-bool wxGridBagSizer::SetItemSpan(wxWindow *window, const wxGBSpan& span)
-{
-    wxGBSizerItem* item = FindItem(window);
-    wxCHECK_MSG(item, false, wxT("Failed to find item."));
-    return item->SetSpan(span);
-}
+    for (int r = 0; r < m_rows; r++)
+    {
+        int offset = r*m_cols;
 
+        for (int c = 0; c < m_cols; c++)
+        {
+            if ((*i)->IsKindOf(CLASSINFO(wxGBSizerItem)))
+                continue;
 
-bool wxGridBagSizer::SetItemSpan(wxSizer *sizer, const wxGBSpan& span)
-{
-    wxGBSizerItem* item = FindItem(sizer);
-    wxCHECK_MSG(item, false, wxT("Failed to find item."));
-    return item->SetSpan(span);
-}
+            // if nothing is already here, then do stuff
+            if (!m_gridTable[offset + c])
+            {
+                DoPopulateSpans(*i, r, c, m_rows, m_cols, m_gridTable);
+                m_gridTable[offset + c] = *i;
 
+                if (++i == end)
+                    break;
+            }   
+        }
 
-bool wxGridBagSizer::SetItemSpan(size_t index, const wxGBSpan& span)
-{
-    wxSizerItemList::compatibility_iterator node = m_children.Item( index );
-    wxCHECK_MSG( node, false, _T("Failed to find item.") );
-    wxGBSizerItem* item = (wxGBSizerItem*)node->GetData();
-    return item->SetSpan(span);
-}
-
-
-
-
-wxGBSizerItem* wxGridBagSizer::FindItem(wxWindow* window)
-{
-    wxSizerItemList::compatibility_iterator node = m_children.GetFirst();
-    while (node)
-    {
-        wxGBSizerItem* item = (wxGBSizerItem*)node->GetData();
-        if ( item->GetWindow() == window )
-            return item;
-        node = node->GetNext();
+        if (i == end)
+            break;
     }
-    return NULL;
-}
 
+    // then anything else that is empty, fill it with emptiness
+    if (m_emptyCell) delete m_emptyCell;
+    m_emptyCell = new wxSizerItem(m_emptyCellSize.x, m_emptyCellSize.y, wxSizerFlags());
+    int count = m_gridTable.GetCount();
 
-wxGBSizerItem* wxGridBagSizer::FindItem(wxSizer* sizer)
-{
-    wxSizerItemList::compatibility_iterator node = m_children.GetFirst();
-    while (node)
-    {
-        wxGBSizerItem* item = (wxGBSizerItem*)node->GetData();
-        if ( item->GetSizer() == sizer )
-            return item;
-        node = node->GetNext();
-    }
-    return NULL;
+    for (int x = 0; x < count; x++)
+        if (!m_gridTable[x])
+            m_gridTable[x] = m_emptyCell;
 }
 
 
+//---------------------------------------------------------------------------
 
-
 wxGBSizerItem* wxGridBagSizer::FindItemAtPosition(const wxGBPosition& pos)
 {
     wxSizerItemList::compatibility_iterator node = m_children.GetFirst();
@@ -398,9 +386,6 @@
     return NULL;
 }
 
-
-
-
 wxGBSizerItem* wxGridBagSizer::FindItemAtPoint(const wxPoint& pt)
 {
     wxSizerItemList::compatibility_iterator node = m_children.GetFirst();
@@ -416,9 +401,6 @@
     return NULL;
 }
 
-
-
-
 wxGBSizerItem* wxGridBagSizer::FindItemWithData(const wxObject* userData)
 {
     wxSizerItemList::compatibility_iterator node = m_children.GetFirst();
@@ -432,355 +414,62 @@
     return NULL;
 }
 
-
-
-
-//---------------------------------------------------------------------------
-
-// Figure out what all the min row heights and col widths are, and calculate
-// min size from that.
-wxSize wxGridBagSizer::CalcMin()
+bool wxGridBagSizer::SetItemPosition(wxWindow *window, const wxGBPosition& pos)
 {
-    int idx;
-
-    if (m_children.GetCount() == 0)
-        return m_emptyCellSize;
-
-    m_rowHeights.Empty();
-    m_colWidths.Empty();
-
-    wxSizerItemList::compatibility_iterator node = m_children.GetFirst();
-    while (node)
-    {
-        wxGBSizerItem* item = (wxGBSizerItem*)node->GetData();
-        if ( item->IsShown() )
-        {
-            int row, col, endrow, endcol;
-
-            item->GetPos(row, col);
-            item->GetEndPos(endrow, endcol);
-
-            // fill heights and widths upto this item if needed
-            while ( m_rowHeights.GetCount() <= (size_t)endrow )
-                m_rowHeights.Add(m_emptyCellSize.GetHeight());
-            while ( m_colWidths.GetCount() <= (size_t)endcol )
-                m_colWidths.Add(m_emptyCellSize.GetWidth());
-
-            // See if this item increases the size of its row(s) or col(s)
-            wxSize size(item->CalcMin());
-            for (idx=row; idx <= endrow; idx++)
-                m_rowHeights[idx] = wxMax(m_rowHeights[idx], size.GetHeight() / (endrow-row+1));
-            for (idx=col; idx <= endcol; idx++)
-                m_colWidths[idx] = wxMax(m_colWidths[idx], size.GetWidth() / (endcol-col+1));
-        }
-        node = node->GetNext();
-    }
-
-    AdjustForOverflow();
-    AdjustForFlexDirection();
-
-    // Now traverse the heights and widths arrays calcing the totals, including gaps
-    int width = 0;
-    m_cols = m_colWidths.GetCount();
-    for (idx=0; idx < m_cols; idx++)
-        width += m_colWidths[idx] + ( idx == m_cols-1 ? 0 : m_hgap );
-
-    int height = 0;
-    m_rows = m_rowHeights.GetCount();
-    for (idx=0; idx < m_rows; idx++)
-        height += m_rowHeights[idx] + ( idx == m_rows-1 ? 0 : m_vgap );
-
-    m_calculatedMinSize = wxSize(width, height);
-    return m_calculatedMinSize;
+    wxSizerItem* item = GetItem(window);
+    wxCHECK_MSG(item, false, wxT("Failed to find item."));
+    wxCHECK_MSG(item->IsKindOf(CLASSINFO(wxGBSizerItem)), false, 
+        wxT("Only absolutely positioned items can be positioned"));
+    return ((wxGBSizerItem*)item)->SetPos(pos);
 }
 
 
-
-void wxGridBagSizer::RecalcSizes()
+bool wxGridBagSizer::SetItemPosition(wxSizer *sizer, const wxGBPosition& pos)
 {
-    if (m_children.GetCount() == 0)
-        return;
-
-    wxPoint pt( GetPosition() );
-    wxSize  sz( GetSize() );
-
-    m_rows = m_rowHeights.GetCount();
-    m_cols = m_colWidths.GetCount();
-    int idx, width, height;
-
-    AdjustForGrowables(sz);
-
-    // Find the start positions on the window of the rows and columns
-    wxArrayInt rowpos;
-    rowpos.Add(0, m_rows);
-    int y = pt.y;
-    for (idx=0; idx < m_rows; idx++)
-    {
-        height = m_rowHeights[idx] + m_vgap;
-        rowpos[idx] = y;
-        y += height;
-    }
-
-    wxArrayInt colpos;
-    colpos.Add(0, m_cols);
-    int x = pt.x;
-    for (idx=0; idx < m_cols; idx++)
-    {
-        width = m_colWidths[idx] + m_hgap;
-        colpos[idx] = x;
-        x += width;
-    }
-
-
-    // Now iterate the children, setting each child's dimensions
-    wxSizerItemList::compatibility_iterator node = m_children.GetFirst();
-    while (node)
-    {
-        int row, col, endrow, endcol;
-        wxGBSizerItem* item = (wxGBSizerItem*)node->GetData();
-
-        if ( item->IsShown() )
-        {
-            item->GetPos(row, col);
-            item->GetEndPos(endrow, endcol);
-
-            height = 0;
-            for(idx=row; idx <= endrow; idx++)
-                height += m_rowHeights[idx];
-            height += (endrow - row) * m_vgap; // add a vgap for every row spanned
-
-            width = 0;
-            for (idx=col; idx <= endcol; idx++)
-                width += m_colWidths[idx];
-            width += (endcol - col) * m_hgap; // add a hgap for every col spanned
-
-            SetItemBounds(item, colpos[col], rowpos[row], width, height);
-        }
-
-        node = node->GetNext();
-    }
+    wxSizerItem* item = GetItem(sizer);
+    wxCHECK_MSG(item, false, wxT("Failed to find item."));
+    wxCHECK_MSG(item->IsKindOf(CLASSINFO(wxGBSizerItem)), false, 
+        wxT("Only absolutely positioned items can be positioned"));
+    return ((wxGBSizerItem*)item)->SetPos(pos);;
 }
 
 
-// Sometimes CalcMin can result in some rows or cols having too much space in
-// them because as it traverses the items it makes some assumptions when
-// items span to other cells.  But those assumptions can become invalid later
-// on when other items are fitted into the same rows or columns that the
-// spanning item occupies. This method tries to find those situations and
-// fixes them.
-void wxGridBagSizer::AdjustForOverflow()
+bool wxGridBagSizer::SetItemPosition(size_t index, const wxGBPosition& pos)
 {
-    int row, col;
-    
-    for (row=0; row<(int)m_rowHeights.GetCount(); row++)
-    {
-        int rowExtra=INT_MAX;
-        int rowHeight = m_rowHeights[row];
-        for (col=0; col<(int)m_colWidths.GetCount(); col++)
-        {
-            wxGBPosition pos(row,col);
-            wxGBSizerItem* item = FindItemAtPosition(pos);
-            if ( !item )
-                continue;
-
-            int endrow, endcol;
-            item->GetEndPos(endrow, endcol);
-            
-            // If the item starts in this position and doesn't span rows, then
-            // just look at the whole item height
-            if ( item->GetPos() == pos && endrow == row )
-            {
-                int itemHeight = item->CalcMin().GetHeight();
-                rowExtra = wxMin(rowExtra, rowHeight - itemHeight);
-                continue;
-            }
-
-            // Otherwise, only look at spanning items if they end on this row
-            if ( endrow == row )
-            {
-                // first deduct the portions of the item that are on prior rows
-                int itemHeight = item->CalcMin().GetHeight();
-                for (int r=item->GetPos().GetRow(); r<row; r++)
-                    itemHeight -= (m_rowHeights[r] + GetHGap());
-
-                if ( itemHeight < 0 )
-                    itemHeight = 0;
-                
-                // and check how much is left
-                rowExtra = wxMin(rowExtra, rowHeight - itemHeight);
-            }
-        }
-        if ( rowExtra && rowExtra != INT_MAX )
-            m_rowHeights[row] -= rowExtra;
-    }
-
-    // Now do the same thing for columns
-    for (col=0; col<(int)m_colWidths.GetCount(); col++)
-    {
-        int colExtra=INT_MAX;
-        int colWidth = m_colWidths[col];
-        for (row=0; row<(int)m_rowHeights.GetCount(); row++)
-        {
-            wxGBPosition pos(row,col);
-            wxGBSizerItem* item = FindItemAtPosition(pos);
-            if ( !item )
-                continue;
-
-            int endrow, endcol;
-            item->GetEndPos(endrow, endcol);
-            
-            if ( item->GetPos() == pos && endcol == col )
-            {
-                int itemWidth = item->CalcMin().GetWidth();
-                colExtra = wxMin(colExtra, colWidth - itemWidth);
-                continue;
-            }
-
-            if ( endcol == col )
-            {
-                int itemWidth = item->CalcMin().GetWidth();
-                for (int c=item->GetPos().GetCol(); c<col; c++)
-                    itemWidth -= (m_colWidths[c] + GetVGap());
-
-                if ( itemWidth < 0 )
-                    itemWidth = 0;
-                
-                colExtra = wxMin(colExtra, colWidth - itemWidth);
-            }
-        }
-        if ( colExtra && colExtra != INT_MAX )
-            m_colWidths[col] -= colExtra;
-    }
-
-    
+    wxSizerItem* item = GetItem(index);
+    wxCHECK_MSG(item, false, wxT("Failed to find item."));
+    wxCHECK_MSG(item->IsKindOf(CLASSINFO(wxGBSizerItem)), false, 
+        wxT("Only absolutely positioned items can be positioned"));
+    return ((wxGBSizerItem*)item)->SetPos(pos);
 }
 
 //---------------------------------------------------------------------------
 
 bool wxGridBagSizer::CheckForIntersection(wxGBSizerItem* item, wxGBSizerItem* excludeItem)
 {
-    return CheckForIntersection(item->GetPos(), item->GetSpan(), excludeItem);
+    return CheckForIntersection(item->GetPos(), item->wxSizerItem::GetSpan(), excludeItem);
 }
 
-bool wxGridBagSizer::CheckForIntersection(const wxGBPosition& pos, const wxGBSpan& span, wxGBSizerItem* excludeItem)
+bool wxGridBagSizer::CheckForIntersection(const wxGBPosition& pos, const wxGridSpan& span, wxGBSizerItem* excludeItem)
 {
     wxSizerItemList::compatibility_iterator node = m_children.GetFirst();
     while (node)
     {
-        wxGBSizerItem* item = (wxGBSizerItem*)node->GetData();
+        wxSizerItem* item = node->GetData();
         node = node->GetNext();
 
-        if ( excludeItem && item == excludeItem )
-            continue;
+        if (item->IsKindOf(CLASSINFO(wxGBSizerItem)))
+        {
+            if ( excludeItem && item == excludeItem )
+                continue;
 
-        if ( item->Intersects(pos, span) )
-            return true;
-
+            if ( ((wxGBSizerItem*)item)->Intersects(pos, span) )
+                return true;
+        }
     }
     return false;
 }
 
 
-// Assumes a 10x10 grid, and returns the first empty cell found.  This is
-// really stupid but it is only used by the Add methods that match the base
-// class virtuals, which should normally not be used anyway...
-wxGBPosition wxGridBagSizer::FindEmptyCell()
-{
-    int row, col;
-
-    for (row=0; row<10; row++)
-        for (col=0; col<10; col++)
-        {
-            wxGBPosition pos(row, col);
-            if ( !CheckForIntersection(pos, wxDefaultSpan) )
-                return pos;
-        }
-    return wxGBPosition(-1, -1);
-}
-
-
 //---------------------------------------------------------------------------
-
-// The Add base class virtuals should not be used with this class, but
-// we'll try to make them automatically select a location for the item
-// anyway.
-
-wxSizerItem* wxGridBagSizer::Add( wxWindow *window, int, int flag, int border, wxObject* userData )
-{
-    return Add(window, FindEmptyCell(), wxDefaultSpan, flag, border, userData);
-}
-
-wxSizerItem* wxGridBagSizer::Add( wxSizer *sizer, int, int flag, int border, wxObject* userData )
-{
-    return Add(sizer, FindEmptyCell(), wxDefaultSpan, flag, border, userData);
-}
-
-wxSizerItem* wxGridBagSizer::Add( int width, int height, int, int flag, int border, wxObject* userData )
-{
-    return Add(width, height, FindEmptyCell(), wxDefaultSpan, flag, border, userData);
-}
-
-
-
-// The Insert nad Prepend base class virtuals that are not appropriate for
-// this class and should not be used.  Their implementation in this class
-// simply fails.
-
-wxSizerItem* wxGridBagSizer::Add( wxSizerItem * )
-{
-    wxFAIL_MSG(wxT("Invalid Add form called."));
-    return (wxSizerItem*)NULL;
-}
-
-wxSizerItem* wxGridBagSizer::Prepend( wxWindow *, int, int, int, wxObject*  )
-{
-    wxFAIL_MSG(wxT("Prepend should not be used with wxGridBagSizer."));
-    return (wxSizerItem*)NULL;
-}
-
-wxSizerItem* wxGridBagSizer::Prepend( wxSizer *, int, int, int, wxObject*  )
-{
-    wxFAIL_MSG(wxT("Prepend should not be used with wxGridBagSizer."));
-    return (wxSizerItem*)NULL;
-}
-
-wxSizerItem* wxGridBagSizer::Prepend( int, int, int, int, int, wxObject*  )
-{
-    wxFAIL_MSG(wxT("Prepend should not be used with wxGridBagSizer."));
-    return (wxSizerItem*)NULL;
-}
-
-wxSizerItem* wxGridBagSizer::Prepend( wxSizerItem * )
-{
-    wxFAIL_MSG(wxT("Prepend should not be used with wxGridBagSizer."));
-    return (wxSizerItem*)NULL;
-}
-
-
-wxSizerItem* wxGridBagSizer::Insert( size_t, wxWindow *, int, int, int, wxObject*  )
-{
-    wxFAIL_MSG(wxT("Insert should not be used with wxGridBagSizer."));
-    return (wxSizerItem*)NULL;
-}
-
-wxSizerItem* wxGridBagSizer::Insert( size_t, wxSizer *, int, int, int, wxObject*  )
-{
-    wxFAIL_MSG(wxT("Insert should not be used with wxGridBagSizer."));
-    return (wxSizerItem*)NULL;
-}
-
-wxSizerItem* wxGridBagSizer::Insert( size_t, int, int, int, int, int, wxObject*  )
-{
-    wxFAIL_MSG(wxT("Insert should not be used with wxGridBagSizer."));
-    return (wxSizerItem*)NULL;
-}
-
-wxSizerItem* wxGridBagSizer::Insert( size_t, wxSizerItem * )
-{
-    wxFAIL_MSG(wxT("Insert should not be used with wxGridBagSizer."));
-    return (wxSizerItem*)NULL;
-}
-
-
 //---------------------------------------------------------------------------
-//---------------------------------------------------------------------------
Index: src/common/sizer.cpp
===================================================================
--- src/common/sizer.cpp	(revision 53980)
+++ src/common/sizer.cpp	(working copy)
@@ -2,8 +2,8 @@
 // Name:        src/common/sizer.cpp
 // Purpose:     provide new wxSizer class for layout
 // Author:      Robert Roebling and Robin Dunn, contributions by
-//              Dirk Holtwick, Ron Lee
-// Modified by: Ron Lee
+//              Dirk Holtwick, Ron Lee, Dustin Spicuzza
+// Modified by: Ron Lee, Dustin Spicuzza
 // Created:
 // RCS-ID:      $Id$
 // Copyright:   (c) Robin Dunn, Robert Roebling
@@ -36,6 +36,7 @@
 
 
 //---------------------------------------------------------------------------
+const wxGridSpan wxDefaultSpan;
 
 IMPLEMENT_CLASS(wxSizerItem, wxObject)
 IMPLEMENT_CLASS(wxSizer, wxObject)
@@ -88,6 +89,7 @@
 // wxSizerItem
 // ----------------------------------------------------------------------------
 
+
 // check for flags conflicts
 static const int SIZER_FLAGS_MASK =
     wxADD_FLAG(wxCENTRE,
@@ -120,6 +122,7 @@
     m_proportion = flags.GetProportion();
     m_flag = flags.GetFlags();
     m_border = flags.GetBorderInPixels();
+    m_span = flags.GetSpan();
 
     ASSERT_VALID_SIZER_FLAGS( m_flag );
 }
@@ -1307,87 +1310,307 @@
 //---------------------------------------------------------------------------
 
 wxGridSizer::wxGridSizer( int rows, int cols, int vgap, int hgap )
-    : m_rows( ( cols == 0 && rows == 0 ) ? 1 : rows )
-    , m_cols( cols )
+    : m_user_rows( ( cols == 0 && rows == 0 ) ? 1 : rows )
+    , m_user_cols( cols )
     , m_vgap( vgap )
     , m_hgap( hgap )
 {
 }
 
 wxGridSizer::wxGridSizer( int cols, int vgap, int hgap )
-    : m_rows( cols == 0 ? 1 : 0 )
-    , m_cols( cols )
+    : m_user_rows( cols == 0 ? 1 : 0 )
+    , m_user_cols( cols )
     , m_vgap( vgap )
     , m_hgap( hgap )
 {
 }
 
-int wxGridSizer::CalcRowsCols(int& nrows, int& ncols) const
+int wxGridSizer::CalcRowsCols()
 {
     int nitems = m_children.GetCount();
-    if ( nitems)
+
+    if ( nitems )
     {
-        if ( m_cols )
+        // colspan/rowspan affects this, calculate those. Assume they are in the right
+        // place, since a later step will catch those errors. 
+        wxSizerItemList::compatibility_iterator node = m_children.GetFirst();
+        while (node)
         {
-            ncols = m_cols;
-            nrows = (nitems + m_cols - 1) / m_cols;
+            const wxGridSpan span = node->GetData()->GetSpan();
+            nitems += (span.GetRowspan() * span.GetColspan() - 1);
+            
+            node = node->GetNext();
         }
-        else if ( m_rows )
+
+        if ( m_user_cols )
         {
-            ncols = (nitems + m_rows - 1) / m_rows;
-            nrows = m_rows;
+            m_cols = m_user_cols;
+            m_rows = (nitems + m_user_cols - 1) / m_user_cols;
         }
+        else if ( m_user_rows )
+        {
+            m_cols = (nitems + m_user_rows - 1) / m_user_rows;
+            m_rows = m_user_rows;
+        }
         else // 0 columns, 0 rows?
         {
-            wxFAIL_MSG( _T("grid sizer must have either rows or columns fixed") );
+            wxFAIL_MSG( _T("grid sizers must have either rows or columns fixed") );
 
-            nrows = ncols = 0;
+            m_rows = m_cols = 0;
         }
+
+        if (m_rows && m_cols)
+            PopulateGrid();
     }
 
     return nitems;
 }
 
-void wxGridSizer::RecalcSizes()
+// goes through and creates a grid. Called by CalcRowsCols()
+// TODO: Make this cacheable
+void wxGridSizer::PopulateGrid()
 {
-    int nitems, nrows, ncols;
-    if ( (nitems = CalcRowsCols(nrows, ncols)) == 0 )
-        return;
+    wxSizerItemList::const_iterator i = m_children.begin();
+    const wxSizerItemList::const_iterator end = m_children.end();
 
-    wxSize sz( GetSize() );
-    wxPoint pt( GetPosition() );
+    // initialize the table
+    m_gridTable.Clear();
+    m_gridTable.Add(NULL, m_rows*m_cols);
 
-    int w = (sz.x - (ncols - 1) * m_hgap) / ncols;
-    int h = (sz.y - (nrows - 1) * m_vgap) / nrows;
+    for (int r = 0; r < m_rows; r++)
+    {
+        int offset = r*m_cols;
 
-    int x = pt.x;
-    for (int c = 0; c < ncols; c++)
-    {
-        int y = pt.y;
-        for (int r = 0; r < nrows; r++)
+        for (int c = 0; c < m_cols; c++)
         {
-            int i = r * ncols + c;
-            if (i < nitems)
+            // if nothing is already here, then do stuff
+            if (!m_gridTable[offset + c])
             {
-                wxSizerItemList::compatibility_iterator node = m_children.Item( i );
 
-                wxASSERT_MSG( node, _T("Failed to find SizerItemList node") );
+                // determine if it spans
+                const wxGridSpan span = (*i)->GetSpan();
+                const int cs = span.GetColspan();
+                const int rs = span.GetRowspan();
+                
+                if (cs > 1 || rs > 1)
+                {
+                    // since it spans, fill out its places in the array
+                    wxASSERT_MSG(c + cs <= m_cols, _T("An item is overflowing its column"));
+                    wxASSERT_MSG(r + rs <= m_rows, _T("An item is overflowing its row"));
 
-                SetItemBounds( node->GetData(), x, y, w, h);
+                    const int maxc = c + cs > m_cols ? m_cols : c + cs;
+                    const int maxr = r + rs > m_rows ? m_rows : r + rs;
+
+                    for (int t_r = r; t_r < maxr; t_r++)
+                    {
+                        const int t_offset = t_r*m_cols;
+                        for (int t_c = c; t_c < maxc; t_c++)
+                        {
+                            wxASSERT_MSG(!m_gridTable[t_offset + t_c], _T("An item is spanning over another item!"));
+                            m_gridTable[t_offset + t_c] = (wxSizerItem*)1;
+                        }
+                    }
+                }
+
+                m_gridTable[offset + c] = *i;
+
+                if (++i == end)
+                    break;
+            }   
+        }
+
+        if (i == end)
+            break;
+    }
+}
+
+// begins iteration
+wxSizerItem* wxGridSizer::BeginIterateGrid(int *row, int *col, wxGridSpan * span)
+{
+    m_grid_cur_col = 0;
+    m_grid_cur_row = 0;
+
+    return IterateGrid(row, col, span);
+}
+
+// returns row, column, span of each cell in succession, properly skipping
+// spanned cells. Useful for any classes that may derive from this
+wxSizerItem* wxGridSizer::IterateGrid(int *row, int *col, wxGridSpan * span)
+{
+    wxSizerItem *ret_item = NULL;
+
+    while (m_grid_cur_row < m_rows)
+    {
+        int offset = m_grid_cur_row*m_cols;
+
+        while (m_grid_cur_col< m_cols)
+        {
+            // should we skip this item?
+            wxSizerItem* item = m_gridTable[offset + m_grid_cur_col];
+            if (item && item != (wxSizerItem*)1)
+            {
+                // nope, found an item... 
+                ret_item = item;
+                break;
             }
-            y = y + h + m_vgap;
+
+            ++m_grid_cur_col;
         }
-        x = x + w + m_hgap;
+        
+        // break twice
+        if (ret_item)
+            break;
+
+        m_grid_cur_col = 0;
+        ++m_grid_cur_row;
     }
+
+    // return the information that the caller requested
+    if (ret_item)
+    {
+        if (row) *row = m_grid_cur_row;
+        if (col) *col = m_grid_cur_col;
+        if (span) *span = ret_item->GetSpan();
+    }
+
+    // no infinite loops
+    ++m_grid_cur_col;
+
+    return ret_item;
 }
 
-wxSize wxGridSizer::CalcMin()
+// this routine gets called from RecalcSizes(), and assigns the 
+// rowHeight/colWidth array sizes. Derived classes will 
+// probably reimplement this function
+void wxGridSizer::CalcGridWidthsAndHeights()
 {
-    int nrows, ncols;
-    if ( CalcRowsCols(nrows, ncols) == 0 )
-        return wxSize();
+    int i;
+    const wxSize sz( GetSize() );
+    
+    const int w = (sz.x - (m_cols - 1) * m_hgap) / m_cols;
+    const int h = (sz.y - (m_rows - 1) * m_vgap) / m_rows;
+    
+    m_rowHeights.Clear();
+    m_rowHeights.Add(-1, m_rows);
 
-    // Find the max width and height for any component
+    m_colWidths.Clear();
+    m_colWidths.Add(-1, m_cols);
+
+    for (i = 0; i < m_rows; i++)
+        m_rowHeights[i] = h;
+    for (i = 0; i < m_cols; i++)
+        m_colWidths[i] = w;
+}
+
+// calculates the edges of the grid and saves them. Only called from
+// RecalcSizes(). Ideally, this should work correctly for all derived
+// classes, and doesn't need to be reimplemented
+void wxGridSizer::CalcGridPoints()
+{
+    int i; 
+    wxPoint pt( GetPosition() );
+    
+    m_colPts.Clear();
+    m_colPts.Add(0,m_cols);
+
+    m_colPts[0] = pt.x;
+   
+    for (i = 1; i < m_cols; i++)
+        // if negative, then assume zero width
+        if (m_colWidths[i] < 0)
+            m_colPts[i] = m_colPts[i-1];
+        else
+            m_colPts[i] = m_colPts[i-1] + m_colWidths[i-1] + m_hgap;
+    
+    m_rowPts.Clear();
+    m_rowPts.Add(0,m_rows);
+
+    m_rowPts[0] = pt.y;
+   
+    for (i = 1; i < m_rows; i++)
+        // if negative, then assume zero height
+        if (m_rowHeights[i] < 0)
+            m_rowPts[i] = m_rowPts[i-1];
+        else
+            m_rowPts[i] = m_rowPts[i-1] + m_rowHeights[i-1] + m_vgap;
+}
+
+
+// the purpose of this function is to calculate the size of each child, 
+// and then actually set it
+void wxGridSizer::RecalcSizes()
+{
+    if ( CalcRowsCols() == 0 )
+        return;
+
+    const wxSize sz( GetSize() );
+
+    int row, col, i;
+    wxGridSpan span;
+    wxSizerItem* item;
+    
+    // next, determine widths/heights
+    CalcGridWidthsAndHeights();
+
+    // and then the edges
+    CalcGridPoints();
+
+    
+    for (item = BeginIterateGrid(&row, &col, &span); 
+         item; 
+         item = IterateGrid(&row, &col, &span))
+    {
+        if (m_rowHeights[row] == -1 || m_colWidths[col] == -1)
+            continue;
+    
+        const int cs = span.GetColspan();
+        const int rs = span.GetRowspan();
+        int w = m_colWidths[col];
+        int h = m_rowHeights[row];
+
+        if (cs > 1 || rs > 1)
+        {   
+            // limit the colspan/rowspan so it doesn't overflow
+            const int maxrs = row + rs > m_rows ? m_rows : row + rs;
+            const int maxcs = col + cs > m_cols ? m_cols : col + cs;
+
+            for (i = row+1; i < maxrs; i++)
+                if (m_rowHeights[i] > 0)
+                    h += m_vgap + m_rowHeights[i];
+
+            for (i = col+1; i < maxcs; i++)
+                if (m_colWidths[i] > 0)
+                    w += m_hgap + m_colWidths[i];
+        }
+
+        SetItemBounds( item, m_colPts[col], m_rowPts[row], w, h);
+    }
+}
+
+// helper function to decide how wide an individual cell should
+// be when dealing with a rowspan/colspan item
+static inline
+int DoCalcAvgSpan(const int initsz, const int span, const int gap)
+{
+    int sz = initsz;
+
+    // adjust for the gaps
+    sz = sz - (span-1)*gap;
+    if (sz < 0)
+        sz = 0;
+
+    // then divide by the span so it doesn't effect overall width
+    if (sz % span)
+        sz = (sz + span)/span;
+    else
+        sz = sz / span;
+
+    return sz;
+}
+
+// Find the max width and height for any component (divided by its colspan or rowspan)
+wxSize wxGridSizer::CalcMaxWH() const {
+   
     int w = 0;
     int h = 0;
 
@@ -1395,47 +1618,69 @@
     while (node)
     {
         wxSizerItem     *item = node->GetData();
-        wxSize           sz( item->CalcMin() );
+        wxSize          sz( item->CalcMin() );
+        wxGridSpan      span = item->GetSpan();
 
+        // if there is a possibility of a span, then need to adjust for
+        // gaps/spans to ensure uniform feel
+        
+        const int cs = span.GetColspan();
+        const int rs = span.GetRowspan();
+
+        // get the average column/row width
+        if (cs > 1)
+            sz.x = DoCalcAvgSpan(sz.x, cs, m_hgap);
+
+        if (rs > 1)
+            sz.y = DoCalcAvgSpan(sz.y, rs, m_vgap);
+
         w = wxMax( w, sz.x );
         h = wxMax( h, sz.y );
 
         node = node->GetNext();
     }
 
+    return wxSize(w,h);
+}
+
+// this function iterates twice to determine the smallest size
+// all of its components can be
+wxSize wxGridSizer::CalcMin()
+{
+    if ( CalcRowsCols() == 0 )
+        return wxSize();
+
+    // get max sizes
+    wxSize cell_max = CalcMaxWH();
+
     // In case we have a nested sizer with a two step algo , give it
     // a chance to adjust to that (we give it width component)
-    node = m_children.GetFirst();
+    wxSizerItemList::compatibility_iterator node = m_children.GetFirst();
     bool didChangeMinSize = false;
     while (node)
     {
         wxSizerItem     *item = node->GetData();
-        didChangeMinSize |= item->InformFirstDirection( wxHORIZONTAL, w, -1 );
+        int             max_x = cell_max.x;
+        int             cs = item->GetSpan().GetColspan();
 
+        // check if we need to readjust it
+        if (cs > 1)  
+            max_x = max_x*cs + (cs-1)*m_hgap;
+
+        didChangeMinSize |= item->InformFirstDirection( wxHORIZONTAL, max_x, -1 );
         node = node->GetNext();
     }
 
-    // And redo iteration in case min size changed
+    // And get the max sizes once again if its changed
     if( didChangeMinSize )
-    {
-        node = m_children.GetFirst();
-        w = h = 0;
-        while (node)
-        {
-            wxSizerItem     *item = node->GetData();
-            wxSize           sz( item->GetMinSizeWithBorder() );
+       cell_max = CalcMaxWH();
 
-            w = wxMax( w, sz.x );
-            h = wxMax( h, sz.y );
-
-            node = node->GetNext();
-        }
-    }
-
-    return wxSize( ncols * w + (ncols-1) * m_hgap,
-                   nrows * h + (nrows-1) * m_vgap );
+    return wxSize( m_cols * cell_max.x + (m_cols-1) * m_hgap,
+                   m_rows * cell_max.y + (m_rows-1) * m_vgap );
 }
 
+// helper function -- children shouldn't need to override this. Called 
+// from RecalcSizes() only
 void wxGridSizer::SetItemBounds( wxSizerItem *item, int x, int y, int w, int h )
 {
     wxPoint pt( x,y );
@@ -1471,220 +1716,401 @@
 }
 
 //---------------------------------------------------------------------------
-// wxFlexGridSizer
-//---------------------------------------------------------------------------
 
-wxFlexGridSizer::wxFlexGridSizer( int rows, int cols, int vgap, int hgap )
-               : wxGridSizer( rows, cols, vgap, hgap ),
-                 m_flexDirection(wxBOTH),
-                 m_growMode(wxFLEX_GROWMODE_SPECIFIED)
+wxSize wxGridSizer::GetCellSize(int row, int col) const
 {
+    wxCHECK_MSG( (row < m_user_rows) && (col < m_user_cols),
+                 wxDefaultSize,
+                 wxT("Invalid cell."));
+    return wxSize( m_colWidths[col], m_rowHeights[row] );
 }
 
-wxFlexGridSizer::wxFlexGridSizer( int cols, int vgap, int hgap )
-               : wxGridSizer( cols, vgap, hgap ),
-                 m_flexDirection(wxBOTH),
-                 m_growMode(wxFLEX_GROWMODE_SPECIFIED)
+wxGridPosition wxGridSizer::GetItemPosition(wxWindow *window)
 {
+    wxSizerItem* item;
+    int row = 0, col = 0;
+
+    CalcRowsCols();
+    for (item = BeginIterateGrid(&row, &col, NULL); 
+         item; 
+         item = IterateGrid(&row, &col, NULL))
+    {
+        if (item->GetWindow() == window)
+            break;
+    }
+
+    wxCHECK_MSG(item, wxGridPosition(-1,-1), wxT("Failed to find item."));
+    return wxGridPosition(row, col);
 }
 
-wxFlexGridSizer::~wxFlexGridSizer()
+
+wxGridPosition wxGridSizer::GetItemPosition(wxSizer *sizer)
 {
+    wxSizerItem* item;
+    int row = 0, col = 0;
+
+    CalcRowsCols();
+    for (item = BeginIterateGrid(&row, &col, NULL); 
+         item; 
+         item = IterateGrid(&row, &col, NULL))
+    {
+        if (item->GetSizer() == sizer)
+            break;
+    }
+
+    wxCHECK_MSG(item, wxGridPosition(-1,-1), wxT("Failed to find item."));
+    return wxGridPosition(row, col);
 }
 
-void wxFlexGridSizer::RecalcSizes()
+
+wxGridPosition wxGridSizer::GetItemPosition(size_t index)
 {
-    int nrows, ncols;
-    if ( !CalcRowsCols(nrows, ncols) )
-        return;
+    wxSizerItem* item;
+    wxSizerItem* itemToFind = GetItem(index);
+    int row = 0, col = 0;
 
-    const wxPoint pt(GetPosition());
-    const wxSize sz(GetSize());
+    CalcRowsCols();
+    for (item = BeginIterateGrid(&row, &col, NULL); 
+         item; 
+         item = IterateGrid(&row, &col, NULL))
+    {
+        if (item == itemToFind)
+            break;
+    }
 
-    AdjustForGrowables(sz);
+    wxCHECK_MSG(item, wxGridPosition(-1,-1), wxT("Failed to find item."));
+    return wxGridPosition(row, col);
+}
 
-    wxSizerItemList::const_iterator i = m_children.begin();
-    const wxSizerItemList::const_iterator end = m_children.end();
+wxGridSpan wxGridSizer::GetItemSpan(wxWindow *window)
+{
+    wxGridSpan badspan(-1,-1);
+    wxSizerItem* item = GetItem(window);
+    wxCHECK_MSG( item, badspan, _T("Failed to find item.") );
+    return item->GetSpan();
+}
 
-    int y = 0;
-    for ( int r = 0; r < nrows; r++ )
-    {
-        if ( m_rowHeights[r] == -1 )
-        {
-            // this row is entirely hidden, skip it
-            for ( int c = 0; c < ncols; c++ )
-            {
-                if ( i == end )
-                    return;
 
-                ++i;
-            }
+wxGridSpan wxGridSizer::GetItemSpan(wxSizer *sizer)
+{
+    wxGridSpan badspan(-1,-1);
+    wxSizerItem* item = GetItem(sizer);
+    wxCHECK_MSG( item, badspan, _T("Failed to find item.") );
+    return item->GetSpan();
+}
 
-            continue;
-        }
 
-        const int hrow = m_rowHeights[r];
-        int h = sz.y - y; // max remaining height, don't overflow it
-        if ( hrow < h )
-            h = hrow;
+wxGridSpan wxGridSizer::GetItemSpan(size_t index)
+{
+    wxGridSpan badspan(-1,-1);
+    wxSizerItem* item = GetItem(index);
+    wxCHECK_MSG( item, badspan, _T("Failed to find item.") );
+    return item->GetSpan();
+}
 
-        int x = 0;
-        for ( int c = 0; c < ncols && i != end; c++, ++i )
-        {
-            const int wcol = m_colWidths[c];
 
-            if ( wcol == -1 )
-                continue;
 
-            int w = sz.x - x; // max possible value, ensure we don't overflow
-            if ( wcol < w )
-                w = wcol;
+bool wxGridSizer::SetItemSpan(wxWindow *window, const wxGridSpan& span)
+{
+    wxSizerItem* item = GetItem(window);
+    wxCHECK_MSG(item, false, wxT("Failed to find item."));
+    return item->SetSpan(span);
+}
 
-            SetItemBounds(*i, pt.x + x, pt.y + y, w, h);
 
-            x += wcol + m_hgap;
-        }
+bool wxGridSizer::SetItemSpan(wxSizer *sizer, const wxGridSpan& span)
+{
+    wxSizerItem* item = GetItem(sizer);
+    wxCHECK_MSG(item, false, wxT("Failed to find item."));
+    return item->SetSpan(span);
+}
 
-        if ( i == end )
-            return;
 
-        y += hrow + m_vgap;
-    }
+bool wxGridSizer::SetItemSpan(size_t index, const wxGridSpan& span)
+{
+    wxSizerItem* item = GetItem(index);
+    wxCHECK_MSG( item, false, _T("Failed to find item.") );
+    return item->SetSpan(span);
 }
 
-// helper function used in CalcMin() to sum up the sizes of non-hidden items
-static int SumArraySizes(const wxArrayInt& sizes, int gap)
+
+//---------------------------------------------------------------------------
+// wxFlexGridSizer
+//---------------------------------------------------------------------------
+
+wxFlexGridSizer::wxFlexGridSizer( int rows, int cols, int vgap, int hgap )
+               : wxGridSizer( rows, cols, vgap, hgap ),
+                 m_flexDirection(wxBOTH),
+                 m_growMode(wxFLEX_GROWMODE_SPECIFIED)
 {
-    // Sum total minimum size, including gaps between rows/columns.
-    // -1 is used as a magic number meaning empty row/column.
-    int total = 0;
+}
 
-    const size_t count = sizes.size();
-    for ( size_t n = 0; n < count; n++ )
+wxFlexGridSizer::wxFlexGridSizer( int cols, int vgap, int hgap )
+               : wxGridSizer( cols, vgap, hgap ),
+                 m_flexDirection(wxBOTH),
+                 m_growMode(wxFLEX_GROWMODE_SPECIFIED)
+{
+}
+
+wxFlexGridSizer::~wxFlexGridSizer()
+{
+}
+
+
+// helper function.. adjusts either the width or height array
+static inline
+void DoAdjustWHArrayForItem(const int sz, 
+                            const int start_idx, 
+                            const int span_len,
+                            wxArrayInt &array, 
+                            const int arraysz,
+                            const int gap )
+{
+    int i, tot_sz = 0, tot_empty = 0, tot_full = 0;
+
+    // sum the number of items spanned
+    int limit = start_idx + span_len < arraysz ? start_idx + span_len : arraysz;
+    
+    // get the size that exists already
+    for (i = start_idx; i < limit; i++)
+        if (array[i] == 0)
+            tot_empty += 1;
+        else if (array[i] > 0)
+        {
+            tot_sz += gap + array[i];
+            tot_full += 1;
+        }
+        
+    // if item is bigger than the total span
+    if (sz > tot_sz)
     {
-        if ( sizes[n] != -1 )
+        // get the average remaining size and distribute it
+        // either across anything that is empty, or failing
+        // that, across anything that is full
+        int div;
+        int szleft = sz - tot_sz;
+
+        if (tot_empty)
         {
-            if ( total )
-                total += gap; // separate from the previous column
+            div = DoCalcAvgSpan(szleft, tot_empty, gap);
 
-            total += sizes[n];
+            // evenly across all empty items
+            for (i = start_idx; tot_empty && i < limit; i++)
+                if (array[i] == 0)
+                {
+                    tot_empty -= 1;
+                    array[i] = div;
+                }
+        } else 
+        {
+            div = DoCalcAvgSpan(szleft, tot_full, gap);
+
+            // evenly across all non-hidden items
+            for (i = start_idx; i < limit; i++)
+                if (div > array[i] && array[i] > 0)
+                    array[i] = div;
         }
     }
-
-    return total;
 }
 
-void wxFlexGridSizer::FindWidthsAndHeights(int nrows, int ncols)
+// this routine assigns the rowHeight/colWidth array sizes
+void wxFlexGridSizer::CalcMaxRowColSz(bool calcMin)
 {
     // We have to recalculate the sizes in case the item minimum size has
     // changed since the previous layout, or the item has been hidden using
     // wxSizer::Show(). If all the items in a row/column are hidden, the final
     // dimension of the row/column will be -1, indicating that the column
     // itself is hidden.
-    m_rowHeights.assign(nrows, -1);
-    m_colWidths.assign(ncols, -1);
+    //
+    // If a column is zero, then it is (potentially) available for spanning
+    m_rowHeights.assign(m_rows, 0); 
+    m_colWidths.assign(m_cols, 0);
 
-    // n is the index of the item in left-to-right top-to-bottom order
-    size_t n = 0;
-    for ( wxSizerItemList::iterator i = m_children.begin();
-          i != m_children.end();
-          ++i, ++n )
+    int row, col, i;
+    wxGridSpan span;
+    wxSizerItem * item;
+
+    // two passes: non-spanning items first, then any spannable
+    // items the second time around. This allows us to minimize
+    // the amount of overflow present (to some extent)
+    //
+    // this is *almost* as good as AdjustForOverflow() is. If we could 
+    // get that working, it would probably be slightly better. However, 
+    // given the current grid mechanism its pretty difficult (and slow) 
+    // to implement it -- IMHO this works for most cases, so its
+    // not worth the tradeoff. Refer to the complex flexgridsizer
+    // portion of the Layout sample for examples of layouts that are 
+    // broken with this.
+
+    for ( item = BeginIterateGrid(&row, &col, &span);
+          item;
+          item = IterateGrid(&row, &col, &span))
     {
-        wxSizerItem * const item = *i;
-        if ( item->IsShown() )
+
+        const int rs = span.GetRowspan();
+		const int cs = span.GetColspan();
+
+        if ( !item->IsShown())
         {
-            // NOTE: Not doing the calculation here, this is just
-            // for finding max values.
-            const wxSize sz(item->GetMinSizeWithBorder());
+            // initialize hidden stuff ONLY if it hasn't 
+            // already been initialized
+            for (i = row; i < row+rs && i < m_rows; i++)
+                if (m_rowHeights[i] == 0)
+                    m_rowHeights[i] = -1;
+            for (i = col; i < col+cs && i < m_cols; i++)
+                if (m_colWidths[i] == 0)
+                    m_colWidths[i] = -1;
+        }
+        else
+        {
+            wxSize sz;
 
-            const int row = n / ncols;
-            const int col = n % ncols;
+            // skip purely spanning items
+            if (rs > 1 && cs > 1)
+                continue;
 
-            if ( sz.y > m_rowHeights[row] )
+            if (calcMin)
+                sz = item->CalcMin();
+            else
+                sz = item->GetMinSizeWithBorder();
+
+            if (rs <= 1 && sz.y > m_rowHeights[row] )
                 m_rowHeights[row] = sz.y;
-            if ( sz.x > m_colWidths[col] )
+
+            if (cs <= 1 && sz.x > m_colWidths[col])
                 m_colWidths[col] = sz.x;
         }
     }
 
-    AdjustForFlexDirection();
+    // do it again, span items only
+    for ( item = BeginIterateGrid(&row, &col, &span);
+          item;
+          item = IterateGrid(&row, &col, &span))
+    {
+        if ( item->IsShown())
+        {
+            wxSize sz;
 
-    m_calculatedMinSize = wxSize(SumArraySizes(m_colWidths, m_hgap),
-                                 SumArraySizes(m_rowHeights, m_vgap));
-}
+            const int rs = span.GetRowspan() < 1 ? 1 : span.GetRowspan();
+		    const int cs = span.GetColspan() < 1 ? 1 : span.GetColspan();
 
-wxSize wxFlexGridSizer::CalcMin()
-{
-    int nrows,
-        ncols;
+            // skip non-spanning items
+            if (rs <= 1 && cs <= 1)
+                continue;
 
-    // Number of rows/columns can change as items are added or removed.
-    if ( !CalcRowsCols(nrows, ncols) )
-        return wxSize();
+            if (calcMin)
+                sz = item->CalcMin();
+            else
+                sz = item->GetMinSizeWithBorder();
 
-
-    // We have to recalculate the sizes in case the item minimum size has
-    // changed since the previous layout, or the item has been hidden using
-    // wxSizer::Show(). If all the items in a row/column are hidden, the final
-    // dimension of the row/column will be -1, indicating that the column
-    // itself is hidden.
-    m_rowHeights.assign(nrows, -1);
-    m_colWidths.assign(ncols, -1);
-
-    // n is the index of the item in left-to-right top-to-bottom order
-    size_t n = 0;
-    for ( wxSizerItemList::iterator i = m_children.begin();
-          i != m_children.end();
-          ++i, ++n )
-    {
-        wxSizerItem * const item = *i;
-        if ( item->IsShown() )
-        {
-            item->CalcMin();
+            DoAdjustWHArrayForItem(sz.x, col, cs, m_colWidths, m_cols, m_vgap );   
+            DoAdjustWHArrayForItem(sz.y, row, rs, m_rowHeights, m_rows, m_hgap );    
         }
     }
+}
 
-    // The stage of looking for max values in each row/column has been
-    // made a separate function, since it's reused in AdjustForGrowables.
-    FindWidthsAndHeights(nrows,ncols);
+/*
+    I've left this in here because in some limited cases it is better than 
+    the two-pass solution as used above, but in most cases the above 
+    mechanism works just fine and its much faster too (2n vs n^2)
 
-    return m_calculatedMinSize;
-}
+    -DS
 
-void wxFlexGridSizer::AdjustForFlexDirection()
+// Sometimes CalcMin can result in some rows or cols having too much space in
+// them because as it traverses the items it makes some assumptions when
+// items span to other cells.  But those assumptions can become invalid later
+// on when other items are fitted into the same rows or columns that the
+// spanning item occupies. This method tries to find those situations and
+// fixes them.
+void wxFlexGridSizer::AdjustForOverflow()
 {
-    // the logic in CalcMin works when we resize flexibly in both directions
-    // but maybe this is not the case
-    if ( m_flexDirection != wxBOTH )
+    int row, col;
+    
+    for (row=0; row<(int)m_rowHeights.GetCount(); row++)
     {
-        // select the array corresponding to the direction in which we do *not*
-        // resize flexibly
-        wxArrayInt& array = m_flexDirection == wxVERTICAL ? m_colWidths
-                                                          : m_rowHeights;
+        int rowExtra=INT_MAX;
+        int rowHeight = m_rowHeights[row];
+        for (col=0; col<(int)m_colWidths.GetCount(); col++)
+        {
+            wxGBPosition pos(row,col);
+            wxGBSizerItem* item = FindItemAtPosition(pos);
+            if ( !item )
+                continue;
 
-        const size_t count = array.GetCount();
+            int endrow, endcol;
+            item->GetEndPos(endrow, endcol);
+            
+            // If the item starts in this position and doesn't span rows, then
+            // just look at the whole item height
+            if ( item->GetPos() == pos && endrow == row )
+            {
+                int itemHeight = item->CalcMin().GetHeight();
+                rowExtra = wxMin(rowExtra, rowHeight - itemHeight);
+                continue;
+            }
 
-        // find the largest value in this array
-        size_t n;
-        int largest = 0;
+            // Otherwise, only look at spanning items if they end on this row
+            if ( endrow == row )
+            {
+                // first deduct the portions of the item that are on prior rows
+                int itemHeight = item->CalcMin().GetHeight();
+                for (int r=item->GetPos().GetRow(); r<row; r++)
+                    itemHeight -= (m_rowHeights[r] + GetHGap());
 
-        for ( n = 0; n < count; ++n )
-        {
-            if ( array[n] > largest )
-                largest = array[n];
+                if ( itemHeight < 0 )
+                    itemHeight = 0;
+                
+                // and check how much is left
+                rowExtra = wxMin(rowExtra, rowHeight - itemHeight);
+            }
         }
+        if ( rowExtra && rowExtra != INT_MAX )
+            m_rowHeights[row] -= rowExtra;
+    }
 
-        // and now fill it with the largest value
-        for ( n = 0; n < count; ++n )
+    // Now do the same thing for columns
+    for (col=0; col<(int)m_colWidths.GetCount(); col++)
+    {
+        int colExtra=INT_MAX;
+        int colWidth = m_colWidths[col];
+        for (row=0; row<(int)m_rowHeights.GetCount(); row++)
         {
-            // don't touch hidden rows
-            if ( array[n] != -1 )
-                array[n] = largest;
+            wxGBPosition pos(row,col);
+            wxGBSizerItem* item = FindItemAtPosition(pos);
+            if ( !item )
+                continue;
+
+            int endrow, endcol;
+            item->GetEndPos(endrow, endcol);
+            
+            if ( item->GetPos() == pos && endcol == col )
+            {
+                int itemWidth = item->CalcMin().GetWidth();
+                colExtra = wxMin(colExtra, colWidth - itemWidth);
+                continue;
+            }
+
+            if ( endcol == col )
+            {
+                int itemWidth = item->CalcMin().GetWidth();
+                for (int c=item->GetPos().GetCol(); c<col; c++)
+                    itemWidth -= (m_colWidths[c] + GetVGap());
+
+                if ( itemWidth < 0 )
+                    itemWidth = 0;
+                
+                colExtra = wxMin(colExtra, colWidth - itemWidth);
+            }
         }
-    }
+        if ( colExtra && colExtra != INT_MAX )
+            m_colWidths[col] -= colExtra;
+    }   
 }
+*/
 
-// helper of AdjustForGrowables() which is called for rows/columns separately
+
+// helper of CalcGridWidthsAndHeights() which is called for rows/columns 
+// separately. This grows out the rows/columns
 //
 // parameters:
 //      delta: the extra space, we do nothing unless it's positive
@@ -1693,7 +2119,7 @@
 //      proportions: proportions of the growable rows/cols or NULL if they all
 //                   should be assumed to have proportion of 1
 static void
-DoAdjustForGrowables(int delta,
+DoAdjustForGrowables(const int delta,
                      const wxArrayInt& growable,
                      wxArrayInt& sizes,
                      const wxArrayInt *proportions)
@@ -1709,102 +2135,97 @@
 
     const int max_idx = sizes.size();
 
-    const size_t count = growable.size();
+    // this parameter is used in both for loops, either refers to
+    // growable[] or sizes[], depending on the value of proportions
+    size_t count = growable.size();
     size_t idx;
-    for ( idx = 0; idx < count; idx++ )
+
+    // if this is NULL, then we automatically resize all items
+    if (!proportions)
+        num = count = max_idx;
+
+    else 
     {
-        // Since the number of rows/columns can change as items are
-        // inserted/deleted, we need to verify at runtime that the
-        // requested growable rows/columns are still valid.
-        if ( growable[idx] >= max_idx )
-            continue;
+        for ( idx = 0; idx < count; idx++ )
+        {
+            // Since the number of rows/columns can change as items are
+            // inserted/deleted, we need to verify at runtime that the
+            // requested growable rows/columns are still valid.
+            if ( growable[idx] >= max_idx )
+                continue;
 
-        // If all items in a row/column are hidden, that row/column will
-        // have a dimension of -1.  This causes the row/column to be
-        // hidden completely.
-        if ( sizes[growable[idx]] == -1 )
-            continue;
+            // If all items in a row/column are hidden, that row/column will
+            // have a dimension of -1.  This causes the row/column to be
+            // hidden completely.
+            if ( sizes[growable[idx]] == -1 )
+                continue;
 
-        if ( proportions )
             sum_proportions += (*proportions)[idx];
+            num++;
+        }
 
-        num++;
+        if ( !num )
+            return;
     }
 
-    if ( !num )
-        return;
-
     // the remaining extra free space, adjusted during each iteration
     for ( idx = 0; idx < count; idx++ )
     {
-        if ( growable[idx] >= max_idx )
+        // skip this check if its null
+        if (proportions && growable[idx] >= max_idx )
             continue;
 
-        if ( sizes[ growable[idx] ] == -1 )
+        int real_idx = proportions ? growable[idx] : idx;
+
+        if ( sizes[real_idx] == -1 )
             continue;
 
         int cur_delta;
         if ( sum_proportions == 0 )
-        {
-            // no growable rows -- divide extra space evenly among all
+            // no growable rows/cols -- divide extra space evenly among all
             cur_delta = delta/num;
-            num--;
-        }
+        
         else // allocate extra space proportionally
         {
             const int cur_prop = (*proportions)[idx];
             cur_delta = (delta*cur_prop)/sum_proportions;
-            sum_proportions -= cur_prop;
         }
 
-        sizes[growable[idx]] += cur_delta;
-        delta -= cur_delta;
+        sizes[real_idx] += cur_delta;
     }
 }
 
-void wxFlexGridSizer::AdjustForGrowables(const wxSize& sz)
+
+// this is only called from RecalcSizes()
+void wxFlexGridSizer::CalcGridWidthsAndHeights()
 {
-    if ( (m_flexDirection & wxHORIZONTAL) || (m_growMode != wxFLEX_GROWMODE_NONE) )
-    {
-        DoAdjustForGrowables
-        (
-            sz.x - m_calculatedMinSize.x,
-            m_growableCols,
-            m_colWidths,
-            m_growMode == wxFLEX_GROWMODE_SPECIFIED ? &m_growableColsProportions
-                                                    : NULL
-        );
+    const wxSize sz( GetSize() );
 
-        // This gives nested objects that benefit from knowing one size
-        // component in advance the chance to use that.
-        bool didAdjustMinSize = false;
-        int nrows, ncols;
-        CalcRowsCols(nrows, ncols);
+    CalcMaxRowColSz(false);
 
-        // Iterate over all items and inform about column width
-        size_t n = 0;
-        for ( wxSizerItemList::iterator i = m_children.begin();
-              i != m_children.end();
-              ++i, ++n )
-        {
-            const int col = n % ncols;
-            didAdjustMinSize |= (*i)->InformFirstDirection(wxHORIZONTAL, m_colWidths[col], sz.y - m_calculatedMinSize.y);
-    }
+    // since this is the flex sizer, we need to adjust the elements to grow
+    // correctly and flex accordingly
 
-        // Only redo if info was actually used
-        if( didAdjustMinSize )
+    // wxFLEX_GROWMODE_ALL is handled specially since both of the following if 
+    // statements will pass it through. A NULL as the fourth parameter
+    // to DoAdjustForGrowables means to distribute the extra weight across all
+    // rows -- which should only be done if wxFLEX_GROWMODE_ALL is specified 
+    // AND it is a non-flexible direction
+
+    // horizontal direction
+    if ( (m_flexDirection & wxHORIZONTAL) || (m_growMode != wxFLEX_GROWMODE_NONE) )
     {
         DoAdjustForGrowables
         (
             sz.x - m_calculatedMinSize.x,
             m_growableCols,
             m_colWidths,
-            m_growMode == wxFLEX_GROWMODE_SPECIFIED ? &m_growableColsProportions
-                                                    : NULL
+            m_flexDirection & wxHORIZONTAL || m_growMode == wxFLEX_GROWMODE_SPECIFIED
+                ? &m_growableColsProportions : NULL
         );
     }
-}
 
+    // then for the vertical direction
     if ( (m_flexDirection & wxVERTICAL) || (m_growMode != wxFLEX_GROWMODE_NONE) )
     {
         // pass NULL instead of proportions if the grow mode is ALL as we
@@ -1814,13 +2235,123 @@
             sz.y - m_calculatedMinSize.y,
             m_growableRows,
             m_rowHeights,
-            m_growMode == wxFLEX_GROWMODE_SPECIFIED ? &m_growableRowsProportions
-                                                    : NULL
+            m_flexDirection & wxVERTICAL || m_growMode == wxFLEX_GROWMODE_SPECIFIED 
+                ? &m_growableRowsProportions : NULL
         );
     }
+
+
+    // this doesn't go here, but it should be integrated in somehow
+            // clip values
+/*     
+    const int x = sz.x - (m_colPts[col] - m_colPts[0]);
+    if (w > x)
+        w = x;
+
+    const int y = sz.y - (m_rowPts[row] - m_rowPts[0]);
+    if (h > y)
+        h = y;
+*/
 }
 
 
+// helper function used in CalcMin() to sum up the sizes of non-hidden items
+static inline
+int SumArraySizes(const wxArrayInt& sizes, int gap)
+{
+    // Sum total minimum size, including gaps between rows/columns.
+    // -1 is used as a magic number meaning empty row/column.
+    int total = 0;
+
+    const size_t count = sizes.size();
+    for ( size_t n = 0; n < count; n++ )
+    {
+        if ( sizes[n] != -1 )
+        {
+            if ( total )
+                total += gap; // separate from the previous column
+
+            total += sizes[n];
+        }
+    }
+
+    return total;
+}
+
+
+wxSize wxFlexGridSizer::CalcMin()
+{
+    // Number of rows/columns can change as items are added or removed.
+    if ( !CalcRowsCols() )
+        return wxSize();
+
+    // do a first go around, find min sizes
+    CalcMaxRowColSz(true);
+
+    // This gives nested objects that benefit from knowing one size
+    // component in advance the chance to use that.
+    bool didAdjustMinSize = false;
+    int col;
+    wxGridSpan span;
+
+    for ( wxSizerItem *item = BeginIterateGrid(NULL, &col, &span); 
+          item; 
+          item = IterateGrid(NULL, &col, &span))
+    {
+        // begin to sum up its total width
+        int w = m_colWidths[col];
+
+        // determine the span length
+        const int maxc = col + span.GetColspan() < m_cols ? col + span.GetColspan() 
+                                                         : m_cols;
+        for (col++; col < maxc; col++)
+            w += m_hgap + m_colWidths[col];
+
+        didAdjustMinSize |= item->InformFirstDirection(wxHORIZONTAL, w, -1);
+    }
+    
+    // do a second go around if needed
+    if (didAdjustMinSize)
+        CalcMaxRowColSz(false);
+
+
+    // the logic in CalcMin works when we resize flexibly in both directions
+    // but maybe this is not the case
+    if ( m_flexDirection != wxBOTH )
+    {
+        // select the array corresponding to the direction in which we do *not*
+        // resize flexibly
+        wxArrayInt& array = m_flexDirection == wxVERTICAL ? m_colWidths
+                                                          : m_rowHeights;
+
+        const size_t count = array.GetCount();
+
+        // find the largest value in this array
+        size_t n;
+        int largest = 0;
+
+        for ( n = 0; n < count; ++n )
+        {
+            if ( array[n] > largest )
+                largest = array[n];
+        }
+
+        // and now fill it with the largest value
+        for ( n = 0; n < count; ++n )
+        {
+            // don't touch hidden rows
+            if ( array[n] != -1 )
+                array[n] = largest;
+        }
+    }
+
+    // sum arrays to return the final size
+    m_calculatedMinSize = wxSize(SumArraySizes(m_colWidths, m_hgap), SumArraySizes(m_rowHeights, m_vgap));
+
+    return m_calculatedMinSize;
+}
+
+
 void wxFlexGridSizer::AddGrowableRow( size_t idx, int proportion )
 {
     m_growableRows.Add( idx );
Index: src/xrc/xh_sizer.cpp
===================================================================
--- src/xrc/xh_sizer.cpp	(revision 53980)
+++ src/xrc/xh_sizer.cpp	(working copy)
@@ -352,12 +352,12 @@
     return wxGBPosition(sz.x, sz.y);
 }
 
-wxGBSpan wxSizerXmlHandler::GetGBSpan(const wxString& param)
+wxGridSpan wxSizerXmlHandler::GetGridSpan(const wxString& param)
 {
     wxSize sz = GetSize(param);
     if (sz.x < 1) sz.x = 1;
     if (sz.y < 1) sz.y = 1;
-    return wxGBSpan(sz.x, sz.y);
+    return wxGridSpan(sz.x, sz.y);
 }
 
 
@@ -382,11 +382,24 @@
     if (!(sz == wxDefaultSize))
         sitem->SetRatio(sz);
 
+    // only useful in gridsizer and derived, but supported by wxSizerItem
+    int rs = GetLong(wxT("rowspan"));
+    int cs = GetLong(wxT("colspan"));
+
+    // really, you shouldn't specify both cellspan and rowspan, but if you
+    // do, then we just use the biggest specified number
+    wxGridSpan span = GetGridSpan(wxT("cellspan"));
+
+    // span already has a min of 1, so the automatic min value here is 1
+    span.SetRowspan(wxMax(span.GetRowspan(), rs));
+    span.SetColspan(wxMax(span.GetColspan(), cs));
+
+    sitem->SetSpan(span);
+
     if (m_isGBS)
     {
         wxGBSizerItem* gbsitem = (wxGBSizerItem*)sitem;
         gbsitem->SetPos(GetGBPos(wxT("cellpos")));
-        gbsitem->SetSpan(GetGBSpan(wxT("cellspan")));
     }
 
     // record the id of the item, if any, for use by XRCSIZERITEM()
