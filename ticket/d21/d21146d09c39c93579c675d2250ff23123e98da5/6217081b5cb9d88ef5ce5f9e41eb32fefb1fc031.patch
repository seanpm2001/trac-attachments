Index: include/wx/aui/auibook.h
===================================================================
--- include/wx/aui/auibook.h
+++ include/wx/aui/auibook.h
@@ -5,6 +5,8 @@
 // Modified by: Jens Lody
 // Created:     2006-06-28
 // Copyright:   (C) Copyright 2006, Kirix Corporation, All Rights Reserved.
+//                            2012, Jens Lody for the code related to left
+//                                  and right positioning
 // Licence:     wxWindows Library Licence, Version 3.1
 ///////////////////////////////////////////////////////////////////////////////
 
@@ -21,31 +23,25 @@
 
 #if wxUSE_AUI
 
-#include "wx/aui/tabart.h"
-#include "wx/aui/framemanager.h"
 #include "wx/bookctrl.h"
-#include "wx/containr.h"
-
-
-class wxAuiNotebook;
-
 
 enum wxAuiNotebookOption
 {
-    wxAUI_NB_TOP                 = 1 << 0,
-    wxAUI_NB_LEFT                = 1 << 1,  // not implemented yet
-    wxAUI_NB_RIGHT               = 1 << 2,  // not implemented yet
-    wxAUI_NB_BOTTOM              = 1 << 3,
-    wxAUI_NB_TAB_SPLIT           = 1 << 4,
-    wxAUI_NB_TAB_MOVE            = 1 << 5,
-    wxAUI_NB_TAB_EXTERNAL_MOVE   = 1 << 6,
-    wxAUI_NB_TAB_FIXED_WIDTH     = 1 << 7,
-    wxAUI_NB_SCROLL_BUTTONS      = 1 << 8,
-    wxAUI_NB_WINDOWLIST_BUTTON   = 1 << 9,
-    wxAUI_NB_CLOSE_BUTTON        = 1 << 10,
-    wxAUI_NB_CLOSE_ON_ACTIVE_TAB = 1 << 11,
-    wxAUI_NB_CLOSE_ON_ALL_TABS   = 1 << 12,
-    wxAUI_NB_MIDDLE_CLICK_CLOSE  = 1 << 13,
+    wxAUI_NB_TAB_SPLIT           = 1 << 1, 
+    wxAUI_NB_TAB_MOVE            = 1 << 2, 
+    wxAUI_NB_TAB_EXTERNAL_MOVE   = 1 << 3, 
+    wxAUI_NB_TOP                 = wxBK_TOP,     // 1 << 4
+    wxAUI_NB_LEFT                = wxBK_LEFT,    // 1 << 5 
+    wxAUI_NB_RIGHT               = wxBK_RIGHT,   // 1 << 6
+    wxAUI_NB_BOTTOM              = wxBK_BOTTOM,  // 1 << 7
+    wxAUI_NB_TAB_FIXED_WIDTH     = 1 << 8,
+    wxAUI_NB_TAB_FIXED_HEIGHT    = wxAUI_NB_TAB_FIXED_WIDTH,
+    wxAUI_NB_SCROLL_BUTTONS      = 1 << 9, 
+    wxAUI_NB_WINDOWLIST_BUTTON   = 1 << 10,
+    wxAUI_NB_CLOSE_BUTTON        = 1 << 11,
+    wxAUI_NB_CLOSE_ON_ACTIVE_TAB = 1 << 12,
+    wxAUI_NB_CLOSE_ON_ALL_TABS   = 1 << 13,
+    wxAUI_NB_MIDDLE_CLICK_CLOSE  = 1 << 14,
 
     wxAUI_NB_DEFAULT_STYLE = wxAUI_NB_TOP |
                              wxAUI_NB_TAB_SPLIT |
@@ -56,6 +52,12 @@ enum wxAuiNotebookOption
 };
 
 
+#include "wx/aui/tabart.h"
+#include "wx/aui/framemanager.h"
+#include "wx/containr.h"
+
+
+class wxAuiNotebook;
 
 
 // aui notebook event class
@@ -171,6 +173,9 @@ public:
     // Make the tab visible if it wasn't already
     void MakeTabVisible(int tabPage, wxWindow* win);
 
+    bool IsLayoutHorizontally() { return (m_flags & (wxAUI_NB_TOP | wxAUI_NB_BOTTOM)) != 0; }
+    bool IsLayoutVertically()   { return (m_flags & (wxAUI_NB_LEFT | wxAUI_NB_RIGHT)) != 0; }
+
 protected:
 
     virtual void Render(wxDC* dc, wxWindow* wnd);
@@ -320,9 +325,15 @@ public:
     // Gets the tab control height
     int GetTabCtrlHeight() const;
 
+    // Gets the tab control width
+    int GetTabCtrlWidth() const;
+
     // Gets the height of the notebook for a given page height
     int GetHeightForPageHeight(int pageHeight);
 
+    // Gets the width of the notebook for a given page width
+    int GetWidthForPageWidth(int pageWidth);
+
     // Advances the selection, generation page selection events
     void AdvanceSelection(bool forward = true);
 
@@ -353,6 +364,13 @@ public:
     virtual bool InsertPage(size_t index, wxWindow *page, const wxString &text,
                             bool select, int imageId);
 
+    bool IsTopAligned()         { return (m_flags & wxAUI_NB_TOP) != 0;}
+    bool IsLeftAligned()        { return (m_flags & wxAUI_NB_LEFT) != 0;}
+    bool IsRightAligned()       { return (m_flags & wxAUI_NB_RIGHT) != 0;}
+    bool IsBottomAligned()      { return (m_flags & wxAUI_NB_BOTTOM) != 0;}
+    bool IsLayoutHorizontally() { return (m_flags & (wxAUI_NB_TOP | wxAUI_NB_BOTTOM)) != 0; }
+    bool IsLayoutVertically()   { return (m_flags & (wxAUI_NB_LEFT | wxAUI_NB_RIGHT)) != 0; }
+
 protected:
     // Common part of all ctors.
     void Init();
@@ -367,9 +385,9 @@ protected:
 
     // update the height, return true if it was done or false if the new height
     // calculated by CalculateTabCtrlHeight() is the same as the old one
-    virtual bool UpdateTabCtrlHeight();
+    virtual bool UpdateTabCtrlSize();
 
-    virtual int CalculateTabCtrlHeight();
+    virtual wxSize CalculateTabCtrlSize();
     virtual wxSize CalculateNewSplitSize();
 
     // remove the page and return a pointer to it
@@ -428,6 +446,7 @@ protected:
     wxFont m_selectedFont;
     wxFont m_normalFont;
     int m_tabCtrlHeight;
+    int m_tabCtrlWidth;
 
     int m_lastDragX;
     unsigned int m_flags;
Index: include/wx/aui/tabart.h
===================================================================
--- include/wx/aui/tabart.h
+++ include/wx/aui/tabart.h
@@ -2,10 +2,12 @@
 // Name:        wx/aui/tabart.h
 // Purpose:     wxaui: wx advanced user interface - notebook
 // Author:      Benjamin I. Williams
-// Modified by: Jens Lody (extracted from wx/aui/auibook.h)
+// Modified by: Jens Lody
 // Created:     2012-03-21
-// RCS-ID:      $Id:$
+// RCS-ID:      $Id$
 // Copyright:   (C) Copyright 2006, Kirix Corporation, All Rights Reserved.
+//                            2012, Jens Lody for the code related to left
+//                                  and right positioning
 // Licence:     wxWindows Library Licence, Version 3.1
 ///////////////////////////////////////////////////////////////////////////////
 
@@ -21,6 +23,8 @@
 
 #if wxUSE_AUI
 
+#include "wx/aui/auibook.h"
+
 #include "wx/colour.h"
 #include "wx/gdicmn.h"
 #include "wx/font.h"
@@ -95,10 +99,16 @@ public:
 
     virtual int GetIndentSize() = 0;
 
+    virtual wxSize GetBestTabSize(
+                         wxWindow* wnd,
+                         const wxAuiNotebookPageArray& pages,
+                         const wxSize& requiredBmpSize) = 0;
+
     virtual int GetBestTabCtrlSize(
                          wxWindow* wnd,
                          const wxAuiNotebookPageArray& pages,
                          const wxSize& requiredBmpSize) = 0;
+                         
 };
 
 
@@ -160,9 +170,22 @@ public:
                  const wxAuiNotebookPageArray& items,
                  int activeIdx);
 
-    int GetBestTabCtrlSize(wxWindow* wnd,
+    wxSize GetBestTabSize(wxWindow* wnd,
                  const wxAuiNotebookPageArray& pages,
                  const wxSize& requiredBmpSize);
+    int GetBestTabCtrlSize(wxWindow* wnd,
+                 const wxAuiNotebookPageArray& pages,
+                 const wxSize& requiredBmpSize)
+                 {
+                     return GetBestTabSize(wnd, pages, requiredBmpSize).GetHeight();
+                 }
+
+    bool IsTopAligned()         { return (m_flags & wxAUI_NB_TOP) != 0;}
+    bool IsLeftAligned()        { return (m_flags & wxAUI_NB_LEFT) != 0;}
+    bool IsRightAligned()       { return (m_flags & wxAUI_NB_RIGHT) != 0;}
+    bool IsBottomAligned()      { return (m_flags & wxAUI_NB_BOTTOM) != 0;}
+    bool IsLayoutHorizontally() { return (m_flags & (wxAUI_NB_TOP | wxAUI_NB_BOTTOM)) != 0; }
+    bool IsLayoutVertically()   { return (m_flags & (wxAUI_NB_LEFT | wxAUI_NB_RIGHT)) != 0; }
 
 protected:
 
@@ -178,13 +201,18 @@ protected:
     wxBitmap m_disabledCloseBmp;
     wxBitmap m_activeLeftBmp;
     wxBitmap m_disabledLeftBmp;
+    wxBitmap m_activeUpBmp;
+    wxBitmap m_disabledUpBmp;
+    wxBitmap m_activeDownBmp;
+    wxBitmap m_disabledDownBmp;
     wxBitmap m_activeRightBmp;
     wxBitmap m_disabledRightBmp;
     wxBitmap m_activeWindowListBmp;
     wxBitmap m_disabledWindowListBmp;
 
-    int m_fixedTabWidth;
+    int m_fixedTabSize;
     int m_tabCtrlHeight;
+    int m_tabCtrlWidth;
     unsigned int m_flags;
 };
 
@@ -248,9 +276,22 @@ public:
                  const wxAuiNotebookPageArray& items,
                  int activeIdx);
 
-    int GetBestTabCtrlSize(wxWindow* wnd,
+    wxSize GetBestTabSize(wxWindow* wnd,
                  const wxAuiNotebookPageArray& pages,
                  const wxSize& requiredBmpSize);
+    int GetBestTabCtrlSize(wxWindow* wnd,
+                 const wxAuiNotebookPageArray& pages,
+                 const wxSize& requiredBmpSize)
+                 {
+                     return GetBestTabSize(wnd, pages, requiredBmpSize).GetHeight();
+                 }
+
+    bool IsTopAligned()         { return (m_flags & wxAUI_NB_TOP) != 0;}
+    bool IsLeftAligned()        { return (m_flags & wxAUI_NB_LEFT) != 0;}
+    bool IsRightAligned()       { return (m_flags & wxAUI_NB_RIGHT) != 0;}
+    bool IsBottomAligned()      { return (m_flags & wxAUI_NB_BOTTOM) != 0;}
+    bool IsLayoutHorizontally() { return (m_flags & (wxAUI_NB_TOP | wxAUI_NB_BOTTOM)) != 0; }
+    bool IsLayoutVertically()   { return (m_flags & (wxAUI_NB_LEFT | wxAUI_NB_RIGHT)) != 0; }
 
 protected:
 
@@ -266,12 +307,16 @@ protected:
     wxBitmap m_disabledCloseBmp;
     wxBitmap m_activeLeftBmp;
     wxBitmap m_disabledLeftBmp;
+    wxBitmap m_activeUpBmp;
+    wxBitmap m_disabledUpBmp;
+    wxBitmap m_activeDownBmp;
+    wxBitmap m_disabledDownBmp;
     wxBitmap m_activeRightBmp;
     wxBitmap m_disabledRightBmp;
     wxBitmap m_activeWindowListBmp;
     wxBitmap m_disabledWindowListBmp;
 
-    int m_fixedTabWidth;
+    int m_fixedTabSize;
     unsigned int m_flags;
 };
 
Index: include/wx/aui/tabartgtk.h
===================================================================
--- include/wx/aui/tabartgtk.h
+++ include/wx/aui/tabartgtk.h
@@ -2,11 +2,13 @@
 // Name:        include/wx/aui/tabartgtk.h
 // Purpose:     declaration of the wxAuiGTKTabArt
 // Author:      Jens Lody and Teodor Petrov
-// Modified by:
+// Modified by: Jens Lody
 // Created:     2012-03-23
-// RCS-ID:      $Id:$
+// RCS-ID:      $Id$
 // Copyright:   (c) 2012 Jens Lody <jens@codeblocks.org>
 //                  and Teodor Petrov
+//                  2012, Jens Lody for the code related to left and right
+//                        positioning
 // Licence:     wxWindows licence
 /////////////////////////////////////////////////////////////////////////////
 
@@ -23,6 +25,7 @@
 
 #include "wx/aui/tabart.h"
 #include "wx/gdicmn.h"
+#include "wx/aui/auibook.h"
 
 class wxWindow;
 class wxDC;
@@ -44,11 +47,16 @@ public:
                          int* x_extent);
     void DrawButton(wxDC& dc, wxWindow* wnd, const wxRect& in_rect, int bitmap_id,
                     int button_state, int orientation, wxRect* out_rect);
-    int GetBestTabCtrlSize(wxWindow* wnd, const wxAuiNotebookPageArray& pages,
+    wxSize GetBestTabSize(wxWindow* wnd, const wxAuiNotebookPageArray& pages,
                             const wxSize& required_bmp_size);
+    int GetBestTabCtrlSize(wxWindow* wnd, const wxAuiNotebookPageArray& pages,
+                         const wxSize& requiredBmpSize)
+                         {
+                             return GetBestTabSize(wnd, pages, requiredBmpSize).GetHeight();
+                         }
     virtual wxSize GetTabSize(wxDC& dc, wxWindow* wnd, const wxString& caption,
                               const wxBitmap& bitmap, bool active,
-                              int close_button_state, int* x_extent);
+                              int close_button_state, int* extent);
 };
 
 #endif  // wxUSE_AUI
Index: samples/aui/auidemo.cpp
===================================================================
--- samples/aui/auidemo.cpp
+++ samples/aui/auidemo.cpp
@@ -2,10 +2,12 @@
 // Name:        auidemo.cpp
 // Purpose:     wxaui: wx advanced user interface - sample/test program
 // Author:      Benjamin I. Williams
-// Modified by:
+// Modified by: Jens Lody
 // Created:     2005-10-03
 // RCS-ID:      $Id$
 // Copyright:   (C) Copyright 2005, Kirix Corporation, All Rights Reserved.
+//                            2012, Jens Lody for the code related to left
+//                                  and right positioning
 // Licence:     wxWindows Library Licence, Version 3.1
 ///////////////////////////////////////////////////////////////////////////////
 
@@ -99,10 +101,19 @@ class MyFrame : public wxFrame
         ID_NotebookWindowList,
         ID_NotebookScrollButtons,
         ID_NotebookTabFixedWidth,
-        ID_NotebookArtGloss,
+        ID_NotebookArtDefault,
         ID_NotebookArtSimple,
+#ifdef wxHAS_NATIVE_TABART
+        ID_NotebookArtGeneric,
+#endif
         ID_NotebookAlignTop,
+        ID_NotebookAlignLeft,
+        ID_NotebookAlignRight,
         ID_NotebookAlignBottom,
+        ID_NotebookSplitLeft,
+        ID_NotebookSplitRight,
+        ID_NotebookSplitTop,
+        ID_NotebookSplitBottom,
 
         ID_SampleItem,
 
@@ -157,6 +168,7 @@ private:
     void OnExit(wxCommandEvent& evt);
     void OnAbout(wxCommandEvent& evt);
     void OnTabAlignment(wxCommandEvent &evt);
+    void OnTabSplit(wxCommandEvent &evt);
 
     void OnGradient(wxCommandEvent& evt);
     void OnToolbarResizing(wxCommandEvent& evt);
@@ -606,10 +618,19 @@ BEGIN_EVENT_TABLE(MyFrame, wxFrame)
     EVT_MENU(ID_NotebookAllowTabSplit, MyFrame::OnNotebookFlag)
     EVT_MENU(ID_NotebookScrollButtons, MyFrame::OnNotebookFlag)
     EVT_MENU(ID_NotebookWindowList, MyFrame::OnNotebookFlag)
-    EVT_MENU(ID_NotebookArtGloss, MyFrame::OnNotebookFlag)
+    EVT_MENU(ID_NotebookArtDefault, MyFrame::OnNotebookFlag)
     EVT_MENU(ID_NotebookArtSimple, MyFrame::OnNotebookFlag)
+#ifdef wxHAS_NATIVE_TABART
+    EVT_MENU(ID_NotebookArtGeneric, MyFrame::OnNotebookFlag)
+#endif
     EVT_MENU(ID_NotebookAlignTop,     MyFrame::OnTabAlignment)
+    EVT_MENU(ID_NotebookAlignLeft,  MyFrame::OnTabAlignment)
+    EVT_MENU(ID_NotebookAlignRight,  MyFrame::OnTabAlignment)
     EVT_MENU(ID_NotebookAlignBottom,  MyFrame::OnTabAlignment)
+    EVT_MENU(ID_NotebookSplitLeft,  MyFrame::OnTabSplit)
+    EVT_MENU(ID_NotebookSplitRight,  MyFrame::OnTabSplit)
+    EVT_MENU(ID_NotebookSplitTop,  MyFrame::OnTabSplit)
+    EVT_MENU(ID_NotebookSplitBottom,  MyFrame::OnTabSplit)
     EVT_MENU(ID_NoGradient, MyFrame::OnGradient)
     EVT_MENU(ID_VerticalGradient, MyFrame::OnGradient)
     EVT_MENU(ID_HorizontalGradient, MyFrame::OnGradient)
@@ -718,8 +739,11 @@ MyFrame::MyFrame(wxWindow* parent,
     options_menu->Append(ID_Settings, _("Settings Pane"));
 
     wxMenu* notebook_menu = new wxMenu;
-    notebook_menu->AppendRadioItem(ID_NotebookArtGloss, _("Glossy Theme (Default)"));
+    notebook_menu->AppendRadioItem(ID_NotebookArtDefault, _("Default Theme"));
     notebook_menu->AppendRadioItem(ID_NotebookArtSimple, _("Simple Theme"));
+#ifdef wxHAS_NATIVE_TABART
+    notebook_menu->AppendRadioItem(ID_NotebookArtGeneric, _("GenericTheme"));
+#endif
     notebook_menu->AppendSeparator();
     notebook_menu->AppendRadioItem(ID_NotebookNoCloseButton, _("No Close Button"));
     notebook_menu->AppendRadioItem(ID_NotebookCloseButton, _("Close Button at Right"));
@@ -727,6 +751,8 @@ MyFrame::MyFrame(wxWindow* parent,
     notebook_menu->AppendRadioItem(ID_NotebookCloseButtonActive, _("Close Button on Active Tab"));
     notebook_menu->AppendSeparator();
     notebook_menu->AppendRadioItem(ID_NotebookAlignTop, _("Tab Top Alignment"));
+    notebook_menu->AppendRadioItem(ID_NotebookAlignLeft, _("Tab Left Alignment"));
+    notebook_menu->AppendRadioItem(ID_NotebookAlignRight, _("Tab Right Alignment"));
     notebook_menu->AppendRadioItem(ID_NotebookAlignBottom, _("Tab Bottom Alignment"));
     notebook_menu->AppendSeparator();
     notebook_menu->AppendCheckItem(ID_NotebookAllowTabMove, _("Allow Tab Move"));
@@ -735,6 +761,11 @@ MyFrame::MyFrame(wxWindow* parent,
     notebook_menu->AppendCheckItem(ID_NotebookScrollButtons, _("Scroll Buttons Visible"));
     notebook_menu->AppendCheckItem(ID_NotebookWindowList, _("Window List Button Visible"));
     notebook_menu->AppendCheckItem(ID_NotebookTabFixedWidth, _("Fixed-width Tabs"));
+    notebook_menu->AppendSeparator();
+    notebook_menu->Append         (ID_NotebookSplitLeft, _("Move Active Tab to Left"));
+    notebook_menu->Append         (ID_NotebookSplitRight, _("Move Active Tab to Right"));
+    notebook_menu->Append         (ID_NotebookSplitTop, _("Move Active Tab to Top"));
+    notebook_menu->Append         (ID_NotebookSplitBottom, _("Move Active Tab to Bottom"));
 
     m_perspectives_menu = new wxMenu;
     m_perspectives_menu->Append(ID_CreatePerspective, _("Create Perspective"));
@@ -1189,7 +1220,7 @@ void MyFrame::OnNotebookFlag(wxCommandEvent& event)
         {
             wxAuiNotebook* nb = (wxAuiNotebook*)pane.window;
 
-            if (id == ID_NotebookArtGloss)
+            if (id == ID_NotebookArtDefault)
             {
                 nb->SetArtProvider(new wxAuiDefaultTabArt);
                 m_notebook_theme = 0;
@@ -1199,6 +1230,13 @@ void MyFrame::OnNotebookFlag(wxCommandEvent& event)
                 nb->SetArtProvider(new wxAuiSimpleTabArt);
                 m_notebook_theme = 1;
             }
+#ifdef wxHAS_NATIVE_TABART
+             else if (id == ID_NotebookArtGeneric)
+            {
+                nb->SetArtProvider(new wxAuiGenericTabArt);
+                m_notebook_theme = 1;
+            }
+#endif
 
 
             nb->SetWindowStyleFlag(m_notebook_style);
@@ -1300,12 +1338,17 @@ void MyFrame::OnUpdateUI(wxUpdateUIEvent& event)
         case ID_NotebookTabFixedWidth:
             event.Check((m_notebook_style & wxAUI_NB_TAB_FIXED_WIDTH) != 0);
             break;
-        case ID_NotebookArtGloss:
+        case ID_NotebookArtDefault:
             event.Check(m_notebook_style == 0);
             break;
         case ID_NotebookArtSimple:
             event.Check(m_notebook_style == 1);
             break;
+#ifdef wxHAS_NATIVE_TABART
+        case ID_NotebookArtGeneric:
+            event.Check(m_notebook_style == 2);
+            break;
+#endif
 
     }
 }
@@ -1522,9 +1565,13 @@ void MyFrame::OnTabAlignment(wxCommandEvent &evt)
             wxAuiNotebook* nb = (wxAuiNotebook*)pane.window;
 
             long style = nb->GetWindowStyleFlag();
-            style &= ~(wxAUI_NB_TOP | wxAUI_NB_BOTTOM);
+            style &= ~(wxAUI_NB_TOP | wxAUI_NB_BOTTOM | wxAUI_NB_LEFT | wxAUI_NB_RIGHT);
             if (evt.GetId() == ID_NotebookAlignTop)
                 style |= wxAUI_NB_TOP;
+            else if (evt.GetId() == ID_NotebookAlignLeft)
+                style |= wxAUI_NB_LEFT;
+            else if (evt.GetId() == ID_NotebookAlignRight)
+                style |= wxAUI_NB_RIGHT;
             else if (evt.GetId() == ID_NotebookAlignBottom)
                 style |= wxAUI_NB_BOTTOM;
             nb->SetWindowStyleFlag(style);
@@ -1534,6 +1581,28 @@ void MyFrame::OnTabAlignment(wxCommandEvent &evt)
     }
 }
 
+void MyFrame::OnTabSplit(wxCommandEvent &evt)
+{
+    size_t i, count;
+    wxAuiPaneInfoArray& all_panes = m_mgr.GetAllPanes();
+    for (i = 0, count = all_panes.GetCount(); i < count; ++i)
+    {
+        wxAuiPaneInfo& pane = all_panes.Item(i);
+        if (pane.window->IsKindOf(CLASSINFO(wxAuiNotebook)))
+        {
+            wxAuiNotebook* nb = (wxAuiNotebook*)pane.window;
+
+            if (evt.GetId() == ID_NotebookSplitLeft)
+                nb->Split(nb->GetSelection(), wxLEFT);
+            else if (evt.GetId() == ID_NotebookSplitRight)
+                nb->Split(nb->GetSelection(), wxRIGHT);
+            else if (evt.GetId() == ID_NotebookSplitTop)
+                nb->Split(nb->GetSelection(), wxTOP);
+            else if (evt.GetId() == ID_NotebookSplitBottom)
+                nb->Split(nb->GetSelection(), wxBOTTOM);
+        }
+    }
+}
 void MyFrame::OnExit(wxCommandEvent& WXUNUSED(event))
 {
     Close(true);
Index: src/aui/auibook.cpp
===================================================================
--- src/aui/auibook.cpp
+++ src/aui/auibook.cpp
@@ -5,6 +5,8 @@
 // Modified by: Jens Lody
 // Created:     2006-06-28
 // Copyright:   (C) Copyright 2006, Kirix Corporation, All Rights Reserved
+//                            2012, Jens Lody for the code related to left
+//                                  and right positioning
 // Licence:     wxWindows Library Licence, Version 3.1
 ///////////////////////////////////////////////////////////////////////////////
 
@@ -113,26 +115,44 @@ void wxAuiTabContainer::SetFlags(unsigned int flags)
     // check for new close button settings
     RemoveButton(wxAUI_BUTTON_LEFT);
     RemoveButton(wxAUI_BUTTON_RIGHT);
+    RemoveButton(wxAUI_BUTTON_UP);
+    RemoveButton(wxAUI_BUTTON_DOWN);
     RemoveButton(wxAUI_BUTTON_WINDOWLIST);
     RemoveButton(wxAUI_BUTTON_CLOSE);
 
 
-    if (flags & wxAUI_NB_SCROLL_BUTTONS)
+    if (IsLayoutVertically())
     {
-        AddButton(wxAUI_BUTTON_LEFT, wxLEFT);
-        AddButton(wxAUI_BUTTON_RIGHT, wxRIGHT);
-    }
+        if (flags & wxAUI_NB_SCROLL_BUTTONS)
+        {
+            AddButton(wxAUI_BUTTON_UP, wxUP);
+            AddButton(wxAUI_BUTTON_DOWN, wxDOWN);
+        }
 
-    if (flags & wxAUI_NB_WINDOWLIST_BUTTON)
-    {
-        AddButton(wxAUI_BUTTON_WINDOWLIST, wxRIGHT);
-    }
+        if (flags & wxAUI_NB_WINDOWLIST_BUTTON)
+        {
+            AddButton(wxAUI_BUTTON_WINDOWLIST, wxUP);
+        }
 
-    if (flags & wxAUI_NB_CLOSE_BUTTON)
-    {
-        AddButton(wxAUI_BUTTON_CLOSE, wxRIGHT);
+        if (flags & wxAUI_NB_CLOSE_BUTTON)
+        {
+            AddButton(wxAUI_BUTTON_CLOSE, wxUP);
+        }
     }
+    else // must be wxAUI_NB_TOP or wxAUI_NB_BOTTOM
+    {
+        if (flags & wxAUI_NB_SCROLL_BUTTONS)
+        {
+            AddButton(wxAUI_BUTTON_LEFT, wxLEFT);
+            AddButton(wxAUI_BUTTON_RIGHT, wxRIGHT);
+        }
+
+        if (flags & wxAUI_NB_WINDOWLIST_BUTTON)
+            AddButton(wxAUI_BUTTON_WINDOWLIST, wxRIGHT);
 
+        if (flags & wxAUI_NB_CLOSE_BUTTON)
+            AddButton(wxAUI_BUTTON_CLOSE, wxRIGHT);
+    }
     if (m_art)
     {
         m_art->SetFlags(m_flags);
@@ -429,10 +449,80 @@ void wxAuiTabContainer::Render(wxDC* raw_dc, wxWindow* wnd)
     if (!dc.IsOk())
         return;
 
+    // draw background
+    m_art->DrawBackground(dc, wnd, m_rect);
+
+    // first we create all buttons on the right/bottom, except the forward arrows
+    // so we can determine, whether we need the backward- and forward-arrows
+
+    // draw buttons
+    int backw_buttons_size = 0;
+    int forw_buttons_size = 0;
+
+    int offset = 0;
+
+    int location_btn_right_top;
+    int location_btn_left_bottom;
+    int id_btn_left_bottom;
+    int id_btn_arrow_right_up;
+    int test_size;
+
+    if (IsLayoutVertically())
+    {
+        location_btn_right_top = wxUP;
+        location_btn_left_bottom = wxDOWN;
+        id_btn_left_bottom = wxAUI_BUTTON_DOWN;
+        id_btn_arrow_right_up = wxAUI_BUTTON_UP;
+        test_size = m_rect.GetHeight();
+    }
+    else
+    {
+        location_btn_right_top = wxRIGHT;
+        location_btn_left_bottom = wxLEFT;
+        id_btn_left_bottom = wxAUI_BUTTON_LEFT;
+        id_btn_arrow_right_up = wxAUI_BUTTON_RIGHT;
+        test_size = m_rect.GetWidth();
+    }
+
+
+    // draw the forward buttons on the top
+    offset = m_rect.x + m_rect.width;
+    for (i = button_count; i > 0 ; --i)
+    {
+        wxAuiTabContainerButton& button = m_buttons.Item(i - 1);
+
+        if (button.location != location_btn_right_top)
+            continue;
+        if (button.curState & wxAUI_BUTTON_STATE_HIDDEN)
+            continue;
+        if (button.id == id_btn_arrow_right_up)
+            continue;
+
+        wxRect button_rect = m_rect;
+        button_rect.SetWidth(offset);
+        button_rect.SetX(1);
+        button_rect.SetY(1);
+
+        m_art->DrawButton(dc,
+                          wnd,
+                          button_rect,
+                          button.id,
+                          button.curState,
+                          location_btn_right_top,
+                          &button.rect);
+
+        offset -= button.rect.GetWidth();
+        if (IsLayoutVertically())
+            backw_buttons_size = wxMax(backw_buttons_size, button.rect.GetHeight());
+        else
+            forw_buttons_size += button.rect.GetWidth();
+
+    }
+
     // find out if size of tabs is larger than can be
     // afforded on screen
-    int total_width = 0;
-    int visible_width = 0;
+    int total_size = 0;
+    int visible_size = 0;
     for (i = 0; i < page_count; ++i)
     {
         wxAuiNotebookPage& page = m_pages.Item(i);
@@ -446,7 +536,7 @@ void wxAuiTabContainer::Render(wxDC* raw_dc, wxWindow* wnd)
         }
 
 
-        int x_extent = 0;
+        int extent = 0;
         wxSize size = m_art->GetTabSize(dc,
                             wnd,
                             page.caption,
@@ -455,87 +545,76 @@ void wxAuiTabContainer::Render(wxDC* raw_dc, wxWindow* wnd)
                             close_button ?
                               wxAUI_BUTTON_STATE_NORMAL :
                               wxAUI_BUTTON_STATE_HIDDEN,
-                            &x_extent);
+                            &extent);
+
+        int s = 0;
+
+        if (IsLayoutVertically())
+            s = size.y;
+        else // must be wxAUI_NB_TOP or wxAUI_NB_BOTTOM
+            s = size.x;
 
         if (i+1 < page_count)
-            total_width += x_extent;
+            total_size += extent;
         else
-            total_width += size.x;
+            total_size += s;
 
         if (i >= m_tabOffset)
         {
             if (i+1 < page_count)
-                visible_width += x_extent;
+                visible_size += extent;
             else
-                visible_width += size.x;
+                visible_size += s;
         }
     }
 
-    if (total_width > m_rect.GetWidth() || m_tabOffset != 0)
-    {
-        // show left/right buttons
-        for (i = 0; i < button_count; ++i)
-        {
-            wxAuiTabContainerButton& button = m_buttons.Item(i);
-            if (button.id == wxAUI_BUTTON_LEFT ||
-                button.id == wxAUI_BUTTON_RIGHT)
-            {
-                button.curState &= ~wxAUI_BUTTON_STATE_HIDDEN;
-            }
-        }
-    }
+    int btn_size;
+    if (IsLayoutVertically())
+        btn_size = backw_buttons_size;
     else
+        btn_size = forw_buttons_size;
+
+    // show up/down buttons
+    for (i = 0; i < button_count; ++i)
     {
-        // hide left/right buttons
-        for (i = 0; i < button_count; ++i)
+        wxAuiTabContainerButton& button = m_buttons.Item(i);
+        if (button.id == id_btn_arrow_right_up ||
+            button.id == id_btn_left_bottom)
         {
-            wxAuiTabContainerButton& button = m_buttons.Item(i);
-            if (button.id == wxAUI_BUTTON_LEFT ||
-                button.id == wxAUI_BUTTON_RIGHT)
-            {
+            if (total_size > (test_size - btn_size - m_art->GetIndentSize()) ||
+                m_tabOffset != 0)
+                button.curState &= ~wxAUI_BUTTON_STATE_HIDDEN;
+            else
                 button.curState |= wxAUI_BUTTON_STATE_HIDDEN;
-            }
         }
     }
 
-    // determine whether left button should be enabled
+    // determine whether left/upbutton should be enabled
     for (i = 0; i < button_count; ++i)
     {
         wxAuiTabContainerButton& button = m_buttons.Item(i);
-        if (button.id == wxAUI_BUTTON_LEFT)
+        if (button.id == wxAUI_BUTTON_LEFT || button.id == wxAUI_BUTTON_UP)
         {
             if (m_tabOffset == 0)
                 button.curState |= wxAUI_BUTTON_STATE_DISABLED;
             else
                 button.curState &= ~wxAUI_BUTTON_STATE_DISABLED;
         }
-        if (button.id == wxAUI_BUTTON_RIGHT)
-        {
-            if (visible_width < m_rect.GetWidth() - ((int)button_count*16))
-                button.curState |= wxAUI_BUTTON_STATE_DISABLED;
-            else
-                button.curState &= ~wxAUI_BUTTON_STATE_DISABLED;
-        }
     }
 
 
+    // now draw forwardarrows, keep the rect where it should be drawn, so we are
+    // able to redraw it, if it should be enabled. We can only determine this, if it is actually drawn
+    // because we do not know it's exact size
+    wxRect forw_btn_rect;
 
-    // draw background
-    m_art->DrawBackground(dc, wnd, m_rect);
-
-    // draw buttons
-    int left_buttons_width = 0;
-    int right_buttons_width = 0;
-
-    int offset = 0;
-
-    // draw the buttons on the right side
-    offset = m_rect.x + m_rect.width;
-    for (i = 0; i < button_count; ++i)
+    for (i = button_count; i > 0 ; --i)
     {
-        wxAuiTabContainerButton& button = m_buttons.Item(button_count - i - 1);
+        wxAuiTabContainerButton& button = m_buttons.Item(i - 1);
 
-        if (button.location != wxRIGHT)
+        if (button.location != location_btn_right_top)
+            continue;
+        if (button.id != id_btn_arrow_right_up)
             continue;
         if (button.curState & wxAUI_BUTTON_STATE_HIDDEN)
             continue;
@@ -544,48 +623,63 @@ void wxAuiTabContainer::Render(wxDC* raw_dc, wxWindow* wnd)
         button_rect.SetY(1);
         button_rect.SetWidth(offset);
 
+        if (IsLayoutHorizontally())
+            forw_btn_rect = button_rect;
+
         m_art->DrawButton(dc,
                           wnd,
                           button_rect,
                           button.id,
                           button.curState,
-                          wxRIGHT,
+                          location_btn_right_top,
                           &button.rect);
 
         offset -= button.rect.GetWidth();
-        right_buttons_width += button.rect.GetWidth();
-    }
-
+        if (IsLayoutVertically())
+            backw_buttons_size = wxMax(backw_buttons_size, button.rect.GetHeight());
+        else
+            forw_buttons_size += button.rect.GetWidth();
 
+    }
 
     offset = 0;
 
-    // draw the buttons on the left side
+        // draw the buttons on the bottom side
 
-    for (i = 0; i < button_count; ++i)
+    for (i = button_count; i > 0 ; --i)
     {
-        wxAuiTabContainerButton& button = m_buttons.Item(button_count - i - 1);
+        wxAuiTabContainerButton& button = m_buttons.Item(i - 1);
 
-        if (button.location != wxLEFT)
+        if (button.location != location_btn_left_bottom)
             continue;
         if (button.curState & wxAUI_BUTTON_STATE_HIDDEN)
             continue;
 
-        wxRect button_rect(offset, 1, 1000, m_rect.height);
+        wxRect button_rect = m_rect;
+        button_rect.SetX(1);
+        button_rect.width -= offset;
+        button_rect.SetY(1);
+
+        if (IsLayoutVertically() && button.id == wxAUI_BUTTON_DOWN)
+            forw_btn_rect = button_rect;
 
         m_art->DrawButton(dc,
                           wnd,
                           button_rect,
                           button.id,
                           button.curState,
-                          wxLEFT,
+                          location_btn_left_bottom,
                           &button.rect);
 
         offset += button.rect.GetWidth();
-        left_buttons_width += button.rect.GetWidth();
+        if (IsLayoutVertically())
+            forw_buttons_size = wxMax(forw_buttons_size, button.rect.GetHeight());
+        else
+            backw_buttons_size += button.rect.GetWidth();
     }
 
-    offset = left_buttons_width;
+    // this is not a typo, we use the size we determined when drawing the top (aka backw) buttons
+    offset = backw_buttons_size;
 
     if (offset == 0)
         offset += m_art->GetIndentSize();
@@ -613,6 +707,26 @@ void wxAuiTabContainer::Render(wxDC* raw_dc, wxWindow* wnd)
         m_tabCloseButtons.Item(i).curState = wxAUI_BUTTON_STATE_HIDDEN;
     }
 
+    // determine whether right/down button should be enabled
+    for (i = 0; i < button_count; ++i)
+    {
+        wxAuiTabContainerButton& button = m_buttons.Item(i);
+        if (button.id == wxAUI_BUTTON_RIGHT || button.id == wxAUI_BUTTON_DOWN)
+        {
+            if (visible_size < test_size - (backw_buttons_size + forw_buttons_size))
+                button.curState |= wxAUI_BUTTON_STATE_DISABLED;
+            else
+                button.curState &= ~wxAUI_BUTTON_STATE_DISABLED;
+
+            m_art->DrawButton(dc,
+                              wnd,
+                              forw_btn_rect,
+                              button.id,
+                              button.curState,
+                              button.location,
+                              &button.rect);
+        }
+    }
 
     // draw the tabs
 
@@ -620,10 +734,19 @@ void wxAuiTabContainer::Render(wxDC* raw_dc, wxWindow* wnd)
     int active_offset = 0;
     wxRect active_rect;
 
-    int x_extent = 0;
+    int extent = 0;
     wxRect rect = m_rect;
-    rect.y = 0;
-    rect.height = m_rect.height;
+
+    if (IsLayoutVertically())
+    {
+        rect.x = 0;
+        rect.width = m_rect.width;
+    }
+    else // must be wxAUI_NB_TOP or wxAUI_NB_BOTTOM
+    {
+        rect.y = 0;
+        rect.height = m_rect.height;
+    }
 
     for (i = m_tabOffset; i < page_count; ++i)
     {
@@ -646,11 +769,20 @@ void wxAuiTabContainer::Render(wxDC* raw_dc, wxWindow* wnd)
             tab_button.curState = wxAUI_BUTTON_STATE_HIDDEN;
         }
 
-        rect.x = offset;
-        rect.width = m_rect.width - right_buttons_width - offset - 2;
-
-        if (rect.width <= 0)
-            break;
+        if (IsLayoutVertically())
+        {
+            rect.y = offset;
+            rect.height = m_rect.height - forw_buttons_size - offset - 2;
+            if (rect.height <= 0)
+                break;
+        }
+        else // must be wxAUI_NB_TOP or wxAUI_NB_BOTTOM
+        {
+            rect.x = offset;
+            rect.width = m_rect.width - forw_buttons_size - offset - 2;
+            if (rect.width <= 0)
+                break;
+        }
 
         m_art->DrawTab(dc,
                        wnd,
@@ -659,7 +791,7 @@ void wxAuiTabContainer::Render(wxDC* raw_dc, wxWindow* wnd)
                        tab_button.curState,
                        &page.rect,
                        &tab_button.rect,
-                       &x_extent);
+                       &extent);
 
         if (page.active)
         {
@@ -668,7 +800,7 @@ void wxAuiTabContainer::Render(wxDC* raw_dc, wxWindow* wnd)
             active_rect = rect;
         }
 
-        offset += x_extent;
+        offset += extent;
     }
 
 
@@ -694,7 +826,7 @@ void wxAuiTabContainer::Render(wxDC* raw_dc, wxWindow* wnd)
                        tab_button.curState,
                        &page.rect,
                        &tab_button.rect,
-                       &x_extent);
+                       &extent);
     }
 
 
@@ -724,7 +856,9 @@ bool wxAuiTabContainer::IsTabVisible(int tabPage, int tabOffset, wxDC* dc, wxWin
     {
         wxAuiTabContainerButton& button = m_buttons.Item(i);
         if (button.id == wxAUI_BUTTON_LEFT ||
-            button.id == wxAUI_BUTTON_RIGHT)
+            button.id == wxAUI_BUTTON_RIGHT ||
+            button.id == wxAUI_BUTTON_UP ||
+            button.id == wxAUI_BUTTON_DOWN)
         {
             if ((button.curState & wxAUI_BUTTON_STATE_HIDDEN) == 0)
                 arrowButtonVisibleCount ++;
@@ -740,87 +874,119 @@ bool wxAuiTabContainer::IsTabVisible(int tabPage, int tabOffset, wxDC* dc, wxWin
         return false;
 
     // draw buttons
-    int left_buttons_width = 0;
-    int right_buttons_width = 0;
+    int forw_buttons_size = 0;
+    int backw_buttons_size = 0;
 
     int offset = 0;
 
-    // calculate size of the buttons on the right side
-    offset = m_rect.x + m_rect.width;
-    for (i = 0; i < button_count; ++i)
+    // calculate size of the buttons on the right/bottom side
+    if (IsLayoutVertically())
     {
-        wxAuiTabContainerButton& button = m_buttons.Item(button_count - i - 1);
+        for (i = 0; i < button_count; ++i)
+        {
+            wxAuiTabContainerButton& button = m_buttons.Item(button_count - i - 1);
 
-        if (button.location != wxRIGHT)
-            continue;
-        if (button.curState & wxAUI_BUTTON_STATE_HIDDEN)
-            continue;
+            if (button.location != wxDOWN)
+                continue;
+            if (button.curState & wxAUI_BUTTON_STATE_HIDDEN)
+                continue;
 
-        offset -= button.rect.GetWidth();
-        right_buttons_width += button.rect.GetWidth();
+            offset = wxMax(offset, button.rect.GetHeight());
+            forw_buttons_size = offset;
+        }
+    }
+    else // must be wxAUI_NB_TOP or wxAUI_NB_BOTTOM
+    {
+        offset = m_rect.x + m_rect.width;
+        for (i = 0; i < button_count; ++i)
+        {
+            wxAuiTabContainerButton& button = m_buttons.Item(button_count - i - 1);
+
+            if (button.location != wxRIGHT)
+                continue;
+            if (button.curState & wxAUI_BUTTON_STATE_HIDDEN)
+                continue;
+
+            offset -= button.rect.GetWidth();
+            forw_buttons_size += button.rect.GetWidth();
+        }
     }
 
+
     offset = 0;
 
-    // calculate size of the buttons on the left side
+    int location_btn_left_top;
+    int test_size;
+
+    if (IsLayoutVertically())
+    {
+        location_btn_left_top = wxUP;
+        test_size = m_rect.GetHeight();
+    }
+    else
+    {
+        location_btn_left_top = wxLEFT;
+        test_size = m_rect.GetWidth();
+    }
+
+
     for (i = 0; i < button_count; ++i)
     {
         wxAuiTabContainerButton& button = m_buttons.Item(button_count - i - 1);
 
-        if (button.location != wxLEFT)
+        if (button.location != location_btn_left_top)
             continue;
         if (button.curState & wxAUI_BUTTON_STATE_HIDDEN)
             continue;
 
-        offset += button.rect.GetWidth();
-        left_buttons_width += button.rect.GetWidth();
+        if (IsLayoutVertically())
+        {
+            offset = wxMax(offset, button.rect.GetHeight());
+            backw_buttons_size = offset;
+        }
+        else
+        {
+            offset += button.rect.GetWidth();
+            backw_buttons_size += button.rect.GetWidth();
+        }
     }
 
-    offset = left_buttons_width;
+    offset = backw_buttons_size;
 
+//    // calculate size of the buttons on the left/top side
     if (offset == 0)
         offset += m_art->GetIndentSize();
 
-    wxRect active_rect;
-
-    wxRect rect = m_rect;
-    rect.y = 0;
-    rect.height = m_rect.height;
-
     // See if the given page is visible at the given tab offset (effectively scroll position)
     for (i = tabOffset; i < page_count; ++i)
     {
         wxAuiNotebookPage& page = m_pages.Item(i);
         wxAuiTabContainerButton& tab_button = m_tabCloseButtons.Item(i);
 
-        rect.x = offset;
-        rect.width = m_rect.width - right_buttons_width - offset - 2;
-
-        if (rect.width <= 0)
+        if ((test_size - forw_buttons_size - offset - 2) <= 0)
             return false; // haven't found the tab, and we've run out of space, so return false
 
-        int x_extent = 0;
+        int extent = 0;
         m_art->GetTabSize(*dc,
                             wnd,
                             page.caption,
                             page.bitmap,
                             page.active,
                             tab_button.curState,
-                            &x_extent);
+                            &extent);
 
-        offset += x_extent;
+        offset += extent;
 
         if (i == (size_t) tabPage)
         {
             // If not all of the tab is visible, and supposing there's space to display it all,
             // we could do better so we return false.
-            if (((m_rect.width - right_buttons_width - offset - 2) <= 0) && ((m_rect.width - right_buttons_width - left_buttons_width) > x_extent))
+            if (((test_size - forw_buttons_size - offset - 2) <= 0) && ((test_size - forw_buttons_size - backw_buttons_size) > extent))
                 return false;
             else
                 return true;
         }
     }
-
     // Shouldn't really get here, but if it does, assume the tab is visible to prevent
     // further looping in calling code.
     return true;
@@ -850,7 +1016,29 @@ void wxAuiTabContainer::MakeTabVisible(int tabPage, wxWindow* win)
 // true if a tab was hit, otherwise false
 bool wxAuiTabContainer::TabHitTest(int x, int y, wxWindow** hit) const
 {
-    if (!m_rect.Contains(x,y))
+    wxRect rect = m_rect;
+    if (m_flags & (wxAUI_NB_LEFT | wxAUI_NB_RIGHT))
+    {
+        int bottom_size = 0;
+        for (size_t i = m_buttons.GetCount(); i > 0 ; --i)
+        {
+            wxAuiTabContainerButton& button = m_buttons.Item(i - 1);
+            if (button.location == wxDOWN)
+            {
+                // if we have hit one of the bottom buttons step out, or we can not click it
+                if (button.rect.Contains(x,y))
+                {
+                    bottom_size = 0;
+                    break;
+                }
+                bottom_size = wxMax(bottom_size, button.rect.GetHeight());
+            }
+        }
+        if (bottom_size)
+            rect.height -= (bottom_size + 2);
+    }
+
+    if (!rect.Contains(x,y))
         return false;
 
     wxAuiTabContainerButton* btn = NULL;
@@ -881,7 +1069,29 @@ bool wxAuiTabContainer::TabHitTest(int x, int y, wxWindow** hit) const
 bool wxAuiTabContainer::ButtonHitTest(int x, int y,
                                       wxAuiTabContainerButton** hit) const
 {
-    if (!m_rect.Contains(x,y))
+    wxRect rect = m_rect;
+    if (m_flags & (wxAUI_NB_LEFT | wxAUI_NB_RIGHT))
+    {
+        int bottom_size = 0;
+        for (size_t i = m_buttons.GetCount(); i > 0 ; --i)
+        {
+            wxAuiTabContainerButton& button = m_buttons.Item(i - 1);
+            if (button.location == wxDOWN)
+            {
+                // if we have hit one of the bottom buttons step out, or we can not click it
+                if (button.rect.Contains(x,y))
+                {
+                    bottom_size = 0;
+                    break;
+                }
+                bottom_size = wxMax(bottom_size, button.rect.GetHeight());
+            }
+        }
+        if (bottom_size)
+            rect.height -= (bottom_size + 2);
+    }
+
+    if (!rect.Contains(x,y))
         return false;
 
     size_t i, button_count;
@@ -1283,9 +1493,13 @@ void wxAuiTabCtrl::OnButton(wxAuiNotebookEvent& event)
 {
     int button = event.GetInt();
 
-    if (button == wxAUI_BUTTON_LEFT || button == wxAUI_BUTTON_RIGHT)
+    if (button == wxAUI_BUTTON_LEFT ||
+        button == wxAUI_BUTTON_UP ||
+        button == wxAUI_BUTTON_DOWN ||
+        button == wxAUI_BUTTON_RIGHT)
     {
-        if (button == wxAUI_BUTTON_LEFT)
+        if (button == wxAUI_BUTTON_LEFT ||
+            button == wxAUI_BUTTON_UP)
         {
             if (GetTabOffset() > 0)
             {
@@ -1470,6 +1684,7 @@ public:
         m_tabs = NULL;
         m_rect = wxRect(0,0,200,200);
         m_tabCtrlHeight = 20;
+        m_tabCtrlHeight = 100;
     }
 
     ~wxTabFrame()
@@ -1482,6 +1697,11 @@ public:
         m_tabCtrlHeight = h;
     }
 
+    void SetTabCtrlWidth(int w)
+    {
+        m_tabCtrlWidth = w;
+    }
+
 protected:
     void DoSetSize(int x, int y,
                    int width, int height,
@@ -1515,14 +1735,24 @@ public:
             m_tabs->SetSize     (m_rect.x, m_rect.y + m_rect.height - m_tabCtrlHeight, m_rect.width, m_tabCtrlHeight);
             m_tabs->SetRect     (wxRect(0, 0, m_rect.width, m_tabCtrlHeight));
         }
-        else //TODO: if (GetFlags() & wxAUI_NB_TOP)
+        else if (m_tabs->GetFlags() & wxAUI_NB_LEFT)
+        {
+            m_tab_rect = wxRect (m_rect.x, m_rect.y, m_tabCtrlWidth , m_rect.height);
+            m_tabs->SetSize     (m_rect.x, m_rect.y, m_tabCtrlWidth , m_rect.height);
+            m_tabs->SetRect     (wxRect(0, 0, m_tabCtrlWidth, m_rect.height));
+        }
+        else if (m_tabs->GetFlags() & wxAUI_NB_RIGHT)
+        {
+            m_tab_rect = wxRect (m_rect.x + m_rect.width - m_tabCtrlWidth, m_rect.y, m_tabCtrlWidth , m_rect.height);
+            m_tabs->SetSize     (m_rect.x + m_rect.width - m_tabCtrlWidth, m_rect.y, m_tabCtrlWidth , m_rect.height);
+            m_tabs->SetRect     (wxRect(0, 0, m_tabCtrlWidth, m_rect.height));
+        }
+        else // must be wxAUI_NB_TOP)
         {
             m_tab_rect = wxRect (m_rect.x, m_rect.y, m_rect.width, m_tabCtrlHeight);
             m_tabs->SetSize     (m_rect.x, m_rect.y, m_rect.width, m_tabCtrlHeight);
             m_tabs->SetRect     (wxRect(0, 0,        m_rect.width, m_tabCtrlHeight));
         }
-        // TODO: else if (GetFlags() & wxAUI_NB_LEFT){}
-        // TODO: else if (GetFlags() & wxAUI_NB_RIGHT){}
 
         m_tabs->Refresh();
         m_tabs->Update();
@@ -1532,12 +1762,28 @@ public:
 
         for (i = 0; i < page_count; ++i)
         {
-            int height = m_rect.height - m_tabCtrlHeight;
-            if ( height < 0 )
+            int height = 0;
+            int width = 0;
+            if (m_tabs->GetFlags() & (wxAUI_NB_LEFT | wxAUI_NB_RIGHT))
             {
-                // avoid passing negative height to wxWindow::SetSize(), this
-                // results in assert failures/GTK+ warnings
-                height = 0;
+                width = m_rect.width - m_tabCtrlWidth;
+                if ( width < 0 )
+                {
+                    // avoid passing negative width to wxWindow::SetSize(), this
+                    // results in assert failures/GTK+ warnings
+                    width = 0;
+                }
+            }
+            else // must be wxAUI_NB_TOP or wxAUI_NB_BOTTOM
+            {
+                height = m_rect.height - m_tabCtrlHeight;
+
+                if ( height < 0 )
+                {
+                    // avoid passing negative height to wxWindow::SetSize(), this
+                    // results in assert failures/GTK+ warnings
+                    height = 0;
+                }
             }
 
             wxAuiNotebookPage& page = pages.Item(i);
@@ -1545,13 +1791,19 @@ public:
             {
                 page.window->SetSize(m_rect.x, m_rect.y, m_rect.width, height);
             }
-            else //TODO: if (GetFlags() & wxAUI_NB_TOP)
+            else if (m_tabs->GetFlags() & wxAUI_NB_LEFT)
+            {
+                page.window->SetSize(m_rect.x + m_tabCtrlWidth, m_rect.y, width, m_rect.height);
+            }
+            else if (m_tabs->GetFlags() & wxAUI_NB_RIGHT)
+            {
+                page.window->SetSize(m_rect.x, m_rect.y, width, m_rect.height);
+            }
+            else // must be wxAUI_NB_TOP)
             {
                 page.window->SetSize(m_rect.x, m_rect.y + m_tabCtrlHeight,
                                      m_rect.width, height);
             }
-            // TODO: else if (GetFlags() & wxAUI_NB_LEFT){}
-            // TODO: else if (GetFlags() & wxAUI_NB_RIGHT){}
 
 #if wxUSE_MDI
             if (page.window->IsKindOf(CLASSINFO(wxAuiMDIChildFrame)))
@@ -1582,6 +1834,7 @@ public:
     wxRect m_tab_rect;
     wxAuiTabCtrl* m_tabs;
     int m_tabCtrlHeight;
+    int m_tabCtrlWidth;
 };
 
 
@@ -1705,7 +1958,7 @@ void wxAuiNotebook::SetArtProvider(wxAuiTabArt* art)
     // Update the height and do nothing else if it did something but otherwise
     // (i.e. if the new art provider uses the same height as the old one) we
     // need to manually set the art provider for all tabs ourselves.
-    if ( !UpdateTabCtrlHeight() )
+    if ( !UpdateTabCtrlSize() )
     {
         wxAuiPaneInfoArray& all_panes = m_mgr.GetAllPanes();
         const size_t pane_count = all_panes.GetCount();
@@ -1735,7 +1988,7 @@ void wxAuiNotebook::SetTabCtrlHeight(int height)
     // if window is already initialized, recalculate the tab height
     if (m_dummyWnd)
     {
-        UpdateTabCtrlHeight();
+        UpdateTabCtrlSize();
     }
 }
 
@@ -1754,25 +2007,27 @@ void wxAuiNotebook::SetUniformBitmapSize(const wxSize& size)
     // if window is already initialized, recalculate the tab height
     if (m_dummyWnd)
     {
-        UpdateTabCtrlHeight();
+        UpdateTabCtrlSize();
     }
 }
 
-// UpdateTabCtrlHeight() does the actual tab resizing. It's meant
+// UpdateTabCtrlSize() does the actual tab resizing. It's meant
 // to be used internally
-bool wxAuiNotebook::UpdateTabCtrlHeight()
+bool wxAuiNotebook::UpdateTabCtrlSize()
 {
     // get the tab ctrl height we will use
-    int height = CalculateTabCtrlHeight();
+    wxSize s = CalculateTabCtrlSize();
 
     // if the tab control height needs to change, update
     // all of our tab controls with the new height
-    if (m_tabCtrlHeight == height)
+    if (m_tabCtrlHeight == s.y &&
+        m_tabCtrlWidth == s.x)
         return false;
 
     wxAuiTabArt* art = m_tabs.GetArtProvider();
 
-    m_tabCtrlHeight = height;
+    m_tabCtrlWidth = s.x;
+    m_tabCtrlHeight = s.y;
 
     wxAuiPaneInfoArray& all_panes = m_mgr.GetAllPanes();
     size_t i, pane_count = all_panes.GetCount();
@@ -1784,6 +2039,7 @@ bool wxAuiNotebook::UpdateTabCtrlHeight()
         wxTabFrame* tab_frame = (wxTabFrame*)pane.window;
         wxAuiTabCtrl* tabctrl = tab_frame->m_tabs;
         tab_frame->SetTabCtrlHeight(m_tabCtrlHeight);
+        tab_frame->SetTabCtrlWidth(m_tabCtrlWidth);
         tabctrl->SetArtProvider(art->Clone());
         tab_frame->DoSizing();
     }
@@ -1836,25 +2092,28 @@ wxSize wxAuiNotebook::CalculateNewSplitSize()
         // this is in place of a more complicated calculation
         // that needs to be implemented
         new_split_size = wxSize(180,180);
+        if (IsLayoutVertically())
+            new_split_size.x += m_tabCtrlWidth;
     }
 
     return new_split_size;
 }
 
-int wxAuiNotebook::CalculateTabCtrlHeight()
+wxSize wxAuiNotebook::CalculateTabCtrlSize()
 {
-    // if a fixed tab ctrl height is specified,
-    // just return that instead of calculating a
-    // tab height
-    if (m_requestedTabCtrlHeight != -1)
-        return m_requestedTabCtrlHeight;
-
-    // find out new best tab height
+    // find out new best tab size
     wxAuiTabArt* art = m_tabs.GetArtProvider();
 
-    return art->GetBestTabCtrlSize(this,
+    wxSize s = art->GetBestTabSize(this,
                                    m_tabs.GetPages(),
                                    m_requestedBmpSize);
+    // if a fixed tab ctrl height is specified,
+    // just use that instead of calculating a
+    // tab height
+    if (m_requestedTabCtrlHeight != -1)
+        s.y = m_requestedTabCtrlHeight;
+
+    return s;
 }
 
 
@@ -1867,7 +2126,15 @@ void wxAuiNotebook::SetWindowStyleFlag(long style)
 {
     wxControl::SetWindowStyleFlag(style);
 
+    bool needsUpdate = m_flags != (unsigned int)style;
     m_flags = (unsigned int)style;
+    if (needsUpdate)
+    {
+        GetArtProvider()->SetFlags(m_flags);
+        UpdateTabCtrlSize();
+        needsUpdate = false;
+    }
+
 
     // if the control is already initialized
     if (m_mgr.GetManagedWindow() == (wxWindow*)this)
@@ -1938,7 +2205,7 @@ bool wxAuiNotebook::InsertPage(size_t page_idx,
     else
         active_tabctrl->InsertPage(page, info, page_idx);
 
-    UpdateTabCtrlHeight();
+    UpdateTabCtrlSize();
     DoSizing();
     active_tabctrl->DoShowHide();
 
@@ -2135,8 +2402,8 @@ bool wxAuiNotebook::SetPageBitmap(size_t page_idx, const wxBitmap& bitmap)
     wxAuiNotebookPage& page_info = m_tabs.GetPage(page_idx);
     page_info.bitmap = bitmap;
 
-    // tab height might have changed
-    UpdateTabCtrlHeight();
+    // tab size might have changed
+    UpdateTabCtrlSize();
 
     // update what's on screen
     wxAuiTabCtrl* ctrl;
@@ -2261,6 +2528,7 @@ wxAuiTabCtrl* wxAuiNotebook::GetActiveTabCtrl()
     // If there is no tabframe at all, create one
     wxTabFrame* tabframe = new wxTabFrame;
     tabframe->SetTabCtrlHeight(m_tabCtrlHeight);
+    tabframe->SetTabCtrlWidth(m_tabCtrlWidth);
     tabframe->m_tabs = new wxAuiTabCtrl(this,
                                         m_tabIdCounter++,
                                         wxDefaultPosition,
@@ -2344,6 +2612,7 @@ void wxAuiNotebook::Split(size_t page, int direction)
     wxTabFrame* new_tabs = new wxTabFrame;
     new_tabs->m_rect = wxRect(wxPoint(0,0), split_size);
     new_tabs->SetTabCtrlHeight(m_tabCtrlHeight);
+    new_tabs->SetTabCtrlWidth(m_tabCtrlWidth);
     new_tabs->m_tabs = new wxAuiTabCtrl(this,
                                         m_tabIdCounter++,
                                         wxDefaultPosition,
@@ -2742,6 +3011,7 @@ void wxAuiNotebook::OnTabEndDrag(wxAuiNotebookEvent& evt)
             wxTabFrame* new_tabs = new wxTabFrame;
             new_tabs->m_rect = wxRect(wxPoint(0,0), CalculateNewSplitSize());
             new_tabs->SetTabCtrlHeight(m_tabCtrlHeight);
+            new_tabs->SetTabCtrlWidth(m_tabCtrlWidth);
             new_tabs->m_tabs = new wxAuiTabCtrl(this,
                                                 m_tabIdCounter++,
                                                 wxDefaultPosition,
@@ -3179,16 +3449,32 @@ int wxAuiNotebook::GetTabCtrlHeight() const
     return m_tabCtrlHeight;
 }
 
+// Gets the tab control width
+int wxAuiNotebook::GetTabCtrlWidth() const
+{
+    return m_tabCtrlWidth;
+}
+
 // Gets the height of the notebook for a given page height
 int wxAuiNotebook::GetHeightForPageHeight(int pageHeight)
 {
-    UpdateTabCtrlHeight();
+    UpdateTabCtrlSize();
 
     int tabCtrlHeight = GetTabCtrlHeight();
     int decorHeight = 2;
     return tabCtrlHeight + pageHeight + decorHeight;
 }
 
+// Gets the width of the notebook for a given page width
+int wxAuiNotebook::GetWidthForPageWidth(int pageWidth)
+{
+    UpdateTabCtrlSize();
+
+    int tabCtrlWidth = GetTabCtrlWidth();
+    int decorWidth = 2;
+    return tabCtrlWidth + pageWidth + decorWidth;
+}
+
 // Advances the selection, generation page selection events
 void wxAuiNotebook::AdvanceSelection(bool forward)
 {
Index: src/aui/tabart.cpp
===================================================================
--- src/aui/tabart.cpp
+++ src/aui/tabart.cpp
@@ -2,10 +2,12 @@
 // Name:        src/aui/tabart.cpp
 // Purpose:     wxaui: wx advanced user interface - notebook-art
 // Author:      Benjamin I. Williams
-// Modified by: Jens Lody (moved from auibook.cpp in extra file)
+// Modified by: Jens Lody
 // Created:     2012-03-21
-// RCS-ID:      $Id:$
+// RCS-ID:      $Id$
 // Copyright:   (C) Copyright 2006, Kirix Corporation, All Rights Reserved
+//                            2012, Jens Lody for the code related to left
+//                                  and right positioning
 // Licence:     wxWindows Library Licence, Version 3.1
 ///////////////////////////////////////////////////////////////////////////////
 
@@ -134,6 +136,16 @@ static const unsigned char left_bits[] = {
    0x1f, 0xfe, 0x0f, 0xfe, 0x1f, 0xfe, 0x3f, 0xfe, 0x7f, 0xfe, 0xff, 0xfe,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
 
+static const unsigned char up_bits[] = {
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xfc,
+   0x3f, 0xf8, 0x1f, 0xf0, 0x0f, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+
+static const unsigned char down_bits[] = {
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x07, 0xf0, 0x0f, 0xf8, 0x1f, 0xfc, 0x3f, 0xfe, 0x7f, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+
 static const unsigned char right_bits[] = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0x9f, 0xff, 0x1f, 0xff,
    0x1f, 0xfe, 0x1f, 0xfc, 0x1f, 0xfe, 0x1f, 0xff, 0x9f, 0xff, 0xdf, 0xff,
@@ -145,10 +157,6 @@ static const unsigned char list_bits[] = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
 
 
-
-
-
-
 // -- wxAuiGenericTabArt class implementation --
 
 wxAuiGenericTabArt::wxAuiGenericTabArt()
@@ -158,7 +166,7 @@ wxAuiGenericTabArt::wxAuiGenericTabArt()
     m_selectedFont.SetWeight(wxBOLD);
     m_measuringFont = m_selectedFont;
 
-    m_fixedTabWidth = 100;
+    m_fixedTabSize = 20;
     m_tabCtrlHeight = 0;
 
 #if defined( __WXMAC__ ) && wxOSX_USE_COCOA_OR_CARBON
@@ -190,6 +198,12 @@ wxAuiGenericTabArt::wxAuiGenericTabArt()
     m_activeLeftBmp = wxAuiBitmapFromBits(left_bits, 16, 16, *wxBLACK);
     m_disabledLeftBmp = wxAuiBitmapFromBits(left_bits, 16, 16, wxColour(128,128,128));
 
+    m_activeUpBmp = wxAuiBitmapFromBits(up_bits, 16, 16, *wxBLACK);
+    m_disabledUpBmp = wxAuiBitmapFromBits(up_bits, 16, 16, wxColour(128,128,128));
+
+    m_activeDownBmp = wxAuiBitmapFromBits(down_bits, 16, 16, *wxBLACK);
+    m_disabledDownBmp = wxAuiBitmapFromBits(down_bits, 16, 16, wxColour(128,128,128));
+
     m_activeRightBmp = wxAuiBitmapFromBits(right_bits, 16, 16, *wxBLACK);
     m_disabledRightBmp = wxAuiBitmapFromBits(right_bits, 16, 16, wxColour(128,128,128));
 
@@ -216,31 +230,61 @@ void wxAuiGenericTabArt::SetFlags(unsigned int flags)
 void wxAuiGenericTabArt::SetSizingInfo(const wxSize& tab_ctrl_size,
                                        size_t tab_count)
 {
-    m_fixedTabWidth = 100;
+    if (IsLayoutVertically())
+    {
+        m_fixedTabSize = 20;
 
-    int tot_width = (int)tab_ctrl_size.x - GetIndentSize() - 4;
+        int tot_height = (int)tab_ctrl_size.y - GetIndentSize() - 4;
 
-    if (m_flags & wxAUI_NB_CLOSE_BUTTON)
-        tot_width -= m_activeCloseBmp.GetWidth();
-    if (m_flags & wxAUI_NB_WINDOWLIST_BUTTON)
-        tot_width -= m_activeWindowListBmp.GetWidth();
+        if (m_flags & wxAUI_NB_CLOSE_BUTTON)
+            tot_height -= m_activeCloseBmp.GetHeight();
+        if (m_flags & wxAUI_NB_WINDOWLIST_BUTTON)
+            tot_height -= m_activeWindowListBmp.GetHeight();
 
-    if (tab_count > 0)
-    {
-        m_fixedTabWidth = tot_width/(int)tab_count;
+        if (tab_count > 0)
+        {
+            m_fixedTabSize = tot_height/(int)tab_count;
+        }
+
+
+        if (m_fixedTabSize < 20)
+            m_fixedTabSize = 20;
+
+        if (m_fixedTabSize > tot_height/2)
+            m_fixedTabSize = tot_height/2;
+
+        if (m_fixedTabSize > 60)
+            m_fixedTabSize = 60;
+
+        m_tabCtrlWidth = tab_ctrl_size.x;
     }
+    else // must be wxAUI_NB_TOP or wxAUI_NB_BOTTOM
+    {
+        m_fixedTabSize = 100;
 
+        int tot_width = (int)tab_ctrl_size.x - GetIndentSize() - 4;
 
-    if (m_fixedTabWidth < 100)
-        m_fixedTabWidth = 100;
+        if (m_flags & wxAUI_NB_CLOSE_BUTTON)
+            tot_width -= m_activeCloseBmp.GetWidth();
+        if (m_flags & wxAUI_NB_WINDOWLIST_BUTTON)
+            tot_width -= m_activeWindowListBmp.GetWidth();
 
-    if (m_fixedTabWidth > tot_width/2)
-        m_fixedTabWidth = tot_width/2;
+        if (tab_count > 0)
+        {
+                m_fixedTabSize = tot_width/(int)tab_count;
+        }
+
+        if (m_fixedTabSize < 100)
+            m_fixedTabSize = 100;
 
-    if (m_fixedTabWidth > 220)
-        m_fixedTabWidth = 220;
+        if (m_fixedTabSize > tot_width/2)
+            m_fixedTabSize = tot_width/2;
+
+        if (m_fixedTabSize > 220)
+            m_fixedTabSize = 220;
 
     m_tabCtrlHeight = tab_ctrl_size.y;
+    }
 }
 
 
@@ -250,38 +294,47 @@ void wxAuiGenericTabArt::DrawBackground(wxDC& dc,
 {
     // draw background
 
-    wxColor top_color       = m_baseColour.ChangeLightness(90);
+    wxColor top_color      = m_baseColour.ChangeLightness(90);
     wxColor bottom_color   = m_baseColour.ChangeLightness(170);
-    wxRect r;
-
-   if (m_flags &wxAUI_NB_BOTTOM)
-       r = wxRect(rect.x, rect.y, rect.width+2, rect.height);
-   // TODO: else if (m_flags &wxAUI_NB_LEFT) {}
-   // TODO: else if (m_flags &wxAUI_NB_RIGHT) {}
-   else //for wxAUI_NB_TOP
-       r = wxRect(rect.x, rect.y, rect.width+2, rect.height-3);
+    wxRect bg_rect, base_rect;
 
-    dc.GradientFillLinear(r, top_color, bottom_color, wxSOUTH);
+    wxDirection d;
+    if (!IsTopAligned())
+        bg_rect = wxRect(rect.x, rect.y, rect.width+2, rect.height);
+    else //for wxAUI_NB_TOP
+        bg_rect = wxRect(rect.x, rect.y, rect.width+2, rect.height-3);
 
 
    // draw base lines
 
-   dc.SetPen(m_borderPen);
    int y = rect.GetHeight();
    int w = rect.GetWidth();
 
-   if (m_flags &wxAUI_NB_BOTTOM)
-   {
-       dc.SetBrush(wxBrush(bottom_color));
-       dc.DrawRectangle(-1, 0, w+2, 4);
-   }
-   // TODO: else if (m_flags &wxAUI_NB_LEFT) {}
-   // TODO: else if (m_flags &wxAUI_NB_RIGHT) {}
-   else //for wxAUI_NB_TOP
-   {
-       dc.SetBrush(m_baseColourBrush);
-       dc.DrawRectangle(-1, y-4, w+2, 4);
-   }
+    if (IsBottomAligned())
+    {
+        base_rect = wxRect(-1, 0, w + 2, 4);
+        d = wxNORTH;
+    }
+    else if (IsLeftAligned())
+    {
+        base_rect = wxRect(w - 5, -1, w, y + 2);
+        d = wxEAST;
+    }
+    else if (IsRightAligned())
+    {
+        base_rect = wxRect(0, -1, 5, y + 2);
+        d = wxWEST;
+    }
+    else //for wxAUI_NB_TOP
+    {
+        base_rect = wxRect (-1, y - 4, w + 2, 4);
+        d = wxSOUTH;
+    }
+
+    dc.SetPen(m_borderPen);
+    dc.SetBrush(m_baseColourBrush);
+    dc.GradientFillLinear(bg_rect, top_color, bottom_color,d);
+    dc.DrawRectangle(base_rect);
 }
 
 
@@ -327,15 +380,32 @@ void wxAuiGenericTabArt::DrawTab(wxDC& dc,
                                  close_button_state,
                                  x_extent);
 
-    wxCoord tab_height = m_tabCtrlHeight - 3;
+    wxCoord tab_height = tab_size.y + 1;
     wxCoord tab_width = tab_size.x;
     wxCoord tab_x = in_rect.x;
     wxCoord tab_y = in_rect.y + in_rect.height - tab_height;
 
+    if (IsLeftAligned())
+    {
+        tab_height += 1;
+        tab_width = in_rect.width - 5;
+        tab_y = in_rect.y - 1;
+    }
+    if (IsRightAligned())
+    {
+        tab_height += 1;
+        tab_width = in_rect.width - 5;
+        tab_y = in_rect.y - 1;
+        tab_x += 4;
+    }
+    if (! page.bitmap.IsOk())
+    {
+        tab_height += 1;
+        tab_y -= 1;
+    }
 
     caption = page.caption;
 
-
     // select pen, brush and font for the tab to be drawn
 
     if (page.active)
@@ -349,36 +419,24 @@ void wxAuiGenericTabArt::DrawTab(wxDC& dc,
         texty = normal_texty;
     }
 
-
     // create points that will make the tab outline
 
     int clip_width = tab_width;
+    int clip_height = tab_height;
+
     if (tab_x + clip_width > in_rect.x + in_rect.width)
         clip_width = (in_rect.x + in_rect.width) - tab_x;
+    if (tab_y + tab_height > in_rect.y + in_rect.height)
+        clip_height = (in_rect.y + in_rect.height) - tab_y;
 
-/*
-    wxPoint clip_points[6];
-    clip_points[0] = wxPoint(tab_x,              tab_y+tab_height-3);
-    clip_points[1] = wxPoint(tab_x,              tab_y+2);
-    clip_points[2] = wxPoint(tab_x+2,            tab_y);
-    clip_points[3] = wxPoint(tab_x+clip_width-1, tab_y);
-    clip_points[4] = wxPoint(tab_x+clip_width+1, tab_y+2);
-    clip_points[5] = wxPoint(tab_x+clip_width+1, tab_y+tab_height-3);
-
-    // FIXME: these ports don't provide wxRegion ctor from array of points
-#if !defined(__WXDFB__) && !defined(__WXCOCOA__)
-    // set the clipping region for the tab --
-    wxRegion clipping_region(WXSIZEOF(clip_points), clip_points);
-    dc.SetClippingRegion(clipping_region);
-#endif // !wxDFB && !wxCocoa
-*/
     // since the above code above doesn't play well with WXDFB or WXCOCOA,
     // we'll just use a rectangle for the clipping region for now --
-    dc.SetClippingRegion(tab_x, tab_y, clip_width+1, tab_height-3);
+    dc.SetClippingRegion(tab_x, tab_y, clip_width+1, clip_height+1);
 
+    wxDirection d;
 
     wxPoint border_points[6];
-    if (m_flags &wxAUI_NB_BOTTOM)
+    if (IsBottomAligned())
     {
         border_points[0] = wxPoint(tab_x,             tab_y);
         border_points[1] = wxPoint(tab_x,             tab_y+tab_height-6);
@@ -386,8 +444,29 @@ void wxAuiGenericTabArt::DrawTab(wxDC& dc,
         border_points[3] = wxPoint(tab_x+tab_width-2, tab_y+tab_height-4);
         border_points[4] = wxPoint(tab_x+tab_width,   tab_y+tab_height-6);
         border_points[5] = wxPoint(tab_x+tab_width,   tab_y);
+        d = wxNORTH;
     }
-    else //if (m_flags & wxAUI_NB_TOP) {}
+    else  if (IsLeftAligned())
+    {
+        border_points[0] = wxPoint(tab_x+tab_width, tab_y);
+        border_points[1] = wxPoint(tab_x+2,         tab_y);
+        border_points[2] = wxPoint(tab_x,           tab_y+2);
+        border_points[3] = wxPoint(tab_x,           tab_y+tab_height-2);
+        border_points[4] = wxPoint(tab_x+2,         tab_y+tab_height);
+        border_points[5] = wxPoint(tab_x+tab_width, tab_y+tab_height);
+        d = wxEAST;
+    }
+    else  if (IsRightAligned())
+    {
+        border_points[0] = wxPoint(tab_x,             tab_y);
+        border_points[1] = wxPoint(tab_x+tab_width-2, tab_y);
+        border_points[2] = wxPoint(tab_x+tab_width,   tab_y+2);
+        border_points[3] = wxPoint(tab_x+tab_width,   tab_y+tab_height-2);
+        border_points[4] = wxPoint(tab_x+tab_width-2, tab_y+tab_height);
+        border_points[5] = wxPoint(tab_x,             tab_y+tab_height);
+        d = wxWEST;
+    }
+    else // must be wxAUI_NB_TOP) {}
     {
         border_points[0] = wxPoint(tab_x,             tab_y+tab_height-4);
         border_points[1] = wxPoint(tab_x,             tab_y+2);
@@ -395,13 +474,17 @@ void wxAuiGenericTabArt::DrawTab(wxDC& dc,
         border_points[3] = wxPoint(tab_x+tab_width-2, tab_y);
         border_points[4] = wxPoint(tab_x+tab_width,   tab_y+2);
         border_points[5] = wxPoint(tab_x+tab_width,   tab_y+tab_height-4);
+        d = wxSOUTH;
     }
-    // TODO: else if (m_flags &wxAUI_NB_LEFT) {}
-    // TODO: else if (m_flags &wxAUI_NB_RIGHT) {}
 
     int drawn_tab_yoff = border_points[1].y;
     int drawn_tab_height = border_points[0].y - border_points[1].y;
 
+    if (IsLayoutVertically())
+    {
+        drawn_tab_height = border_points[3].y - border_points[2].y;
+        drawn_tab_yoff = border_points[2].y;
+    }
 
     if (page.active)
     {
@@ -411,78 +494,177 @@ void wxAuiGenericTabArt::DrawTab(wxDC& dc,
         wxRect r(tab_x, tab_y, tab_width, tab_height);
         dc.SetPen(wxPen(m_activeColour));
         dc.SetBrush(wxBrush(m_activeColour));
-        dc.DrawRectangle(r.x+1, r.y+1, r.width-1, r.height-4);
+
+        if (IsRightAligned())
+            dc.DrawRectangle(r.x, r.y+1, r.width, r.height-1);
+        else if (IsLeftAligned())
+            dc.DrawRectangle(r.x+1, r.y+1, r.width, r.height-1);
+        else // must be wxAUI_NB_TOP or wxAUI_NB_BOTTOM
+            dc.DrawRectangle(r.x+1, r.y+1, r.width-1, r.height-4);
 
         // this white helps fill out the gradient at the top of the tab
         dc.SetPen(*wxWHITE_PEN);
         dc.SetBrush(*wxWHITE_BRUSH);
-        dc.DrawRectangle(r.x+2, r.y+1, r.width-3, r.height-4);
+        if (IsRightAligned())
+            dc.DrawRectangle(r.x+1, r.y+1, r.width-2, r.height-1);
+        else if (IsLeftAligned())
+            dc.DrawRectangle(r.x+2, r.y+1, r.width-2, r.height-1);
+        else // must be wxAUI_NB_TOP or wxAUI_NB_BOTTOM
+            dc.DrawRectangle(r.x+2, r.y+1, r.width-3, r.height-4);
 
         // these two points help the rounded corners appear more antialiased
         dc.SetPen(wxPen(m_activeColour));
-        dc.DrawPoint(r.x+2, r.y+1);
-        dc.DrawPoint(r.x+r.width-2, r.y+1);
+        if (IsRightAligned())
+        {
+            dc.DrawPoint(r.x+r.width-2, r.y+1);
+            dc.DrawPoint(r.x+r.width-2, r.y+r.height-1);
+        }
+        else if (IsLeftAligned())
+        {
+            dc.DrawPoint(r.x+2, r.y+1);
+            dc.DrawPoint(r.x+2, r.y+r.height-1);
+        }
+        else if (IsBottomAligned())
+        {
+            dc.DrawPoint(r.x+2, r.y+r.height-5);
+            dc.DrawPoint(r.x+r.width-2, r.y+r.height-5);
+        }
+        else // must be wxAUI_NB_TOP
+        {
+            dc.DrawPoint(r.x+2, r.y+1);
+            dc.DrawPoint(r.x+r.width-2, r.y+1);
+        }
 
-        // set rectangle down a bit for gradient drawing
-        r.SetHeight(r.GetHeight()/2);
-        r.x += 2;
-        r.width -= 3;
-        r.y += r.height;
-        r.y -= 2;
+
+        if (IsRightAligned())
+        {
+            // set rectangle down a bit for gradient drawing
+            r.SetWidth(r.GetWidth()/2);
+            r.y += 1;
+            r.height -= 1;
+        }
+        else if (IsLeftAligned())
+        {
+            // set rectangle down a bit for gradient drawing
+            r.SetWidth(r.GetWidth()/2);
+            r.y += 1;
+            r.height -= 1;
+            r.x += r.width;
+        }
+        else if (IsBottomAligned())
+        {
+            // set rectangle down a bit for gradient drawing
+            r.SetHeight(r.GetHeight()/2);
+            r.x += 2;
+            r.width -= 3;
+        }
+        else // must be wxAUI_NB_TOP
+        {
+            // set rectangle down a bit for gradient drawing
+            r.SetHeight(r.GetHeight()/2);
+            r.x += 2;
+            r.width -= 3;
+            r.y += (r.height - 2);
+        }
 
         // draw gradient background
         wxColor top_color = *wxWHITE;
         wxColor bottom_color = m_activeColour;
-        dc.GradientFillLinear(r, bottom_color, top_color, wxNORTH);
+        dc.GradientFillLinear(r, top_color, bottom_color, d);
     }
     else
     {
         // draw inactive tab
 
-        wxRect r(tab_x, tab_y+1, tab_width, tab_height-3);
+        wxRect r_top(tab_x, tab_y+1, tab_width, tab_height-3);
+        wxRect r_base;
+
 
         // start the gradent up a bit and leave the inside border inset
         // by a pixel for a 3D look.  Only the top half of the inactive
         // tab will have a slight gradient
-        r.x += 3;
-        r.y++;
-        r.width -= 4;
-        r.height /= 2;
-        r.height--;
+        if (IsLayoutVertically())
+        {
+            r_top.x += 2;
+            r_top.y++;
+            r_top.width -= 2;
+            r_top.height += 3;
+            r_top.width /= 2;
+            
+            r_base = r_top;
+            
+            if (IsRightAligned())
+            {
+                r_top.x += r_top.width;
+                r_top.x--;
+            }
+            else // must be wxAUI_NB_LEFT
+            {
+                r_base.x += r_base.width;
+                r_base.x--;
+            }
+        }
+        else // must be wxAUI_NB_TOP or wxAUI_NB_BOTTOM
+        {
+            r_top.x += 3;
+            r_top.y++;
+            r_top.width -= 4;
+            r_top.height /= 2;
+            r_top.height--;
+            
+            r_base = r_top;
+            
+            if (IsBottomAligned())
+            {
+                r_top.y += r_top.height;
+                r_top.y--;
+            }
+            else // must be wxAUI_NB_TOP
+            {
+                r_base.y += r_base.height;
+                r_base.y--;
+            }
+        }
+
 
         // -- draw top gradient fill for glossy look
         wxColor top_color = m_baseColour;
         wxColor bottom_color = top_color.ChangeLightness(160);
-        dc.GradientFillLinear(r, bottom_color, top_color, wxNORTH);
+        dc.GradientFillLinear(r_top, bottom_color, top_color, d);
 
-        r.y += r.height;
-        r.y--;
 
         // -- draw bottom fill for glossy look
         top_color = m_baseColour;
         bottom_color = m_baseColour;
-        dc.GradientFillLinear(r, top_color, bottom_color, wxSOUTH);
+        dc.GradientFillLinear(r_base, top_color, bottom_color, d);
     }
 
     // draw tab outline
     dc.SetPen(m_borderPen);
     dc.SetBrush(*wxTRANSPARENT_BRUSH);
+
     dc.DrawPolygon(WXSIZEOF(border_points), border_points);
 
     // there are two horizontal grey lines at the bottom of the tab control,
     // this gets rid of the top one of those lines in the tab control
     if (page.active)
     {
-        if (m_flags &wxAUI_NB_BOTTOM)
-            dc.SetPen(wxPen(m_baseColour.ChangeLightness(170)));
-        // TODO: else if (m_flags &wxAUI_NB_LEFT) {}
-        // TODO: else if (m_flags &wxAUI_NB_RIGHT) {}
-        else //for wxAUI_NB_TOP
             dc.SetPen(m_baseColourPen);
-        dc.DrawLine(border_points[0].x+1,
-                    border_points[0].y,
-                    border_points[5].x,
-                    border_points[5].y);
+
+        if (IsLayoutVertically())
+        {
+            dc.DrawLine(border_points[0].x,
+                        border_points[0].y+1,
+                        border_points[5].x,
+                        border_points[5].y);
+        }
+        else // must be wxAUI_NB_TOP or wxAUI_NB_BOTTOM
+        {
+            dc.DrawLine(border_points[0].x+1,
+                        border_points[0].y,
+                        border_points[5].x,
+                        border_points[5].y);
+        }
     }
 
 
@@ -494,6 +676,7 @@ void wxAuiGenericTabArt::DrawTab(wxDC& dc,
     }
 
     int bitmap_offset = 0;
+    
     if (page.bitmap.IsOk())
     {
         bitmap_offset = tab_x + 8;
@@ -509,9 +692,7 @@ void wxAuiGenericTabArt::DrawTab(wxDC& dc,
 
     }
     else
-    {
         text_offset = tab_x + 8;
-    }
 
 
     wxString draw_text = wxAuiChopText(dc,
@@ -560,7 +741,7 @@ void wxAuiGenericTabArt::DrawTab(wxDC& dc,
         }
 
         int offsetY = tab_y-1;
-        if (m_flags & wxAUI_NB_BOTTOM)
+        if (IsBottomAligned())
             offsetY = 1;
 
         wxRect rect(tab_x + tab_width - close_button_width - 1,
@@ -574,7 +755,7 @@ void wxAuiGenericTabArt::DrawTab(wxDC& dc,
         *out_button_rect = rect;
     }
 
-    *out_tab_rect = wxRect(tab_x, tab_y, tab_width, tab_height);
+    *out_tab_rect = wxRect(tab_x, tab_y, clip_width+1, clip_height+1);
 
     dc.DestroyClippingRegion();
 }
@@ -590,7 +771,7 @@ wxSize wxAuiGenericTabArt::GetTabSize(wxDC& dc,
                                       const wxBitmap& bitmap,
                                       bool WXUNUSED(active),
                                       int close_button_state,
-                                      int* x_extent)
+                                      int* extent)
 {
     wxCoord measured_textx, measured_texty, tmp;
 
@@ -603,9 +784,16 @@ wxSize wxAuiGenericTabArt::GetTabSize(wxDC& dc,
     wxCoord tab_width = measured_textx;
     wxCoord tab_height = measured_texty;
 
-    // if the close button is showing, add space for it
-    if (close_button_state != wxAUI_BUTTON_STATE_HIDDEN)
-        tab_width += m_activeCloseBmp.GetWidth() + 3;
+    // if the close button is showing or the tab-position is left or right,
+    //  add space for it
+    if ((close_button_state != wxAUI_BUTTON_STATE_HIDDEN) ||
+        (IsLayoutVertically() &&
+         !(m_flags & wxAUI_NB_CLOSE_BUTTON)))
+     {
+        tab_width += m_activeCloseBmp.GetWidth();
+        tab_width += 3;
+        tab_height = wxMax(tab_height, m_activeCloseBmp.GetHeight());
+     }
 
     // if there's a bitmap, add space for it
     if (bitmap.IsOk())
@@ -619,19 +807,25 @@ wxSize wxAuiGenericTabArt::GetTabSize(wxDC& dc,
     tab_width += 16;
     tab_height += 10;
 
-    if (m_flags & wxAUI_NB_TAB_FIXED_WIDTH)
+    if (IsLayoutVertically())
     {
-        tab_width = m_fixedTabWidth;
+        if (m_flags & wxAUI_NB_TAB_FIXED_HEIGHT)
+            tab_height = m_fixedTabSize;
+        *extent = tab_height;
+    }
+    else // must be wxAUI_NB_TOP or wxAUI_NB_BOTTOM
+    {
+        if (m_flags & wxAUI_NB_TAB_FIXED_WIDTH)
+            tab_width = m_fixedTabSize;
+        *extent = tab_width;
     }
-
-    *x_extent = tab_width;
 
     return wxSize(tab_width, tab_height);
 }
 
 
 void wxAuiGenericTabArt::DrawButton(wxDC& dc,
-                                    wxWindow* WXUNUSED(wnd),
+                                    wxWindow* wnd,
                                     const wxRect& in_rect,
                                     int bitmap_id,
                                     int button_state,
@@ -639,7 +833,8 @@ void wxAuiGenericTabArt::DrawButton(wxDC& dc,
                                     wxRect* out_rect)
 {
     wxBitmap bmp;
-    wxRect rect;
+    wxRect rect = in_rect;
+
 
     switch (bitmap_id)
     {
@@ -648,6 +843,7 @@ void wxAuiGenericTabArt::DrawButton(wxDC& dc,
                 bmp = m_disabledCloseBmp;
             else
                 bmp = m_activeCloseBmp;
+            rect.SetX(in_rect.x + in_rect.width - bmp.GetWidth());
             break;
         case wxAUI_BUTTON_LEFT:
             if (button_state & wxAUI_BUTTON_STATE_DISABLED)
@@ -655,6 +851,20 @@ void wxAuiGenericTabArt::DrawButton(wxDC& dc,
             else
                 bmp = m_activeLeftBmp;
             break;
+        case wxAUI_BUTTON_UP:
+            if (button_state & wxAUI_BUTTON_STATE_DISABLED)
+                bmp = m_disabledUpBmp;
+            else
+                bmp = m_activeUpBmp;
+            rect.width = wnd->GetRect().GetWidth();
+            rect.SetX(((rect.x + rect.width)/2) - (bmp.GetWidth()/2));
+            break;
+        case wxAUI_BUTTON_DOWN:
+            if (button_state & wxAUI_BUTTON_STATE_DISABLED)
+                bmp = m_disabledDownBmp;
+            else
+                bmp = m_activeDownBmp;
+            break;
         case wxAUI_BUTTON_RIGHT:
             if (button_state & wxAUI_BUTTON_STATE_DISABLED)
                 bmp = m_disabledRightBmp;
@@ -666,6 +876,7 @@ void wxAuiGenericTabArt::DrawButton(wxDC& dc,
                 bmp = m_disabledWindowListBmp;
             else
                 bmp = m_activeWindowListBmp;
+            rect.SetX(in_rect.x + in_rect.width - bmp.GetWidth());
             break;
     }
 
@@ -673,8 +884,6 @@ void wxAuiGenericTabArt::DrawButton(wxDC& dc,
     if (!bmp.IsOk())
         return;
 
-    rect = in_rect;
-
     if (orientation == wxLEFT)
     {
         rect.SetX(in_rect.x);
@@ -682,7 +891,20 @@ void wxAuiGenericTabArt::DrawButton(wxDC& dc,
         rect.SetWidth(bmp.GetWidth());
         rect.SetHeight(bmp.GetHeight());
     }
-    else
+    else if (orientation == wxUP)
+    {
+        rect.SetY(in_rect.y);
+        rect.SetWidth(bmp.GetWidth());
+        rect.SetHeight(bmp.GetHeight());
+    }
+    else if (orientation == wxDOWN)
+    {
+        rect.SetX(((in_rect.x + in_rect.width)/2) - (bmp.GetWidth()/2));
+        rect.SetY(in_rect.y  + in_rect.height - bmp.GetHeight() - bmp.GetHeight() / 2);
+        rect.SetWidth(bmp.GetWidth());
+        rect.SetHeight(bmp.GetHeight());
+    }
+    else if (orientation == wxRIGHT)
     {
         rect = wxRect(in_rect.x + in_rect.width - bmp.GetWidth(),
                       ((in_rect.y + in_rect.height)/2) - (bmp.GetHeight()/2),
@@ -724,11 +946,16 @@ int wxAuiGenericTabArt::ShowDropDown(wxWindow* wnd,
 
     // find out the screen coordinate at the bottom of the tab ctrl
     wxRect cli_rect = wnd->GetClientRect();
+
+    if (IsLayoutVertically())
+        pt.x = cli_rect.x + cli_rect.width;
+    else // must be wxAUI_NB_TOP or wxAUI_NB_BOTTOM
     pt.y = cli_rect.y + cli_rect.height;
 
     wxAuiCommandCapture* cc = new wxAuiCommandCapture;
     wnd->PushEventHandler(cc);
     wnd->PopupMenu(&menuPopup, pt);
+//    wnd->PopupMenu(&menuPopup);
     int command = cc->GetCommandId();
     wnd->PopEventHandler(true);
 
@@ -738,7 +965,7 @@ int wxAuiGenericTabArt::ShowDropDown(wxWindow* wnd,
     return -1;
 }
 
-int wxAuiGenericTabArt::GetBestTabCtrlSize(wxWindow* wnd,
+wxSize wxAuiGenericTabArt::GetBestTabSize(wxWindow* wnd,
                                            const wxAuiNotebookPageArray& pages,
                                            const wxSize& requiredBmp_size)
 {
@@ -756,7 +983,7 @@ int wxAuiGenericTabArt::GetBestTabCtrlSize(wxWindow* wnd,
     }
 
 
-    int max_y = 0;
+    wxSize max_size;
     size_t i, page_count = pages.GetCount();
     for (i = 0; i < page_count; ++i)
     {
@@ -768,23 +995,22 @@ int wxAuiGenericTabArt::GetBestTabCtrlSize(wxWindow* wnd,
         else
             bmp = page.bitmap;
 
-        // we don't use the caption text because we don't
-        // want tab heights to be different in the case
-        // of a very short piece of text on one tab and a very
-        // tall piece of text on another tab
-        int x_ext = 0;
+        int ext = 0;
         wxSize s = GetTabSize(dc,
                               wnd,
-                              wxT("ABCDEFGHIj"),
+                              page.caption,
                               bmp,
                               true,
                               wxAUI_BUTTON_STATE_HIDDEN,
-                              &x_ext);
+                              &ext);
 
-        max_y = wxMax(max_y, s.y);
+        max_size.x = wxMax(max_size.x, s.x);
+        max_size.y = wxMax(max_size.y, s.y);
     }
 
-    return max_y+2;
+    max_size.IncBy(2, 2);
+
+    return max_size;
 }
 
 void wxAuiGenericTabArt::SetNormalFont(const wxFont& font)
@@ -825,7 +1051,8 @@ wxAuiSimpleTabArt::wxAuiSimpleTabArt()
     m_measuringFont = m_selectedFont;
 
     m_flags = 0;
-    m_fixedTabWidth = 100;
+
+    m_fixedTabSize = 20;
 
     wxColour baseColour = wxSystemSettings::GetColour(wxSYS_COLOUR_3DFACE);
 
@@ -845,6 +1072,12 @@ wxAuiSimpleTabArt::wxAuiSimpleTabArt()
     m_activeLeftBmp = wxAuiBitmapFromBits(left_bits, 16, 16, *wxBLACK);
     m_disabledLeftBmp = wxAuiBitmapFromBits(left_bits, 16, 16, wxColour(128,128,128));
 
+    m_activeUpBmp = wxAuiBitmapFromBits(up_bits, 16, 16, *wxBLACK);
+    m_disabledUpBmp = wxAuiBitmapFromBits(up_bits, 16, 16, wxColour(128,128,128));
+
+    m_activeDownBmp = wxAuiBitmapFromBits(down_bits, 16, 16, *wxBLACK);
+    m_disabledDownBmp = wxAuiBitmapFromBits(down_bits, 16, 16, wxColour(128,128,128));
+
     m_activeRightBmp = wxAuiBitmapFromBits(right_bits, 16, 16, *wxBLACK);
     m_disabledRightBmp = wxAuiBitmapFromBits(right_bits, 16, 16, wxColour(128,128,128));
 
@@ -870,29 +1103,60 @@ void wxAuiSimpleTabArt::SetFlags(unsigned int flags)
 void wxAuiSimpleTabArt::SetSizingInfo(const wxSize& tab_ctrl_size,
                                       size_t tab_count)
 {
-    m_fixedTabWidth = 100;
+    if (IsLayoutVertically())
+    {
+        m_fixedTabSize = 20;
 
-    int tot_width = (int)tab_ctrl_size.x - GetIndentSize() - 4;
+        int tot_height = (int)tab_ctrl_size.y - GetIndentSize() - 4;
 
-    if (m_flags & wxAUI_NB_CLOSE_BUTTON)
-        tot_width -= m_activeCloseBmp.GetWidth();
-    if (m_flags & wxAUI_NB_WINDOWLIST_BUTTON)
-        tot_width -= m_activeWindowListBmp.GetWidth();
+        if (m_flags & wxAUI_NB_CLOSE_BUTTON)
+            tot_height -= m_activeCloseBmp.GetHeight();
+        if (m_flags & wxAUI_NB_WINDOWLIST_BUTTON)
+            tot_height -= m_activeWindowListBmp.GetHeight();
+
+        if (tab_count > 0)
+        {
+            m_fixedTabSize = tot_height/(int)tab_count;
+        }
+
+
+        if (m_fixedTabSize < 20)
+            m_fixedTabSize = 20;
+
+        if (m_fixedTabSize > tot_height/2)
+            m_fixedTabSize = tot_height/2;
+
+        if (m_fixedTabSize > 60)
+            m_fixedTabSize = 60;
 
-    if (tab_count > 0)
-    {
-        m_fixedTabWidth = tot_width/(int)tab_count;
     }
+    else // must be wxAUI_NB_TOP or wxAUI_NB_BOTTOM
+    {
+        m_fixedTabSize = 100;
 
+        int tot_width = (int)tab_ctrl_size.x - GetIndentSize() - 4;
 
-    if (m_fixedTabWidth < 100)
-        m_fixedTabWidth = 100;
+        if (m_flags & wxAUI_NB_CLOSE_BUTTON)
+            tot_width -= m_activeCloseBmp.GetWidth();
+        if (m_flags & wxAUI_NB_WINDOWLIST_BUTTON)
+            tot_width -= m_activeWindowListBmp.GetWidth();
 
-    if (m_fixedTabWidth > tot_width/2)
-        m_fixedTabWidth = tot_width/2;
+        if (tab_count > 0)
+        {
+                m_fixedTabSize = tot_width/(int)tab_count;
+        }
 
-    if (m_fixedTabWidth > 220)
-        m_fixedTabWidth = 220;
+
+        if (m_fixedTabSize < 100)
+            m_fixedTabSize = 100;
+
+        if (m_fixedTabSize > tot_width/2)
+            m_fixedTabSize = tot_width/2;
+
+        if (m_fixedTabSize > 220)
+            m_fixedTabSize = 220;
+
+    }
 }
 
 void wxAuiSimpleTabArt::SetColour(const wxColour& colour)
@@ -919,7 +1183,22 @@ void wxAuiSimpleTabArt::DrawBackground(wxDC& dc,
 
     // draw base line
     dc.SetPen(*wxGREY_PEN);
+    if (IsLeftAligned())
+    {
+        dc.DrawLine(rect.GetWidth(), 0, rect.GetWidth()-1, rect.GetHeight());
+    }
+    else if (IsRightAligned())
+    {
+        dc.DrawLine(1, 0, 1, rect.GetHeight());
+    }
+    else if (IsBottomAligned())
+    {
+        dc.DrawLine(0, 1, rect.GetWidth(), 1);
+    }
+    else // must be wxAUI_NB_TOP
+    {
     dc.DrawLine(0, rect.GetHeight()-1, rect.GetWidth(), rect.GetHeight()-1);
+    }
 }
 
 
@@ -939,7 +1218,7 @@ void wxAuiSimpleTabArt::DrawTab(wxDC& dc,
                                 int close_button_state,
                                 wxRect* out_tab_rect,
                                 wxRect* out_button_rect,
-                                int* x_extent)
+                                int* extent)
 {
     wxCoord normal_textx, normal_texty;
     wxCoord selected_textx, selected_texty;
@@ -963,12 +1242,18 @@ void wxAuiSimpleTabArt::DrawTab(wxDC& dc,
                                  page.bitmap,
                                  page.active,
                                  close_button_state,
-                                 x_extent);
+                                 extent);
 
     wxCoord tab_height = tab_size.y;
     wxCoord tab_width = tab_size.x;
     wxCoord tab_x = in_rect.x;
-    wxCoord tab_y = in_rect.y + in_rect.height - tab_height;
+    wxCoord tab_y = in_rect.y + in_rect.height - tab_height - 1;
+    if (IsLayoutVertically())
+    {
+        tab_width = in_rect.width;
+        tab_y = in_rect.y - 1;
+        tab_height += 2;
+    }
 
     caption = page.caption;
 
@@ -991,31 +1276,91 @@ void wxAuiSimpleTabArt::DrawTab(wxDC& dc,
         texty = normal_texty;
     }
 
-
     // -- draw line --
-
     wxPoint points[7];
-    points[0].x = tab_x;
-    points[0].y = tab_y + tab_height - 1;
-    points[1].x = tab_x + tab_height - 3;
-    points[1].y = tab_y + 2;
-    points[2].x = tab_x + tab_height + 3;
-    points[2].y = tab_y;
-    points[3].x = tab_x + tab_width - 2;
-    points[3].y = tab_y;
-    points[4].x = tab_x + tab_width;
-    points[4].y = tab_y + 2;
-    points[5].x = tab_x + tab_width;
-    points[5].y = tab_y + tab_height - 1;
-    points[6] = points[0];
-
-    dc.SetClippingRegion(in_rect);
+
+    if (IsLeftAligned())
+    {
+        points[0].x = tab_x;
+        points[0].y = tab_y + tab_height;
+        points[1].x = tab_x;
+        points[1].y = tab_y + tab_height - 2;
+        points[2].x = tab_x + tab_height - 4;
+        points[2].y = tab_y + 2;
+        points[3].x = tab_x + tab_height + 2;
+        points[3].y = tab_y;
+        points[4].x = tab_x + tab_width - 1;
+        points[4].y = tab_y;
+        points[5].x = tab_x + tab_width - 1;
+        points[5].y = tab_y + tab_height;
+        points[6] = points[0];
+    }
+    else if (IsRightAligned())
+    {
+        points[0].x = tab_x + 1;
+        points[0].y = tab_y + tab_height;
+        points[1].x = tab_x + 1;
+        points[1].y = tab_y;
+        points[2].x = tab_x + tab_width - tab_height - 3;
+        points[2].y = tab_y;
+        points[3].x = tab_x + tab_width - tab_height + 3;
+        points[3].y = tab_y + 2;
+        points[4].x = tab_x + tab_width;
+        points[4].y = tab_y + tab_height - 2;
+        points[5].x = tab_x + tab_width;
+        points[5].y = tab_y + tab_height;
+        points[6] = points[0];
+    }
+    else if (IsBottomAligned())
+    {
+        points[0].x = tab_x;
+        points[0].y = tab_y - 1;
+        points[1].x = tab_x + tab_height - 3;
+        points[1].y = tab_y + tab_height - 4;
+        points[2].x = tab_x + tab_height + 3;
+        points[2].y = tab_y + tab_height - 2;
+        points[3].x = tab_x + tab_width - 2;
+        points[3].y = tab_y + tab_height - 2;
+        points[4].x = tab_x + tab_width;
+        points[4].y = tab_y + tab_height - 4;
+        points[5].x = tab_x + tab_width;
+        points[5].y = tab_y - 1;
+        points[6] = points[0];
+    }
+    else // must be wxAUI_NB_TOP
+    {
+        points[0].x = tab_x;
+        points[0].y = tab_y + tab_height;
+        points[1].x = tab_x + tab_height - 3;
+        points[1].y = tab_y + 2;
+        points[2].x = tab_x + tab_height + 3;
+        points[2].y = tab_y;
+        points[3].x = tab_x + tab_width - 2;
+        points[3].y = tab_y;
+        points[4].x = tab_x + tab_width;
+        points[4].y = tab_y + 2;
+        points[5].x = tab_x + tab_width;
+        points[5].y = tab_y + tab_height;
+        points[6] = points[0];
+    }
+
+    int clip_width = tab_width;
+    int clip_height = tab_height;
+
+    if (tab_x + clip_width > in_rect.x + in_rect.width)
+        clip_width = (in_rect.x + in_rect.width) - tab_x;
+    if (tab_y + tab_height > in_rect.y + in_rect.height)
+        clip_height = (in_rect.y + in_rect.height) - tab_y;
+    ++clip_width;
+    ++clip_height;
+
+    dc.SetClippingRegion(tab_x, tab_y, clip_width, clip_height);
+
 
     dc.DrawPolygon(WXSIZEOF(points) - 1, points);
 
     dc.SetPen(*wxGREY_PEN);
 
-    //dc.DrawLines(active ? WXSIZEOF(points) - 1 : WXSIZEOF(points), points);
     dc.DrawLines(WXSIZEOF(points), points);
 
 
@@ -1036,6 +1381,8 @@ void wxAuiSimpleTabArt::DrawTab(wxDC& dc,
     if (text_offset < tab_x + tab_height)
         text_offset = tab_x + tab_height;
 
+    if (IsRightAligned())
+        text_offset -= tab_height;
     // chop text if necessary
     wxString draw_text = wxAuiChopText(dc,
                           caption,
@@ -1044,13 +1391,13 @@ void wxAuiSimpleTabArt::DrawTab(wxDC& dc,
     // draw tab text
     dc.DrawText(draw_text,
                  text_offset,
-                 (tab_y + tab_height)/2 - (texty/2) + 1);
+                 tab_y + (tab_height - texty) / 2 + 1);
 
 
     // draw focus rectangle
     if (page.active && (wnd->FindFocus() == wnd))
     {
-        wxRect focusRect(text_offset, ((tab_y + tab_height)/2 - (texty/2) + 1),
+        wxRect focusRect(text_offset, (tab_y + (tab_height - texty) / 2 + 1),
             selected_textx, selected_texty);
 
         focusRect.Inflate(2, 2);
@@ -1071,6 +1418,8 @@ void wxAuiSimpleTabArt::DrawTab(wxDC& dc,
                     tab_y + (tab_height/2) - (bmp.GetHeight()/2) + 1,
                     close_button_width,
                     tab_height - 1);
+        if (IsRightAligned())
+            rect.x -= tab_height;
         DrawButtons(dc, rect, bmp, *wxWHITE, close_button_state);
 
         *out_button_rect = rect;
@@ -1093,32 +1442,42 @@ wxSize wxAuiSimpleTabArt::GetTabSize(wxDC& dc,
                                      const wxBitmap& WXUNUSED(bitmap),
                                      bool WXUNUSED(active),
                                      int close_button_state,
-                                     int* x_extent)
+                                     int* extent)
 {
-    wxCoord measured_textx, measured_texty;
+    wxCoord measured_textx, measured_texty, tmp;
 
     dc.SetFont(m_measuringFont);
     dc.GetTextExtent(caption, &measured_textx, &measured_texty);
 
+    dc.GetTextExtent(wxT("ABCDEFXj"), &tmp, &measured_texty);
+
     wxCoord tab_height = measured_texty + 4;
     wxCoord tab_width = measured_textx + tab_height + 5;
 
     if (close_button_state != wxAUI_BUTTON_STATE_HIDDEN)
         tab_width += m_activeCloseBmp.GetWidth();
 
-    if (m_flags & wxAUI_NB_TAB_FIXED_WIDTH)
+
+    if (IsLayoutVertically())
     {
-        tab_width = m_fixedTabWidth;
+        if (m_flags & wxAUI_NB_TAB_FIXED_HEIGHT)
+            tab_height = m_fixedTabSize;
+        tab_width += 16;
+        *extent = tab_height + 2;
+    }
+    else // must be wxAUI_NB_TOP or wxAUI_NB_BOTTOM
+    {
+        if (m_flags & wxAUI_NB_TAB_FIXED_WIDTH)
+            tab_width = m_fixedTabSize;
+        *extent = tab_width - (tab_height/2) - 1;
     }
-
-    *x_extent = tab_width - (tab_height/2) - 1;
 
     return wxSize(tab_width, tab_height);
 }
 
 
 void wxAuiSimpleTabArt::DrawButton(wxDC& dc,
-                                   wxWindow* WXUNUSED(wnd),
+                                   wxWindow* wnd,
                                    const wxRect& in_rect,
                                    int bitmap_id,
                                    int button_state,
@@ -1126,7 +1485,7 @@ void wxAuiSimpleTabArt::DrawButton(wxDC& dc,
                                    wxRect* out_rect)
 {
     wxBitmap bmp;
-    wxRect rect;
+    wxRect rect = in_rect;
 
     switch (bitmap_id)
     {
@@ -1135,6 +1494,7 @@ void wxAuiSimpleTabArt::DrawButton(wxDC& dc,
                 bmp = m_disabledCloseBmp;
             else
                 bmp = m_activeCloseBmp;
+            rect.SetX(in_rect.x + in_rect.width - bmp.GetWidth());
             break;
         case wxAUI_BUTTON_LEFT:
             if (button_state & wxAUI_BUTTON_STATE_DISABLED)
@@ -1142,6 +1502,20 @@ void wxAuiSimpleTabArt::DrawButton(wxDC& dc,
             else
                 bmp = m_activeLeftBmp;
             break;
+        case wxAUI_BUTTON_UP:
+            if (button_state & wxAUI_BUTTON_STATE_DISABLED)
+                bmp = m_disabledUpBmp;
+            else
+                bmp = m_activeUpBmp;
+            rect.width = wnd->GetRect().GetWidth();
+            rect.SetX(((rect.x + rect.width)/2) - (bmp.GetWidth()/2));
+            break;
+        case wxAUI_BUTTON_DOWN:
+            if (button_state & wxAUI_BUTTON_STATE_DISABLED)
+                bmp = m_disabledDownBmp;
+            else
+                bmp = m_activeDownBmp;
+            break;
         case wxAUI_BUTTON_RIGHT:
             if (button_state & wxAUI_BUTTON_STATE_DISABLED)
                 bmp = m_disabledRightBmp;
@@ -1153,14 +1527,13 @@ void wxAuiSimpleTabArt::DrawButton(wxDC& dc,
                 bmp = m_disabledWindowListBmp;
             else
                 bmp = m_activeWindowListBmp;
+            rect.SetX(in_rect.x + in_rect.width - bmp.GetWidth());
             break;
     }
 
     if (!bmp.IsOk())
         return;
 
-    rect = in_rect;
-
     if (orientation == wxLEFT)
     {
         rect.SetX(in_rect.x);
@@ -1168,7 +1541,20 @@ void wxAuiSimpleTabArt::DrawButton(wxDC& dc,
         rect.SetWidth(bmp.GetWidth());
         rect.SetHeight(bmp.GetHeight());
     }
-    else
+    else if (orientation == wxUP)
+    {
+        rect.SetY(in_rect.y);
+        rect.SetWidth(bmp.GetWidth());
+        rect.SetHeight(bmp.GetHeight());
+    }
+    else if (orientation == wxDOWN)
+    {
+        rect.SetX(((in_rect.x + in_rect.width)/2) - (bmp.GetWidth()/2));
+        rect.SetY(in_rect.y  + in_rect.height - bmp.GetHeight() - bmp.GetHeight() / 2);
+        rect.SetWidth(bmp.GetWidth());
+        rect.SetHeight(bmp.GetHeight());
+    }
+    else if (orientation == wxRIGHT)
     {
         rect = wxRect(in_rect.x + in_rect.width - bmp.GetWidth(),
                       ((in_rect.y + in_rect.height)/2) - (bmp.GetHeight()/2),
@@ -1211,6 +1597,10 @@ int wxAuiSimpleTabArt::ShowDropDown(wxWindow* wnd,
 
     // find out the screen coordinate at the bottom of the tab ctrl
     wxRect cli_rect = wnd->GetClientRect();
+
+    if (IsLayoutVertically())
+        pt.x = cli_rect.x + cli_rect.width;
+    else // must be wxAUI_NB_TOP or wxAUI_NB_BOTTOM
     pt.y = cli_rect.y + cli_rect.height;
 
     wxAuiCommandCapture* cc = new wxAuiCommandCapture;
@@ -1225,21 +1615,35 @@ int wxAuiSimpleTabArt::ShowDropDown(wxWindow* wnd,
     return -1;
 }
 
-int wxAuiSimpleTabArt::GetBestTabCtrlSize(wxWindow* wnd,
-                                          const wxAuiNotebookPageArray& WXUNUSED(pages),
+wxSize wxAuiSimpleTabArt::GetBestTabSize(wxWindow* wnd,
+                                         const wxAuiNotebookPageArray& pages,
                                           const wxSize& WXUNUSED(requiredBmp_size))
 {
     wxClientDC dc(wnd);
     dc.SetFont(m_measuringFont);
-    int x_ext = 0;
-    wxSize s = GetTabSize(dc,
-                          wnd,
-                          wxT("ABCDEFGHIj"),
-                          wxNullBitmap,
-                          true,
-                          wxAUI_BUTTON_STATE_HIDDEN,
-                          &x_ext);
-    return s.y+3;
+
+    wxSize max_size;
+    size_t i, page_count = pages.GetCount();
+    for (i = 0; i < page_count; ++i)
+    {
+        wxAuiNotebookPage& page = pages.Item(i);
+
+        int ext = 0;
+        wxSize s = GetTabSize(dc,
+                              wnd,
+                              page.caption,
+                              wxNullBitmap,
+                              true,
+                              wxAUI_BUTTON_STATE_HIDDEN,
+                              &ext);
+
+        max_size.x = wxMax(max_size.x, s.x);
+        max_size.y = wxMax(max_size.y, s.y);
+    }
+
+
+    max_size.IncBy(3, 3);
+    return max_size;
 }
 
 void wxAuiSimpleTabArt::SetNormalFont(const wxFont& font)
Index: src/aui/tabartgtk.cpp
===================================================================
--- src/aui/tabartgtk.cpp
+++ src/aui/tabartgtk.cpp
@@ -2,11 +2,13 @@
 // Name:        src/aui/tabartgtk.cpp
 // Purpose:     implementation of the wxAuiGTKTabArt
 // Author:      Jens Lody and Teodor Petrov
-// Modified by:
+// Modified by: Jens Lody
 // Created:     2012-03-23
 // RCS-ID:      $Id$
 // Copyright:   (c) 2012 Jens Lody <jens@codeblocks.org>
 //                  and Teodor Petrov
+//                  2012, Jens Lody for the code related to left and right
+//                        positioning
 // Licence:     wxWindows licence
 ///////////////////////////////////////////////////////////////////////////////
 
@@ -50,6 +52,8 @@ static int s_CloseIconSize = 16; // default size
 
 }
 
+wxString wxAuiChopText(wxDC& dc, const wxString& text, int max_size);
+
 wxAuiGtkTabArt::wxAuiGtkTabArt()
 
 {
@@ -128,12 +132,18 @@ wxRect DrawCloseButton(wxDC& dc,
 
     wxRect out_rect;
 
+    out_rect.y = in_rect.y + (in_rect.height - button_size) / 2;
+
     if (orientation == wxLEFT)
-        out_rect.x = in_rect.x - ythickness;
-    else
-        out_rect.x = in_rect.x + in_rect.width - button_size - ythickness;
+        out_rect.x = in_rect.x - xthickness;
+    else if (orientation == wxRIGHT)
+        out_rect.x = in_rect.x + in_rect.width - button_size;
+    else if (orientation == wxUP)
+    {
+        out_rect.x = in_rect.x + in_rect.width - button_size - xthickness;
+        out_rect.y = in_rect.y + ythickness;
+    }
 
-    out_rect.y = in_rect.y + (in_rect.height - button_size) / 2;
     out_rect.width = button_size;
     out_rect.height = button_size;
 
@@ -166,140 +176,161 @@ void wxAuiGtkTabArt::DrawTab(wxDC& dc, wxWindow* wnd, const wxAuiNotebookPage& p
     GtkWidget *widget = wnd->GetHandle();
     GtkStyle *style_notebook = gtk_widget_get_style(wxGTKPrivate::GetNotebookWidget());
 
-    wxRect const &window_rect = wnd->GetRect();
-
     int focus_width = 0;
 
     gtk_widget_style_get(wxGTKPrivate::GetNotebookWidget(),
                          "focus-line-width", &focus_width,
                          NULL);
 
-    int tab_pos;
-    if (m_flags &wxAUI_NB_BOTTOM)
-        tab_pos = wxAUI_NB_BOTTOM;
-    else //if (m_flags & wxAUI_NB_TOP) {}
-        tab_pos = wxAUI_NB_TOP;
-
-    // TODO: else if (m_flags &wxAUI_NB_LEFT) {}
-    // TODO: else if (m_flags &wxAUI_NB_RIGHT) {}
-
     // figure out the size of the tab
     wxSize tab_size = GetTabSize(dc, wnd, page.caption, page.bitmap,
                                     page.active, close_button_state, x_extent);
 
     wxRect tab_rect = in_rect;
-    tab_rect.width = tab_size.x;
-    tab_rect.height = tab_size.y;
-    tab_rect.y += 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
-
-    if (page.active)
-        tab_rect.height += 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
-    // if no bitmap is set, we need a tiny correction
-    if (! page.bitmap.IsOk())
-        tab_rect.height += 1;
+    wxRect gap_rect = wnd->GetRect();
+    int gap_start = 0, gap_width = 0;
 
-    int gap_rect_height = 6 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
-    int gap_rect_x = 1, gap_start = 0, gap_width = 0;
-    int gap_rect_y = tab_rect.y - gap_rect_height;
-    int gap_rect_width = window_rect.width;
+    GtkPositionType gap_box_pos;
+    GtkPositionType gap_pos;
 
-    switch (tab_pos)
+    if (IsLayoutHorizontally())
     {
-        case wxAUI_NB_TOP:
-            tab_rect.y -= 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
+        tab_rect.width = tab_size.x;
+        tab_rect.height = tab_size.y;
+        if (page.active)
+            tab_rect.height += 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
+        // if no bitmap is set, we need a tiny correction
+        if (! page.bitmap.IsOk())
+            tab_rect.height += 1;
+        tab_rect.y += GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder / 2;
+        gap_rect.height = 6 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
+        gap_rect.x = 1;
+        gap_start = tab_rect.x - GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder / 2;
+        gap_width = tab_rect.width;
+
+        if (IsTopAligned())
+        {
             if (!page.active)
                 tab_rect.y += 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
-            gap_rect_y = tab_rect.y + tab_rect.height - GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder / 2;
-            // fall through
-        case wxAUI_NB_BOTTOM:
-            gap_start = tab_rect.x - GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder / 2;
-            gap_width = tab_rect.width;
-            break;
-        // TODO: case wxAUI_NB_LEFT: break;
-        // TODO: case wxAUI_NB_RIGHT: break;
+            tab_rect.y -= 1;
+            gap_rect.y = tab_rect.y + tab_rect.height;
+            gap_box_pos = GTK_POS_TOP;
+            gap_pos = GTK_POS_BOTTOM;
+        }
+        else if (IsBottomAligned())
+        {
+            tab_rect.y += 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
+            tab_rect.height += 2;
+            gap_rect.y = tab_rect.y - gap_rect.height;
+            gap_rect.y += GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder / 2;
+            gap_box_pos = GTK_POS_BOTTOM;
+            gap_pos = GTK_POS_TOP;
+        }
+    }
+
+    if (IsLayoutVertically())
+    {
+        tab_rect.width -= 4 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder;
+        tab_rect.height = tab_size.y;
+        gap_rect.width = 6 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
+        gap_rect.y = 1;
+        gap_start = tab_rect.y - GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder / 2;
+        gap_width = tab_rect.height;
+
+        if (IsLeftAligned())
+        {
+            if (!page.active)
+            {
+                tab_rect.x += 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder;
+                tab_rect.width -= 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder;
+            }
+            gap_rect.x = tab_rect.x + tab_rect.width;
+            gap_box_pos = GTK_POS_LEFT;
+            gap_pos = GTK_POS_RIGHT;
+        }
+        else if (IsRightAligned())
+        {
+            tab_rect.x = wnd->GetRect().width - tab_rect.width;
+            if (!page.active)
+                tab_rect.width -= 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder;
+            gap_rect.x = tab_rect.x - gap_rect.width;
+            gap_box_pos = GTK_POS_RIGHT;
+            gap_pos = GTK_POS_LEFT;
+        }                                        
     }
-    tab_rect.y += GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder / 2;
-    gap_rect_y += GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder / 2;
 
     int padding = focus_width + GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
 
     int clip_width = tab_rect.width;
+    int clip_height = tab_rect.height;
     if (tab_rect.x + tab_rect.width > in_rect.x + in_rect.width)
         clip_width = (in_rect.x + in_rect.width) - tab_rect.x;
+    if (tab_rect.y + tab_rect.height > in_rect.y + in_rect.height)
+        clip_height = (in_rect.y + in_rect.height) - tab_rect.y;
 
-    dc.SetClippingRegion(tab_rect.x, tab_rect.y - GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder, clip_width, tab_rect.height + GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder);
+    dc.SetClippingRegion(tab_rect.x,
+                         tab_rect.y,
+                         clip_width,
+                         clip_height);
 
     GdkRectangle area;
     area.x = tab_rect.x - GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder;
     area.y = tab_rect.y - 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
     area.width = clip_width + GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder;
-    area.height = tab_rect.height + 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
+    area.height = clip_height + 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
 
     wxGTKDCImpl *impldc = (wxGTKDCImpl*) dc.GetImpl();
     GdkWindow* window = impldc->GetGDKWindow();
 
-    if (tab_pos == wxAUI_NB_BOTTOM)
-    {
-        if (page.active)
-        {
-            gtk_paint_box_gap(style_notebook, window, GTK_STATE_NORMAL, GTK_SHADOW_OUT,
-                              NULL, widget,
-                              const_cast<char*>("notebook"),
-                              gap_rect_x, gap_rect_y,
-                              gap_rect_width, gap_rect_height,
-                              GTK_POS_BOTTOM, gap_start , gap_width);
-        }
-        gtk_paint_extension(style_notebook, window,
-                           page.active ? GTK_STATE_NORMAL : GTK_STATE_ACTIVE, GTK_SHADOW_OUT,
-                           &area, widget,
-                           const_cast<char*>("tab"),
-                           tab_rect.x, tab_rect.y,
-                           tab_rect.width, tab_rect.height,
-                           GTK_POS_TOP);
-    }
-    else
+    // we draw a box here, because the gap-box is not drawn, if the active tab is not visible
+    gtk_paint_box(style_notebook, window, GTK_STATE_NORMAL, GTK_SHADOW_OUT,
+                  NULL, widget,
+                  const_cast<char*>("notebook"),
+                  gap_rect.x, gap_rect.y,
+                  gap_rect.width, gap_rect.height);
+
+    if (page.active)
     {
-        if (page.active)
-        {
-            gtk_paint_box_gap(style_notebook, window, GTK_STATE_NORMAL, GTK_SHADOW_OUT,
-                              NULL, widget,
-                              const_cast<char*>("notebook"),
-                              gap_rect_x, gap_rect_y,
-                              gap_rect_width, gap_rect_height,
-                              GTK_POS_TOP, gap_start , gap_width);
-        }
-        gtk_paint_extension(style_notebook, window,
-                           page.active ? GTK_STATE_NORMAL : GTK_STATE_ACTIVE, GTK_SHADOW_OUT,
-                           &area, widget,
-                           const_cast<char*>("tab"),
-                           tab_rect.x, tab_rect.y,
-                           tab_rect.width, tab_rect.height,
-                           GTK_POS_BOTTOM);
+        gtk_paint_box_gap(style_notebook, window, GTK_STATE_NORMAL, GTK_SHADOW_OUT,
+                          NULL, widget,
+                          const_cast<char*>("notebook"),
+                          gap_rect.x, gap_rect.y,
+                          gap_rect.width, gap_rect.height,
+                          gap_box_pos, gap_start , gap_width);
     }
+    gtk_paint_extension(style_notebook, window,
+                       page.active ? GTK_STATE_NORMAL : GTK_STATE_ACTIVE, GTK_SHADOW_OUT,
+                       &area, widget,
+                       const_cast<char*>("tab"),
+                       tab_rect.x, tab_rect.y,
+                       tab_rect.width, tab_rect.height,
+                       gap_pos);
 
     wxCoord textX = tab_rect.x + padding + style_notebook->xthickness;
 
-    int bitmap_offset = 0;
+    int bitmapX = 0;
     if (page.bitmap.IsOk())
     {
-        bitmap_offset = textX;
+        bitmapX = textX;
 
         // draw bitmap
         int bitmapY = tab_rect.y +(tab_rect.height - page.bitmap.GetHeight()) / 2;
         if(!page.active)
         {
-            if (tab_pos == wxAUI_NB_TOP)
+            if (IsTopAligned())
                 bitmapY += style_notebook->ythickness / 2;
-            else
+            else  if (IsBottomAligned())
                 bitmapY -= style_notebook->ythickness / 2;
         }
         dc.DrawBitmap(page.bitmap,
-                      bitmap_offset,
+                      bitmapX,
                       bitmapY,
                       true);
 
         textX += page.bitmap.GetWidth() + padding;
     }
+    if (page.active)
+        textX += style_notebook->ythickness;
 
     wxCoord textW, textH, textY;
 
@@ -308,9 +339,9 @@ void wxAuiGtkTabArt::DrawTab(wxDC& dc, wxWindow* wnd, const wxAuiNotebookPage& p
     textY = tab_rect.y + (tab_rect.height - textH) / 2;
     if(!page.active)
     {
-        if (tab_pos == wxAUI_NB_TOP)
+        if (IsTopAligned())
             textY += style_notebook->ythickness / 2;
-        else
+        else  if (IsBottomAligned())
             textY -= style_notebook->ythickness / 2;
     }
 
@@ -330,12 +361,19 @@ void wxAuiGtkTabArt::DrawTab(wxDC& dc, wxWindow* wnd, const wxAuiNotebookPage& p
         // clipping seems not to work here, so we we have to recalc the focus-area manually
         if((focus_area.x + focus_area.width) > (area.x + area.width))
             focus_area.width = area.x + area.width - focus_area.x + focus_width - GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder;
+        if((focus_area.y + focus_area.height) > (area.y + area.height))
+            focus_area.height = area.y + area.height - focus_area.y + focus_width - GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
         gtk_paint_focus (style_notebook, window,
                          GTK_STATE_ACTIVE, NULL, widget, "tab",
                          focus_area.x, focus_area.y, focus_area.width, focus_area.height);
     }
 
-    dc.DrawText(page.caption, textX, textY);
+    int close_button_width = (close_button_state != wxAUI_BUTTON_STATE_HIDDEN) ? s_CloseIconSize + 3 * padding : 0;
+    wxString draw_text = wxAuiChopText(dc,page.caption,
+                                       tab_rect.width - (textX - tab_rect.x) - close_button_width);
+
+
+    dc.DrawText(draw_text, textX, textY);
 
     // draw close-button on tab (if enabled)
     if (close_button_state != wxAUI_BUTTON_STATE_HIDDEN)
@@ -343,7 +381,7 @@ void wxAuiGtkTabArt::DrawTab(wxDC& dc, wxWindow* wnd, const wxAuiNotebookPage& p
         wxRect rect(tab_rect.x, tab_rect.y, tab_rect.width - style_notebook->xthickness, tab_rect.height);
         if(!page.active)
         {
-            if (tab_pos == wxAUI_NB_TOP)
+            if (IsTopAligned())
                 rect.y += style_notebook->ythickness / 2;
             else
                 rect.y -= style_notebook->ythickness / 2;
@@ -378,14 +416,24 @@ wxRect DrawSimpleArrow(wxDC& dc,
 
     if (orientation == wxLEFT)
         out_rect.x = in_rect.x;
-    else
+    else if (orientation == wxUP || orientation == wxDOWN)
+        out_rect.x = in_rect.x + (in_rect.width - scroll_arrow_hlength) / 2;
+    else  if (orientation == wxRIGHT)
         out_rect.x = in_rect.x + in_rect.width - scroll_arrow_hlength;
+
+    if (orientation == wxDOWN)
+        out_rect.y = in_rect.y + in_rect.height -  scroll_arrow_vlength;
+    else if (orientation == wxUP)
+        out_rect.y = in_rect.y;
+    else
     out_rect.y = (in_rect.y + in_rect.height - 3 * gtk_widget_get_style(wxGTKPrivate::GetNotebookWidget())->ythickness - scroll_arrow_vlength) / 2;
+
     out_rect.width = scroll_arrow_hlength;
     out_rect.height = scroll_arrow_vlength;
 
     wxGTKDCImpl *impldc = (wxGTKDCImpl*) dc.GetImpl();
     GdkWindow* window = impldc->GetGDKWindow();
+
     gtk_paint_arrow (gtk_widget_get_style(wxGTKPrivate::GetButtonWidget()), window, state, shadow, NULL, widget, "notebook",
                      arrow_type, TRUE, out_rect.x, out_rect.y, out_rect.width, out_rect.height);
 
@@ -401,13 +449,18 @@ void wxAuiGtkTabArt::DrawButton(wxDC& dc, wxWindow* wnd,
 {
     GtkWidget *widget = wnd->GetHandle();
     wxRect rect = in_rect;
-    if (m_flags &wxAUI_NB_BOTTOM)
+    if (IsBottomAligned())
         rect.y += 2 * gtk_widget_get_style(wxGTKPrivate::GetButtonWidget())->ythickness;
 
     switch (bitmap_id)
     {
         case wxAUI_BUTTON_CLOSE:
+            if (orientation != wxUP)
             rect.y -= 2 * gtk_widget_get_style(wxGTKPrivate::GetButtonWidget())->ythickness;
+            else
+                rect.y -= gtk_widget_get_style(wxGTKPrivate::GetButtonWidget())->ythickness;
+            if (IsLeftAligned())
+                rect.x -= 4 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder;
             rect = DrawCloseButton(dc, widget, button_state, rect, orientation, NULL);
             break;
 
@@ -419,12 +472,33 @@ void wxAuiGtkTabArt::DrawButton(wxDC& dc, wxWindow* wnd,
             rect = DrawSimpleArrow(dc, widget, button_state, rect, orientation, GTK_ARROW_RIGHT);
             break;
 
+        case wxAUI_BUTTON_UP:
+            rect.width = wnd->GetRect().GetWidth();
+            rect = DrawSimpleArrow(dc, widget, button_state, rect, orientation, GTK_ARROW_UP);
+            break;
+
+        case wxAUI_BUTTON_DOWN:
+            rect = DrawSimpleArrow(dc, widget, button_state, rect, orientation, GTK_ARROW_DOWN);
+            break;
+
         case wxAUI_BUTTON_WINDOWLIST:
             {
-                rect.height -= 4 * gtk_widget_get_style(wxGTKPrivate::GetButtonWidget())->ythickness;
-                rect.width = rect.height;
+                int scroll_arrow_hlength, scroll_arrow_vlength;
+                gtk_widget_style_get(widget,
+                                     "scroll-arrow-hlength", &scroll_arrow_hlength,
+                                     "scroll-arrow-vlength", &scroll_arrow_vlength,
+                                     NULL);
+                rect.height = 1.5 * scroll_arrow_vlength;
+                rect.width = 1.5 * scroll_arrow_hlength;
                 rect.x = in_rect.x + in_rect.width - rect.width;
 
+
+                if (orientation == wxUP)
+                {
+                    if (IsLeftAligned())
+                        rect.x -= 4 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder;
+                }
+
                 if (button_state == wxAUI_BUTTON_STATE_HOVER)
                     wxRendererNative::Get().DrawComboBoxDropButton(wnd, dc, rect, wxCONTROL_CURRENT);
                 else if (button_state == wxAUI_BUTTON_STATE_PRESSED)
@@ -439,14 +513,16 @@ void wxAuiGtkTabArt::DrawButton(wxDC& dc, wxWindow* wnd,
 }
 
 
-int wxAuiGtkTabArt::GetBestTabCtrlSize(wxWindow* wnd,
+wxSize wxAuiGtkTabArt::GetBestTabSize(wxWindow* wnd,
                                    const wxAuiNotebookPageArray& pages,
                                    const wxSize& required_bmp_size)
 {
     SetMeasuringFont(m_normalFont);
     SetSelectedFont(m_normalFont);
-    int tab_height = 3 * gtk_widget_get_style(wxGTKPrivate::GetNotebookWidget())->ythickness + wxAuiGenericTabArt::GetBestTabCtrlSize(wnd, pages, required_bmp_size);
-    return tab_height;
+    wxSize s = wxAuiGenericTabArt::GetBestTabSize(wnd, pages, required_bmp_size);
+    s.IncBy(3 * gtk_widget_get_style(wxGTKPrivate::GetNotebookWidget())->xthickness,
+            3 * gtk_widget_get_style(wxGTKPrivate::GetNotebookWidget())->ythickness);
+    return s;
 }
 
 wxSize wxAuiGtkTabArt::GetTabSize(wxDC& dc,
@@ -455,15 +531,15 @@ wxSize wxAuiGtkTabArt::GetTabSize(wxDC& dc,
                               const wxBitmap& bitmap,
                               bool active,
                               int close_button_state,
-                              int* x_extent)
+                              int* extent)
 {
-    wxSize s = wxAuiGenericTabArt::GetTabSize(dc, wnd, caption, bitmap, active, close_button_state, x_extent);
+    wxSize s = wxAuiGenericTabArt::GetTabSize(dc, wnd, caption, bitmap, active, close_button_state, extent);
 
     int overlap = 0;
     gtk_widget_style_get (wnd->GetHandle(),
         "focus-line-width", &overlap,
         NULL);
-    *x_extent -= overlap;
+    *extent -= overlap;
     return s;
 }
 #endif  // wxUSE_AUI
