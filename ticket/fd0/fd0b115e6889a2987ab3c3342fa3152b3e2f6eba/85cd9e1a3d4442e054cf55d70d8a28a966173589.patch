Index: include/wx/gtk/webview_webkit.h
===================================================================
--- include/wx/gtk/webview_webkit.h	(revision 70614)
+++ include/wx/gtk/webview_webkit.h	(working copy)
@@ -95,6 +95,9 @@
     virtual void Undo();
     virtual void Redo();
 
+    //Find function
+    virtual long Find(const wxString& text, int flags = wxWEB_VIEW_FIND_DEFAULT) { return wxNOT_FOUND; };
+
     //Editing functions
     virtual void SetEditable(bool enable = true);
     virtual bool IsEditable() const;
@@ -108,7 +111,7 @@
     virtual void ClearSelection();
 
     virtual void RunScript(const wxString& javascript);
-    
+
     //Virtual Filesystem Support
     virtual void RegisterHandler(wxSharedPtr<wxWebViewHandler> handler);
     virtual wxVector<wxSharedPtr<wxWebViewHandler> > GetHandlers() { return m_handlerList; }
Index: include/wx/msw/webview_ie.h
===================================================================
--- include/wx/msw/webview_ie.h	(revision 70614)
+++ include/wx/msw/webview_ie.h	(working copy)
@@ -200,7 +200,7 @@
 
     virtual HRESULT wxSTDCALL GetHostInfo(DOCHOSTUIINFO *pInfo) = 0;
 
-    virtual HRESULT wxSTDCALL ShowUI(DWORD dwID, 
+    virtual HRESULT wxSTDCALL ShowUI(DWORD dwID,
                                      IOleInPlaceActiveObject *pActiveObject,
                                      IOleCommandTarget *pCommandTarget,
                                      IOleInPlaceFrame *pFrame,
@@ -209,7 +209,7 @@
     virtual HRESULT wxSTDCALL HideUI(void) = 0;
 
     virtual HRESULT wxSTDCALL UpdateUI(void) = 0;
-    
+
     virtual HRESULT wxSTDCALL EnableModeless(BOOL fEnable) = 0;
 
     virtual HRESULT wxSTDCALL OnDocWindowActivate(BOOL fActivate) = 0;
@@ -220,11 +220,11 @@
                                            IOleInPlaceUIWindow *pUIWindow,
                                            BOOL fRameWindow) = 0;
 
-    virtual HRESULT wxSTDCALL TranslateAccelerator(LPMSG lpMsg, 
+    virtual HRESULT wxSTDCALL TranslateAccelerator(LPMSG lpMsg,
                                                    const GUID *pguidCmdGroup,
                                                    DWORD nCmdID) = 0;
 
-    virtual HRESULT wxSTDCALL GetOptionKeyPath(LPOLESTR *pchKey, 
+    virtual HRESULT wxSTDCALL GetOptionKeyPath(LPOLESTR *pchKey,
                                                DWORD dw) = 0;
 
     virtual HRESULT wxSTDCALL GetDropTarget(IDropTarget *pDropTarget,
@@ -243,10 +243,13 @@
 /* END OF MSHTMHST.H implementation */
 
 struct IHTMLDocument2;
+struct IHTMLElement;
+struct IMarkupPointer;
 class wxFSFile;
 class ClassFactory;
 class wxIEContainer;
 class DocHostUIHandler;
+class wxFindPointers;
 
 class WXDLLIMPEXP_WEBVIEW wxWebViewIE : public wxWebView
 {
@@ -321,6 +324,9 @@
     virtual void Undo();
     virtual void Redo();
 
+    //Find function
+    virtual long Find(const wxString& text, int flags = wxWEB_VIEW_FIND_DEFAULT);
+
     //Editing functions
     virtual void SetEditable(bool enable = true);
     virtual bool IsEditable() const;
@@ -380,10 +386,26 @@
     bool m_historyLoadingFromList;
     bool m_historyEnabled;
 
-    //Generic helper functions for IHtmlDocument commands
+    //We store find flag, results and position.
+    wxVector<wxFindPointers> m_findPointers;
+    int m_findFlags;
+    wxString m_findText;
+    int m_findPosition;
+
+    //Generic helper functions
     bool CanExecCommand(wxString command) const;
     void ExecCommand(wxString command);
     IHTMLDocument2* GetDocument() const;
+    bool IsElementVisible(IHTMLElement* elm);
+    //Find helper functions.
+    //The FindInternal does the actual searching. The first two paramters
+    //are obvious text is the phrase to search for and flags are the search flags.
+    //The add_pointers tells the function if the results should be added to m_findPointers.
+    //and the remove_highligt just removes the highlighted items. This way we avoid code duplication
+    //since both highlight add, highlight removal and search requries all the code in the function.
+    void FindInternal(const wxString& text, int flags, bool add_pointers, bool remove_highligt = false);
+    long FindNext(int direction = 1);
+    void FindClear();
     //Toggles control features see INTERNETFEATURELIST for values.
     bool EnableControlFeature(long flag, bool enable = true);
 
@@ -468,7 +490,7 @@
     virtual HRESULT wxSTDCALL ShowContextMenu(DWORD dwID, POINT *ppt,
                                               IUnknown *pcmdtReserved,
                                               IDispatch *pdispReserved);
-    
+
     virtual HRESULT wxSTDCALL GetHostInfo(DOCHOSTUIINFO *pInfo);
 
     virtual HRESULT wxSTDCALL ShowUI(DWORD dwID,
@@ -495,7 +517,7 @@
                                                    const GUID *pguidCmdGroup,
                                                    DWORD nCmdID);
 
-    virtual HRESULT wxSTDCALL GetOptionKeyPath(LPOLESTR *pchKey, 
+    virtual HRESULT wxSTDCALL GetOptionKeyPath(LPOLESTR *pchKey,
                                                DWORD dw);
 
     virtual HRESULT wxSTDCALL GetDropTarget(IDropTarget *pDropTarget,
@@ -513,6 +535,18 @@
     DECLARE_IUNKNOWN_METHODS;
 };
 
+class wxFindPointers
+{
+public:
+    wxFindPointers(IMarkupPointer *ptrBegin, IMarkupPointer *ptrEnd)
+    {
+        begin = ptrBegin;
+        end = ptrEnd;
+    }
+    //The two markup pointers.
+    IMarkupPointer *begin, *end;
+};
+
 #endif // wxUSE_WEBVIEW && wxUSE_WEBVIEW_IE && defined(__WXMSW__)
 
 #endif // wxWebViewIE_H
Index: include/wx/osx/webview_webkit.h
===================================================================
--- include/wx/osx/webview_webkit.h	(revision 70614)
+++ include/wx/osx/webview_webkit.h	(working copy)
@@ -74,20 +74,23 @@
     virtual bool CanSetZoomType(wxWebViewZoomType type) const;
 
     virtual bool IsBusy() const { return m_busy; }
-    
+
     //History functions
     virtual void ClearHistory();
     virtual void EnableHistory(bool enable = true);
     virtual wxVector<wxSharedPtr<wxWebViewHistoryItem> > GetBackwardHistory();
     virtual wxVector<wxSharedPtr<wxWebViewHistoryItem> > GetForwardHistory();
     virtual void LoadHistoryItem(wxSharedPtr<wxWebViewHistoryItem> item);
-    
+
     //Undo / redo functionality
     virtual bool CanUndo() const;
     virtual bool CanRedo() const;
     virtual void Undo();
     virtual void Redo();
 
+    //Find function
+    virtual long Find(const wxString& text, int flags = wxWEB_VIEW_FIND_DEFAULT) { return wxNOT_FOUND; };
+
     //Clipboard functions
     virtual bool CanCut() const { return true; }
     virtual bool CanCopy() const { return true; }
@@ -95,11 +98,11 @@
     virtual void Cut();
     virtual void Copy();
     virtual void Paste();
-    
+
     //Editing functions
     virtual void SetEditable(bool enable = true);
     virtual bool IsEditable() const;
-    
+
     //Selection
     virtual void DeleteSelection();
     virtual bool HasSelection() const;
@@ -107,9 +110,9 @@
     virtual wxString GetSelectedText() const;
     virtual wxString GetSelectedSource() const;
     virtual void ClearSelection();
-    
+
     void RunScript(const wxString& javascript);
-    
+
     //Virtual Filesystem Support
     virtual void RegisterHandler(wxSharedPtr<wxWebViewHandler> handler);
 
@@ -158,6 +161,6 @@
     //TODO: look into using DECLARE_WXCOCOA_OBJC_CLASS rather than this.
 };
 
-#endif // wxUSE_WEBVIEW && wxUSE_WEBVIEW_WEBKIT 
+#endif // wxUSE_WEBVIEW && wxUSE_WEBVIEW_WEBKIT
 
 #endif // _WX_WEBKIT_H_
Index: include/wx/webview.h
===================================================================
--- include/wx/webview.h	(revision 70614)
+++ include/wx/webview.h	(working copy)
@@ -65,9 +65,19 @@
 {
     //Default, may access cache
     wxWEB_VIEW_RELOAD_DEFAULT,
-    wxWEB_VIEW_RELOAD_NO_CACHE 
+    wxWEB_VIEW_RELOAD_NO_CACHE
 };
 
+enum // wxWebViewFindFlags
+{
+    wxWEB_VIEW_FIND_WRAP =              0x0001,
+    wxWEB_VIEW_FIND_ENTIRE_WORD =       0x0002,
+    wxWEB_VIEW_FIND_MATCH_CASE =        0x0004,
+    wxWEB_VIEW_FIND_HIGHLIGHT_RESULT =  0x0008,
+    wxWEB_VIEW_FIND_BACKWARDS =         0x0010,
+    wxWEB_VIEW_FIND_DEFAULT =           0
+};
+
 enum wxWebViewBackend
 {
     wxWEB_VIEW_BACKEND_DEFAULT,
@@ -176,6 +186,9 @@
     virtual void Undo() = 0;
     virtual void Redo() = 0;
 
+    //Find function
+    virtual long Find(const wxString& text, int flags = wxWEB_VIEW_FIND_DEFAULT) = 0;
+
     wxDECLARE_ABSTRACT_CLASS(wxWebView);
 };
 
Index: interface/wx/webview.h
===================================================================
--- interface/wx/webview.h	(revision 70614)
+++ interface/wx/webview.h	(working copy)
@@ -23,18 +23,18 @@
 */
 enum wxWebViewZoomType
 {
-    /** 
-        The entire layout scales when zooming, including images 
+    /**
+        The entire layout scales when zooming, including images
     */
     wxWEB_VIEW_ZOOM_TYPE_LAYOUT,
-    /** 
+    /**
         Only the text changes in size when zooming, images and other layout
-        elements retain their initial size 
+        elements retain their initial size
     */
     wxWEB_VIEW_ZOOM_TYPE_TEXT
 };
 
-/** 
+/**
     Types of errors that can cause navigation to fail
 */
 enum wxWebViewNavigationError
@@ -58,18 +58,41 @@
     wxWEB_NAV_ERR_OTHER
 };
 
-/** 
-    Type of refresh 
+/**
+    Type of refresh
 */
 enum wxWebViewReloadFlags
 {
     /** Default reload, will access cache */
     wxWEB_VIEW_RELOAD_DEFAULT,
     /** Reload the current view without accessing the cache */
-    wxWEB_VIEW_RELOAD_NO_CACHE 
+    wxWEB_VIEW_RELOAD_NO_CACHE
 };
 
+/**
+    Find flags used when searching for text on page.
+*/
+enum // wxWebViewFindFlags
+{
+    /** Causes the search to restart when end or beginning reached */
+    wxWEB_VIEW_FIND_WRAP =              0x0001,
 
+    /** Matches an entire word when searching */
+    wxWEB_VIEW_FIND_ENTIRE_WORD =       0x0002,
+
+    /** Match case, e.i. case sensitive searching */
+    wxWEB_VIEW_FIND_MATCH_CASE =        0x0004,
+
+    /** Highlights the search results */
+    wxWEB_VIEW_FIND_HIGHLIGHT_RESULT =  0x0008,
+
+    /** Searches for phrase in backward direction */
+    wxWEB_VIEW_FIND_BACKWARDS =         0x0010,
+
+    /** The default flag, which is simple searching */
+    wxWEB_VIEW_FIND_DEFAULT =           0
+};
+
 /**
  * List of available backends for wxWebView
  */
@@ -88,14 +111,14 @@
 
 /**
     @class wxWebViewHistoryItem
-  
+
     A simple class that contains the URL and title of an element of the history
-    of a wxWebView. 
-   
+    of a wxWebView.
+
     @since 2.9.3
     @library{wxwebview}
     @category{webview}
-    
+
     @see wxWebView
  */
 class wxWebViewHistoryItem
@@ -105,12 +128,12 @@
         Construtor.
     */
     wxWebViewHistoryItem(const wxString& url, const wxString& title);
-    
+
     /**
         @return The url of the page.
     */
     wxString GetUrl();
-    
+
     /**
         @return The title of the page.
     */
@@ -119,14 +142,14 @@
 
 /**
     @class wxWebViewHandler
-  
-    The base class for handling custom schemes in wxWebView, for example to 
+
+    The base class for handling custom schemes in wxWebView, for example to
     allow virtual file system support.
-   
+
     @since 2.9.3
     @library{wxwebview}
     @category{webview}
-    
+
     @see wxWebView
  */
 class wxWebViewHandler
@@ -140,7 +163,7 @@
 
     /**
         @return A pointer to the file represented by @c uri.
-    */  
+    */
     virtual wxFSFile* GetFile(const wxString &uri) = 0;
 
     /**
@@ -151,68 +174,68 @@
 
 /**
     @class wxWebView
-  
+
     This control may be used to render web (HTML / CSS / javascript) documents.
-    It is designed to allow the creation of multiple backends for each port, 
+    It is designed to allow the creation of multiple backends for each port,
     although currently just one is available. It differs from wxHtmlWindow in
     that each backend is actually a full rendering engine, Trident on MSW and
     Webkit on OSX and GTK. This allows the correct viewing complex pages with
-    javascript and css. 
-    
+    javascript and css.
+
     @section descriptions Backend Descriptions
-    
+
     @par wxWEB_VIEW_BACKEND_IE (MSW)
-    
+
     The IE backend uses Microsoft's Trident rendering engine, specifically the
     version used by the locally installed copy of Internet Explorer. As such it
-    is only available for the MSW port. By default recent versions of the 
+    is only available for the MSW port. By default recent versions of the
     <a href="http://msdn.microsoft.com/en-us/library/aa752085%28v=VS.85%29.aspx">WebBrowser</a>
     control, which this backend uses, emulate Internet Explorer 7. This can be
-    changed with a registry setting, see 
+    changed with a registry setting, see
     <a href="http://msdn.microsoft.com/en-us/library/ee330730%28v=vs.85%29.aspx#browser_emulation">
     this</a> article for more information. This backend has full support for
     custom schemes and virtual file systems.
-    
+
     @par wxWEB_VIEW_WEBKIT (GTK)
-    
-    Under GTK the WebKit backend uses 
+
+    Under GTK the WebKit backend uses
     <a href="http://webkitgtk.org/">WebKitGTK+</a>. The current minimum version
     required is 1.3.1 which ships by default with Ubuntu Natty and Debian
-    Wheezy and has the package name libwebkitgtk-dev. Custom schemes and 
+    Wheezy and has the package name libwebkitgtk-dev. Custom schemes and
     virtual files systems are supported under this backend, however embedded
     resources such as images and stylesheets are currently loaded using the
     data:// scheme.
-    
+
     @par wxWEB_VIEW_WEBKIT (OSX)
-    
-    The OSX WebKit backend uses Apple's 
+
+    The OSX WebKit backend uses Apple's
     <a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Reference/WebKit/Classes/WebView_Class/Reference/Reference.html#//apple_ref/doc/uid/20001903">WebView</a>
     class. This backend has full support for custom schemes and virtual file
     systems.
 
     @section async Asynchronous Notifications
-    
+
     Many of the methods in wxWebView are asynchronous, i.e. they return
     immediately and perform their work in the background. This includes
-    functions such as LoadUrl() and Reload(). To receive notification of the 
+    functions such as LoadUrl() and Reload(). To receive notification of the
     progress and completion of these functions you need to handle the events
     that are provided. Specifically @c wxEVT_COMMAND_WEB_VIEW_LOADED notifies
-    when the page or a sub-frame has finished loading and 
+    when the page or a sub-frame has finished loading and
     @c wxEVT_COMMAND_WEB_VIEW_ERROR notifies that an error has occurred.
-    
+
     @section vfs Virtual File Systems and Custom Schemes
-    
+
     wxWebView supports the registering of custom scheme handlers, for example
-    @c file or @c http. To do this create a new class which inherits from 
-    wxWebViewHandler, where wxWebHandler::GetFile() returns a pointer to a 
+    @c file or @c http. To do this create a new class which inherits from
+    wxWebViewHandler, where wxWebHandler::GetFile() returns a pointer to a
     wxFSFile which represents the given url. You can then register your handler
     with RegisterHandler() it will be called for all pages and resources.
-    
+
     wxWebFileHandler is provided to allow the navigation of pages inside a zip
-    archive. It overrides the @c file scheme and provides support for the 
-    standard @c file syntax as well as paths to archives of the form 
+    archive. It overrides the @c file scheme and provides support for the
+    standard @c file syntax as well as paths to archives of the form
     @c file:///C:/example/docs.zip;protocol=zip/main.htm
-  
+
     @beginEventEmissionTable{wxWebViewEvent}
     @event{EVT_WEB_VIEW_NAVIGATING(id, func)}
        Process a @c wxEVT_COMMAND_WEB_VIEW_NAVIGATING event, generated before trying
@@ -226,7 +249,7 @@
        will be generated per frame.
     @event{EVT_WEB_VIEW_LOADED(id, func)}
        Process a @c wxEVT_COMMAND_WEB_VIEW_LOADED event generated when the document
-       is fully loaded and displayed. Note that if the displayed HTML document has 
+       is fully loaded and displayed. Note that if the displayed HTML document has
        several frames, one such event will be generated per frame.
     @event{EVT_WEB_VIEW_ERROR(id, func)}
        Process a @c wxEVT_COMMAND_WEB_VIEW_ERROR event generated when a navigation
@@ -236,13 +259,13 @@
        precise error message/code.
     @event{EVT_WEB_VIEW_NEWWINDOW(id, func)}
        Process a @c wxEVT_COMMAND_WEB_VIEW_NEWWINDOW event, generated when a new
-       window is created. You must handle this event if you want anything to 
+       window is created. You must handle this event if you want anything to
        happen, for example to load the page in a new window or tab.
     @event{EVT_WEB_VIEW_TITLE_CHANGED(id, func)}
-       Process a @c wxEVT_COMMAND_WEB_VIEW_TITLE_CHANGED event, generated when 
+       Process a @c wxEVT_COMMAND_WEB_VIEW_TITLE_CHANGED event, generated when
        the page title changes. Use GetString to get the title.
     @endEventTable
-   
+
     @since 2.9.3
     @library{wxwebview}
     @category{ctrl,webview}
@@ -311,12 +334,12 @@
                 shown.
     */
     virtual wxString GetPageSource() const = 0;
-    
+
     /**
         Get the text of the current page.
     */
     virtual wxString GetPageText() const = 0;
-    
+
     /**
         Returns whether the web control is currently busy (e.g. loading a page).
     */
@@ -341,7 +364,7 @@
         displayed page.
     */
     virtual void Print() = 0;
-    
+
     /**
         Registers a custom scheme handler.
         @param handler A shared pointer to a wxWebHandler.
@@ -353,12 +376,12 @@
         @param flags A bit array that may optionally contain reload options.
     */
     virtual void Reload(wxWebViewReloadFlags flags = wxWEB_VIEW_RELOAD_DEFAULT) = 0;
-    
+
     /**
-        Runs the given javascript code. 
+        Runs the given javascript code.
     */
     virtual void RunScript(const wxString& javascript) = 0;
-    
+
     /**
         Set the editable property of the web control. Enabling allows the user
         to edit the page even if the @c contenteditable attribute is not set.
@@ -395,27 +418,27 @@
 
     /**
         Returns @true if the current selection can be copied.
-        
+
         @note This always returns @c true on the OSX WebKit backend.
     */
     virtual bool CanCopy() const = 0;
 
     /**
         Returns @true if the current selection can be cut.
-        
+
          @note This always returns @c true on the OSX WebKit backend.
     */
     virtual bool CanCut() const = 0;
 
     /**
         Returns @true if data can be pasted.
-        
+
         @note This always returns @c true on the OSX WebKit backend.
     */
     virtual bool CanPaste() const = 0;
 
     /**
-        Copies the current selection. 
+        Copies the current selection.
     */
     virtual void Copy() = 0;
 
@@ -433,13 +456,13 @@
         @name History
     */
 
-    /** 
+    /**
         Returns @true if it is possible to navigate backward in the history of
         visited pages.
     */
     virtual bool CanGoBack() const = 0;
 
-    /** 
+    /**
         Returns @true if it is possible to navigate forward in the history of
         visited pages.
     */
@@ -462,13 +485,13 @@
     virtual wxVector<wxSharedPtr<wxWebViewHistoryItem> > GetBackwardHistory() = 0;
 
     /**
-        Returns a list of items in the forward history. The first item in the 
-        vector is the next item in the history with respect to the curently 
+        Returns a list of items in the forward history. The first item in the
+        vector is the next item in the history with respect to the curently
         loaded page.
     */
     virtual wxVector<wxSharedPtr<wxWebViewHistoryItem> > GetForwardHistory() = 0;
 
-    /** 
+    /**
         Navigate back in the history of visited pages.
         Only valid if CanGoBack() returns true.
     */
@@ -481,31 +504,31 @@
     virtual void GoForward() = 0;
 
     /**
-        Loads a history item. 
+        Loads a history item.
     */
     virtual void LoadHistoryItem(wxSharedPtr<wxWebViewHistoryItem> item) = 0;
-    
+
     /**
         @name Selection
     */
-    
+
     /**
-        Clears the current selection. 
+        Clears the current selection.
     */
     virtual void ClearSelection() = 0;
-    
+
     /**
         Deletes the current selection. Note that for @c wxWEB_VIEW_BACKEND_WEBKIT
-        the selection must be editable, either through SetEditable or the 
+        the selection must be editable, either through SetEditable or the
         correct HTML attribute.
     */
     virtual void DeleteSelection() = 0;
-    
+
     /**
         Returns the currently selected source, if any.
     */
     virtual wxString GetSelectedSource() const = 0;
-    
+
     /**
         Returns the currently selected text, if any.
     */
@@ -546,6 +569,29 @@
     virtual void Undo() = 0;
 
     /**
+        @name Finding
+    */
+
+    /**
+        Finds a phrase on the current page and if found, the control will scroll the phrase
+        into view and select it.
+        @param the phrase to search for.
+        @param find flags for the search.
+        @return if search phrase was not found in combination with the flags then wxNOT_FOUND is returned.
+                If called for the first time with search phrase then the total number of results will be returned.
+                Then for every time its called with the same search phrase it will return the position of the
+                next phrase in the search.
+        @note This function will restart the search if the flags wxWEB_VIEW_FIND_ENTIRE_WORD or
+              wxWEB_VIEW_FIND_MATCH_CASE are changed, since this will require a new search.
+              To reset the search, for example reseting the highlights call the function with
+              an empty search phrase.
+              Currently only implemented on WXMSW.
+        @since 2.9.4
+    */
+    virtual bool Find(const wxString& text, int flags = wxWEB_VIEW_FIND_DEFAULT) = 0;
+
+
+    /**
         @name Zoom
     */
 
@@ -591,7 +637,7 @@
 /**
     @class wxWebViewEvent
 
-    A navigation  event holds information about events associated with 
+    A navigation  event holds information about events associated with
     wxWebView objects.
 
     @beginEventEmissionTable{wxWebViewEvent}
@@ -607,7 +653,7 @@
        will be generated per frame.
     @event{EVT_WEB_VIEW_LOADED(id, func)}
        Process a @c wxEVT_COMMAND_WEB_VIEW_LOADED event generated when the document
-       is fully loaded and displayed. Note that if the displayed HTML document has 
+       is fully loaded and displayed. Note that if the displayed HTML document has
        several frames, one such event will be generated per frame.
     @event{EVT_WEB_VIEW_ERROR(id, func)}
        Process a @c wxEVT_COMMAND_WEB_VIEW_ERROR event generated when a navigation
@@ -617,13 +663,13 @@
        precise error message/code.
     @event{EVT_WEB_VIEW_NEWWINDOW(id, func)}
        Process a @c wxEVT_COMMAND_WEB_VIEW_NEWWINDOW event, generated when a new
-       window is created. You must handle this event if you want anything to 
+       window is created. You must handle this event if you want anything to
        happen, for example to load the page in a new window or tab.
     @event{EVT_WEB_VIEW_TITLE_CHANGED(id, func)}
-       Process a @c wxEVT_COMMAND_WEB_VIEW_TITLE_CHANGED event, generated when 
+       Process a @c wxEVT_COMMAND_WEB_VIEW_TITLE_CHANGED event, generated when
        the page title changes. Use GetString to get the title.
     @endEventTable
-    
+
     @since 2.9.3
     @library{wxwebview}
     @category{events,webview}
Index: samples/webview/webview.cpp
===================================================================
--- samples/webview/webview.cpp	(revision 70614)
+++ samples/webview/webview.cpp	(working copy)
@@ -101,6 +101,10 @@
     void OnDeleteSelection(wxCommandEvent& evt);
     void OnSelectAll(wxCommandEvent& evt);
     void OnLoadScheme(wxCommandEvent& evt);
+    void OnFind(wxCommandEvent& evt);
+    void OnFindDone(wxCommandEvent& evt);
+    void OnFindText(wxCommandEvent& evt);
+    void OnFindOptions(wxCommandEvent& evt);
 
 private:
     wxTextCtrl* m_url;
@@ -113,6 +117,11 @@
     wxToolBarToolBase* m_toolbar_reload;
     wxToolBarToolBase* m_toolbar_tools;
 
+    wxToolBarToolBase* m_find_toolbar_done;
+    wxToolBarToolBase* m_find_toolbar_options;
+    wxToolBarToolBase* m_find_toolbar_next;
+    wxToolBarToolBase* m_find_toolbar_previous;
+
     wxMenu* m_tools_menu;
     wxMenu* m_tools_history_menu;
     wxMenuItem* m_tools_layout;
@@ -132,11 +141,16 @@
     wxMenuItem* m_edit_mode;
     wxMenuItem* m_selection_clear;
     wxMenuItem* m_selection_delete;
+    wxMenuItem* m_find;
 
     wxInfoBar *m_info;
     wxStaticText* m_info_text;
+    wxTextCtrl* m_find_ctrl;
+    wxToolBar* m_find_toolbar;
 
     wxMenuHistoryMap m_histMenuItems;
+    wxString m_findText;
+    int m_findFlags, m_findCount;
 };
 
 class SourceViewDialog : public wxDialog
@@ -200,6 +214,39 @@
 
     m_toolbar->Realize();
 
+    // Set find values.
+    m_findFlags = wxWEB_VIEW_FIND_DEFAULT;
+    m_findText = wxEmptyString;
+    m_findCount = 0;
+
+    // Create panel for find toolbar.
+    wxPanel* panel = new wxPanel(this);
+    topsizer->Add(panel, wxSizerFlags().Expand());
+
+    // Create sizer for panel.
+    wxBoxSizer* panel_sizer = new wxBoxSizer(wxVERTICAL);
+    panel->SetSizer(panel_sizer);
+
+    // Create the find toolbar.
+    m_find_toolbar = new wxToolBar(panel,wxID_ANY,wxDefaultPosition,wxDefaultSize,wxTB_HORIZONTAL|wxTB_TEXT|wxTB_HORZ_LAYOUT);
+    m_find_toolbar->Hide();
+    panel_sizer->Add(m_find_toolbar,wxSizerFlags().Expand());
+
+    // Create find control.
+    m_find_ctrl = new wxTextCtrl(m_find_toolbar,wxID_ANY,wxEmptyString,wxDefaultPosition,wxSize(140,-1),wxTE_PROCESS_ENTER);
+
+    // Add find toolbar tools.
+    m_find_toolbar->SetToolSeparation(7);
+    m_find_toolbar_done = m_find_toolbar->AddTool(wxID_ANY,"Done",wxArtProvider::GetBitmap(wxART_CROSS_MARK));
+    m_find_toolbar->AddSeparator();
+    m_find_toolbar->AddControl(m_find_ctrl,"Find");
+    m_find_toolbar->AddSeparator();
+    m_find_toolbar_next = m_find_toolbar->AddTool(wxID_ANY,"Next",wxArtProvider::GetBitmap(wxART_GO_DOWN,wxART_OTHER,wxSize(16,16)));
+    m_find_toolbar_previous = m_find_toolbar->AddTool(wxID_ANY,"Previous",wxArtProvider::GetBitmap(wxART_GO_UP,wxART_OTHER,wxSize(16,16)));
+    m_find_toolbar->AddSeparator();
+    m_find_toolbar_options = m_find_toolbar->AddTool(wxID_ANY,"Options",wxArtProvider::GetBitmap(wxART_PLUS,wxART_OTHER,wxSize(16,16)));
+    m_find_toolbar->Realize();
+
     // Create the info panel
     m_info = new wxInfoBar(this);
     topsizer->Add(m_info, wxSizerFlags().Expand());
@@ -235,6 +282,10 @@
     m_tools_handle_new_window = m_tools_menu->AppendCheckItem(wxID_ANY, _("Handle New Windows"));
     m_tools_menu->AppendSeparator();
 
+    //Find
+    m_find = m_tools_menu->Append(wxID_ANY, _("Find"));
+    m_tools_menu->AppendSeparator();
+
     //History menu
     m_tools_history_menu = new wxMenu();
     wxMenuItem* clearhist =  m_tools_history_menu->Append(wxID_ANY, _("Clear History"));
@@ -292,6 +343,22 @@
     Connect(m_url->GetId(), wxEVT_COMMAND_TEXT_ENTER,
             wxCommandEventHandler(WebFrame::OnUrl), NULL, this );
 
+    // Connect find toolbar events.
+    Connect(m_find_toolbar_done->GetId(), wxEVT_COMMAND_TOOL_CLICKED,
+            wxCommandEventHandler(WebFrame::OnFindDone), NULL, this );
+    Connect(m_find_toolbar_next->GetId(), wxEVT_COMMAND_TOOL_CLICKED,
+            wxCommandEventHandler(WebFrame::OnFindText), NULL, this );
+    Connect(m_find_toolbar_previous->GetId(), wxEVT_COMMAND_TOOL_CLICKED,
+            wxCommandEventHandler(WebFrame::OnFindText), NULL, this );
+    Connect(m_find_toolbar_options->GetId(), wxEVT_COMMAND_TOOL_CLICKED,
+            wxCommandEventHandler(WebFrame::OnFindOptions), NULL, this );
+
+    // Connect find control events.
+    Connect(m_find_ctrl->GetId(), wxEVT_COMMAND_TEXT_UPDATED,
+            wxCommandEventHandler(WebFrame::OnFindText), NULL, this );
+    Connect(m_find_ctrl->GetId(), wxEVT_COMMAND_TEXT_ENTER,
+            wxCommandEventHandler(WebFrame::OnFindText), NULL, this );
+
     // Connect the webview events
     Connect(m_browser->GetId(), wxEVT_COMMAND_WEB_VIEW_NAVIGATING,
             wxWebViewEventHandler(WebFrame::OnNavigationRequest), NULL, this);
@@ -349,6 +416,8 @@
             wxCommandEventHandler(WebFrame::OnSelectAll),  NULL, this );
     Connect(loadscheme->GetId(), wxEVT_COMMAND_MENU_SELECTED,
             wxCommandEventHandler(WebFrame::OnLoadScheme),  NULL, this );
+    Connect(m_find->GetId(), wxEVT_COMMAND_MENU_SELECTED,
+            wxCommandEventHandler(WebFrame::OnFind),  NULL, this );
 
     //Connect the idle events
     Connect(wxID_ANY, wxEVT_IDLE, wxIdleEventHandler(WebFrame::OnIdle), NULL, this);
@@ -494,6 +563,119 @@
     m_browser->LoadURL(path);
 }
 
+void WebFrame::OnFind(wxCommandEvent& WXUNUSED(evt))
+{
+    wxString value = m_browser->GetSelectedText();
+    if(value.Len() > 150)
+    {
+        value.Truncate(150);
+    }
+    m_find_ctrl->SetValue(value);
+    if(!m_find_toolbar->IsShown()){
+        m_find_toolbar->Show(true);
+        SendSizeEvent();
+    }
+    m_find_ctrl->SelectAll();
+}
+
+void WebFrame::OnFindDone(wxCommandEvent& WXUNUSED(evt))
+{
+    m_find_toolbar->Show(false);
+    SendSizeEvent();
+}
+
+void WebFrame::OnFindText(wxCommandEvent& evt)
+{
+    int flag = m_findFlags;
+
+    if(m_find_toolbar_previous->GetId() == evt.GetId())
+    {
+        flag |= wxWEB_VIEW_FIND_BACKWARDS;
+    }
+
+    wxString find_text = m_find_ctrl->GetValue();
+    long count = m_browser->Find(find_text,flag);
+
+    if(m_findText != find_text)
+    {
+        m_findCount = count;
+        m_findText = find_text;
+    }
+
+    if(count != wxNOT_FOUND || find_text.IsEmpty())
+    {
+        m_find_ctrl->SetBackgroundColour(*wxWHITE);
+    }
+    else
+    {
+        m_find_ctrl->SetBackgroundColour(wxColour(255,101,101));
+    }
+
+    m_find_ctrl->Refresh();
+
+    //Log the result, note that count is zero indexed.
+    if(count != m_findCount)
+    {
+        count++;
+    }
+    wxLogMessage("Searching for:%s  Matches:%i/%i",m_findText.c_str(),count,m_findCount);
+}
+
+void WebFrame::OnFindOptions(wxCommandEvent& WXUNUSED(evt))
+{
+    wxMenu* menu = new wxMenu;
+    wxMenuItem* wrap = menu->AppendCheckItem(wxID_ANY,"Wrap");
+    wxMenuItem* match_case = menu->AppendCheckItem(wxID_ANY,"Match Case");
+    wxMenuItem* entire_word = menu->AppendCheckItem(wxID_ANY,"Entire Word");
+    wxMenuItem* highlight = menu->AppendCheckItem(wxID_ANY,"Highlight");
+    // Do checks.
+    menu->Check(wrap->GetId(),(m_findFlags & wxWEB_VIEW_FIND_WRAP) != 0);
+    menu->Check(match_case->GetId(),(m_findFlags & wxWEB_VIEW_FIND_MATCH_CASE) != 0);
+    menu->Check(entire_word->GetId(),(m_findFlags & wxWEB_VIEW_FIND_ENTIRE_WORD) != 0);
+    menu->Check(highlight->GetId(),(m_findFlags & wxWEB_VIEW_FIND_HIGHLIGHT_RESULT) != 0);
+    // Make the popup point.
+    wxPoint pt = m_find_toolbar->ScreenToClient(m_find_toolbar->GetScreenPosition());
+    pt.y += m_find_toolbar->GetClientSize().GetHeight()-1;
+    pt.x += (m_find_toolbar->GetToolSize().GetWidth()*3)+m_find_ctrl->GetSize().GetWidth()+(3*m_find_toolbar->GetToolSeparation());
+    // Popup menu and get selection.
+    int index = m_find_toolbar->GetPopupMenuSelectionFromUser(*menu,pt);
+    // Update find flag.
+    if(index != wxID_NONE){
+        int flags = wxWEB_VIEW_FIND_DEFAULT;
+        if(menu->IsChecked(wrap->GetId()))
+        {
+            flags |= wxWEB_VIEW_FIND_WRAP;
+        }
+        if(menu->IsChecked(match_case->GetId()))
+        {
+            flags |= wxWEB_VIEW_FIND_MATCH_CASE;
+        }
+        if(menu->IsChecked(entire_word->GetId()))
+        {
+            flags |= wxWEB_VIEW_FIND_ENTIRE_WORD;
+        }
+        //check if there is any change.
+        if(((m_findFlags & wxWEB_VIEW_FIND_HIGHLIGHT_RESULT) == 0) != !menu->IsChecked(highlight->GetId()))
+        {
+            if((m_findFlags & wxWEB_VIEW_FIND_HIGHLIGHT_RESULT) == 0)
+            {
+                flags |= wxWEB_VIEW_FIND_HIGHLIGHT_RESULT;
+            }
+            m_findFlags = flags;
+            //send dummy event to show highlight now.
+            wxCommandEvent evt(wxEVT_COMMAND_TOOL_CLICKED,m_find_toolbar_next->GetId());
+            HandleWindowEvent(evt);
+        }
+        else if(menu->IsChecked(highlight->GetId()))
+        {
+            flags |= wxWEB_VIEW_FIND_HIGHLIGHT_RESULT;
+        }
+        m_findFlags = flags;
+    }
+    delete menu;
+}
+
+
 /**
   * Callback invoked when there is a request to load a new page (for instance
   * when the user clicks a link)
Index: src/msw/webview_ie.cpp
===================================================================
--- src/msw/webview_ie.cpp	(revision 70614)
+++ src/msw/webview_ie.cpp	(working copy)
@@ -68,6 +68,7 @@
     m_historyEnabled = true;
     m_historyPosition = -1;
     m_zoomType = wxWEB_VIEW_ZOOM_TYPE_TEXT;
+    FindClear();
 
     if (::CoCreateInstance(CLSID_WebBrowser, NULL,
                            CLSCTX_INPROC_SERVER, // CLSCTX_INPROC,
@@ -101,6 +102,7 @@
     }
 
     m_uiHandler->Release();
+    FindClear();
 }
 
 void wxWebViewIE::LoadURL(const wxString& url)
@@ -537,6 +539,7 @@
 {
     return CanExecCommand("Copy");
 }
+
 bool wxWebViewIE::CanPaste() const
 {
     return CanExecCommand("Paste");
@@ -561,6 +564,7 @@
 {
     return CanExecCommand("Undo");
 }
+
 bool wxWebViewIE::CanRedo() const
 {
     return CanExecCommand("Redo");
@@ -576,6 +580,53 @@
     ExecCommand("Redo");
 }
 
+long wxWebViewIE::Find(const wxString& text, int flags)
+{
+    //If the text is empty then we clear.
+    if(text.IsEmpty())
+    {
+        ClearSelection();
+        if(m_findFlags & wxWEB_VIEW_FIND_HIGHLIGHT_RESULT)
+        {
+            FindInternal(m_findText,(m_findFlags &~ wxWEB_VIEW_FIND_HIGHLIGHT_RESULT),false,true);
+        }
+        FindClear();
+        return wxNOT_FOUND;
+    }
+    //Have we done this search before?
+    if(m_findText == text)
+    {
+        //Just do a highlight?
+        if((flags & wxWEB_VIEW_FIND_HIGHLIGHT_RESULT) != (m_findFlags & wxWEB_VIEW_FIND_HIGHLIGHT_RESULT))
+        {
+            m_findFlags = flags;
+            if(!m_findPointers.empty())
+            {
+                FindInternal(m_findText,m_findFlags,false,(flags & wxWEB_VIEW_FIND_HIGHLIGHT_RESULT) == 0);
+            }
+            return m_findPosition;
+        }
+        else if(((m_findFlags&wxWEB_VIEW_FIND_ENTIRE_WORD) == (flags&wxWEB_VIEW_FIND_ENTIRE_WORD)) && ((m_findFlags&wxWEB_VIEW_FIND_MATCH_CASE) == (flags&wxWEB_VIEW_FIND_MATCH_CASE)))
+        {
+            m_findFlags = flags;
+            return FindNext(((flags & wxWEB_VIEW_FIND_BACKWARDS) ? -1 : 1));
+        }
+    }
+    //Remove old highlight if any.
+    if(m_findFlags & wxWEB_VIEW_FIND_HIGHLIGHT_RESULT)
+    {
+        FindInternal(m_findText,(m_findFlags &~ wxWEB_VIEW_FIND_HIGHLIGHT_RESULT),false,true);
+    }
+    //Reset find variables.
+    FindClear();
+    ClearSelection();
+    m_findText = text;
+    m_findFlags = flags;
+    //find the text and return count.
+    FindInternal(text,flags,true);
+    return m_findPointers.empty() ? wxNOT_FOUND : m_findPointers.size();
+}
+
 void wxWebViewIE::SetEditable(bool enable)
 {
     IHTMLDocument2* document = GetDocument();
@@ -792,13 +843,232 @@
     return document;
 }
 
+bool wxWebViewIE::IsElementVisible(IHTMLElement* elm)
+{
+	IHTMLCurrentStyle* style;
+	IHTMLElement *elm1 = elm;
+	IHTMLElement2 *elm2;
+	BSTR tmp_bstr;
+	bool is_visible = true;
+	//This method is not perfect but it does discover most of the hidden elements.
+	//so if a better solution is found, then please do improve.
+	while(elm1)
+	{
+        if(SUCCEEDED(elm1->QueryInterface(IID_IHTMLElement2, (void**) &elm2)))
+        {
+            if(SUCCEEDED(elm2->get_currentStyle(&style)))
+            {
+                //Check if the object has the style display:none.
+                if((style->get_display(&tmp_bstr) != S_OK) || (tmp_bstr != NULL && (_wcsicmp(tmp_bstr, L"none") == 0)))
+                    is_visible = false;
+                //Check if the object has the style visibility:hidden.
+                if(is_visible && (style->get_visibility(&tmp_bstr) != S_OK) || (tmp_bstr != NULL && _wcsicmp(tmp_bstr, L"hidden") == 0))
+                    is_visible = false;
+                style->Release();
+            }
+            elm2->Release();
+        }
+
+        //Lets check the object's parent element.
+        IHTMLElement* parent;
+        if(is_visible && SUCCEEDED(elm1->get_parentElement(&parent)))
+        {
+            elm1->Release();
+            elm1 = parent;
+        }
+        else{
+            elm1->Release();
+            break;
+        }
+	}
+	return is_visible;
+}
+
+void wxWebViewIE::FindInternal(const wxString& text, int flags, bool add_pointers, bool remove_highligt)
+{
+    IMarkupServices *pIMS;
+    IMarkupContainer *pIMC;
+    IMarkupPointer *ptrBegin, *ptrEnd;
+    IHTMLElement* elm;
+    long find_flag = 0;
+    IHTMLDocument2 *document = GetDocument();
+    //This function does the acutal work.
+    if(SUCCEEDED(document->QueryInterface(IID_IMarkupServices,(void **)&pIMS)))
+    {
+        if(SUCCEEDED(document->QueryInterface(IID_IMarkupContainer,(void **)&pIMC)))
+        {
+            BSTR attr_bstr = SysAllocString(L"style=\"background-color:#ffff00\"");
+            BSTR text_bstr = SysAllocString(text.wc_str());
+            pIMS->CreateMarkupPointer(&ptrBegin);
+            pIMS->CreateMarkupPointer(&ptrEnd);
+
+            ptrBegin->SetGravity(POINTER_GRAVITY_Right);
+            ptrBegin->MoveToContainer(pIMC, TRUE);
+            //Create the find flag from the wx one.
+            if(flags & wxWEB_VIEW_FIND_ENTIRE_WORD)
+            {
+                find_flag |= FINDTEXT_WHOLEWORD;
+            }
+            if(flags & wxWEB_VIEW_FIND_MATCH_CASE)
+            {
+                find_flag |= FINDTEXT_MATCHCASE;
+            }
+
+            //A little speed-up to avoid to re-alloc in the positions vector.
+            if(text.Len() < 3 && m_findPointers.capacity() < 500)
+            {
+               m_findPointers.reserve(text.Len() == 1 ? 1000 : 500);
+            }
+
+            while(ptrBegin->FindText(text_bstr, find_flag, ptrEnd, NULL) == S_OK)
+            {
+                if(ptrBegin->CurrentScope(&elm) == S_OK)
+                {
+                    if(IsElementVisible(elm))
+                    {
+                        //Highlight the word if the flag was set.
+                        if(flags & wxWEB_VIEW_FIND_HIGHLIGHT_RESULT)
+                        {
+                            IHTMLElement* pFontEl;
+                            pIMS->CreateElement(TAGID_FONT, attr_bstr, &pFontEl);
+                            pIMS->InsertElement(pFontEl, ptrBegin, ptrEnd);
+                        }
+                        if(remove_highligt)
+                        {
+                            IHTMLElement* pFontEl;
+                            ptrBegin->CurrentScope(&pFontEl);
+                            pIMS->RemoveElement(pFontEl);
+                            pFontEl->Release();
+                        }
+                        if(add_pointers)
+                        {
+                            IMarkupPointer *cptrBegin, *cptrEnd;
+                            pIMS->CreateMarkupPointer(&cptrBegin);
+                            pIMS->CreateMarkupPointer(&cptrEnd);
+                            cptrBegin->MoveToPointer(ptrBegin);
+                            cptrEnd->MoveToPointer(ptrEnd);
+                            m_findPointers.push_back(wxFindPointers(cptrBegin,cptrEnd));
+                        }
+                    }
+                    elm->Release();
+                }
+                ptrBegin->MoveToPointer(ptrEnd);
+            }
+            //Clean up.
+            SysFreeString(text_bstr);
+            SysFreeString(attr_bstr);
+            pIMC->Release();
+            ptrBegin->Release();
+            ptrEnd->Release();
+        }
+        pIMS->Release();
+    }
+    document->Release();
+}
+
+long wxWebViewIE::FindNext(int direction)
+{
+    //Don't bother if we have no pointers set.
+    if(m_findPointers.empty())
+    {
+        return wxNOT_FOUND;
+    }
+    //Manage the find position and do some checks.
+    if(direction > 0)
+    {
+        m_findPosition++;
+    }
+    else
+    {
+        m_findPosition--;
+    }
+
+    if(m_findPosition >= (signed)m_findPointers.size())
+    {
+        if(m_findFlags & wxWEB_VIEW_FIND_WRAP)
+        {
+            m_findPosition = 0;
+        }
+        else
+        {
+            m_findPosition--;
+            return wxNOT_FOUND;
+        }
+    }
+    else if(m_findPosition < 0)
+    {
+        if(m_findFlags & wxWEB_VIEW_FIND_WRAP)
+        {
+            m_findPosition = m_findPointers.size()-1;
+        }
+        else
+        {
+            m_findPosition++;
+            return wxNOT_FOUND;
+        }
+    }
+    //some variables to use later on.
+    IHTMLElement *body_element;
+    IHTMLBodyElement *body;
+    IHTMLTxtRange *range = NULL;
+    IMarkupServices *pIMS;
+    IHTMLDocument2 *document = GetDocument();
+    long ret = -1;
+    //Now try to create a range from the body.
+    if(SUCCEEDED(document->get_body(&body_element)))
+    {
+        if(SUCCEEDED(body_element->QueryInterface(IID_IHTMLBodyElement,(void**)&body)))
+        {
+            if(SUCCEEDED(body->createTextRange(&range)))
+            {
+                //So far so good, now we try to position our find pointers.
+                if(SUCCEEDED(document->QueryInterface(IID_IMarkupServices,(void **)&pIMS)))
+                {
+                    IMarkupPointer *begin = m_findPointers[m_findPosition].begin, *end = m_findPointers[m_findPosition].end;
+                    if(pIMS->MoveRangeToPointers(begin,end,range) == S_OK && range->select() == S_OK)
+                    {
+                        ret = m_findPosition;
+                    }
+                    pIMS->Release();
+                }
+                range->Release();
+            }
+            body->Release();
+        }
+        body_element->Release();
+    }
+    document->Release();
+    return ret;
+}
+
+void wxWebViewIE::FindClear()
+{
+    //Reset find variables.
+    m_findText.Empty();
+    m_findFlags = wxWEB_VIEW_FIND_DEFAULT;
+    m_findPosition = -1;
+
+    //The m_findPointers contains pointers for the found text.
+    //Since it uses ref counting we call release on the pointers first
+    //before we remove them from the vector. In other words do not just
+    //remove elements from m_findPointers without calling release first
+    //or you will get a memory leak.
+    size_t count = m_findPointers.size();
+    for(size_t i = 0; i < count; i++)
+    {
+        m_findPointers[i].begin->Release();
+        m_findPointers[i].end->Release();
+    }
+    m_findPointers.clear();
+}
+
 bool wxWebViewIE::EnableControlFeature(long flag, bool enable)
 {
 #if wxUSE_DYNLIB_CLASS
 
     wxDynamicLibrary urlMon(wxT("urlmon.dll"));
-    if( urlMon.IsLoaded() && 
-        urlMon.HasSymbol("CoInternetSetFeatureEnabled") && 
+    if( urlMon.IsLoaded() &&
+        urlMon.HasSymbol("CoInternetSetFeatureEnabled") &&
         urlMon.HasSymbol("CoInternetIsFeatureEnabled"))
     {
         typedef HRESULT (WINAPI *CoInternetSetFeatureEnabled_t)(DWORD, DWORD, BOOL);
@@ -925,6 +1195,8 @@
             }
             //Reset as we are done now
             m_historyLoadingFromList = false;
+            //Reset the find values.
+            FindClear();
             // TODO: set target parameter if possible
             wxString target = wxEmptyString;
             wxWebViewEvent event(wxEVT_COMMAND_WEB_VIEW_LOADED, GetId(),
@@ -1201,7 +1473,7 @@
     return S_OK;
 }
 
-wxIEContainer::wxIEContainer(wxWindow *parent, REFIID iid, IUnknown *pUnk, 
+wxIEContainer::wxIEContainer(wxWindow *parent, REFIID iid, IUnknown *pUnk,
                              DocHostUIHandler* uiHandler) :
     wxActiveXContainer(parent,iid,pUnk)
 {
@@ -1212,7 +1484,7 @@
 {
 }
 
-bool wxIEContainer::QueryClientSiteInterface(REFIID iid, void **_interface, 
+bool wxIEContainer::QueryClientSiteInterface(REFIID iid, void **_interface,
                                              const char *&desc)
 {
     if (m_uiHandler && IsEqualIID(iid, wxIID_IDocHostUIHandler))
@@ -1224,8 +1496,8 @@
     return false;
 }
 
-HRESULT DocHostUIHandler::ShowContextMenu(DWORD dwID, POINT *ppt, 
-                                          IUnknown *pcmdtReserved, 
+HRESULT DocHostUIHandler::ShowContextMenu(DWORD dwID, POINT *ppt,
+                                          IUnknown *pcmdtReserved,
                                           IDispatch *pdispReserved)
 {
     wxUnusedVar(dwID);
@@ -1237,13 +1509,13 @@
 
 HRESULT DocHostUIHandler::GetHostInfo(DOCHOSTUIINFO *pInfo)
 {
-    //don't show 3d border and ebales themes.
+    //don't show 3d border and enable themes.
     pInfo->dwFlags = pInfo->dwFlags | DOCHOSTUIFLAG_NO3DBORDER | DOCHOSTUIFLAG_THEME;
     return S_OK;
 }
 
 HRESULT DocHostUIHandler::ShowUI(DWORD dwID,
-                                 IOleInPlaceActiveObject *pActiveObject, 
+                                 IOleInPlaceActiveObject *pActiveObject,
                                  IOleCommandTarget *pCommandTarget,
                                  IOleInPlaceFrame *pFrame,
                                  IOleInPlaceUIWindow *pDoc)
@@ -1284,7 +1556,7 @@
     return E_NOTIMPL;
 }
 
-HRESULT DocHostUIHandler::ResizeBorder(LPCRECT prcBorder, 
+HRESULT DocHostUIHandler::ResizeBorder(LPCRECT prcBorder,
                                        IOleInPlaceUIWindow *pUIWindow,
                                        BOOL fFrameWindow)
 {
@@ -1294,7 +1566,7 @@
     return E_NOTIMPL;
 }
 
-HRESULT DocHostUIHandler::TranslateAccelerator(LPMSG lpMsg, 
+HRESULT DocHostUIHandler::TranslateAccelerator(LPMSG lpMsg,
                                                const GUID *pguidCmdGroup,
                                                DWORD nCmdID)
 {
