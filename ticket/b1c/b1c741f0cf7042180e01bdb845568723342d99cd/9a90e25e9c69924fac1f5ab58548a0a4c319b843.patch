Index: wxX11.spec
===================================================================
--- wxX11.spec	(revision 61424)
+++ wxX11.spec	(working copy)
@@ -135,6 +135,7 @@
 # --- wxBase headers list begins here ---
 cat <<EOF >wxbase-headers.files
 wx/afterstd.h
+wx/any.h
 wx/anystr.h
 wx/app.h
 wx/apptrait.h
Index: Makefile.in
===================================================================
--- Makefile.in	(revision 61424)
+++ Makefile.in	(working copy)
@@ -310,6 +310,7 @@
 PLUGINS_INST_DIR = $(libdir)/wx/$(PLUGIN_VERSION0)
 ALL_BASE_HEADERS =  \
 	wx/afterstd.h \
+	wx/any.h \
 	wx/anystr.h \
 	wx/app.h \
 	wx/apptrait.h \
@@ -470,6 +471,7 @@
 	$(ALL_GUI_HEADERS)
 ALL_PORTS_BASE_HEADERS =  \
 	wx/afterstd.h \
+	wx/any.h \
 	wx/anystr.h \
 	wx/app.h \
 	wx/apptrait.h \
@@ -665,6 +667,7 @@
 	wx/xml/xml.h \
 	wx/xtixml.h
 ALL_BASE_SOURCES =  \
+	src/common/any.cpp \
 	src/common/appbase.cpp \
 	src/common/arcall.cpp \
 	src/common/arcfind.cpp \
@@ -853,6 +856,7 @@
 	-I$(top_srcdir)/src/stc/scintilla/src -D__WX__ -DSCI_LEXER -DLINK_LEXERS \
 	$(PIC_FLAG) $(CPPFLAGS) $(OBJCXXFLAGS)
 MONODLL_OBJECTS =  \
+	monodll_any.o \
 	monodll_appbase.o \
 	monodll_arcall.o \
 	monodll_arcfind.o \
@@ -978,6 +982,7 @@
 	-I$(top_srcdir)/src/stc/scintilla/src -D__WX__ -DSCI_LEXER -DLINK_LEXERS \
 	$(CPPFLAGS) $(OBJCXXFLAGS)
 MONOLIB_OBJECTS =  \
+	monolib_any.o \
 	monolib_appbase.o \
 	monolib_arcall.o \
 	monolib_arcfind.o \
@@ -1100,6 +1105,7 @@
 	$(CPPFLAGS) $(OBJCXXFLAGS)
 BASEDLL_OBJECTS =  \
 	$(__basedll___win32rc) \
+	basedll_any.o \
 	basedll_appbase.o \
 	basedll_arcall.o \
 	basedll_arcfind.o \
@@ -1204,6 +1210,7 @@
 	$(__INC_JPEG_p) $(__INC_PNG_p) $(__INC_ZLIB_p) $(__INC_REGEX_p) \
 	$(__INC_EXPAT_p) -DwxUSE_GUI=0 -DwxUSE_BASE=1 $(CPPFLAGS) $(OBJCXXFLAGS)
 BASELIB_OBJECTS =  \
+	baselib_any.o \
 	baselib_appbase.o \
 	baselib_arcall.o \
 	baselib_arcfind.o \
@@ -14028,6 +14035,9 @@
 wxscintilla_XPM.o: $(srcdir)/src/stc/scintilla/src/XPM.cxx
 	$(CXXC) -c -o $@ $(WXSCINTILLA_CXXFLAGS) $(srcdir)/src/stc/scintilla/src/XPM.cxx
 
+monodll_any.o: $(srcdir)/src/common/any.cpp $(MONODLL_ODEP)
+	$(CXXC) -c -o $@ $(MONODLL_CXXFLAGS) $(srcdir)/src/common/any.cpp
+
 monodll_appbase.o: $(srcdir)/src/common/appbase.cpp $(MONODLL_ODEP)
 	$(CXXC) -c -o $@ $(MONODLL_CXXFLAGS) $(srcdir)/src/common/appbase.cpp
 
@@ -18750,6 +18760,9 @@
 monodll_version_rc.o: $(srcdir)/src/msw/version.rc $(MONODLL_ODEP)
 	$(WINDRES) -i$< -o$@    --define __WX$(TOOLKIT)__ $(__WXUNIV_DEFINE_p_58)  $(__EXCEPTIONS_DEFINE_p_57) $(__RTTI_DEFINE_p_57) $(__THREAD_DEFINE_p_57)   --define WXBUILDING --define WXDLLNAME=$(WXDLLNAMEPREFIXGUI)$(WXUNICODEFLAG)$(WXDEBUGFLAG)$(WX_LIB_FLAVOUR)$(WXCOMPILER)$(VENDORTAG)$(WXDLLVERSIONTAG) $(__RCDEFDIR_p) --include-dir $(top_srcdir)/include $(__INC_TIFF_BUILD_p_58) $(__INC_TIFF_p_58) $(__INC_JPEG_p_58) $(__INC_PNG_p_57) $(__INC_ZLIB_p_59) $(__INC_REGEX_p_57) $(__INC_EXPAT_p_57) --define wxUSE_BASE=1 --define WXMAKINGDLL --include-dir $(top_srcdir)/src/stc/scintilla/include --include-dir $(top_srcdir)/src/stc/scintilla/src --define __WX__ --define SCI_LEXER --define LINK_LEXERS
 
+monolib_any.o: $(srcdir)/src/common/any.cpp $(MONOLIB_ODEP)
+	$(CXXC) -c -o $@ $(MONOLIB_CXXFLAGS) $(srcdir)/src/common/any.cpp
+
 monolib_appbase.o: $(srcdir)/src/common/appbase.cpp $(MONOLIB_ODEP)
 	$(CXXC) -c -o $@ $(MONOLIB_CXXFLAGS) $(srcdir)/src/common/appbase.cpp
 
@@ -23472,6 +23485,9 @@
 basedll_version_rc.o: $(srcdir)/src/msw/version.rc $(BASEDLL_ODEP)
 	$(WINDRES) -i$< -o$@    --define __WX$(TOOLKIT)__ $(__WXUNIV_DEFINE_p_58)  $(__EXCEPTIONS_DEFINE_p_57) $(__RTTI_DEFINE_p_57) $(__THREAD_DEFINE_p_57)   --define WXBUILDING --define WXDLLNAME=$(WXDLLNAMEPREFIX)$(WXUNICODEFLAG)$(WXDEBUGFLAG)$(WX_LIB_FLAVOUR)$(WXCOMPILER)$(VENDORTAG)$(WXDLLVERSIONTAG) $(__RCDEFDIR_p) --include-dir $(top_srcdir)/include $(__INC_TIFF_BUILD_p_58) $(__INC_TIFF_p_58) $(__INC_JPEG_p_58) $(__INC_PNG_p_57) $(__INC_ZLIB_p_59) $(__INC_REGEX_p_57) $(__INC_EXPAT_p_57) --define wxUSE_GUI=0 --define WXMAKINGDLL_BASE --define wxUSE_BASE=1
 
+basedll_any.o: $(srcdir)/src/common/any.cpp $(BASEDLL_ODEP)
+	$(CXXC) -c -o $@ $(BASEDLL_CXXFLAGS) $(srcdir)/src/common/any.cpp
+
 basedll_appbase.o: $(srcdir)/src/common/appbase.cpp $(BASEDLL_ODEP)
 	$(CXXC) -c -o $@ $(BASEDLL_CXXFLAGS) $(srcdir)/src/common/appbase.cpp
 
@@ -23937,6 +23953,9 @@
 @COND_PLATFORM_MACOSX_1@basedll_utilsunx.o: $(srcdir)/src/unix/utilsunx.cpp $(BASEDLL_ODEP)
 @COND_PLATFORM_MACOSX_1@	$(CXXC) -c -o $@ $(BASEDLL_CXXFLAGS) $(srcdir)/src/unix/utilsunx.cpp
 
+baselib_any.o: $(srcdir)/src/common/any.cpp $(BASELIB_ODEP)
+	$(CXXC) -c -o $@ $(BASELIB_CXXFLAGS) $(srcdir)/src/common/any.cpp
+
 baselib_appbase.o: $(srcdir)/src/common/appbase.cpp $(BASELIB_ODEP)
 	$(CXXC) -c -o $@ $(BASELIB_CXXFLAGS) $(srcdir)/src/common/appbase.cpp
 
Index: wxMotif.spec
===================================================================
--- wxMotif.spec	(revision 61424)
+++ wxMotif.spec	(working copy)
@@ -111,6 +111,7 @@
 # --- wxBase headers list begins here ---
 cat <<EOF >wxbase-headers.files
 wx/afterstd.h
+wx/any.h
 wx/anystr.h
 wx/app.h
 wx/apptrait.h
Index: src/common/any.cpp
===================================================================
--- src/common/any.cpp	(revision 0)
+++ src/common/any.cpp	(revision 0)
@@ -0,0 +1,410 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        src/common/any.cpp
+// Purpose:     wxAny class, container for any type
+// Author:      Jaakko Salli
+// Modified by:
+// Created:     07/05/2009
+// RCS-ID:      $Id$
+// Copyright:   (c) wxWidgets team
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#include "wx/any.h"
+
+#if wxUSE_ANY
+
+#ifndef WX_PRECOMP
+    #include "wx/math.h"
+    #include "wx/crt.h"
+#endif
+
+#include "wx/vector.h"
+#include "wx/module.h"
+
+using namespace wxPrivate;
+
+//-------------------------------------------------------------------------
+// wxAnyValueTypeGlobals
+//-------------------------------------------------------------------------
+
+//
+// Helper class to manage wxAnyValueType instances and other
+// related global variables.
+//
+// NB: We really need to have wxAnyValueType instances allocated
+//     in heap. They are stored as static template member variables,
+//     and with them we just can't be too careful (eg. not allocating
+//     them in heap broke the type identification in GCC).
+//
+class wxAnyValueTypeGlobals
+{
+public:
+    wxAnyValueTypeGlobals()
+    {
+    }
+    ~wxAnyValueTypeGlobals()
+    {
+        for ( size_t i=0; i<m_valueTypes.size(); i++ )
+            delete m_valueTypes[i];
+    }
+
+    void RegisterValueType(wxAnyValueType* valueType)
+    {
+        m_valueTypes.push_back(valueType);
+    }
+
+private:
+    wxVector<wxAnyValueType*>   m_valueTypes;
+};
+
+static wxAnyValueTypeGlobals* g_wxAnyValueTypeGlobals = NULL;
+
+//
+// This class is to make sure that wxAnyValueType instances
+// etc. get freed correctly. We must use a separate wxAnyValueTypeGlobals
+// because wxModule itself is instantiated too late.
+//
+class wxAnyValueTypeGlobalsManager : public wxModule
+{
+    DECLARE_DYNAMIC_CLASS(wxAnyValueTypeGlobalsManager)
+public:
+    wxAnyValueTypeGlobalsManager() : wxModule() { }
+    virtual ~wxAnyValueTypeGlobalsManager() { }
+
+    virtual bool OnInit()
+    {
+        return true;
+    }
+    virtual void OnExit()
+    {
+        delete g_wxAnyValueTypeGlobals;
+        g_wxAnyValueTypeGlobals = NULL;
+    }
+private:
+};
+
+IMPLEMENT_DYNAMIC_CLASS(wxAnyValueTypeGlobalsManager, wxModule)
+
+
+//-------------------------------------------------------------------------
+// wxAnyValueType
+//-------------------------------------------------------------------------
+
+wxAnyValueType::wxAnyValueType()
+{
+    if ( !g_wxAnyValueTypeGlobals )
+        g_wxAnyValueTypeGlobals = new wxAnyValueTypeGlobals();
+
+    g_wxAnyValueTypeGlobals->RegisterValueType(this);
+}
+
+//-------------------------------------------------------------------------
+// wxAny
+//-------------------------------------------------------------------------
+
+void wxAny::AssignAny(const wxAny &any)
+{
+    if ( !any.m_type->IsSameType(m_type) )
+    {
+        m_type->DeleteValue(m_buffer);
+        m_type = any.m_type;
+    }
+    m_type->CopyBuffer(any.m_buffer, m_buffer);
+}
+
+//-------------------------------------------------------------------------
+// Dynamic conversion member functions
+//-------------------------------------------------------------------------
+
+//
+// Define integer minimum and maximum as helpers
+#ifdef wxLongLong_t
+const wxAnyBaseIntType UseIntMin = wxINT64_MIN;
+const wxAnyBaseUintType UseIntMax = wxINT64_MAX;
+const wxAnyBaseUintType UseUintMax = wxUINT64_MAX;
+#else
+const wxAnyBaseIntType UseIntMin = LONG_MIN;
+const wxAnyBaseUintType UseUintMax = ULONG_MAX;
+const wxAnyBaseUintType UseIntMax = LONG_MAX;
+#endif
+
+const double UseIntMinF = static_cast<double>(UseIntMin);
+#ifndef __VISUALC6__
+const double UseIntMaxF = static_cast<double>(UseIntMax);
+const double UseUintMaxF = static_cast<double>(UseUintMax);
+#else
+// VC6 doesn't implement conversion from unsigned __int64 to double
+const wxAnyBaseIntType UseIntMax0 = static_cast<wxAnyBaseIntType>(UseIntMax);
+const wxAnyBaseIntType UseUintMax0 = static_cast<wxAnyBaseIntType>(UseUintMax);
+const double UseIntMaxF = static_cast<double>(UseIntMax0);
+const double UseUintMaxF = static_cast<double>(UseUintMax0);
+#endif
+
+
+bool wxAnyValueTypeImplInt::ConvertValue(const wxAnyValueBuffer& src,
+                                         wxAnyValueType* dstType,
+                                         wxAnyValueBuffer& dst) const
+{
+    wxAnyBaseIntType value = GetValue(src);
+    if ( wxANY_VALUE_TYPE_CHECK_TYPE(dstType, wxString) )
+    {
+#ifdef wxLongLong_t
+        wxLongLong ll(value);
+        wxString s = ll.ToString();
+#else
+        wxString s = wxString::Format(wxS("%ld"), (long)value);
+#endif
+        wxAnyValueTypeImpl<wxString>::SetValue(s, dst);
+    }
+    else if ( wxANY_VALUE_TYPE_CHECK_TYPE(dstType, wxAnyBaseUintType) )
+    {
+        if ( value < 0 )
+            return false;
+        wxAnyBaseUintType ul = (wxAnyBaseUintType) value;
+        wxAnyValueTypeImplUint::SetValue(ul, dst);
+    }
+    else if ( wxANY_VALUE_TYPE_CHECK_TYPE(dstType, double) )
+    {
+        double value2 = static_cast<double>(value);
+        wxAnyValueTypeImplDouble::SetValue(value2, dst);
+    }
+    else if ( wxANY_VALUE_TYPE_CHECK_TYPE(dstType, bool) )
+    {
+        bool value2 = value ? true : false;
+        wxAnyValueTypeImpl<bool>::SetValue(value2, dst);
+    }
+    else
+        return false;
+
+    return true;
+}
+
+bool wxAnyValueTypeImplUint::ConvertValue(const wxAnyValueBuffer& src,
+                                          wxAnyValueType* dstType,
+                                          wxAnyValueBuffer& dst) const
+{
+    wxAnyBaseUintType value = GetValue(src);
+    if ( wxANY_VALUE_TYPE_CHECK_TYPE(dstType, wxString) )
+    {
+#ifdef wxLongLong_t
+        wxULongLong ull(value);
+        wxString s = ull.ToString();
+#else
+        wxString s = wxString::Format(wxS("%lu"), (long)value);
+#endif
+        wxAnyValueTypeImpl<wxString>::SetValue(s, dst);
+    }
+    else if ( wxANY_VALUE_TYPE_CHECK_TYPE(dstType, wxAnyBaseIntType) )
+    {
+        if ( value > UseIntMax )
+            return false;
+        wxAnyBaseIntType l = (wxAnyBaseIntType) value;
+        wxAnyValueTypeImplInt::SetValue(l, dst);
+    }
+    else if ( wxANY_VALUE_TYPE_CHECK_TYPE(dstType, double) )
+    {
+#ifndef __VISUALC6__
+        double value2 = static_cast<double>(value);
+#else
+        // VC6 doesn't implement conversion from unsigned __int64 to double
+        wxAnyBaseIntType value0 = static_cast<wxAnyBaseIntType>(value);
+        double value2 = static_cast<double>(value0);
+#endif
+        wxAnyValueTypeImplDouble::SetValue(value2, dst);
+    }
+    else if ( wxANY_VALUE_TYPE_CHECK_TYPE(dstType, bool) )
+    {
+        bool value2 = value ? true : false;
+        wxAnyValueTypeImpl<bool>::SetValue(value2, dst);
+    }
+    else
+        return false;
+
+    return true;
+}
+
+bool wxAnyValueTypeImplString::ConvertValue(const wxAnyValueBuffer& src,
+                                            wxAnyValueType* dstType,
+                                            wxAnyValueBuffer& dst) const
+{
+    wxString value = GetValue(src);
+    if ( wxANY_VALUE_TYPE_CHECK_TYPE(dstType, wxAnyBaseIntType) )
+    {
+        wxAnyBaseIntType value2;
+#ifdef wxLongLong_t
+        if ( !value.ToLongLong(&value2) )
+#else
+        if ( !value.ToLong(&value2) )
+#endif
+            return false;
+        wxAnyValueTypeImplInt::SetValue(value2, dst);
+    }
+    else if ( wxANY_VALUE_TYPE_CHECK_TYPE(dstType, wxAnyBaseUintType) )
+    {
+        wxAnyBaseUintType value2;
+#ifdef wxLongLong_t
+        if ( !value.ToULongLong(&value2) )
+#else
+        if ( !value.ToULong(&value2) )
+#endif
+            return false;
+        wxAnyValueTypeImplUint::SetValue(value2, dst);
+    }
+    else if ( wxANY_VALUE_TYPE_CHECK_TYPE(dstType, double) )
+    {
+        double value2;
+        if ( !value.ToDouble(&value2) )
+            return false;
+        wxAnyValueTypeImplDouble::SetValue(value2, dst);
+    }
+    else if ( wxANY_VALUE_TYPE_CHECK_TYPE(dstType, bool) )
+    {
+        bool value2;
+        value.MakeLower();
+        if ( value == wxS("true") ||
+             value == wxS("yes") ||
+             value == wxS('1') )
+            value2 = true;
+        else if ( value == wxS("false") ||
+                  value == wxS("no") ||
+                  value == wxS('0') )
+            value2 = false;
+        else
+            return false;
+
+        wxAnyValueTypeImpl<bool>::SetValue(value2, dst);
+    }
+    else
+        return false;
+
+    return true;
+}
+
+bool wxAnyValueTypeImpl<bool>::ConvertValue(const wxAnyValueBuffer& src,
+                                            wxAnyValueType* dstType,
+                                            wxAnyValueBuffer& dst) const
+{
+    bool value = GetValue(src);
+    if ( wxANY_VALUE_TYPE_CHECK_TYPE(dstType, wxAnyBaseIntType) )
+    {
+        wxAnyBaseIntType value2 = static_cast<wxAnyBaseIntType>(value);
+        wxAnyValueTypeImplInt::SetValue(value2, dst);
+    }
+    else if ( wxANY_VALUE_TYPE_CHECK_TYPE(dstType, wxAnyBaseUintType) )
+    {
+        wxAnyBaseIntType value2 = static_cast<wxAnyBaseUintType>(value);
+        wxAnyValueTypeImplUint::SetValue(value2, dst);
+    }
+    else if ( wxANY_VALUE_TYPE_CHECK_TYPE(dstType, wxString) )
+    {
+        wxString s;
+        if ( value )
+            s = wxS("true");
+        else
+            s = wxS("false");
+        wxAnyValueTypeImpl<wxString>::SetValue(s, dst);
+    }
+    else
+        return false;
+
+    return true;
+}
+
+bool wxAnyValueTypeImplDouble::ConvertValue(const wxAnyValueBuffer& src,
+                                            wxAnyValueType* dstType,
+                                            wxAnyValueBuffer& dst) const
+{
+    double value = GetValue(src);
+    if ( wxANY_VALUE_TYPE_CHECK_TYPE(dstType, wxAnyBaseIntType) )
+    {
+        if ( value < UseIntMinF || value > UseIntMaxF )
+            return false;
+        wxAnyBaseUintType ul = static_cast<wxAnyBaseUintType>(value);
+        wxAnyValueTypeImplUint::SetValue(ul, dst);
+    }
+    else if ( wxANY_VALUE_TYPE_CHECK_TYPE(dstType, wxAnyBaseUintType) )
+    {
+        if ( value < 0.0 || value > UseUintMaxF )
+            return false;
+        wxAnyBaseUintType ul = static_cast<wxAnyBaseUintType>(value);
+        wxAnyValueTypeImplUint::SetValue(ul, dst);
+    }
+    else if ( wxANY_VALUE_TYPE_CHECK_TYPE(dstType, wxString) )
+    {
+        wxString s = wxString::Format(wxS("%.14g"), value);
+        wxAnyValueTypeImpl<wxString>::SetValue(s, dst);
+    }
+    else
+        return false;
+
+    return true;
+}
+
+WX_IMPLEMENT_ANY_VALUE_TYPE(wxAnyValueTypeImplInt)
+WX_IMPLEMENT_ANY_VALUE_TYPE(wxAnyValueTypeImplUint)
+WX_IMPLEMENT_ANY_VALUE_TYPE(wxAnyValueTypeImplString)
+WX_IMPLEMENT_ANY_VALUE_TYPE(wxAnyValueTypeImpl<bool>)
+WX_IMPLEMENT_ANY_VALUE_TYPE(wxAnyValueTypeImplDouble)
+
+//-------------------------------------------------------------------------
+// wxAnyNullValueType implementation
+//-------------------------------------------------------------------------
+
+class wxAnyNullValue
+{
+private:
+    void*   m_dummy;
+};
+
+template <>
+class wxAnyValueTypeImpl<wxAnyNullValue> : public wxAnyValueType
+{
+    WX_DECLARE_ANY_VALUE_TYPE(wxAnyValueTypeImpl<wxAnyNullValue>)
+public:
+    virtual void DeleteValue(wxAnyValueBuffer& buf) const
+    {
+        buf.m_ptr = NULL;  // This is important
+    }
+
+    // Dummy implementations
+    virtual void CopyBuffer(const wxAnyValueBuffer& src,
+                            wxAnyValueBuffer& dst) const
+    {
+        wxUnusedVar(src);
+        wxUnusedVar(dst);
+    }
+
+    virtual bool EqOfSameType(const wxAnyValueBuffer& buf1,
+                              const wxAnyValueBuffer& buf2) const
+    {
+        wxUnusedVar(buf1);
+        wxUnusedVar(buf2);
+        return false;
+    }
+
+    virtual bool ConvertValue(const wxAnyValueBuffer& src,
+                              wxAnyValueType* dstType,
+                              wxAnyValueBuffer& dst) const
+    {
+        wxUnusedVar(src);
+        wxUnusedVar(dstType);
+        wxUnusedVar(dst);
+        return false;
+    }
+
+private:
+};
+
+WX_IMPLEMENT_ANY_VALUE_TYPE(wxAnyValueTypeImpl<wxAnyNullValue>)
+
+wxAnyValueType* wxAnyNullValueType =
+    wxAnyValueTypeImpl<wxAnyNullValue>::GetInstance();
+
+#endif // wxUSE_ANY
Index: src/common/descrip.mms
===================================================================
--- src/common/descrip.mms	(revision 61424)
+++ src/common/descrip.mms	(working copy)
@@ -212,7 +212,8 @@
 		listctrlcmn.obj,socketiohandler.obj,fdiodispatcher.obj,\
 		selectdispatcher.obj,overlaycmn.obj,windowid.obj,sstream.obj,\
 		wrapsizer.obj,headerctrlcmn.obj,headercolcmn.obj,\
-		rearrangectrl.obj,spinctrlcmn.obj,datetimefmt.obj,xlocale.obj
+		rearrangectrl.obj,spinctrlcmn.obj,datetimefmt.obj,xlocale.obj,\
+		any.obj
 
 OBJECTS_MOTIF=radiocmn.obj,combocmn.obj
 
@@ -229,6 +230,7 @@
 		accelcmn.cpp,\
 		anidecod.cpp,\
 		animatecmn.cpp,\
+		any.cpp,\
 		appbase.cpp,\
 		appcmn.cpp,\
 		arrstr.cpp,\
@@ -459,6 +461,7 @@
 accelcmn.obj : accelcmn.cpp
 anidecod.obj : anidecod.cpp
 animatecmn.obj : animatecmn.cpp
+any.obj : any.cpp
 appbase.obj : appbase.cpp
 appcmn.obj : appcmn.cpp
 arrstr.obj : arrstr.cpp
Index: docs/doxygen/scripts/common.py
===================================================================
--- docs/doxygen/scripts/common.py	(revision 61424)
+++ docs/doxygen/scripts/common.py	(working copy)
@@ -7,6 +7,8 @@
 # these classes are either replaced by different data types in bindings, or have equivalent / better
 # functionality provided by the target language.
 excluded_classes = [
+        "wxAny",
+        "wxAnyValueType",
         "wxArchiveClassFactory",
         "wxArchiveEntry",
         "wxArchiveInputStream",
Index: docs/doxygen/mainpages/const_wxusedef.h
===================================================================
--- docs/doxygen/mainpages/const_wxusedef.h	(revision 61424)
+++ docs/doxygen/mainpages/const_wxusedef.h	(working copy)
@@ -67,6 +67,7 @@
 @itemdef{wxUSE_ACCEL, Use wxAcceleratorTable/Entry classes and support for them in wxMenu, wxMenuBar.}
 @itemdef{wxUSE_AFM_FOR_POSTSCRIPT, In wxPostScriptDC class use AFM (adobe font metrics) file for character widths.}
 @itemdef{wxUSE_ANIMATIONCTRL, Use wxAnimationCtrl class.}
+@itemdef{wxUSE_ANY, Use wxAny class.}
 @itemdef{wxUSE_APPLE_IEEE, IEEE Extended to/from double routines; see src/common/extended.c file.}
 @itemdef{wxUSE_ARCHIVE_STREAMS, Enable streams for archive formats.}
 @itemdef{wxUSE_AUI, Use AUI (dockable windows) library.}
Index: docs/doxygen/mainpages/cat_classes.h
===================================================================
--- docs/doxygen/mainpages/cat_classes.h	(revision 61424)
+++ docs/doxygen/mainpages/cat_classes.h	(working copy)
@@ -624,6 +624,7 @@
 
 These are the data structure classes supported by wxWidgets.
 
+@li wxAny: A class for storing arbitrary types that may change at run-time
 @li wxCmdLineParser: Command line parser class
 @li wxDateSpan: A logical time interval.
 @li wxDateTime: A class for date/time manipulations
Index: setup.h.in
===================================================================
--- setup.h.in	(revision 61424)
+++ setup.h.in	(working copy)
@@ -291,6 +291,8 @@
 
 #define wxUSE_VARIANT 0
 
+#define wxUSE_ANY 0
+
 #define wxUSE_REGEX       0
 
 #define wxUSE_SYSTEM_OPTIONS 0
Index: wxGTK.spec
===================================================================
--- wxGTK.spec	(revision 61424)
+++ wxGTK.spec	(working copy)
@@ -206,6 +206,7 @@
 # --- wxBase headers list begins here ---
 cat <<EOF >wxbase-headers.files
 wx/afterstd.h
+wx/any.h
 wx/anystr.h
 wx/app.h
 wx/apptrait.h
Index: tests/Makefile.in
===================================================================
--- tests/Makefile.in	(revision 61424)
+++ tests/Makefile.in	(working copy)
@@ -54,6 +54,7 @@
 	$(CPPFLAGS) $(CXXFLAGS)
 TEST_OBJECTS =  \
 	test_test.o \
+	test_wxanytest.o \
 	test_archivetest.o \
 	test_ziptest.o \
 	test_tartest.o \
@@ -343,6 +344,9 @@
 test_test.o: $(srcdir)/test.cpp $(TEST_ODEP)
 	$(CXXC) -c -o $@ $(TEST_CXXFLAGS) $(srcdir)/test.cpp
 
+test_wxanytest.o: $(srcdir)/any/wxanytest.cpp $(TEST_ODEP)
+	$(CXXC) -c -o $@ $(TEST_CXXFLAGS) $(srcdir)/any/wxanytest.cpp
+
 test_archivetest.o: $(srcdir)/archive/archivetest.cpp $(TEST_ODEP)
 	$(CXXC) -c -o $@ $(TEST_CXXFLAGS) $(srcdir)/archive/archivetest.cpp
 
Index: tests/test_vc7_test.vcproj
===================================================================
--- tests/test_vc7_test.vcproj	(revision 61424)
+++ tests/test_vc7_test.vcproj	(working copy)
@@ -786,6 +786,9 @@
 				RelativePath=".\weakref\weakref.cpp">
 			</File>
 			<File
+				RelativePath=".\any\wxanytest.cpp">
+			</File>
+			<File
 				RelativePath=".\regex\wxregextest.cpp">
 			</File>
 			<File
Index: tests/test_vc8_test.vcproj
===================================================================
--- tests/test_vc8_test.vcproj	(revision 61424)
+++ tests/test_vc8_test.vcproj	(working copy)
@@ -1124,6 +1124,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\any\wxanytest.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\regex\wxregextest.cpp"
 				>
 			</File>
Index: tests/test_vc9_test.vcproj
===================================================================
--- tests/test_vc9_test.vcproj	(revision 61424)
+++ tests/test_vc9_test.vcproj	(working copy)
@@ -1096,6 +1096,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\any\wxanytest.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\regex\wxregextest.cpp"
 				>
 			</File>
Index: tests/test_test.dsp
===================================================================
--- tests/test_test.dsp	(revision 61424)
+++ tests/test_test.dsp	(working copy)
@@ -477,6 +477,10 @@
 # End Source File
 # Begin Source File
 
+SOURCE=.\any\wxanytest.cpp
+# End Source File
+# Begin Source File
+
 SOURCE=.\regex\wxregextest.cpp
 # End Source File
 # Begin Source File
Index: tests/makefile.bcc
===================================================================
--- tests/makefile.bcc	(revision 61424)
+++ tests/makefile.bcc	(working copy)
@@ -38,6 +38,7 @@
 TEST_OBJECTS =  \
 	$(OBJS)\test_dummy.obj \
 	$(OBJS)\test_test.obj \
+	$(OBJS)\test_wxanytest.obj \
 	$(OBJS)\test_archivetest.obj \
 	$(OBJS)\test_ziptest.obj \
 	$(OBJS)\test_tartest.obj \
@@ -386,6 +387,9 @@
 $(OBJS)\test_test.obj: .\test.cpp
 	$(CXX) -q -c -P -o$@ $(TEST_CXXFLAGS) .\test.cpp
 
+$(OBJS)\test_wxanytest.obj: .\any\wxanytest.cpp
+	$(CXX) -q -c -P -o$@ $(TEST_CXXFLAGS) .\any\wxanytest.cpp
+
 $(OBJS)\test_archivetest.obj: .\archive\archivetest.cpp
 	$(CXX) -q -c -P -o$@ $(TEST_CXXFLAGS) .\archive\archivetest.cpp
 
Index: tests/makefile.vc
===================================================================
--- tests/makefile.vc	(revision 61424)
+++ tests/makefile.vc	(working copy)
@@ -31,6 +31,7 @@
 TEST_OBJECTS =  \
 	$(OBJS)\test_dummy.obj \
 	$(OBJS)\test_test.obj \
+	$(OBJS)\test_wxanytest.obj \
 	$(OBJS)\test_archivetest.obj \
 	$(OBJS)\test_ziptest.obj \
 	$(OBJS)\test_tartest.obj \
@@ -466,6 +467,9 @@
 $(OBJS)\test_test.obj: .\test.cpp
 	$(CXX) /c /nologo /TP /Fo$@ $(TEST_CXXFLAGS) .\test.cpp
 
+$(OBJS)\test_wxanytest.obj: .\any\wxanytest.cpp
+	$(CXX) /c /nologo /TP /Fo$@ $(TEST_CXXFLAGS) .\any\wxanytest.cpp
+
 $(OBJS)\test_archivetest.obj: .\archive\archivetest.cpp
 	$(CXX) /c /nologo /TP /Fo$@ $(TEST_CXXFLAGS) .\archive\archivetest.cpp
 
Index: tests/any/wxanytest.cpp
===================================================================
--- tests/any/wxanytest.cpp	(revision 0)
+++ tests/any/wxanytest.cpp	(revision 0)
@@ -0,0 +1,564 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        tests/m_any/m_anytest.cpp
+// Purpose:     Test the wxAny classes
+// Author:      Jaakko Salli
+// RCS-ID:      $Id$
+// Copyright:   (c) the wxWidgets team
+// Licence:     wxWindows licence
+///////////////////////////////////////////////////////////////////////////////
+
+#include "testprec.h"
+
+#ifdef __BORLANDC__
+#   pragma hdrstop
+#endif
+
+#ifndef WX_PRECOMP
+#   include "wx/wx.h"
+#endif
+
+#if wxUSE_ANY
+
+#include "wx/any.h"
+#include "wx/datetime.h"
+
+#include <math.h>
+
+// ----------------------------------------------------------------------------
+// utilies
+// ----------------------------------------------------------------------------
+
+// A simple floating-point equality comparison
+bool feq(double a, double b)
+{
+    if ( fabs(a-b) > 0.001 )
+    {
+        //printf("feq failed! (a=%f, b=%f, fabs(a-b)=%f)\n",a,b,fabs(a-b));
+        return false;
+    }
+    return true;
+}
+
+// ----------------------------------------------------------------------------
+// test class
+// ----------------------------------------------------------------------------
+
+class wxAnyTestCase : public CppUnit::TestCase
+{
+public:
+    wxAnyTestCase();
+
+private:
+    CPPUNIT_TEST_SUITE( wxAnyTestCase );
+        CPPUNIT_TEST( Equality );
+        CPPUNIT_TEST( As );
+        CPPUNIT_TEST( GetAs );
+        CPPUNIT_TEST( Null );
+        CPPUNIT_TEST( CustomTemplateSpecialization );
+    CPPUNIT_TEST_SUITE_END();
+
+    void Equality();
+    void As();
+    void GetAs();
+    void Null();
+    void CustomTemplateSpecialization();
+
+    wxDateTime m_testDateTime;
+
+    wxAny   m_anySignedChar1;
+    wxAny   m_anySignedShort1;
+    wxAny   m_anySignedInt1;
+    wxAny   m_anySignedLong1;
+    wxAny   m_anySignedLongLong1;
+    wxAny   m_anyUnsignedChar1;
+    wxAny   m_anyUnsignedShort1;
+    wxAny   m_anyUnsignedInt1;
+    wxAny   m_anyUnsignedLong1;
+    wxAny   m_anyUnsignedLongLong1;
+    wxAny   m_anyStringString1;
+    wxAny   m_anyCharString1;
+    wxAny   m_anyWcharString1;
+    wxAny   m_anyBool1;
+    wxAny   m_anyFloatDouble1;
+    wxAny   m_anyDoubleDouble1;
+    wxAny   m_anyWxObjectPtr1;
+    wxAny   m_anyVoidPtr1;
+    wxAny   m_anyDateTime1;
+
+    wxAny   m_anySignedChar2;
+    wxAny   m_anySignedShort2;
+    wxAny   m_anySignedInt2;
+    wxAny   m_anySignedLong2;
+    wxAny   m_anySignedLongLong2;
+    wxAny   m_anyUnsignedChar2;
+    wxAny   m_anyUnsignedShort2;
+    wxAny   m_anyUnsignedInt2;
+    wxAny   m_anyUnsignedLong2;
+    wxAny   m_anyUnsignedLongLong2;
+    wxAny   m_anyStringString2;
+    wxAny   m_anyCharString2;
+    wxAny   m_anyWcharString2;
+    wxAny   m_anyBool2;
+    wxAny   m_anyFloatDouble2;
+    wxAny   m_anyDoubleDouble2;
+    wxAny   m_anyWxObjectPtr2;
+    wxAny   m_anyVoidPtr2;
+    wxAny   m_anyDateTime2;
+
+    DECLARE_NO_COPY_CLASS(wxAnyTestCase)
+};
+
+// register in the unnamed registry so that these tests are run by default
+CPPUNIT_TEST_SUITE_REGISTRATION( wxAnyTestCase );
+
+// also include in it's own registry so that these tests can be run alone
+CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( wxAnyTestCase, "wxAnyTestCase" );
+
+// Let's use a number with first digit after decimal dot less than 5,
+// so that we don't have to worry about whether conversion from float
+// to int truncates or rounds.
+const double TEST_FLOAT_CONST = 123.456;
+
+wxObject* dummyWxObjectPointer = reinterpret_cast<wxObject*>(1234);
+void* dummyVoidPointer = reinterpret_cast<void*>(1234);
+
+//
+// Test both 'creation' methods
+wxAnyTestCase::wxAnyTestCase()
+    : m_anySignedChar1((signed char)15),
+      m_anySignedShort1((signed short)15),
+      m_anySignedInt1((signed int)15),
+      m_anySignedLong1((signed long)15),
+#ifdef wxLongLong_t
+      m_anySignedLongLong1((wxLongLong_t)15),
+#endif
+      m_anyUnsignedChar1((unsigned char)15),
+      m_anyUnsignedShort1((unsigned short)15),
+      m_anyUnsignedInt1((unsigned int)15),
+      m_anyUnsignedLong1((unsigned long)15),
+#ifdef wxLongLong_t
+      m_anyUnsignedLongLong1((wxULongLong_t)15),
+#endif
+      m_anyStringString1(wxString("abc")),
+      m_anyCharString1("abc"),
+      m_anyWcharString1(L"abc"),
+      m_anyBool1(true),
+      m_anyFloatDouble1((float)TEST_FLOAT_CONST),
+      m_anyDoubleDouble1((double)TEST_FLOAT_CONST),
+      m_anyWxObjectPtr1(dummyWxObjectPointer),
+      m_anyVoidPtr1(dummyVoidPointer),
+      m_anyDateTime1(wxDateTime::Now())
+{
+    m_testDateTime = wxDateTime::Now();
+    m_anySignedChar2 = (signed char)15;
+    m_anySignedShort2 = (signed short)15;
+    m_anySignedInt2 = (signed int)15;
+    m_anySignedLong2 = (signed long)15;
+#ifdef wxLongLong_t
+    m_anySignedLongLong2 = (wxLongLong_t)15;
+#endif
+    m_anyUnsignedChar2 = (unsigned char)15;
+    m_anyUnsignedShort2 = (unsigned short)15;
+    m_anyUnsignedInt2 = (unsigned int)15;
+    m_anyUnsignedLong2 = (unsigned long)15;
+#ifdef wxLongLong_t
+    m_anyUnsignedLongLong2 = (wxULongLong_t)15;
+#endif
+    m_anyStringString2 = wxString("abc");
+    m_anyCharString2 = "abc";
+    m_anyWcharString2 = L"abc";
+    m_anyBool2 = true;
+    m_anyFloatDouble2 = (float)TEST_FLOAT_CONST;
+    m_anyDoubleDouble2 = (double)TEST_FLOAT_CONST;
+    m_anyDateTime2 = m_testDateTime;
+    m_anyWxObjectPtr2 = dummyWxObjectPointer;
+    m_anyVoidPtr2 = dummyVoidPointer;
+}
+
+void wxAnyTestCase::Equality()
+{
+    CPPUNIT_ASSERT(m_anySignedChar1 == m_anySignedShort1);
+    CPPUNIT_ASSERT(m_anySignedChar1 == m_anySignedInt1);
+    CPPUNIT_ASSERT(m_anySignedChar1 == m_anySignedLong1);
+#ifdef wxLongLong_t
+    CPPUNIT_ASSERT(m_anySignedChar1 == m_anySignedLongLong1);
+#endif
+    CPPUNIT_ASSERT(m_anySignedShort1 == m_anySignedChar1);
+    CPPUNIT_ASSERT(m_anySignedShort1 == m_anySignedInt1);
+    CPPUNIT_ASSERT(m_anySignedShort1 == m_anySignedLong1);
+#ifdef wxLongLong_t
+    CPPUNIT_ASSERT(m_anySignedShort1 == m_anySignedLongLong1);
+#endif
+    CPPUNIT_ASSERT(m_anySignedInt1 == m_anySignedChar1);
+    CPPUNIT_ASSERT(m_anySignedInt1 == m_anySignedShort1);
+    CPPUNIT_ASSERT(m_anySignedInt1 == m_anySignedLong1);
+#ifdef wxLongLong_t
+    CPPUNIT_ASSERT(m_anySignedInt1 == m_anySignedLongLong1);
+#endif
+    CPPUNIT_ASSERT(m_anySignedLong1 == m_anySignedChar1);
+    CPPUNIT_ASSERT(m_anySignedLong1 == m_anySignedShort1);
+    CPPUNIT_ASSERT(m_anySignedLong1 == m_anySignedInt1);
+#ifdef wxLongLong_t
+    CPPUNIT_ASSERT(m_anySignedLong1 == m_anySignedLongLong1);
+#endif
+#ifdef wxLongLong_t
+    CPPUNIT_ASSERT(m_anySignedLongLong1 == m_anySignedChar1);
+    CPPUNIT_ASSERT(m_anySignedLongLong1 == m_anySignedShort1);
+    CPPUNIT_ASSERT(m_anySignedLongLong1 == m_anySignedInt1);
+    CPPUNIT_ASSERT(m_anySignedLongLong1 == m_anySignedLong1);
+#endif
+    CPPUNIT_ASSERT(m_anySignedLong1 == 15);
+
+    CPPUNIT_ASSERT(m_anyUnsignedChar1 == m_anyUnsignedShort1);
+    CPPUNIT_ASSERT(m_anyUnsignedChar1 == m_anyUnsignedInt1);
+    CPPUNIT_ASSERT(m_anyUnsignedChar1 == m_anyUnsignedLong1);
+#ifdef wxLongLong_t
+    CPPUNIT_ASSERT(m_anyUnsignedChar1 == m_anyUnsignedLongLong1);
+#endif
+    CPPUNIT_ASSERT(m_anyUnsignedShort1 == m_anyUnsignedChar1);
+    CPPUNIT_ASSERT(m_anyUnsignedShort1 == m_anyUnsignedInt1);
+    CPPUNIT_ASSERT(m_anyUnsignedShort1 == m_anyUnsignedLong1);
+#ifdef wxLongLong_t
+    CPPUNIT_ASSERT(m_anyUnsignedShort1 == m_anyUnsignedLongLong1);
+#endif
+    CPPUNIT_ASSERT(m_anyUnsignedInt1 == m_anyUnsignedChar1);
+    CPPUNIT_ASSERT(m_anyUnsignedInt1 == m_anyUnsignedShort1);
+    CPPUNIT_ASSERT(m_anyUnsignedInt1 == m_anyUnsignedLong1);
+#ifdef wxLongLong_t
+    CPPUNIT_ASSERT(m_anyUnsignedInt1 == m_anyUnsignedLongLong1);
+#endif
+    CPPUNIT_ASSERT(m_anyUnsignedLong1 == m_anyUnsignedChar1);
+    CPPUNIT_ASSERT(m_anyUnsignedLong1 == m_anyUnsignedShort1);
+    CPPUNIT_ASSERT(m_anyUnsignedLong1 == m_anyUnsignedInt1);
+#ifdef wxLongLong_t
+    CPPUNIT_ASSERT(m_anyUnsignedLong1 == m_anyUnsignedLongLong1);
+#endif
+#ifdef wxLongLong_t
+    CPPUNIT_ASSERT(m_anyUnsignedLongLong1 == m_anyUnsignedChar1);
+    CPPUNIT_ASSERT(m_anyUnsignedLongLong1 == m_anyUnsignedShort1);
+    CPPUNIT_ASSERT(m_anyUnsignedLongLong1 == m_anyUnsignedInt1);
+    CPPUNIT_ASSERT(m_anyUnsignedLongLong1 == m_anyUnsignedLong1);
+#endif
+
+    // It'd be nice for this to work, but current model does not
+    // support it, as signed and unsigned numbers are of separate
+    // type.
+    CPPUNIT_ASSERT(m_anyUnsignedLong1 != 15);
+    CPPUNIT_ASSERT(m_anyUnsignedLong1 == (unsigned long)15);
+    CPPUNIT_ASSERT(m_anyUnsignedLong1 != m_anySignedLong1);
+
+    CPPUNIT_ASSERT(m_anyStringString1 == m_anyCharString1);
+    CPPUNIT_ASSERT(m_anyStringString1 == m_anyWcharString1);
+    CPPUNIT_ASSERT(m_anyWcharString1 == m_anyCharString1);
+    CPPUNIT_ASSERT(m_anyStringString1 == wxString("abc"));
+    CPPUNIT_ASSERT(m_anyStringString1 == "abc");
+    CPPUNIT_ASSERT(m_anyStringString1 == L"abc");
+    CPPUNIT_ASSERT(m_anyBool1 == true);
+    CPPUNIT_ASSERT(feq(wxANY_AS(m_anyFloatDouble1, double),
+                       wxANY_AS(m_anyDoubleDouble1, double)));
+    CPPUNIT_ASSERT(feq(wxANY_AS(m_anyFloatDouble1, double),
+                       TEST_FLOAT_CONST));
+    CPPUNIT_ASSERT(m_anyWxObjectPtr1 == dummyWxObjectPointer);
+    CPPUNIT_ASSERT(m_anyVoidPtr1 == dummyVoidPointer);
+
+    // Make sure incompatible pointer types are not comparable
+    CPPUNIT_ASSERT(m_anyWxObjectPtr1 != dummyVoidPointer);
+
+    CPPUNIT_ASSERT(m_anySignedChar1 == m_anySignedShort2);
+    CPPUNIT_ASSERT(m_anySignedChar1 == m_anySignedInt2);
+    CPPUNIT_ASSERT(m_anySignedChar1 == m_anySignedLong2);
+#ifdef wxLongLong_t
+    CPPUNIT_ASSERT(m_anySignedChar1 == m_anySignedLongLong2);
+#endif
+    CPPUNIT_ASSERT(m_anySignedShort1 == m_anySignedChar2);
+    CPPUNIT_ASSERT(m_anySignedShort1 == m_anySignedInt2);
+    CPPUNIT_ASSERT(m_anySignedShort1 == m_anySignedLong2);
+#ifdef wxLongLong_t
+    CPPUNIT_ASSERT(m_anySignedShort1 == m_anySignedLongLong2);
+#endif
+    CPPUNIT_ASSERT(m_anySignedInt1 == m_anySignedChar2);
+    CPPUNIT_ASSERT(m_anySignedInt1 == m_anySignedShort2);
+    CPPUNIT_ASSERT(m_anySignedInt1 == m_anySignedLong2);
+#ifdef wxLongLong_t
+    CPPUNIT_ASSERT(m_anySignedInt1 == m_anySignedLongLong2);
+#endif
+    CPPUNIT_ASSERT(m_anySignedLong1 == m_anySignedChar2);
+    CPPUNIT_ASSERT(m_anySignedLong1 == m_anySignedShort2);
+    CPPUNIT_ASSERT(m_anySignedLong1 == m_anySignedInt2);
+#ifdef wxLongLong_t
+    CPPUNIT_ASSERT(m_anySignedLong1 == m_anySignedLongLong2);
+#endif
+#ifdef wxLongLong_t
+    CPPUNIT_ASSERT(m_anySignedLongLong1 == m_anySignedChar2);
+    CPPUNIT_ASSERT(m_anySignedLongLong1 == m_anySignedShort2);
+    CPPUNIT_ASSERT(m_anySignedLongLong1 == m_anySignedInt2);
+    CPPUNIT_ASSERT(m_anySignedLongLong1 == m_anySignedLong2);
+#endif
+    CPPUNIT_ASSERT(m_anySignedLong2 == 15);
+
+    CPPUNIT_ASSERT(m_anyUnsignedChar1 == m_anyUnsignedShort2);
+    CPPUNIT_ASSERT(m_anyUnsignedChar1 == m_anyUnsignedInt2);
+    CPPUNIT_ASSERT(m_anyUnsignedChar1 == m_anyUnsignedLong2);
+#ifdef wxLongLong_t
+    CPPUNIT_ASSERT(m_anyUnsignedChar1 == m_anyUnsignedLongLong2);
+#endif
+    CPPUNIT_ASSERT(m_anyUnsignedShort1 == m_anyUnsignedChar2);
+    CPPUNIT_ASSERT(m_anyUnsignedShort1 == m_anyUnsignedInt2);
+    CPPUNIT_ASSERT(m_anyUnsignedShort1 == m_anyUnsignedLong2);
+#ifdef wxLongLong_t
+    CPPUNIT_ASSERT(m_anyUnsignedShort1 == m_anyUnsignedLongLong2);
+#endif
+    CPPUNIT_ASSERT(m_anyUnsignedInt1 == m_anyUnsignedChar2);
+    CPPUNIT_ASSERT(m_anyUnsignedInt1 == m_anyUnsignedShort2);
+    CPPUNIT_ASSERT(m_anyUnsignedInt1 == m_anyUnsignedLong2);
+#ifdef wxLongLong_t
+    CPPUNIT_ASSERT(m_anyUnsignedInt1 == m_anyUnsignedLongLong2);
+#endif
+    CPPUNIT_ASSERT(m_anyUnsignedLong1 == m_anyUnsignedChar2);
+    CPPUNIT_ASSERT(m_anyUnsignedLong1 == m_anyUnsignedShort2);
+    CPPUNIT_ASSERT(m_anyUnsignedLong1 == m_anyUnsignedInt2);
+#ifdef wxLongLong_t
+    CPPUNIT_ASSERT(m_anyUnsignedLong1 == m_anyUnsignedLongLong2);
+#endif
+#ifdef wxLongLong_t
+    CPPUNIT_ASSERT(m_anyUnsignedLongLong1 == m_anyUnsignedChar2);
+    CPPUNIT_ASSERT(m_anyUnsignedLongLong1 == m_anyUnsignedShort2);
+    CPPUNIT_ASSERT(m_anyUnsignedLongLong1 == m_anyUnsignedInt2);
+    CPPUNIT_ASSERT(m_anyUnsignedLongLong1 == m_anyUnsignedLong2);
+#endif
+
+    CPPUNIT_ASSERT(m_anyDateTime1 == m_testDateTime);
+    CPPUNIT_ASSERT(m_anyDateTime2 == m_testDateTime);
+    CPPUNIT_ASSERT(m_anyDateTime1 == m_anyDateTime2);
+
+    CPPUNIT_ASSERT(m_anyStringString2 == m_anyCharString1);
+    CPPUNIT_ASSERT(m_anyStringString2 == m_anyWcharString1);
+    CPPUNIT_ASSERT(m_anyWcharString2 == m_anyCharString1);
+    CPPUNIT_ASSERT(m_anyStringString2 == wxString("abc"));
+    CPPUNIT_ASSERT(m_anyStringString2 == "abc");
+    CPPUNIT_ASSERT(m_anyStringString2 == L"abc");
+    CPPUNIT_ASSERT(m_anyBool2 == true);
+    CPPUNIT_ASSERT(feq(wxANY_AS(m_anyFloatDouble2, double),
+                       wxANY_AS(m_anyDoubleDouble2, double)));
+    CPPUNIT_ASSERT(feq(wxANY_AS(m_anyFloatDouble2, double),
+                       TEST_FLOAT_CONST));
+    CPPUNIT_ASSERT(m_anyWxObjectPtr2 == dummyWxObjectPointer);
+    CPPUNIT_ASSERT(m_anyVoidPtr2 == dummyVoidPointer);
+}
+
+void wxAnyTestCase::As()
+{
+    //
+    // Test getting C++ data from wxAny without dynamic conversion
+    signed char a = wxANY_AS(m_anySignedChar1, signed char);
+    CPPUNIT_ASSERT(a == (signed int)15);
+    signed short b = wxANY_AS(m_anySignedShort1, signed short);
+    CPPUNIT_ASSERT(b == (signed int)15);
+    signed int c = wxANY_AS(m_anySignedInt1, signed int);
+    CPPUNIT_ASSERT(c == (signed int)15);
+    signed long d = wxANY_AS(m_anySignedLong1, signed long);
+    CPPUNIT_ASSERT(d == (signed int)15);
+#ifdef wxLongLong_t
+    wxLongLong_t e = wxANY_AS(m_anySignedLongLong1, wxLongLong_t);
+    CPPUNIT_ASSERT(e == (signed int)15);
+#endif
+    unsigned char f = wxANY_AS(m_anyUnsignedChar1, unsigned char);
+    CPPUNIT_ASSERT(f == (unsigned int)15);
+    unsigned short g = wxANY_AS(m_anyUnsignedShort1, unsigned short);
+    CPPUNIT_ASSERT(g == (unsigned int)15);
+    unsigned int h = wxANY_AS(m_anyUnsignedInt1, unsigned int);
+    CPPUNIT_ASSERT(h == (unsigned int)15);
+    unsigned long i = wxANY_AS(m_anyUnsignedLong1, unsigned long);
+    CPPUNIT_ASSERT(i == (unsigned int)15);
+#ifdef wxLongLong_t
+    wxULongLong_t j = wxANY_AS(m_anyUnsignedLongLong1, wxULongLong_t);
+    CPPUNIT_ASSERT(j == (unsigned int)15);
+#endif
+    wxString k = wxANY_AS(m_anyStringString1, wxString);
+    CPPUNIT_ASSERT(k == "abc");
+    wxString l = wxANY_AS(m_anyCharString1, wxString);
+    CPPUNIT_ASSERT(l == "abc");
+    wxString m = wxANY_AS(m_anyWcharString1, wxString);
+    CPPUNIT_ASSERT(m == "abc");
+    bool n = wxANY_AS(m_anyBool1, bool);
+    CPPUNIT_ASSERT(n);
+    float o = wxANY_AS(m_anyFloatDouble1, float);
+    CPPUNIT_ASSERT(feq(o, TEST_FLOAT_CONST));
+    double p = wxANY_AS(m_anyDoubleDouble1, double);
+    CPPUNIT_ASSERT(feq(p, TEST_FLOAT_CONST));
+    wxDateTime q = wxANY_AS(m_anyDateTime1, wxDateTime);
+    CPPUNIT_ASSERT(q == m_testDateTime);
+    wxObject* r = wxANY_AS(m_anyWxObjectPtr1, wxObject*);
+    CPPUNIT_ASSERT(r == dummyWxObjectPointer);
+    void* s = wxANY_AS(m_anyVoidPtr1, void*);
+    CPPUNIT_ASSERT(s == dummyVoidPointer);
+}
+
+void wxAnyTestCase::Null()
+{
+    wxAny a;
+    CPPUNIT_ASSERT(a.IsNull());
+    a = -127;
+    CPPUNIT_ASSERT(a == -127);
+    a.MakeNull();
+    CPPUNIT_ASSERT(a.IsNull());
+}
+
+void wxAnyTestCase::GetAs()
+{
+    //
+    // Test dynamic conversion
+    bool res;
+    long l = 0;
+    unsigned long ul = 0;
+    wxString s;
+    // Let's test against float instead of double, since the former
+    // is not the native underlying type the code converts to, but
+    // should still work, all the same.
+    float f = 0.0;
+    bool b = false;
+
+    // Conversions from signed long type
+    res = m_anySignedLong1.GetAs(&ul);
+    CPPUNIT_ASSERT(res && ul == static_cast<unsigned long>(15));
+    res = m_anySignedLong1.GetAs(&s);
+    CPPUNIT_ASSERT(res && s == "15");
+    res = m_anySignedLong1.GetAs(&f);
+    CPPUNIT_ASSERT(res && feq(f, 15.0));
+    res = m_anySignedLong1.GetAs(&b);
+    CPPUNIT_ASSERT(res && b == true);
+
+    // Conversions from unsigned long type
+    res = m_anyUnsignedLong1.GetAs(&l);
+    CPPUNIT_ASSERT(res && l == static_cast<signed long>(15));
+    res = m_anyUnsignedLong1.GetAs(&s);
+    CPPUNIT_ASSERT(res && s == "15");
+    res = m_anyUnsignedLong1.GetAs(&f);
+    CPPUNIT_ASSERT(res && feq(f, 15.0));
+    res = m_anyUnsignedLong1.GetAs(&b);
+    CPPUNIT_ASSERT(res && b == true);
+
+    // Conversions from default "abc" string to other types
+    // should not work.
+    CPPUNIT_ASSERT(!m_anyStringString1.GetAs(&l));
+    CPPUNIT_ASSERT(!m_anyStringString1.GetAs(&ul));
+    CPPUNIT_ASSERT(!m_anyStringString1.GetAs(&f));
+    CPPUNIT_ASSERT(!m_anyStringString1.GetAs(&b));
+
+    // Let's test some other conversions from string that should work.
+    wxAny anyString;
+
+    anyString = "15";
+    res = anyString.GetAs(&l);
+    CPPUNIT_ASSERT(res && l == static_cast<signed long>(15));
+    res = anyString.GetAs(&ul);
+    CPPUNIT_ASSERT(res && ul == static_cast<unsigned long>(15));
+    res = anyString.GetAs(&f);
+    CPPUNIT_ASSERT(res && feq(f, 15.0));
+    anyString = "TRUE";
+    res = anyString.GetAs(&b);
+    CPPUNIT_ASSERT(res && b == true);
+    anyString = "0";
+    res = anyString.GetAs(&b);
+    CPPUNIT_ASSERT(res && b == false);
+
+    // Conversions from bool type
+    res = m_anyBool1.GetAs(&l);
+    CPPUNIT_ASSERT(res && l == static_cast<signed long>(1));
+    res = m_anyBool1.GetAs(&ul);
+    CPPUNIT_ASSERT(res && ul == static_cast<unsigned long>(1));
+    res = m_anyBool1.GetAs(&s);
+    CPPUNIT_ASSERT(res && s == "true");
+    CPPUNIT_ASSERT(!m_anyBool1.GetAs(&f));
+
+    // Conversions from floating point type
+    res = m_anyDoubleDouble1.GetAs(&l);
+    CPPUNIT_ASSERT(res && l == static_cast<signed long>(123));
+    res = m_anyDoubleDouble1.GetAs(&ul);
+    CPPUNIT_ASSERT(res && ul == static_cast<unsigned long>(123));
+    res = m_anyDoubleDouble1.GetAs(&s);
+    CPPUNIT_ASSERT(res);
+    double d2;
+    res = s.ToDouble(&d2);
+    CPPUNIT_ASSERT(res);
+    CPPUNIT_ASSERT(feq(d2, TEST_FLOAT_CONST));
+}
+
+//
+// Test user data type specialization of wxAnyValueTypeImpl
+//
+
+class MyClass
+{
+public:
+    MyClass( int someValue = 32768 )
+    {
+        m_someValue = someValue;
+    }
+
+    wxString ToString()
+    {
+        return wxString::Format("%i", m_someValue);
+    }
+
+private:
+    int     m_someValue;
+};
+
+
+// Dummy equality operator implementation
+inline bool operator==(const MyClass&, const MyClass&)
+    { return false; }
+
+
+template<>
+class wxAnyValueTypeImpl<MyClass> :
+    public wxAnyValueTypeImplBase<MyClass>
+{
+    WX_DECLARE_ANY_VALUE_TYPE(wxAnyValueTypeImpl<MyClass>)
+public:
+    wxAnyValueTypeImpl() :
+        wxAnyValueTypeImplBase<MyClass>() { }
+    virtual ~wxAnyValueTypeImpl() { }
+
+    virtual bool ConvertValue(const wxAnyValueBuffer& src,
+                              wxAnyValueType* dstType,
+                              wxAnyValueBuffer& dst) const
+    {
+        MyClass value = GetValue(src);
+
+        if ( wxANY_VALUE_TYPE_CHECK_TYPE(dstType, wxString) )
+        {
+            wxString s = value.ToString();
+            wxAnyValueTypeImpl<wxString>::SetValue(s, dst);
+        }
+        else
+            return false;
+
+        return true;
+    }
+};
+
+//
+// Following must be placed somewhere in your source code
+WX_IMPLEMENT_ANY_VALUE_TYPE(wxAnyValueTypeImpl<MyClass>)
+
+void wxAnyTestCase::CustomTemplateSpecialization()
+{
+    // Do only a minimal CheckType() test, as dynamic type conversion already
+    // uses it a lot.
+    bool res;
+    MyClass myObject;
+    wxAny any = myObject;
+
+    CPPUNIT_ASSERT( wxANY_CHECK_TYPE(any, MyClass) );
+    MyClass myObject2 = wxANY_AS(any, MyClass);
+    wxUnusedVar(myObject2);
+
+    wxString str;
+    res = any.GetAs(&str);
+    CPPUNIT_ASSERT( res && str == myObject.ToString() );
+}
+
+#endif // wxUSE_ANY
+
Index: tests/makefile.wat
===================================================================
--- tests/makefile.wat	(revision 61424)
+++ tests/makefile.wat	(working copy)
@@ -269,6 +269,7 @@
 TEST_OBJECTS =  &
 	$(OBJS)\test_dummy.obj &
 	$(OBJS)\test_test.obj &
+	$(OBJS)\test_wxanytest.obj &
 	$(OBJS)\test_archivetest.obj &
 	$(OBJS)\test_ziptest.obj &
 	$(OBJS)\test_tartest.obj &
@@ -425,6 +426,9 @@
 $(OBJS)\test_test.obj :  .AUTODEPEND .\test.cpp
 	$(CXX) -bt=nt -zq -fo=$^@ $(TEST_CXXFLAGS) $<
 
+$(OBJS)\test_wxanytest.obj :  .AUTODEPEND .\any\wxanytest.cpp
+	$(CXX) -bt=nt -zq -fo=$^@ $(TEST_CXXFLAGS) $<
+
 $(OBJS)\test_archivetest.obj :  .AUTODEPEND .\archive\archivetest.cpp
 	$(CXX) -bt=nt -zq -fo=$^@ $(TEST_CXXFLAGS) $<
 
Index: tests/test.bkl
===================================================================
--- tests/test.bkl	(revision 61424)
+++ tests/test.bkl	(working copy)
@@ -29,6 +29,7 @@
                    template_append="wx_append_base">
         <sources>
             test.cpp
+            any/wxanytest.cpp
             archive/archivetest.cpp
             archive/ziptest.cpp
             archive/tartest.cpp
Index: tests/makefile.gcc
===================================================================
--- tests/makefile.gcc	(revision 61424)
+++ tests/makefile.gcc	(working copy)
@@ -30,6 +30,7 @@
 TEST_OBJECTS =  \
 	$(OBJS)\test_dummy.o \
 	$(OBJS)\test_test.o \
+	$(OBJS)\test_wxanytest.o \
 	$(OBJS)\test_archivetest.o \
 	$(OBJS)\test_ziptest.o \
 	$(OBJS)\test_tartest.o \
@@ -373,6 +374,9 @@
 $(OBJS)\test_test.o: ./test.cpp
 	$(CXX) -c -o $@ $(TEST_CXXFLAGS) $(CPPDEPS) $<
 
+$(OBJS)\test_wxanytest.o: ./any/wxanytest.cpp
+	$(CXX) -c -o $@ $(TEST_CXXFLAGS) $(CPPDEPS) $<
+
 $(OBJS)\test_archivetest.o: ./archive/archivetest.cpp
 	$(CXX) -c -o $@ $(TEST_CXXFLAGS) $(CPPDEPS) $<
 
Index: include/wx/univ/setup0.h
===================================================================
--- include/wx/univ/setup0.h	(revision 61424)
+++ include/wx/univ/setup0.h	(working copy)
@@ -553,6 +553,14 @@
 // possible in which case setting this to 0 can gain up to 100KB.
 #define wxUSE_VARIANT 1
 
+// Support for wxAny class, the successor for wxVariant.
+//
+// Default is 1.
+//
+// Recommended setting: 1 unless you want to reduce the library size by a small amount,
+// or your compiler cannot for some reason cope with complexity of templates used.
+#define wxUSE_ANY 1
+
 // Support for regular expression matching via wxRegEx class: enable this to
 // use POSIX regular expressions in your code. You need to compile regex
 // library from src/regex to use it under Windows.
Index: include/wx/palmos/setup0.h
===================================================================
--- include/wx/palmos/setup0.h	(revision 61424)
+++ include/wx/palmos/setup0.h	(working copy)
@@ -554,6 +554,14 @@
 // possible in which case setting this to 0 can gain up to 100KB.
 #define wxUSE_VARIANT 1
 
+// Support for wxAny class, the successor for wxVariant.
+//
+// Default is 1.
+//
+// Recommended setting: 1 unless you want to reduce the library size by a small amount,
+// or your compiler cannot for some reason cope with complexity of templates used.
+#define wxUSE_ANY 1
+
 // Support for regular expression matching via wxRegEx class: enable this to
 // use POSIX regular expressions in your code. You need to compile regex
 // library from src/regex to use it under Windows.
Index: include/wx/msw/setup0.h
===================================================================
--- include/wx/msw/setup0.h	(revision 61424)
+++ include/wx/msw/setup0.h	(working copy)
@@ -554,6 +554,14 @@
 // possible in which case setting this to 0 can gain up to 100KB.
 #define wxUSE_VARIANT 1
 
+// Support for wxAny class, the successor for wxVariant.
+//
+// Default is 1.
+//
+// Recommended setting: 1 unless you want to reduce the library size by a small amount,
+// or your compiler cannot for some reason cope with complexity of templates used.
+#define wxUSE_ANY 1
+
 // Support for regular expression matching via wxRegEx class: enable this to
 // use POSIX regular expressions in your code. You need to compile regex
 // library from src/regex to use it under Windows.
Index: include/wx/msw/wince/setup.h
===================================================================
--- include/wx/msw/wince/setup.h	(revision 61424)
+++ include/wx/msw/wince/setup.h	(working copy)
@@ -554,6 +554,14 @@
 // possible in which case setting this to 0 can gain up to 100KB.
 #define wxUSE_VARIANT 1
 
+// Support for wxAny class, the successor for wxVariant.
+//
+// Default is 1.
+//
+// Recommended setting: 1 unless you want to reduce the library size by a small amount,
+// or your compiler cannot for some reason cope with complexity of templates used.
+#define wxUSE_ANY 1
+
 // Support for regular expression matching via wxRegEx class: enable this to
 // use POSIX regular expressions in your code. You need to compile regex
 // library from src/regex to use it under Windows.
Index: include/wx/os2/setup0.h
===================================================================
--- include/wx/os2/setup0.h	(revision 61424)
+++ include/wx/os2/setup0.h	(working copy)
@@ -554,6 +554,14 @@
 // possible in which case setting this to 0 can gain up to 100KB.
 #define wxUSE_VARIANT 1
 
+// Support for wxAny class, the successor for wxVariant.
+//
+// Default is 1.
+//
+// Recommended setting: 1 unless you want to reduce the library size by a small amount,
+// or your compiler cannot for some reason cope with complexity of templates used.
+#define wxUSE_ANY 1
+
 // Support for regular expression matching via wxRegEx class: enable this to
 // use POSIX regular expressions in your code. You need to compile regex
 // library from src/regex to use it under Windows.
Index: include/wx/osx/setup0.h
===================================================================
--- include/wx/osx/setup0.h	(revision 61424)
+++ include/wx/osx/setup0.h	(working copy)
@@ -555,6 +555,14 @@
 // possible in which case setting this to 0 can gain up to 100KB.
 #define wxUSE_VARIANT 1
 
+// Support for wxAny class, the successor for wxVariant.
+//
+// Default is 1.
+//
+// Recommended setting: 1 unless you want to reduce the library size by a small amount,
+// or your compiler cannot for some reason cope with complexity of templates used.
+#define wxUSE_ANY 1
+
 // Support for regular expression matching via wxRegEx class: enable this to
 // use POSIX regular expressions in your code. You need to compile regex
 // library from src/regex to use it under Windows.
Index: include/wx/chkconf.h
===================================================================
--- include/wx/chkconf.h	(revision 61424)
+++ include/wx/chkconf.h	(working copy)
@@ -68,6 +68,14 @@
    please keep the options in alphabetical order!
  */
 
+#ifndef wxUSE_ANY
+#   ifdef wxABORT_ON_CONFIG_ERROR
+#       error "wxUSE_ANY must be defined."
+#   else
+#       define wxUSE_ANY 0
+#   endif
+#endif /* wxUSE_ANY */
+
 #ifndef wxUSE_CONSOLE_EVENTLOOP
 #   ifdef wxABORT_ON_CONFIG_ERROR
 #       error "wxUSE_CONSOLE_EVENTLOOP must be defined."
Index: include/wx/any.h
===================================================================
--- include/wx/any.h	(revision 0)
+++ include/wx/any.h	(revision 0)
@@ -0,0 +1,759 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/any.h
+// Purpose:     wxAny class
+// Author:      Jaakko Salli
+// Modified by:
+// Created:     07/05/2009
+// RCS-ID:      $Id$
+// Copyright:   (c) wxWidgets team
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_ANY_H_
+#define _WX_ANY_H_
+
+#include "wx/defs.h"
+
+#if wxUSE_ANY
+
+#include "wx/string.h"
+#include "wx/meta/movable.h"
+#include "wx/meta/if.h"
+
+
+// Size of the wxAny value buffer.
+enum
+{
+    WX_ANY_VALUE_BUFFER_SIZE = 16
+};
+
+union wxAnyValueBuffer
+{
+    void*   m_ptr;
+    wxByte  m_buffer[WX_ANY_VALUE_BUFFER_SIZE];
+};
+
+typedef void (*wxAnyClassInfo)();
+
+
+//
+// wxAnyValueType is base class for value type functionality for C++ data
+// types used with wxAny. Usually the default template will create a
+//
+class WXDLLIMPEXP_BASE wxAnyValueType
+{
+public:
+    /**
+        Default constructor.
+    */
+    wxAnyValueType();
+
+    /**
+        Destructor.
+    */
+    virtual ~wxAnyValueType()
+    {
+    }
+
+    /**
+        This function is used for internal type matching.
+    */
+    virtual wxAnyClassInfo GetClassInfo() const = 0;
+
+    /**
+        This function is used for internal type matching.
+    */
+    virtual bool IsSameType(const wxAnyValueType* otherType) const = 0;
+
+    /**
+        This function is called every time the data in wxAny
+        buffer needs to be freed.
+    */
+    virtual void DeleteValue(wxAnyValueBuffer& buf) const = 0;
+
+    /**
+        Implement this for buffer-to-buffer copy. src.m_ptr can
+        be excepted to be NULL if value type of previously stored
+        data was different.
+    */
+    virtual void CopyBuffer(const wxAnyValueBuffer& src,
+                            wxAnyValueBuffer& dst) const = 0;
+
+    /**
+        Equality test of two datas with same type.
+    */
+    virtual bool EqOfSameType(const wxAnyValueBuffer& buf1,
+                              const wxAnyValueBuffer& buf2) const = 0;
+
+    /**
+        Convert value into buffer of different type. Return false if
+        not possible.
+    */
+    virtual bool ConvertValue(const wxAnyValueBuffer& src,
+                              wxAnyValueType* dstType,
+                              wxAnyValueBuffer& dst) const = 0;
+
+    /**
+        Use this template function for checking if wxAnyValueType represents
+        a specific C++ data type.
+
+        @remarks This template function does not work on some older compilers
+                (such as Visual C++ 6.0). For full compiler ccompatibility
+                please use wxANY_VALUE_TYPE_CHECK_TYPE(valueTypePtr, T) macro
+                instead.
+
+        @see wxAny::CheckType()
+    */
+    // FIXME-VC6: remove this hack when VC6 is no longer supported
+    template <typename T>
+    bool CheckType(T* reserved = NULL);
+private:
+};
+
+//
+// This method of checking the type is compatible with VC6
+#define wxANY_VALUE_TYPE_CHECK_TYPE(valueTypePtr, T) \
+    wxAnyValueTypeImpl<T>::IsSameClass(valueTypePtr)
+
+    //valueTypePtr->CheckType(static_cast<T*>(NULL))
+
+
+/**
+    Helper macro for defining user value types.
+
+    NB: We really cannot compare sm_classInfo directly in IsSameClass(),
+        but instead call sm_instance->GetClassInfo(). The former technique
+        broke at least on GCC 4.2 (but worked on VC8 shared build).
+*/
+#define WX_DECLARE_ANY_VALUE_TYPE(CLS) \
+    friend class wxAny; \
+public: \
+    static void sm_classInfo() {} \
+ \
+    virtual wxAnyClassInfo GetClassInfo() const \
+    { \
+        return sm_classInfo; \
+    } \
+    static bool IsSameClass(const wxAnyValueType* otherType) \
+    { \
+        return sm_instance->GetClassInfo() == otherType->GetClassInfo(); \
+    } \
+    virtual bool IsSameType(const wxAnyValueType* otherType) const \
+    { \
+        return IsSameClass(otherType); \
+    } \
+private: \
+    static CLS* sm_instance; \
+public: \
+    static wxAnyValueType* GetInstance() \
+    { \
+        return sm_instance; \
+    }
+
+
+#define WX_IMPLEMENT_ANY_VALUE_TYPE(CLS) \
+    CLS* CLS::sm_instance = new CLS();
+
+
+#ifdef __VISUALC6__
+    // "non dll-interface class 'xxx' used as base interface
+    #pragma warning (push)
+    #pragma warning (disable:4275)
+#endif
+
+/**
+    Following are helper classes for the wxAnyValueTypeImplBase.
+*/
+namespace wxPrivate
+{
+
+template<typename T>
+class wxAnyValueTypeOpsMovable
+{
+public:
+    static void DeleteValue(wxAnyValueBuffer& buf)
+    {
+        wxUnusedVar(buf);
+    }
+
+    static void SetValue(const T& value,
+                         wxAnyValueBuffer& buf)
+    {
+        memcpy(buf.m_buffer, &value, sizeof(T));
+    }
+
+    static const T& GetValue(const wxAnyValueBuffer& buf)
+    {
+        return *(reinterpret_cast<const T*>(&buf.m_buffer[0]));
+    }
+};
+
+
+template<typename T>
+class wxAnyValueTypeOpsGeneric
+{
+public:
+    template<typename T2>
+    class DataHolder
+    {
+    public:
+        DataHolder(const T2& value)
+        {
+            m_value = value;
+        }
+        virtual ~DataHolder() { }
+
+        T2   m_value;
+    private:
+        wxDECLARE_NO_COPY_CLASS(DataHolder);
+    };
+
+    static void DeleteValue(wxAnyValueBuffer& buf)
+    {
+        DataHolder<T>* holder = static_cast<DataHolder<T>*>(buf.m_ptr);
+        delete holder;
+    }
+
+    static void SetValue(const T& value,
+                         wxAnyValueBuffer& buf)
+    {
+        DataHolder<T>* holder = new DataHolder<T>(value);
+        buf.m_ptr = holder;
+    }
+
+    static const T& GetValue(const wxAnyValueBuffer& buf)
+    {
+        DataHolder<T>* holder = static_cast<DataHolder<T>*>(buf.m_ptr);
+        return holder->m_value;
+    }
+};
+
+} // namespace wxPrivate
+
+
+/**
+    Intermediate template for the generic value type implementation.
+    We can derive from this same value type for multiple actual types
+    (for instance, we can have wxAnyValueTypeImplInt for all signed
+    integer types), and also easily implement specialized templates
+    with specific dynamic type conversion.
+*/
+template<typename T>
+class wxAnyValueTypeImplBase : public wxAnyValueType
+{
+    typedef typename wxIf< wxIsMovable<T>::value &&
+                                sizeof(T) <= WX_ANY_VALUE_BUFFER_SIZE,
+                           wxPrivate::wxAnyValueTypeOpsMovable<T>,
+                           wxPrivate::wxAnyValueTypeOpsGeneric<T> >::value
+            Ops;
+
+public:
+    wxAnyValueTypeImplBase() : wxAnyValueType() { }
+    virtual ~wxAnyValueTypeImplBase() { }
+
+    virtual void DeleteValue(wxAnyValueBuffer& buf) const
+    {
+        Ops::DeleteValue(buf);
+        buf.m_ptr = NULL;  // This is important
+    }
+
+    virtual void CopyBuffer(const wxAnyValueBuffer& src,
+                            wxAnyValueBuffer& dst) const
+    {
+        Ops::DeleteValue(dst);
+        Ops::SetValue(Ops::GetValue(src), dst);
+    }
+
+    /**
+        It is important to reimplement this in any specialized template
+        classes that inherit from wxAnyValueTypeImplBase.
+    */
+    static void SetValue(const T& value,
+                         wxAnyValueBuffer& buf)
+    {
+        Ops::SetValue(value, buf);
+    }
+
+    /**
+        It is important to reimplement this in any specialized template
+        classes that inherit from wxAnyValueTypeImplBase.
+    */
+    static const T& GetValue(const wxAnyValueBuffer& buf)
+    {
+        return Ops::GetValue(buf);
+    }
+
+    virtual bool EqOfSameType(const wxAnyValueBuffer& buf1,
+                              const wxAnyValueBuffer& buf2) const
+    {
+        return GetValue(buf1) == GetValue(buf2);
+    }
+};
+
+
+/*
+    Generic value type template. Note that bulk of the implementation
+    resides in wxAnyValueTypeImplBase.
+*/
+template<typename T>
+class wxAnyValueTypeImpl : public wxAnyValueTypeImplBase<T>
+{
+    WX_DECLARE_ANY_VALUE_TYPE(wxAnyValueTypeImpl<T>)
+public:
+    wxAnyValueTypeImpl() : wxAnyValueTypeImplBase<T>() { }
+    virtual ~wxAnyValueTypeImpl() { }
+
+    virtual bool ConvertValue(const wxAnyValueBuffer& src,
+                              wxAnyValueType* dstType,
+                              wxAnyValueBuffer& dst) const
+    {
+        wxUnusedVar(src);
+        wxUnusedVar(dstType);
+        wxUnusedVar(dst);
+        return false;
+    }
+};
+
+template<typename T>
+wxAnyValueTypeImpl<T>* wxAnyValueTypeImpl<T>::sm_instance =
+    new wxAnyValueTypeImpl<T>();
+
+
+//
+// Helper macro for using same base value type implementation for multiple
+// actual C++ data types.
+//
+#define WX_ANY_DEFINE_SUB_TYPE(T, CLSTYPE) \
+template<> \
+class wxAnyValueTypeImpl<T> : public wxAnyValueTypeImpl##CLSTYPE \
+{ \
+    typedef wxAnyBase##CLSTYPE##Type UseDataType; \
+public: \
+    wxAnyValueTypeImpl() : wxAnyValueTypeImpl##CLSTYPE() { } \
+    virtual ~wxAnyValueTypeImpl() { } \
+    static void SetValue(const T& value, wxAnyValueBuffer& buf) \
+    { \
+        *(reinterpret_cast<UseDataType*>(&buf.m_buffer[0])) = \
+            static_cast<UseDataType>(value); \
+    } \
+    static T GetValue(const wxAnyValueBuffer& buf) \
+    { \
+        return static_cast<T>( \
+            *(reinterpret_cast<const UseDataType*>(&buf.m_buffer[0]))); \
+    } \
+};
+
+
+//
+//  Integer value types
+//
+
+#ifdef wxLongLong_t
+    typedef wxLongLong_t wxAnyBaseIntType;
+    typedef wxULongLong_t wxAnyBaseUintType;
+#else
+    typedef long wxAnyBaseIntType;
+    typedef unsigned long wxAnyBaseUintType;
+#endif
+
+
+class WXDLLIMPEXP_BASE wxAnyValueTypeImplInt :
+    public wxAnyValueTypeImplBase<wxAnyBaseIntType>
+{
+    WX_DECLARE_ANY_VALUE_TYPE(wxAnyValueTypeImplInt)
+public:
+    wxAnyValueTypeImplInt() :
+        wxAnyValueTypeImplBase<wxAnyBaseIntType>() { }
+    virtual ~wxAnyValueTypeImplInt() { }
+
+    virtual bool ConvertValue(const wxAnyValueBuffer& src,
+                              wxAnyValueType* dstType,
+                              wxAnyValueBuffer& dst) const;
+};
+
+
+class WXDLLIMPEXP_BASE wxAnyValueTypeImplUint :
+    public wxAnyValueTypeImplBase<wxAnyBaseUintType>
+{
+    WX_DECLARE_ANY_VALUE_TYPE(wxAnyValueTypeImplUint)
+public:
+    wxAnyValueTypeImplUint() :
+        wxAnyValueTypeImplBase<wxAnyBaseUintType>() { }
+    virtual ~wxAnyValueTypeImplUint() { }
+
+    virtual bool ConvertValue(const wxAnyValueBuffer& src,
+                              wxAnyValueType* dstType,
+                              wxAnyValueBuffer& dst) const;
+};
+
+
+WX_ANY_DEFINE_SUB_TYPE(signed long, Int)
+WX_ANY_DEFINE_SUB_TYPE(signed int, Int)
+WX_ANY_DEFINE_SUB_TYPE(signed short, Int)
+WX_ANY_DEFINE_SUB_TYPE(signed char, Int)
+#ifdef wxLongLong_t
+WX_ANY_DEFINE_SUB_TYPE(wxLongLong_t, Int)
+#endif
+
+WX_ANY_DEFINE_SUB_TYPE(unsigned long, Uint)
+WX_ANY_DEFINE_SUB_TYPE(unsigned int, Uint)
+WX_ANY_DEFINE_SUB_TYPE(unsigned short, Uint)
+WX_ANY_DEFINE_SUB_TYPE(unsigned char, Uint)
+#ifdef wxLongLong_t
+WX_ANY_DEFINE_SUB_TYPE(wxULongLong_t, Uint)
+#endif
+
+
+//
+// String value type
+//
+class WXDLLIMPEXP_BASE wxAnyValueTypeImplString :
+    public wxAnyValueTypeImplBase<wxString>
+{
+    WX_DECLARE_ANY_VALUE_TYPE(wxAnyValueTypeImplString)
+public:
+    wxAnyValueTypeImplString() :
+        wxAnyValueTypeImplBase<wxString>() { }
+    virtual ~wxAnyValueTypeImplString() { }
+
+    /**
+        Convert value into buffer of different type. Return false if
+        not possible.
+    */
+    virtual bool ConvertValue(const wxAnyValueBuffer& src,
+                              wxAnyValueType* dstType,
+                              wxAnyValueBuffer& dst) const;
+
+};
+
+template<>
+class wxAnyValueTypeImpl<wxString> : public wxAnyValueTypeImplString
+{
+public:
+    wxAnyValueTypeImpl() : wxAnyValueTypeImplString() { }
+    virtual ~wxAnyValueTypeImpl() { }
+};
+
+
+//
+// Bool value type
+//
+template<>
+class WXDLLIMPEXP_BASE wxAnyValueTypeImpl<bool> :
+    public wxAnyValueTypeImplBase<bool>
+{
+    WX_DECLARE_ANY_VALUE_TYPE(wxAnyValueTypeImpl<bool>)
+public:
+    wxAnyValueTypeImpl() :
+        wxAnyValueTypeImplBase<bool>() { }
+    virtual ~wxAnyValueTypeImpl() { }
+
+    virtual bool ConvertValue(const wxAnyValueBuffer& src,
+                              wxAnyValueType* dstType,
+                              wxAnyValueBuffer& dst) const;
+};
+
+//
+// Floating point value type
+//
+class WXDLLIMPEXP_BASE wxAnyValueTypeImplDouble :
+    public wxAnyValueTypeImplBase<double>
+{
+    WX_DECLARE_ANY_VALUE_TYPE(wxAnyValueTypeImplDouble)
+public:
+    wxAnyValueTypeImplDouble() :
+        wxAnyValueTypeImplBase<double>() { }
+    virtual ~wxAnyValueTypeImplDouble() { }
+
+    virtual bool ConvertValue(const wxAnyValueBuffer& src,
+                              wxAnyValueType* dstType,
+                              wxAnyValueBuffer& dst) const;
+};
+
+// WX_ANY_DEFINE_SUB_TYPE requires this
+typedef double wxAnyBaseDoubleType;
+
+WX_ANY_DEFINE_SUB_TYPE(float, Double)
+WX_ANY_DEFINE_SUB_TYPE(double, Double)
+
+
+#ifdef __VISUALC6__
+    // Re-enable useless VC6 warnings
+    #pragma warning (pop)
+#endif
+
+
+/*
+    Let's define a discrete Null value so we don't have to really
+    ever check if wxAny.m_type pointer is NULL or not. This is an
+    optimization, mostly. Implementation of this value type is
+    "hidden" in the source file.
+*/
+extern WXDLLIMPEXP_DATA_BASE(wxAnyValueType*) wxAnyNullValueType;
+
+
+//
+// The wxAny class represents a container for any type. A variant's value
+// can be changed at run time, possibly to a different type of value.
+//
+// As standard, wxAny can store value of almost any type, in a fairly
+// optimal manner even.
+//
+class WXDLLIMPEXP_BASE wxAny
+{
+public:
+    /**
+        Default constructor.
+    */
+    wxAny()
+    {
+        m_type = wxAnyNullValueType;
+    }
+
+    /**
+        Destructor.
+    */
+    ~wxAny()
+    {
+        m_type->DeleteValue(m_buffer);
+    }
+
+    //@{
+    /**
+        Various constructors.
+    */
+    wxAny(const char* value)
+    {
+        m_type = wxAnyNullValueType;
+        Assign(wxString(value));
+    }
+    wxAny(const wchar_t* value)
+    {
+        m_type = wxAnyNullValueType;
+        Assign(wxString(value));
+    }
+
+    wxAny(const wxAny& any)
+    {
+        m_type = wxAnyNullValueType;
+        AssignAny(any);
+    }
+
+    template<typename T>
+    wxAny(const T& value)
+    {
+        m_type = wxAnyValueTypeImpl<T>::sm_instance;
+        wxAnyValueTypeImpl<T>::SetValue(value, m_buffer);
+    }
+    //@}
+
+    /**
+        Use this template function for checking if this wxAny holds
+        a specific C++ data type.
+
+        @remarks This template function does not work on some older compilers
+                (such as Visual C++ 6.0). For full compiler ccompatibility
+                please use wxANY_CHECK_TYPE(any, T) macro instead.
+
+        @see wxAnyValueType::CheckType()
+    */
+    // FIXME-VC6: remove this hack when VC6 is no longer supported
+    template <typename T>
+    bool CheckType(T* = NULL)
+    {
+        return m_type->CheckType<T>();
+    }
+
+    /**
+        Returns the value type as wxAnyValueType instance.
+
+        @remarks You cannot reliably test whether two wxAnys are of
+                 same value type by simply comparing return values
+                 of wxAny::GetType(). Instead use
+                 wxAnyValueType::CheckType<T>() template function.
+    */
+    const wxAnyValueType* GetType() const
+    {
+        return m_type;
+    }
+
+    /**
+        Tests if wxAny is null (that is, whether there is data).
+    */
+    bool IsNull() const
+    {
+        return (m_type == wxAnyNullValueType);
+    }
+
+    /**
+        Makes wxAny null (that is, clears it).
+    */
+    void MakeNull()
+    {
+        m_type->DeleteValue(m_buffer);
+        m_type = wxAnyNullValueType;
+    }
+
+    //@{
+    /**
+        Assignment operators.
+    */
+    wxAny& operator=(const wxAny &any)
+    {
+        AssignAny(any);
+        return *this;
+    }
+
+    template<typename T>
+    wxAny& operator=(const T &value)
+    {
+        m_type->DeleteValue(m_buffer);
+        m_type = wxAnyValueTypeImpl<T>::sm_instance;
+        wxAnyValueTypeImpl<T>::SetValue(value, m_buffer);
+        return *this;
+    }
+
+    wxAny& operator=(const char* value)
+        { Assign(wxString(value)); return *this; }
+    wxAny& operator=(const wchar_t* value)
+        { Assign(wxString(value)); return *this; }
+    //@}
+
+    //@{
+    /**
+        Equality operators.
+    */
+    template<typename T>
+    bool operator==(const T& value) const
+    {
+        if ( !wxAnyValueTypeImpl<T>::IsSameClass(m_type) )
+            return false;
+
+        return value ==
+            static_cast<T>(wxAnyValueTypeImpl<T>::GetValue(m_buffer));
+    }
+
+    bool operator==(const wxAny& any) const
+    {
+        if ( !m_type->IsSameType(any.m_type) )
+            return false;
+
+        return m_type->EqOfSameType(m_buffer, any.m_buffer);
+    }
+
+    bool operator==(const char* value) const
+        { return (*this) == wxString(value); }
+    bool operator==(const wchar_t* value) const
+        { return (*this) == wxString(value); }
+    //@}
+
+    //@{
+    /**
+        Inequality operators.
+    */
+    template<typename T>
+    bool operator!=(const T& value) const
+    {
+        return !((*this) == value);
+    }
+
+    bool operator!=(const wxAny& any) const
+    {
+        return !((*this) == any);
+    }
+
+    bool operator!=(const char* value) const
+        { return !((*this) == value); }
+    bool operator!=(const wchar_t* value) const
+        { return !((*this) == value); }
+    //@}
+
+    /**
+        This template function converts wxAny into given type. No dynamic
+        conversion is performed, so if the type is incorrect an assertion
+        failure will occur in debug builds, and a bogus value is returned
+        in release ones.
+
+        @remarks This template function does not work on some older compilers
+                (such as Visual C++ 6.0). For full compiler ccompatibility
+                please use wxANY_AS(any, T) macro instead.
+    */
+    // FIXME-VC6: remove this hack when VC6 is no longer supported
+    template<typename T>
+    T As(T* = NULL) const
+    {
+        if ( !wxAnyValueTypeImpl<T>::IsSameClass(m_type) )
+            wxFAIL_MSG("Incorrect or non-convertible data type");
+        return static_cast<T>(wxAnyValueTypeImpl<T>::GetValue(m_buffer));
+    }
+
+    /**
+        Template function that etrieves and converts the value of this
+        variant to the type that T* value is.
+
+        @return Returns @true if conversion was succesfull.
+    */
+    template<typename T>
+    bool GetAs(T* value) const
+    {
+        if ( !wxAnyValueTypeImpl<T>::IsSameClass(m_type) )
+        {
+            wxAnyValueType* otherType =
+                wxAnyValueTypeImpl<T>::sm_instance;
+            wxAnyValueBuffer temp_buf;
+
+            if ( !m_type->ConvertValue(m_buffer, otherType, temp_buf) )
+                return false;
+
+            *value =
+                static_cast<T>(wxAnyValueTypeImpl<T>::GetValue(temp_buf));
+            otherType->DeleteValue(temp_buf);
+
+            return true;
+        }
+        *value = static_cast<T>(wxAnyValueTypeImpl<T>::GetValue(m_buffer));
+        return true;
+    }
+
+private:
+    //Assignment functions.
+    void AssignAny(const wxAny &any);
+
+    template<typename T>
+    void Assign(const T &value)
+    {
+        m_type->DeleteValue(m_buffer);
+        m_type = wxAnyValueTypeImpl<T>::sm_instance;
+        wxAnyValueTypeImpl<T>::SetValue(value, m_buffer);
+    }
+
+    // Data
+    wxAnyValueType*     m_type;
+    wxAnyValueBuffer    m_buffer;
+};
+
+
+//
+// This method of checking the type is compatible with VC6
+#define wxANY_CHECK_TYPE(any, T) \
+    wxANY_VALUE_TYPE_CHECK_TYPE(any.GetType(), T)
+
+
+//
+// This method of getting the value is compatible with VC6
+#define wxANY_AS(any, T) \
+    any.As(static_cast<T*>(NULL))
+
+
+template<typename T>
+inline bool wxAnyValueType::CheckType(T* reserved)
+{
+    wxUnusedVar(reserved);
+    return wxAnyValueTypeImpl<T>::IsSameClass(this);
+}
+
+
+
+#endif // wxUSE_ANY
+
+#endif // _WX_ANY_H_
Index: include/wx/setup_inc.h
===================================================================
--- include/wx/setup_inc.h	(revision 61424)
+++ include/wx/setup_inc.h	(working copy)
@@ -550,6 +550,14 @@
 // possible in which case setting this to 0 can gain up to 100KB.
 #define wxUSE_VARIANT 1
 
+// Support for wxAny class, the successor for wxVariant.
+//
+// Default is 1.
+//
+// Recommended setting: 1 unless you want to reduce the library size by a small amount,
+// or your compiler cannot for some reason cope with complexity of templates used.
+#define wxUSE_ANY 1
+
 // Support for regular expression matching via wxRegEx class: enable this to
 // use POSIX regular expressions in your code. You need to compile regex
 // library from src/regex to use it under Windows.
Index: configure.in
===================================================================
--- configure.in	(revision 61424)
+++ configure.in	(working copy)
@@ -702,6 +702,7 @@
 WX_ARG_FEATURE(selectloop,    [  --enable-selectloop     use wxSelectDispatcher class], wxUSE_SELECT_DISPATCHER)
 
 dnl please keep the settings below in alphabetical order
+WX_ARG_FEATURE(any,           [  --enable-any            use wxAny class], wxUSE_ANY)
 WX_ARG_FEATURE(apple_ieee,    [  --enable-apple_ieee     use the Apple IEEE codec], wxUSE_APPLE_IEEE)
 WX_ARG_FEATURE(arcstream,     [  --enable-arcstream      use wxArchive streams], wxUSE_ARCHIVE_STREAMS)
 WX_ARG_FEATURE(base64,        [  --enable-base64         use base64 encoding/decoding functions], wxUSE_BASE64)
@@ -5420,6 +5421,10 @@
   AC_DEFINE(wxUSE_EXTENDED_RTTI)
 fi
 
+if test "$wxUSE_ANY" = "yes"; then
+    AC_DEFINE(wxUSE_ANY)
+fi
+
 if test "$wxUSE_APPLE_IEEE" = "yes"; then
   AC_DEFINE(wxUSE_APPLE_IEEE)
 fi
Index: build/bakefiles/files.bkl
===================================================================
--- build/bakefiles/files.bkl	(revision 61424)
+++ build/bakefiles/files.bkl	(working copy)
@@ -303,6 +303,7 @@
 <!--                              Common                                    -->
 <!-- =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- -->
 <set var="BASE_CMN_SRC" hints="files">
+    src/common/any.cpp
     src/common/appbase.cpp
     src/common/arcall.cpp
     src/common/arcfind.cpp
@@ -391,6 +392,7 @@
 </set>
 <set var="BASE_CMN_HDR" hints="files">
     wx/afterstd.h
+    wx/any.h
     wx/anystr.h
     wx/app.h
     wx/apptrait.h
Index: build/msw/wx_base.dsp
===================================================================
--- build/msw/wx_base.dsp	(revision 61424)
+++ build/msw/wx_base.dsp	(working copy)
@@ -244,6 +244,10 @@
 # PROP Default_Filter ""
 # Begin Source File
 
+SOURCE=..\..\src\common\any.cpp
+# End Source File
+# Begin Source File
+
 SOURCE=..\..\src\common\appbase.cpp
 # End Source File
 # Begin Source File
@@ -1039,6 +1043,10 @@
 # End Source File
 # Begin Source File
 
+SOURCE=..\..\include\wx\any.h
+# End Source File
+# Begin Source File
+
 SOURCE=..\..\include\wx\anystr.h
 # End Source File
 # Begin Source File
Index: build/msw/makefile.bcc
===================================================================
--- build/msw/makefile.bcc	(revision 61424)
+++ build/msw/makefile.bcc	(working copy)
@@ -307,6 +307,7 @@
 	$(CXXFLAGS)
 MONODLL_OBJECTS =  \
 	$(OBJS)\monodll_dummy.obj \
+	$(OBJS)\monodll_any.obj \
 	$(OBJS)\monodll_appbase.obj \
 	$(OBJS)\monodll_arcall.obj \
 	$(OBJS)\monodll_arcfind.obj \
@@ -447,6 +448,7 @@
 	$(CXXFLAGS)
 MONOLIB_OBJECTS =  \
 	$(OBJS)\monolib_dummy.obj \
+	$(OBJS)\monolib_any.obj \
 	$(OBJS)\monolib_appbase.obj \
 	$(OBJS)\monolib_arcall.obj \
 	$(OBJS)\monolib_arcfind.obj \
@@ -584,6 +586,7 @@
 	-DwxUSE_BASE=1 -Hu -H=$(OBJS)\wxprec_basedll.csm $(CPPFLAGS) $(CXXFLAGS)
 BASEDLL_OBJECTS =  \
 	$(OBJS)\basedll_dummy.obj \
+	$(OBJS)\basedll_any.obj \
 	$(OBJS)\basedll_appbase.obj \
 	$(OBJS)\basedll_arcall.obj \
 	$(OBJS)\basedll_arcfind.obj \
@@ -706,6 +709,7 @@
 	-H=$(OBJS)\wxprec_baselib.csm $(CPPFLAGS) $(CXXFLAGS)
 BASELIB_OBJECTS =  \
 	$(OBJS)\baselib_dummy.obj \
+	$(OBJS)\baselib_any.obj \
 	$(OBJS)\baselib_appbase.obj \
 	$(OBJS)\baselib_arcall.obj \
 	$(OBJS)\baselib_arcfind.obj \
@@ -5421,6 +5425,9 @@
 $(OBJS)\monodll_dummy.obj: ..\..\src\common\dummy.cpp
 	$(CXX) -q -c -P -o$@ $(MONODLL_CXXFLAGS) -H ..\..\src\common\dummy.cpp
 
+$(OBJS)\monodll_any.obj: ..\..\src\common\any.cpp
+	$(CXX) -q -c -P -o$@ $(MONODLL_CXXFLAGS) ..\..\src\common\any.cpp
+
 $(OBJS)\monodll_appbase.obj: ..\..\src\common\appbase.cpp
 	$(CXX) -q -c -P -o$@ $(MONODLL_CXXFLAGS) ..\..\src\common\appbase.cpp
 
@@ -7658,6 +7665,9 @@
 $(OBJS)\monolib_dummy.obj: ..\..\src\common\dummy.cpp
 	$(CXX) -q -c -P -o$@ $(MONOLIB_CXXFLAGS) -H ..\..\src\common\dummy.cpp
 
+$(OBJS)\monolib_any.obj: ..\..\src\common\any.cpp
+	$(CXX) -q -c -P -o$@ $(MONOLIB_CXXFLAGS) ..\..\src\common\any.cpp
+
 $(OBJS)\monolib_appbase.obj: ..\..\src\common\appbase.cpp
 	$(CXX) -q -c -P -o$@ $(MONOLIB_CXXFLAGS) ..\..\src\common\appbase.cpp
 
@@ -9895,6 +9905,9 @@
 $(OBJS)\basedll_version.res: ..\..\src\msw\version.rc
 	brcc32 -32 -r -fo$@ -i$(BCCDIR)\include    -d__WXMSW__ $(__WXUNIV_DEFINE_p_58) $(__DEBUG_DEFINE_p_57) $(__EXCEPTIONS_DEFINE_p_57) $(__RTTI_DEFINE_p_57) $(__THREAD_DEFINE_p_57) $(__UNICODE_DEFINE_p_58) $(__MSLU_DEFINE_p_57) $(__GFXCTX_DEFINE_p_57) -i$(SETUPHDIR) -i..\..\include -dWXBUILDING -dWXDLLNAME=wxbase$(WX_VERSION_NODOT)$(WXUNICODEFLAG)$(WXDEBUGFLAG)$(WX_LIB_FLAVOUR)_bcc$(VENDORTAG)  -i..\..\src\tiff\libtiff -i..\..\src\jpeg -i..\..\src\png -i..\..\src\zlib -i..\..\src\regex -i..\..\src\expat\lib -dwxUSE_GUI=0 -dWXMAKINGDLL_BASE -dwxUSE_BASE=1 ..\..\src\msw\version.rc
 
+$(OBJS)\basedll_any.obj: ..\..\src\common\any.cpp
+	$(CXX) -q -c -P -o$@ $(BASEDLL_CXXFLAGS) ..\..\src\common\any.cpp
+
 $(OBJS)\basedll_appbase.obj: ..\..\src\common\appbase.cpp
 	$(CXX) -q -c -P -o$@ $(BASEDLL_CXXFLAGS) ..\..\src\common\appbase.cpp
 
@@ -10210,6 +10223,9 @@
 $(OBJS)\baselib_dummy.obj: ..\..\src\common\dummy.cpp
 	$(CXX) -q -c -P -o$@ $(BASELIB_CXXFLAGS) -H ..\..\src\common\dummy.cpp
 
+$(OBJS)\baselib_any.obj: ..\..\src\common\any.cpp
+	$(CXX) -q -c -P -o$@ $(BASELIB_CXXFLAGS) ..\..\src\common\any.cpp
+
 $(OBJS)\baselib_appbase.obj: ..\..\src\common\appbase.cpp
 	$(CXX) -q -c -P -o$@ $(BASELIB_CXXFLAGS) ..\..\src\common\appbase.cpp
 
Index: build/msw/wx_vc7_base.vcproj
===================================================================
--- build/msw/wx_vc7_base.vcproj	(revision 61424)
+++ build/msw/wx_vc7_base.vcproj	(working copy)
@@ -525,6 +525,9 @@
 			Name="Common Sources"
 			UniqueIdentifier="{A6A5C30D-BDB6-5050-906D-10A96065136C}">
 			<File
+				RelativePath="..\..\src\common\any.cpp">
+			</File>
+			<File
 				RelativePath="..\..\src\common\appbase.cpp">
 			</File>
 			<File
@@ -1206,6 +1209,9 @@
 				RelativePath="..\..\include\wx\afterstd.h">
 			</File>
 			<File
+				RelativePath="..\..\include\wx\any.h">
+			</File>
+			<File
 				RelativePath="..\..\include\wx\anystr.h">
 			</File>
 			<File
Index: build/msw/wx_vc8_base.vcproj
===================================================================
--- build/msw/wx_vc8_base.vcproj	(revision 61424)
+++ build/msw/wx_vc8_base.vcproj	(working copy)
@@ -735,6 +735,10 @@
 			UniqueIdentifier="{A6A5C30D-BDB6-5050-906D-10A96065136C}"
 			>
 			<File
+				RelativePath="..\..\src\common\any.cpp"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\common\appbase.cpp"
 				>
 			</File>
@@ -1628,6 +1632,10 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\include\wx\any.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\include\wx\anystr.h"
 				>
 			</File>
Index: build/msw/wx_vc9_base.vcproj
===================================================================
--- build/msw/wx_vc9_base.vcproj	(revision 61424)
+++ build/msw/wx_vc9_base.vcproj	(working copy)
@@ -731,6 +731,10 @@
 			UniqueIdentifier="{A6A5C30D-BDB6-5050-906D-10A96065136C}"
 			>
 			<File
+				RelativePath="..\..\src\common\any.cpp"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\common\appbase.cpp"
 				>
 			</File>
@@ -1624,6 +1628,10 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\include\wx\any.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\include\wx\anystr.h"
 				>
 			</File>
Index: build/msw/makefile.vc
===================================================================
--- build/msw/makefile.vc	(revision 61424)
+++ build/msw/makefile.vc	(working copy)
@@ -308,6 +308,7 @@
 	/Fp"$(OBJS)\wxprec_monodll.pch" $(CPPFLAGS) $(CXXFLAGS)
 MONODLL_OBJECTS =  \
 	$(OBJS)\monodll_dummy.obj \
+	$(OBJS)\monodll_any.obj \
 	$(OBJS)\monodll_appbase.obj \
 	$(OBJS)\monodll_arcall.obj \
 	$(OBJS)\monodll_arcfind.obj \
@@ -453,6 +454,7 @@
 	/Fp"$(OBJS)\wxprec_monolib.pch" $(CPPFLAGS) $(CXXFLAGS)
 MONOLIB_OBJECTS =  \
 	$(OBJS)\monolib_dummy.obj \
+	$(OBJS)\monolib_any.obj \
 	$(OBJS)\monolib_appbase.obj \
 	$(OBJS)\monolib_arcall.obj \
 	$(OBJS)\monolib_arcfind.obj \
@@ -596,6 +598,7 @@
 BASEDLL_OBJECTS =  \
 	$(OBJS)\basedll_dummy.obj \
 	$(OBJS)\basedll_version.res \
+	$(OBJS)\basedll_any.obj \
 	$(OBJS)\basedll_appbase.obj \
 	$(OBJS)\basedll_arcall.obj \
 	$(OBJS)\basedll_arcfind.obj \
@@ -723,6 +726,7 @@
 	/Fp"$(OBJS)\wxprec_baselib.pch" $(CPPFLAGS) $(CXXFLAGS)
 BASELIB_OBJECTS =  \
 	$(OBJS)\baselib_dummy.obj \
+	$(OBJS)\baselib_any.obj \
 	$(OBJS)\baselib_appbase.obj \
 	$(OBJS)\baselib_arcall.obj \
 	$(OBJS)\baselib_arcfind.obj \
@@ -5767,6 +5771,9 @@
 $(OBJS)\monodll_dummy.obj: ..\..\src\common\dummy.cpp
 	$(CXX) /c /nologo /TP /Fo$@ $(MONODLL_CXXFLAGS) /Ycwx/wxprec.h ..\..\src\common\dummy.cpp
 
+$(OBJS)\monodll_any.obj: ..\..\src\common\any.cpp
+	$(CXX) /c /nologo /TP /Fo$@ $(MONODLL_CXXFLAGS) ..\..\src\common\any.cpp
+
 $(OBJS)\monodll_appbase.obj: ..\..\src\common\appbase.cpp
 	$(CXX) /c /nologo /TP /Fo$@ $(MONODLL_CXXFLAGS) ..\..\src\common\appbase.cpp
 
@@ -8004,6 +8011,9 @@
 $(OBJS)\monolib_dummy.obj: ..\..\src\common\dummy.cpp
 	$(CXX) /c /nologo /TP /Fo$@ $(MONOLIB_CXXFLAGS) /Ycwx/wxprec.h ..\..\src\common\dummy.cpp
 
+$(OBJS)\monolib_any.obj: ..\..\src\common\any.cpp
+	$(CXX) /c /nologo /TP /Fo$@ $(MONOLIB_CXXFLAGS) ..\..\src\common\any.cpp
+
 $(OBJS)\monolib_appbase.obj: ..\..\src\common\appbase.cpp
 	$(CXX) /c /nologo /TP /Fo$@ $(MONOLIB_CXXFLAGS) ..\..\src\common\appbase.cpp
 
@@ -10241,6 +10251,9 @@
 $(OBJS)\basedll_version.res: ..\..\src\msw\version.rc
 	rc /fo$@  /d WIN32 $(____DEBUGRUNTIME_4) $(__NO_VC_CRTDBG_p_64)  /d __WXMSW__ $(__WXUNIV_DEFINE_p_58) $(__DEBUG_DEFINE_p_57) $(__EXCEPTIONS_DEFINE_p_57) $(__RTTI_DEFINE_p_57) $(__THREAD_DEFINE_p_57) $(__UNICODE_DEFINE_p_58) $(__MSLU_DEFINE_p_57) $(__GFXCTX_DEFINE_p_57) /i $(SETUPHDIR) /i ..\..\include /d WXBUILDING /d WXDLLNAME=wxbase$(WX_VERSION_NODOT)$(WXUNICODEFLAG)$(WXDEBUGFLAG)$(WX_LIB_FLAVOUR)_vc$(VENDORTAG)  /i ..\..\src\tiff\libtiff /i ..\..\src\jpeg /i ..\..\src\png /i ..\..\src\zlib /i ..\..\src\regex /i ..\..\src\expat\lib /d wxUSE_GUI=0 /d WXMAKINGDLL_BASE /d wxUSE_BASE=1 ..\..\src\msw\version.rc
 
+$(OBJS)\basedll_any.obj: ..\..\src\common\any.cpp
+	$(CXX) /c /nologo /TP /Fo$@ $(BASEDLL_CXXFLAGS) ..\..\src\common\any.cpp
+
 $(OBJS)\basedll_appbase.obj: ..\..\src\common\appbase.cpp
 	$(CXX) /c /nologo /TP /Fo$@ $(BASEDLL_CXXFLAGS) ..\..\src\common\appbase.cpp
 
@@ -10556,6 +10569,9 @@
 $(OBJS)\baselib_dummy.obj: ..\..\src\common\dummy.cpp
 	$(CXX) /c /nologo /TP /Fo$@ $(BASELIB_CXXFLAGS) /Ycwx/wxprec.h ..\..\src\common\dummy.cpp
 
+$(OBJS)\baselib_any.obj: ..\..\src\common\any.cpp
+	$(CXX) /c /nologo /TP /Fo$@ $(BASELIB_CXXFLAGS) ..\..\src\common\any.cpp
+
 $(OBJS)\baselib_appbase.obj: ..\..\src\common\appbase.cpp
 	$(CXX) /c /nologo /TP /Fo$@ $(BASELIB_CXXFLAGS) ..\..\src\common\appbase.cpp
 
Index: build/msw/makefile.wat
===================================================================
--- build/msw/makefile.wat	(revision 61424)
+++ build/msw/makefile.wat	(working copy)
@@ -3421,6 +3421,7 @@
 	$(__EXCEPTIONSFLAG) $(CPPFLAGS) $(CXXFLAGS)
 MONODLL_OBJECTS =  &
 	$(OBJS)\monodll_dummy.obj &
+	$(OBJS)\monodll_any.obj &
 	$(OBJS)\monodll_appbase.obj &
 	$(OBJS)\monodll_arcall.obj &
 	$(OBJS)\monodll_arcfind.obj &
@@ -3561,6 +3562,7 @@
 	$(CPPFLAGS) $(CXXFLAGS)
 MONOLIB_OBJECTS =  &
 	$(OBJS)\monolib_dummy.obj &
+	$(OBJS)\monolib_any.obj &
 	$(OBJS)\monolib_appbase.obj &
 	$(OBJS)\monolib_arcall.obj &
 	$(OBJS)\monolib_arcfind.obj &
@@ -3699,6 +3701,7 @@
 	$(CPPFLAGS) $(CXXFLAGS)
 BASEDLL_OBJECTS =  &
 	$(OBJS)\basedll_dummy.obj &
+	$(OBJS)\basedll_any.obj &
 	$(OBJS)\basedll_appbase.obj &
 	$(OBJS)\basedll_arcall.obj &
 	$(OBJS)\basedll_arcfind.obj &
@@ -3821,6 +3824,7 @@
 	$(CPPFLAGS) $(CXXFLAGS)
 BASELIB_OBJECTS =  &
 	$(OBJS)\baselib_dummy.obj &
+	$(OBJS)\baselib_any.obj &
 	$(OBJS)\baselib_appbase.obj &
 	$(OBJS)\baselib_arcall.obj &
 	$(OBJS)\baselib_arcfind.obj &
@@ -5822,6 +5826,9 @@
 $(OBJS)\monodll_dummy.obj :  .AUTODEPEND ..\..\src\common\dummy.cpp
 	$(CXX) -bt=nt -zq -fo=$^@ $(MONODLL_CXXFLAGS) $<
 
+$(OBJS)\monodll_any.obj :  .AUTODEPEND ..\..\src\common\any.cpp
+	$(CXX) -bt=nt -zq -fo=$^@ $(MONODLL_CXXFLAGS) $<
+
 $(OBJS)\monodll_appbase.obj :  .AUTODEPEND ..\..\src\common\appbase.cpp
 	$(CXX) -bt=nt -zq -fo=$^@ $(MONODLL_CXXFLAGS) $<
 
@@ -8171,6 +8178,9 @@
 $(OBJS)\monolib_dummy.obj :  .AUTODEPEND ..\..\src\common\dummy.cpp
 	$(CXX) -bt=nt -zq -fo=$^@ $(MONOLIB_CXXFLAGS) $<
 
+$(OBJS)\monolib_any.obj :  .AUTODEPEND ..\..\src\common\any.cpp
+	$(CXX) -bt=nt -zq -fo=$^@ $(MONOLIB_CXXFLAGS) $<
+
 $(OBJS)\monolib_appbase.obj :  .AUTODEPEND ..\..\src\common\appbase.cpp
 	$(CXX) -bt=nt -zq -fo=$^@ $(MONOLIB_CXXFLAGS) $<
 
@@ -10520,6 +10530,9 @@
 $(OBJS)\basedll_version.res :  .AUTODEPEND ..\..\src\msw\version.rc
 	wrc -q -ad -bt=nt -r -fo=$^@    -d__WXMSW__ $(__WXUNIV_DEFINE_p) $(__DEBUG_DEFINE_p) $(__EXCEPTIONS_DEFINE_p) $(__RTTI_DEFINE_p) $(__THREAD_DEFINE_p) $(__UNICODE_DEFINE_p)  $(__GFXCTX_DEFINE_p) -i=$(SETUPHDIR) -i=..\..\include -dWXBUILDING -dWXDLLNAME=wxbase$(WX_VERSION_NODOT)$(WXUNICODEFLAG)$(WXDEBUGFLAG)$(WX_LIB_FLAVOUR)_wat$(VENDORTAG)  -i=..\..\src\tiff\libtiff -i=..\..\src\jpeg -i=..\..\src\png -i=..\..\src\zlib -i=..\..\src\regex -i=..\..\src\expat\lib -dwxUSE_GUI=0 -dWXMAKINGDLL_BASE -dwxUSE_BASE=1 $<
 
+$(OBJS)\basedll_any.obj :  .AUTODEPEND ..\..\src\common\any.cpp
+	$(CXX) -bt=nt -zq -fo=$^@ $(BASEDLL_CXXFLAGS) $<
+
 $(OBJS)\basedll_appbase.obj :  .AUTODEPEND ..\..\src\common\appbase.cpp
 	$(CXX) -bt=nt -zq -fo=$^@ $(BASEDLL_CXXFLAGS) $<
 
@@ -10835,6 +10848,9 @@
 $(OBJS)\baselib_dummy.obj :  .AUTODEPEND ..\..\src\common\dummy.cpp
 	$(CXX) -bt=nt -zq -fo=$^@ $(BASELIB_CXXFLAGS) $<
 
+$(OBJS)\baselib_any.obj :  .AUTODEPEND ..\..\src\common\any.cpp
+	$(CXX) -bt=nt -zq -fo=$^@ $(BASELIB_CXXFLAGS) $<
+
 $(OBJS)\baselib_appbase.obj :  .AUTODEPEND ..\..\src\common\appbase.cpp
 	$(CXX) -bt=nt -zq -fo=$^@ $(BASELIB_CXXFLAGS) $<
 
Index: build/msw/makefile.gcc
===================================================================
--- build/msw/makefile.gcc	(revision 61424)
+++ build/msw/makefile.gcc	(working copy)
@@ -293,6 +293,7 @@
 	-Wno-ctor-dtor-privacy $(CPPFLAGS) $(CXXFLAGS)
 MONODLL_OBJECTS =  \
 	$(OBJS)\monodll_dummy.o \
+	$(OBJS)\monodll_any.o \
 	$(OBJS)\monodll_appbase.o \
 	$(OBJS)\monodll_arcall.o \
 	$(OBJS)\monodll_arcfind.o \
@@ -434,6 +435,7 @@
 	-Wno-ctor-dtor-privacy $(CPPFLAGS) $(CXXFLAGS)
 MONOLIB_OBJECTS =  \
 	$(OBJS)\monolib_dummy.o \
+	$(OBJS)\monolib_any.o \
 	$(OBJS)\monolib_appbase.o \
 	$(OBJS)\monolib_arcall.o \
 	$(OBJS)\monolib_arcfind.o \
@@ -573,6 +575,7 @@
 BASEDLL_OBJECTS =  \
 	$(OBJS)\basedll_dummy.o \
 	$(OBJS)\basedll_version_rc.o \
+	$(OBJS)\basedll_any.o \
 	$(OBJS)\basedll_appbase.o \
 	$(OBJS)\basedll_arcall.o \
 	$(OBJS)\basedll_arcfind.o \
@@ -695,6 +698,7 @@
 	$(CXXFLAGS)
 BASELIB_OBJECTS =  \
 	$(OBJS)\baselib_dummy.o \
+	$(OBJS)\baselib_any.o \
 	$(OBJS)\baselib_appbase.o \
 	$(OBJS)\baselib_arcall.o \
 	$(OBJS)\baselib_arcfind.o \
@@ -5573,6 +5577,9 @@
 $(OBJS)\monodll_dummy.o: ../../src/common/dummy.cpp
 	$(CXX) -c -o $@ $(MONODLL_CXXFLAGS) $(CPPDEPS) $<
 
+$(OBJS)\monodll_any.o: ../../src/common/any.cpp
+	$(CXX) -c -o $@ $(MONODLL_CXXFLAGS) $(CPPDEPS) $<
+
 $(OBJS)\monodll_appbase.o: ../../src/common/appbase.cpp
 	$(CXX) -c -o $@ $(MONODLL_CXXFLAGS) $(CPPDEPS) $<
 
@@ -7922,6 +7929,9 @@
 $(OBJS)\monolib_dummy.o: ../../src/common/dummy.cpp
 	$(CXX) -c -o $@ $(MONOLIB_CXXFLAGS) $(CPPDEPS) $<
 
+$(OBJS)\monolib_any.o: ../../src/common/any.cpp
+	$(CXX) -c -o $@ $(MONOLIB_CXXFLAGS) $(CPPDEPS) $<
+
 $(OBJS)\monolib_appbase.o: ../../src/common/appbase.cpp
 	$(CXX) -c -o $@ $(MONOLIB_CXXFLAGS) $(CPPDEPS) $<
 
@@ -10271,6 +10281,9 @@
 $(OBJS)\basedll_version_rc.o: ../../src/msw/version.rc
 	windres --use-temp-file -i$< -o$@    --define __WXMSW__ $(__WXUNIV_DEFINE_p_58) $(__DEBUG_DEFINE_p_57) $(__EXCEPTIONS_DEFINE_p_57) $(__RTTI_DEFINE_p_57) $(__THREAD_DEFINE_p_57) $(__UNICODE_DEFINE_p_58) $(__MSLU_DEFINE_p_57) $(__GFXCTX_DEFINE_p_57) --include-dir $(SETUPHDIR) --include-dir ../../include --define WXBUILDING --define WXDLLNAME=wxbase$(WX_VERSION_NODOT)$(WXUNICODEFLAG)$(WXDEBUGFLAG)$(WX_LIB_FLAVOUR)_gcc$(VENDORTAG)  --include-dir ../../src/tiff/libtiff --include-dir ../../src/jpeg --include-dir ../../src/png --include-dir ../../src/zlib --include-dir ../../src/regex --include-dir ../../src/expat/lib --define wxUSE_GUI=0 --define WXMAKINGDLL_BASE --define wxUSE_BASE=1
 
+$(OBJS)\basedll_any.o: ../../src/common/any.cpp
+	$(CXX) -c -o $@ $(BASEDLL_CXXFLAGS) $(CPPDEPS) $<
+
 $(OBJS)\basedll_appbase.o: ../../src/common/appbase.cpp
 	$(CXX) -c -o $@ $(BASEDLL_CXXFLAGS) $(CPPDEPS) $<
 
@@ -10586,6 +10599,9 @@
 $(OBJS)\baselib_dummy.o: ../../src/common/dummy.cpp
 	$(CXX) -c -o $@ $(BASELIB_CXXFLAGS) $(CPPDEPS) $<
 
+$(OBJS)\baselib_any.o: ../../src/common/any.cpp
+	$(CXX) -c -o $@ $(BASELIB_CXXFLAGS) $(CPPDEPS) $<
+
 $(OBJS)\baselib_appbase.o: ../../src/common/appbase.cpp
 	$(CXX) -c -o $@ $(BASELIB_CXXFLAGS) $(CPPDEPS) $<
 
Index: interface/wx/any.h
===================================================================
--- interface/wx/any.h	(revision 0)
+++ interface/wx/any.h	(revision 0)
@@ -0,0 +1,410 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        any.h
+// Purpose:     interface of wxAny
+// Author:      wxWidgets team
+// RCS-ID:      $Id$
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+
+
+/**
+    @class wxAny
+
+    The wxAny class represents a container for any type. Its value
+    can be changed at run time, possibly to a different type of value.
+
+    wxAny is successor class for wxVariant, essentially doing the same thing
+    in a more modern, template-based manner and with transparent support
+    for any user data type that has operator==() implementation (even a
+    dummy one will suffice).
+
+    As standard, wxAny can store value of almost any type, in a fairly
+    optimal manner.
+
+    Some pseudo-code'ish example of use with arbitrary user data:
+
+    @code
+        // MyClass requires == operator implementation. Let's assume one
+        // doesn't exist and create a dummy one.
+        inline bool operator==(const MyClass&, const MyClass&)
+            { return false; }
+
+        void SomeFunction()
+        {
+            MyClass myObject;
+            wxAny any = myObject;
+
+            // Do something
+            // ...
+
+            // Let's do a sanity check to make sure that any still holds
+            // data of correct type.
+            if ( any.CheckType<MyClass>() )
+            {
+                // Thank goodness, still a correct type.
+                MyClass myObject2 = any.As<MyClass>();
+            }
+            else
+            {
+                // Something has gone horribly wrong!
+                wxFAIL();
+            }
+        }
+    @endcode
+
+    @remarks Note that signed and unsigned integers use separate underlying
+            class and as such cannot be compared directly. For instance,
+            take a look at this code:
+
+            @code
+                wxAny anyUlong(static_cast<unsigned long>(128));
+
+                // This condition will fail since integer literals are signed
+                // by default.
+                if ( anyUlong == 128 )
+                {
+                    ...
+                }
+
+                // This, on the other hand will succeed
+                if ( anyUlong == static_cast<unsigned long>(128) )
+                {
+                    ...
+                }
+            @endcode
+
+    @library{wxbase}
+    @category{data}
+
+    @see wxAnyValueType, wxVariant
+*/
+class wxAny
+{
+public:
+    /**
+        Default constructor.
+    */
+    wxAny();
+
+    /**
+        Destructor.
+    */
+    ~wxAny();
+
+    //@{
+    /**
+        @name Miscellaneous constructors
+    */
+    template<typename T>
+    wxAny(const T& value);
+    wxAny(const wxAny& any)
+    wxAny(const char* value);
+    wxAny(const wchar_t* value);
+    //@}
+
+    /**
+        Use this template function for checking if this wxAny holds
+        a specific C++ data type.
+
+        @remarks This template function may not work properly with Visual C++
+                6. For full compiler compatibility, please use
+                wxAnyTypeCheck(T, valueType) macro instead.
+
+        @see wxAnyValueType::CheckType()
+    */
+    template<typename T>
+    bool CheckType();
+
+    /**
+        Returns the value type as wxAnyValueType instance.
+
+        @remarks You cannot reliably test whether two wxAnys are of
+                same value type by simply comparing return values
+                of wxAny::GetType(). Instead use
+                wxAnyValueType::CheckType<T>() template function.
+    */
+    const wxAnyValueType* GetType() const;
+
+    /**
+        Tests if wxAny is null (that is, whether there is data).
+    */
+    bool IsNull() const;
+
+    /**
+        Makes wxAny null (that is, clears it).
+    */
+    void MakeNull();
+
+    //@{
+    /**
+        @name Assignment operators
+    */
+    template<typename T>
+    wxAny& operator=(const T &value);
+    wxAny& operator=(const wxAny &any);
+    wxAny& operator=(const char* value);
+    wxAny& operator=(const wchar_t* value);
+    //@}
+
+    //@{
+    /**
+        @name Equality operators
+    */
+    template<typename T>
+    bool operator==(const T& value) const;
+    bool operator==(const wxAny& any) const;
+    bool operator==(const char* value) const;
+    bool operator==(const wchar_t* value) const;
+    //@}
+
+    //@{
+    /**
+        @name Inequality operators
+    */
+    template<typename T>
+    bool operator!=(const T& value) const;
+    bool operator!=(const wxAny& any) const;
+    bool operator!=(const char* value) const;
+    bool operator!=(const wchar_t* value) const;
+    //@}
+
+    /**
+        This template function converts wxAny into given type. No dynamic
+        conversion is performed, so if the type is incorrect an assertion
+        failure will occur in debug builds, and a bogus value is returned
+        in release ones.
+    */
+    template<typename T>
+    T As() const;
+
+    /**
+        Template function that retrieves and converts the value of this
+        wxAny to the type that T* value is.
+
+        @return Returns @true if conversion was succesfull.
+    */
+    template<typename T>
+    bool GetAs(T* value) const;
+};
+
+/**
+    This is type checking macro that is more compatible with older
+    compilers, such as Visual C++ 6.0.
+*/
+#define wxANY_CHECK_TYPE(any, T)
+
+
+/**
+    Size of the wxAny value buffer.
+*/
+enum
+{
+    WX_ANY_VALUE_BUFFER_SIZE = 16
+};
+
+/**
+    Type for buffer within wxAny for holding data.
+*/
+union wxAnyValueBuffer
+{
+    void*   m_ptr;
+    wxByte  m_buffer[WX_ANY_VALUE_BUFFER_SIZE];
+};
+
+
+/**
+    @class wxAnyValueType
+
+    wxAnyValueType is base class for value type functionality for C++ data
+    types used with wxAny. Usually the default template will create a
+    satisfactory wxAnyValueType implementation for a data type, but
+    sometimes you may need to add some customization. To do this you will need
+    to add specialized template of wxAnyValueTypeImpl<>. Often your only
+    need may be to add dynamic type conversion which would be done like
+    this:
+
+    @code
+        template<>
+        class wxAnyValueTypeImpl<MyClass> :
+            public wxAnyValueTypeImplBase<MyClass>
+        {
+            WX_DECLARE_ANY_VALUE_TYPE(wxAnyValueTypeImpl<MyClass>)
+        public:
+            wxAnyValueTypeImpl() :
+                wxAnyValueTypeImplBase<MyClass>() { }
+            virtual ~wxAnyValueTypeImpl() { }
+
+            virtual bool ConvertValue(const wxAnyValueBuffer& src,
+                                      wxAnyValueType* dstType,
+                                      wxAnyValueBuffer& dst) const
+            {
+                // GetValue() is a static member function implemented
+                // in wxAnyValueTypeImplBase<>.
+                MyClass value = GetValue(src);
+
+                // TODO: Convert value from src buffer to destination
+                //       type and buffer. If cannot be done, return
+                //       false. This is a simple sample.
+                if ( dstType->CheckType<wxString>() )
+                {
+                    wxString s = value.ToString();
+                    wxAnyValueTypeImpl<wxString>::SetValue(s, dst);
+                }
+                else
+                {
+                    return false;
+                }
+            }
+        };
+
+        //
+        // Following must be placed somewhere in your source code
+        WX_IMPLEMENT_ANY_VALUE_TYPE(wxAnyValueTypeImpl<MyClass>)
+    @endcode
+
+    wxAnyValueTypeImplBase<> template, from which we inherit in the above
+    example, contains the bulk of the default wxAnyValueTypeImpl<> template
+    implementation, and as such allows you to easily add some minor
+    customization.
+
+    If you need a have complete control over the type interpretation, you
+    will need to derive a class directly from wxAnyValueType, like this:
+
+    @code
+        template <>
+        class wxAnyValueTypeImpl<MyClass> : public wxAnyValueType
+        {
+            WX_DECLARE_ANY_VALUE_TYPE(wxAnyValueTypeImpl<MyClass>)
+        public:
+            virtual void DeleteValue(wxAnyValueBuffer& buf) const
+            {
+                // TODO: Free the data in buffer
+                // It is important to clear the buffer like this
+                // at the end of DeleteValue().
+                buf.m_ptr = NULL;
+            }
+
+            virtual void CopyBuffer(const wxAnyValueBuffer& src,
+                                    wxAnyValueBuffer& dst) const
+            {
+                // TODO: Copy value from one buffer to another.
+            }
+
+            virtual bool EqOfSameType(const wxAnyValueBuffer& buf1,
+                                      const wxAnyValueBuffer& buf2) const
+            {
+                // TODO: Compare values from two buffers.
+            }
+
+            virtual bool ConvertValue(const wxAnyValueBuffer& src,
+                                      wxAnyValueType* dstType,
+                                      wxAnyValueBuffer& dst) const
+            {
+                // TODO: Convert value from src buffer to destination
+                //       type and buffer.
+            }
+
+            //
+            // Following static functions must be implemented
+            //
+
+            static void SetValue(const T& value,
+                                 wxAnyValueBuffer& buf)
+            {
+                // TODO: Store value into buf.
+            }
+
+            static const T& GetValue(const wxAnyValueBuffer& buf)
+            {
+                // TODO: Return reference to value stored in buffer.
+            }
+        };
+
+        //
+        // Following must be placed somewhere in your source code
+        WX_IMPLEMENT_ANY_VALUE_TYPE(wxAnyValueTypeImpl<MyClass>)
+
+    @endcode
+
+    @library{wxbase}
+    @category{data}
+
+    @see wxAny
+*/
+class wxAnyValueType
+{
+public:
+    /**
+        Default constructor.
+    */
+    wxAnyValueType();
+
+    /**
+        Destructor.
+    */
+    virtual ~wxAnyValueType();
+
+    /**
+        This function is used for internal type matching.
+    */
+    virtual wxAnyClassInfo GetClassInfo() const = 0;
+
+    /**
+        This function is used for internal type matching.
+    */
+    virtual bool IsSameType(const wxAnyValueType* otherType) const = 0;
+
+    /**
+        This function is called every time the data in wxAny
+        buffer needs to be freed.
+    */
+    virtual void DeleteValue(wxAnyValueBuffer& buf) const = 0;
+
+    /**
+        Implement this for buffer-to-buffer copy. src.m_ptr can
+        be excepted to be NULL if value type of previously stored
+        data was different.
+    */
+    virtual void CopyBuffer(const wxAnyValueBuffer& src,
+                            wxAnyValueBuffer& dst) const = 0;
+
+    /**
+        Equality test of two datas with same type.
+    */
+    virtual bool EqOfSameType(const wxAnyValueBuffer& buf1,
+                              const wxAnyValueBuffer& buf2) const = 0;
+
+    /**
+        Convert value into buffer of different type. Return false if
+        not possible.
+    */
+    virtual bool ConvertValue(const wxAnyValueBuffer& src,
+                              wxAnyValueType* dstType,
+                              wxAnyValueBuffer& dst) const = 0;
+
+    /**
+        Use this template function for checking if wxAnyValueType represents
+        a specific C++ data type.
+        
+        @remarks This template function does not work on some older compilers
+                (such as Visual C++ 6.0). For full compiler ccompatibility
+                please use wxANY_VALUE_TYPE_CHECK_TYPE(valueTypePtr, T) macro
+                instead.
+
+        @see wxAny::CheckType()
+    */
+    template <typename T>
+    bool CheckType();
+};
+
+/**
+    This is type checking macro that is more compatible with older
+    compilers, such as Visual C++ 6.0.
+*/
+#define wxANY_VALUE_TYPE_CHECK_TYPE(valueTypePtr, T)
+
+/**
+    This is value getter macro that is more compatible with older
+    compilers, such as Visual C++ 6.0.
+*/
+#define wxANY_AS(any, T)
Index: setup.h_vms
===================================================================
--- setup.h_vms	(revision 61424)
+++ setup.h_vms	(working copy)
@@ -315,6 +315,8 @@
 
 #define wxUSE_VARIANT 1
 
+#define wxUSE_ANY 1
+
 #define wxUSE_REGEX       0
 
 #define wxUSE_SYSTEM_OPTIONS 1
