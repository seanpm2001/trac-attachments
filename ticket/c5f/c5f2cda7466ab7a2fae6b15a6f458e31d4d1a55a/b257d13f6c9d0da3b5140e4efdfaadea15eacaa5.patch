Index: build/bakefiles/files.bkl
===================================================================
--- build/bakefiles/files.bkl	(revision 50083)
+++ build/bakefiles/files.bkl	(working copy)
@@ -348,6 +348,7 @@
     src/common/fs_filter.cpp
     src/common/hash.cpp
     src/common/hashmap.cpp
+    src/common/idmgr.cpp
     src/common/init.cpp
     src/common/intl.cpp
     src/common/ipcbase.cpp
Index: include/wx/idmgr.h
===================================================================
--- include/wx/idmgr.h	(revision 0)
+++ include/wx/idmgr.h	(revision 0)
@@ -0,0 +1,42 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        wx/idmgr.h
+// Purpose:     wxIDManager class - a class for managing autogenerated ids
+// Author:      Brian Vanderburg II
+// Modified by: 
+// Created:     09/21/07
+// RCS-ID:      $Id: $
+// Copyright:   (c) Brian Vanderburg II
+// Licence:     wxWindows licence
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_IDMGR_H_
+#define _WX_IDMGR_H_
+
+// ----------------------------------------------------------------------------
+// Needed headers
+// ----------------------------------------------------------------------------
+#include "wx/defs.h"
+
+// ----------------------------------------------------------------------------
+// wxIdManager - An manager for automatically generated window IDs
+// ----------------------------------------------------------------------------
+class WXDLLEXPORT wxIdManager
+{
+public:
+        // returns true if this id value belong to the range reserved for the
+        // auto-generated (by NewControlId()) ids (they're always negative)
+    static bool IsAutoGeneratedId(wxWindowID id);
+
+        // generate a unique id (or count of them consecutively), returns a
+        // valid id in IsAutoGeneratedId() range or wxID_NONE if failed
+    static wxWindowID NewId(int count = 1);
+
+        // mark an id previously returned by NewControlId() as being unused any
+        // more so that it can be reused again for another control later
+    static void ReleaseId(wxWindowID id, int count = 1);
+};
+
+
+#endif // _WX_IDMGR_H_
+
+
Index: include/wx/window.h
===================================================================
--- include/wx/window.h	(revision 50083)
+++ include/wx/window.h	(working copy)
@@ -230,7 +230,7 @@
 
         // mark an id previously returned by NewControlId() as being unused any
         // more so that it can be reused again for another control later
-    static void ReleaseControlId(wxWindowID id);
+    static void ReleaseControlId(wxWindowID id, int count = 1);
 
 
     // moving/resizing
Index: src/common/idmgr.cpp
===================================================================
--- src/common/idmgr.cpp	(revision 0)
+++ src/common/idmgr.cpp	(revision 0)
@@ -0,0 +1,157 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        src/common/idmgr.cpp
+// Purpose:     wxIDManager class - a class for managing autogenerated ids
+// Author:      Brian Vanderburg II
+// Modified by: 
+// Created:     09/21/07
+// RCS-ID:      $Id: $
+// Copyright:   (c) Brian Vanderburg II
+// Licence:     wxWindows licence
+///////////////////////////////////////////////////////////////////////////////
+
+// This code could probably all be moved directly to wxWindowBase
+
+// ----------------------------------------------------------------------------
+// Needed headers
+// ----------------------------------------------------------------------------
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#ifndef WX_PRECOMP
+    #include "wx/log.h"
+    #include "wx/intl.h"
+#endif //WX_PRECOMP
+
+#include "wx/idmgr.h"
+
+
+namespace
+{
+
+// this array contains, in packed form, the "in use" flags for the entire
+// auto-generated ids range: N-th element of the array contains the flags for
+// ids in [wxID_AUTO_LOWEST + 8*N, wxID_AUTO_LOWEST + 8*N + 7] range
+//
+// initially no ids are in use and we allocate them consecutively, but after we
+// exhaust the entire range, we wrap around and reuse the ids freed in the
+// meanwhile
+wxByte gs_autoIdsInUse[(wxID_AUTO_HIGHEST - wxID_AUTO_LOWEST + 1)/8 + 1] = { 0 };
+
+// this is an optimization used until we wrap around wxID_AUTO_HIGHEST: if this
+// value is < wxID_AUTO_HIGHEST we know that we haven't wrapped yet and so can
+// allocate the ids simply by incrementing it
+static wxWindowID gs_nextAutoId = wxID_AUTO_LOWEST;
+
+void MarkAutoIdUsed(wxWindowID id)
+{
+    id -= wxID_AUTO_LOWEST;
+
+    const int theByte = id / 8;
+    const int theBit = id % 8;
+
+    gs_autoIdsInUse[theByte] |= 1 << theBit;
+}
+
+void FreeAutoId(wxWindowID id)
+{
+    id -= wxID_AUTO_LOWEST;
+
+    const int theByte = id / 8;
+    const int theBit = id % 8;
+
+    gs_autoIdsInUse[theByte] &= ~(1 << theBit);
+}
+
+bool IsAutoIdInUse(wxWindowID id)
+{
+    id -= wxID_AUTO_LOWEST;
+
+    const int theByte = id / 8;
+    const int theBit = id % 8;
+
+    return (gs_autoIdsInUse[theByte] & (1 << theBit)) != 0;
+}
+
+} // anonymous namespace
+
+
+/* static */
+bool wxIdManager::IsAutoGeneratedId(wxWindowID id)
+{
+    if ( id < wxID_AUTO_LOWEST || id > wxID_AUTO_HIGHEST )
+        return false;
+
+    // we shouldn't have any stray ids in this range
+    wxASSERT_MSG( IsAutoIdInUse(id), "unused automatically generated id?" );
+
+    return true;
+}
+
+/* static */
+wxWindowID wxIdManager::NewId(int count)
+{
+    wxASSERT_MSG( count > 0, "can't allocate less than 1 id" );
+
+    if ( gs_nextAutoId + count - 1 <= wxID_AUTO_HIGHEST )
+    {
+        // we haven't wrapped yet, so we can just grab the next count ids
+        wxWindowID id = gs_nextAutoId;
+
+        while ( count-- )
+            MarkAutoIdUsed(gs_nextAutoId++);
+
+        return id;
+    }
+    else // we've already wrapped or are now going to
+    {
+        // brute-force search for the id values
+
+        // number of consecutive free ids found so far
+        int found = 0;
+
+        for ( wxWindowID id = wxID_AUTO_LOWEST; id <= wxID_AUTO_HIGHEST; id++ )
+        {
+            if ( !IsAutoIdInUse(id) )
+            {
+                // found another consecutive available id
+                found++;
+                if ( found == count )
+                {
+                    // mark all count consecutive free ids we found as being in
+                    // use now and rewind back to the start of available range
+                    // in the process
+                    while ( count-- )
+                        MarkAutoIdUsed(id--);
+
+                    return id;
+                }
+            }
+            else // this id is in use
+            {
+                // reset the number of consecutive free values found
+                found = 0;
+            }
+        }
+    }
+
+    // if we get here, there are not enough consecutive free ids
+    ::wxLogError(_("Unable to generate user interface ID.  It is recommended"
+                   " to restart the application.")); // Change to something better
+    return wxID_NONE;
+}
+
+void wxIdManager::ReleaseId(wxWindowID id, int count)
+{
+    wxASSERT_MSG( count > 0, "can't release less than 1 id" );
+
+    while(count--)
+    {
+        wxCHECK2_MSG( IsAutoGeneratedId(id), continue, "can't release non auto-generated id" );
+
+        FreeAutoId(id++);
+    }
+}
+
Index: src/common/wincmn.cpp
===================================================================
--- src/common/wincmn.cpp	(revision 50083)
+++ src/common/wincmn.cpp	(working copy)
@@ -81,6 +81,7 @@
 #endif
 
 #include "wx/platinfo.h"
+#include "wx/idmgr.h"
 
 // Windows List
 WXDLLIMPEXP_DATA_CORE(wxWindowList) wxTopLevelWindows;
@@ -3153,125 +3154,20 @@
     return x;
 }
 
-// ----------------------------------------------------------------------------
-// Window (and menu items) identifiers management
-// ----------------------------------------------------------------------------
 
-namespace
-{
-
-// this array contains, in packed form, the "in use" flags for the entire
-// auto-generated ids range: N-th element of the array contains the flags for
-// ids in [wxID_AUTO_LOWEST + 8*N, wxID_AUTO_LOWEST + 8*N + 7] range
-//
-// initially no ids are in use and we allocate them consecutively, but after we
-// exhaust the entire range, we wrap around and reuse the ids freed in the
-// meanwhile
-wxByte gs_autoIdsInUse[(wxID_AUTO_HIGHEST - wxID_AUTO_LOWEST + 1)/8 + 1] = { 0 };
-
-// this is an optimization used until we wrap around wxID_AUTO_HIGHEST: if this
-// value is < wxID_AUTO_HIGHEST we know that we haven't wrapped yet and so can
-// allocate the ids simply by incrementing it
-static wxWindowID gs_nextControlId = wxID_AUTO_LOWEST;
-
-void MarkAutoIdUsed(wxWindowID id)
-{
-    id -= wxID_AUTO_LOWEST;
-
-    const int theByte = id / 8;
-    const int theBit = id % 8;
-
-    gs_autoIdsInUse[theByte] |= 1 << theBit;
-}
-
-void FreeAutoId(wxWindowID id)
-{
-    id -= wxID_AUTO_LOWEST;
-
-    const int theByte = id / 8;
-    const int theBit = id % 8;
-
-    gs_autoIdsInUse[theByte] &= ~(1 << theBit);
-}
-
-bool IsAutoIdInUse(wxWindowID id)
-{
-    id -= wxID_AUTO_LOWEST;
-
-    const int theByte = id / 8;
-    const int theBit = id % 8;
-
-    return (gs_autoIdsInUse[theByte] & (1 << theBit)) != 0;
-}
-
-} // anonymous namespace
-
-
 /* static */
 bool wxWindowBase::IsAutoGeneratedId(wxWindowID id)
 {
-    if ( id < wxID_AUTO_LOWEST || id > wxID_AUTO_HIGHEST )
-        return false;
-
-    // we shouldn't have any stray ids in this range
-    wxASSERT_MSG( IsAutoIdInUse(id), "unused automatically generated id?" );
-
-    return true;
+    return wxIdManager::IsAutoGeneratedId(id);
 }
 
 wxWindowID wxWindowBase::NewControlId(int count)
 {
-    wxASSERT_MSG( count > 0, "can't allocate less than 1 id" );
-
-    if ( gs_nextControlId + count - 1 <= wxID_AUTO_HIGHEST )
-    {
-        // we haven't wrapped yet, so we can just grab the next count ids
-        wxWindowID id = gs_nextControlId;
-
-        while ( count-- )
-            MarkAutoIdUsed(gs_nextControlId++);
-
-        return id;
-    }
-    else // we've already wrapped or are now going to
-    {
-        // brute-force search for the id values
-
-        // number of consecutive free ids found so far
-        int found = 0;
-
-        for ( wxWindowID id = wxID_AUTO_LOWEST; id <= wxID_AUTO_HIGHEST; id++ )
-        {
-            if ( !IsAutoIdInUse(id) )
-            {
-                // found another consecutive available id
-                found++;
-                if ( found == count )
-                {
-                    // mark all count consecutive free ids we found as being in
-                    // use now and rewind back to the start of available range
-                    // in the process
-                    while ( count-- )
-                        MarkAutoIdUsed(id--);
-
-                    return id;
-                }
-            }
-            else // this id is in use
-            {
-                // reset the number of consecutive free values found
-                found = 0;
-            }
-        }
-    }
-
-    // if we get here, there are not enough consecutive free ids
-    return wxID_NONE;
+   
+    return wxIdManager::NewId(count);
 }
 
-void wxWindowBase::ReleaseControlId(wxWindowID id)
+void wxWindowBase::ReleaseControlId(wxWindowID id, int count)
 {
-    wxCHECK_RET( IsAutoGeneratedId(id), "can't release non auto-generated id" );
-
-    FreeAutoId(id);
+    wxIdManager::ReleaseId(id, count);
 }

 	  	 
