Index: build/symbian/ABLD.BAT
===================================================================
--- build/symbian/ABLD.BAT	(revision 62850)
+++ build/symbian/ABLD.BAT	(working copy)
@@ -1,15 +0,0 @@
-@ECHO OFF
-
-REM Bldmake-generated batch file - ABLD.BAT
-REM ** DO NOT EDIT **
-
-perl -S ABLD.PL "\Project\newnet\src\cpp\3rd\wxwidgets\Symbian\group\\" %1 %2 %3 %4 %5 %6 %7 %8 %9
-if errorlevel==1 goto CheckPerl
-goto End
-
-:CheckPerl
-perl -v >NUL
-if errorlevel==1 echo Is Perl, version 5.003_07 or later, installed?
-goto End
-
-:End
Index: build/symbian/wxSymLib.mmp
===================================================================
--- build/symbian/wxSymLib.mmp	(revision 62850)
+++ build/symbian/wxSymLib.mmp	(working copy)
@@ -21,8 +21,11 @@
 USERINCLUDE	 ..\..\include\
 
 SOURCEPATH ..\..\src\symbian 
-SOURCE dir.cpp evtloop.cpp thread.cpp timer.cpp utils.cpp sockunix.cpp mimetype.cpp fdiounix.cpp utilsexc.cpp
+SOURCE dir.cpp evtloop.cpp thread.cpp timer.cpp utils.cpp utilsexc.cpp
 
+SOURCEPATH ..\..\src\unix
+SOURCE sockunix.cpp fdiounix.cpp mimetype.cpp
+
 SOURCEPATH ..\..\src\common 
 SOURCE arrstr.cpp clntdata.cpp cmdline.cpp config.cpp datetime.cpp datetimefmt.cpp dircmn.cpp dynarray.cpp encconv.cpp event.cpp file.cpp fileconf.cpp filefn.cpp filename.cpp hash.cpp hashmap.cpp init.cpp list.cpp log.cpp longlong.cpp mimecmn.cpp module.cpp msgout.cpp object.cpp process.cpp stdpbase.cpp stopwatch.cpp strconv.cpp stream.cpp string.cpp sysopt.cpp textbuf.cpp textcmn.cpp textfile.cpp tokenzr.cpp txtstrm.cpp uri.cpp url.cpp utilscmn.cpp wfstream.cpp appbase.cpp clntdata.cpp cmdline.cpp config.cpp datetime.cpp dircmn.cpp dynarray.cpp encconv.cpp event.cpp file.cpp fileconf.cpp filefn.cpp filename.cpp hash.cpp hashmap.cpp init.cpp list.cpp log.cpp longlong.cpp mimecmn.cpp module.cpp msgout.cpp object.cpp process.cpp stdpbase.cpp stopwatch.cpp strconv.cpp stream.cpp string.cpp sysopt.cpp textbuf.cpp textcmn.cpp textfile.cpp tokenzr.cpp txtstrm.cpp uri.cpp url.cpp utilscmn.cpp wfstream.cpp
 SOURCE powercmn.cpp
Index: include/wx/apptrait.h
===================================================================
--- include/wx/apptrait.h	(revision 62855)
+++ include/wx/apptrait.h	(working copy)
@@ -296,6 +296,12 @@
     #endif // wxUSE_GUI
     class wxConsoleAppTraits: public wxConsoleAppTraitsBase
     {
+    #if wxUSE_CONSOLE_EVENTLOOP
+        virtual wxEventLoopBase *CreateEventLoop();
+    #endif // wxUSE_CONSOLE_EVENTLOOP
+    #if wxUSE_TIMER
+        virtual wxTimerImpl *CreateTimerImpl(wxTimer *timer);
+    #endif //  wxUSE_TIMER
     };
 #endif // platform
 
Index: include/wx/chkconf.h
===================================================================
--- include/wx/chkconf.h	(revision 62855)
+++ include/wx/chkconf.h	(working copy)
@@ -1088,6 +1088,8 @@
 
 #if defined(__WXPALMOS__)
 #  include "wx/palmos/chkconf.h"
+#elif defined(__WXSYMBIAN__)
+#  include "wx/symbian/chkconf.h"
 #elif defined(__WXWINCE__)
 #  include "wx/msw/wince/chkconf.h"
 #elif defined(__WXMSW__)
Index: include/wx/private/selectdispatcher.h
===================================================================
--- include/wx/private/selectdispatcher.h	(revision 62859)
+++ include/wx/private/selectdispatcher.h	(working copy)
@@ -27,6 +27,11 @@
 
 #include "wx/private/fdiodispatcher.h"
 
+#if defined(HAVE_SYS_SELECT_H) || defined(__WATCOMC__)
+    #include <sys/time.h>
+    #include <sys/select.h>
+#endif
+
 // helper class storing all the select() fd sets
 class WXDLLIMPEXP_BASE wxSelectSets
 {
Index: include/wx/private/socket.h
===================================================================
--- include/wx/private/socket.h	(revision 62859)
+++ include/wx/private/socket.h	(working copy)
@@ -67,6 +67,11 @@
     #include <sys/time.h>   // for timeval
 #endif
 
+#ifdef __WXSYMBIAN__
+    #define WX_SOCKLEN_T socklen_t
+    #define SOCKOPTLEN_T socklen_t
+#endif
+
 // these definitions are for MSW when we don't use configure, otherwise these
 // symbols are defined by configure
 #ifndef WX_SOCKLEN_T
Index: include/wx/symbian/app.h
===================================================================
--- include/wx/symbian/app.h	(revision 62855)
+++ include/wx/symbian/app.h	(working copy)
@@ -10,10 +10,6 @@
 #ifndef _WX_APP_SYMBIAN_H_
 #define _WX_APP_SYMBIAN_H_
 
-#if defined(__GNUG__) && !defined(NO_GCC_PRAGMA)
-#pragma interface "app.h"
-#endif
-
 #include "wx/event.h"
 #if wxUSE_GUI
 #include "wx/icon.h"
Index: include/wx/symbian/chkconf.h
===================================================================
--- include/wx/symbian/chkconf.h	(revision 62855)
+++ include/wx/symbian/chkconf.h	(working copy)
@@ -9,6 +9,9 @@
 
 /* THIS IS A C FILE, DON'T USE C++ FEATURES (IN PARTICULAR COMMENTS) IN IT */
 
+#undef wxUSE_GUI
+#define wxUSE_GUI 0
+
 #undef wxUSE_WXHTML_HELP
 #define wxUSE_WXHTML_HELP 0
 
Index: include/wx/symbian/control.h
===================================================================
--- include/wx/symbian/control.h	(revision 62855)
+++ include/wx/symbian/control.h	(working copy)
@@ -10,10 +10,6 @@
 #ifndef _WX_CONTROL_H_
 #define _WX_CONTROL_H_
 
-#if defined(__GNUG__) && !defined(NO_GCC_PRAGMA)
-    #pragma interface "control.h"
-#endif
-
 #include "wx/dynarray.h"
 
 // General item class
Index: include/wx/symbian/dcclient.h
===================================================================
--- include/wx/symbian/dcclient.h	(revision 62855)
+++ include/wx/symbian/dcclient.h	(working copy)
@@ -4,7 +4,7 @@
 // Author:      Jordan Langholz
 // Modified by:
 // Created:     04/24/07
-// RCS-ID:      $Id: dcclient.h,v 1.3 2005/05/31 09:18:43 JS Exp $
+// RCS-ID:      $Id$
 // Copyright:   (c) Jordan Langholz
 // Licence:     wxWindows licence
 /////////////////////////////////////////////////////////////////////////////
@@ -16,10 +16,6 @@
 // headers
 // ----------------------------------------------------------------------------
 
-#if defined(__GNUG__) && !defined(NO_GCC_PRAGMA)
-    #pragma interface "dcclient.h"
-#endif
-
 #include "wx/dc.h"
 #include "wx/dynarray.h"
 
Index: include/wx/symbian/dcmemory.h
===================================================================
--- include/wx/symbian/dcmemory.h	(revision 62855)
+++ include/wx/symbian/dcmemory.h	(working copy)
@@ -4,7 +4,7 @@
 // Author:      Jordan Langholz
 // Modified by:
 // Created:     04/24/07
-// RCS-ID:      $Id: dcmemory.h,v 1.2 2005/01/18 21:14:24 ABX Exp $
+// RCS-ID:      $Id$
 // Copyright:   (c) Jordan Langholz
 // Licence:     wxWindows licence
 /////////////////////////////////////////////////////////////////////////////
@@ -12,10 +12,6 @@
 #ifndef _WX_DCMEMORY_H_
 #define _WX_DCMEMORY_H_
 
-#if defined(__GNUG__) && !defined(NO_GCC_PRAGMA)
-#pragma interface "dcmemory.h"
-#endif
-
 #include "wx/dcclient.h"
 
 class WXDLLEXPORT wxMemoryDC : public wxDC
Index: include/wx/symbian/dcprint.h
===================================================================
--- include/wx/symbian/dcprint.h	(revision 62855)
+++ include/wx/symbian/dcprint.h	(working copy)
@@ -4,7 +4,7 @@
 // Author:      Jordan Langholz
 // Modified by:
 // Created:     04/24/07
-// RCS-ID:      $Id: dcprint.h,v 1.2 2005/01/18 21:14:24 ABX Exp $
+// RCS-ID:      $Id$
 // Copyright:   (c) Jordan Langholz
 // Licence:     wxWindows licence
 /////////////////////////////////////////////////////////////////////////////
@@ -12,10 +12,6 @@
 #ifndef _WX_DCPRINT_H_
 #define _WX_DCPRINT_H_
 
-#if defined(__GNUG__) && !defined(NO_GCC_PRAGMA)
-    #pragma interface "dcprint.h"
-#endif
-
 #if wxUSE_PRINTING_ARCHITECTURE
 
 #include "wx/dc.h"
Index: include/wx/symbian/dcscreen.h
===================================================================
--- include/wx/symbian/dcscreen.h	(revision 62855)
+++ include/wx/symbian/dcscreen.h	(working copy)
@@ -4,7 +4,7 @@
 // Author:      Jordan Langholz
 // Modified by:
 // Created:     04/24/07
-// RCS-ID:      $Id: dcscreen.h,v 1.2 2005/01/18 21:14:24 ABX Exp $
+// RCS-ID:      $Id$
 // Copyright:   (c) Jordan Langholz
 // Licence:     wxWindows licence
 /////////////////////////////////////////////////////////////////////////////
@@ -12,10 +12,6 @@
 #ifndef _WX_DCSCREEN_H_
 #define _WX_DCSCREEN_H_
 
-#if defined(__GNUG__) && !defined(NO_GCC_PRAGMA)
-#pragma interface "dcscreen.h"
-#endif
-
 #include "wx/dcclient.h"
 
 class WXDLLEXPORT wxScreenDC : public wxWindowDC
Index: include/wx/symbian/msgdlg.h
===================================================================
--- include/wx/symbian/msgdlg.h	(revision 62855)
+++ include/wx/symbian/msgdlg.h	(working copy)
@@ -4,7 +4,7 @@
 // Author:      Jordan Langholz
 // Modified by:
 // Created:     04/24/07
-// RCS-ID:      $Id: msgdlg.h,v 1.3 2005/03/11 15:33:59 ABX Exp $
+// RCS-ID:      $Id$
 // Copyright:   (c) Jordan Langholz
 // Licence:     wxWindows licence
 /////////////////////////////////////////////////////////////////////////////
@@ -12,10 +12,6 @@
 #ifndef _WX_MSGBOXDLG_H_
 #define _WX_MSGBOXDLG_H_
 
-#if defined(__GNUG__) && !defined(NO_GCC_PRAGMA)
-#pragma interface "msgdlg.h"
-#endif
-
 #include "wx/defs.h"
 #include "wx/dialog.h"
 
Index: include/wx/symbian/private/sockunix.h
===================================================================
--- include/wx/symbian/private/sockunix.h	(revision 62855)
+++ include/wx/symbian/private/sockunix.h	(working copy)
@@ -1,137 +0,0 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        wx/unix/private/sockunix.h
-// Purpose:     wxSocketImpl implementation for Unix systems
-// Authors:     Guilhem Lavaux, Vadim Zeitlin
-// Created:     April 1997
-// RCS-ID:      $Id$
-// Copyright:   (c) 1997 Guilhem Lavaux
-//              (c) 2008 Vadim Zeitlin
-// Licence:     wxWindows licence
-/////////////////////////////////////////////////////////////////////////////
-
-#ifndef _WX_UNIX_GSOCKUNX_H_
-#define _WX_UNIX_GSOCKUNX_H_
-
-#include <unistd.h>
-#include <sys/ioctl.h>
-#include "wx/private/fdiomanager.h"
-
-class wxSocketImplUnix : public wxSocketImpl,
-                         public wxFDIOHandler
-{
-public:
-    wxSocketImplUnix(wxSocketBase& wxsocket)
-        : wxSocketImpl(wxsocket)
-    {
-        m_fds[0] =
-        m_fds[1] = -1;
-    }
-
-    virtual wxSocketError GetLastError() const;
-
-    virtual void ReenableEvents(wxSocketEventFlags flags)
-    {
-        // enable the notifications about input/output being available again in
-        // case they were disabled by OnRead/WriteWaiting()
-        //
-        // notice that we'd like to enable the events here only if there is
-        // nothing more left on the socket right now as otherwise we're going
-        // to get a "ready for whatever" notification immediately (well, during
-        // the next event loop iteration) and disable the event back again
-        // which is rather inefficient but unfortunately doing it like this
-        // doesn't work because the existing code (e.g. src/common/sckipc.cpp)
-        // expects to keep getting notifications about the data available from
-        // the socket even if it didn't read all the data the last time, so we
-        // absolutely have to continue generating them
-        EnableEvents(flags);
-    }
-
-    // wxFDIOHandler methods
-    virtual void OnReadWaiting();
-    virtual void OnWriteWaiting();
-    virtual void OnExceptionWaiting();
-    virtual bool IsOk() const { return m_fd != INVALID_SOCKET; }
-
-private:
-    virtual void DoClose()
-    {
-        DisableEvents();
-
-        close(m_fd);
-    }
-
-    virtual void UnblockAndRegisterWithEventLoop()
-    {
-        int trueArg = 1;
-        ioctl(m_fd, FIONBIO, &trueArg);
-
-        EnableEvents();
-    }
-
-    // enable or disable notifications for socket input/output events
-    void EnableEvents(int flags = wxSOCKET_INPUT_FLAG | wxSOCKET_OUTPUT_FLAG)
-        { DoEnableEvents(flags, true); }
-    void DisableEvents(int flags = wxSOCKET_INPUT_FLAG | wxSOCKET_OUTPUT_FLAG)
-        { DoEnableEvents(flags, false); }
-
-    // really enable or disable socket input/output events
-    void DoEnableEvents(int flags, bool enable);
-
-protected:
-    // descriptors for input and output event notification channels associated
-    // with the socket
-    int m_fds[2];
-
-private:
-    // notify the associated wxSocket about a change in socket state and shut
-    // down the socket if the event is wxSOCKET_LOST
-    void OnStateChange(wxSocketNotify event);
-
-    // check if there is any input available, return 1 if yes, 0 if no or -1 on
-    // error
-    int CheckForInput();
-
-
-    // give it access to our m_fds
-    friend class wxSocketFDBasedManager;
-};
-
-// A version of wxSocketManager which uses FDs for socket IO: it is used by
-// Unix console applications and some X11-like ports (wxGTK and wxMotif but not
-// wxX11 currently) which implement their own port-specific wxFDIOManagers
-class wxSocketFDBasedManager : public wxSocketManager
-{
-public:
-    wxSocketFDBasedManager()
-    {
-        m_fdioManager = NULL;
-    }
-
-    virtual bool OnInit();
-    virtual void OnExit() { }
-
-    virtual wxSocketImpl *CreateSocket(wxSocketBase& wxsocket)
-    {
-        return new wxSocketImplUnix(wxsocket);
-    }
-
-    virtual void Install_Callback(wxSocketImpl *socket_, wxSocketNotify event);
-    virtual void Uninstall_Callback(wxSocketImpl *socket_, wxSocketNotify event);
-
-protected:
-    // get the FD index corresponding to the given wxSocketNotify
-    wxFDIOManager::Direction
-    GetDirForEvent(wxSocketImpl *socket, wxSocketNotify event);
-
-    // access the FDs we store
-    int& FD(wxSocketImplUnix *socket, wxFDIOManager::Direction d)
-    {
-        return socket->m_fds[d];
-    }
-
-    wxFDIOManager *m_fdioManager;
-
-    wxDECLARE_NO_COPY_CLASS(wxSocketFDBasedManager);
-};
-
-#endif  /* _WX_UNIX_GSOCKUNX_H_ */
Index: include/wx/symbian/region.h
===================================================================
--- include/wx/symbian/region.h	(revision 62855)
+++ include/wx/symbian/region.h	(working copy)
@@ -4,7 +4,7 @@
 // Author:      Jordan Langholz
 // Modified by:
 // Created:     04/20/07
-// RCS-ID:      $Id: region.h,v 1.1 2004/10/19 13:39:47 JS Exp $
+// RCS-ID:      $Id$
 // Copyright:   (c) Jordan Langholz
 // Licence:     wxWindows licence
 /////////////////////////////////////////////////////////////////////////////
@@ -12,10 +12,6 @@
 #ifndef _WX_REGION_H_
 #define _WX_REGION_H_
 
-#if defined(__GNUG__) && !defined(NO_GCC_PRAGMA)
-    #pragma interface "region.h"
-#endif
-
 #include "wx/gdiobj.h"
 #include "wx/gdicmn.h"
 
Index: include/wx/symbian/tls.h
===================================================================
--- include/wx/symbian/tls.h	(revision 62855)
+++ include/wx/symbian/tls.h	(working copy)
@@ -1,61 +0,0 @@
-///////////////////////////////////////////////////////////////////////////////
-// Name:        wx/symbian/tls.h
-// Purpose:     Pthreads implementation of wxTlsValue<>
-// Author:      Andrei Matuk
-// Created:     2008-08-08
-// RCS-ID:      $Id: tls.h 58757 2009-02-08 11:45:59Z VZ $
-// Copyright:   (c) 2009 Andrei Matuk <Veon.UA@gmail.com>
-// Licence:     wxWindows licence
-///////////////////////////////////////////////////////////////////////////////
-
-#ifndef _WX_SYMBIAN_TLS_H_
-#define _WX_SYMBIAN_TLS_H_
-
-#include <pthread.h>
-
-// ----------------------------------------------------------------------------
-// wxTlsKey is a helper class encapsulating the TLS value index
-// ----------------------------------------------------------------------------
-
-class wxTlsKey
-{
-public:
-    // ctor allocates a new key and possibly registering a destructor function
-    // for it (notice that using destructor function is Pthreads-specific and
-    // not supported in Win32 implementation)
-    wxTlsKey(void (*destructor)(void *) = NULL)
-    {
-        if ( pthread_key_create(&m_key, destructor) != 0 )
-            m_key = 0;
-    }
-
-    // return true if the key was successfully allocated
-    bool IsOk() const { return m_key != 0; }
-
-    // get the key value, there is no error return
-    void *Get() const
-    {
-        return pthread_getspecific(m_key);
-    }
-
-    // change the key value, return true if ok
-    bool Set(void *value)
-    {
-        return pthread_setspecific(m_key, value) == 0;
-    }
-
-    // free the key
-    ~wxTlsKey()
-    {
-        if ( IsOk() )
-            pthread_key_delete(m_key);
-    }
-
-private:
-    pthread_key_t m_key;
-
-    wxDECLARE_NO_COPY_CLASS(wxTlsKey);
-};
-
-#endif // _WX_SYMBIAN_TLS_H_
-
Index: include/wx/symbian/toplevel.h
===================================================================
--- include/wx/symbian/toplevel.h	(revision 62855)
+++ include/wx/symbian/toplevel.h	(working copy)
@@ -3,7 +3,7 @@
 // Purpose:     wxTopLevelWindow
 // Author:      Jordan Langholz
 // Created:     04/24/07
-// RCS-ID:      $Id: toplevel.h,v 1.10 2005/07/01 19:36:51 ABX Exp $
+// RCS-ID:      $Id$
 // Copyright:   (c) Jordan Langholz
 // Licence:     wxWindows licence
 ///////////////////////////////////////////////////////////////////////////////
@@ -11,10 +11,6 @@
 #ifndef _WX_SYMBIAN_TOPLEVEL_H_
 #define _WX_SYMBIAN_TOPLEVEL_H_
 
-#if defined(__GNUG__) && !defined(NO_GCC_PRAGMA)
-    #pragma interface "toplevel.h"
-#endif
-
 #include <aknview.h>
 
 // ----------------------------------------------------------------------------
Index: include/wx/tls.h
===================================================================
--- include/wx/tls.h	(revision 62855)
+++ include/wx/tls.h	(working copy)
@@ -48,10 +48,8 @@
         #include "wx/msw/tls.h"
     #elif defined(__OS2__)
         #include "wx/os2/tls.h"
-    #elif defined(__UNIX__)
+    #elif defined(__UNIX__) || defined(__WXSYMBIAN__)
         #include "wx/unix/tls.h"
-    #elif defined(__WXSYMBIAN__)
-        #include "wx/symbian/tls.h"
     #else
         // TODO: we could emulate TLS for such platforms...
         #error Neither compiler nor OS support thread-specific variables.
Index: src/common/filename.cpp
===================================================================
--- src/common/filename.cpp	(revision 62850)
+++ src/common/filename.cpp	(working copy)
@@ -785,8 +785,11 @@
     path += wxT("XXXXXX");
 
     // we need to copy the path to the buffer in which mkstemp() can modify it
+#ifdef __SYMBIAN32__
+    wxCharBuffer buf(path.utf8_str());
+#else
     wxCharBuffer buf(path.fn_str());
-
+#endif
     // cast is safe because the string length doesn't change
     int fdTemp = mkstemp( (char*)(const char*) buf );
     if ( fdTemp == -1 )
Index: src/common/intl.cpp
===================================================================
--- src/common/intl.cpp	(revision 62850)
+++ src/common/intl.cpp	(working copy)
@@ -1892,6 +1892,7 @@
     }
 #else
     wxUnusedVar(flags);
+    wxUnusedVar(ret);
     return false;
     #define WX_NO_LOCALE_SUPPORT
 #endif
Index: src/common/selectdispatcher.cpp
===================================================================
--- src/common/selectdispatcher.cpp	(revision 62850)
+++ src/common/selectdispatcher.cpp	(working copy)
@@ -34,11 +34,6 @@
     #include "wx/intl.h"
 #endif
 
-#if defined(HAVE_SYS_SELECT_H) || defined(__WATCOMC__)
-    #include <sys/time.h>
-    #include <sys/select.h>
-#endif
-
 #include <errno.h>
 
 #define wxSelectDispatcher_Trace wxT("selectdispatcher")
Index: src/common/socket.cpp
===================================================================
--- src/common/socket.cpp	(revision 62850)
+++ src/common/socket.cpp	(working copy)
@@ -49,6 +49,8 @@
 
 #ifdef __UNIX__
     #include <errno.h>
+#elif defined __SYMBIAN32__
+    #include <sys/select.h>
 #endif
 
 // we use MSG_NOSIGNAL to avoid getting SIGPIPE when sending data to a remote
Index: src/symbian/dir.cpp
===================================================================
--- src/symbian/dir.cpp	(revision 62850)
+++ src/symbian/dir.cpp	(working copy)
@@ -17,17 +17,9 @@
 // headers
 // ----------------------------------------------------------------------------
 
-#if defined(__GNUG__) && !defined(NO_GCC_PRAGMA)
-    #pragma implementation "dir.h"
-#endif
-
 // For compilers that support precompilation, includes "wx.h".
 #include "wx/wxprec.h"
 
-#ifdef __BORLANDC__
-    #pragma hdrstop
-#endif
-
 #ifndef WX_PRECOMP
     #include "wx/intl.h"
     #include "wx/log.h"
Index: src/symbian/fdiounix.cpp
===================================================================
--- src/symbian/fdiounix.cpp	(revision 62850)
+++ src/symbian/fdiounix.cpp	(working copy)
@@ -1,101 +0,0 @@
-///////////////////////////////////////////////////////////////////////////////
-// Name:        src/unix/fdiounix.cpp
-// Purpose:     wxFDIOManager implementation for console Unix applications
-// Author:      Vadim Zeitlin
-// Created:     2009-08-17
-// RCS-ID:      $Id: fdiounix.cpp 61690 2009-08-17 23:46:48Z VZ $
-// Copyright:   (c) 2009 Vadim Zeitlin <vadim@wxwidgets.org>
-// Licence:     wxWindows licence
-///////////////////////////////////////////////////////////////////////////////
-
-// ============================================================================
-// declarations
-// ============================================================================
-
-// ----------------------------------------------------------------------------
-// headers
-// ----------------------------------------------------------------------------
-
-// for compilers that support precompilation, includes "wx.h".
-#include "wx/wxprec.h"
-
-#ifdef __BORLANDC__
-    #pragma hdrstop
-#endif
-
-#include "wx/apptrait.h"
-#include "wx/log.h"
-#include "wx/private/fdiodispatcher.h"
-#include "wx/unix/private/fdiounix.h"
-
-// ============================================================================
-// wxFDIOManagerUnix implementation
-// ============================================================================
-
-int wxFDIOManagerUnix::AddInput(wxFDIOHandler *handler, int fd, Direction d)
-{
-    wxFDIODispatcher * const dispatcher = wxFDIODispatcher::Get();
-    wxCHECK_MSG( dispatcher, -1, "can't monitor FDs without FD IO dispatcher" );
-
-    // translate our direction to dispatcher flags
-    const int flag = d == INPUT ? wxFDIO_INPUT : wxFDIO_OUTPUT;
-
-    // we need to either register this FD with the dispatcher or update an
-    // existing registration depending on whether it had been previously
-    // registered for anything or not
-    bool ok;
-    const int regmask = handler->GetRegisteredEvents();
-    if ( !regmask )
-    {
-        ok = dispatcher->RegisterFD(fd, handler, flag);
-    }
-    else
-    {
-        ok = dispatcher->ModifyFD(fd, handler, regmask | flag);
-    }
-
-    if ( !ok )
-        return -1;
-
-    // update the stored mask of registered events
-    handler->SetRegisteredEvent(flag);
-
-    return fd;
-}
-
-void wxFDIOManagerUnix::RemoveInput(wxFDIOHandler *handler, int fd, Direction d)
-{
-    wxFDIODispatcher * const dispatcher = wxFDIODispatcher::Get();
-    if ( !dispatcher )
-        return;
-
-    const int flag = d == INPUT ? wxFDIO_INPUT : wxFDIO_OUTPUT;
-
-    // just as in AddInput() above we may need to either just modify the FD or
-    // remove it completely if we don't need to monitor it any more
-    bool ok;
-    const int regmask = handler->GetRegisteredEvents();
-    if ( regmask == flag )
-    {
-        ok = dispatcher->UnregisterFD(fd);
-    }
-    else
-    {
-        ok = dispatcher->ModifyFD(fd, handler, regmask & ~flag);
-    }
-
-    if ( !ok )
-    {
-        wxLogDebug("Failed to unregister %d in direction %d", fd, d);
-    }
-
-    // do this even after a failure to unregister it, we still tried...
-    handler->ClearRegisteredEvent(flag);
-}
-
-wxFDIOManager *wxAppTraits::GetFDIOManager()
-{
-    static wxFDIOManagerUnix s_manager;
-    return &s_manager;
-}
-
Index: src/symbian/mimetype.cpp
===================================================================
--- src/symbian/mimetype.cpp	(revision 62850)
+++ src/symbian/mimetype.cpp	(working copy)
@@ -1,1026 +0,0 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        src/unix/mimetype.cpp
-// Purpose:     classes and functions to manage MIME types
-// Author:      Vadim Zeitlin
-// Modified by:
-// Created:     23.09.98
-// RCS-ID:      $Id: mimetype.cpp 61724 2009-08-21 10:41:26Z VZ $
-// Copyright:   (c) 1998 Vadim Zeitlin <zeitlin@dptmaths.ens-cachan.fr>
-// Licence:     wxWindows licence (part of wxExtra library)
-/////////////////////////////////////////////////////////////////////////////
-
-// for compilers that support precompilation, includes "wx.h".
-#include "wx/wxprec.h"
-
-#ifdef __BORLANDC__
-    #pragma hdrstop
-#endif
-
-#if wxUSE_MIMETYPE && wxUSE_FILE
-
-#include "wx/unix/mimetype.h"
-
-#ifndef WX_PRECOMP
-    #include "wx/dynarray.h"
-    #include "wx/string.h"
-    #include "wx/intl.h"
-    #include "wx/log.h"
-    #include "wx/utils.h"
-#endif
-
-#include "wx/file.h"
-#include "wx/confbase.h"
-
-#include "wx/ffile.h"
-#include "wx/dir.h"
-#include "wx/tokenzr.h"
-#include "wx/iconloc.h"
-#include "wx/filename.h"
-#include "wx/app.h"
-#include "wx/apptrait.h"
-
-// other standard headers
-#include <ctype.h>
-
-class wxMimeTextFile
-{
-public:
-    wxMimeTextFile()
-    {
-    }
-
-    wxMimeTextFile(const wxString& fname)
-    {
-       m_fname = fname;
-    }
-
-    bool Open()
-    {
-       wxFFile file( m_fname );
-       if (!file.IsOpened())
-          return false;
-
-       size_t size = file.Length();
-       wxCharBuffer buffer( size );
-       file.Read( (void*) (const char*) buffer, size );
-
-       // Check for valid UTF-8 here?
-       wxString all = wxString::FromUTF8( buffer, size );
-
-       wxStringTokenizer tok( all, "\n" );
-       while (tok.HasMoreTokens())
-       {
-          wxString t = tok.GetNextToken();
-          t.MakeLower();
-          if ((!!t) && (t.Find( "comment" ) != 0) && (t.Find( "#" ) != 0) && (t.Find( "generic" ) != 0))
-             m_text.Add( t );
-       }
-       return true;
-    }
-
-    unsigned int GetLineCount() const { return m_text.GetCount(); }
-    wxString &GetLine( unsigned int line ) { return m_text[line]; }
-
-    int pIndexOf(const wxString& sSearch,
-                 bool bIncludeComments = false,
-                 int iStart = 0)
-    {
-        wxString sTest = sSearch;
-        sTest.MakeLower();
-        for(size_t i = iStart; i < GetLineCount(); i++)
-        {
-            wxString sLine = GetLine(i);
-            if(bIncludeComments || ! sLine.StartsWith(wxT("#")))
-            {
-                if(sLine.StartsWith(sTest))
-                    return (int)i;
-            }
-        }
-        return wxNOT_FOUND;
-    }
-
-    wxString GetVerb(size_t i)
-    {
-        if (i > GetLineCount() )
-            return wxEmptyString;
-
-        wxString sTmp = GetLine(i).BeforeFirst(wxT('='));
-        return sTmp;
-    }
-
-    wxString GetCmd(size_t i)
-    {
-        if (i > GetLineCount() )
-            return wxEmptyString;
-
-        wxString sTmp = GetLine(i).AfterFirst(wxT('='));
-        return sTmp;
-    }
-
-private:
-    wxArrayString m_text;
-    wxString m_fname;
-};
-
-// ----------------------------------------------------------------------------
-// constants
-// ----------------------------------------------------------------------------
-
-// MIME code tracing mask
-#define TRACE_MIME wxT("mime")
-
-
-// Read a XDG *.desktop file of type 'Application'
-void wxMimeTypesManagerImpl::LoadXDGApp(const wxString& filename)
-{
-    wxLogTrace(TRACE_MIME, wxT("loading XDG file %s"), filename.c_str());
-
-    wxMimeTextFile file(filename);
-    if ( !file.Open() )
-        return;
-
-    // Here, only type 'Application' should be considered.
-    int nIndex = file.pIndexOf( "Type=" );
-    if (nIndex != wxNOT_FOUND && file.GetCmd(nIndex) != "application")
-        return;
-
-    // The hidden entry specifies a file to be ignored.
-    nIndex = file.pIndexOf( "Hidden=" );
-    if (nIndex != wxNOT_FOUND && file.GetCmd(nIndex) == "true")
-        return;
-
-    // Semicolon separated list of mime types handled by the application.
-    nIndex = file.pIndexOf( wxT("MimeType=") );
-    if (nIndex == wxNOT_FOUND)
-        return;
-    wxString mimetypes = file.GetCmd (nIndex);
-
-    // Name of the application
-    wxString nameapp;
-    nIndex = wxNOT_FOUND;
-#if wxUSE_INTL // try "Name[locale name]" first
-    wxLocale *locale = wxGetLocale();
-    if ( locale )
-        nIndex = file.pIndexOf(wxT("Name[")+locale->GetName()+wxT("]="));
-#endif // wxUSE_INTL
-    if(nIndex == wxNOT_FOUND)
-        nIndex = file.pIndexOf( wxT("Name=") );
-    if(nIndex != wxNOT_FOUND)
-        nameapp = file.GetCmd(nIndex);
-
-    // Icon of the application.
-    wxString nameicon, namemini;
-    nIndex = wxNOT_FOUND;
-#if wxUSE_INTL // try "Icon[locale name]" first
-    if ( locale )
-        nIndex = file.pIndexOf(wxT("Icon[")+locale->GetName()+wxT("]="));
-#endif // wxUSE_INTL
-    if(nIndex == wxNOT_FOUND)
-        nIndex = file.pIndexOf( wxT("Icon=") );
-    if(nIndex != wxNOT_FOUND) {
-        nameicon = wxString(wxT("--icon ")) + file.GetCmd(nIndex);
-        namemini = wxString(wxT("--miniicon ")) + file.GetCmd(nIndex);
-    }
-
-    // Replace some of the field code in the 'Exec' entry.
-    // TODO: deal with %d, %D, %n, %N, %k and %v (but last one is deprecated)
-    nIndex = file.pIndexOf( wxT("Exec=") );
-    if (nIndex == wxNOT_FOUND)
-        return;
-    wxString sCmd = file.GetCmd(nIndex);
-    // we expect %f; others including  %F and %U and %u are possible
-    sCmd.Replace(wxT("%F"), wxT("%f"));
-    sCmd.Replace(wxT("%U"), wxT("%f"));
-    sCmd.Replace(wxT("%u"), wxT("%f"));
-    if (0 == sCmd.Replace ( wxT("%f"), wxT("%s") ))
-        sCmd = sCmd + wxT(" %s");
-    sCmd.Replace(wxT("%c"), nameapp);
-    sCmd.Replace(wxT("%i"), nameicon);
-    sCmd.Replace(wxT("%m"), namemini);
-
-    wxStringTokenizer tokenizer(mimetypes, wxT(";"));
-    while(tokenizer.HasMoreTokens()) {
-        wxString mimetype = tokenizer.GetNextToken().Lower();
-        nIndex = m_aTypes.Index(mimetype);
-        if(nIndex != wxNOT_FOUND) { // is this a known MIME type?
-            wxMimeTypeCommands* entry = m_aEntries[nIndex];
-            entry->AddOrReplaceVerb(wxT("open"), sCmd);
-        }
-    }
-}
-
-void wxMimeTypesManagerImpl::LoadXDGAppsFilesFromDir(const wxString& dirname)
-{
-    // Don't complain if we don't have permissions to read - it confuses users
-    wxLogNull logNull;
-
-    if(! wxDir::Exists(dirname))
-        return;
-    wxDir dir(dirname);
-    if ( !dir.IsOpened() )
-        return;
-
-    wxString filename;
-    // Look into .desktop files
-    bool cont = dir.GetFirst(&filename, wxT("*.desktop"), wxDIR_FILES);
-    while (cont)
-    {
-        wxFileName p(dirname, filename);
-        LoadXDGApp( p.GetFullPath() );
-        cont = dir.GetNext(&filename);
-    }
-
-#if 0
-    // RR: I'm not sure this makes any sense. On my system we'll just
-    //     scan the YAST2 and other useless directories
-
-    // Look recursively into subdirs
-    cont = dir.GetFirst(&filename, wxEmptyString, wxDIR_DIRS);
-    while (cont)
-    {
-        wxFileName p(dirname, wxEmptyString);
-        p.AppendDir(filename);
-        LoadXDGAppsFilesFromDir( p.GetPath() );
-        cont = dir.GetNext(&filename);
-    }
-#endif
-}
-
-
-void wxMimeTypesManagerImpl::LoadXDGGlobs(const wxString& filename)
-{
-    if ( !wxFileName::FileExists(filename) )
-        return;
-
-    wxLogTrace(TRACE_MIME, wxT("loading XDG globs file from %s"), filename.c_str());
-
-    wxMimeTextFile file(filename);
-    if ( !file.Open() )
-        return;
-
-    size_t i;
-    for (i = 0; i < file.GetLineCount(); i++)
-    {
-       wxStringTokenizer tok( file.GetLine(i), ":" );
-       wxString mime = tok.GetNextToken();
-       wxString ext = tok.GetNextToken();
-       ext.Remove( 0, 2 );
-       wxArrayString exts;
-       exts.Add( ext );
-
-       AddToMimeData(mime, wxEmptyString, NULL, exts, wxEmptyString, true );
-    }
-}
-
-// ----------------------------------------------------------------------------
-// wxFileTypeImpl (Unix)
-// ----------------------------------------------------------------------------
-
-wxString wxFileTypeImpl::GetExpandedCommand(const wxString & verb, const wxFileType::MessageParameters& params) const
-{
-    wxString sTmp;
-    size_t i = 0;
-    while ( (i < m_index.GetCount() ) && sTmp.empty() )
-    {
-        sTmp = m_manager->GetCommand( verb, m_index[i] );
-        i++;
-    }
-
-    return wxFileType::ExpandCommand(sTmp, params);
-}
-
-bool wxFileTypeImpl::GetIcon(wxIconLocation *iconLoc) const
-{
-    wxString sTmp;
-    size_t i = 0;
-    while ( (i < m_index.GetCount() ) && sTmp.empty() )
-    {
-        sTmp = m_manager->m_aIcons[m_index[i]];
-        i++;
-    }
-
-    if ( sTmp.empty() )
-        return false;
-
-    if ( iconLoc )
-    {
-        iconLoc->SetFileName(sTmp);
-    }
-
-    return true;
-}
-
-bool wxFileTypeImpl::GetMimeTypes(wxArrayString& mimeTypes) const
-{
-    mimeTypes.Clear();
-    size_t nCount = m_index.GetCount();
-    for (size_t i = 0; i < nCount; i++)
-        mimeTypes.Add(m_manager->m_aTypes[m_index[i]]);
-
-    return true;
-}
-
-size_t wxFileTypeImpl::GetAllCommands(wxArrayString *verbs,
-                                  wxArrayString *commands,
-                                  const wxFileType::MessageParameters& params) const
-{
-    wxString vrb, cmd, sTmp;
-    size_t count = 0;
-    wxMimeTypeCommands * sPairs;
-
-    // verbs and commands have been cleared already in mimecmn.cpp...
-    // if we find no entries in the exact match, try the inexact match
-    for (size_t n = 0; ((count == 0) && (n < m_index.GetCount())); n++)
-    {
-        // list of verb = command pairs for this mimetype
-        sPairs = m_manager->m_aEntries [m_index[n]];
-        size_t i;
-        for ( i = 0; i < sPairs->GetCount(); i++ )
-        {
-            vrb = sPairs->GetVerb(i);
-            // some gnome entries have "." inside
-            vrb = vrb.AfterLast(wxT('.'));
-            cmd = sPairs->GetCmd(i);
-            if (! cmd.empty() )
-            {
-                 cmd = wxFileType::ExpandCommand(cmd, params);
-                 count++;
-                 if ( vrb.IsSameAs(wxT("open")))
-                 {
-                     if ( verbs )
-                        verbs->Insert(vrb, 0u);
-                     if ( commands )
-                        commands ->Insert(cmd, 0u);
-                 }
-                 else
-                 {
-                     if ( verbs )
-                        verbs->Add(vrb);
-                     if ( commands )
-                        commands->Add(cmd);
-                 }
-             }
-        }
-    }
-
-    return count;
-}
-
-bool wxFileTypeImpl::GetExtensions(wxArrayString& extensions)
-{
-    const wxString strExtensions = m_manager->GetExtension(m_index[0]);
-    extensions.Empty();
-
-    // one extension in the space or comma-delimited list
-    wxString strExt;
-    wxString::const_iterator end = strExtensions.end();
-    for ( wxString::const_iterator p = strExtensions.begin(); /* nothing */; ++p )
-    {
-        if ( p == end || *p == wxT(' ') || *p == wxT(',') )
-        {
-            if ( !strExt.empty() )
-            {
-                extensions.Add(strExt);
-                strExt.Empty();
-            }
-            //else: repeated spaces
-            // (shouldn't happen, but it's not that important if it does happen)
-
-            if ( p == end )
-                break;
-        }
-        else if ( *p == wxT('.') )
-        {
-            // remove the dot from extension (but only if it's the first char)
-            if ( !strExt.empty() )
-            {
-                strExt += wxT('.');
-            }
-            //else: no, don't append it
-        }
-        else
-        {
-            strExt += *p;
-        }
-    }
-
-    return true;
-}
-
-// set an arbitrary command:
-// could adjust the code to ask confirmation if it already exists and
-// overwriteprompt is true, but this is currently ignored as *Associate* has
-// no overwrite prompt
-bool
-wxFileTypeImpl::SetCommand(const wxString& cmd,
-                           const wxString& verb,
-                           bool WXUNUSED(overwriteprompt))
-{
-    wxArrayString strExtensions;
-    wxString strDesc, strIcon;
-
-    wxArrayString strTypes;
-    GetMimeTypes(strTypes);
-    if ( strTypes.IsEmpty() )
-        return false;
-
-    wxMimeTypeCommands *entry = new wxMimeTypeCommands();
-    entry->Add(verb + wxT("=")  + cmd + wxT(" %s "));
-
-    bool ok = false;
-    size_t nCount = strTypes.GetCount();
-    for ( size_t i = 0; i < nCount; i++ )
-    {
-        if ( m_manager->DoAssociation
-                        (
-                            strTypes[i],
-                            strIcon,
-                            entry,
-                            strExtensions,
-                            strDesc
-                        ) )
-        {
-            // DoAssociation() took ownership of entry, don't delete it below
-            ok = true;
-        }
-    }
-
-    if ( !ok )
-        delete entry;
-
-    return ok;
-}
-
-// ignore index on the grounds that we only have one icon in a Unix file
-bool wxFileTypeImpl::SetDefaultIcon(const wxString& strIcon, int WXUNUSED(index))
-{
-    if (strIcon.empty())
-        return false;
-
-    wxArrayString strExtensions;
-    wxString strDesc;
-
-    wxArrayString strTypes;
-    GetMimeTypes(strTypes);
-    if ( strTypes.IsEmpty() )
-        return false;
-
-    wxMimeTypeCommands *entry = new wxMimeTypeCommands();
-    bool ok = false;
-    size_t nCount = strTypes.GetCount();
-    for ( size_t i = 0; i < nCount; i++ )
-    {
-        if ( m_manager->DoAssociation
-                        (
-                            strTypes[i],
-                            strIcon,
-                            entry,
-                            strExtensions,
-                            strDesc
-                        ) )
-        {
-            // we don't need to free entry now, DoAssociation() took ownership
-            // of it
-            ok = true;
-        }
-    }
-
-    if ( !ok )
-        delete entry;
-
-    return ok;
-}
-
-// ----------------------------------------------------------------------------
-// wxMimeTypesManagerImpl (Unix)
-// ----------------------------------------------------------------------------
-
-wxMimeTypesManagerImpl::wxMimeTypesManagerImpl()
-{
-    m_initialized = false;
-}
-
-void wxMimeTypesManagerImpl::InitIfNeeded()
-{
-    if ( !m_initialized )
-    {
-        // set the flag first to prevent recursion
-        m_initialized = true;
-
-        wxString wm = wxTheApp->GetTraits()->GetDesktopEnvironment();
-
-        if (wm == wxT("KDE"))
-            Initialize( wxMAILCAP_KDE  );
-        else if (wm == wxT("GNOME"))
-            Initialize( wxMAILCAP_GNOME );
-        else
-            Initialize();
-    }
-}
-
-
-
-// read system and user mailcaps and other files
-void wxMimeTypesManagerImpl::Initialize(int mailcapStyles,
-                                        const wxString& sExtraDir)
-{
-#ifdef __VMS
-    // XDG tables are never installed on OpenVMS
-    return;
-#else
-
-    // Read MIME type - extension associations
-    LoadXDGGlobs( "/usr/share/mime/globs" );
-    LoadXDGGlobs( "/usr/local/share/mime/globs" );
-
-    // Load desktop files for XDG, and then override them with the defaults.
-    // We will override them one desktop file at a time, rather
-    // than one mime type at a time, but it should be a reasonable
-    // heuristic.
-    {
-        wxString xdgDataHome = wxGetenv("XDG_DATA_HOME");
-        if ( xdgDataHome.empty() )
-            xdgDataHome = wxGetHomeDir() + "/.local/share";
-        wxString xdgDataDirs = wxGetenv("XDG_DATA_DIRS");
-        if ( xdgDataDirs.empty() )
-        {
-            xdgDataDirs = "/usr/local/share:/usr/share";
-            if (mailcapStyles & wxMAILCAP_GNOME)
-                xdgDataDirs += ":/usr/share/gnome:/opt/gnome/share";
-            if (mailcapStyles & wxMAILCAP_KDE)
-                xdgDataDirs += ":/usr/share/kde3:/opt/kde3/share";
-        }
-        if ( !sExtraDir.empty() )
-        {
-           xdgDataDirs += ':';
-           xdgDataDirs += sExtraDir;
-        }
-
-        wxArrayString dirs;
-        wxStringTokenizer tokenizer(xdgDataDirs, ":");
-        while ( tokenizer.HasMoreTokens() )
-        {
-            wxString p = tokenizer.GetNextToken();
-            dirs.Add(p);
-        }
-        dirs.insert(dirs.begin(), xdgDataHome);
-
-        wxString defaultsList;
-        size_t i;
-        for (i = 0; i < dirs.GetCount(); i++)
-        {
-            wxString f = dirs[i];
-            if (f.Last() != '/') f += '/';
-            f += "applications/defaults.list";
-            if (wxFileExists(f))
-            {
-                defaultsList = f;
-                break;
-            }
-        }
-
-        // Load application files and associate them to corresponding mime types.
-        size_t nDirs = dirs.GetCount();
-        for (size_t nDir = 0; nDir < nDirs; nDir++)
-        {
-            wxString dirStr = dirs[nDir];
-            if (dirStr.Last() != '/') dirStr += '/';
-            dirStr += "applications";
-            LoadXDGAppsFilesFromDir(dirStr);
-        }
-
-        if (!defaultsList.IsEmpty())
-        {
-            wxArrayString deskTopFilesSeen;
-
-            wxMimeTextFile textfile(defaultsList);
-            if ( textfile.Open() )
-            {
-                int nIndex = textfile.pIndexOf( wxT("[Default Applications]") );
-                if (nIndex != wxNOT_FOUND)
-                {
-                    for (i = nIndex+1; i < textfile.GetLineCount(); i++)
-                    {
-                        if (textfile.GetLine(i).Find(wxT("=")) != wxNOT_FOUND)
-                        {
-                            wxString desktopFile = textfile.GetCmd(i);
-
-                            if (deskTopFilesSeen.Index(desktopFile) == wxNOT_FOUND)
-                            {
-                                deskTopFilesSeen.Add(desktopFile);
-                                size_t j;
-                                for (j = 0; j < dirs.GetCount(); j++)
-                                {
-                                    wxString desktopPath = dirs[j];
-                                    if (desktopPath.Last() != '/') desktopPath += '/';
-                                    desktopPath += "applications/";
-                                    desktopPath += desktopFile;
-
-                                    if (wxFileExists(desktopPath))
-                                        LoadXDGApp(desktopPath);
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-        }
-    }
-#endif
-}
-
-// clear data so you can read another group of WM files
-void wxMimeTypesManagerImpl::ClearData()
-{
-    m_aTypes.Clear();
-    m_aIcons.Clear();
-    m_aExtensions.Clear();
-    m_aDescriptions.Clear();
-
-    WX_CLEAR_ARRAY(m_aEntries);
-    m_aEntries.Empty();
-}
-
-wxMimeTypesManagerImpl::~wxMimeTypesManagerImpl()
-{
-    ClearData();
-}
-
-wxFileType * wxMimeTypesManagerImpl::Associate(const wxFileTypeInfo& ftInfo)
-{
-    InitIfNeeded();
-
-    wxString strType = ftInfo.GetMimeType();
-    wxString strDesc = ftInfo.GetDescription();
-    wxString strIcon = ftInfo.GetIconFile();
-
-    wxMimeTypeCommands *entry = new wxMimeTypeCommands();
-
-    if ( ! ftInfo.GetOpenCommand().empty())
-        entry->Add(wxT("open=")  + ftInfo.GetOpenCommand() + wxT(" %s "));
-    if ( ! ftInfo.GetPrintCommand().empty())
-        entry->Add(wxT("print=") + ftInfo.GetPrintCommand() + wxT(" %s "));
-
-    // now find where these extensions are in the data store and remove them
-    wxArrayString sA_Exts = ftInfo.GetExtensions();
-    wxString sExt, sExtStore;
-    size_t i, nIndex;
-    size_t nExtCount = sA_Exts.GetCount();
-    for (i=0; i < nExtCount; i++)
-    {
-        sExt = sA_Exts.Item(i);
-
-        // clean up to just a space before and after
-        sExt.Trim().Trim(false);
-        sExt = wxT(' ') + sExt + wxT(' ');
-        size_t nCount = m_aExtensions.GetCount();
-        for (nIndex = 0; nIndex < nCount; nIndex++)
-        {
-            sExtStore = m_aExtensions.Item(nIndex);
-            if (sExtStore.Replace(sExt, wxT(" ") ) > 0)
-                m_aExtensions.Item(nIndex) = sExtStore;
-        }
-    }
-
-    if ( !DoAssociation(strType, strIcon, entry, sA_Exts, strDesc) )
-        return NULL;
-
-    return GetFileTypeFromMimeType(strType);
-}
-
-bool wxMimeTypesManagerImpl::DoAssociation(const wxString& strType,
-                                           const wxString& strIcon,
-                                           wxMimeTypeCommands *entry,
-                                           const wxArrayString& strExtensions,
-                                           const wxString& strDesc)
-{
-    int nIndex = AddToMimeData(strType, strIcon, entry, strExtensions, strDesc, true);
-
-    if ( nIndex == wxNOT_FOUND )
-        return false;
-
-    return true;
-}
-
-int wxMimeTypesManagerImpl::AddToMimeData(const wxString& strType,
-                                          const wxString& strIcon,
-                                          wxMimeTypeCommands *entry,
-                                          const wxArrayString& strExtensions,
-                                          const wxString& strDesc,
-                                          bool replaceExisting)
-{
-    InitIfNeeded();
-
-    // ensure mimetype is always lower case
-    wxString mimeType = strType.Lower();
-
-    // is this a known MIME type?
-    int nIndex = m_aTypes.Index(mimeType);
-    if ( nIndex == wxNOT_FOUND )
-    {
-        // We put MIME types containing  "application" at the end, so that
-        // if the MIME type for the extention "htm" is searched for, it will
-        // rather find "text/html" than "application/x-mozilla-bookmarks".
-        if (mimeType.Find( "application" ) == 0)
-        {
-           // new file type
-           m_aTypes.Add(mimeType);
-           m_aIcons.Add(strIcon);
-           m_aEntries.Add(entry ? entry : new wxMimeTypeCommands);
-
-           // change nIndex so we can use it below to add the extensions
-           m_aExtensions.Add(wxEmptyString);
-           nIndex = m_aExtensions.size() - 1;
-
-           m_aDescriptions.Add(strDesc);
-        }
-        else
-        {
-           // new file type
-           m_aTypes.Insert(mimeType,0);
-           m_aIcons.Insert(strIcon,0);
-           m_aEntries.Insert(entry ? entry : new wxMimeTypeCommands,0);
-
-           // change nIndex so we can use it below to add the extensions
-           m_aExtensions.Insert(wxEmptyString,0);
-           nIndex = 0;
-
-           m_aDescriptions.Insert(strDesc,0);
-        }
-    }
-    else // yes, we already have it
-    {
-        if ( replaceExisting )
-        {
-            // if new description change it
-            if ( !strDesc.empty())
-                m_aDescriptions[nIndex] = strDesc;
-
-            // if new icon change it
-            if ( !strIcon.empty())
-                m_aIcons[nIndex] = strIcon;
-
-            if ( entry )
-            {
-                delete m_aEntries[nIndex];
-                m_aEntries[nIndex] = entry;
-            }
-        }
-        else // add data we don't already have ...
-        {
-            // if new description add only if none
-            if ( m_aDescriptions[nIndex].empty() )
-                m_aDescriptions[nIndex] = strDesc;
-
-            // if new icon and no existing icon
-            if ( m_aIcons[nIndex].empty() )
-                m_aIcons[nIndex] = strIcon;
-
-            // add any new entries...
-            if ( entry )
-            {
-                wxMimeTypeCommands *entryOld = m_aEntries[nIndex];
-
-                size_t count = entry->GetCount();
-                for ( size_t i = 0; i < count; i++ )
-                {
-                    const wxString& verb = entry->GetVerb(i);
-                    if ( !entryOld->HasVerb(verb) )
-                    {
-                        entryOld->AddOrReplaceVerb(verb, entry->GetCmd(i));
-                    }
-                }
-
-                // as we don't store it anywhere, it won't be deleted later as
-                // usual -- do it immediately instead
-                delete entry;
-            }
-        }
-    }
-
-    // always add the extensions to this mimetype
-    wxString& exts = m_aExtensions[nIndex];
-
-    // add all extensions we don't have yet
-    wxString ext;
-    size_t count = strExtensions.GetCount();
-    for ( size_t i = 0; i < count; i++ )
-    {
-        ext = strExtensions[i];
-        ext += wxT(' ');
-
-        if ( exts.Find(ext) == wxNOT_FOUND )
-        {
-            exts += ext;
-        }
-    }
-
-    // check data integrity
-    wxASSERT( m_aTypes.GetCount() == m_aEntries.GetCount() &&
-              m_aTypes.GetCount() == m_aExtensions.GetCount() &&
-              m_aTypes.GetCount() == m_aIcons.GetCount() &&
-              m_aTypes.GetCount() == m_aDescriptions.GetCount() );
-
-    return nIndex;
-}
-
-wxFileType * wxMimeTypesManagerImpl::GetFileTypeFromExtension(const wxString& ext)
-{
-    if (ext.empty() )
-        return NULL;
-
-    InitIfNeeded();
-
-    size_t count = m_aExtensions.GetCount();
-    for ( size_t n = 0; n < count; n++ )
-    {
-        wxStringTokenizer tk(m_aExtensions[n], wxT(' '));
-
-        while ( tk.HasMoreTokens() )
-        {
-            // consider extensions as not being case-sensitive
-            if ( tk.GetNextToken().IsSameAs(ext, false /* no case */) )
-            {
-                // found
-                wxFileType *fileType = new wxFileType;
-                fileType->m_impl->Init(this, n);
-
-                return fileType;
-            }
-        }
-    }
-
-    return NULL;
-}
-
-wxFileType * wxMimeTypesManagerImpl::GetFileTypeFromMimeType(const wxString& mimeType)
-{
-    InitIfNeeded();
-
-    wxFileType * fileType = NULL;
-    // mime types are not case-sensitive
-    wxString mimetype(mimeType);
-    mimetype.MakeLower();
-
-    // first look for an exact match
-    int index = m_aTypes.Index(mimetype);
-
-    if ( index != wxNOT_FOUND )
-    {
-        fileType = new wxFileType;
-        fileType->m_impl->Init(this, index);
-    }
-
-    // then try to find "text/*" as match for "text/plain" (for example)
-    // NB: if mimeType doesn't contain '/' at all, BeforeFirst() will return
-    //     the whole string - ok.
-
-    index = wxNOT_FOUND;
-    wxString strCategory = mimetype.BeforeFirst(wxT('/'));
-
-    size_t nCount = m_aTypes.GetCount();
-    for ( size_t n = 0; n < nCount; n++ )
-    {
-        if ( (m_aTypes[n].BeforeFirst(wxT('/')) == strCategory ) &&
-                m_aTypes[n].AfterFirst(wxT('/')) == wxT("*") )
-        {
-            index = n;
-            break;
-        }
-    }
-
-    if ( index != wxNOT_FOUND )
-    {
-       // don't throw away fileType that was already found
-        if (!fileType)
-            fileType = new wxFileType;
-        fileType->m_impl->Init(this, index);
-    }
-
-    return fileType;
-}
-
-wxString wxMimeTypesManagerImpl::GetCommand(const wxString & verb, size_t nIndex) const
-{
-    wxString command, testcmd, sV, sTmp;
-    sV = verb + wxT("=");
-
-    // list of verb = command pairs for this mimetype
-    wxMimeTypeCommands * sPairs = m_aEntries [nIndex];
-
-    size_t i;
-    size_t nCount = sPairs->GetCount();
-    for ( i = 0; i < nCount; i++ )
-    {
-        sTmp = sPairs->GetVerbCmd (i);
-        if ( sTmp.Contains(sV) )
-            command = sTmp.AfterFirst(wxT('='));
-    }
-
-    return command;
-}
-
-void wxMimeTypesManagerImpl::AddFallback(const wxFileTypeInfo& filetype)
-{
-    InitIfNeeded();
-
-    wxString extensions;
-    const wxArrayString& exts = filetype.GetExtensions();
-    size_t nExts = exts.GetCount();
-    for ( size_t nExt = 0; nExt < nExts; nExt++ )
-    {
-        if ( nExt > 0 )
-            extensions += wxT(' ');
-
-        extensions += exts[nExt];
-    }
-
-    AddMimeTypeInfo(filetype.GetMimeType(),
-                    extensions,
-                    filetype.GetDescription());
-}
-
-void wxMimeTypesManagerImpl::AddMimeTypeInfo(const wxString& strMimeType,
-                                             const wxString& strExtensions,
-                                             const wxString& strDesc)
-{
-    // reading mailcap may find image/* , while
-    // reading mime.types finds image/gif and no match is made
-    // this means all the get functions don't work  fix this
-    wxString strIcon;
-    wxString sTmp = strExtensions;
-
-    wxArrayString sExts;
-    sTmp.Trim().Trim(false);
-
-    while (!sTmp.empty())
-    {
-        sExts.Add(sTmp.AfterLast(wxT(' ')));
-        sTmp = sTmp.BeforeLast(wxT(' '));
-    }
-
-    AddToMimeData(strMimeType, strIcon, NULL, sExts, strDesc, true);
-}
-
-size_t wxMimeTypesManagerImpl::EnumAllFileTypes(wxArrayString& mimetypes)
-{
-    InitIfNeeded();
-
-    mimetypes.Empty();
-
-    size_t count = m_aTypes.GetCount();
-    for ( size_t n = 0; n < count; n++ )
-    {
-        // don't return template types from here (i.e. anything containg '*')
-        const wxString &type = m_aTypes[n];
-        if ( type.Find(wxT('*')) == wxNOT_FOUND )
-        {
-            mimetypes.Add(type);
-        }
-    }
-
-    return mimetypes.GetCount();
-}
-
-// ----------------------------------------------------------------------------
-// writing to MIME type files
-// ----------------------------------------------------------------------------
-
-bool wxMimeTypesManagerImpl::Unassociate(wxFileType *ft)
-{
-    InitIfNeeded();
-
-    wxArrayString sMimeTypes;
-    ft->GetMimeTypes(sMimeTypes);
-
-    size_t i;
-    size_t nCount = sMimeTypes.GetCount();
-    for (i = 0; i < nCount; i ++)
-    {
-        const wxString &sMime = sMimeTypes.Item(i);
-        int nIndex = m_aTypes.Index(sMime);
-        if ( nIndex == wxNOT_FOUND)
-        {
-            // error if we get here ??
-            return false;
-        }
-        else
-        {
-            m_aTypes.RemoveAt(nIndex);
-            m_aEntries.RemoveAt(nIndex);
-            m_aExtensions.RemoveAt(nIndex);
-            m_aDescriptions.RemoveAt(nIndex);
-            m_aIcons.RemoveAt(nIndex);
-        }
-    }
-    // check data integrity
-    wxASSERT( m_aTypes.GetCount() == m_aEntries.GetCount() &&
-            m_aTypes.GetCount() == m_aExtensions.GetCount() &&
-            m_aTypes.GetCount() == m_aIcons.GetCount() &&
-            m_aTypes.GetCount() == m_aDescriptions.GetCount() );
-
-    return true;
-}
-
-#endif
-  // wxUSE_MIMETYPE && wxUSE_FILE
Index: src/symbian/sockunix.cpp
===================================================================
--- src/symbian/sockunix.cpp	(revision 62850)
+++ src/symbian/sockunix.cpp	(working copy)
@@ -1,206 +0,0 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        src/symbian/sockunix.cpp
-// Purpose:     wxSocketImpl implementation for Symbian (based on Unix)
-// Authors:     Guilhem Lavaux, Guillermo Rodriguez Garcia, David Elliott,
-//              Andrei Matuk, Vadim Zeitlin
-// Created:     April 1997
-// RCS-ID:      $Id$
-// Copyright:   (c) 1997 Guilhem Lavaux
-//              (c) 2008 Vadim Zeitlin
-// Licence:     wxWindows licence
-/////////////////////////////////////////////////////////////////////////////
-
-
-#include "wx/wxprec.h"
-
-#if wxUSE_SOCKETS
-
-#include "wx/private/fd.h"
-#include "wx/private/socket.h"
-#include "wx/unix/sockunix.h"
-#include <errno.h>
-
-#ifndef SOCKOPTLEN_T
-    #define SOCKOPTLEN_T WX_SOCKLEN_T
-#endif
-
-// ============================================================================
-// wxSocketImpl implementation
-// ============================================================================
-
-wxSocketError wxSocketImplUnix::GetLastError() const
-{
-    switch ( errno )
-    {
-        case 0:
-            return wxSOCKET_NOERROR;
-
-        case ENOTSOCK:
-            return wxSOCKET_INVSOCK;
-
-        // unfortunately EAGAIN only has the "would block" meaning for read(),
-        // not for connect() for which it means something rather different but
-        // we can't distinguish between these two situations currently...
-        //
-        // also notice that EWOULDBLOCK can be different from EAGAIN on some
-        // systems (HP-UX being the only known example) while it's defined as
-        // EAGAIN on most others (e.g. Linux)
-        case EAGAIN:
-#ifdef EWOULDBLOCK
-    #if EWOULDBLOCK != EAGAIN
-        case EWOULDBLOCK:
-    #endif
-#endif // EWOULDBLOCK
-        case EINPROGRESS:
-            return wxSOCKET_WOULDBLOCK;
-
-        default:
-            return wxSOCKET_IOERR;
-    }
-}
-
-void wxSocketImplUnix::DoEnableEvents(int flags, bool enable)
-{
-    wxSocketManager * const manager = wxSocketManager::Get();
-    if (!manager)
-        return;
-
-    if ( enable )
-    {
-        if ( flags & wxSOCKET_INPUT_FLAG )
-            manager->Install_Callback(this, wxSOCKET_INPUT);
-        if ( flags & wxSOCKET_OUTPUT_FLAG )
-            manager->Install_Callback(this, wxSOCKET_OUTPUT);
-    }
-    else // off
-    {
-        if ( flags & wxSOCKET_INPUT_FLAG )
-            manager->Uninstall_Callback(this, wxSOCKET_INPUT);
-        if ( flags & wxSOCKET_OUTPUT_FLAG )
-            manager->Uninstall_Callback(this, wxSOCKET_OUTPUT);
-    }
-}
-
-int wxSocketImplUnix::CheckForInput()
-{
-    char c;
-    int rc;
-    do
-    {
-        rc = recv(m_fd, &c, 1, MSG_PEEK);
-    } while ( rc == -1 && errno == EINTR );
-
-    return rc;
-}
-
-void wxSocketImplUnix::OnStateChange(wxSocketNotify event)
-{
-    NotifyOnStateChange(event);
-
-    if ( event == wxSOCKET_LOST )
-        Shutdown();
-}
-
-void wxSocketImplUnix::OnReadWaiting()
-{
-    wxASSERT_MSG( m_fd != INVALID_SOCKET, wxT("invalid socket ready for reading?") );
-
-    // we need to disable the read notifications until we read all the data
-    // already available for the socket, otherwise we're going to keep getting
-    // them continuously which is worse than inefficient: as IO notifications
-    // have higher priority than idle events in e.g. GTK+, our pending events
-    // whose handlers typically call Read() which would consume the data and so
-    // stop the notifications flood would never be dispatched at all if the
-    // notifications were not disabled
-    DisableEvents(wxSOCKET_INPUT_FLAG);
-
-
-    // find out what are we going to notify about exactly
-    wxSocketNotify notify;
-
-    // TCP listening sockets become ready for reading when there is a pending
-    // connection
-    if ( m_server && m_stream )
-    {
-        notify = wxSOCKET_CONNECTION;
-    }
-    else // check if there is really any input available
-    {
-        switch ( CheckForInput() )
-        {
-            case 1:
-                notify = wxSOCKET_INPUT;
-                break;
-
-            case 0:
-                // reading 0 bytes for a TCP socket means that the connection
-                // was closed by peer but for UDP it just means that we got an
-                // empty datagram
-                notify = m_stream ? wxSOCKET_LOST : wxSOCKET_INPUT;
-                break;
-
-            default:
-                wxFAIL_MSG( wxT("unexpected CheckForInput() return value") );
-                // fall through
-
-            case -1:
-                if ( GetLastError() == wxSOCKET_WOULDBLOCK )
-                {
-                    // just a spurious wake up
-                    EnableEvents(wxSOCKET_INPUT_FLAG);
-                    return;
-                }
-
-                notify = wxSOCKET_LOST;
-        }
-    }
-
-    OnStateChange(notify);
-}
-
-void wxSocketImplUnix::OnWriteWaiting()
-{
-    wxASSERT_MSG( m_fd != INVALID_SOCKET, wxT("invalid socket ready for writing?") );
-
-    // see comment in the beginning of OnReadWaiting() above
-    DisableEvents(wxSOCKET_OUTPUT_FLAG);
-
-
-    // check whether this is a notification for the completion of a
-    // non-blocking connect()
-    if ( m_establishing && !m_server )
-    {
-        m_establishing = false;
-
-        // check whether we connected successfully
-        int error;
-        SOCKOPTLEN_T len = sizeof(error);
-
-        getsockopt(m_fd, SOL_SOCKET, SO_ERROR, (void*)&error, (socklen_t*)&len);
-
-        if ( error )
-        {
-            OnStateChange(wxSOCKET_LOST);
-            return;
-        }
-
-        OnStateChange(wxSOCKET_CONNECTION);
-    }
-
-    OnStateChange(wxSOCKET_OUTPUT);
-}
-
-void wxSocketImplUnix::OnExceptionWaiting()
-{
-    // when using epoll() this is called when an error occurred on the socket
-    // so close it if it hadn't been done yet -- what else can we do?
-    //
-    // notice that we shouldn't be called at all when using select() as we
-    // don't use wxFDIO_EXCEPTION when registering the socket for monitoring
-    // and this is good because select() would call this for any OOB data which
-    // is not necessarily an error
-    if ( m_fd != INVALID_SOCKET )
-        OnStateChange(wxSOCKET_LOST);
-}
-
-#endif  /* wxUSE_SOCKETS */
Index: src/symbian/thread.cpp
===================================================================
--- src/symbian/thread.cpp	(revision 62850)
+++ src/symbian/thread.cpp	(working copy)
@@ -14,10 +14,6 @@
 // For compilers that support precompilation, includes "wx.h".
 #include "wx/wxprec.h"
 
-#if defined(__BORLANDC__)
-    #pragma hdrstop
-#endif
-
 #if wxUSE_THREADS
 
 #include "wx/thread.h"
Index: src/symbian/timer.cpp
===================================================================
--- src/symbian/timer.cpp	(revision 62850)
+++ src/symbian/timer.cpp	(working copy)
@@ -7,21 +7,12 @@
 // Licence:     wxWindows licence
 /////////////////////////////////////////////////////////////////////////////
 
-#if defined(__GNUG__) && !defined(NO_GCC_PRAGMA)
-    #pragma implementation "timer.h"
-#endif
-
 // For compilers that support precompilation, includes "wx.h".
 #include "wx/wxprec.h"
 
-#ifdef __BORLANDC__
-    #pragma hdrstop
-#endif
-
 #if wxUSE_TIMER
 
 #ifndef WX_PRECOMP
-//    #include "wx/window.h"
     #include "wx/list.h"
     #include "wx/event.h"
     #include "wx/app.h"
Index: src/symbian/utils.cpp
===================================================================
--- src/symbian/utils.cpp	(revision 62850)
+++ src/symbian/utils.cpp	(working copy)
@@ -18,10 +18,6 @@
 // For compilers that support precompilation, includes "wx.h".
 #include "wx/wxprec.h"
 
-#ifdef __BORLANDC__
-    #pragma hdrstop
-#endif
-
 #ifndef WX_PRECOMP
     #include "wx/utils.h"
     #include "wx/app.h"
@@ -161,10 +157,12 @@
 {
     CTelephony* iTelephony;
     TRequestStatus iStatus;
+    iTelephony = CTelephony::NewL(); 
     CTelephony::TBatteryInfoV1      iBatteryInfoV1;
     CTelephony::TBatteryInfoV1Pckg  iBatteryInfoV1Pckg(iBatteryInfoV1);
     iTelephony->GetBatteryInfo(iStatus, iBatteryInfoV1Pckg); // Create asynchronous request to Telephony server
     User::WaitForRequest(iStatus);
+    delete iTelephony; 
     return iBatteryInfoV1;
 }
 
Index: src/symbian/utilsexc.cpp
===================================================================
--- src/symbian/utilsexc.cpp	(revision 62850)
+++ src/symbian/utilsexc.cpp	(working copy)
@@ -15,17 +15,9 @@
 // headers
 // ----------------------------------------------------------------------------
 
-#if defined(__GNUG__) && !defined(NO_GCC_PRAGMA)
-    #pragma implementation
-#endif
-
 // For compilers that support precompilation, includes "wx.h".
 #include "wx/wxprec.h"
 
-#ifdef __BORLANDC__
-    #pragma hdrstop
-#endif
-
 #ifndef WX_PRECOMP
     #include "wx/utils.h"
     #include "wx/app.h"
