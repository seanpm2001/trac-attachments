Index: configure.in
===================================================================
--- configure.in	(revisión: 72260)
+++ configure.in	(copia de trabajo)
@@ -893,6 +893,7 @@
     DEFAULT_wxUSE_LISTBOX=no
     DEFAULT_wxUSE_LISTCTRL=no
     DEFAULT_wxUSE_MARKUP=no
+    DEFAULT_wxUSE_MASKED_EDIT=no
     DEFAULT_wxUSE_NOTEBOOK=no
     DEFAULT_wxUSE_POPUPWIN=no
     DEFAULT_wxUSE_RADIOBOX=no
@@ -964,6 +965,7 @@
 WX_ARG_FEATURE(listbook,    [  --enable-listbook       use wxListbook class], wxUSE_LISTBOOK)
 WX_ARG_FEATURE(listbox,     [  --enable-listbox        use wxListBox class], wxUSE_LISTBOX)
 WX_ARG_FEATURE(listctrl,    [  --enable-listctrl       use wxListCtrl class], wxUSE_LISTCTRL)
+WX_ARG_FEATURE(maskededit,  [  --enable-maskededit     use wxMaskedEdit class], wxUSE_MASKED_EDIT)
 WX_ARG_FEATURE(notebook,    [  --enable-notebook       use wxNotebook class], wxUSE_NOTEBOOK)
 WX_ARG_FEATURE(notifmsg,    [  --enable-notifmsg       use wxNotificationMessage class], wxUSE_NOTIFICATION_MESSAGE)
 WX_ARG_FEATURE(odcombobox,  [  --enable-odcombobox     use wxOwnerDrawnComboBox class], wxUSE_ODCOMBOBOX)
@@ -6811,6 +6813,12 @@
     USES_CONTROLS=1
 fi
 
+if test "$wxUSE_MASKED_EDIT" = "yes"; then
+  AC_DEFINE(wxUSE_MASKED_EDIT)
+  USES_CONTROLS=1
+  SAMPLES_SUBDIRS="$SAMPLES_SUBDIRS maskededit"
+fi
+
 if test "$wxUSE_NOTEBOOK" = "yes"; then
     AC_DEFINE(wxUSE_NOTEBOOK)
     USES_CONTROLS=1

Index: build/bakefiles/files.bkl
===================================================================
--- build/bakefiles/files.bkl	(revisión: 72260)
+++ build/bakefiles/files.bkl	(copia de trabajo)
@@ -2901,6 +2901,7 @@
     src/generic/helpext.cpp
     src/generic/hyperlinkg.cpp
     src/generic/laywin.cpp
+    src/generic/maskededit.cpp
     src/generic/notifmsgg.cpp
     src/generic/odcombo.cpp
     src/generic/propdlg.cpp
@@ -2941,6 +2942,7 @@
     wx/generic/helpext.h
     wx/generic/hyperlink.h
     wx/generic/laywin.h
+    wx/generic/maskededit.h
     wx/generic/notifmsg.h
     wx/generic/propdlg.h
     wx/generic/sashwin.h
@@ -2951,6 +2953,7 @@
     wx/hyperlink.h
     wx/joystick.h
     wx/laywin.h
+    wx/maskededit.h
     wx/notifmsg.h
     wx/odcombo.h
     wx/propdlg.h

Index: docs/doxygen/images/maskededit.png
===================================================================

Index: include/wx/setup_inc.h
===================================================================
--- include/wx/setup_inc.h	(revisión: 72260)
+++ include/wx/setup_inc.h	(copia de trabajo)
@@ -1006,6 +1006,13 @@
 // wxHeaderCtrl)
 #define wxUSE_REARRANGECTRL 1
 
+// wxMaskedEditText and wxMaskedEditCombo controls
+//
+// Default is 1.
+//
+// Recommended setting: 1
+#define wxUSE_MASKED_EDIT 1
+
 // ----------------------------------------------------------------------------
 // Miscellaneous GUI stuff
 // ----------------------------------------------------------------------------

Index: include/wx/maskededit.h
===================================================================
--- include/wx/maskededit.h	(revisión: 0)
+++ include/wx/maskededit.h	(revisión: 0)
@@ -0,0 +1,18 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/maskededit.h
+// Purpose:     wxMaskedEdit interface
+// Author:      Manuel Martin
+// Modified by:
+// Created:     2012-07-30
+// RCS-ID:      $Id$
+// Copyright:   (c)
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_MASKED_EDIT_H_BASE
+#define _WX_MASKED_EDIT_H_BASE
+
+#include "wx/generic/maskededit.h"
+
+#endif // _WX_MASKED_EDIT_H_BASE
+

Index: include/wx/generic/maskededit.h
===================================================================
--- include/wx/generic/maskededit.h	(revisión: 0)
+++ include/wx/generic/maskededit.h	(revisión: 0)
@@ -0,0 +1,682 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/generic/maskededit.h
+// Purpose:     wxMaskedEdit interface
+// Author:      Manuel Martin
+// Modified by:
+// Created:     2012-07-30
+// RCS-ID:      $Id$
+// Copyright:   (c)
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_MASKED_EDIT_H_
+#define _WX_MASKED_EDIT_H_
+
+#include "wx/defs.h"
+
+#if wxUSE_MASKED_EDIT
+
+#include "wx/colour.h"
+#include "wx/vector.h"
+
+#if wxUSE_TEXTCTRL
+    #include "wx/textctrl.h"
+#endif // wxUSE_TEXTCTRL
+
+#if wxUSE_COMBOBOX
+    #include "wx/combobox.h"
+#endif // wxUSE_COMBOBOX
+
+
+//Colours used for different cases.
+struct WXDLLIMPEXP_ADV wxMaskedEditColours
+{
+    //When everything is OK
+    wxColour colOKForegn;
+    wxColour colOKBackgn;
+    //When something is wrong
+    wxColour colWrForegn;
+    wxColour colWrBackgn;
+    //When nothing is filled, empty control's value
+    wxColour colEmForegn;
+    wxColour colEmBackgn;
+};
+
+//An object to store flags
+class WXDLLIMPEXP_ADV wxEditFieldFlags
+{
+public:
+    wxEditFieldFlags(wxAlignment alignment = wxALIGN_LEFT)
+    {
+        //Only left or right alignment
+        m_alignment = alignment == wxALIGN_RIGHT ? wxALIGN_RIGHT : wxALIGN_LEFT;
+        m_fillChar = wxChar(' ');
+        m_paddingChar = wxChar('\0');
+    }
+
+    //Setters for all flags. Return the object itself, so that calls to them
+    // can be chained
+
+    wxEditFieldFlags& SetAlignment(wxAlignment alignment)
+    {
+        //Only left or right alignment
+        m_alignment = alignment == wxALIGN_RIGHT ? wxALIGN_RIGHT : wxALIGN_LEFT;
+        return *this;
+    }
+
+    wxEditFieldFlags& SetFillChar(wxChar fillchar)
+    {
+        if ( !wxIsprint(fillchar) )
+        {
+            wxFAIL_MSG("Warning: Unprintable character in masked flags");
+        }
+        m_fillChar = fillchar;
+        return *this;
+    }
+
+    wxEditFieldFlags& SetPaddingChar(wxChar paddingchar)
+    {
+        if ( paddingchar != '\0' && !wxIsprint(paddingchar) )
+        {
+            wxFAIL_MSG("Warning: Unprintable character in masked flags");
+        }
+        m_paddingChar = paddingchar;
+        return *this;
+    }
+
+    //Accessors
+    wxAlignment GetAlignment()
+    {   return m_alignment; }
+
+    wxChar GetFillChar()
+    {   return m_fillChar; }
+
+    wxChar GetPaddingChar()
+    {   return m_paddingChar; }
+
+private:
+    wxAlignment m_alignment;
+    wxChar m_fillChar;
+    wxChar m_paddingChar;
+};
+
+class WXDLLIMPEXP_ADV wxMaskedEdit;
+//For field test
+typedef long wxMaskedFieldFunc(const wxMaskedEdit*, size_t, void*);
+//For whole value test
+typedef long wxMaskedFunc(const wxMaskedEdit*, void*);
+
+// All configurable parameters are stored here.
+class WXDLLIMPEXP_ADV wxMaskedEditParams
+{
+public:
+    wxMaskedEditParams()
+    {
+        ResetFields(0);
+        controlFunc = NULL;
+        controlFuncParams = NULL;
+    };
+    ~wxMaskedEditParams() {};
+
+    //Reset the per field parameters.
+    void ResetFields(size_t numFields)
+    {
+        fieldsFlags.clear();
+        fieldsFlags.resize(numFields);
+        fieldsFuncs.clear();
+        fieldsFuncs.resize(numFields, NULL);
+        fieldFuncsParams.clear();
+        fieldFuncsParams.resize(numFields, NULL);
+    }
+
+    //The mask.
+    wxString mask;
+
+    //Colours used for different cases. The whole control is coloured.
+    wxMaskedEditColours colours;
+
+    //Fields settings containers.
+    //Flags
+    wxVector<wxEditFieldFlags> fieldsFlags;
+
+    //Functions to test a field
+    wxVector<wxMaskedFieldFunc*> fieldsFuncs;
+    //And their parameters
+    wxVector<void*> fieldFuncsParams;
+
+    //Function for the whole control
+    wxMaskedFunc* controlFunc;
+    //And its parameters
+    void* controlFuncParams;
+};
+
+
+// ----------------------------------------------------------------------------
+// Base class for all masked edit controls
+// ----------------------------------------------------------------------------
+
+class WXDLLIMPEXP_ADV wxMaskedEdit
+{
+public:
+    //ctor.
+    wxMaskedEdit()
+    { m_bellOnError = true; }
+
+    //dtor.
+    ~wxMaskedEdit() {};
+
+    //Control configuration -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
+    //Setters for configuration parameters. Replace old ones.
+    //Sets the mask. If no field is defined, it returns false.
+    /* Characters and their meaning:
+      #    Required digit.
+      9    Optional digit.
+      A    Required alpha character.
+      a    Optional alpha character.
+      N    Required alphanumeric character (i.e. letter or digit).
+      n    Optional alphanumeric character.
+      C    Required character (any printable).
+      c    Optional character (any printable).
+      X    Required hexadecimal character [0-F]
+      x    Optional hexadecimal character [0-F]
+      {x}  The previous character (one of the above) is taken x times. This
+           is an "expander": #{3} expands into ###, X{4} expands into XXXX.
+      >    Convert all following characters to upper case.
+      <    Convert all following characters to lower case.
+      ^    Switch off upper/lower case conversion.
+      \    Escape the next character and use it as a literal.
+     Note the above specifications are tested using wxIsxxx functions. So,
+     they are locale dependant.
+     Any other char is a literal. It is shown in the control, but it can
+     not be edited.
+     Literals are also used as fields separators.
+     '|'  is a special literal. It's invisible, takes no space, but still
+     is a fields separator.
+
+     Space is not a character (except for C and c commands).
+    */
+
+    bool SetMask(const wxString& mask);
+
+    //Set the colours for different cases.
+    void SetMaskedColours(const wxMaskedEditColours& colours);
+
+    //Set the flags for a field.
+    void SetFieldFlags(size_t index, const wxEditFieldFlags& flags)
+    {
+        m_params.fieldsFlags.at(index) = flags;
+    }
+
+    //Set all fields with the same flags.
+    void SetAllFieldsFlags(const wxEditFieldFlags& flags);
+
+    //Set the test function for a field.
+    void SetFieldFunction(size_t index, wxMaskedFieldFunc* fn, void* param);
+
+    //Set all fields with the same functions.
+    void SetAllFieldsFunction(wxMaskedFieldFunc* fn, void* param);
+
+    //Set the test function for the whole control.
+    void SetControlFunction(wxMaskedFunc* fn, void* param);
+
+    //Set all parameters at once, replacing old ones.
+    bool SetParams(const wxMaskedEditParams& params);
+
+    //Set the control's value from a undecorated text.
+    bool SetPlainValue(const wxString& plainValue);
+
+    //Sets the value for a field.
+    bool SetFieldValue(size_t index, const wxString& plainValue);
+
+    //Check characters, fields and the whole control's value.
+    long IsValid();
+
+    //Bell on error.
+    void SetBellOnError(bool bell)
+    {
+        m_bellOnError = bell;
+    }
+
+
+    //Accessors -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
+    //Get the number of fields.
+    size_t GetFieldsCount() const
+    {
+        return m_arrPosS.size();
+    }
+
+    //Get control's value, without decorations.
+    wxString GetPlainValue() const;
+
+    //Get the current text in a field. Empty cells are filled with the padding
+    //char set for this field.
+    wxString GetFieldValue(size_t index) const;
+
+    //Get the mask. The string passed at SetMask()
+    wxString GetMask() const
+    {
+        return m_params.mask;
+    }
+
+    //Get the colours for different cases.
+    wxMaskedEditColours GetMaskedColours() const
+    {
+        return m_params.colours;
+    }
+
+    //Get the flags used in a field.
+    wxEditFieldFlags GetFieldFlags(size_t index) const
+    {
+        return m_params.fieldsFlags.at(index);
+    }
+
+    //Get the parameters.
+    wxMaskedEditParams GetParams() const
+    {
+        return m_params;
+    }
+
+    //Event handling
+    void OnKeyDown(wxKeyEvent& event);
+    void OnChar(wxKeyEvent& event);
+    void OnCut(wxCommandEvent& event);
+    void OnPaste(wxCommandEvent& event);
+#if wxUSE_COMBOBOX
+    void OnComboSelect(wxCommandEvent& event);
+    void OnComboDrop(wxCommandEvent& event);
+#endif // wxUSE_COMBOBOX
+
+protected:
+    //Like SetFieldValue(), but operates on inText, not in control
+    wxString SetFieldOnText(size_t index,
+                            const wxString& plainValue,
+                            const wxString& inText);
+
+    //Like GetFieldValue(), but operates on inText, not in control
+    wxString GetFieldOnText(size_t index,
+                            const wxString& inText,
+                            wxChar chPad) const;
+
+    //If the cell has not been filled
+    bool CellIsEmpty(long curpos) const
+    {
+        return !m_filled[(size_t)curpos];
+    }
+
+    //Get the internal type for a char in the expanded mask
+    int GetMaskedType(size_t pos) const
+    {
+        return m_maskIDs[pos];
+    }
+
+    //Default colours
+    void GetDefaultColours(wxColour* defFgCol, wxColour* defBgCol);
+
+    //Handle the selection, returning the new possible control's value
+    wxString HandleSelection(long *pos, bool *changed);
+
+    //Our control derives from wxTextEntry, but not this class. Get a pointer to it
+    wxTextEntry* GetTextEntry() const;
+
+    //Update colours, depending on empty/valid/invalid cases
+    void UpdateMaskedColours();
+
+    //Join characters and align the field
+    void NormalizeField(size_t index, wxString* inText);
+
+    //Test if the field has a free cell for a char.
+    bool HasFieldRoom(size_t index) const;
+
+    //Find the field in which the cursor is.
+    int FindField(long curpos) const;
+    //Find the field to insert a char in the given position.
+    int GuessField(long pos) const;
+
+    //A reasonable position for caret in the previous field to where the caret is.
+    long PosForFieldPrev(long curpos) const;
+    //A reasonable position for caret in the next field to where the caret is.
+    long PosForFieldNext(long curpos) const;
+
+    //Move caret from current position to the foreseeable one
+    long MoveCaret(long curPos, bool toRight);
+
+    //Insert a char at an intended position. Returns false if insertion is not
+    // possible (invalid char or no room available)
+    bool InsertAtPos(wxChar iChar, long* pos, size_t index, wxString* inText);
+
+    //Process a char, coming from OnChar() or from DoPaste()
+    bool ProcessChar(wxChar aChar, long* pos, wxString* inText, bool* changed);
+
+    //Cutting
+    void DoCut();
+    //Pasting
+    void DoPaste();
+
+    //Set the proper string for SetValue/ChangeValue
+    wxString SetMaskedValue(const wxString& value);
+
+    //Show the colours
+    void UseColours(int whatColours);
+
+    enum
+    {
+        mEmColour = 1,
+        mOKColour,
+        mWRColour
+    };
+
+    //Bell
+    void DoBell()
+    {
+        if ( m_bellOnError )
+            wxBell();
+    }
+
+    //General Test Functions -  -  -  -  -  -  -  -  -
+    //Test the character according with the mask.
+    bool CharAgreesWithMask(wxChar testChar, long pos) const;
+
+    //Return the char converted to upper/lower case according with the mask
+    wxChar ToUppLowCase(wxChar ch, size_t pos);
+
+    //Test the character.
+    bool TestChar(wxChar* tryChar, long pos);
+
+    //Tell if field passed all of its tests.
+    long IsFieldValid(size_t index) const;
+
+    //Containers -  -  -  -  -  -  -  -  -  -  -  -
+    //The configuration container
+    wxMaskedEditParams m_params;
+
+    //The expanded mask
+    wxString m_ExpMask;
+    //Positions in m_ExpMask where each field starts
+    wxVector<long> m_arrPosS;
+    //Positions in m_ExpMask where each field finishes
+    wxVector<long> m_arrPosF;
+    //Internal representation of the mask, with identifiers.
+    wxVector<int> m_maskIDs;
+    //If each cell is filled with a char or it is empty
+    wxVector<bool> m_filled;
+    //Backup copy while temporary use
+    wxVector<bool> m_fillBck;
+
+    //The real control
+    wxControl* msk_control;
+
+    //Bell on error. Default is true
+    bool m_bellOnError;
+
+    //The mask identifiers
+    enum
+    {
+        mDigitReq = 1, //'#'
+        mDigitOpt,     //'9'
+        mAlphaReq,     //'A'
+        mAlphaOpt,     //'a'
+        mAlpNumReq,    //'N'
+        mAlpNumOpt,    //'n'
+        mAnyCharReq,   //'C'
+        mAnyCharOpt,   //'c'
+        mHexReq,       //'H'
+        mHexOpt,       //'H'
+        mLiteral,
+        mUppChar = 100, //'>'
+        mLowChar = 200  //'<'
+    };
+};
+
+// ----------------------------------------------------------------------------
+// Masked edit controls
+// ----------------------------------------------------------------------------
+
+#if wxUSE_TEXTCTRL
+//wxMaskedEditText is only for wxTextCtrl
+class WXDLLIMPEXP_ADV wxMaskedEditText : public wxMaskedEdit,
+                                         public wxTextCtrl
+{
+public:
+    //Constructors
+    wxMaskedEditText()
+    {
+        mskInit( 0 );
+    }
+
+    wxMaskedEditText(wxWindow *parent, wxWindowID id,
+                     const wxString& value = wxEmptyString,
+                     const wxPoint& pos = wxDefaultPosition,
+                     const wxSize& size = wxDefaultSize,
+                     long style = 0,
+                     const wxValidator& validator = wxDefaultValidator,
+                     const wxString& name = wxTextCtrlNameStr)
+         : wxTextCtrl(parent, id, value, pos, size, style, validator, name)
+    {
+        mskInit( style );
+        mskPostInit();
+    }
+
+    bool Create(wxWindow *parent, wxWindowID id,
+                const wxString& value = wxEmptyString,
+                const wxPoint& pos = wxDefaultPosition,
+                const wxSize& size = wxDefaultSize,
+                long style = 0,
+                const wxValidator& validator = wxDefaultValidator,
+                const wxString& name = wxTextCtrlNameStr)
+    {
+        mskInit( style );
+
+        if ( ! wxTextCtrl::Create(parent, id, value, pos, size, style,
+                                  validator, name) )
+        {
+            return false;
+        }
+        mskPostInit();
+        return true;
+    }
+
+    virtual ~wxMaskedEditText() {};
+
+    //Override SetValue()
+    virtual void SetValue(const wxString& value)
+    {
+        wxTextCtrl::SetValue( SetMaskedValue(value) );
+        //Test the new value and set colours
+        UpdateMaskedColours();
+    }
+
+    //Override ChangeValue()
+    virtual void ChangeValue(const wxString& value)
+    {
+        wxTextCtrl::ChangeValue( SetMaskedValue(value) );
+        //Test the new value and set colours
+        UpdateMaskedColours();
+    }
+
+private:
+    void mskInit( long style )
+    {
+        //Only single line control
+        if ( style & wxTE_MULTILINE )
+        {
+            wxFAIL_MSG("Multiline wxMaskedEditText not allowed yet");
+        }
+    }
+
+    void mskPostInit()
+    {
+        msk_control = this;
+
+        //Set default fixed pitch font
+        //Don't use directly m_font because wxWindowBase::SetFont decides
+        // it is the same font.
+        wxFont font = GetFont();
+        font.SetFamily(wxFONTFAMILY_TELETYPE);
+        SetFont(font);
+
+        //Event handlers
+        Bind(wxEVT_KEY_DOWN, &wxMaskedEdit::OnKeyDown, this);
+        Bind(wxEVT_CHAR, &wxMaskedEdit::OnChar, this);
+        Bind(wxEVT_COMMAND_TEXT_CUT, &wxMaskedEdit::OnCut, this);
+        Bind(wxEVT_COMMAND_TEXT_PASTE, &wxMaskedEdit::OnPaste, this);
+    }
+
+};
+#endif // wxUSE_TEXTCTRL
+
+#if wxUSE_COMBOBOX
+//wxMaskedEditCombo is only for wxComboBox
+class WXDLLIMPEXP_ADV wxMaskedEditCombo : public wxMaskedEdit,
+                                          public wxComboBox
+{
+public:
+    //Constructors
+    wxMaskedEditCombo() {};
+
+    wxMaskedEditCombo(wxWindow *parent, wxWindowID id,
+                      const wxString& value = wxEmptyString,
+                      const wxPoint& pos = wxDefaultPosition,
+                      const wxSize& size = wxDefaultSize,
+                      int n = 0, const wxString choices[] = NULL,
+                      long style = 0,
+                      const wxValidator& validator = wxDefaultValidator,
+                      const wxString& name = wxComboBoxNameStr)
+        : wxComboBox(parent, id, value, pos, size, n, choices, style, validator, name)
+    {
+        mskPostInit();
+    }
+
+    wxMaskedEditCombo(wxWindow *parent, wxWindowID id,
+                      const wxString& value,
+                      const wxPoint& pos,
+                      const wxSize& size,
+                      const wxArrayString& choices,
+                      long style = 0,
+                      const wxValidator& validator = wxDefaultValidator,
+                      const wxString& name = wxComboBoxNameStr)
+        : wxComboBox(parent, id, value, pos, size, choices, style, validator, name)
+    {
+        mskPostInit();
+    }
+
+    bool Create(wxWindow *parent,
+                wxWindowID id,
+                const wxString& value = wxEmptyString,
+                const wxPoint& pos = wxDefaultPosition,
+                const wxSize& size = wxDefaultSize,
+                int n = 0,
+                const wxString choices[] = NULL,
+                long style = 0,
+                const wxValidator& validator = wxDefaultValidator,
+                const wxString& name = wxComboBoxNameStr)
+    {
+        if ( ! wxComboBox::Create(parent, id, value, pos, size,
+                                  n, choices, style, validator, name) )
+        {
+            return false;
+        }
+        mskPostInit();
+        return true;
+    }
+
+    bool Create(wxWindow *parent,
+                wxWindowID id,
+                const wxString& value,
+                const wxPoint& pos,
+                const wxSize& size,
+                const wxArrayString& choices,
+                long style = 0,
+                const wxValidator& validator = wxDefaultValidator,
+                const wxString& name = wxComboBoxNameStr)
+    {
+        if ( ! wxComboBox::Create(parent, id, value, pos, size,
+                                  choices, style, validator, name) )
+        {
+            return false;
+        }
+        mskPostInit();
+        return true;
+    }
+
+    virtual ~wxMaskedEditCombo() {};
+
+    //Override SetValue()
+    virtual void SetValue(const wxString& value)
+    {
+        wxComboBox::SetValue( SetMaskedValue(value) );
+        //Test the new value and set colours
+        UpdateMaskedColours();
+    }
+
+    //Override ChangeValue()
+    virtual void ChangeValue(const wxString& value)
+    {
+        wxComboBox::ChangeValue( SetMaskedValue(value) );
+        //Test the new value and set colours
+        UpdateMaskedColours();
+    }
+
+private:
+    void mskPostInit()
+    {
+        msk_control = this;
+
+        //Set default fixed pitch font
+        //Don't use directly m_font because wxWindowBase::SetFont decides
+        // it is the same font.
+        wxFont font = GetFont();
+        font.SetFamily(wxFONTFAMILY_TELETYPE);
+        SetFont(font);
+
+        //Event handlers
+        Bind(wxEVT_KEY_DOWN, &wxMaskedEdit::OnKeyDown, this);
+        Bind(wxEVT_CHAR, &wxMaskedEdit::OnChar, this);
+        Bind(wxEVT_COMMAND_TEXT_CUT, &wxMaskedEdit::OnCut, this);
+        Bind(wxEVT_COMMAND_TEXT_PASTE, &wxMaskedEdit::OnPaste, this);
+        //Also when an item is selected
+        Bind(wxEVT_COMMAND_COMBOBOX_SELECTED, &wxMaskedEdit::OnComboSelect, this);
+        //When the list is shown, change control's colour
+        Bind(wxEVT_COMMAND_COMBOBOX_DROPDOWN, &wxMaskedEdit::OnComboDrop, this);
+    }
+};
+#endif // wxUSE_COMBOBOX
+
+
+// ----------------------------------------------------------------------------
+//                            Predefined functions
+//
+// They return '-1' if all is OK. Otherwise, return the position of the error.
+// ----------------------------------------------------------------------------
+
+//Range check
+class WXDLLIMPEXP_ADV wxRangeParams
+{
+public:
+    wxRangeParams()
+    {
+        rmin = rmax = 0;
+        base = 10;
+    }
+    long rmin;
+    long rmax;
+    int base;
+};
+
+WXDLLIMPEXP_ADV long wxMaskedRangeCheck(const wxMaskedEdit* caller,
+                                        size_t index,
+                                        void* params);
+
+//Date check
+struct WXDLLIMPEXP_ADV wxDateParams
+{
+    size_t dayField;
+    size_t monthField;
+    size_t yearField;
+};
+
+WXDLLIMPEXP_ADV long wxMaskedDateShort(const wxMaskedEdit* caller, void* params);
+
+#endif // wxUSE_MASKED_EDIT
+
+#endif // _WX_MASKED_EDIT_H_
+

Index: interface/wx/maskededit.h
===================================================================
--- interface/wx/maskededit.h	(revisión: 0)
+++ interface/wx/maskededit.h	(revisión: 0)
@@ -0,0 +1,935 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        maskededit.h
+// Purpose:     interface of wxMaskedEdit
+// Author:      wxWidgets team
+// RCS-ID:      $Id$
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+
+/**
+@defgroup group_maskededit_predef Masked edit predefined functions
+*/
+
+/**
+    Struct with the colours used for different cases with wxMaskedEditText and
+    wxMaskedEditCombo.
+
+    If you don't set a member of this struct, the standard system default
+    colour for the control is used for it.
+
+    @library{wxadv}
+    @category{ctrl}
+
+    @see wxMaskedEditText, wxMaskedEditCombo
+
+    @since 2.9.5
+
+*/
+struct wxMaskedEditColours
+{
+    /// Foreground colour used when everything is OK.
+    wxColour colOKForegn;
+    /// Background colour used when everything is OK.
+    wxColour colOKBackgn;
+
+    /// Foreground colour used when something is wrong.
+    wxColour colWrForegn;
+    /// Background colour used when something is wrong.
+    wxColour colWrBackgn;
+
+    /// Foreground colour used for an empty control's value.
+    wxColour colEmForegn;
+    /// Background colour used for an empty control's value.
+    wxColour colEmBackgn;
+};
+
+/**
+    @class wxEditFieldFlags
+
+    Container for flags used in a field of a masked edit control.
+
+    There are three flags: alignment, fill char and padding char.
+
+    You can create wxEditFieldFlags objects which can be reused for several
+    masked controls.
+
+    @code
+    wxEditFieldFlags fieldflags;
+    maskedCtrlA->SetFieldFlags(n, fieldflags);
+    maskedCtrlB->SetAllFieldFlags(fieldflags);
+    @endcode
+
+    By specification, all methods of wxEditFieldFlags return the
+    wxEditFieldFlags object itself to allowing chaining multiple methods calls,
+    like in this example:
+
+    @code
+    maskedCtrl->SetFieldFlags(n, wxEditFieldFlags().SetFillChar('_'));
+    @endcode
+
+    @library{wxadv}
+    @category{ctrl}
+
+    @see wxMaskedEdit
+
+    @since 2.9.5
+*/
+class wxEditFieldFlags
+{
+public:
+    /**
+        Constructor.
+        Sets the alignment of this wxEditFieldFlags to @a alignment.
+
+        Also, by default, sets the fill char to ' ' (space) and the
+        padding char to '\0' (null).
+
+        @param alignment
+            @c wxALIGN_LEFT (default) or @c wxALIGN_RIGHT.
+
+    */
+    wxEditFieldFlags(wxAlignment alignment = wxALIGN_LEFT);
+
+    /**
+        Sets the alignment of this wxEditFieldFlags to @a alignment.
+
+        @param alignment
+            @c wxALIGN_LEFT (default) or @c wxALIGN_RIGHT.
+
+    */
+    wxEditFieldFlags& SetAlignment(wxAlignment alignment);
+
+    /**
+        Sets the fill char of this wxEditFieldFlags to @a fillchar.
+
+        The fill char is used to fill the empty (i.e. not typed yet)
+        positions in the field for showing them. Typically it is a space.
+
+        @param fillchar
+            Any printable character.
+
+    */
+    wxEditFieldFlags& SetFillChar(wxChar fillchar);
+
+    /**
+        Sets the padding char of this wxEditFieldFlags to @a paddingchar.
+
+        The padding char is used to fill the empty (i.e. not typed yet)
+        positions in the field for the return of wxMaskedEdit::GetPlainValue()
+        and wxMaskedEdit::GetFieldValue().
+
+        Default is '\0' (null) which is interpreted as "don't fill"
+
+        @param paddingchar
+            Any printable character or '\0'.
+
+    */
+    wxEditFieldFlags& SetPaddingChar(wxChar paddingchar);
+
+    /**
+        Returns the alignment used in this object.
+
+        @see SetAlignment()
+    */
+    wxAlignment GetAlignment();
+
+    /**
+        Returns the fill char used in this object.
+
+        @see SetFillChar()
+    */
+    wxChar GetFillChar();
+
+    /**
+        Returns the padding char used in this object.
+
+        @see SetPaddingChar()
+    */
+    wxChar GetPaddingChar();
+};
+
+/** @addtogroup group_maskededit_predef
+/**@{*/
+/**
+    The prototype of function used to test a field of a masked edit control.
+
+    The function accepts as parameters a pointer to the instance of the object
+    that calls this function (your wxMaskedEditText or wxMaskedEditCombo), the
+    field for which this function applies and a pointer to an object containing
+    needed information for this function.
+
+    An example of a currently defined function is wxMaskedRangeCheck().
+
+    @library{wxadv}
+    @category{ctrl}
+
+    @see wxMaskedEdit::SetFieldFunction()
+
+    @since 2.9.5
+
+*/
+typedef long wxMaskedFieldFunc(const wxMaskedEdit*, size_t, void*);
+
+/**
+    The prototype of function used to test the value of a masked edit control.
+
+    The function accepts as parameters a pointer to the instance of the object
+    that calls this function (your wxMaskedEditText or wxMaskedEditCombo) and
+    a pointer to an object containing needed information for this function.
+
+    An example of a currently defined function is wxMaskedDateShort().
+
+    @library{wxadv}
+    @category{ctrl}
+
+    @see wxMaskedEdit::SetControlFunction()
+
+    @since 2.9.5
+
+    @header{wx/maskededit.h}
+*/
+typedef long wxMaskedFunc(const wxMaskedEdit*, void*);
+/**@}*/
+
+/**
+    @class wxMaskedEditParams
+
+    Container used by wxMaskedEdit to store all configurable parameters.
+
+    It is also useful if you have several masked edit controls and you want
+    to set all parameters at once repeatedly.
+
+    @library{wxadv}
+    @category{ctrl}
+
+    @see wxMaskedEditText, wxMaskedEditCombo, wxMaskedEdit
+
+    @since 2.9.5
+*/
+class wxMaskedEditParams
+{
+public:
+    /**
+        Constructor.
+
+        Resets all parameters, deleting previous ones.
+    */
+    wxMaskedEditParams();
+
+    /**
+        Resets all per-field parameters, deleting previous ones, and
+        setting room for @a numFields fields.
+    */
+    void ResetFields(size_t numFields);
+
+    /**
+        The string passed to the masked edit control with wxMaskedEdit::SetMask().
+    */
+    wxString mask;
+
+    /**
+        Colours used for different cases. The whole control is coloured.
+    */
+    wxMaskedEditColours colours;
+
+    /**
+        The container for each field flags.
+    */
+    wxVector<wxEditFieldFlags> fieldsFlags;
+
+    /**
+        The container for each field test function.
+
+        @see wxMaskedEdit::SetFieldFunction()
+    */
+    wxVector<wxMaskedFieldFunc*> fieldsFuncs;
+
+    /**
+        Container for the parameters for each wxMaskedFieldFunc
+
+        @see wxMaskedEdit::SetFieldFunction()
+    */
+    wxVector<void*> fieldFuncsParams;
+
+    /**
+        Pointer to the function for testing the whole control.
+
+        @see wxMaskedEdit::SetControlFunction()
+    */
+    wxMaskedFunc* controlFunc;
+
+    /**
+        Parameters to pass to the function for testing the whole control.
+
+        @see wxMaskedEdit::SetControlFunction()
+    */
+    void* controlFuncParams;
+};
+
+/**
+    @class wxMaskedEdit
+
+    This is the base class for all masked edit controls. Here is where most
+    of their features are implemented.
+
+    A masked edit control is like a form, with boxes where you write the data.
+    You may have a 4-cells field to write a year, a 2-cells field to write a day
+    of the month, a group of 4 fields, each of them is 3-cells long to write an
+    IP v4 address, etc.
+
+    Outside fields you can set "literals". They are characters that may help
+    the user to type the data. This literals are fixed, the user can't change
+    them.
+
+    Each cell accepts a predefined type of character. These types can be digits,
+    letters, digits or letters, any printable character, etc. All cells in a
+    field must accept the same type; the field must be "homogeneous". You can't
+    mix in the same field some cells accepting only digits and other cells
+    accepting only letters.
+
+    This per-cell definition, literals included, is called a "mask".
+
+    Examples. With this code:
+    @code
+    wxMaskedEditText *ctr1, *ctr2;
+    ctr1 = new wxMaskedEditText(this, ID1);
+    ctr1->SetMask("99#.99#.99#.99#");
+    ctr1->SetAllFieldsFlags(wxEditFieldFlags(wxALIGN_RIGHT));
+    ctr2 = new wxMaskedEditText(this, ID2);
+    ctr2->SetMask("####/9#/9#");
+    ctr2->SetAllFieldsFlags(wxEditFieldFlags(wxALIGN_RIGHT));
+    @endcode
+    you could create two masked controls, and set an IP mask (4 fields) and
+    a yyyy/mm/dd date mask (3 fields). All fields are also set to be right
+    aligned. Their appearance, empty and with some characters typed, may be
+    like these:
+    @image html maskededit.png
+
+    As said above, each cell is told to accept only one kind of characters,
+    filtering all others. You can also set a function that test a specific
+    field. You can assign a different function for each field. You can also
+    set a function that works with the whole control's value. All of this
+    functions just do test (i.e. they don't change anything) and inform the
+    main code if that field/control has an acceptable value.
+
+    @library{wxadv}
+    @category{ctrl}
+
+    @see wxMaskedEditText, wxMaskedEditCombo
+
+    @since 2.9.5
+*/
+class wxMaskedEdit
+{
+public:
+    /**
+        Default constructor.
+    */
+    wxMaskedEdit();
+
+    /**
+        Default destructor.
+    */
+    ~wxMaskedEdit();
+
+    /**
+        Sets the mask.
+
+    The mask is composed of command-characters and literals. A group of
+    consecutive commands forms a field.
+
+    If no field is defined with this new mask, nothing is changed and it
+    returns @false. Otherwise, the previous per-field definitions (flags
+    and test functions) are reset.
+
+    Command-characters and their meaning:
+    @beginTable
+    @row2col{ # , Required digit.}
+    @row2col{ 9 , Optional digit.}
+    @row2col{ A , Required alpha character.}
+    @row2col{ a , Optional alpha character.}
+    @row2col{ N , Required alphanumeric character (i.e. letter or digit).}
+    @row2col{ n , Optional alphanumeric character.}
+    @row2col{ C , Required character (any printable).}
+    @row2col{ c , Optional character (any printable).}
+    @row2col{ X , Required hexadecimal character [0-F].}
+    @row2col{ x , Optional hexadecimal character [0-F].}
+    @row2col{{x}, The previous character (one of the above) is taken x times.<br>
+        This is an "expander": #{3} expands into ### and X{4} expands into XXXX.}
+    @row2col{ > , Convert all following characters to upper case.}
+    @row2col{ < , Convert all following characters to lower case.}
+    @row2col{ ^ , Switch off upper/lower case conversion.}
+    @row2col{ \ , Escape the next character and use it as a literal.}
+    @row2col{ | , Special literal. It's invisible, takes no space, but still
+     is a fields separator.}
+    @endTable
+     Note the above specifications are tested using wxIsxxx functions. So,
+     they are locale dependant.
+
+     Any other char is a literal. It is shown in the control, but it can
+     not be edited.
+
+     Literals are also used as fields separators.
+
+     Space is not a character (except for C and c commands), and it is typically
+     used as fillchar (see wxEditFieldFlags). If you want to use C or c command
+     you must set the fillchar to some character you don't allow.
+
+     @param mask
+        The string that defines the mask.
+    */
+    bool SetMask(const wxString& mask);
+
+    /**
+        Sets the colours for different cases.
+
+        You don't need to set all of them. Default system values are used for
+        those colours not set.
+
+        @param colours
+            The struct containing the different colours.
+    */
+    void SetMaskedColours(const wxMaskedEditColours& colours);
+
+    /**
+        Sets the flags for a field.
+
+        You can set alignment, fill char and padding char.
+
+        This is a per-field setter. Different fields may have different flags.
+
+        @param index
+            The field (0-based) to set the flags.
+
+        @param flags
+            The flags for that field.
+
+        @see wxEditFieldFlags, SetAllFieldsFlags()
+    */
+    void SetFieldFlags(size_t index, const wxEditFieldFlags& flags);
+
+    /**
+        Sets all fields with the same flags.
+
+        @param flags
+            The flags to be set for all fields.
+
+        @see wxEditFieldFlags, SetFieldFlags()
+    */
+    void SetAllFieldsFlags(const wxEditFieldFlags& flags);
+
+    /**
+        Sets the test function for a field.
+
+        Apart from filtering characters as defined in the mask, a field can
+        be tested. For example, for an "hour field" it is advisable to test
+        the number to be in [0-23] range.
+
+        The result of this test does not change the field's value. It only
+        informs if the result of test is satisfactory or not.
+
+        @param index
+            The field (0-based) to which applies the function.
+
+        @param fn
+            A pointer to the function to be used for field @a index, defined as:
+        @code
+  typedef long wxMaskedFieldFunc(const wxMaskedEdit*, size_t, void*);
+        @endcode
+
+        @param param
+            A pointer to the parameters to be passed to the function.
+
+        Currently there is one predefined function, wxMaskedRangeCheck(), which
+        uses the also predefined class wxRangeParams. An example on how to use
+        it is:
+        @code
+        wxRangeParams rParm;
+        rParm.rmin = 0;
+        rParm.rmax = 23;
+        maskedCtrl->SetFieldFunction(field, &wxMaskedRangeCheck, &rParm);
+        @endcode
+
+        You can also set your own function, which may use your own parameters.
+
+        @see SetAllFieldsFunction(), SetControlFunction()
+    */
+    void SetFieldFunction(size_t index, wxMaskedFieldFunc* fn, void* param);
+
+    /**
+        Sets all fields with the same test function.
+
+        @param fn
+            A pointer to the function to be used for all fields, defined as:
+        @code
+  typedef long wxMaskedFieldFunc(const wxMaskedEdit*, size_t, void*);
+        @endcode
+
+        @param param
+            A pointer to the parameters to be passed to the function.
+
+        @see SetFieldFunction()
+    */
+    void SetAllFieldsFunction(wxMaskedFieldFunc* fn, void* param);
+
+    /**
+        Sets the test function for the whole control.
+
+        The result of this test does not change the control's value. It only
+        informs if the result of test is satisfactory or not.
+
+        @param fn
+            A pointer to the function to be used, defined as:
+        @code
+  typedef long wxMaskedFunc(const wxMaskedEdit*, void*);
+        @endcode
+
+        @param param
+            A pointer to the parameters to be passed to the function.
+
+        Currently there is one predefined function, wxMaskedDateShort(), which
+        uses the also predefined struct wxDateParams. Here is an example on how
+        to use it, being the date in shape yyyy/mm/dd and being the year the
+        fourth field in the control:
+        @code
+        wxDateParams dparam;
+        dparam.yearField = 3;
+        dparam.monthField = 4;
+        dparam.dayField = 5;
+        maskedCtrl->SetControlFunction( &wxMaskedDateShort, &dparam );
+        @endcode
+
+        You can also set your own function, which may use your own parameters.
+
+        @see SetFieldFunction()
+    */
+    void SetControlFunction(wxMaskedFunc* fn, void* param);
+
+    /**
+        Sets all parameters at once, replacing old ones.
+
+        @param params
+            All the parameters that govern this control: mask, flags, colours
+            and test functions.
+    */
+    bool SetParams(const wxMaskedEditParams& params);
+
+    /**
+        Sets the control's value from an undecorated text.
+
+        The plain value (i.e. undecorated text, without "literals") is supposed
+        to resemble the user's input. So this text does not need to fill all
+        cells. If this is the case, filling begins at the first field, this is,
+        from the left of the control.
+
+        @param plainValue
+            The text resembling the characters typed by the user.
+
+        If any character is not allowed, it returns @false.
+
+        If the plain value is bigger than the mask, it returns @false.
+
+        @see GetPlainValue(), SetFieldValue(), wxMaskedEditText::SetValue()
+    */
+    bool SetPlainValue(const wxString& plainValue);
+
+    /**
+        Sets the value for a field.
+
+        @param plainValue
+            The text replacing the current field's one.
+
+        If any character is not allowed, it returns @false.
+
+        @see GetFieldValue(), SetPlainValue(), wxMaskedEditText::SetValue()
+    */
+    bool SetFieldValue(size_t index, const wxString& plainValue);
+
+    /**
+        Checks whether all cells, fields and the whole control's value are OK.
+
+        Returns the position of the error found, or '-1' if everything is well.
+    */
+    long IsValid();
+
+    /**
+        Sets bell on/off when a character is not accepted.
+
+        @param bell
+            Set it to @false if you don't want the sound.
+    */
+    void SetBellOnError(bool bell);
+
+
+    //Accessors -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
+    /**
+        Gets the number of fields in the mask.
+    */
+    size_t GetFieldsCount() const;
+
+    /**
+        Gets control's value, without decorations.
+
+        The return value is the current control's value, after removing
+        all "literals" and filling untyped cells with per-field padding chars.
+
+        @see SetPlainValue(), GetFieldValue(), wxEditFieldFlags
+    */
+    wxString GetPlainValue() const;
+
+    /**
+        Gets the current text in the field @a index.
+
+        Empty cells are filled with the padding character set for this field.
+    */
+    wxString GetFieldValue(size_t index) const;
+
+    /**
+        Gets the mask.
+
+        Returns the string passed at SetMask().
+    */
+    wxString GetMask() const;
+
+    /**
+        Gets the colours used for different cases.
+    */
+    wxMaskedEditColours GetMaskedColours() const;
+
+    /**
+        Gets the wxEditFieldFlags instance used in the field @a index.
+    */
+    wxEditFieldFlags GetFieldFlags(size_t index) const;
+
+    /**
+        Gets the parameters that set the behaviour of this control.
+    */
+    wxMaskedEditParams GetParams() const;
+};
+
+
+/**
+    @class wxMaskedEditText
+
+    A specialized wxTextCtrl where the user can only fill some of its
+    positions. The rest of positions are fixed literal characters.
+
+    @remarks
+    Please refer to wxMaskedEdit documentation for the description of methods
+    operating with the text.
+
+    The events this class emits are those of wxTextCtrl.
+
+    @library{wxadv}
+    @category{ctrl}
+
+    @see wxMaskedEdit, wxMaskedEditCombo, wxTextCtrl
+
+    @since 2.9.5
+*/
+class wxMaskedEditText : public wxMaskedEdit, public wxTextCtrl
+{
+public:
+    /**
+        Default constructor.
+    */
+    wxMaskedEditText();
+
+    /**
+        Constructor, creating and showing a wxTextCtrl.
+
+        Note the style wxTE_MULTILINE is not allowed.
+
+        The control is set with a fixed pitch font.
+
+        Refer to wxTextCtrl::wxTextCtrl() for the description of the parameters.
+    */
+    wxMaskedEditText(wxWindow *parent, wxWindowID id,
+                     const wxString& value = wxEmptyString,
+                     const wxPoint& pos = wxDefaultPosition,
+                     const wxSize& size = wxDefaultSize,
+                     long style = 0,
+                     const wxValidator& validator = wxDefaultValidator,
+                     const wxString& name = wxTextCtrlNameStr);
+
+    /**
+        Creates the wxMaskedEditText for two-step construction. Derived classes
+        should call or replace this function.
+
+        Refer to wxMaskedEditText() for further details.
+
+        Refer to wxTextCtrl::Create() for the description of the parameters.
+    */
+    bool Create(wxWindow *parent, wxWindowID id,
+                const wxString& value = wxEmptyString,
+                const wxPoint& pos = wxDefaultPosition,
+                const wxSize& size = wxDefaultSize,
+                long style = 0,
+                const wxValidator& validator = wxDefaultValidator,
+                const wxString& name = wxTextCtrlNameStr);
+
+    /**
+        Destructor, destroying the masked control.
+    */
+    virtual ~wxMaskedEditText();
+
+    /**
+        Sets the whole text, decorations included.
+
+        For a mask like "9#:9#" (likely used for hh:mm) if your value
+        is 14 hours 25 minutes, you must pass "14:25". Also you must respect
+        alignment and fill char for each field.
+
+        @param value
+            The text to set. It will be tested and adapted to the mask.
+
+       Notice that this method will generate a @c wxEVT_COMMAND_TEXT_UPDATED
+       event, use ChangeValue() if this is undesirable.
+
+       @see wxTextEntry::SetValue(), wxMaskedEdit::SetPlainValue()
+    */
+    virtual void SetValue(const wxString& value);
+
+    /**
+        Same as SetValue(), except it does not generate the
+        wxEVT_COMMAND_TEXT_UPDATED event.
+
+        @see SetValue(), wxTextEntry::ChangeValue()
+    */
+    virtual void ChangeValue(const wxString& value);
+
+};
+
+/**
+    @class wxMaskedEditCombo
+
+    A specialized wxComboBox. For the edit part, the user can only fill
+    some of its positions. The rest of positions are fixed literal characters.
+
+    @remarks
+    Please refer to wxMaskedEdit documentation for the description of methods
+    operating with the text.
+
+    The events this class emits are those of wxComboBox.
+
+    @library{wxadv}
+    @category{ctrl}
+
+    @see wxMaskedEdit, wxMaskedEditText, wxComboBox
+
+    @since 2.9.5
+*/
+class wxMaskedEditCombo : public wxMaskedEdit,  public wxComboBox
+{
+public:
+    /**
+        Default constructor.
+    */
+    wxMaskedEditCombo();
+
+    /**
+        Constructor, creating and showing a wxComboBox.
+
+        The control is set with a fixed pitch font.
+
+        Refer to wxComboBox::wxComboBox() for the description of the parameters.
+    */
+    wxMaskedEditCombo(wxWindow *parent, wxWindowID id,
+                      const wxString& value = wxEmptyString,
+                      const wxPoint& pos = wxDefaultPosition,
+                      const wxSize& size = wxDefaultSize,
+                      int n = 0, const wxString choices[] = NULL,
+                      long style = 0,
+                      const wxValidator& validator = wxDefaultValidator,
+                      const wxString& name = wxComboBoxNameStr);
+
+    /**
+        Constructor, creating and showing a wxComboBox.
+
+        The control is set with a fixed pitch font.
+
+        Refer to wxComboBox::wxComboBox() for the description of the parameters.
+    */
+    wxMaskedEditCombo(wxWindow *parent, wxWindowID id,
+                      const wxString& value,
+                      const wxPoint& pos,
+                      const wxSize& size,
+                      const wxArrayString& choices,
+                      long style = 0,
+                      const wxValidator& validator = wxDefaultValidator,
+                      const wxString& name = wxComboBoxNameStr);
+
+    //@{
+    /**
+        Creates the wxMaskedEditCombo for two-step construction. Derived classes
+        should call or replace this function.
+
+        Refer to wxMaskedEditCombo() for further details.
+
+        Refer to wxComboBox::Create() for the description of the parameters.
+    */
+    bool Create(wxWindow *parent,
+                wxWindowID id,
+                const wxString& value = wxEmptyString,
+                const wxPoint& pos = wxDefaultPosition,
+                const wxSize& size = wxDefaultSize,
+                int n = 0,
+                const wxString choices[] = NULL,
+                long style = 0,
+                const wxValidator& validator = wxDefaultValidator,
+                const wxString& name = wxComboBoxNameStr);
+
+    bool Create(wxWindow *parent,
+                wxWindowID id,
+                const wxString& value,
+                const wxPoint& pos,
+                const wxSize& size,
+                const wxArrayString& choices,
+                long style = 0,
+                const wxValidator& validator = wxDefaultValidator,
+                const wxString& name = wxComboBoxNameStr);
+    //@}
+
+    /**
+        Destructor, destroying the masked control.
+    */
+    virtual ~wxMaskedEditCombo() {};
+
+    /**
+        Sets the whole text, decorations included, for the edit part of the
+        wxComboBox.
+
+        For a mask like "9#:9#" (likely used for hh:mm) if your value
+        is 14 hours 25 minutes, you must pass "14:25". Also you must respect
+        alignment and fill char for each field.
+
+        @param value
+            The text to set. It will be tested and adapted to the mask.
+
+       Notice that this method will generate a @c wxEVT_COMMAND_TEXT_UPDATED
+       event, use ChangeValue() if this is undesirable.
+
+       @see wxComboBox::SetValue(), wxTextEntry::SetValue(),
+       wxMaskedEdit::SetPlainValue()
+    */
+    virtual void SetValue(const wxString& value);
+
+    /**
+        Same as SetValue(), except it does not generate the
+        wxEVT_COMMAND_TEXT_UPDATED event.
+
+        @see SetValue(), wxTextEntry::ChangeValue()
+    */
+    virtual void ChangeValue(const wxString& value);
+
+};
+
+
+// ----------------------------------------------------------------------------
+//                            Predefined functions
+//
+// They return '-1' if all is OK. Otherwise, return the position of the error.
+// ----------------------------------------------------------------------------
+
+/** @addtogroup group_maskededit_predef
+/**@{*/
+/**
+    @class wxRangeParams
+
+    Used to pass parameters to wxMaskedRangeCheck()
+
+    @library{wxadv}
+    @category{ctrl}
+
+    @see wxMaskedEditText, wxMaskedEditCombo, wxMaskedEdit
+
+    @since 2.9.5
+
+*/
+class wxRangeParams
+{
+public:
+    wxRangeParams()
+    {
+        rmin = rmax = 0;
+        base = 10;
+    }
+    ///min value
+    long rmin;
+    ///max value
+    long rmax;
+    ///base of the value to be checked. Default is 10.
+    int base;
+};
+
+/**
+    Predefined range check function used with wxMaskedEdit::SetFieldFunction().
+
+    @param caller
+        The masked edit control that calls this function.
+
+    @param index
+        The field (0-based) to test.
+
+    @param params
+        A pointer to a wxRangeParams object, containing @a min, @a max and
+        @a base values.
+
+    The functions tests the field's value to be in the [@a min-@a max] range.
+    <br>@a min and @a max are valid values.
+
+    Setting @a max < @a min makes the function to test the value to be outside
+    the range (excluded range as opposed to included range). For example, 33
+    or 90 are valid values for a [70-50] range.
+
+    @library{wxadv}
+    @category{ctrl}
+
+    @since 2.9.5
+*/
+long wxMaskedRangeCheck(const wxMaskedEdit* caller, size_t index, void* params);
+
+/**
+    Used to pass parameters to wxMaskedDateShort()
+
+    @library{wxadv}
+    @category{ctrl}
+
+    @see wxMaskedEditText, wxMaskedEditCombo, wxMaskedEdit
+
+    @since 2.9.5
+*/
+struct wxDateParams
+{
+    /// The field whose value is the day.
+    size_t dayField;
+    /// The field whose value is the month.
+    size_t monthField;
+    /// The field whose value is the year.
+    size_t yearField;
+};
+
+/**
+    Predefined date check function used with wxMaskedEdit::SetControlFunction().
+
+    @param caller
+        The masked edit control that calls this function.
+
+    @param params
+        A pointer to a wxDateParams object, that defines what fields match with
+        day, month and year.
+
+    Once the fields are known, their values are extracted and tested to form a
+    valid date.
+
+    @library{wxadv}
+    @category{ctrl}
+
+    @see wxMaskedEditText, wxMaskedEditCombo, wxMaskedEdit
+
+    @since 2.9.5
+*/
+long wxMaskedDateShort(const wxMaskedEdit* caller, void* params);
+
+/**@}*/
+

Index: samples/maskededit/maskedctrl.cpp
===================================================================
--- samples/maskededit/maskedctrl.cpp	(revisión: 0)
+++ samples/maskededit/maskedctrl.cpp	(revisión: 0)
@@ -0,0 +1,631 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        samples/maskededit/maskedctrl.cpp
+// Purpose:     wxWidgets masked edit control sample
+// Author:      Manuel Martin
+// Modified by:
+// Created:     2012-07-30
+// RCS-ID:      $Id$
+// Copyright:   (c)
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+// ============================================================================
+// declarations
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// headers
+// ----------------------------------------------------------------------------
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+// for all others, include the necessary headers (this file is usually all you
+// need because it includes almost all "standard" wxWidgets headers)
+#ifndef WX_PRECOMP
+    #include "wx/wx.h"
+#endif
+
+#include "wx/maskededit.h"
+
+// ----------------------------------------------------------------------------
+// resources
+// ----------------------------------------------------------------------------
+
+// the application icon (under Windows and OS/2 it is in resources and even
+// though we could still include the XPM here it would be unused)
+#if !defined(__WXMSW__) && !defined(__WXPM__)
+    #include "../sample.xpm"
+#endif
+
+// ----------------------------------------------------------------------------
+// private classes
+// ----------------------------------------------------------------------------
+
+// Define a new application type, each program should derive a class from wxApp
+class MyApp : public wxApp
+{
+public:
+    // override base class virtuals
+    // ----------------------------
+
+    // this one is called on application startup and is a good place for the app
+    // initialization (doing it here and not in the ctor allows to have an error
+    // return: if OnInit() returns false, the application terminates)
+    virtual bool OnInit();
+};
+
+// Define a new frame type: this is going to be our main frame
+class MyFrame : public wxFrame
+{
+public:
+    // ctor(s)
+    MyFrame(const wxString& title);
+
+    // event handlers (these functions should _not_ be virtual)
+    void OnQuit(wxCommandEvent& event);
+    void OnBell(wxCommandEvent& event);
+    void OnAbout(wxCommandEvent& event);
+    void OnUpdatePlain(wxCommandEvent& event);
+
+    //A container for some of our control's IDs
+    wxVector<long> ctrIDs;
+
+private:
+    // any class wishing to process wxWidgets events must use this macro
+    DECLARE_EVENT_TABLE()
+};
+
+// Define a new panel type: this will fit inside our main frame
+class MyPanel : public wxPanel
+{
+public:
+    // ctor(s)
+    MyPanel(MyFrame* parent);
+
+    //Structs used in test functions in this sample
+    wxRangeParams fparamsIP;
+    wxRangeParams fparams23;
+    wxRangeParams fparams59;
+    wxDateParams  dparams1;
+    wxDateParams  dparams2;
+};
+
+// ----------------------------------------------------------------------------
+// constants
+// ----------------------------------------------------------------------------
+
+// IDs for the controls and the menu commands
+enum
+{
+    // menu items
+    MaskCtrl_Quit = wxID_EXIT,
+
+    // it is important for the id corresponding to the "About" command to have
+    // this standard value as otherwise it won't be handled properly under Mac
+    // (where it is special and put into the "Apple" menu)
+    MaskCtrl_About = wxID_ABOUT,
+
+    MaskCtrl_Bell = wxID_HIGHEST + 1000,
+    MaskCtrl_First
+};
+
+// ----------------------------------------------------------------------------
+// event tables and other macros for wxWidgets
+// ----------------------------------------------------------------------------
+
+// the event tables connect the wxWidgets events with the functions (event
+// handlers) which process them. It can be also done at run-time, but for the
+// simple menu events like this the static method is much simpler.
+BEGIN_EVENT_TABLE(MyFrame, wxFrame)
+    EVT_MENU(MaskCtrl_Quit,  MyFrame::OnQuit)
+    EVT_MENU(MaskCtrl_Bell,  MyFrame::OnBell)
+    EVT_MENU(MaskCtrl_About, MyFrame::OnAbout)
+    EVT_TEXT(wxID_ANY, MyFrame::OnUpdatePlain)
+END_EVENT_TABLE()
+
+// Create a new application object: this macro will allow wxWidgets to create
+// the application object during program execution (it's better than using a
+// static object for many reasons) and also implements the accessor function
+// wxGetApp() which will return the reference of the right type (i.e. MyApp and
+// not wxApp)
+IMPLEMENT_APP(MyApp)
+
+// ============================================================================
+// implementation
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// the application class
+// ----------------------------------------------------------------------------
+
+// 'Main program' equivalent: the program execution "starts" here
+bool MyApp::OnInit()
+{
+    // call the base class initialization method, currently it only parses a
+    // few common command-line options but it could be do more in the future
+    if ( !wxApp::OnInit() )
+        return false;
+
+    // create the main application window
+    MyFrame *frame = new MyFrame("Masked Edit Control wxWidgets App");
+
+    // and show it (the frames, unlike simple controls, are not shown when
+    // created initially)
+    frame->Show(true);
+
+    // success: wxApp::OnRun() will be called which will enter the main message
+    // loop and the application will run. If we returned false here, the
+    // application would exit immediately.
+    return true;
+}
+
+// ----------------------------------------------------------------------------
+// main frame
+// ----------------------------------------------------------------------------
+
+// frame constructor
+MyFrame::MyFrame(const wxString& title)
+       : wxFrame(NULL, wxID_ANY, title)
+{
+    // set the frame icon
+    SetIcon(wxICON(sample));
+
+#if wxUSE_MENUS
+    // create a menu bar
+    wxMenuBar *menuBar = new wxMenuBar();
+
+    // set menus
+    wxMenu *fileMenu = new wxMenu;
+    fileMenu->Append(MaskCtrl_Quit, "E&xit\tAlt-X", "Quit this program");
+
+    wxMenu *bellMenu = new wxMenu;
+    bellMenu->AppendCheckItem(MaskCtrl_Bell, _("&Bell on error"),
+                               _("Toggle bell on error"));
+    bellMenu->Check(MaskCtrl_Bell, true);
+
+    // the "About" item should be in the help menu
+    wxMenu *helpMenu = new wxMenu;
+    helpMenu->Append(MaskCtrl_About, "&About...\tF1", "Show about dialog");
+
+    // now append the freshly created menu to the menu bar...
+    menuBar->Append(fileMenu, "&File");
+    menuBar->Append(bellMenu, "&Bell");
+    menuBar->Append(helpMenu, "&Help");
+
+    // ... and attach this menu bar to the frame
+    SetMenuBar(menuBar);
+#endif // wxUSE_MENUS
+
+#if wxUSE_STATUSBAR
+    // create a status bar just for fun (by default with 1 pane only)
+    CreateStatusBar(2);
+    SetStatusText("Welcome to wxWidgets!");
+#endif // wxUSE_STATUSBAR
+
+    //Add a panel to place our controls
+    MyPanel* myPanel = new MyPanel(this);
+
+    //The sizer is set for the panel. Because the panel is the only child
+    //of the frame, it will fill all frame's client area.
+    //We also want to set the minimum size of this frame.
+    myPanel->GetSizer()->SetSizeHints(this);
+}
+
+
+// event handlers
+
+void MyFrame::OnQuit(wxCommandEvent& WXUNUSED(event))
+{
+    // true is to force the frame to close
+    Close(true);
+}
+
+void MyFrame::OnBell(wxCommandEvent& WXUNUSED(event))
+{
+    //Use the ID of each wxMaskedEdit control
+    wxVector<long>::const_iterator it;
+    for (it = ctrIDs.begin(); it != ctrIDs.end(); it++)
+    {
+        wxWindow* win = FindWindow(*it);
+        if ( wxMaskedEditText *etext = wxDynamicCast(win, wxMaskedEditText) )
+            etext->SetBellOnError( GetMenuBar()->IsChecked(MaskCtrl_Bell) );
+        else if ( wxMaskedEditCombo *ecombo = wxDynamicCast(win, wxMaskedEditCombo) )
+            ecombo->SetBellOnError( GetMenuBar()->IsChecked(MaskCtrl_Bell) );
+    }
+}
+
+void MyFrame::OnAbout(wxCommandEvent& WXUNUSED(event))
+{
+    wxMessageBox(wxString::Format
+                 (
+                    "Welcome to %s!\n"
+                    "\n"
+                    "This is the Masked Edit Control wxWidgets sample\n"
+                    "running under %s.",
+                    wxVERSION_STRING,
+                    wxGetOsDescription()
+                 ),
+                 "About wxWidgets Masked Control sample",
+                 wxOK | wxICON_INFORMATION,
+                 this);
+}
+
+void MyFrame::OnUpdatePlain(wxCommandEvent& event)
+{
+    //We want to reflect changes only for the wxMaskedEditXXXX samples
+    //Use the ID of each wxMaskedEditXXXX control
+    long plainTextID = -1;
+    wxVector<long>::const_iterator it;
+    for (it = ctrIDs.begin(); it != ctrIDs.end(); it++)
+    {
+        if ( *it == event.GetId() )
+        {
+            plainTextID = *it + 100;
+            break;
+        }
+    }
+
+    if (plainTextID == -1)
+        return; //The sender for this event is not in our list
+
+    //the wxTextCtrl where we show the plain value of its partner
+    wxWindow *win = FindWindow(plainTextID);
+    if ( !win )
+        return;
+    wxTextCtrl *ptc = wxDynamicCast(win, wxTextCtrl);
+
+    win = FindWindow(plainTextID - 100);
+    if ( wxMaskedEditText *etext = wxDynamicCast(win, wxMaskedEditText) )
+        ptc->SetValue( etext->GetPlainValue() );
+    else if ( wxMaskedEditCombo *ecombo = wxDynamicCast(win, wxMaskedEditCombo) )
+        ptc->SetValue( ecombo->GetPlainValue() );
+}
+
+// ----------------------------------------------------------------------------
+// An example function that operates with the whole control value.
+//In this case, it does not need any extra data. So we don't need any special
+// struct for that data. The compiler will warn about 'unused params'
+// It's definition is fixed:
+long MyFunction(const wxMaskedEdit* caller, void* params)
+{
+    //Get the whole control's value, without decorations
+    wxString str = caller->GetPlainValue();
+
+    //Sum of distances to '0'
+    long sum = 0;
+    wxString::const_iterator it = str.begin();
+    while ( it != str.end() )
+    {
+        sum += *it - wxChar('0');
+        it++;
+    }
+
+    //We accept any sum > 0 and multiple of 5
+    if ( sum > 0 && (sum % 5) == 0 )
+        return -1; //means "OK"
+
+    //Wrong value. We can't say where the error is, so return the beginning.
+    return 0;
+}
+
+// ----------------------------------------------------------------------------
+// The panel
+// ----------------------------------------------------------------------------
+
+MyPanel::MyPanel(MyFrame* parent)
+             : wxPanel(parent,
+                       wxID_ANY,
+                       wxDefaultPosition,
+                       wxDefaultSize,
+                       wxTAB_TRAVERSAL)
+{
+    SetBackgroundColour(wxColour(235,235,255));
+
+    //A grid sizer to layout formatting samples
+    wxFlexGridSizer *mainSizer = new wxFlexGridSizer(4, 5, 5);
+
+    //Reusable pointers
+    wxStaticText *stDesText;
+    wxStaticText *stMaskText;
+    wxTextCtrl *tcPlainText;
+    wxMaskedEditText *edTexCtrl;
+    wxMaskedEditCombo *edComboCtrl;
+    wxString edMask;
+    wxString edPlain;
+
+    //IDs for edit and 'PlainText' controls
+    long idCtrl = MaskCtrl_First;
+
+    //Sizer flags
+    wxSizerFlags sizerFlags(0);
+    sizerFlags.Align(wxALIGN_LEFT | wxALIGN_CENTER_VERTICAL);
+    sizerFlags.Border(wxLEFT | wxRIGHT | wxTOP, 10);
+
+    //Colours
+    wxMaskedEditColours mskColours;
+    mskColours.colOKBackgn.Set(160, 255, 100);
+    mskColours.colOKForegn.Set(0, 0, 255);
+    mskColours.colWrBackgn.Set(255, 125, 100);
+
+    //Headers
+    stDesText = new wxStaticText(this, wxID_ANY, "Description");
+    stDesText->SetFont( GetFont().Bold() );
+    mainSizer->Add(stDesText, sizerFlags);
+    stDesText = new wxStaticText(this, wxID_ANY, "Mask");
+    stDesText->SetFont( GetFont().Bold() );
+    mainSizer->Add(stDesText, sizerFlags);
+    stDesText = new wxStaticText(this, wxID_ANY, "Edit control");
+    stDesText->SetFont( GetFont().Bold() );
+    mainSizer->Add(stDesText, sizerFlags);
+    stDesText = new wxStaticText(this, wxID_ANY, "Plain Value");
+    stDesText->SetFont( GetFont().Bold() );
+    mainSizer->Add(stDesText, sizerFlags);
+
+    sizerFlags.Border(wxLEFT | wxRIGHT, 10);
+
+    //Sample 1
+    stDesText = new wxStaticText(this, wxID_ANY, "Age");
+    mainSizer->Add(stDesText, sizerFlags);
+    edMask = "999";
+    stMaskText = new wxStaticText(this, wxID_ANY, edMask);
+    mainSizer->Add(stMaskText, sizerFlags);
+
+    edTexCtrl = new wxMaskedEditText(this, idCtrl);
+    parent->ctrIDs.push_back(idCtrl);
+    edTexCtrl->SetMask(edMask);
+    edTexCtrl->SetFieldFlags(0, wxEditFieldFlags(wxALIGN_RIGHT));
+    mainSizer->Add(edTexCtrl, sizerFlags);
+
+    edPlain = edTexCtrl->GetPlainValue();
+    tcPlainText = new wxTextCtrl(this, idCtrl + 100, edPlain);
+    tcPlainText->SetEditable(false);
+    tcPlainText->SetMinSize( edTexCtrl->GetMinSize() );
+    mainSizer->Add(tcPlainText, sizerFlags);
+
+    //Sample 2
+    idCtrl++;
+    stDesText = new wxStaticText(this, wxID_ANY, "Anger expression");
+    mainSizer->Add(stDesText, sizerFlags);
+    edMask = "c{20}";
+    stMaskText = new wxStaticText(this, wxID_ANY, edMask);
+    mainSizer->Add(stMaskText, sizerFlags);
+
+    edTexCtrl = new wxMaskedEditText(this, idCtrl);
+    parent->ctrIDs.push_back(idCtrl);
+    edTexCtrl->SetMask(edMask);
+    edTexCtrl->SetFieldFlags(0, wxEditFieldFlags().SetFillChar('_'));
+    edTexCtrl->SetValue("GRRR ***@&#%!!!");
+    mainSizer->Add(edTexCtrl, sizerFlags);
+
+    edPlain = edTexCtrl->GetPlainValue();
+    tcPlainText = new wxTextCtrl(this, idCtrl + 100, edPlain);
+    tcPlainText->SetEditable(false);
+    tcPlainText->SetMinSize( edTexCtrl->GetMinSize() );
+    mainSizer->Add(tcPlainText, sizerFlags);
+
+    //Sample 3
+    idCtrl++;
+    stDesText = new wxStaticText(this, wxID_ANY, "Phone No");
+    mainSizer->Add(stDesText, sizerFlags);
+    edMask = "(999) ###-#### E\\xt.999";
+    stMaskText = new wxStaticText(this, wxID_ANY, edMask);
+    mainSizer->Add(stMaskText, sizerFlags);
+
+    edTexCtrl = new wxMaskedEditText(this, idCtrl);
+    parent->ctrIDs.push_back(idCtrl);
+    edTexCtrl->SetMask(edMask);
+    wxEditFieldFlags fieldFlags;
+    fieldFlags.SetAlignment(wxALIGN_RIGHT);
+    fieldFlags.SetPaddingChar('0');
+    edTexCtrl->SetAllFieldsFlags(fieldFlags);
+    edTexCtrl->SetMaskedColours(mskColours);
+    mainSizer->Add(edTexCtrl, sizerFlags);
+
+    edPlain = edTexCtrl->GetPlainValue();
+    tcPlainText = new wxTextCtrl(this, idCtrl + 100, edPlain);
+    tcPlainText->SetEditable(false);
+    tcPlainText->SetMinSize( edTexCtrl->GetMinSize() );
+    mainSizer->Add(tcPlainText, sizerFlags);
+
+    //Sample 4
+    idCtrl++;
+    stDesText = new wxStaticText(this, wxID_ANY, "ADDRESS:offset");
+    mainSizer->Add(stDesText, sizerFlags);
+    edMask = ">x{4}:<x{4}";
+    stMaskText = new wxStaticText(this, wxID_ANY, edMask);
+    mainSizer->Add(stMaskText, sizerFlags);
+
+    edTexCtrl = new wxMaskedEditText(this, idCtrl);
+    parent->ctrIDs.push_back(idCtrl);
+    edTexCtrl->SetMask(edMask);
+    edTexCtrl->SetAllFieldsFlags(fieldFlags); //same as sample 3
+    mainSizer->Add(edTexCtrl, sizerFlags);
+
+    edPlain = edTexCtrl->GetPlainValue();
+    tcPlainText = new wxTextCtrl(this, idCtrl + 100, edPlain);
+    tcPlainText->SetEditable(false);
+    tcPlainText->SetMinSize( edTexCtrl->GetMinSize() );
+    mainSizer->Add(tcPlainText, sizerFlags);
+
+    //Sample 5
+    idCtrl++;
+    stDesText = new wxStaticText(this, wxID_ANY, "IP v4");
+    mainSizer->Add(stDesText, sizerFlags);
+    edMask = "99#.99#.99#.99#";
+    stMaskText = new wxStaticText(this, wxID_ANY, edMask);
+    mainSizer->Add(stMaskText, sizerFlags);
+
+    edTexCtrl = new wxMaskedEditText(this, idCtrl);
+    parent->ctrIDs.push_back(idCtrl);
+    edTexCtrl->SetMask(edMask);
+
+    edTexCtrl->SetAllFieldsFlags(fieldFlags); //same as sample 3
+    edTexCtrl->SetMaskedColours(mskColours);
+    mainSizer->Add(edTexCtrl, sizerFlags);
+    edTexCtrl->SetPlainValue("1920");
+    //use the predefined range function
+    fparamsIP.rmin = 0;
+    fparamsIP.rmax = 255;
+    edTexCtrl->SetAllFieldsFunction(&wxMaskedRangeCheck, &fparamsIP);
+
+    edPlain = edTexCtrl->GetPlainValue();
+    tcPlainText = new wxTextCtrl(this, idCtrl + 100, edPlain);
+    tcPlainText->SetEditable(false);
+    tcPlainText->SetMinSize( edTexCtrl->GetMinSize() );
+    mainSizer->Add(tcPlainText, sizerFlags);
+
+    //Sample 6
+    idCtrl++;
+    stDesText = new wxStaticText(this, wxID_ANY, "hh:mm:ss");
+    mainSizer->Add(stDesText, sizerFlags);
+    edMask = "99:99:99";
+    stMaskText = new wxStaticText(this, wxID_ANY, edMask);
+    mainSizer->Add(stMaskText, sizerFlags);
+
+    edTexCtrl = new wxMaskedEditText(this, idCtrl);
+    parent->ctrIDs.push_back(idCtrl);
+    edTexCtrl->SetMask(edMask);
+
+    edTexCtrl->SetAllFieldsFlags(fieldFlags); //same flags as sample 3
+    edTexCtrl->SetMaskedColours(mskColours); //idem
+    mainSizer->Add(edTexCtrl, sizerFlags);
+    //use the predefined range function
+    fparams23.rmin = 0;
+    fparams23.rmax = 23;
+    edTexCtrl->SetFieldFunction(0, &wxMaskedRangeCheck, &fparams23);
+    fparams59.rmin = 0;
+    fparams59.rmax = 59;
+    edTexCtrl->SetFieldFunction(1, &wxMaskedRangeCheck, &fparams59);
+    edTexCtrl->SetFieldFunction(2, &wxMaskedRangeCheck, &fparams59);
+
+    edPlain = edTexCtrl->GetPlainValue();
+    tcPlainText = new wxTextCtrl(this, idCtrl + 100, edPlain);
+    tcPlainText->SetEditable(false);
+    tcPlainText->SetMinSize( edTexCtrl->GetMinSize() );
+    mainSizer->Add(tcPlainText, sizerFlags);
+
+    //Sample 7
+    idCtrl++;
+    stDesText = new wxStaticText(this, wxID_ANY, "Date mm/dd/yyyy");
+    mainSizer->Add(stDesText, sizerFlags);
+    edMask = "9#/9#/####";
+    stMaskText = new wxStaticText(this, wxID_ANY, edMask);
+    mainSizer->Add(stMaskText, sizerFlags);
+
+    edTexCtrl = new wxMaskedEditText(this, idCtrl);
+    parent->ctrIDs.push_back(idCtrl);
+    edTexCtrl->SetMask(edMask);
+
+    edTexCtrl->SetAllFieldsFlags(fieldFlags); //same flags as sample 3
+    edTexCtrl->SetFieldValue(2, "2012");
+    edTexCtrl->SetMaskedColours(mskColours); //idem
+    mainSizer->Add(edTexCtrl, sizerFlags);
+    //use the predefined date function
+    dparams1.monthField = 0;
+    dparams1.dayField = 1;
+    dparams1.yearField = 2;
+    edTexCtrl->SetControlFunction( &wxMaskedDateShort, &dparams1 );
+
+    edPlain = edTexCtrl->GetPlainValue();
+    tcPlainText = new wxTextCtrl(this, idCtrl + 100, edPlain);
+    tcPlainText->SetEditable(false);
+    tcPlainText->SetMinSize( edTexCtrl->GetMinSize() );
+    mainSizer->Add(tcPlainText, sizerFlags);
+
+    //Sample 8
+    idCtrl++;
+    stDesText = new wxStaticText(this, wxID_ANY, "Date yyyy/mm/dd");
+    mainSizer->Add(stDesText, sizerFlags);
+    edMask = "####/9#/9#";
+    stMaskText = new wxStaticText(this, wxID_ANY, edMask);
+    mainSizer->Add(stMaskText, sizerFlags);
+
+    edTexCtrl = new wxMaskedEditText(this, idCtrl);
+    parent->ctrIDs.push_back(idCtrl);
+    edTexCtrl->SetMask(edMask);
+
+    edTexCtrl->SetAllFieldsFlags(fieldFlags); //same flags as sample 3
+    edTexCtrl->SetMaskedColours(mskColours); //idem
+    mainSizer->Add(edTexCtrl, sizerFlags);
+    //use the predefined date function
+    dparams2.monthField = 1;
+    dparams2.dayField = 2;
+    dparams2.yearField = 0;
+    edTexCtrl->SetControlFunction( &wxMaskedDateShort, &dparams2 );
+
+    edPlain = edTexCtrl->GetPlainValue();
+    tcPlainText = new wxTextCtrl(this, idCtrl + 100, edPlain);
+    tcPlainText->SetEditable(false);
+    tcPlainText->SetMinSize( edTexCtrl->GetMinSize() );
+    mainSizer->Add(tcPlainText, sizerFlags);
+
+    //sample 9
+    idCtrl++;
+    stDesText = new wxStaticText(this, wxID_ANY, "Product key");
+    mainSizer->Add(stDesText, sizerFlags);
+    edMask = "AAA-NNNN-NN|##";
+    stMaskText = new wxStaticText(this, wxID_ANY, edMask);
+    mainSizer->Add(stMaskText, sizerFlags);
+
+    edTexCtrl = new wxMaskedEditText(this, idCtrl);
+    parent->ctrIDs.push_back(idCtrl);
+    edTexCtrl->SetMask(edMask);
+
+    edTexCtrl->SetMaskedColours(mskColours); //idem
+    mainSizer->Add(edTexCtrl, sizerFlags);
+    //use our user function. It does not need parameters, so pass NULL
+    edTexCtrl->SetControlFunction( &MyFunction, NULL );
+
+    edPlain = edTexCtrl->GetPlainValue();
+    tcPlainText = new wxTextCtrl(this, idCtrl + 100, edPlain);
+    tcPlainText->SetEditable(false);
+    tcPlainText->SetMinSize( edTexCtrl->GetMinSize() );
+    mainSizer->Add(tcPlainText, sizerFlags);
+
+    //sample 10
+    idCtrl++;
+    stDesText = new wxStaticText(this, wxID_ANY, "Critical moments");
+    mainSizer->Add(stDesText, sizerFlags);
+    edMask = "9#/9#/#### \\at 9#:9#";
+    stMaskText = new wxStaticText(this, wxID_ANY, edMask);
+    mainSizer->Add(stMaskText, sizerFlags);
+
+    wxString myChoices[] = {" 1/ 1/2000 at 00:00",
+                            "12/31/1999 at 23:59",
+                            "12/21/2012 at 12:00"};
+    edComboCtrl = new wxMaskedEditCombo(this, idCtrl, "",
+                                        wxDefaultPosition, wxDefaultSize,
+                                        WXSIZEOF(myChoices), myChoices);
+    parent->ctrIDs.push_back(idCtrl);
+    edComboCtrl->SetMask(edMask);
+
+    edComboCtrl->SetAllFieldsFlags(fieldFlags); //same flags as sample 3
+    mskColours.colWrForegn.Set(0, 0, 0);
+    edComboCtrl->SetMaskedColours(mskColours);
+    mainSizer->Add(edComboCtrl, sizerFlags);
+    //use the predefined range and date functions
+    edComboCtrl->SetFieldFunction(3, &wxMaskedRangeCheck, &fparams23);
+    edComboCtrl->SetFieldFunction(4, &wxMaskedRangeCheck, &fparams59);
+    dparams1.monthField = 0;
+    dparams1.dayField = 1;
+    dparams1.yearField = 2;
+    edComboCtrl->SetControlFunction( &wxMaskedDateShort, &dparams1 );
+
+    edPlain = edComboCtrl->GetPlainValue();
+    tcPlainText = new wxTextCtrl(this, idCtrl + 100, edPlain);
+    tcPlainText->SetEditable(false);
+    tcPlainText->SetMinSize( edComboCtrl->GetMinSize() );
+    mainSizer->Add(tcPlainText, sizerFlags);
+
+
+    mainSizer->AddSpacer(5);
+
+    //The layout of this panel is managed by this sizer
+    SetSizer(mainSizer);
+}
+

Index: samples/maskededit/maskededit.bkl
===================================================================
--- samples/maskededit/maskededit.bkl	(revisión: 0)
+++ samples/maskededit/maskededit.bkl	(revisión: 0)
@@ -0,0 +1,13 @@
+<?xml version="1.0" ?>
+<makefile>
+
+    <include file="../../build/bakefiles/common_samples.bkl"/>
+
+    <exe id="maskededit" template="wx_sample" template_append="wx_append">
+        <sources>maskedctrl.cpp</sources>
+        <wx-lib>adv</wx-lib>
+        <wx-lib>core</wx-lib>
+        <wx-lib>base</wx-lib>
+    </exe>
+
+</makefile>

Index: src/generic/maskededit.cpp
===================================================================
--- src/generic/maskededit.cpp	(revisión: 0)
+++ src/generic/maskededit.cpp	(revisión: 0)
@@ -0,0 +1,1952 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        src/generic/maskedfield.cpp
+// Purpose:     wxMaskedEdit implementation
+// Author:      Manuel Martin
+// Modified by:
+// Created:     2012-07-30
+// RCS-ID:      $Id$
+// Copyright:   (c)
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#if wxUSE_MASKED_EDIT
+
+#if wxUSE_COMBOBOX
+    #include "wx/scrolbar.h"
+#endif // wxUSE_COMBOBOX
+
+#include "wx/clipbrd.h"
+#include "wx/maskededit.h"
+
+
+//////////////////////////  wxMaskedEdit  ////////////////////////////////
+/*EXPLANATIONS
+  This control must filter chars, according with the mask. We store mask
+  information in two ways: the expanded string (see below) 'm_ExpMask' and
+  a vector of types (enum: mDigitReq, mDigitOpt, mAlphaReq, etc) 'm_maskIDs'.
+  m_ExpMask tells us the literals used between fields. m_maskIDs allows us
+  to store also upper/lower commands (by adding some value).
+
+  Fields are homogeneous, which means, for example, that we don't allow a
+  digit where only an alpha char is accepted.
+
+  All ways for enter/delete characters (EVT_CHAR, Paste, SetFieldValue, etc)
+  end in the same point: calling TextEntry::SetValue(newValue). The user can
+  call SetValue(useValue). And before setting it, we must test it, filtering
+  chars against the mask.
+  Because this new value contains not only the 'typed' chars, but also literal
+  chars and the chars used to fill empty positions ("cells"), we can not tell
+  just from this value which are literals, which are empty cells and which are
+  not. In a common case, space ' ' is used as literal and also as the char for
+  empty cells. We annotate used cells in m_filled, carefully setting true/false
+  for each position in the value.
+
+  When the user calls SetValue(), we can't make use of this m_filled to test
+  the value. But we must fill m_filled. We set false (empty cell) when we
+  meet a literal or the char we will use to fill empty cells. The consequence
+  is that the 'fillchar' is not accepted in a field that uses it, even if the
+  mask in that field allows that fillchar.
+
+  A tricky part in this code is the caret movement. We use PosForFieldPrev(),
+  PosForFieldNext() and MoveCaret() combined adequately for each case.
+
+  The functions used to test a field and the one used with the whole control
+  don't change the value. They only say right/wrong. If the user has set the
+  colours parameter, the control is coloured according this function's return.
+  And, of course, also accordingly with the mask (think of required chars).
+*/
+
+// Set the mask. If there isn't a field in it, returns false.
+/*
+  We really don't use the string passed as mask. This is due it may be a
+  compressed one. "#-#-#{5}" will expand into "#-#-#####". Instead, we use
+  an array of identifiers, with an identifier (see the enum) for each
+  expanded position. We also store the expanded mask, so we can have the
+  'literals' used as field separators.
+
+  The expanded mask sets the fixed-length user's input. In other words, the
+  control's value has always the same length, despite of if some positions
+  are empty or not.
+  We store the begin/end positions (expanded) for each field (m_arrPosS and
+  m_arrPosF). This way, we can quickly know which field corresponds to control's
+  cursor position.
+
+  Each field must be homogeneous: all of its commands must allow the same
+  chars. So "#9" is valid, while "#C" is not.
+*/
+
+//Check the cell to be homogeneous with the field type.
+// type1 type2 are valid types (e.g. # 9 or A a)
+inline bool IsHomogField(int* firstFieldCmm, int type1, int type2)
+{
+    if ( *firstFieldCmm == -1)
+    {
+        *firstFieldCmm = type1; //Field beginning, annotate the command
+    }
+    else if ( *firstFieldCmm != type1 && *firstFieldCmm != type2)
+    {
+        wxFAIL_MSG("Unhomogeneous field in mask");
+        return false;
+    }
+    return true;
+}
+
+
+bool wxMaskedEdit::SetMask(const wxString& mask)
+{
+    //If mask is empty, do nothing
+    if ( mask.IsEmpty() )
+    {
+        wxFAIL_MSG("Empty mask is not allowed");
+        return false; //This "mask" is not a mask.
+    }
+
+    //Temporary objects. We need them because this 'mask' may be wrong, which
+    // means it has really no field at all. If so, we don't change anything.
+    wxString   maskTmp;
+    wxVector<int> maskIDTmp;
+    wxVector<long> fieldsBeg;
+    wxVector<long> fieldsEnd;
+    //We'll use this string to set the min size of the control
+    wxString sForSize;
+
+    //Iterate through the mask
+    long pos = 0;
+    wxString comchars = "#9AaNnCcXx"; //expandable commands
+    bool fieldStarted = false;
+    bool lastIsComchars = false;
+    int firstFieldCmm = -1; //the first command in a field
+    bool isLiteral = true;
+    //An integer to add for upper/lower forced cases
+    int caseULforced = 0; //3-state: 0 nothing, mUppChar, mLowChar
+    wxString::const_iterator i = mask.begin();
+    while ( i != mask.end() )
+    {
+        wxChar ch = *i;
+
+        //Possibilities: command, upper/lower, expansion, literal
+        if ( comchars.Find( ch ) != wxNOT_FOUND )
+        {
+            //let's see if it's a field's start
+            if ( !fieldStarted )
+            {
+                fieldsBeg.push_back( pos ); //position in the expanded mask
+                fieldStarted = true;
+            }
+
+            if ( ch == '#' )
+            {
+                maskIDTmp.push_back( mDigitReq );
+                if ( !IsHomogField(&firstFieldCmm, mDigitReq, mDigitOpt) )
+                    return false;
+            }
+            else if ( ch == '9' )
+            {
+                maskIDTmp.push_back( mDigitOpt );
+                if ( !IsHomogField(&firstFieldCmm, mDigitReq, mDigitOpt) )
+                    return false;
+            }
+            else if( ch == 'A' )
+            {
+                maskIDTmp.push_back( mAlphaReq + caseULforced );
+                if ( !IsHomogField(&firstFieldCmm, mAlphaReq, mAlphaOpt) )
+                    return false;
+            }
+            else if( ch == 'a' )
+            {
+                maskIDTmp.push_back( mAlphaOpt + caseULforced );
+                if ( !IsHomogField(&firstFieldCmm, mAlphaReq, mAlphaOpt) )
+                    return false;
+            }
+            else if( ch == 'N' )
+            {
+                maskIDTmp.push_back( mAlpNumReq + caseULforced );
+                if ( !IsHomogField(&firstFieldCmm, mAlpNumReq, mAlpNumOpt) )
+                    return false;
+            }
+            else if( ch == 'n' )
+            {
+                maskIDTmp.push_back( mAlpNumOpt + caseULforced );
+                if ( !IsHomogField(&firstFieldCmm, mAlpNumReq, mAlpNumOpt) )
+                    return false;
+            }
+            else if( ch == 'C' )
+            {
+                maskIDTmp.push_back( mAnyCharReq + caseULforced );
+                if ( !IsHomogField(&firstFieldCmm, mAnyCharReq, mAnyCharOpt) )
+                    return false;
+            }
+            else if( ch == 'c' )
+            {
+                maskIDTmp.push_back( mAnyCharOpt + caseULforced );
+                if ( !IsHomogField(&firstFieldCmm, mAnyCharReq, mAnyCharOpt) )
+                    return false;
+            }
+            else if( ch == 'X' )
+            {
+                maskIDTmp.push_back( mHexReq + caseULforced );
+                if ( !IsHomogField(&firstFieldCmm, mHexReq, mHexOpt) )
+                    return false;
+            }
+            else if( ch == 'x' )
+            {
+                maskIDTmp.push_back( mHexOpt + caseULforced );
+                if ( !IsHomogField(&firstFieldCmm, mHexReq, mHexOpt) )
+                    return false;
+            }
+
+            maskTmp << ch;
+            lastIsComchars = true;
+            if (ch == '#' || ch == '9')
+                sForSize << '9' ;
+            else
+                sForSize << 'M' ;
+
+            pos++;
+            i++;
+            continue;
+        }
+
+        if ( ch == '>' )
+        {
+            caseULforced = mUppChar;
+            //Don't 'close' the field. This char is not a literal
+            i++;
+            continue;
+        }
+        if ( ch == '<' )
+        {
+            caseULforced = mLowChar;
+            //Don't 'close' the field. This char is not a literal
+            i++;
+            continue;
+        }
+        if ( ch == '^' )
+        {
+            caseULforced = 0; //stop upper/lower forcing
+            //Don't 'close' the field. This char is not a literal
+            i++;
+            continue;
+        }
+
+        isLiteral = true;
+        //The expansion command '{' only acts on chars inside comchars wxString
+        if( lastIsComchars && ch == '{' )
+        {
+            //If only digits are found until '}', this is an expansion command
+            //Otherwise it's a literal
+            wxString::const_iterator j = i;
+            j++;
+            wxChar ce;
+            size_t nudigs = 0;
+            wxString theNum;
+            //Let's see the next characters
+            while ( j != mask.end() )
+            {
+                ce = *j;
+                if ( wxIsdigit( ce ) )
+                {
+                    nudigs++;
+                    theNum << ce; //forming the number
+                    j++;
+                }
+                else if ( ce == '}' && nudigs > 0 ) //expander finishes here
+                {
+                    //Convert theNum to a long. Perhaps it was "000", which
+                    // is a valid but useless expander.
+                    long numex = 0;
+                    if ( theNum.ToCLong( &numex ) && numex > 1 )
+                    {
+                        //Expand previous command
+                        numex--; //the first "copy" was already given
+                        int lastID = maskIDTmp.back();
+                        for (long nu = 0; nu < numex; nu++)
+                        {
+                            maskIDTmp.push_back(lastID);
+                        }
+                        maskTmp.Append( maskTmp.Last(), (size_t) numex );
+                        if (sForSize.Last() == '9')
+                            sForSize.Append('9', (size_t) numex );
+                        else
+                            sForSize.Append('M', (size_t) numex );
+
+                        pos += numex;
+                    }
+                    i = j; //skip these already examined chars.
+                    i++;
+                    isLiteral = false;
+                    //Don't allow consecutive expanders: {3}{6}
+                    lastIsComchars = false;
+                    break;
+                }
+                else
+                {
+                    break; //treat this '{' as a literal
+                }
+            }
+        }
+
+        //Literal treatment
+        if ( isLiteral )
+        {
+            //When previous char was inside a field, finish it.
+            if ( fieldStarted )
+            {
+                fieldsEnd.push_back( pos - 1 ); //Define a new field
+                fieldStarted = false;
+                firstFieldCmm = -1; //reset
+            }
+
+            //'|' means fields ends here, but don't show '|' as any literal
+            if ( ch != '|' )
+            {
+                if ( ch == '\\' )
+                {
+                    i++; //the real literal is next char.
+                    if ( i != mask.end() )
+                    {
+                        ch = *i;
+                    }
+                    else
+                    {
+                        wxFAIL_MSG("Incomplete escaped character");
+                        return false; //'\' at end of mask
+                    }
+                }
+                //Store in the expanded mask. Useful for 'painting' it
+                if ( !wxIsprint(ch) )
+                {
+                    wxFAIL_MSG("Warning: Unprintable character in mask");
+                }
+                maskTmp << ch;
+                maskIDTmp.push_back(mLiteral);
+                sForSize << ch; //This literal has its own size. Don't use 9/M
+                pos++;
+            }
+            i++;
+            lastIsComchars = false;
+        }
+    }
+
+    //If a field is still 'not closed', finish it
+    if ( fieldStarted )
+    {
+        fieldsEnd.push_back( pos - 1 ); //Define a new field
+    }
+
+    if ( fieldsEnd.empty() )
+    {
+        wxFAIL_MSG("The mask must have at least one field");
+        return false;
+    }
+
+    //Copy temporary objects to definitive ones
+    m_ExpMask = maskTmp;
+    m_maskIDs = maskIDTmp;
+    m_arrPosS = fieldsBeg;
+    m_arrPosF = fieldsEnd;
+
+    //Update also at params object
+    m_params.mask = mask; //User definition string, not the expanded
+
+    //Also clear all field dependent parameters.
+    //Changing the mask may change fields. We suppose that previous fields
+    // parameters (choices, allowed/excluded chars, etc) are now invalid.
+    m_params.ResetFields( fieldsEnd.size() );
+
+    //Previous value in the control is lost. Let's show the new empty one
+    m_filled.clear();
+    m_filled.reserve( m_ExpMask.Len() );
+    for (size_t i = 0; i < m_ExpMask.Len(); i++)
+        m_filled.push_back(false);
+
+    SetPlainValue("");
+
+    //Update the minimal size of the control
+    sForSize << 'a'; //give it a tip, for margins
+
+    int extraSize = 0;
+#if wxUSE_COMBOBOX
+    //If our control is a wxComboBox we need extra space for the drop arrow
+    wxComboBox *combo = wxDynamicCast(msk_control, wxComboBox);
+    if ( combo )
+    {
+        wxScrollBar *sb = new wxScrollBar(combo->GetParent(), wxID_ANY,
+                                          wxDefaultPosition, wxDefaultSize, wxSB_VERTICAL);
+        extraSize = sb->GetSize().GetWidth();
+        sb->Destroy();
+    }
+#endif // wxUSE_COMBOBOX
+
+    int w, h;
+    msk_control->GetTextExtent(sForSize, &w, &h);
+    w += extraSize;
+    //try to avoid ugliness
+    if ( msk_control->GetFont().IsFixedWidth() )
+        w += 3; //just a bit more
+    else
+        w = w * 8 / 10; //The rule of 80%/20% is worth everywhere
+
+    msk_control->SetMinClientSize(wxSize(w, -1));
+
+    return true;
+}
+
+//Set the colours for different cases.
+void wxMaskedEdit::SetMaskedColours(const wxMaskedEditColours& colours)
+{
+    wxColour defFg, defBg;
+    GetDefaultColours( &defFg, &defBg );
+
+    m_params.colours = colours;
+    //Use defaults for colours that have not been set yet
+    if ( m_params.colours.colOKBackgn == wxNullColour )
+        m_params.colours.colOKBackgn == defBg;
+    if ( m_params.colours.colOKForegn == wxNullColour )
+        m_params.colours.colOKForegn == defFg;
+    if ( m_params.colours.colWrBackgn == wxNullColour )
+        m_params.colours.colWrBackgn == defBg;
+    if ( m_params.colours.colWrForegn == wxNullColour )
+        m_params.colours.colWrForegn == defFg;
+    if ( m_params.colours.colEmBackgn == wxNullColour )
+        m_params.colours.colEmBackgn == defBg;
+    if ( m_params.colours.colEmForegn == wxNullColour )
+        m_params.colours.colEmForegn == defFg;
+}
+
+//Default colours. We need them if not all of the six colours have been set.
+void wxMaskedEdit::GetDefaultColours(wxColour* defFgCol, wxColour* defBgCol)
+{
+#if wxUSE_TEXTCTRL
+    if ( wxTextCtrl *text = wxDynamicCast(msk_control, wxTextCtrl) )
+    {
+        *defBgCol = text->GetClassDefaultAttributes().colBg;
+        *defFgCol = text->GetClassDefaultAttributes().colFg;
+        return;
+    }
+#endif // wxUSE_TEXTCTRL
+
+#if wxUSE_COMBOBOX
+    if ( wxComboBox *combo = wxDynamicCast(msk_control, wxComboBox) )
+    {
+        *defBgCol = combo->GetClassDefaultAttributes().colBg;
+        *defFgCol = combo->GetClassDefaultAttributes().colFg;
+        return;
+    }
+#endif // wxUSE_COMBOBOX
+
+    return;
+}
+
+//Set all fields with the same flags.
+void wxMaskedEdit::SetAllFieldsFlags(const wxEditFieldFlags& flags)
+{
+    for (size_t i = 0; i < GetFieldsCount(); i++)
+        SetFieldFlags(i, flags);
+}
+
+//Set the test function for a field.
+void wxMaskedEdit::SetFieldFunction(size_t index,
+                                    wxMaskedFieldFunc* fn,
+                                    void* param)
+{
+    m_params.fieldsFuncs.at(index) = fn;
+    m_params.fieldFuncsParams.at(index) = param;
+}
+
+//Set all fields with the same functions
+void wxMaskedEdit::SetAllFieldsFunction(wxMaskedFieldFunc* fn, void* param)
+{
+    for (size_t i = 0; i < GetFieldsCount(); i++)
+        SetFieldFunction(i, fn, param);
+}
+
+//Set the test function for the whole control.
+void wxMaskedEdit::SetControlFunction(wxMaskedFunc* fn, void* param)
+{
+    m_params.controlFunc = fn;
+    m_params.controlFuncParams = param;
+}
+
+//Set all parameters at once, replacing old ones
+bool wxMaskedEdit::SetParams(const wxMaskedEditParams& params)
+{
+    //Try the mask
+    if ( !SetMask(params.mask) )
+        return false;
+
+    //Set the new fields parameters
+    if ( params.fieldsFlags.size() != m_params.fieldsFlags.size()
+        || params.fieldsFuncs.size() != m_params.fieldsFuncs.size()
+        || params.fieldFuncsParams.size() != m_params.fieldFuncsParams.size() )
+    {
+        wxFAIL_MSG("Wrong number of fields parameters");
+        return false;
+    }
+
+    for (size_t i = 0; i < params.fieldsFlags.size(); i++)
+    {
+        SetFieldFlags(i, params.fieldsFlags[i]);
+        SetFieldFunction(i, params.fieldsFuncs[i], params.fieldFuncsParams[i]);
+    }
+
+    SetControlFunction(params.controlFunc, params.controlFuncParams);
+
+    //Set the colours
+    SetMaskedColours(params.colours);
+
+    return true;
+}
+
+//Set the control's value from an undecorated text, which is supposed to
+// resemble user's input.
+//Also annotates empty cells (characters not typed)
+bool wxMaskedEdit::SetPlainValue(const wxString& plainValue)
+{
+    //If the mask is not big enough, this plainValue does not fit in it
+    //TODO: allow it with a flag?
+    if ( plainValue.Len() > m_ExpMask.Len() )
+        return false;
+
+    size_t posMask;
+    wxString forControl(wxChar('\0'), m_ExpMask.Len());
+    wxChar ch;
+    //If we return before all chars are processed, we'll restore the backup
+    m_fillBck = m_filled;
+
+    // Fill from left to right
+    wxString::const_iterator iMask = m_ExpMask.begin();
+    wxString::const_iterator iPlain = plainValue.begin();
+    wxString::iterator iControl = forControl.begin();
+    posMask = 0;
+    while ( iMask != m_ExpMask.end() )
+    {
+        if ( m_maskIDs[posMask] == mLiteral )
+        {
+            ch = *iMask;
+            m_filled[posMask] = false;
+        }
+        else
+        {
+            if ( iPlain != plainValue.end() )
+            {
+                ch = *iPlain;
+                iPlain++;
+                if ( !TestChar(&ch, posMask) ) //may force upper/lower case
+                {
+                    m_filled = m_fillBck; //restore
+                    return false; //stop now because this char is not allowed
+                }
+                m_filled[posMask] = true; //mark it as 'typed'
+            }
+            else //use fillChar
+            {
+                ch = GetFieldFlags(FindField((long)posMask)).GetFillChar();
+                m_filled[posMask] = false;
+            }
+        }
+        *iControl = ch; //set the char
+        iControl++;
+        iMask++;
+        posMask++;
+    }
+
+    //Make sure all fields are aligned
+    for (size_t index = 0; index < GetFieldsCount(); index++)
+        NormalizeField(index, &forControl);
+
+    //Update the control
+    GetTextEntry()->SetValue(forControl);
+
+    return true;
+}
+
+//Like SetFieldValue(), but operates on inText, not in control
+wxString wxMaskedEdit::SetFieldOnText(size_t index,
+                                      const wxString& plainValue,
+                                      const wxString& inText)
+{
+    wxString resString;
+
+    //Does this field exist?
+    if ( index >= GetFieldsCount() )
+        return wxEmptyString;
+
+    //If left aligned, fill from left, else fill from right
+    int ctlPos = m_arrPosS[index];
+    int endPos = m_arrPosF[index] + 1;
+    int valuePos = 0;
+    int valueEnd = plainValue.Len();
+    int inc = 1;
+
+    //If the field is not big enough, this plainValue does not fit in it
+    //TODO allow it with a flag?
+    if ( valueEnd > endPos - ctlPos )
+        return wxEmptyString;
+
+    if ( GetFieldFlags(index).GetAlignment() == wxALIGN_RIGHT )
+    {
+        endPos = m_arrPosS[index] - 1;
+        ctlPos = m_arrPosF[index];
+        inc = -1;
+        valuePos = plainValue.Len() - 1;
+        valueEnd = -1;
+    }
+
+    resString = inText;
+    wxChar ch;
+    while ( ctlPos != endPos )
+    {
+        if ( valuePos != valueEnd )
+        {
+            ch = plainValue.GetChar((size_t)valuePos);
+            if ( !TestChar(&ch, ctlPos) ) //may force upper/lower case
+                return wxEmptyString; //stop now because this char is not allowed
+
+            m_filled[(size_t)ctlPos] = true; //mark it as 'typed'
+            valuePos += inc;
+        }
+        else //plainValue is shorter than the field
+        {
+            ch = GetFieldFlags(index).GetFillChar();
+            m_filled[(size_t)ctlPos] = false; //mark it as 'not typed'
+        }
+
+        resString[(size_t)ctlPos] = ch; //replace in the whole [control] string
+        ctlPos += inc;
+    }
+
+    return resString;
+}
+
+//Set the value for a field.
+bool wxMaskedEdit::SetFieldValue(size_t index, const wxString& plainValue)
+{
+    wxString controlValue = GetTextEntry()->GetValue();
+    m_fillBck = m_filled;
+
+    wxString cVal = SetFieldOnText(index, plainValue, controlValue);
+
+    if ( cVal.IsEmpty() )
+    {
+        m_filled = m_fillBck;
+        return false;
+    }
+
+    //Update the control
+    GetTextEntry()->SetValue(cVal);
+
+    return true;
+}
+
+//Like GetFieldValue(), but operates on inText, not in control
+//Fill empty cells with 'chPad', if it is != '\0'
+wxString wxMaskedEdit::GetFieldOnText(size_t index,
+                                      const wxString& inText,
+                                      wxChar chPad) const
+{
+    wxString resString;
+
+    //Does this field exist?
+    if ( index >= GetFieldsCount() )
+        return resString;
+
+    //Extract char by char. Fill with chPad if the cell is empty
+    for (long i = m_arrPosS[index]; i <= m_arrPosF[index]; i++)
+    {
+        if ( !CellIsEmpty(i) )
+            resString << inText[(size_t)i];
+        else if ( chPad != '\0' )
+            resString << chPad;
+    }
+
+    return resString;
+}
+
+//Get the current text in a field. Fill empty cells with padding-char flag
+wxString wxMaskedEdit::GetFieldValue(size_t index) const
+{
+    return GetFieldOnText(index,
+                          GetTextEntry()->GetValue(),
+                          GetFieldFlags(index).GetPaddingChar() );
+}
+
+//Get control's value, without decorations.
+wxString wxMaskedEdit::GetPlainValue() const
+{
+    wxString pValue;
+    wxString ctrlValue = GetTextEntry()->GetValue();
+    wxString::const_iterator iT = ctrlValue.begin();
+    size_t pos = 0;
+    size_t field = 0;
+    wxChar padCh = '\0';
+    while ( iT != ctrlValue.end() )
+    {
+        if ( m_maskIDs[pos] != mLiteral )
+        {
+            if ( m_filled[pos] )
+                pValue += *iT;
+            else
+            {
+                //use the padding char
+                field = FindField((long) pos);
+                if ( field != (size_t)wxNOT_FOUND )
+                {
+                    padCh = GetFieldFlags(field).GetPaddingChar();
+                    if ( padCh != '\0' )
+                        pValue += padCh;
+                }
+            }
+        }
+        ++iT;
+        ++pos;
+    }
+
+    return pValue;
+}
+
+// ---------------------------------------------------------------------------
+// -  -  -  -  -  -  -  - Event handling -  -  -  -  -  -  -  -  -  -  -  -  -
+
+//Handle the selection, returning the new possible control's value
+wxString wxMaskedEdit::HandleSelection(long *pos, bool *changed)
+{
+    wxString newString = GetTextEntry()->GetValue();
+    long selFrom, selTo;
+    GetTextEntry()->GetSelection(&selFrom, &selTo);
+
+    if (selFrom == selTo)
+    {
+        //No selection, nothing else to do
+        *changed = false;
+        return newString;
+    }
+
+    //To erase the selection we replace each cell with it's fillchar.
+    //Also mark this cells as 'empty'
+    size_t i = (size_t)selFrom;
+    wxString::iterator it = newString.begin() + selFrom;
+    while ( i < (size_t)selTo )
+    {
+        if ( m_maskIDs[i] != mLiteral && m_filled[i] )
+        {
+            *it = GetFieldFlags((size_t) FindField(i) ).GetFillChar();
+            m_filled[i] = false;
+            *changed = true;
+        }
+        i++;
+        ++it;
+    }
+
+    if ( *changed )
+        *pos = selFrom;
+
+    return newString;
+}
+
+void wxMaskedEdit::OnKeyDown(wxKeyEvent& event)
+{
+    event.Skip();
+
+    //Using shift+arrow means 'selecting'. We don't handle this.
+    if ( event.HasModifiers() )
+    {
+        if (  event.GetKeyCode() == WXK_BACK
+            ||event.GetKeyCode() == WXK_DELETE
+            ||event.GetKeyCode() == WXK_NUMPAD_DELETE )
+        {
+            //don't allow these sort of deleting
+            event.Skip(false);
+        }
+
+        //Clipboard
+        if ( event.GetModifiers()== wxMOD_CONTROL )
+        {
+            //Cutting with 'Ctrl-X'
+            if (event.GetKeyCode() == 88)
+            {
+                event.Skip(false);
+                DoCut();
+            }
+            //Pasting with 'Ctrl-V'
+            else if(event.GetKeyCode() == 86)
+            {
+                event.Skip(false);
+                DoPaste();
+            }
+        }
+
+        //We don't handle other modifiers neither.
+        return;
+    }
+
+    long carPos = GetTextEntry()->GetInsertionPoint();
+    bool toNext = true;
+
+    switch ( event.GetKeyCode() )
+    {
+        case WXK_LEFT:
+        case WXK_NUMPAD_LEFT:
+        {
+            toNext = false;
+            //fall through
+        }
+        case WXK_RIGHT:
+        case WXK_NUMPAD_RIGHT:
+        {
+            MoveCaret(carPos, toNext);
+            event.Skip(false);
+            return;
+        }
+
+        case WXK_BACK:
+            if ( carPos > m_arrPosS[0] )
+                carPos--;
+        case WXK_DELETE:
+        case WXK_NUMPAD_DELETE:
+        {
+            long newPos = -1;
+            bool shouldUpdate = false;
+            //The whole control's value, changed after deleting the selection
+            event.Skip(false); //no other processing
+
+            wxString ctrString = HandleSelection(&newPos, &shouldUpdate);
+            if ( newPos == -1 )
+            {
+                //No selection.
+                size_t index = (size_t) wxNOT_FOUND;
+
+                if ( carPos >= m_arrPosS[0] && carPos <= m_arrPosF.back() )
+                {
+                    index = (size_t) FindField(carPos);
+                    if (index != (size_t) wxNOT_FOUND && !CellIsEmpty(carPos))
+                    {
+                        m_filled[carPos] = false;
+                        ctrString[carPos] = GetFieldFlags((size_t)index).GetFillChar();
+                        NormalizeField((size_t)index, &ctrString);
+                        shouldUpdate = true;
+                        if ( GetFieldFlags((size_t)index).GetAlignment() == wxALIGN_RIGHT)
+                            carPos++;
+                    }
+                    else
+                    {
+                        if (event.GetKeyCode() == WXK_BACK )
+                        {
+                            //Backspace in an empty position, move to previous field
+                            carPos = MoveCaret(++carPos, false);
+                            index = (size_t)FindField(carPos);
+                            if ( index != (size_t)wxNOT_FOUND
+                                && GetFieldFlags((size_t)index).GetAlignment()
+                                    == wxALIGN_LEFT
+                                && !CellIsEmpty(carPos) )
+                            {
+                                carPos++;
+                            }
+                        }
+                        else
+                        {
+                            //delete in an empty position, move towards right
+                            carPos = MoveCaret(carPos, true);
+                        }
+                    }
+                }
+                else
+                {
+                    if (event.GetKeyCode() == WXK_BACK )
+                        carPos = MoveCaret(++carPos, false);
+                    else
+                        carPos = MoveCaret(carPos, true);
+                }
+            }
+            //with selection
+            else
+            {
+                //done: delete the selection and set cursor at its beginning
+                if (event.GetKeyCode() == WXK_BACK )
+                    carPos++;
+            }
+
+            //Set value and cursor
+            if ( newPos != -1 || shouldUpdate )
+            {
+                //Join characters and align fields
+                for (size_t index = 0; index < GetFieldsCount(); index++)
+                    NormalizeField(index, &ctrString);
+
+                GetTextEntry()->SetValue(ctrString);
+            }
+
+            GetTextEntry()->SetInsertionPoint(carPos);
+            break;
+        }
+
+        default:
+            return;
+    }
+}
+
+void wxMaskedEdit::OnChar(wxKeyEvent& event)
+{
+    event.Skip();
+
+    //The char. Unicode or ASCII
+    int kc = 0;
+#if wxUSE_UNICODE
+    kc = (int) event.GetUnicodeKey();
+#else // !wxUSE_UNICODE
+    kc = event.GetKeyCode();
+#endif // wxUSE_UNICODE/!wxUSE_UNICODE
+
+    //Allow default 'ctrl-C' manager
+    if ( kc == WXK_CONTROL_C)
+        return;
+
+    //Allow standard 32-127 ASCII and also 128-255 ASCII extended characters
+    if ( kc < WXK_SPACE || kc >= WXK_START )
+        return;
+
+    wxChar keyChar(kc);
+
+    event.Skip(false); //This event will end here.
+
+    //If an EVT_CHAR event was generated for these cases, don't process
+    //them again. They have been already processed at OnKeyDown
+    switch ( (int)keyChar )
+    {
+        case WXK_LEFT:
+        case WXK_NUMPAD_LEFT:
+        case WXK_RIGHT:
+        case WXK_NUMPAD_RIGHT:
+        case WXK_BACK:
+        case WXK_DELETE:
+        case WXK_NUMPAD_DELETE:
+            return;
+
+        default:
+            break;
+    }
+
+    long caretPos = GetTextEntry()->GetInsertionPoint();
+
+    m_fillBck = m_filled;
+    //First handle the selection, if any
+    long selPos = -1; //changes if a selection erases anything
+    bool needsUpdate = false;
+    //The whole control's value, changed after deleting the selection;
+    // and the new caret position.
+    wxString workString = HandleSelection(&selPos, &needsUpdate);
+    if ( selPos != -1 )
+        caretPos = selPos;
+
+    bool isProccesed = ProcessChar(keyChar, &caretPos, &workString, &needsUpdate);
+
+    //Update if necessary
+    if ( isProccesed )
+    {
+        //If there was no selection and the typed char is a literal, we only
+        // move the caret, without useless SetValue().
+        //And avoid so the false wxEVT_COMMAND_TEXT_UPDATED event.
+        if ( needsUpdate || selPos != -1)
+            GetTextEntry()->SetValue(workString);
+
+        MoveCaret(caretPos, true);
+    }
+    else
+    {
+        //restore
+        m_filled = m_fillBck;
+        //beep
+        DoBell();
+    }
+}
+
+void wxMaskedEdit::OnCut(wxCommandEvent& event)
+{
+    event.Skip(false);
+    DoCut();
+}
+
+void wxMaskedEdit::OnPaste(wxCommandEvent& event)
+{
+    event.Skip(false);
+    DoPaste();
+}
+
+#if wxUSE_COMBOBOX
+void wxMaskedEdit::OnComboSelect(wxCommandEvent& event)
+{
+    //We must process this new value (test, tell empty cells, etc)
+    SetMaskedValue(event.GetString());
+    UpdateMaskedColours();
+    GetTextEntry()->SetInsertionPoint(0);
+
+    event.Skip(true);
+}
+
+void wxMaskedEdit::OnComboDrop(wxCommandEvent& event)
+{
+    //Neither OK nor Wr[ong] colours are good here. Use colours for an empty value
+    UseColours(mEmColour);
+
+    event.Skip(true);
+}
+#endif // wxUSE_COMBOBOX
+
+// ---------------------------------------------------------------------------
+// -  -  -  -  -  -  -  - More helpers -  -  -  -  -  -  -  -  -  -  -  -  -
+
+//Our control derives from wxTextEntry, but not this class. Get a pointer to it
+wxTextEntry* wxMaskedEdit::GetTextEntry() const
+{
+#if wxUSE_TEXTCTRL
+    if ( wxTextCtrl *text = wxDynamicCast(msk_control, wxTextCtrl) )
+        return text;
+#endif // wxUSE_TEXTCTRL
+
+#if wxUSE_COMBOBOX
+    if ( wxComboBox *combo = wxDynamicCast(msk_control, wxComboBox) )
+        return combo;
+#endif // wxUSE_COMBOBOX
+
+    wxFAIL_MSG("Can only be used with wxTextCtrl or wxComboBox");
+
+    return NULL;
+}
+
+//Update colours, depending on empty/valid/invalid cases
+void wxMaskedEdit::UpdateMaskedColours()
+{
+    //On an empty value, there are also defined colours
+    bool isEmpty = true;
+    for (size_t i = 0; i < m_filled.size(); i++)
+    {
+        if ( m_filled[i] )
+        {
+            isEmpty = false;
+            break;
+        }
+    }
+
+    if ( isEmpty )
+        UseColours(mEmColour);
+    else if ( IsValid() == -1 )
+        UseColours(mOKColour);
+    else
+        UseColours(mWRColour);
+
+}
+
+//Join characters and align the field. inText is the whole control's value.
+void wxMaskedEdit::NormalizeField(size_t index, wxString* inText)
+{
+    //Extract the field. Passing '\0' as filling char give us the typed value
+    wxString sField = GetFieldOnText(index, *inText, '\0');
+
+    //Do nothing on an empty field
+    if ( sField.IsEmpty() )
+        return;
+    //If the field is full filled, do nothing
+    size_t nToFill = m_arrPosF[index] - m_arrPosS[index] + 1;
+    if (sField.Len() == nToFill)
+        return;
+
+
+    size_t pos = m_arrPosS[index];
+    wxString::iterator iT = inText->begin() + pos;
+    wxChar fillChar = GetFieldFlags(index).GetFillChar();
+    wxString::const_iterator isF = sField.begin();
+
+    //set empty cells at left
+    if ( GetFieldFlags(index).GetAlignment() == wxALIGN_RIGHT )
+    {
+        while ( nToFill > sField.Len() )
+        {
+            *iT = fillChar;
+            m_filled[pos] = false;
+            ++iT;
+            ++pos;
+            nToFill--;
+        }
+    }
+    //Fill the cells
+    while ( nToFill > 0 )
+    {
+        if ( isF == sField.end() )
+        {
+            *iT = fillChar;
+            m_filled[pos] = false;
+        }
+        else
+        {
+            //This moved char must agree with mask. The field is homogeneous,
+            // so we know it is allowed. Set it to upper/lower case.
+            *iT = ToUppLowCase(*isF, pos);
+            m_filled[pos] = true;
+            ++isF;
+        }
+        ++iT;
+        ++pos;
+        nToFill--;
+    }
+}
+
+//If each cell is filled with a [typed] char or it is empty.
+//This information is stored in 'm_filled'
+/* For a field with 10 alpha chars (e.g. a 'Name' field) and being the fillchar
+  the typical blank (space), the 'real' control is initially filled with
+  10 spaces, so it can be shown in the screen.
+  When we call wxTextEntry::GetValue() we can't tell if those spaces are typed
+  or if they are there because of initial filling.
+  Carefully handling 'm_filled', we are aware of typed/filled chars.
+*/
+bool wxMaskedEdit::HasFieldRoom(size_t index) const
+{
+    //m_arrPosS/m_arrPosF are where field starts/finishes
+    for (long i = m_arrPosS[index]; i <= m_arrPosF[index]; i++)
+    {
+        //If we find an empty cell, the field has room
+        if ( CellIsEmpty(i) )
+            return true;
+    }
+
+    //No free cell found
+    return false;
+}
+
+//Find the field in which the cursor is.
+//For a position like "_23|-__" with mask "###-aa" it will return false, even
+// this is a valid position for typing the next char in a right aligned field.
+// GuessField() is more convenient for that case.
+int wxMaskedEdit::FindField(long curpos) const
+{
+    if ( curpos >= 0 )
+    {   for (size_t i = 0; i < m_arrPosS.size(); i++)
+        {
+            //Is the cursor between start and finish of a field?
+            if ( m_arrPosS[i] <= curpos && curpos <= m_arrPosF[i] )
+            {
+                return (int)i; //found
+            }
+        }
+    }
+
+    return wxNOT_FOUND; //not in a field
+}
+
+//Find the field to insert a char in the given position.
+int wxMaskedEdit::GuessField(long pos) const
+{
+    int index = FindField(pos);
+
+    //Perhaps we are just past the right most cell in a right aligned field
+    //For an insane mask as "###|AAA" with the first field right aligned, if
+    // the caret is just between both fields, which field do we get? The first
+    // one if it has room; otherwise, the second.
+    int prevIndex = FindField( pos - 1 );
+    if ( prevIndex != wxNOT_FOUND
+        && GetFieldFlags((size_t)prevIndex).GetAlignment() == wxALIGN_RIGHT
+        && HasFieldRoom((size_t)prevIndex) )
+    {
+        index = prevIndex;
+    }
+
+    return index;
+}
+
+//A reasonable position for caret in the previous field to where the caret is.
+long wxMaskedEdit::PosForFieldPrev(long curpos) const
+{
+    //Backwards search the first field that ends before the cursor position
+    size_t iField = m_arrPosF.size();
+    while ( iField > 0 )
+    {
+        if ( m_arrPosF[iField - 1] < curpos )
+        {
+            break;
+        }
+        iField--;
+    }
+    if ( iField == 0 )
+    {
+        //There is no field at left of the caret
+        return wxNOT_FOUND;
+    }
+
+    iField--;
+    long pos = m_arrPosF[iField];
+    if ( GetFieldFlags(iField).GetAlignment() == wxALIGN_LEFT )
+    {
+        if ( CellIsEmpty(pos) )
+        {
+            while (pos >= m_arrPosS[iField] && CellIsEmpty(pos) )
+                pos--;
+            pos++; //we have gone 1 char beyond
+        }
+    }
+    else
+    {
+        pos++; //e.g. "__123|"
+
+        //For a mask like "###-###|AA" we can have the case "__1-___FG".
+        //If the caret is at left of 'F' "__1-___|FG" and the user press
+        // left arrow, we must skip the second field (because it's empty)
+        // and move to the previous field.
+        if ( pos == curpos )
+        {
+            if ( CellIsEmpty(pos - 1) ) //empty field
+            {
+                long ppos = PosForFieldPrev(pos - 1);
+                if ( ppos != wxNOT_FOUND )
+                    pos = ppos;
+            }
+            else
+                pos--; //from "__123|" to "__12|3"
+        }
+    }
+
+    return pos;
+}
+
+//A reasonable position for caret in the next field to where the caret is.
+long wxMaskedEdit::PosForFieldNext(long curpos) const
+{
+    if ( curpos < 0 )
+        return wxNOT_FOUND;
+
+    //Search the first field that begins after the cursor position
+    size_t iField = 0;
+    while ( iField < m_arrPosS.size() )
+    {
+        if ( m_arrPosS[iField] > curpos )
+        {
+            break;
+        }
+        iField++;
+    }
+    if ( iField == m_arrPosS.size() )
+    {
+        //The cursor is at last field, or beyond it
+        return wxNOT_FOUND;
+    }
+
+    long pos = m_arrPosS[iField];
+    if ( GetFieldFlags(iField).GetAlignment() == wxALIGN_RIGHT )
+    {
+        while (pos <= m_arrPosF[iField] && CellIsEmpty(pos) )
+            pos++;
+    }
+
+    return pos;
+}
+
+//Move caret from current position to the foreseeable one.
+//In order this to work, alignment on fields values must be previously done.
+long wxMaskedEdit::MoveCaret(long curPos, bool toRight)
+{
+    long defPos = toRight ? curPos + 1 : curPos - 1;
+
+    //Check bounds
+    //not before the first cell of the first field
+    //not after the last cell of the last field
+    if ( defPos < m_arrPosS.front() || defPos > m_arrPosF.back() )
+    {
+        if (defPos < m_arrPosS.front())
+            defPos = m_arrPosS.front();
+        else
+            defPos = m_arrPosF.back() + 1; //last cell at left of caret
+
+        //Move the caret
+        GetTextEntry()->SetInsertionPoint(defPos);
+        return defPos;
+    }
+
+    //current field
+    int inField = FindField(curPos);
+
+    //All possible position/action cases
+    if ( inField != wxNOT_FOUND )
+    {
+        //Either define the new position or look for a new field
+        if ( GetFieldFlags((size_t)inField).GetAlignment() == wxALIGN_LEFT )
+        {
+            if ( toRight )
+            {
+                if ( CellIsEmpty (curPos) || curPos == m_arrPosF[(size_t)inField] )
+                {
+                    defPos = PosForFieldNext(curPos);
+                }
+                //else defPos already defined
+            }
+            else //towards left in a left aligned field
+            {
+                if ( curPos == m_arrPosS[(size_t)inField] )
+                {
+                    defPos = PosForFieldPrev(curPos);
+                }
+                else
+                {
+                    //case like "ab_|_"  move to "ab|__"
+                    //case like "_|___"  move to "|____"
+                    if ( CellIsEmpty(defPos) )
+                    {
+                        while (defPos >= m_arrPosS[(size_t)inField]
+                               && CellIsEmpty(defPos) )
+                        {
+                            defPos--;
+                        }
+                        defPos++;
+                    }
+                }
+            }
+        }
+
+        else //we are in a right aligned field
+        {
+            if ( !toRight )
+            {
+                if ( curPos == m_arrPosS[(size_t)inField] //at start
+                    || CellIsEmpty(defPos) ) //at left (still in field) is empty
+                {
+                    defPos = PosForFieldPrev(curPos);
+                }
+                //else defPos already defined
+            }
+            else //towards right in a right aligned field
+            {
+                //case like "_|__45"  move to "___|45"
+                //case like "_|____"  move to "_____|"
+                while (defPos <= m_arrPosF[(size_t)inField]
+                        && CellIsEmpty(defPos) )
+                    defPos++;
+            }
+        }
+    }
+
+    else // not in a field
+    {
+        defPos = toRight ? PosForFieldNext(curPos) : PosForFieldPrev(curPos);
+    }
+
+    //We have not found where to go
+    if ( defPos == wxNOT_FOUND )
+    {
+        return curPos; //don't move
+    }
+
+    //Move the caret
+    GetTextEntry()->SetInsertionPoint(defPos);
+
+    return defPos;
+}
+
+//Insert a char at an intended position. Returns false if insertion is not
+// possible (invalid char or no room available)
+//'pos' is replaced with the effective insertion point.
+bool wxMaskedEdit::InsertAtPos(wxChar iChar, long* pos, size_t index,
+                               wxString* inText)
+{
+    /* We are asked to insert 'iChar' character at '*pos' position in
+       field 'index'.
+
+       Insertion is made in the current position. It's field is properly
+       re-aligned. If the field was full, the char is still inserted, which
+       means that the rest of chars are right-shifted. If this shifting is not
+       possible (i.e. some char doesn't agree with the mask or there is no
+       room in the fields affected), then nothing is done.
+    */
+
+    if ( index == (size_t)wxNOT_FOUND )
+        return false;
+
+    long ePos = *pos;
+
+    //Because of 'HandleSelection()' we may be trying to insert 'x' in a
+    // current field value like "__|_ab__". The final result should be
+    // "x|ab____". The tricky part is the new caret position. We deal with
+    //it counting empty skipped cells.
+    size_t emptyCount = 0;
+
+    bool isLeftAlign = false;
+    if ( GetFieldFlags(index).GetAlignment() == wxALIGN_LEFT )
+        isLeftAlign = true;
+    for (long gpos = m_arrPosS[index]; gpos <= m_arrPosF[index]; gpos++)
+    {
+        if (isLeftAlign && gpos < ePos && CellIsEmpty(gpos) )
+            emptyCount++;
+        else if (!isLeftAlign && gpos >= ePos && CellIsEmpty(gpos) )
+            emptyCount++;
+    }
+    //The good position to insert the char in a field with all chars joined
+    ePos += isLeftAlign ? -emptyCount : emptyCount;
+
+    //The current filled cells
+    wxString fieldText = GetFieldOnText(index, *inText, '\0');
+
+    //find the place to insert at
+    if ( isLeftAlign )
+        ePos = ePos - m_arrPosS[index];
+    else
+        ePos = ePos - m_arrPosF[index] + fieldText.Len() - 1;
+
+    //set the char
+    fieldText.insert((size_t)ePos, 1, iChar);
+
+    //If the field is full, we will "push" a char to the next field.
+    wxChar pushedChar = '\0';
+
+    //Is shifting needed?
+    if ( (long)fieldText.Len() > m_arrPosF[index] - m_arrPosS[index] + 1 )
+    {
+        //Nowhere to push
+        if (index == GetFieldsCount() - 1)
+            return false;
+
+        pushedChar = fieldText.Last();
+        fieldText.RemoveLast();
+    }
+
+    //Setting the field also tests the char and does upper/lower conversion
+    wxString str = SetFieldOnText(index, fieldText, *inText);
+    if ( ! str.IsEmpty() )
+    {
+        //The real caret position where we have inserted
+        //We can not presume the caret is at a "good" position, because
+        // the user can click anywhere. But we know where we have inserted.
+        if ( !isLeftAlign )
+        {
+            //MoveCaret() will move it towards right. We want to stay here
+            *pos = ePos - fieldText.Len() + m_arrPosF[index] + 1;
+        }
+        else
+            *pos = ePos + m_arrPosS[index];
+    }
+
+    else
+        return false; //this char is not allowed here
+
+    //Shifting
+    if ( pushedChar == '\0' )
+    {
+        *inText = str;
+        return true;
+    }
+
+    index++;
+    while ( pushedChar != '\0' && index < GetFieldsCount() )
+    {
+        fieldText = GetFieldOnText(index, str, '\0');
+        fieldText.insert(0, 1, pushedChar);
+        if ( (long)fieldText.Len() > m_arrPosF[index] - m_arrPosS[index] + 1 )
+        {
+            //Nowhere to push
+            if (index == GetFieldsCount() - 1)
+                return false;
+
+            pushedChar = fieldText.Last();
+            fieldText.RemoveLast();
+        }
+        else
+            pushedChar = '\0';
+
+        str = SetFieldOnText(index, fieldText, wxString(str));
+        if ( str.IsEmpty() )
+            return false;
+
+        index++;
+    }
+
+    *inText = str;
+    return true;
+}
+
+//Process a char, coming from OnChar() or from DoPaste()
+//It may return false because the char is not allowed or because there is not
+// enough room for it.
+//It may return true because it is inserted, or because it means 'move the caret'
+bool wxMaskedEdit::ProcessChar(wxChar aChar, long* pos, wxString* inText, bool* changed)
+{
+    bool isProccesed = false;
+    long nPos = *pos;
+
+    //The field in which the char would be inserted.
+    size_t index = (size_t) GuessField(nPos);
+    if ( index == (size_t)wxNOT_FOUND && nPos < m_arrPosS.back() )
+    {
+        //We have one or more fields towards right.
+        //Test this char for coincidence with a literal at this position
+        if ( aChar == m_ExpMask[nPos] )
+        {
+            isProccesed = true;
+            //a position in next field
+            nPos = PosForFieldNext(nPos);
+            nPos--;
+        }
+    }
+
+    //The char must be valid before we insert it.
+    //caret pos may be just at right of a right aligned field, beyond the
+    // position where this field finishes. Instead, because the field is
+    // homogeneous, we can test the char against any position in the field.
+    if ( !isProccesed && index != (size_t)wxNOT_FOUND )
+    {
+        if ( TestChar(&aChar, m_arrPosF[index]) )
+        {
+            //Try to insert the char
+            if ( InsertAtPos(aChar, &nPos, index, inText) )
+            {
+                *changed = true;
+                isProccesed = true;
+            }
+        }
+
+        else
+        {
+            //If the char is the same as first char of next literal, this means
+            // that the user wants to move to next field
+            size_t nextLitPos = (size_t) m_arrPosF[index] + 1;
+            if ( nextLitPos < m_ExpMask.Len()
+                && m_maskIDs[nextLitPos] == mLiteral
+                && aChar == m_ExpMask[nextLitPos] )
+            {
+                nPos = nextLitPos;
+                isProccesed = true;
+            }
+        }
+    }
+
+    //Try inserting in next field
+    if ( !isProccesed
+        && index == (size_t)wxNOT_FOUND
+        && nPos < m_arrPosS.back() )
+    {
+        nPos = PosForFieldNext(nPos);
+        index = GuessField(nPos);
+        //Try to insert the char
+        if ( InsertAtPos(aChar, &nPos, index, inText) )
+        {
+            *changed = true;
+            isProccesed = true;
+        }
+    }
+
+    if ( isProccesed )
+        *pos = nPos;
+
+    return isProccesed;
+}
+
+//Cutting
+void wxMaskedEdit::DoCut()
+{
+    if ( ! GetTextEntry()->CanCut() )
+        return;
+
+    long selFrom, selTo;
+    GetTextEntry()->GetSelection(&selFrom, &selTo);
+
+    //Get the string to cut
+    wxString cutStr = ( GetTextEntry()->GetValue() )
+                   .substr((size_t)selFrom, (size_t)(selTo - selFrom));
+
+    //Pass it to the clipboard
+    if ( wxTheClipboard->Open() )
+    {
+        wxTheClipboard->SetData( new wxTextDataObject(cutStr) );
+        wxTheClipboard->Close();
+    }
+
+    //Update in our control
+    long pos = -1;
+    bool changed = false;
+    GetTextEntry()->SetValue( HandleSelection(&pos, &changed) );
+    if ( changed && pos >=  0 )
+        GetTextEntry()->SetInsertionPoint(pos);
+}
+
+//Pasting
+void wxMaskedEdit::DoPaste()
+{
+    if ( ! GetTextEntry()->CanPaste() )
+        return;
+
+    wxString pasteStr;
+    if (wxTheClipboard->Open())
+    {
+        if (wxTheClipboard->IsSupported( wxDF_TEXT ))
+        {
+            wxTextDataObject data;
+            wxTheClipboard->GetData( data );
+            pasteStr = data.GetText();
+        }
+        wxTheClipboard->Close();
+    }
+
+    if ( pasteStr.IsEmpty() )
+        return;
+
+    long pos = GetTextEntry()->GetInsertionPoint();
+    bool somethingProcessed = false;
+    //Backup copy. We'll restore it if this paste fails.
+    m_fillBck = m_filled;
+    //First handle the selection, if any
+    long selPos = -1; //changes if a selection erases anything
+    bool valueChanged = false;
+    //The whole control's value, changed after deleting the selection;
+    // and the new caret position.
+    wxString workString = HandleSelection(&selPos, &valueChanged);
+    if ( selPos != -1 )
+        pos = selPos;
+
+    //Insert char by char, as if they were typed
+    wxString::const_iterator iT = pasteStr.begin();
+    while ( iT != pasteStr.end() )
+    {
+        if ( ProcessChar(*iT, &pos, &workString, &valueChanged) )
+        {
+            somethingProcessed = true;
+            pos = MoveCaret(pos, true);
+            //new backup
+            m_fillBck = m_filled;
+        }
+
+        iT++;
+    }
+
+    //Some chars have been inserted and/or the caret has been moved
+    if ( somethingProcessed )
+    {
+        if ( valueChanged || selPos != -1)
+        {
+            GetTextEntry()->SetValue(workString);
+            GetTextEntry()->SetInsertionPoint(pos);
+        }
+    }
+    else //nothing was accepted. Nothing to change, not even the selection, if any
+    {
+        //restore
+        m_filled = m_fillBck;
+        //beep
+        DoBell();
+    }
+}
+
+//Set the proper string for SetValue/ChangeValue
+wxString wxMaskedEdit::SetMaskedValue(const wxString& value)
+{
+    //'value' is supposed to be well masked (i.e. with decorations)
+    //We make sure of it, and also test each char against the mask,
+    // and fill the 'typed cells' vector.
+
+    size_t pos = 0;
+    size_t maxLen = m_ExpMask.Len();
+    wxString maskedValue('\0', maxLen);
+
+    wxString::const_iterator iV = value.begin();
+    wxString::const_iterator iM = m_ExpMask.begin() + pos;
+    wxString::iterator iMV = maskedValue.begin() + pos;
+    wxChar ch = '\0';
+
+    while (pos < maxLen)
+    {
+        if ( m_maskIDs[pos] == mLiteral )
+        {
+            *iMV = *iM;
+            m_filled[pos] = false;
+        }
+
+        else
+        {
+            ch = '\0';
+
+            if ( iV != value.end() )
+                ch = *iV;
+
+            if ( !TestChar(&ch, (long)pos) )
+            {
+                //This char is not allowed. Use fillChar instead
+                size_t index = FindField((long)pos);
+                ch = GetFieldFlags(index).GetFillChar();
+                m_filled[pos] = false;
+            }
+            else
+                m_filled[pos] = true;
+
+            *iMV = ch;
+        }
+
+        pos++;
+        ++iMV;
+        ++iM;
+        if ( iV != value.end() )
+            ++iV;
+    }
+
+    //Make sure all fields are aligned, and all chars in proper upper/lower case
+    for (size_t index = 0; index < GetFieldsCount(); index++)
+        NormalizeField(index, &maskedValue);
+
+    return maskedValue;
+}
+
+//Show the colours
+void wxMaskedEdit::UseColours(int whatColours)
+{
+    if (whatColours == mEmColour)
+    {
+        msk_control->SetBackgroundColour(m_params.colours.colEmBackgn);
+        msk_control->SetForegroundColour(m_params.colours.colEmForegn);
+    }
+
+    else if (whatColours == mOKColour)
+    {
+        msk_control->SetBackgroundColour(m_params.colours.colOKBackgn);
+        msk_control->SetForegroundColour(m_params.colours.colOKForegn);
+    }
+
+    else
+    {
+        msk_control->SetBackgroundColour(m_params.colours.colWrBackgn);
+        msk_control->SetForegroundColour(m_params.colours.colWrForegn);
+    }
+
+    msk_control->Refresh();
+}
+
+
+// ---------------------------------------------------------------------------
+// -  -  -  -  -  -  -  - General Test Functions -  -  -  -  -  -  -  -  -
+
+//Character vs mask commands. 'pos' is the cursor position, which corresponds
+// to expanded mask position.
+//We don't do forced upper/lower conversion here. Should be done before this.
+//Note these wxIsxxx functions work with current locale.
+bool wxMaskedEdit::CharAgreesWithMask(wxChar testChar, long pos) const
+{
+    switch ( GetMaskedType( (size_t)pos ) )
+    {
+        case mDigitReq :
+        case mDigitOpt :
+            return wxIsdigit( testChar );
+        case mAlphaReq :
+        case mAlphaReq + mUppChar :
+        case mAlphaReq + mLowChar :
+        case mAlphaOpt :
+        case mAlphaOpt + mUppChar :
+        case mAlphaOpt + mLowChar :
+            return wxIsalpha( testChar );
+        case mAlpNumReq :
+        case mAlpNumReq + mUppChar :
+        case mAlpNumReq + mLowChar :
+        case mAlpNumOpt :
+        case mAlpNumOpt + mUppChar :
+        case mAlpNumOpt + mLowChar :
+            return wxIsalnum( testChar );
+        case mAnyCharReq :
+        case mAnyCharReq + mUppChar :
+        case mAnyCharReq + mLowChar :
+        case mAnyCharOpt :
+        case mAnyCharOpt + mUppChar :
+        case mAnyCharOpt + mLowChar :
+            return wxIsprint ( testChar ); //space allowed
+        case mHexReq :
+        case mHexReq + mUppChar :
+        case mHexReq + mLowChar :
+        case mHexOpt :
+        case mHexOpt + mUppChar :
+        case mHexOpt + mLowChar :
+            return wxIsxdigit( testChar );
+
+        default :
+            return false;
+    }
+}
+
+//Return the char converted to upper/lower case according with the mask
+wxChar wxMaskedEdit::ToUppLowCase(wxChar ch, size_t pos)
+{
+    int mktype = GetMaskedType( pos );
+    //Forced uppercase types are normal + mUppChar
+    //Forced lowercase types are normal + mLowChar
+    if ( mktype > mUppChar && mktype < mLowChar )
+    {
+        return wxToupper( ch );
+    }
+    else if ( mktype > mLowChar )
+    {
+        return wxTolower( ch );
+    }
+    return ch;
+}
+
+//Test the character.
+//'tryChar' is received from EVT_CHAR, SetPlainValue, SetFieldValue, etc.
+//We change it to upper/lower if mask tells it so and it is accepted.
+bool wxMaskedEdit::TestChar(wxChar* tryChar, long pos)
+{
+    int index = FindField( pos );
+    if ( index == wxNOT_FOUND )
+    {
+        //The cursor is not in a field.
+        return false;
+    }
+
+    //Null char is never allowed
+    if ( *tryChar == '\0' )
+        return false;
+
+    //If it is the char we use to fill empty cells, don't allow it
+    //Not doing so will make m_filled[] really wrong.
+    if ( *tryChar == GetFieldFlags((size_t)index).GetFillChar() )
+        return false;
+
+    //TODO: Other test
+    //allowed / excluded chars
+
+    //Convert it upper/lower case, if demanded
+    wxChar candidateChar = ToUppLowCase(*tryChar, (size_t) pos );
+
+    //Does this char match the mask?
+    if ( CharAgreesWithMask(candidateChar, pos) )
+    {
+        *tryChar = candidateChar;
+        return true;
+    }
+
+    return false;
+}
+
+//Tell if field passed all of its tests
+long wxMaskedEdit::IsFieldValid(size_t index) const
+{
+    //TODO: choices validation
+
+    //We have already done TestChar() for every char, so we know they agree
+    // with the mask, and other tests.
+    //We check here whether all required chars are in their cells.
+    for (long i = m_arrPosS[index]; i <= m_arrPosF[index] ; i++)
+    {
+        int masktype = m_maskIDs[(size_t)i];
+        //remove upper/lower forced
+        if (masktype > mUppChar)
+            masktype -= mUppChar;
+        if (masktype > mLowChar)
+            masktype -= mLowChar;
+        //check
+        if ( ( masktype == mDigitReq || masktype == mAlphaReq
+            || masktype == mAlpNumReq || masktype == mAnyCharReq
+            || masktype == mHexReq ) && !m_filled[(size_t)i] )
+        {
+            return i - m_arrPosS[index]; //error position
+        }
+    }
+
+    //Validation function for this field, if any
+    wxMaskedFieldFunc *fn = m_params.fieldsFuncs[index];
+    if ( fn )
+        return fn(this, index, m_params.fieldFuncsParams[index]);
+
+    return -1;
+}
+
+//Check fields and the whole control's value
+long wxMaskedEdit::IsValid()
+{
+    //Don't do validation if we have no fields at all
+    size_t nuFields = GetFieldsCount();
+    if ( nuFields < 1 )
+        return 0;
+
+    //Test all fields
+    for (size_t i = 0; i < nuFields; i++)
+    {
+        long res = IsFieldValid(i);
+        if ( res >= 0 )
+            return res + m_arrPosS[i];
+    }
+
+    //Test the whole value
+    if ( m_params.controlFunc )
+        return m_params.controlFunc(this, m_params.controlFuncParams);
+
+    return -1;
+}
+
+
+// ---------------------------------------------------------------------------
+// -  -  -  -  -  -  -  - Predefined Test Functions -  -  -  -  -  -  -  -  -
+
+//If we want to set the cursor in the position where an error is found, we
+//return this position. Returning '-1' means that no error has been found.
+
+//Range check. we handle two cases: allow only inside the range or outside it.
+long wxMaskedRangeCheck(const wxMaskedEdit* caller, size_t index, void* params)
+{
+    if ( !params )
+        return 0;
+
+    wxRangeParams *rparms = (wxRangeParams*) params;
+    long vmin = rparms->rmin;
+    long vmax = rparms->rmax;
+    int base = (rparms->base >= 0 && rparms->base < 37) ? rparms->base : 10;
+
+    //Current field value
+    wxString sval = caller->GetFieldValue(index);
+    long val;
+    if ( !sval.ToCLong(&val, base) )
+        return 0; //beginning position in this field
+
+    if (//Normal case: test vmin <= val <= vmax
+        ( vmin <= vmax && vmin <= val && val <= vmax )
+        || //Excluded range
+        ( vmin > vmax && (val < vmin || val > vmax) ) )
+    {
+        return -1;
+    }
+
+    //value not in range
+    return 0;
+}
+
+//Date check
+long wxMaskedDateShort(const wxMaskedEdit* caller, void* params)
+{
+    wxDateParams *dparams = (wxDateParams*) params;
+    //Get data
+    wxString str = caller->GetFieldValue(dparams->dayField);
+    long day, month, year;
+    if ( !str.ToCLong(&day) )
+        return 0;
+    str = caller->GetFieldValue(dparams->monthField);
+    if ( !str.ToCLong(&month) )
+        return 0;
+    str = caller->GetFieldValue(dparams->yearField);
+    if ( !str.ToCLong(&year) )
+        return 0;
+
+    //Test day and month
+    if ( (day > 31 || day < 1 || month > 12 || month < 1)
+        || ((month == 4 || month == 6 || month == 9 || month == 11) && day > 31)
+        || ( month == 2 && day > 29) )
+    {
+        return 0;
+    }
+
+    //Test leap year
+    if ( day == 29 && month == 2
+        && !(year % 400 == 0 || ((year % 4) == 0 && (year % 100) > 0) ) )
+    {
+        return 0;
+    }
+
+    //OK
+    return -1;
+}
+
+#endif // wxUSE_MASKED_EDIT
+

Index: tests/test.bkl
===================================================================
--- tests/test.bkl	(revisión: 72260)
+++ tests/test.bkl	(copia de trabajo)
@@ -164,6 +164,7 @@
             controls/listctrltest.cpp
             controls/listviewtest.cpp
             controls/markuptest.cpp
+            controls/maskededittest.cpp
             controls/notebooktest.cpp
             controls/ownerdrawncomboboxtest.cpp
             controls/pickerbasetest.cpp

Index: tests/controls/maskededittest.cpp
===================================================================
--- tests/controls/maskededittest.cpp	(revisión: 0)
+++ tests/controls/maskededittest.cpp	(revisión: 0)
@@ -0,0 +1,127 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        tests/controls/maskededittest.cpp
+// Purpose:     wxMaskedEdit controls unit test
+// Author:      Manuel Martin
+// Created:     2012-07-30
+// RCS-ID:      $Id:
+// Copyright:   (c)
+///////////////////////////////////////////////////////////////////////////////
+
+#include "testprec.h"
+
+#if wxUSE_MASKED_EDIT
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#ifndef WX_PRECOMP
+    #include "wx/app.h"
+#endif // WX_PRECOMP
+
+#include "wx/maskededit.h"
+
+#include "testableframe.h"
+#include "wx/uiaction.h"
+
+class MaskedEditTestCase : public CppUnit::TestCase
+{
+public:
+    MaskedEditTestCase() { }
+
+    void setUp();
+    void tearDown();
+
+private:
+    CPPUNIT_TEST_SUITE( MaskedEditTestCase );
+        CPPUNIT_TEST( TestSet );
+        WXUISIM_TEST( TestUI );
+        CPPUNIT_TEST( TestFunc );
+  CPPUNIT_TEST_SUITE_END();
+
+    void TestSet();
+#if wxUSE_UIACTIONSIMULATOR
+    void TestUI();
+#endif
+    void TestFunc();
+
+    wxMaskedEditText* m_editTx;
+
+    DECLARE_NO_COPY_CLASS(MaskedEditTestCase)
+};
+
+// register in the unnamed registry so that these tests are run by default
+CPPUNIT_TEST_SUITE_REGISTRATION( MaskedEditTestCase );
+
+// also include in its own registry so that these tests can be run alone
+CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( MaskedEditTestCase, "MaskedEditTestCase" );
+
+void MaskedEditTestCase::setUp()
+{
+    m_editTx = new wxMaskedEditText(wxTheApp->GetTopWindow(), wxID_ANY);
+}
+
+void MaskedEditTestCase::tearDown()
+{
+    wxTheApp->GetTopWindow()->DestroyChildren();
+}
+
+void MaskedEditTestCase::TestSet()
+{
+    m_editTx->SetMask("=a>A^-###++xx.#{4}");
+    // test empty value
+    CPPUNIT_ASSERT_EQUAL( "=  -   ++  .    ", m_editTx->GetValue() );
+
+    m_editTx->SetValue("=bc- 12++  .9876");
+    // 'c' should be changed to 'C' and '12' should be left re-aligned
+    CPPUNIT_ASSERT_EQUAL( "=bC-12 ++  .9876", m_editTx->GetValue() );
+
+    m_editTx->SetFieldFlags(3, wxEditFieldFlags(wxALIGN_RIGHT));
+    m_editTx->SetPlainValue("fg56");
+    m_editTx->SetFieldValue(3, "987");
+    CPPUNIT_ASSERT_EQUAL( "=fG-56 ++  . 987", m_editTx->GetValue() );
+}
+
+#if wxUSE_UIACTIONSIMULATOR
+void MaskedEditTestCase::TestUI()
+{
+    wxUIActionSimulator sim;
+
+    m_editTx->SetFocus();
+    sim.Char(WXK_END);
+    sim.Char(WXK_BACK);
+    wxYield();
+    CPPUNIT_ASSERT_EQUAL( "=fG-56 ++  .  98", m_editTx->GetValue() );
+
+    sim.Char(WXK_LEFT);
+    sim.Char(WXK_LEFT);
+    sim.Char('d');
+    wxYield();
+    CPPUNIT_ASSERT_EQUAL( "=fG-56 ++d .  98", m_editTx->GetValue() );
+
+    m_editTx->SetInsertionPoint(6);
+    sim.Char(WXK_RIGHT);
+    sim.Char('2');
+    wxYield();
+    CPPUNIT_ASSERT_EQUAL( "=fG-56 ++2d.  98", m_editTx->GetValue() );
+}
+#endif
+
+
+void MaskedEditTestCase::TestFunc()
+{
+    // Should fail because not all fields have all required chars
+    CPPUNIT_ASSERT( !m_editTx->IsValid() );
+
+    m_editTx->ChangeValue("=aB-123++  .5670");
+    CPPUNIT_ASSERT( m_editTx->IsValid() );
+
+    wxRangeParams parms;
+    parms.rmin = 70;
+    parms.rmax = 100;
+    m_editTx->SetFieldFunction(1, &wxMaskedRangeCheck, &parms);
+    // Should fail because 123 > 100
+    CPPUNIT_ASSERT( !m_editTx->IsValid() );
+}
+
+#endif // wxUSE_MASKED_EDIT

