Index: src/common/imagjpeg.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/common/imagjpeg.cpp,v
retrieving revision 1.47.2.1
diff --unified -r1.47.2.1 imagjpeg.cpp
--- src/common/imagjpeg.cpp	2006/04/02 01:27:36	1.47.2.1
+++ src/common/imagjpeg.cpp	2006/11/30 11:55:15
@@ -28,14 +28,20 @@
 #include "wx/log.h"
 #include "wx/app.h"
 
-// NB: Some compilers define boolean type in Windows headers
-//     (e.g. Watcom C++, but not Open Watcom).
-//     This causes a conflict with jmorecfg.h header from libjpeg, so we have
-//     to make sure libjpeg won't try to define boolean itself. This is done by
-//     defining HAVE_BOOLEAN.
-#if defined(__WXMSW__) && (defined(__MWERKS__) || defined(__DIGITALMARS__) || (defined(__WATCOMC__) && __WATCOMC__ < 1200))
+// A hack based on one from tif_jpeg.c to overcome the problem on Windows
+// of rpcndr.h defining boolean with a different type to the jpeg headers.
+// 
+// This hack is only necessary for an external jpeg library, the builtin one
+// usually used on Windows doesn't use the type boolean, so always works.
+//
+#if defined wxHACK_BOOLEAN || defined __RPCNDR_H__ || defined __WINE_RPCNDR_H
     #define HAVE_BOOLEAN
-    #include "wx/msw/wrapwin.h"
+
+    #ifdef wxHACK_BOOLEAN
+        #define boolean wxHACK_BOOLEAN
+    #else
+        #define boolean int
+    #endif
 #endif
 
 extern "C"
@@ -46,6 +52,10 @@
     #include "jpeglib.h"
 }
 
+#ifndef HAVE_WXJPEG_BOOLEAN
+typedef boolean wxjpeg_boolean;
+#endif
+
 #include "wx/filefn.h"
 #include "wx/wfstream.h"
 #include "wx/intl.h"
@@ -103,7 +113,7 @@
 {
 }
 
-CPP_METHODDEF(boolean) wx_fill_input_buffer ( j_decompress_ptr cinfo )
+CPP_METHODDEF(wxjpeg_boolean) wx_fill_input_buffer ( j_decompress_ptr cinfo )
 {
     wx_src_ptr src = (wx_src_ptr) cinfo->src;
 
@@ -291,7 +301,7 @@
     dest->pub.free_in_buffer = OUTPUT_BUF_SIZE;
 }
 
-CPP_METHODDEF(boolean) wx_empty_output_buffer (j_compress_ptr cinfo)
+CPP_METHODDEF(wxjpeg_boolean) wx_empty_output_buffer (j_compress_ptr cinfo)
 {
     wx_dest_ptr dest = (wx_dest_ptr) cinfo->dest;
 
Index: src/jpeg/jcapimin.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jcapimin.c,v
retrieving revision 1.1
retrieving revision 1.2
diff --unified -r1.1 -r1.2
--- src/jpeg/jcapimin.c	1999/04/17 17:53:59	1.1
+++ src/jpeg/jcapimin.c	2006/11/28 16:24:39	1.2
@@ -116,7 +116,7 @@
  */
 
 GLOBAL(void)
-jpeg_suppress_tables (j_compress_ptr cinfo, boolean suppress)
+jpeg_suppress_tables (j_compress_ptr cinfo, wxjpeg_boolean suppress)
 {
   int i;
   JQUANT_TBL * qtbl;
Index: src/jpeg/jcapistd.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jcapistd.c,v
retrieving revision 1.1
retrieving revision 1.2
diff --unified -r1.1 -r1.2
--- src/jpeg/jcapistd.c	1999/04/17 17:53:59	1.1
+++ src/jpeg/jcapistd.c	2006/11/28 16:24:39	1.2
@@ -35,7 +35,7 @@
  */
 
 GLOBAL(void)
-jpeg_start_compress (j_compress_ptr cinfo, boolean write_all_tables)
+jpeg_start_compress (j_compress_ptr cinfo, wxjpeg_boolean write_all_tables)
 {
   if (cinfo->global_state != CSTATE_START)
     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
Index: src/jpeg/jccoefct.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jccoefct.c,v
retrieving revision 1.1
retrieving revision 1.2
diff --unified -r1.1 -r1.2
--- src/jpeg/jccoefct.c	1999/04/17 17:53:59	1.1
+++ src/jpeg/jccoefct.c	2006/11/28 16:24:40	1.2
@@ -58,12 +58,12 @@
 
 
 /* Forward declarations */
-METHODDEF(boolean) compress_data
+METHODDEF(wxjpeg_boolean) compress_data
     JPP((j_compress_ptr cinfo, JSAMPIMAGE input_buf));
 #ifdef FULL_COEF_BUFFER_SUPPORTED
-METHODDEF(boolean) compress_first_pass
+METHODDEF(wxjpeg_boolean) compress_first_pass
     JPP((j_compress_ptr cinfo, JSAMPIMAGE input_buf));
-METHODDEF(boolean) compress_output
+METHODDEF(wxjpeg_boolean) compress_output
     JPP((j_compress_ptr cinfo, JSAMPIMAGE input_buf));
 #endif
 
@@ -139,7 +139,7 @@
  * which we index according to the component's SOF position.
  */
 
-METHODDEF(boolean)
+METHODDEF(wxjpeg_boolean)
 compress_data (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
 {
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
@@ -241,7 +241,7 @@
  * at the scan-dependent variables (MCU dimensions, etc).
  */
 
-METHODDEF(boolean)
+METHODDEF(wxjpeg_boolean)
 compress_first_pass (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
 {
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
@@ -337,7 +337,7 @@
  * NB: input_buf is ignored; it is likely to be a NULL pointer.
  */
 
-METHODDEF(boolean)
+METHODDEF(wxjpeg_boolean)
 compress_output (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
 {
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
@@ -402,7 +402,7 @@
  */
 
 GLOBAL(void)
-jinit_c_coef_controller (j_compress_ptr cinfo, boolean need_full_buffer)
+jinit_c_coef_controller (j_compress_ptr cinfo, wxjpeg_boolean need_full_buffer)
 {
   my_coef_ptr coef;
 
Index: src/jpeg/jchuff.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jchuff.c,v
retrieving revision 1.2
retrieving revision 1.3
diff --unified -r1.2 -r1.3
--- src/jpeg/jchuff.c	2002/05/26 11:49:37	1.2
+++ src/jpeg/jchuff.c	2006/11/28 16:24:40	1.3
@@ -86,11 +86,11 @@
 
 
 /* Forward declarations */
-METHODDEF(boolean) encode_mcu_huff JPP((j_compress_ptr cinfo,
+METHODDEF(wxjpeg_boolean) encode_mcu_huff JPP((j_compress_ptr cinfo,
 					JBLOCKROW *MCU_data));
 METHODDEF(void) finish_pass_huff JPP((j_compress_ptr cinfo));
 #ifdef ENTROPY_OPT_SUPPORTED
-METHODDEF(boolean) encode_mcu_gather JPP((j_compress_ptr cinfo,
+METHODDEF(wxjpeg_boolean) encode_mcu_gather JPP((j_compress_ptr cinfo,
 					  JBLOCKROW *MCU_data));
 METHODDEF(void) finish_pass_gather JPP((j_compress_ptr cinfo));
 #endif
@@ -103,7 +103,7 @@
  */
 
 METHODDEF(void)
-start_pass_huff (j_compress_ptr cinfo, boolean gather_statistics)
+start_pass_huff (j_compress_ptr cinfo, wxjpeg_boolean gather_statistics)
 {
   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   int ci, dctbl, actbl;
@@ -176,7 +176,7 @@
  */
 
 GLOBAL(void)
-jpeg_make_c_derived_tbl (j_compress_ptr cinfo, boolean isDC, int tblno,
+jpeg_make_c_derived_tbl (j_compress_ptr cinfo, wxjpeg_boolean isDC, int tblno,
 			 c_derived_tbl ** pdtbl)
 {
   JHUFF_TBL *htbl;
@@ -274,7 +274,7 @@
 	      { action; } }
 
 
-LOCAL(boolean)
+LOCAL(wxjpeg_boolean)
 dump_buffer (working_state * state)
 /* Empty the output buffer; return TRUE if successful, FALSE if must suspend */
 {
@@ -298,7 +298,7 @@
  */
 
 INLINE
-LOCAL(boolean)
+LOCAL(wxjpeg_boolean)
 emit_bits (working_state * state, unsigned int code, int size)
 /* Emit some bits; return TRUE if successful, FALSE if must suspend */
 {
@@ -336,7 +336,7 @@
 }
 
 
-LOCAL(boolean)
+LOCAL(wxjpeg_boolean)
 flush_bits (working_state * state)
 {
   if (! emit_bits(state, 0x7F, 7)) /* fill any partial byte with ones */
@@ -349,7 +349,7 @@
 
 /* Encode a single block's worth of coefficients */
 
-LOCAL(boolean)
+LOCAL(wxjpeg_boolean)
 encode_one_block (working_state * state, JCOEFPTR block, int last_dc_val,
 		  c_derived_tbl *dctbl, c_derived_tbl *actbl)
 {
@@ -447,7 +447,7 @@
  * Emit a restart marker & resynchronize predictions.
  */
 
-LOCAL(boolean)
+LOCAL(wxjpeg_boolean)
 emit_restart (working_state * state, int restart_num)
 {
   int ci;
@@ -472,7 +472,7 @@
  * Encode and output one MCU's worth of Huffman-compressed coefficients.
  */
 
-METHODDEF(boolean)
+METHODDEF(wxjpeg_boolean)
 encode_mcu_huff (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
 {
   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
@@ -641,7 +641,7 @@
  * No data is actually output, so no suspension return is possible.
  */
 
-METHODDEF(boolean)
+METHODDEF(wxjpeg_boolean)
 encode_mcu_gather (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
 {
   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
@@ -849,8 +849,8 @@
   int ci, dctbl, actbl;
   jpeg_component_info * compptr;
   JHUFF_TBL **htblptr;
-  boolean did_dc[NUM_HUFF_TBLS];
-  boolean did_ac[NUM_HUFF_TBLS];
+  wxjpeg_boolean did_dc[NUM_HUFF_TBLS];
+  wxjpeg_boolean did_ac[NUM_HUFF_TBLS];
 
   /* It's important not to apply jpeg_gen_optimal_table more than once
    * per table, because it clobbers the input frequency counts!
Index: src/jpeg/jchuff.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jchuff.h,v
retrieving revision 1.1
retrieving revision 1.2
diff --unified -r1.1 -r1.2
--- src/jpeg/jchuff.h	1999/04/17 17:54:00	1.1
+++ src/jpeg/jchuff.h	2006/11/28 16:24:40	1.2
@@ -39,7 +39,7 @@
 
 /* Expand a Huffman table definition into the derived format */
 EXTERN(void) jpeg_make_c_derived_tbl
-	JPP((j_compress_ptr cinfo, boolean isDC, int tblno,
+	JPP((j_compress_ptr cinfo, wxjpeg_boolean isDC, int tblno,
 	     c_derived_tbl ** pdtbl));
 
 /* Generate an optimal table definition given the specified counts */
Index: src/jpeg/jcinit.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jcinit.c,v
retrieving revision 1.1
retrieving revision 1.2
diff --unified -r1.1 -r1.2
--- src/jpeg/jcinit.c	1999/04/17 17:54:00	1.1
+++ src/jpeg/jcinit.c	2006/11/28 16:24:40	1.2
@@ -56,7 +56,7 @@
 
   /* Need a full-image coefficient buffer in any multi-pass mode. */
   jinit_c_coef_controller(cinfo,
-		(boolean) (cinfo->num_scans > 1 || cinfo->optimize_coding));
+		(wxjpeg_boolean) (cinfo->num_scans > 1 || cinfo->optimize_coding));
   jinit_c_main_controller(cinfo, FALSE /* never need full buffer here */);
 
   jinit_marker_writer(cinfo);
Index: src/jpeg/jcmainct.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jcmainct.c,v
retrieving revision 1.2
retrieving revision 1.3
diff --unified -r1.2 -r1.3
--- src/jpeg/jcmainct.c	2002/05/14 11:33:24	1.2
+++ src/jpeg/jcmainct.c	2006/11/28 16:24:40	1.3
@@ -30,7 +30,7 @@
 
   JDIMENSION cur_iMCU_row;	/* number of current iMCU row */
   JDIMENSION rowgroup_ctr;	/* counts row groups received in iMCU row */
-  boolean suspended;		/* remember if we suspended output */
+  wxjpeg_boolean suspended;		/* remember if we suspended output */
   J_BUF_MODE pass_mode;		/* current operating mode */
 
   /* If using just a strip buffer, this points to the entire set of buffers
@@ -173,7 +173,7 @@
   my_main_ptr mymain = (my_main_ptr) cinfo->main;
   int ci;
   jpeg_component_info *compptr;
-  boolean writing = (mymain->pass_mode != JBUF_CRANK_DEST);
+  wxjpeg_boolean writing = (mymain->pass_mode != JBUF_CRANK_DEST);
 
   while (mymain->cur_iMCU_row < cinfo->total_iMCU_rows) {
     /* Realign the virtual buffers if at the start of an iMCU row. */
@@ -242,7 +242,7 @@
  */
 
 GLOBAL(void)
-jinit_c_main_controller (j_compress_ptr cinfo, boolean need_full_buffer)
+jinit_c_main_controller (j_compress_ptr cinfo, wxjpeg_boolean need_full_buffer)
 {
   my_main_ptr mymain;
   int ci;
Index: src/jpeg/jcmarker.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jcmarker.c,v
retrieving revision 1.1
retrieving revision 1.2
diff --unified -r1.1 -r1.2
--- src/jpeg/jcmarker.c	1999/04/17 17:54:01	1.1
+++ src/jpeg/jcmarker.c	2006/11/28 16:24:40	1.2
@@ -181,7 +181,7 @@
 
 
 LOCAL(void)
-emit_dht (j_compress_ptr cinfo, int index, boolean is_ac)
+emit_dht (j_compress_ptr cinfo, int index, wxjpeg_boolean is_ac)
 /* Emit a DHT marker */
 {
   JHUFF_TBL * htbl;
@@ -494,7 +494,7 @@
 write_frame_header (j_compress_ptr cinfo)
 {
   int ci, prec;
-  boolean is_baseline;
+  wxjpeg_boolean is_baseline;
   jpeg_component_info *compptr;
   
   /* Emit DQT for each quantization table.
Index: src/jpeg/jcmaster.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jcmaster.c,v
retrieving revision 1.1
retrieving revision 1.2
diff --unified -r1.1 -r1.2
--- src/jpeg/jcmaster.c	1999/04/17 17:54:01	1.1
+++ src/jpeg/jcmaster.c	2006/11/28 16:24:40	1.2
@@ -135,7 +135,7 @@
   const jpeg_scan_info * scanptr;
   int scanno, ncomps, ci, coefi, thisi;
   int Ss, Se, Ah, Al;
-  boolean component_sent[MAX_COMPONENTS];
+  wxjpeg_boolean component_sent[MAX_COMPONENTS];
 #ifdef C_PROGRESSIVE_SUPPORTED
   int * last_bitpos_ptr;
   int last_bitpos[MAX_COMPONENTS][DCTSIZE2];
@@ -540,7 +540,7 @@
  */
 
 GLOBAL(void)
-jinit_c_master_control (j_compress_ptr cinfo, boolean transcode_only)
+jinit_c_master_control (j_compress_ptr cinfo, wxjpeg_boolean transcode_only)
 {
   my_master_ptr master;
 
Index: src/jpeg/jcparam.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jcparam.c,v
retrieving revision 1.1
retrieving revision 1.2
diff --unified -r1.1 -r1.2
--- src/jpeg/jcparam.c	1999/04/17 17:54:01	1.1
+++ src/jpeg/jcparam.c	2006/11/28 16:24:41	1.2
@@ -22,7 +22,7 @@
 GLOBAL(void)
 jpeg_add_quant_table (j_compress_ptr cinfo, int which_tbl,
 		      const unsigned int *basic_table,
-		      int scale_factor, boolean force_baseline)
+		      int scale_factor, wxjpeg_boolean force_baseline)
 /* Define a quantization table equal to the basic_table times
  * a scale factor (given as a percentage).
  * If force_baseline is TRUE, the computed quantization table entries
@@ -62,7 +62,7 @@
 
 GLOBAL(void)
 jpeg_set_linear_quality (j_compress_ptr cinfo, int scale_factor,
-			 boolean force_baseline)
+			 wxjpeg_boolean force_baseline)
 /* Set or change the 'quality' (quantization) setting, using default tables
  * and a straight percentage-scaling quality scale.  In most cases it's better
  * to use jpeg_set_quality (below); this entry point is provided for
@@ -129,7 +129,7 @@
 
 
 GLOBAL(void)
-jpeg_set_quality (j_compress_ptr cinfo, int quality, boolean force_baseline)
+jpeg_set_quality (j_compress_ptr cinfo, int quality, wxjpeg_boolean force_baseline)
 /* Set or change the 'quality' (quantization) setting, using default tables.
  * This is the standard quality-adjusting entry point for typical user
  * interfaces; only those who want detailed control over quantization tables
Index: src/jpeg/jcphuff.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jcphuff.c,v
retrieving revision 1.2
retrieving revision 1.3
diff --unified -r1.2 -r1.3
--- src/jpeg/jcphuff.c	2002/05/26 11:49:37	1.2
+++ src/jpeg/jcphuff.c	2006/11/28 16:24:41	1.3
@@ -25,7 +25,7 @@
   struct jpeg_entropy_encoder pub; /* public fields */
 
   /* Mode flag: TRUE for optimization, FALSE for actual data output */
-  boolean gather_statistics;
+  wxjpeg_boolean gather_statistics;
 
   /* Bit-level coding status.
    * next_output_byte/free_in_buffer are local copies of cinfo->dest fields.
@@ -86,13 +86,13 @@
 #endif
 
 /* Forward declarations */
-METHODDEF(boolean) encode_mcu_DC_first JPP((j_compress_ptr cinfo,
+METHODDEF(wxjpeg_boolean) encode_mcu_DC_first JPP((j_compress_ptr cinfo,
 					    JBLOCKROW *MCU_data));
-METHODDEF(boolean) encode_mcu_AC_first JPP((j_compress_ptr cinfo,
+METHODDEF(wxjpeg_boolean) encode_mcu_AC_first JPP((j_compress_ptr cinfo,
 					    JBLOCKROW *MCU_data));
-METHODDEF(boolean) encode_mcu_DC_refine JPP((j_compress_ptr cinfo,
+METHODDEF(wxjpeg_boolean) encode_mcu_DC_refine JPP((j_compress_ptr cinfo,
 					     JBLOCKROW *MCU_data));
-METHODDEF(boolean) encode_mcu_AC_refine JPP((j_compress_ptr cinfo,
+METHODDEF(wxjpeg_boolean) encode_mcu_AC_refine JPP((j_compress_ptr cinfo,
 					     JBLOCKROW *MCU_data));
 METHODDEF(void) finish_pass_phuff JPP((j_compress_ptr cinfo));
 METHODDEF(void) finish_pass_gather_phuff JPP((j_compress_ptr cinfo));
@@ -103,10 +103,10 @@
  */
 
 METHODDEF(void)
-start_pass_phuff (j_compress_ptr cinfo, boolean gather_statistics)
+start_pass_phuff (j_compress_ptr cinfo, wxjpeg_boolean gather_statistics)
 {  
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
-  boolean is_DC_band;
+  wxjpeg_boolean is_DC_band;
   int ci, tbl;
   jpeg_component_info * compptr;
 
@@ -373,7 +373,7 @@
  * or first pass of successive approximation).
  */
 
-METHODDEF(boolean)
+METHODDEF(wxjpeg_boolean)
 encode_mcu_DC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
 {
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
@@ -460,7 +460,7 @@
  * or first pass of successive approximation).
  */
 
-METHODDEF(boolean)
+METHODDEF(wxjpeg_boolean)
 encode_mcu_AC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
 {
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
@@ -567,7 +567,7 @@
  * is not very clear on the point.
  */
 
-METHODDEF(boolean)
+METHODDEF(wxjpeg_boolean)
 encode_mcu_DC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
 {
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
@@ -614,7 +614,7 @@
  * MCU encoding for AC successive approximation refinement scan.
  */
 
-METHODDEF(boolean)
+METHODDEF(wxjpeg_boolean)
 encode_mcu_AC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
 {
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
@@ -767,11 +767,11 @@
 finish_pass_gather_phuff (j_compress_ptr cinfo)
 {
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
-  boolean is_DC_band;
+  wxjpeg_boolean is_DC_band;
   int ci, tbl;
   jpeg_component_info * compptr;
   JHUFF_TBL **htblptr;
-  boolean did[NUM_HUFF_TBLS];
+  wxjpeg_boolean did[NUM_HUFF_TBLS];
 
   /* Flush out buffered data (all we care about is counting the EOB symbol) */
   emit_eobrun(entropy);
Index: src/jpeg/jcprepct.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jcprepct.c,v
retrieving revision 1.1
retrieving revision 1.2
diff --unified -r1.1 -r1.2
--- src/jpeg/jcprepct.c	1999/04/17 17:54:01	1.1
+++ src/jpeg/jcprepct.c	2006/11/28 16:24:41	1.2
@@ -312,7 +312,7 @@
  */
 
 GLOBAL(void)
-jinit_c_prep_controller (j_compress_ptr cinfo, boolean need_full_buffer)
+jinit_c_prep_controller (j_compress_ptr cinfo, wxjpeg_boolean need_full_buffer)
 {
   my_prep_ptr prep;
   int ci;
Index: src/jpeg/jcsample.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jcsample.c,v
retrieving revision 1.2
retrieving revision 1.3
diff --unified -r1.2 -r1.3
--- src/jpeg/jcsample.c	2002/05/26 11:49:37	1.2
+++ src/jpeg/jcsample.c	2006/11/28 16:24:41	1.3
@@ -466,7 +466,7 @@
   my_downsample_ptr downsample;
   int ci;
   jpeg_component_info * compptr;
-  boolean smoothok = TRUE;
+  wxjpeg_boolean smoothok = TRUE;
 
   downsample = (my_downsample_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
Index: src/jpeg/jctrans.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jctrans.c,v
retrieving revision 1.2
retrieving revision 1.3
diff --unified -r1.2 -r1.3
--- src/jpeg/jctrans.c	2002/10/11 16:01:42	1.2
+++ src/jpeg/jctrans.c	2006/11/28 16:24:41	1.3
@@ -279,7 +279,7 @@
  * NB: input_buf is ignored; it is likely to be a NULL pointer.
  */
 
-METHODDEF(boolean)
+METHODDEF(wxjpeg_boolean)
 compress_output (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
 {
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
Index: src/jpeg/jdapimin.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jdapimin.c,v
retrieving revision 1.1
retrieving revision 1.2
diff --unified -r1.1 -r1.2
--- src/jpeg/jdapimin.c	1999/04/17 17:54:02	1.1
+++ src/jpeg/jdapimin.c	2006/11/28 16:24:41	1.2
@@ -238,7 +238,7 @@
  */
 
 GLOBAL(int)
-jpeg_read_header (j_decompress_ptr cinfo, boolean require_image)
+jpeg_read_header (j_decompress_ptr cinfo, wxjpeg_boolean require_image)
 {
   int retcode;
 
@@ -330,7 +330,7 @@
  * Have we finished reading the input file?
  */
 
-GLOBAL(boolean)
+GLOBAL(wxjpeg_boolean)
 jpeg_input_complete (j_decompress_ptr cinfo)
 {
   /* Check for valid jpeg object */
@@ -345,7 +345,7 @@
  * Is there more than one scan?
  */
 
-GLOBAL(boolean)
+GLOBAL(wxjpeg_boolean)
 jpeg_has_multiple_scans (j_decompress_ptr cinfo)
 {
   /* Only valid after jpeg_read_header completes */
@@ -365,7 +365,7 @@
  * a suspending data source is used.
  */
 
-GLOBAL(boolean)
+GLOBAL(wxjpeg_boolean)
 jpeg_finish_decompress (j_decompress_ptr cinfo)
 {
   if ((cinfo->global_state == DSTATE_SCANNING ||
Index: src/jpeg/jdapistd.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jdapistd.c,v
retrieving revision 1.1
retrieving revision 1.2
diff --unified -r1.1 -r1.2
--- src/jpeg/jdapistd.c	1999/04/17 17:54:02	1.1
+++ src/jpeg/jdapistd.c	2006/11/28 16:24:41	1.2
@@ -20,7 +20,7 @@
 
 
 /* Forward declarations */
-LOCAL(boolean) output_pass_setup JPP((j_decompress_ptr cinfo));
+LOCAL(wxjpeg_boolean) output_pass_setup JPP((j_decompress_ptr cinfo));
 
 
 /*
@@ -34,7 +34,7 @@
  * a suspending data source is used.
  */
 
-GLOBAL(boolean)
+GLOBAL(wxjpeg_boolean)
 jpeg_start_decompress (j_decompress_ptr cinfo)
 {
   if (cinfo->global_state == DSTATE_READY) {
@@ -91,7 +91,7 @@
  *       If suspended, returns FALSE and sets global_state = DSTATE_PRESCAN.
  */
 
-LOCAL(boolean)
+LOCAL(wxjpeg_boolean)
 output_pass_setup (j_decompress_ptr cinfo)
 {
   if (cinfo->global_state != DSTATE_PRESCAN) {
@@ -224,7 +224,7 @@
  * Initialize for an output pass in buffered-image mode.
  */
 
-GLOBAL(boolean)
+GLOBAL(wxjpeg_boolean)
 jpeg_start_output (j_decompress_ptr cinfo, int scan_number)
 {
   if (cinfo->global_state != DSTATE_BUFIMAGE &&
@@ -249,7 +249,7 @@
  * a suspending data source is used.
  */
 
-GLOBAL(boolean)
+GLOBAL(wxjpeg_boolean)
 jpeg_finish_output (j_decompress_ptr cinfo)
 {
   if ((cinfo->global_state == DSTATE_SCANNING ||
Index: src/jpeg/jdatadst.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jdatadst.c,v
retrieving revision 1.1
retrieving revision 1.2
diff --unified -r1.1 -r1.2
--- src/jpeg/jdatadst.c	1999/04/17 17:54:02	1.1
+++ src/jpeg/jdatadst.c	2006/11/28 16:24:42	1.2
@@ -77,7 +77,7 @@
  * write it out when emptying the buffer externally.
  */
 
-METHODDEF(boolean)
+METHODDEF(wxjpeg_boolean)
 empty_output_buffer (j_compress_ptr cinfo)
 {
   my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
Index: src/jpeg/jdatasrc.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jdatasrc.c,v
retrieving revision 1.1
retrieving revision 1.2
diff --unified -r1.1 -r1.2
--- src/jpeg/jdatasrc.c	1999/04/17 17:54:02	1.1
+++ src/jpeg/jdatasrc.c	2006/11/28 16:24:42	1.2
@@ -27,7 +27,7 @@
 
   FILE * infile;		/* source stream */
   JOCTET * buffer;		/* start of buffer */
-  boolean start_of_file;	/* have we gotten any data yet? */
+  wxjpeg_boolean start_of_file;	/* have we gotten any data yet? */
 } my_source_mgr;
 
 typedef my_source_mgr * my_src_ptr;
@@ -86,7 +86,7 @@
  * the front of the buffer rather than discarding it.
  */
 
-METHODDEF(boolean)
+METHODDEF(wxjpeg_boolean)
 fill_input_buffer (j_decompress_ptr cinfo)
 {
   my_src_ptr src = (my_src_ptr) cinfo->src;
Index: src/jpeg/jdcoefct.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jdcoefct.c,v
retrieving revision 1.3
retrieving revision 1.4
diff --unified -r1.3 -r1.4
--- src/jpeg/jdcoefct.c	2002/12/04 14:08:26	1.3
+++ src/jpeg/jdcoefct.c	2006/11/28 16:24:42	1.4
@@ -69,7 +69,7 @@
 	JPP((j_decompress_ptr cinfo, JSAMPIMAGE output_buf));
 #endif
 #ifdef BLOCK_SMOOTHING_SUPPORTED
-LOCAL(boolean) smoothing_ok JPP((j_decompress_ptr cinfo));
+LOCAL(wxjpeg_boolean) smoothing_ok JPP((j_decompress_ptr cinfo));
 METHODDEF(int) decompress_smooth_data
 	JPP((j_decompress_ptr cinfo, JSAMPIMAGE output_buf));
 #endif
@@ -404,11 +404,11 @@
  * more accurately than they really are.
  */
 
-LOCAL(boolean)
+LOCAL(wxjpeg_boolean)
 smoothing_ok (j_decompress_ptr cinfo)
 {
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
-  boolean smoothing_useful = FALSE;
+  wxjpeg_boolean smoothing_useful = FALSE;
   int ci, coefi;
   jpeg_component_info *compptr;
   JQUANT_TBL * qtable;
@@ -473,7 +473,7 @@
   JDIMENSION output_col;
   jpeg_component_info *compptr;
   inverse_DCT_method_ptr inverse_DCT;
-  boolean first_row, last_row;
+  wxjpeg_boolean first_row, last_row;
   JBLOCK workspace;
   int *coef_bits;
   JQUANT_TBL *quanttbl;
@@ -676,7 +676,7 @@
  */
 
 GLOBAL(void)
-jinit_d_coef_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
+jinit_d_coef_controller (j_decompress_ptr cinfo, wxjpeg_boolean need_full_buffer)
 {
   my_coef_ptr coef;
 
Index: src/jpeg/jdhuff.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jdhuff.c,v
retrieving revision 1.2
retrieving revision 1.3
diff --unified -r1.2 -r1.3
--- src/jpeg/jdhuff.c	2002/05/26 11:49:37	1.2
+++ src/jpeg/jdhuff.c	2006/11/28 16:24:42	1.3
@@ -71,8 +71,8 @@
   d_derived_tbl * dc_cur_tbls[D_MAX_BLOCKS_IN_MCU];
   d_derived_tbl * ac_cur_tbls[D_MAX_BLOCKS_IN_MCU];
   /* Whether we care about the DC and AC coefficient values for each block */
-  boolean dc_needed[D_MAX_BLOCKS_IN_MCU];
-  boolean ac_needed[D_MAX_BLOCKS_IN_MCU];
+  wxjpeg_boolean dc_needed[D_MAX_BLOCKS_IN_MCU];
+  wxjpeg_boolean ac_needed[D_MAX_BLOCKS_IN_MCU];
 } huff_entropy_decoder;
 
 typedef huff_entropy_decoder * huff_entropy_ptr;
@@ -146,7 +146,7 @@
  */
 
 GLOBAL(void)
-jpeg_make_d_derived_tbl (j_decompress_ptr cinfo, boolean isDC, int tblno,
+jpeg_make_d_derived_tbl (j_decompress_ptr cinfo, wxjpeg_boolean isDC, int tblno,
 			 d_derived_tbl ** pdtbl)
 {
   JHUFF_TBL *htbl;
@@ -288,7 +288,7 @@
 #endif
 
 
-GLOBAL(boolean)
+GLOBAL(wxjpeg_boolean)
 jpeg_fill_bit_buffer (bitread_working_state * state,
 		      register bit_buf_type get_buffer, register int bits_left,
 		      int nbits)
@@ -464,7 +464,7 @@
  * Returns FALSE if must suspend.
  */
 
-LOCAL(boolean)
+LOCAL(wxjpeg_boolean)
 process_restart (j_decompress_ptr cinfo)
 {
   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
@@ -513,7 +513,7 @@
  * this module, since we'll just re-assign them on the next call.)
  */
 
-METHODDEF(boolean)
+METHODDEF(wxjpeg_boolean)
 decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 {
   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
Index: src/jpeg/jdhuff.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jdhuff.h,v
retrieving revision 1.2
retrieving revision 1.3
diff --unified -r1.2 -r1.3
--- src/jpeg/jdhuff.h	2002/05/26 11:49:37	1.2
+++ src/jpeg/jdhuff.h	2006/11/28 16:24:42	1.3
@@ -47,7 +47,7 @@
 
 /* Expand a Huffman table definition into the derived format */
 EXTERN(void) jpeg_make_d_derived_tbl
-	JPP((j_decompress_ptr cinfo, boolean isDC, int tblno,
+	JPP((j_decompress_ptr cinfo, wxjpeg_boolean isDC, int tblno,
 	     d_derived_tbl ** pdtbl));
 
 
@@ -151,7 +151,7 @@
 	(bits_left -= (nbits))
 
 /* Load up the bit buffer to a depth of at least nbits */
-EXTERN(boolean) jpeg_fill_bit_buffer
+EXTERN(wxjpeg_boolean) jpeg_fill_bit_buffer
 	JPP((bitread_working_state * state, register bit_buf_type get_buffer,
 	     register int bits_left, int nbits));
 
Index: src/jpeg/jdinput.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jdinput.c,v
retrieving revision 1.4
retrieving revision 1.5
diff --unified -r1.4 -r1.5
--- src/jpeg/jdinput.c	2003/01/06 17:50:21	1.4
+++ src/jpeg/jdinput.c	2006/11/28 16:24:42	1.5
@@ -20,7 +20,7 @@
 typedef struct {
   struct jpeg_input_controller pub; /* public fields */
 
-  boolean inheaders;		/* TRUE until first SOS is reached */
+  wxjpeg_boolean inheaders;		/* TRUE until first SOS is reached */
 } my_input_controller;
 
 typedef my_input_controller * my_inputctl_ptr;
Index: src/jpeg/jdmainct.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jdmainct.c,v
retrieving revision 1.3
retrieving revision 1.4
diff --unified -r1.3 -r1.4
--- src/jpeg/jdmainct.c	2002/10/11 16:01:44	1.3
+++ src/jpeg/jdmainct.c	2006/11/28 16:24:43	1.4
@@ -119,7 +119,7 @@
   /* Pointer to allocated workspace (M or M+2 row groups). */
   JSAMPARRAY buffer[MAX_COMPONENTS];
 
-  boolean buffer_full;		/* Have we gotten an iMCU row from decoder? */
+  wxjpeg_boolean buffer_full;		/* Have we gotten an iMCU row from decoder? */
   JDIMENSION rowgroup_ctr;	/* counts row groups output to postprocessor */
 
   /* Remaining fields are only used in the context case. */
@@ -481,7 +481,7 @@
  */
 
 GLOBAL(void)
-jinit_d_main_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
+jinit_d_main_controller (j_decompress_ptr cinfo, wxjpeg_boolean need_full_buffer)
 {
   my_main_ptr main;
   int ci, rgroup, ngroups;
Index: src/jpeg/jdmarker.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jdmarker.c,v
retrieving revision 1.2
retrieving revision 1.3
diff --unified -r1.2 -r1.3
--- src/jpeg/jdmarker.c	2002/05/26 11:49:37	1.2
+++ src/jpeg/jdmarker.c	2006/11/28 16:24:43	1.3
@@ -193,7 +193,7 @@
  */
 
 
-LOCAL(boolean)
+LOCAL(wxjpeg_boolean)
 get_soi (j_decompress_ptr cinfo)
 /* Process an SOI marker */
 {
@@ -233,8 +233,8 @@
 }
 
 
-LOCAL(boolean)
-get_sof (j_decompress_ptr cinfo, boolean is_prog, boolean is_arith)
+LOCAL(wxjpeg_boolean)
+get_sof (j_decompress_ptr cinfo, wxjpeg_boolean is_prog, wxjpeg_boolean is_arith)
 /* Process a SOFn marker */
 {
   JPEG_INT32 length;
@@ -297,7 +297,7 @@
 }
 
 
-LOCAL(boolean)
+LOCAL(wxjpeg_boolean)
 get_sos (j_decompress_ptr cinfo)
 /* Process a SOS marker */
 {
@@ -369,7 +369,7 @@
 
 #ifdef D_ARITH_CODING_SUPPORTED
 
-LOCAL(boolean)
+LOCAL(wxjpeg_boolean)
 get_dac (j_decompress_ptr cinfo)
 /* Process a DAC marker */
 {
@@ -415,7 +415,7 @@
 #endif /* D_ARITH_CODING_SUPPORTED */
 
 
-LOCAL(boolean)
+LOCAL(wxjpeg_boolean)
 get_dht (j_decompress_ptr cinfo)
 /* Process a DHT marker */
 {
@@ -486,7 +486,7 @@
 }
 
 
-LOCAL(boolean)
+LOCAL(wxjpeg_boolean)
 get_dqt (j_decompress_ptr cinfo)
 /* Process a DQT marker */
 {
@@ -544,7 +544,7 @@
 }
 
 
-LOCAL(boolean)
+LOCAL(wxjpeg_boolean)
 get_dri (j_decompress_ptr cinfo)
 /* Process a DRI marker */
 {
@@ -687,7 +687,7 @@
 }
 
 
-METHODDEF(boolean)
+METHODDEF(wxjpeg_boolean)
 get_interesting_appn (j_decompress_ptr cinfo)
 /* Process an APP0 or APP14 marker without saving it */
 {
@@ -735,7 +735,7 @@
 
 #ifdef SAVE_MARKERS_SUPPORTED
 
-METHODDEF(boolean)
+METHODDEF(wxjpeg_boolean)
 save_marker (j_decompress_ptr cinfo)
 /* Save an APPn or COM marker into the marker list */
 {
@@ -841,7 +841,7 @@
 #endif /* SAVE_MARKERS_SUPPORTED */
 
 
-METHODDEF(boolean)
+METHODDEF(wxjpeg_boolean)
 skip_variable (j_decompress_ptr cinfo)
 /* Skip over an unknown or uninteresting variable-length marker */
 {
@@ -870,7 +870,7 @@
  * but it will never be 0 or FF.
  */
 
-LOCAL(boolean)
+LOCAL(wxjpeg_boolean)
 next_marker (j_decompress_ptr cinfo)
 {
   int c;
@@ -917,7 +917,7 @@
 }
 
 
-LOCAL(boolean)
+LOCAL(wxjpeg_boolean)
 first_marker (j_decompress_ptr cinfo)
 /* Like next_marker, but used to obtain the initial SOI marker. */
 /* For this marker, we do not allow preceding garbage or fill; otherwise,
@@ -1109,7 +1109,7 @@
  * it holds a marker which the decoder will be unable to read past.
  */
 
-METHODDEF(boolean)
+METHODDEF(wxjpeg_boolean)
 read_restart_marker (j_decompress_ptr cinfo)
 {
   /* Obtain a marker unless we already did. */
@@ -1188,7 +1188,7 @@
  * any other marker would have to be bogus data in that case.
  */
 
-GLOBAL(boolean)
+GLOBAL(wxjpeg_boolean)
 jpeg_resync_to_restart (j_decompress_ptr cinfo, int desired)
 {
   int marker = cinfo->unread_marker;
Index: src/jpeg/jdmaster.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jdmaster.c,v
retrieving revision 1.3
retrieving revision 1.4
diff --unified -r1.3 -r1.4
--- src/jpeg/jdmaster.c	2003/01/06 17:50:20	1.3
+++ src/jpeg/jdmaster.c	2006/11/28 16:24:43	1.4
@@ -22,7 +22,7 @@
 
   int pass_number;		/* # of passes completed */
 
-  boolean using_merged_upsample; /* TRUE if using merged upsample/cconvert */
+  wxjpeg_boolean using_merged_upsample; /* TRUE if using merged upsample/cconvert */
 
   /* Saved references to initialized quantizer modules,
    * in case we need to switch modes.
@@ -39,7 +39,7 @@
  * CRUCIAL: this must match the actual capabilities of jdmerge.c!
  */
 
-LOCAL(boolean)
+LOCAL(wxjpeg_boolean)
 use_merged_upsample (j_decompress_ptr cinfo)
 {
 #ifdef UPSAMPLE_MERGING_SUPPORTED
@@ -287,7 +287,7 @@
 master_selection (j_decompress_ptr cinfo)
 {
   my_master_ptr master = (my_master_ptr) cinfo->master;
-  boolean use_c_buffer;
+  wxjpeg_boolean use_c_buffer;
   long samplesperrow;
   JDIMENSION jd_samplesperrow;
 
Index: src/jpeg/jdmerge.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jdmerge.c,v
retrieving revision 1.3
retrieving revision 1.4
diff --unified -r1.3 -r1.4
--- src/jpeg/jdmerge.c	2002/05/26 11:49:37	1.3
+++ src/jpeg/jdmerge.c	2006/11/28 16:24:43	1.4
@@ -61,7 +61,7 @@
    * to discard the dummy last row if the image height is odd.
    */
   JSAMPROW spare_row;
-  boolean spare_full;		/* T if spare buffer is occupied */
+  wxjpeg_boolean spare_full;		/* T if spare buffer is occupied */
 
   JDIMENSION out_row_width;	/* samples per output row */
   JDIMENSION rows_to_go;	/* counts rows remaining in image */
Index: src/jpeg/jdphuff.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jdphuff.c,v
retrieving revision 1.1
retrieving revision 1.2
diff --unified -r1.1 -r1.2
--- src/jpeg/jdphuff.c	1999/04/17 17:54:03	1.1
+++ src/jpeg/jdphuff.c	2006/11/28 16:24:43	1.2
@@ -74,13 +74,13 @@
 typedef phuff_entropy_decoder * phuff_entropy_ptr;
 
 /* Forward declarations */
-METHODDEF(boolean) decode_mcu_DC_first JPP((j_decompress_ptr cinfo,
+METHODDEF(wxjpeg_boolean) decode_mcu_DC_first JPP((j_decompress_ptr cinfo,
 					    JBLOCKROW *MCU_data));
-METHODDEF(boolean) decode_mcu_AC_first JPP((j_decompress_ptr cinfo,
+METHODDEF(wxjpeg_boolean) decode_mcu_AC_first JPP((j_decompress_ptr cinfo,
 					    JBLOCKROW *MCU_data));
-METHODDEF(boolean) decode_mcu_DC_refine JPP((j_decompress_ptr cinfo,
+METHODDEF(wxjpeg_boolean) decode_mcu_DC_refine JPP((j_decompress_ptr cinfo,
 					     JBLOCKROW *MCU_data));
-METHODDEF(boolean) decode_mcu_AC_refine JPP((j_decompress_ptr cinfo,
+METHODDEF(wxjpeg_boolean) decode_mcu_AC_refine JPP((j_decompress_ptr cinfo,
 					     JBLOCKROW *MCU_data));
 
 
@@ -92,7 +92,7 @@
 start_pass_phuff_decoder (j_decompress_ptr cinfo)
 {
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
-  boolean is_DC_band, bad;
+  wxjpeg_boolean is_DC_band, bad;
   int ci, coefi, tbl;
   int *coef_bit_ptr;
   jpeg_component_info * compptr;
@@ -224,7 +224,7 @@
  * Returns FALSE if must suspend.
  */
 
-LOCAL(boolean)
+LOCAL(wxjpeg_boolean)
 process_restart (j_decompress_ptr cinfo)
 {
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
@@ -282,7 +282,7 @@
  * or first pass of successive approximation).
  */
 
-METHODDEF(boolean)
+METHODDEF(wxjpeg_boolean)
 decode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 {   
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
@@ -353,7 +353,7 @@
  * or first pass of successive approximation).
  */
 
-METHODDEF(boolean)
+METHODDEF(wxjpeg_boolean)
 decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 {   
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
@@ -438,7 +438,7 @@
  * is not very clear on the point.
  */
 
-METHODDEF(boolean)
+METHODDEF(wxjpeg_boolean)
 decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 {   
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
@@ -487,7 +487,7 @@
  * MCU decoding for AC successive approximation refinement scan.
  */
 
-METHODDEF(boolean)
+METHODDEF(wxjpeg_boolean)
 decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 {   
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
Index: src/jpeg/jdpostct.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jdpostct.c,v
retrieving revision 1.1
retrieving revision 1.2
diff --unified -r1.1 -r1.2
--- src/jpeg/jdpostct.c	1999/04/17 17:54:04	1.1
+++ src/jpeg/jdpostct.c	2006/11/28 16:24:43	1.2
@@ -247,7 +247,7 @@
  */
 
 GLOBAL(void)
-jinit_d_post_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
+jinit_d_post_controller (j_decompress_ptr cinfo, wxjpeg_boolean need_full_buffer)
 {
   my_post_ptr post;
 
Index: src/jpeg/jdsample.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jdsample.c,v
retrieving revision 1.2
retrieving revision 1.3
diff --unified -r1.2 -r1.3
--- src/jpeg/jdsample.c	2002/05/26 11:49:37	1.2
+++ src/jpeg/jdsample.c	2006/11/28 16:24:43	1.3
@@ -401,7 +401,7 @@
   my_upsample_ptr upsample;
   int ci;
   jpeg_component_info * compptr;
-  boolean need_buffer, do_fancy;
+  wxjpeg_boolean need_buffer, do_fancy;
   int h_in_group, v_in_group, h_out_group, v_out_group;
 
   upsample = (my_upsample_ptr)
Index: src/jpeg/jerror.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jerror.c,v
retrieving revision 1.1
retrieving revision 1.2
diff --unified -r1.1 -r1.2
--- src/jpeg/jerror.c	1999/04/17 17:54:04	1.1
+++ src/jpeg/jerror.c	2006/11/28 16:24:43	1.2
@@ -161,7 +161,7 @@
   const char * msgtext = NULL;
   const char * msgptr;
   char ch;
-  boolean isstring;
+  wxjpeg_boolean isstring;
 
   /* Look up message string in proper table */
   if (msg_code > 0 && msg_code <= err->last_jpeg_message) {
Index: src/jpeg/jmemdos.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jmemdos.c,v
retrieving revision 1.1
retrieving revision 1.2
diff --unified -r1.1 -r1.2
--- src/jpeg/jmemdos.c	1999/04/17 17:54:05	1.1
+++ src/jpeg/jmemdos.c	2006/11/28 16:24:43	1.2
@@ -284,7 +284,7 @@
 }
 
 
-LOCAL(boolean)
+LOCAL(wxjpeg_boolean)
 open_file_store (j_common_ptr cinfo, backing_store_ptr info,
 		 long total_bytes_needed)
 {
@@ -410,7 +410,7 @@
 }
 
 
-LOCAL(boolean)
+LOCAL(wxjpeg_boolean)
 open_xms_store (j_common_ptr cinfo, backing_store_ptr info,
 		long total_bytes_needed)
 {
@@ -550,7 +550,7 @@
 }
 
 
-LOCAL(boolean)
+LOCAL(wxjpeg_boolean)
 open_ems_store (j_common_ptr cinfo, backing_store_ptr info,
 		long total_bytes_needed)
 {
Index: src/jpeg/jmemmgr.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jmemmgr.c,v
retrieving revision 1.1
retrieving revision 1.2
diff --unified -r1.1 -r1.2
--- src/jpeg/jmemmgr.c	1999/04/17 17:54:06	1.1
+++ src/jpeg/jmemmgr.c	2006/11/28 16:24:44	1.2
@@ -156,9 +156,9 @@
   JDIMENSION rowsperchunk;	/* allocation chunk size in mem_buffer */
   JDIMENSION cur_start_row;	/* first logical row # in the buffer */
   JDIMENSION first_undef_row;	/* row # of first uninitialized row */
-  boolean pre_zero;		/* pre-zero mode requested? */
-  boolean dirty;		/* do current buffer contents need written? */
-  boolean b_s_open;		/* is backing-store data valid? */
+  wxjpeg_boolean pre_zero;		/* pre-zero mode requested? */
+  wxjpeg_boolean dirty;		/* do current buffer contents need written? */
+  wxjpeg_boolean b_s_open;		/* is backing-store data valid? */
   jvirt_sarray_ptr next;	/* link to next virtual sarray control block */
   backing_store_info b_s_info;	/* System-dependent control info */
 };
@@ -172,9 +172,9 @@
   JDIMENSION rowsperchunk;	/* allocation chunk size in mem_buffer */
   JDIMENSION cur_start_row;	/* first logical row # in the buffer */
   JDIMENSION first_undef_row;	/* row # of first uninitialized row */
-  boolean pre_zero;		/* pre-zero mode requested? */
-  boolean dirty;		/* do current buffer contents need written? */
-  boolean b_s_open;		/* is backing-store data valid? */
+  wxjpeg_boolean pre_zero;		/* pre-zero mode requested? */
+  wxjpeg_boolean dirty;		/* do current buffer contents need written? */
+  wxjpeg_boolean b_s_open;		/* is backing-store data valid? */
   jvirt_barray_ptr next;	/* link to next virtual barray control block */
   backing_store_info b_s_info;	/* System-dependent control info */
 };
@@ -520,7 +520,7 @@
 
 
 METHODDEF(jvirt_sarray_ptr)
-request_virt_sarray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
+request_virt_sarray (j_common_ptr cinfo, int pool_id, wxjpeg_boolean pre_zero,
 		     JDIMENSION samplesperrow, JDIMENSION numrows,
 		     JDIMENSION maxaccess)
 /* Request a virtual 2-D sample array */
@@ -550,7 +550,7 @@
 
 
 METHODDEF(jvirt_barray_ptr)
-request_virt_barray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
+request_virt_barray (j_common_ptr cinfo, int pool_id, wxjpeg_boolean pre_zero,
 		     JDIMENSION blocksperrow, JDIMENSION numrows,
 		     JDIMENSION maxaccess)
 /* Request a virtual 2-D coefficient-block array */
@@ -687,7 +687,7 @@
 
 
 LOCAL(void)
-do_sarray_io (j_common_ptr cinfo, jvirt_sarray_ptr ptr, boolean writing)
+do_sarray_io (j_common_ptr cinfo, jvirt_sarray_ptr ptr, wxjpeg_boolean writing)
 /* Do backing store read or write of a virtual sample array */
 {
   long bytesperrow, file_offset, byte_count, rows, thisrow, i;
@@ -720,7 +720,7 @@
 
 
 LOCAL(void)
-do_barray_io (j_common_ptr cinfo, jvirt_barray_ptr ptr, boolean writing)
+do_barray_io (j_common_ptr cinfo, jvirt_barray_ptr ptr, wxjpeg_boolean writing)
 /* Do backing store read or write of a virtual coefficient-block array */
 {
   long bytesperrow, file_offset, byte_count, rows, thisrow, i;
@@ -755,7 +755,7 @@
 METHODDEF(JSAMPARRAY)
 access_virt_sarray (j_common_ptr cinfo, jvirt_sarray_ptr ptr,
 		    JDIMENSION start_row, JDIMENSION num_rows,
-		    boolean writable)
+		    wxjpeg_boolean writable)
 /* Access the part of a virtual sample array starting at start_row */
 /* and extending for num_rows rows.  writable is true if  */
 /* caller intends to modify the accessed area. */
@@ -840,7 +840,7 @@
 METHODDEF(JBLOCKARRAY)
 access_virt_barray (j_common_ptr cinfo, jvirt_barray_ptr ptr,
 		    JDIMENSION start_row, JDIMENSION num_rows,
-		    boolean writable)
+		    wxjpeg_boolean writable)
 /* Access the part of a virtual block array starting at start_row */
 /* and extending for num_rows rows.  writable is true if  */
 /* caller intends to modify the accessed area. */
Index: src/jpeg/jmorecfg.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jmorecfg.h,v
retrieving revision 1.20
retrieving revision 1.21
diff --unified -r1.20 -r1.21
--- src/jpeg/jmorecfg.h	2003/01/07 13:48:56	1.20
+++ src/jpeg/jmorecfg.h	2006/11/28 16:24:44	1.21
@@ -260,9 +260,29 @@
  * Defining HAVE_BOOLEAN before including jpeglib.h should make it work.
  */
 
+#if 0
 #ifndef HAVE_BOOLEAN
 typedef int boolean;
 #endif
+#endif
+
+/*
+ * Notes about boolean above:
+ *
+ * The main conflict we see is with the Windows headers of some compilers that
+ * have a different definition of boolean. Therefore boolean has been replaced
+ * with wxjpeg_boolean throughout the jpeg sources. The alternative would have
+ * been to make the definition here the same as the Windows definition. It's
+ * not enough to just define HAVE_BOOLEAN when using the jpeg library, the
+ * definition of boolean must match when the jpeg library is compiled too.
+ *
+ * System jepg libs won't have this type, of course, so to use test
+ * HAVE_WXJPEG_BOOLEAN and fall back to boolean when not defined.
+ */
+
+typedef int wxjpeg_boolean;
+#define HAVE_WXJPEG_BOOLEAN
+
 #ifndef FALSE			/* in case these macros already exist */
 #define FALSE	0		/* values of boolean */
 #endif
Index: src/jpeg/jpegint.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jpegint.h,v
retrieving revision 1.5
retrieving revision 1.6
diff --unified -r1.5 -r1.6
--- src/jpeg/jpegint.h	2003/01/06 17:50:20	1.5
+++ src/jpeg/jpegint.h	2006/11/28 16:24:44	1.6
@@ -48,8 +48,8 @@
   JMETHOD(void, finish_pass, (j_compress_ptr cinfo));
 
   /* State variables made visible to other modules */
-  boolean call_pass_startup;	/* True if pass_startup must be called */
-  boolean is_last_pass;		/* True during last pass */
+  wxjpeg_boolean call_pass_startup;	/* True if pass_startup must be called */
+  wxjpeg_boolean is_last_pass;		/* True during last pass */
 };
 
 /* Main buffer control (downsampled-data buffer) */
@@ -75,7 +75,7 @@
 /* Coefficient buffer control */
 struct jpeg_c_coef_controller {
   JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
-  JMETHOD(boolean, compress_data, (j_compress_ptr cinfo,
+  JMETHOD(wxjpeg_boolean, compress_data, (j_compress_ptr cinfo,
 				   JSAMPIMAGE input_buf));
 };
 
@@ -95,7 +95,7 @@
 			     JSAMPIMAGE output_buf,
 			     JDIMENSION out_row_group_index));
 
-  boolean need_context_rows;	/* TRUE if need rows above & below */
+  wxjpeg_boolean need_context_rows;	/* TRUE if need rows above & below */
 };
 
 /* Forward DCT (also controls coefficient quantization) */
@@ -111,8 +111,8 @@
 
 /* Entropy encoding */
 struct jpeg_entropy_encoder {
-  JMETHOD(void, start_pass, (j_compress_ptr cinfo, boolean gather_statistics));
-  JMETHOD(boolean, encode_mcu, (j_compress_ptr cinfo, JBLOCKROW *MCU_data));
+  JMETHOD(void, start_pass, (j_compress_ptr cinfo, wxjpeg_boolean gather_statistics));
+  JMETHOD(wxjpeg_boolean, encode_mcu, (j_compress_ptr cinfo, JBLOCKROW *MCU_data));
   JMETHOD(void, finish_pass, (j_compress_ptr cinfo));
 };
 
@@ -139,7 +139,7 @@
   JMETHOD(void, finish_output_pass, (j_decompress_ptr cinfo));
 
   /* State variables made visible to other modules */
-  boolean is_dummy_pass;	/* True during 1st pass for 2-pass quant */
+  wxjpeg_boolean is_dummy_pass;	/* True during 1st pass for 2-pass quant */
 };
 
 /* Input control module */
@@ -150,8 +150,8 @@
   JMETHOD(void, finish_input_pass, (j_decompress_ptr cinfo));
 
   /* State variables made visible to other modules */
-  boolean has_multiple_scans;	/* True if file has multiple scans */
-  boolean eoi_reached;		/* True when EOI has been consumed */
+  wxjpeg_boolean has_multiple_scans;	/* True if file has multiple scans */
+  wxjpeg_boolean eoi_reached;		/* True when EOI has been consumed */
 };
 
 /* Main buffer control (downsampled-data buffer) */
@@ -207,8 +207,8 @@
   /* State of marker reader --- nominally internal, but applications
    * supplying COM or APPn handlers might like to know the state.
    */
-  boolean saw_SOI;		/* found SOI? */
-  boolean saw_SOF;		/* found SOF? */
+  wxjpeg_boolean saw_SOI;		/* found SOI? */
+  wxjpeg_boolean saw_SOF;		/* found SOF? */
   int next_restart_num;		/* next restart number expected (0-7) */
   unsigned int discarded_bytes;	/* # of bytes skipped looking for a marker */
 };
@@ -216,12 +216,12 @@
 /* Entropy decoding */
 struct jpeg_entropy_decoder {
   JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
-  JMETHOD(boolean, decode_mcu, (j_decompress_ptr cinfo,
+  JMETHOD(wxjpeg_boolean, decode_mcu, (j_decompress_ptr cinfo,
 				JBLOCKROW *MCU_data));
 
   /* This is here to share code between baseline and progressive decoders; */
   /* other modules probably should not use it */
-  boolean insufficient_data;	/* set TRUE after emitting warning */
+  wxjpeg_boolean insufficient_data;	/* set TRUE after emitting warning */
 };
 
 /* Inverse DCT (also performs dequantization) */
@@ -247,7 +247,7 @@
 			   JDIMENSION *out_row_ctr,
 			   JDIMENSION out_rows_avail));
 
-  boolean need_context_rows;	/* TRUE if need rows above & below */
+  wxjpeg_boolean need_context_rows;	/* TRUE if need rows above & below */
 };
 
 /* Colorspace conversion */
@@ -260,7 +260,7 @@
 
 /* Color quantization or color precision reduction */
 struct jpeg_color_quantizer {
-  JMETHOD(void, start_pass, (j_decompress_ptr cinfo, boolean is_pre_scan));
+  JMETHOD(void, start_pass, (j_decompress_ptr cinfo, wxjpeg_boolean is_pre_scan));
   JMETHOD(void, color_quantize, (j_decompress_ptr cinfo,
 				 JSAMPARRAY input_buf, JSAMPARRAY output_buf,
 				 int num_rows));
@@ -341,13 +341,13 @@
 /* Compression module initialization routines */
 EXTERN(void) jinit_compress_master JPP((j_compress_ptr cinfo));
 EXTERN(void) jinit_c_master_control JPP((j_compress_ptr cinfo,
-					 boolean transcode_only));
+					 wxjpeg_boolean transcode_only));
 EXTERN(void) jinit_c_main_controller JPP((j_compress_ptr cinfo,
-					  boolean need_full_buffer));
+					  wxjpeg_boolean need_full_buffer));
 EXTERN(void) jinit_c_prep_controller JPP((j_compress_ptr cinfo,
-					  boolean need_full_buffer));
+					  wxjpeg_boolean need_full_buffer));
 EXTERN(void) jinit_c_coef_controller JPP((j_compress_ptr cinfo,
-					  boolean need_full_buffer));
+					  wxjpeg_boolean need_full_buffer));
 EXTERN(void) jinit_color_converter JPP((j_compress_ptr cinfo));
 EXTERN(void) jinit_downsampler JPP((j_compress_ptr cinfo));
 EXTERN(void) jinit_forward_dct JPP((j_compress_ptr cinfo));
@@ -357,11 +357,11 @@
 /* Decompression module initialization routines */
 EXTERN(void) jinit_master_decompress JPP((j_decompress_ptr cinfo));
 EXTERN(void) jinit_d_main_controller JPP((j_decompress_ptr cinfo,
-					  boolean need_full_buffer));
+					  wxjpeg_boolean need_full_buffer));
 EXTERN(void) jinit_d_coef_controller JPP((j_decompress_ptr cinfo,
-					  boolean need_full_buffer));
+					  wxjpeg_boolean need_full_buffer));
 EXTERN(void) jinit_d_post_controller JPP((j_decompress_ptr cinfo,
-					  boolean need_full_buffer));
+					  wxjpeg_boolean need_full_buffer));
 EXTERN(void) jinit_input_controller JPP((j_decompress_ptr cinfo));
 EXTERN(void) jinit_marker_reader JPP((j_decompress_ptr cinfo));
 EXTERN(void) jinit_huff_decoder JPP((j_decompress_ptr cinfo));
Index: src/jpeg/jpeglib.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jpeglib.h,v
retrieving revision 1.3
retrieving revision 1.4
diff --unified -r1.3 -r1.4
--- src/jpeg/jpeglib.h	1999/10/26 04:38:09	1.3
+++ src/jpeg/jpeglib.h	2006/11/28 16:24:44	1.4
@@ -91,7 +91,7 @@
    * You could suppress output of a table by setting this to TRUE.
    * (See jpeg_suppress_tables for an example.)
    */
-  boolean sent_table;		/* TRUE when table has been output */
+  wxjpeg_boolean sent_table;		/* TRUE when table has been output */
 } JQUANT_TBL;
 
 
@@ -107,7 +107,7 @@
    * You could suppress output of a table by setting this to TRUE.
    * (See jpeg_suppress_tables for an example.)
    */
-  boolean sent_table;		/* TRUE when table has been output */
+  wxjpeg_boolean sent_table;		/* TRUE when table has been output */
 } JHUFF_TBL;
 
 
@@ -157,7 +157,7 @@
    * components will be ignored (eg grayscale output from YCbCr image),
    * we can skip most computations for the unused components.
    */
-  boolean component_needed;	/* do we need the value of this component? */
+  wxjpeg_boolean component_needed;	/* do we need the value of this component? */
 
   /* These values are computed before starting a scan of the component. */
   /* The decompressor output side may not use these variables. */
@@ -243,7 +243,7 @@
   struct jpeg_memory_mgr * mem;	/* Memory manager module */\
   struct jpeg_progress_mgr * progress; /* Progress monitor, or NULL if none */\
   void * client_data;		/* Available for use by application */\
-  boolean is_decompressor;	/* So common code can tell which is which */\
+  wxjpeg_boolean is_decompressor;	/* So common code can tell which is which */\
   int global_state		/* For checking call sequence validity */
 
 /* Routines that are to be used by both halves of the library are declared
@@ -317,10 +317,10 @@
    * set num_scans and scan_info to point to an array of scan definitions.
    */
 
-  boolean raw_data_in;		/* TRUE=caller supplies downsampled data */
-  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */
-  boolean optimize_coding;	/* TRUE=optimize entropy encoding parms */
-  boolean CCIR601_sampling;	/* TRUE=first samples are cosited */
+  wxjpeg_boolean raw_data_in;		/* TRUE=caller supplies downsampled data */
+  wxjpeg_boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */
+  wxjpeg_boolean optimize_coding;	/* TRUE=optimize entropy encoding parms */
+  wxjpeg_boolean CCIR601_sampling;	/* TRUE=first samples are cosited */
   int smoothing_factor;		/* 1..100, or 0 for no input smoothing */
   J_DCT_METHOD dct_method;	/* DCT algorithm selector */
 
@@ -334,7 +334,7 @@
 
   /* Parameters controlling emission of special markers. */
 
-  boolean write_JFIF_header;	/* should a JFIF marker be written? */
+  wxjpeg_boolean write_JFIF_header;	/* should a JFIF marker be written? */
   UINT8 JFIF_major_version;	/* What to write for the JFIF version number */
   UINT8 JFIF_minor_version;
   /* These three values are not used by the JPEG code, merely copied */
@@ -344,7 +344,7 @@
   UINT8 density_unit;		/* JFIF code for pixel size units */
   UINT16 X_density;		/* Horizontal pixel density */
   UINT16 Y_density;		/* Vertical pixel density */
-  boolean write_Adobe_marker;	/* should an Adobe marker be written? */
+  wxjpeg_boolean write_Adobe_marker;	/* should an Adobe marker be written? */
 
   /* State variable: index of next scanline to be written to
    * jpeg_write_scanlines().  Application may use this to control its
@@ -360,7 +360,7 @@
   /*
    * These fields are computed during compression startup
    */
-  boolean progressive_mode;	/* TRUE if scan script uses progressive mode */
+  wxjpeg_boolean progressive_mode;	/* TRUE if scan script uses progressive mode */
   int max_h_samp_factor;	/* largest h_samp_factor */
   int max_v_samp_factor;	/* largest v_samp_factor */
 
@@ -433,22 +433,22 @@
 
   double output_gamma;		/* image gamma wanted in output */
 
-  boolean buffered_image;	/* TRUE=multiple output passes */
-  boolean raw_data_out;		/* TRUE=downsampled data wanted */
+  wxjpeg_boolean buffered_image;	/* TRUE=multiple output passes */
+  wxjpeg_boolean raw_data_out;		/* TRUE=downsampled data wanted */
 
   J_DCT_METHOD dct_method;	/* IDCT algorithm selector */
-  boolean do_fancy_upsampling;	/* TRUE=apply fancy upsampling */
-  boolean do_block_smoothing;	/* TRUE=apply interblock smoothing */
+  wxjpeg_boolean do_fancy_upsampling;	/* TRUE=apply fancy upsampling */
+  wxjpeg_boolean do_block_smoothing;	/* TRUE=apply interblock smoothing */
 
-  boolean quantize_colors;	/* TRUE=colormapped output wanted */
+  wxjpeg_boolean quantize_colors;	/* TRUE=colormapped output wanted */
   /* the following are ignored if not quantize_colors: */
   J_DITHER_MODE dither_mode;	/* type of color dithering to use */
-  boolean two_pass_quantize;	/* TRUE=use two-pass color quantization */
+  wxjpeg_boolean two_pass_quantize;	/* TRUE=use two-pass color quantization */
   int desired_number_of_colors;	/* max # colors to use in created colormap */
   /* these are significant only in buffered-image mode: */
-  boolean enable_1pass_quant;	/* enable future use of 1-pass quantizer */
-  boolean enable_external_quant;/* enable future use of external colormap */
-  boolean enable_2pass_quant;	/* enable future use of 2-pass quantizer */
+  wxjpeg_boolean enable_1pass_quant;	/* enable future use of 1-pass quantizer */
+  wxjpeg_boolean enable_external_quant;/* enable future use of external colormap */
+  wxjpeg_boolean enable_2pass_quant;	/* enable future use of 2-pass quantizer */
 
   /* Description of actual output image that will be returned to application.
    * These fields are computed by jpeg_start_decompress().
@@ -535,8 +535,8 @@
   jpeg_component_info * comp_info;
   /* comp_info[i] describes component that appears i'th in SOF */
 
-  boolean progressive_mode;	/* TRUE if SOFn specifies progressive mode */
-  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */
+  wxjpeg_boolean progressive_mode;	/* TRUE if SOFn specifies progressive mode */
+  wxjpeg_boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */
 
   UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
   UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
@@ -547,17 +547,17 @@
   /* These fields record data obtained from optional markers recognized by
    * the JPEG library.
    */
-  boolean saw_JFIF_marker;	/* TRUE iff a JFIF APP0 marker was found */
+  wxjpeg_boolean saw_JFIF_marker;	/* TRUE iff a JFIF APP0 marker was found */
   /* Data copied from JFIF marker; only valid if saw_JFIF_marker is TRUE: */
   UINT8 JFIF_major_version;	/* JFIF version number */
   UINT8 JFIF_minor_version;
   UINT8 density_unit;		/* JFIF code for pixel size units */
   UINT16 X_density;		/* Horizontal pixel density */
   UINT16 Y_density;		/* Vertical pixel density */
-  boolean saw_Adobe_marker;	/* TRUE iff an Adobe APP14 marker was found */
+  wxjpeg_boolean saw_Adobe_marker;	/* TRUE iff an Adobe APP14 marker was found */
   UINT8 Adobe_transform;	/* Color transform code from Adobe marker */
 
-  boolean CCIR601_sampling;	/* TRUE=first samples are cosited */
+  wxjpeg_boolean CCIR601_sampling;	/* TRUE=first samples are cosited */
 
   /* Aside from the specific data retained from APPn markers known to the
    * library, the uninterpreted contents of any or all APPn and COM markers
@@ -715,7 +715,7 @@
   size_t free_in_buffer;	/* # of byte spaces remaining in buffer */
 
   JMETHOD(void, init_destination, (j_compress_ptr cinfo));
-  JMETHOD(boolean, empty_output_buffer, (j_compress_ptr cinfo));
+  JMETHOD(wxjpeg_boolean, empty_output_buffer, (j_compress_ptr cinfo));
   JMETHOD(void, term_destination, (j_compress_ptr cinfo));
 };
 
@@ -727,9 +727,9 @@
   size_t bytes_in_buffer;	/* # of bytes remaining in buffer */
 
   JMETHOD(void, init_source, (j_decompress_ptr cinfo));
-  JMETHOD(boolean, fill_input_buffer, (j_decompress_ptr cinfo));
+  JMETHOD(wxjpeg_boolean, fill_input_buffer, (j_decompress_ptr cinfo));
   JMETHOD(void, skip_input_data, (j_decompress_ptr cinfo, long num_bytes));
-  JMETHOD(boolean, resync_to_restart, (j_decompress_ptr cinfo, int desired));
+  JMETHOD(wxjpeg_boolean, resync_to_restart, (j_decompress_ptr cinfo, int desired));
   JMETHOD(void, term_source, (j_decompress_ptr cinfo));
 };
 
@@ -767,13 +767,13 @@
 				      JDIMENSION numrows));
   JMETHOD(jvirt_sarray_ptr, request_virt_sarray, (j_common_ptr cinfo,
 						  int pool_id,
-						  boolean pre_zero,
+						  wxjpeg_boolean pre_zero,
 						  JDIMENSION samplesperrow,
 						  JDIMENSION numrows,
 						  JDIMENSION maxaccess));
   JMETHOD(jvirt_barray_ptr, request_virt_barray, (j_common_ptr cinfo,
 						  int pool_id,
-						  boolean pre_zero,
+						  wxjpeg_boolean pre_zero,
 						  JDIMENSION blocksperrow,
 						  JDIMENSION numrows,
 						  JDIMENSION maxaccess));
@@ -782,12 +782,12 @@
 					   jvirt_sarray_ptr ptr,
 					   JDIMENSION start_row,
 					   JDIMENSION num_rows,
-					   boolean writable));
+					   wxjpeg_boolean writable));
   JMETHOD(JBLOCKARRAY, access_virt_barray, (j_common_ptr cinfo,
 					    jvirt_barray_ptr ptr,
 					    JDIMENSION start_row,
 					    JDIMENSION num_rows,
-					    boolean writable));
+					    wxjpeg_boolean writable));
   JMETHOD(void, free_pool, (j_common_ptr cinfo, int pool_id));
   JMETHOD(void, self_destruct, (j_common_ptr cinfo));
 
@@ -806,7 +806,7 @@
 /* Routine signature for application-supplied marker processing methods.
  * Need not pass marker code since it is stored in cinfo->unread_marker.
  */
-typedef JMETHOD(boolean, jpeg_marker_parser_method, (j_decompress_ptr cinfo));
+typedef JMETHOD(wxjpeg_boolean, jpeg_marker_parser_method, (j_decompress_ptr cinfo));
 
 
 /* Declarations for routines called by application.
@@ -917,24 +917,24 @@
 				      J_COLOR_SPACE colorspace));
 EXTERN(void) jpeg_default_colorspace JPP((j_compress_ptr cinfo));
 EXTERN(void) jpeg_set_quality JPP((j_compress_ptr cinfo, int quality,
-				   boolean force_baseline));
+				   wxjpeg_boolean force_baseline));
 EXTERN(void) jpeg_set_linear_quality JPP((j_compress_ptr cinfo,
 					  int scale_factor,
-					  boolean force_baseline));
+					  wxjpeg_boolean force_baseline));
 EXTERN(void) jpeg_add_quant_table JPP((j_compress_ptr cinfo, int which_tbl,
 				       const unsigned int *basic_table,
 				       int scale_factor,
-				       boolean force_baseline));
+				       wxjpeg_boolean force_baseline));
 EXTERN(int) jpeg_quality_scaling JPP((int quality));
 EXTERN(void) jpeg_simple_progression JPP((j_compress_ptr cinfo));
 EXTERN(void) jpeg_suppress_tables JPP((j_compress_ptr cinfo,
-				       boolean suppress));
+				       wxjpeg_boolean suppress));
 EXTERN(JQUANT_TBL *) jpeg_alloc_quant_table JPP((j_common_ptr cinfo));
 EXTERN(JHUFF_TBL *) jpeg_alloc_huff_table JPP((j_common_ptr cinfo));
 
 /* Main entry points for compression */
 EXTERN(void) jpeg_start_compress JPP((j_compress_ptr cinfo,
-				      boolean write_all_tables));
+				      wxjpeg_boolean write_all_tables));
 EXTERN(JDIMENSION) jpeg_write_scanlines JPP((j_compress_ptr cinfo,
 					     JSAMPARRAY scanlines,
 					     JDIMENSION num_lines));
@@ -960,7 +960,7 @@
 
 /* Decompression startup: read start of JPEG datastream to see what's there */
 EXTERN(int) jpeg_read_header JPP((j_decompress_ptr cinfo,
-				  boolean require_image));
+				  wxjpeg_boolean require_image));
 /* Return value is one of: */
 #define JPEG_SUSPENDED		0 /* Suspended due to lack of input data */
 #define JPEG_HEADER_OK		1 /* Found valid image datastream */
@@ -972,11 +972,11 @@
  */
 
 /* Main entry points for decompression */
-EXTERN(boolean) jpeg_start_decompress JPP((j_decompress_ptr cinfo));
+EXTERN(wxjpeg_boolean) jpeg_start_decompress JPP((j_decompress_ptr cinfo));
 EXTERN(JDIMENSION) jpeg_read_scanlines JPP((j_decompress_ptr cinfo,
 					    JSAMPARRAY scanlines,
 					    JDIMENSION max_lines));
-EXTERN(boolean) jpeg_finish_decompress JPP((j_decompress_ptr cinfo));
+EXTERN(wxjpeg_boolean) jpeg_finish_decompress JPP((j_decompress_ptr cinfo));
 
 /* Replaces jpeg_read_scanlines when reading raw downsampled data. */
 EXTERN(JDIMENSION) jpeg_read_raw_data JPP((j_decompress_ptr cinfo,
@@ -984,11 +984,11 @@
 					   JDIMENSION max_lines));
 
 /* Additional entry points for buffered-image mode. */
-EXTERN(boolean) jpeg_has_multiple_scans JPP((j_decompress_ptr cinfo));
-EXTERN(boolean) jpeg_start_output JPP((j_decompress_ptr cinfo,
+EXTERN(wxjpeg_boolean) jpeg_has_multiple_scans JPP((j_decompress_ptr cinfo));
+EXTERN(wxjpeg_boolean) jpeg_start_output JPP((j_decompress_ptr cinfo,
 				       int scan_number));
-EXTERN(boolean) jpeg_finish_output JPP((j_decompress_ptr cinfo));
-EXTERN(boolean) jpeg_input_complete JPP((j_decompress_ptr cinfo));
+EXTERN(wxjpeg_boolean) jpeg_finish_output JPP((j_decompress_ptr cinfo));
+EXTERN(wxjpeg_boolean) jpeg_input_complete JPP((j_decompress_ptr cinfo));
 EXTERN(void) jpeg_new_colormap JPP((j_decompress_ptr cinfo));
 EXTERN(int) jpeg_consume_input JPP((j_decompress_ptr cinfo));
 /* Return value is one of: */
@@ -1034,7 +1034,7 @@
 EXTERN(void) jpeg_destroy JPP((j_common_ptr cinfo));
 
 /* Default restart-marker-resync procedure for use by data source modules */
-EXTERN(boolean) jpeg_resync_to_restart JPP((j_decompress_ptr cinfo,
+EXTERN(wxjpeg_boolean) jpeg_resync_to_restart JPP((j_decompress_ptr cinfo,
 					    int desired));
 
 
Index: src/jpeg/jpegtran.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jpegtran.c,v
retrieving revision 1.1
retrieving revision 1.2
diff --unified -r1.1 -r1.2
--- src/jpeg/jpegtran.c	1999/04/17 17:54:07	1.1
+++ src/jpeg/jpegtran.c	2006/11/28 16:24:44	1.2
@@ -112,7 +112,7 @@
 
 LOCAL(int)
 parse_switches (j_compress_ptr cinfo, int argc, char **argv,
-		int last_file_arg_seen, boolean for_real)
+		int last_file_arg_seen, wxjpeg_boolean for_real)
 /* Parse optional switches.
  * Returns argv[] index of first file-name argument (== argc if none).
  * Any file names with indexes <= last_file_arg_seen are ignored;
@@ -124,7 +124,7 @@
 {
   int argn;
   char * arg;
-  boolean simple_progressive;
+  wxjpeg_boolean simple_progressive;
   char * scansarg = NULL;	/* saves -scans parm if any */
 
   /* Set up default JPEG parameters. */
@@ -176,7 +176,7 @@
     } else if (keymatch(arg, "debug", 1) || keymatch(arg, "verbose", 1)) {
       /* Enable debug printouts. */
       /* On first -d, print version identification */
-      static boolean printed_version = FALSE;
+      static wxjpeg_boolean printed_version = FALSE;
 
       if (! printed_version) {
 	fprintf(stderr, "Independent JPEG Group's JPEGTRAN, version %s\n%s\n",
Index: src/jpeg/jquant1.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jquant1.c,v
retrieving revision 1.2
retrieving revision 1.3
diff --unified -r1.2 -r1.3
--- src/jpeg/jquant1.c	2002/05/26 11:49:37	1.2
+++ src/jpeg/jquant1.c	2006/11/28 16:24:45	1.3
@@ -151,7 +151,7 @@
    * premultiplied as described above.  Since colormap indexes must fit into
    * JSAMPLEs, the entries of this array will too.
    */
-  boolean is_padded;		/* is the colorindex padded for odither? */
+  wxjpeg_boolean is_padded;		/* is the colorindex padded for odither? */
 
   int Ncolors[MAX_Q_COMPS];	/* # of values alloced to each component */
 
@@ -161,7 +161,7 @@
 
   /* Variables for Floyd-Steinberg dithering */
   FSERRPTR fserrors[MAX_Q_COMPS]; /* accumulated errors */
-  boolean on_odd_row;		/* flag to remember which row we are on */
+  wxjpeg_boolean on_odd_row;		/* flag to remember which row we are on */
 } my_cquantizer;
 
 typedef my_cquantizer * my_cquantize_ptr;
@@ -191,7 +191,7 @@
   int nc = cinfo->out_color_components; /* number of color components */
   int max_colors = cinfo->desired_number_of_colors;
   int total_colors, iroot, i, j;
-  boolean changed;
+  wxjpeg_boolean changed;
   long temp;
   static const int RGB_order[3] = { RGB_GREEN, RGB_RED, RGB_BLUE };
 
@@ -738,7 +738,7 @@
  */
 
 METHODDEF(void)
-start_pass_1_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
+start_pass_1_quant (j_decompress_ptr cinfo, wxjpeg_boolean is_pre_scan)
 {
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
   size_t arraysize;
Index: src/jpeg/jquant2.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/jpeg/jquant2.c,v
retrieving revision 1.2
retrieving revision 1.3
diff --unified -r1.2 -r1.3
--- src/jpeg/jquant2.c	2002/05/26 11:49:37	1.2
+++ src/jpeg/jquant2.c	2006/11/28 16:24:45	1.3
@@ -200,11 +200,11 @@
   /* Variables for accumulating image statistics */
   hist3d histogram;		/* pointer to the histogram */
 
-  boolean needs_zeroed;		/* TRUE if next pass must zero histogram */
+  wxjpeg_boolean needs_zeroed;		/* TRUE if next pass must zero histogram */
 
   /* Variables for Floyd-Steinberg dithering */
   FSERRPTR fserrors;		/* accumulated errors */
-  boolean on_odd_row;		/* flag to remember which row we are on */
+  wxjpeg_boolean on_odd_row;		/* flag to remember which row we are on */
   int * error_limiter;		/* table for clamping the applied error */
 } my_cquantizer;
 
@@ -1164,7 +1164,7 @@
  */
 
 METHODDEF(void)
-start_pass_2_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
+start_pass_2_quant (j_decompress_ptr cinfo, wxjpeg_boolean is_pre_scan)
 {
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
   hist3d histogram = cquantize->histogram;
Index: src/tiff/tif_jpeg.c
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/tiff/tif_jpeg.c,v
retrieving revision 1.3
retrieving revision 1.5
diff --unified -r1.3 -r1.5
--- src/tiff/tif_jpeg.c	2004/11/19 22:29:44	1.3
+++ src/tiff/tif_jpeg.c	2006/11/29 21:42:51	1.5
@@ -59,14 +59,23 @@
 
    http://bugzilla.remotesensing.org/show_bug.cgi?id=188
 */
-#if defined(__RPCNDR_H__)
-#define HAVE_BOOLEAN
-#define boolean unsigned int
+#if defined wxHACK_BOOLEAN || defined __RPCNDR_H__ || defined __WINE_RPCNDR_H
+    #define HAVE_BOOLEAN
+
+    #ifdef wxHACK_BOOLEAN
+        #define boolean wxHACK_BOOLEAN
+    #else
+        #define boolean int
+    #endif
 #endif
 
 #include "jpeglib.h"
 #include "jerror.h"
 
+#ifndef HAVE_WXJPEG_BOOLEAN
+typedef boolean wxjpeg_boolean;
+#endif
+
 /*
  * On some machines it may be worthwhile to use _setjmp or sigsetjmp
  * in place of plain setjmp.  These macros will make it easier.
@@ -239,20 +248,20 @@
 }
 
 static int
-TIFFjpeg_set_quality(JPEGState* sp, int quality, boolean force_baseline)
+TIFFjpeg_set_quality(JPEGState* sp, int quality, wxjpeg_boolean force_baseline)
 {
 	return CALLVJPEG(sp,
 	    jpeg_set_quality(&sp->cinfo.c, quality, force_baseline));
 }
 
 static int
-TIFFjpeg_suppress_tables(JPEGState* sp, boolean suppress)
+TIFFjpeg_suppress_tables(JPEGState* sp, wxjpeg_boolean suppress)
 {
 	return CALLVJPEG(sp, jpeg_suppress_tables(&sp->cinfo.c, suppress));
 }
 
 static int
-TIFFjpeg_start_compress(JPEGState* sp, boolean write_all_tables)
+TIFFjpeg_start_compress(JPEGState* sp, wxjpeg_boolean write_all_tables)
 {
 	return CALLVJPEG(sp,
 	    jpeg_start_compress(&sp->cinfo.c, write_all_tables));
@@ -285,7 +294,7 @@
 }
 
 static int
-TIFFjpeg_read_header(JPEGState* sp, boolean require_image)
+TIFFjpeg_read_header(JPEGState* sp, wxjpeg_boolean require_image)
 {
 	return CALLJPEG(sp, -1, jpeg_read_header(&sp->cinfo.d, require_image));
 }
@@ -353,7 +362,7 @@
 	sp->dest.free_in_buffer = (size_t) tif->tif_rawdatasize;
 }
 
-static boolean
+static wxjpeg_boolean
 std_empty_output_buffer(j_compress_ptr cinfo)
 {
 	JPEGState* sp = (JPEGState*) cinfo;
@@ -404,7 +413,7 @@
 	sp->dest.free_in_buffer = (size_t) sp->jpegtables_length;
 }
 
-static boolean
+static wxjpeg_boolean
 tables_empty_output_buffer(j_compress_ptr cinfo)
 {
 	JPEGState* sp = (JPEGState*) cinfo;
@@ -470,7 +479,7 @@
 	sp->src.bytes_in_buffer = (size_t) tif->tif_rawcc;
 }
 
-static boolean
+static wxjpeg_boolean
 std_fill_input_buffer(j_decompress_ptr cinfo)
 {
 	JPEGState* sp = (JPEGState* ) cinfo;

 	  	 
