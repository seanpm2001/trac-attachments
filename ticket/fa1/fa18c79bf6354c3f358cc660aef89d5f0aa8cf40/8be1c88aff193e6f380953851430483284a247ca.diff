Index: wxWidgets/src/generic/grid.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/generic/grid.cpp,v
retrieving revision 1.350
diff -u -8 -r1.350 grid.cpp
--- wxWidgets/src/generic/grid.cpp	2005/09/26 00:29:38	1.350
+++ wxWidgets/src/generic/grid.cpp	2005/09/29 03:01:55
@@ -202,17 +202,17 @@
         m_rowLabelWin = (wxGridRowLabelWindow *)NULL;
         m_colLabelWin = (wxGridColLabelWindow *)NULL;
     }
 
     wxGridWindow( wxGrid *parent,
                   wxGridRowLabelWindow *rowLblWin,
                   wxGridColLabelWindow *colLblWin,
                   wxWindowID id, const wxPoint &pos, const wxSize &size );
-    ~wxGridWindow(){}
+    ~wxGridWindow() {}
 
     void ScrollWindow( int dx, int dy, const wxRect *rect );
 
     wxGrid* GetOwner() { return m_owner; }
 
 private:
     wxGrid                   *m_owner;
     wxGridRowLabelWindow     *m_rowLabelWin;
@@ -228,17 +228,16 @@
     void OnFocus( wxFocusEvent& );
 
     DECLARE_DYNAMIC_CLASS(wxGridWindow)
     DECLARE_EVENT_TABLE()
     DECLARE_NO_COPY_CLASS(wxGridWindow)
 };
 
 
-
 class wxGridCellEditorEvtHandler : public wxEvtHandler
 {
 public:
     wxGridCellEditorEvtHandler(wxGrid* grid, wxGridCellEditor* editor)
         : m_grid(grid),
           m_editor(editor),
           m_inSetFocus(false)
     {
@@ -1018,17 +1017,17 @@
 }
 
 // return the value in the spin control if it is there (the text control otherwise)
 wxString wxGridCellNumberEditor::GetValue() const
 {
     wxString s;
 
 #if wxUSE_SPINCTRL
-    if( HasRange() )
+    if ( HasRange() )
     {
         long value = Spin()->GetValue();
         s.Printf(wxT("%ld"), value);
     }
     else
 #endif
     {
         s = Text()->GetValue();
@@ -1617,17 +1616,17 @@
                               wxDC& dc,
                               const wxRect& rect,
                               int WXUNUSED(row), int WXUNUSED(col),
                               bool isSelected)
 {
     dc.SetBackgroundMode( wxSOLID );
 
     // grey out fields if the grid is disabled
-    if( grid.IsEnabled() )
+    if ( grid.IsEnabled() )
     {
         if ( isSelected )
         {
             dc.SetBrush( wxBrush(grid.GetSelectionBackground(), wxSOLID) );
         }
         else
         {
             dc.SetBrush( wxBrush(attr.GetBackgroundColour(), wxSOLID) );
@@ -1651,17 +1650,17 @@
                                                      wxDC& dc,
                                                      bool isSelected)
 {
     dc.SetBackgroundMode( wxTRANSPARENT );
 
     // TODO some special colours for attr.IsReadOnly() case?
 
     // different coloured text when the grid is disabled
-    if( grid.IsEnabled() )
+    if ( grid.IsEnabled() )
     {
       if ( isSelected )
       {
           dc.SetTextBackground( grid.GetSelectionBackground() );
           dc.SetTextForeground( grid.GetSelectionForeground() );
       }
       else
       {
@@ -1747,20 +1746,22 @@
                 }
                 if (is_empty)
                     rect.width += grid.GetColSize(i);
                 else
                 {
                     i--;
                     break;
                 }
-                if (rect.width >= best_width) break;
+                if (rect.width >= best_width)
+                    break;
             }
             overflowCols = i - col - cell_cols + 1;
-            if (overflowCols >= cols) overflowCols = cols - 1;
+            if (overflowCols >= cols)
+                overflowCols = cols - 1;
         }
 
         if (overflowCols > 0) // redraw overflow cells w/ proper hilight
         {
             hAlign = wxALIGN_LEFT; // if oveflowed then it's left aligned
             wxRect clip = rect;
             clip.x += rectCell.width;
             // draw each overflow cell individually
@@ -2161,17 +2162,18 @@
 void wxGridCellAttr::MergeWith(wxGridCellAttr *mergefrom)
 {
     if ( !HasTextColour() && mergefrom->HasTextColour() )
         SetTextColour(mergefrom->GetTextColour());
     if ( !HasBackgroundColour() && mergefrom->HasBackgroundColour() )
         SetBackgroundColour(mergefrom->GetBackgroundColour());
     if ( !HasFont() && mergefrom->HasFont() )
         SetFont(mergefrom->GetFont());
-    if ( !HasAlignment() && mergefrom->HasAlignment() ){
+    if ( !HasAlignment() && mergefrom->HasAlignment() )
+    {
         int hAlign, vAlign;
         mergefrom->GetAlignment( &hAlign, &vAlign);
         SetAlignment(hAlign, vAlign);
     }
     if ( !HasSize() && mergefrom->HasSize() )
         mergefrom->GetSize( &m_sizeRows, &m_sizeCols );
 
     // Directly access member functions as GetRender/Editor don't just return
@@ -2263,31 +2265,35 @@
     }
 }
 
 
 void wxGridCellAttr::GetAlignment(int *hAlign, int *vAlign) const
 {
     if (HasAlignment())
     {
-        if ( hAlign ) *hAlign = m_hAlign;
-        if ( vAlign ) *vAlign = m_vAlign;
+        if ( hAlign )
+            *hAlign = m_hAlign;
+        if ( vAlign )
+            *vAlign = m_vAlign;
     }
     else if (m_defGridAttr && m_defGridAttr != this)
         m_defGridAttr->GetAlignment(hAlign, vAlign);
     else
     {
         wxFAIL_MSG(wxT("Missing default cell attribute"));
     }
 }
 
 void wxGridCellAttr::GetSize( int *num_rows, int *num_cols ) const
 {
-    if ( num_rows ) *num_rows = m_sizeRows;
-    if ( num_cols ) *num_cols = m_sizeCols;
+    if ( num_rows )
+        *num_rows = m_sizeRows;
+    if ( num_cols )
+        *num_cols = m_sizeCols;
 }
 
 // GetRenderer and GetEditor use a slightly different decision path about
 // which attribute to use.  If a non-default attr object has one then it is
 // used, otherwise the default editor or renderer is fetched from the grid and
 // used.  It should be the default for the data type of the cell.  If it is
 // NULL (because the table has a type that the grid does not have in its
 // registry,) then the grid's default editor or renderer is used.
@@ -2454,17 +2460,18 @@
                     coords.SetRow(row + numRows);
                 }
                 else
                 {
                     // ...or remove the attribute
                     // No need to DecRef the attribute itself since this is
                     // done be wxGridCellWithAttr's destructor!
                     m_attrs.RemoveAt(n);
-                    n--; count--;
+                    n--;
+                    count--;
                 }
             }
         }
     }
 }
 
 void wxGridCellAttrData::UpdateAttrCols( size_t pos, int numCols )
 {
@@ -2589,17 +2596,18 @@
                 // If rows deleted, either decrement row counter (if row still exists)
                 if ((size_t)rowOrCol >= pos - numRowsOrCols)
                     rowOrCol += numRowsOrCols;
                 else
                 {
                     m_rowsOrCols.RemoveAt(n);
                     m_attrs[n]->DecRef();
                     m_attrs.RemoveAt(n);
-                    n--; count--;
+                    n--;
+                    count--;
                 }
             }
         }
     }
 }
 
 // ----------------------------------------------------------------------------
 // wxGridCellAttrProvider
@@ -2627,74 +2635,83 @@
     if ( m_data )
     {
         switch(kind)
         {
             case (wxGridCellAttr::Any):
                 //Get cached merge attributes.
                 // Currenlty not used as no cache implemented as not mutiable
                 // attr = m_data->m_mergeAttr.GetAttr(row, col);
-                if(!attr)
+                if (!attr)
                 {
-                     //Basicaly implement old version.
+                     //Basically implement old version.
                     //Also check merge cache, so we don't have to re-merge every time..
                     wxGridCellAttr *attrcell = m_data->m_cellAttrs.GetAttr(row, col);
                     wxGridCellAttr *attrrow = m_data->m_rowAttrs.GetAttr(row);
                     wxGridCellAttr *attrcol = m_data->m_colAttrs.GetAttr(col);
 
-                    if((attrcell != attrrow) && (attrrow != attrcol) && (attrcell != attrcol)){
+                    if ((attrcell != attrrow) && (attrrow != attrcol) && (attrcell != attrcol))
+                    {
                         // Two or more are non NULL
                         attr = new wxGridCellAttr;
                         attr->SetKind(wxGridCellAttr::Merged);
 
                         //Order important..
-                        if(attrcell){
+                        if (attrcell)
+                        {
                             attr->MergeWith(attrcell);
                             attrcell->DecRef();
                         }
-                        if(attrcol){
+                        if (attrcol)
+                        {
                             attr->MergeWith(attrcol);
                             attrcol->DecRef();
                         }
-                        if(attrrow){
+                        if (attrrow)
+                        {
                             attr->MergeWith(attrrow);
                             attrrow->DecRef();
                         }
                         //store merge attr if cache implemented
                         //attr->IncRef();
                         //m_data->m_mergeAttr.SetAttr(attr, row, col);
                     }
                     else
                     {
                         // one or none is non null return it or null.
-                        if(attrrow) attr = attrrow;
-                        if(attrcol)
+                        if (attrrow)
+                            attr = attrrow;
+                        if (attrcol)
                         {
-                            if(attr)
+                            if (attr)
                                 attr->DecRef();
                             attr = attrcol;
                         }
-                        if(attrcell)
+                        if (attrcell)
                         {
-                            if(attr)
+                            if (attr)
                                 attr->DecRef();
                             attr = attrcell;
                         }
                     }
                 }
             break;
+
             case (wxGridCellAttr::Cell):
                 attr = m_data->m_cellAttrs.GetAttr(row, col);
             break;
+
             case (wxGridCellAttr::Col):
                 attr = m_data->m_colAttrs.GetAttr(col);
             break;
+
             case (wxGridCellAttr::Row):
                 attr = m_data->m_rowAttrs.GetAttr(row);
             break;
+
             default:
                 // unused as yet...
                 // (wxGridCellAttr::Default):
                 // (wxGridCellAttr::Merged):
             break;
         }
     }
     return attr;
@@ -2798,47 +2815,51 @@
         // check whether this is one of the standard ones, in which case
         // register it "on the fly"
 #if wxUSE_TEXTCTRL
         if ( typeName == wxGRID_VALUE_STRING )
         {
             RegisterDataType(wxGRID_VALUE_STRING,
                              new wxGridCellStringRenderer,
                              new wxGridCellTextEditor);
-        } else
+        }
+        else
 #endif // wxUSE_TEXTCTRL
 #if wxUSE_CHECKBOX
         if ( typeName == wxGRID_VALUE_BOOL )
         {
             RegisterDataType(wxGRID_VALUE_BOOL,
                              new wxGridCellBoolRenderer,
                              new wxGridCellBoolEditor);
-        } else
+        }
+        else
 #endif // wxUSE_CHECKBOX
 #if wxUSE_TEXTCTRL
         if ( typeName == wxGRID_VALUE_NUMBER )
         {
             RegisterDataType(wxGRID_VALUE_NUMBER,
                              new wxGridCellNumberRenderer,
                              new wxGridCellNumberEditor);
         }
         else if ( typeName == wxGRID_VALUE_FLOAT )
         {
             RegisterDataType(wxGRID_VALUE_FLOAT,
                              new wxGridCellFloatRenderer,
                              new wxGridCellFloatEditor);
-        } else
+        }
+        else
 #endif // wxUSE_TEXTCTRL
 #if wxUSE_COMBOBOX
         if ( typeName == wxGRID_VALUE_CHOICE )
         {
             RegisterDataType(wxGRID_VALUE_CHOICE,
                              new wxGridCellStringRenderer,
                              new wxGridCellChoiceEditor);
-        } else
+        }
+        else
 #endif // wxUSE_COMBOBOX
         {
             return wxNOT_FOUND;
         }
 
         // we get here only if just added the entry for this type, so return
         // the last index
         index = m_typeinfo.GetCount() - 1;
@@ -3030,17 +3051,16 @@
 bool wxGridTableBase::DeleteCols( size_t WXUNUSED(pos),
                                   size_t WXUNUSED(numCols) )
 {
     wxFAIL_MSG( wxT("Called grid table class function DeleteCols\nbut your derived table class does not override this function"));
 
     return false;
 }
 
-
 wxString wxGridTableBase::GetRowLabelValue( int row )
 {
     wxString s;
     s << row + 1; // RD: Starting the rows at zero confuses users, no matter
                   //     how much it makes sense to us geeks.
     return s;
 }
 
@@ -3052,30 +3072,30 @@
     //   etc.
 
     wxString s;
     unsigned int i, n;
     for ( n = 1; ; n++ )
     {
         s += (wxChar) (_T('A') + (wxChar)( col%26 ));
         col = col/26 - 1;
-        if ( col < 0 ) break;
+        if ( col < 0 )
+            break;
     }
 
     // reverse the string...
     wxString s2;
     for ( i = 0;  i < n;  i++ )
     {
         s2 += s[n-i-1];
     }
 
     return s2;
 }
 
-
 wxString wxGridTableBase::GetTypeName( int WXUNUSED(row), int WXUNUSED(col) )
 {
     return wxGRID_VALUE_STRING;
 }
 
 bool wxGridTableBase::CanGetValueAs( int WXUNUSED(row), int WXUNUSED(col),
                                      const wxString& typeName )
 {
@@ -3272,18 +3292,19 @@
     }
 
     return true;
 }
 
 bool wxGridStringTable::AppendRows( size_t numRows )
 {
     size_t curNumRows = m_data.GetCount();
-    size_t curNumCols = ( curNumRows > 0 ? m_data[0].GetCount() :
-                          ( GetView() ? GetView()->GetNumberCols() : 0 ) );
+    size_t curNumCols = ( curNumRows > 0
+                         ? m_data[0].GetCount()
+                         : ( GetView() ? GetView()->GetNumberCols() : 0 ) );
 
     wxArrayString sa;
     if ( curNumCols > 0 )
     {
         sa.Alloc( curNumCols );
         sa.Add( wxEmptyString, curNumCols );
     }
 
@@ -3326,16 +3347,17 @@
     if ( numRows >= curNumRows )
     {
         m_data.Clear();
     }
     else
     {
         m_data.RemoveAt( pos, numRows );
     }
+
     if ( GetView() )
     {
         wxGridTableMessage msg( this,
                                 wxGRIDTABLE_NOTIFY_ROWS_DELETED,
                                 pos,
                                 numRows );
 
         GetView()->ProcessTableMessage( msg );
@@ -3344,31 +3366,33 @@
     return true;
 }
 
 bool wxGridStringTable::InsertCols( size_t pos, size_t numCols )
 {
     size_t row, col;
 
     size_t curNumRows = m_data.GetCount();
-    size_t curNumCols = ( curNumRows > 0 ? m_data[0].GetCount() :
-                          ( GetView() ? GetView()->GetNumberCols() : 0 ) );
+    size_t curNumCols = ( curNumRows > 0
+                         ? m_data[0].GetCount()
+                         : ( GetView() ? GetView()->GetNumberCols() : 0 ) );
 
     if ( pos >= curNumCols )
     {
         return AppendCols( numCols );
     }
 
     for ( row = 0;  row < curNumRows;  row++ )
     {
         for ( col = pos;  col < pos + numCols;  col++ )
         {
             m_data[row].Insert( wxEmptyString, col );
         }
     }
+
     if ( GetView() )
     {
         wxGridTableMessage msg( this,
                                 wxGRIDTABLE_NOTIFY_COLS_INSERTED,
                                 pos,
                                 numCols );
 
         GetView()->ProcessTableMessage( msg );
@@ -3440,16 +3464,17 @@
         {
             m_data[row].Clear();
         }
         else
         {
             m_data[row].RemoveAt( pos, numCols );
         }
     }
+
     if ( GetView() )
     {
         wxGridTableMessage msg( this,
                                 wxGRIDTABLE_NOTIFY_COLS_DELETED,
                                 pos,
                                 numCols );
 
         GetView()->ProcessTableMessage( msg );
@@ -3512,17 +3537,16 @@
             m_colLabels.Add( wxGridTableBase::GetColLabelValue(i) );
         }
     }
 
     m_colLabels[col] = value;
 }
 
 
-
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
 
 IMPLEMENT_DYNAMIC_CLASS( wxGridRowLabelWindow, wxWindow )
 
 BEGIN_EVENT_TABLE( wxGridRowLabelWindow, wxWindow )
     EVT_PAINT( wxGridRowLabelWindow::OnPaint )
     EVT_MOUSEWHEEL( wxGridRowLabelWindow::OnMouseWheel)
@@ -3553,29 +3577,26 @@
     int x, y;
     m_owner->CalcUnscrolledPosition( 0, 0, &x, &y );
     dc.SetDeviceOrigin( 0, -y );
 
     wxArrayInt rows = m_owner->CalcRowLabelsExposed( GetUpdateRegion() );
     m_owner->DrawRowLabels( dc , rows );
 }
 
-
 void wxGridRowLabelWindow::OnMouseEvent( wxMouseEvent& event )
 {
     m_owner->ProcessRowLabelMouseEvent( event );
 }
 
-
 void wxGridRowLabelWindow::OnMouseWheel( wxMouseEvent& event )
 {
     m_owner->GetEventHandler()->ProcessEvent(event);
 }
 
-
 // This seems to be required for wxMotif otherwise the mouse
 // cursor must be in the cell edit control to get key events
 //
 void wxGridRowLabelWindow::OnKeyDown( wxKeyEvent& event )
 {
     if ( !m_owner->GetEventHandler()->ProcessEvent( event ) ) event.Skip();
 }
 
@@ -3585,17 +3606,16 @@
 }
 
 void wxGridRowLabelWindow::OnChar( wxKeyEvent& event )
 {
     if ( !m_owner->GetEventHandler()->ProcessEvent( event ) ) event.Skip();
 }
 
 
-
 //////////////////////////////////////////////////////////////////////
 
 IMPLEMENT_DYNAMIC_CLASS( wxGridColLabelWindow, wxWindow )
 
 BEGIN_EVENT_TABLE( wxGridColLabelWindow, wxWindow )
     EVT_PAINT( wxGridColLabelWindow::OnPaint )
     EVT_MOUSEWHEEL( wxGridColLabelWindow::OnMouseWheel)
     EVT_MOUSE_EVENTS( wxGridColLabelWindow::OnMouseEvent )
@@ -3625,44 +3645,45 @@
     int x, y;
     m_owner->CalcUnscrolledPosition( 0, 0, &x, &y );
     dc.SetDeviceOrigin( -x, 0 );
 
     wxArrayInt cols = m_owner->CalcColLabelsExposed( GetUpdateRegion() );
     m_owner->DrawColLabels( dc , cols );
 }
 
-
 void wxGridColLabelWindow::OnMouseEvent( wxMouseEvent& event )
 {
     m_owner->ProcessColLabelMouseEvent( event );
 }
 
 void wxGridColLabelWindow::OnMouseWheel( wxMouseEvent& event )
 {
     m_owner->GetEventHandler()->ProcessEvent(event);
 }
 
-
 // This seems to be required for wxMotif otherwise the mouse
 // cursor must be in the cell edit control to get key events
 //
 void wxGridColLabelWindow::OnKeyDown( wxKeyEvent& event )
 {
-    if ( !m_owner->GetEventHandler()->ProcessEvent( event ) ) event.Skip();
+    if ( !m_owner->GetEventHandler()->ProcessEvent( event ) )
+        event.Skip();
 }
 
 void wxGridColLabelWindow::OnKeyUp( wxKeyEvent& event )
 {
-    if ( !m_owner->GetEventHandler()->ProcessEvent( event ) ) event.Skip();
+    if ( !m_owner->GetEventHandler()->ProcessEvent( event ) )
+        event.Skip();
 }
 
 void wxGridColLabelWindow::OnChar( wxKeyEvent& event )
 {
-    if ( !m_owner->GetEventHandler()->ProcessEvent( event ) ) event.Skip();
+    if ( !m_owner->GetEventHandler()->ProcessEvent( event ) )
+        event.Skip();
 }
 
 
 //////////////////////////////////////////////////////////////////////
 
 IMPLEMENT_DYNAMIC_CLASS( wxGridCornerLabelWindow, wxWindow )
 
 BEGIN_EVENT_TABLE( wxGridCornerLabelWindow, wxWindow )
@@ -3707,23 +3728,21 @@
     dc.DrawLine( 0, 0, 0, client_height );
 
     dc.SetPen( *wxWHITE_PEN );
     dc.DrawLine( 1, 1, client_width-1, 1 );
     dc.DrawLine( 1, 1, 1, client_height-1 );
 #endif // __WXGTK__/!__WXGTK__
 }
 
-
 void wxGridCornerLabelWindow::OnMouseEvent( wxMouseEvent& event )
 {
     m_owner->ProcessCornerLabelMouseEvent( event );
 }
 
-
 void wxGridCornerLabelWindow::OnMouseWheel( wxMouseEvent& event )
 {
     m_owner->GetEventHandler()->ProcessEvent(event);
 }
 
 // This seems to be required for wxMotif otherwise the mouse
 // cursor must be in the cell edit control to get key events
 //
@@ -3762,47 +3781,43 @@
 wxGridWindow::wxGridWindow( wxGrid *parent,
                             wxGridRowLabelWindow *rowLblWin,
                             wxGridColLabelWindow *colLblWin,
                             wxWindowID id,
                             const wxPoint &pos,
                             const wxSize &size )
             : wxWindow( parent, id, pos, size, wxWANTS_CHARS | wxBORDER_NONE | wxCLIP_CHILDREN|wxFULL_REPAINT_ON_RESIZE,
                         wxT("grid window") )
-
 {
     m_owner = parent;
     m_rowLabelWin = rowLblWin;
     m_colLabelWin = colLblWin;
 }
 
-
 void wxGridWindow::OnPaint( wxPaintEvent &WXUNUSED(event) )
 {
     wxPaintDC dc( this );
     m_owner->PrepareDC( dc );
     wxRegion reg = GetUpdateRegion();
     wxGridCellCoordsArray DirtyCells = m_owner->CalcCellsExposed( reg );
     m_owner->DrawGridCellArea( dc , DirtyCells);
 #if WXGRID_DRAW_LINES
     m_owner->DrawAllGridLines( dc, reg );
 #endif
     m_owner->DrawGridSpace( dc );
     m_owner->DrawHighlight( dc , DirtyCells );
 }
 
-
 void wxGridWindow::ScrollWindow( int dx, int dy, const wxRect *rect )
 {
     wxWindow::ScrollWindow( dx, dy, rect );
     m_rowLabelWin->ScrollWindow( 0, dy, rect );
     m_colLabelWin->ScrollWindow( dx, 0, rect );
 }
 
-
 void wxGridWindow::OnMouseEvent( wxMouseEvent& event )
 {
     if (event.ButtonDown(wxMOUSE_BTN_LEFT) && FindFocus() != this)
         SetFocus();
 
     m_owner->ProcessGridCellMouseEvent( event );
 }
 
@@ -3811,27 +3826,30 @@
     m_owner->GetEventHandler()->ProcessEvent(event);
 }
 
 // This seems to be required for wxMotif/wxGTK otherwise the mouse
 // cursor must be in the cell edit control to get key events
 //
 void wxGridWindow::OnKeyDown( wxKeyEvent& event )
 {
-    if ( !m_owner->GetEventHandler()->ProcessEvent( event ) ) event.Skip();
+    if ( !m_owner->GetEventHandler()->ProcessEvent( event ) )
+        event.Skip();
 }
 
 void wxGridWindow::OnKeyUp( wxKeyEvent& event )
 {
-    if ( !m_owner->GetEventHandler()->ProcessEvent( event ) ) event.Skip();
+    if ( !m_owner->GetEventHandler()->ProcessEvent( event ) )
+        event.Skip();
 }
 
 void wxGridWindow::OnChar( wxKeyEvent& event )
 {
-    if ( !m_owner->GetEventHandler()->ProcessEvent( event ) ) event.Skip();
+    if ( !m_owner->GetEventHandler()->ProcessEvent( event ) )
+        event.Skip();
 }
 
 void wxGridWindow::OnEraseBackground( wxEraseEvent& WXUNUSED(event) )
 {
 }
 
 void wxGridWindow::OnFocus(wxFocusEvent& event)
 {
@@ -4348,32 +4366,34 @@
     if ( m_colLabelWin->IsShown() )
         ch -= m_colLabelHeight;
 
     // grid total size
     int w = m_numCols > 0 ? GetColRight(m_numCols - 1) + m_extraWidth + 1 : 0;
     int h = m_numRows > 0 ? GetRowBottom(m_numRows - 1) + m_extraHeight + 1 : 0;
 
     // take into account editor if shown
-    if( IsCellEditControlShown() )
+    if ( IsCellEditControlShown() )
     {
       int w2, h2;
       int r = m_currentCellCoords.GetRow();
       int c = m_currentCellCoords.GetCol();
       int x = GetColLeft(c);
       int y = GetRowTop(r);
 
       // how big is the editor
       wxGridCellAttr* attr = GetCellAttr(r, c);
       wxGridCellEditor* editor = attr->GetEditor(this, r, c);
       editor->GetControl()->GetSize(&w2, &h2);
       w2 += x;
       h2 += y;
-      if( w2 > w ) w = w2;
-      if( h2 > h ) h = h2;
+      if ( w2 > w )
+          w = w2;
+      if ( h2 > h )
+          h = h2;
       editor->DecRef();
       attr->DecRef();
     }
 
     // preserve (more or less) the previous position
     int x, y;
     GetViewStart( &x, &y );
 
@@ -4557,17 +4577,18 @@
             {
                 if ( m_currentCellCoords.GetRow() >= m_numRows )
                     m_currentCellCoords.Set( 0, 0 );
             }
 
             if ( m_selection )
                 m_selection->UpdateRows( pos, -((int)numRows) );
             wxGridCellAttrProvider * attrProvider = m_table->GetAttrProvider();
-            if (attrProvider) {
+            if (attrProvider)
+            {
                 attrProvider->UpdateAttrRows( pos, -((int)numRows) );
 // ifdef'd out following patch from Paul Gammans
 #if 0
                 // No need to touch column attributes, unless we
                 // removed _all_ rows, in this case, we remove
                 // all column attributes.
                 // I hate to do this here, but the
                 // needed data is not available inside UpdateAttrRows.
@@ -4688,17 +4709,18 @@
             {
                 if ( m_currentCellCoords.GetCol() >= m_numCols )
                   m_currentCellCoords.Set( 0, 0 );
             }
 
             if ( m_selection )
                 m_selection->UpdateCols( pos, -((int)numCols) );
             wxGridCellAttrProvider * attrProvider = m_table->GetAttrProvider();
-            if (attrProvider) {
+            if (attrProvider)
+            {
                 attrProvider->UpdateAttrCols( pos, -((int)numCols) );
 // ifdef'd out following patch from Paul Gammans
 #if 0
                 // No need to touch row attributes, unless we
                 // removed _all_ columns, in this case, we remove
                 // all row attributes.
                 // I hate to do this here, but the
                 // needed data is not available inside UpdateAttrCols.
@@ -5468,17 +5490,17 @@
             if (abs(m_startDragPos.x - pos.x) < 4 && abs(m_startDragPos.y - pos.y) < 4)
                 return;
         }
 
         m_isDragging = true;
         if ( m_cursorMode == WXGRID_CURSOR_SELECT_CELL )
         {
             // Hide the edit control, so it
-            // won't interfer with drag-shrinking.
+            // won't interfere with drag-shrinking.
             if ( IsCellEditControlShown() )
             {
                 HideCellEditControl();
                 SaveEditControlValue();
             }
 
             // Have we captured the mouse yet?
             if (! m_winCapture)
@@ -5770,17 +5792,17 @@
             // no default action at the moment
         }
     }
 
     // ------------ Moving and no button action
     //
     else if ( event.Moving() && !event.IsButton() )
     {
-        if( coords.GetRow() < 0 || coords.GetCol() < 0 )
+        if ( coords.GetRow() < 0 || coords.GetCol() < 0 )
         {
             // out of grid cell area
             ChangeCursorMode(WXGRID_CURSOR_SELECT_CELL);
             return;
         }
 
         int dragRow = YToEdgeOfRow( y );
         int dragCol = XToEdgeOfCol( x );
@@ -6201,17 +6223,19 @@
                mouseEv.ShiftDown(),
                mouseEv.AltDown(),
                mouseEv.MetaDown() );
        claimed = GetEventHandler()->ProcessEvent(gridEvt);
        vetoed = !gridEvt.IsAllowed();
    }
 
    // A Veto'd event may not be `claimed' so test this first
-   if (vetoed) return -1;
+   if (vetoed)
+       return -1;
+
    return claimed ? 1 : 0;
 }
 
 
 // Generate a grid event of specified type and return the result
 // of ProcessEvent().
 //
 int wxGrid::SendEvent( const wxEventType type,
@@ -6239,49 +6263,51 @@
                              this,
                              row, col );
 
         claimed = GetEventHandler()->ProcessEvent(gridEvt);
         vetoed  = !gridEvt.IsAllowed();
      }
 
     // A Veto'd event may not be `claimed' so test this first
-    if (vetoed) return -1;
+    if (vetoed)
+        return -1;
+
     return claimed ? 1 : 0;
 }
 
-
 void wxGrid::OnPaint( wxPaintEvent& WXUNUSED(event) )
 {
     wxPaintDC dc(this);  // needed to prevent zillions of paint events on MSW
 }
 
 void wxGrid::Refresh(bool eraseb, const wxRect* rect)
 {
     // Don't do anything if between Begin/EndBatch...
     // EndBatch() will do all this on the last nested one anyway.
     if (! GetBatchCount())
     {
         // Refresh to get correct scrolled position:
-        wxScrolledWindow::Refresh(eraseb,rect);
+        wxScrolledWindow::Refresh(eraseb, rect);
 
         if (rect)
         {
             int rect_x, rect_y, rectWidth, rectHeight;
             int width_label, width_cell, height_label, height_cell;
             int x, y;
 
             //Copy rectangle can get scroll offsets..
             rect_x = rect->GetX();
             rect_y = rect->GetY();
             rectWidth = rect->GetWidth();
             rectHeight = rect->GetHeight();
 
             width_label = m_rowLabelWidth - rect_x;
-            if (width_label > rectWidth) width_label = rectWidth;
+            if (width_label > rectWidth)
+                width_label = rectWidth;
 
             height_label = m_colLabelHeight - rect_y;
             if (height_label > rectHeight) height_label = rectHeight;
 
             if (rect_x > m_rowLabelWidth)
             {
                 x = rect_x - m_rowLabelWidth;
                 width_cell = rectWidth;
@@ -6851,17 +6877,18 @@
 
 
 // Note - this function only draws cells that are in the list of
 // exposed cells (usually set from the update region by
 // CalcExposedCells)
 //
 void wxGrid::DrawGridCellArea( wxDC& dc, const wxGridCellCoordsArray& cells )
 {
-    if ( !m_numRows || !m_numCols ) return;
+    if ( !m_numRows || !m_numCols )
+        return;
 
     int i, numCells = cells.GetCount();
     int row, col, cell_rows, cell_cols;
     wxGridCellCoordsArray redrawCells;
 
     for ( i = numCells-1; i >= 0;  i-- )
     {
         row = cells[i].GetRow();
@@ -6887,34 +6914,36 @@
                 for (int j = 0; j < count; j++)
                 {
                     if ( cell == redrawCells[j] )
                     {
                         marked = true;
                         break;
                     }
                 }
-                if (!marked) redrawCells.Add( cell );
+                if (!marked)
+                    redrawCells.Add( cell );
             }
             continue; // don't bother drawing this cell
         }
 
         // If this cell is empty, find cell to left that might want to overflow
         if (m_table && m_table->IsEmptyCell(row, col))
         {
             for ( int l = 0; l < cell_rows; l++ )
             {
                 // find a cell in this row to left alreay marked for repaint
                 int left = col;
                 for (int k = 0; k < int(redrawCells.GetCount()); k++)
                     if ((redrawCells[k].GetCol() < left) &&
                         (redrawCells[k].GetRow() == row))
-                        left=redrawCells[k].GetCol();
+                        left = redrawCells[k].GetCol();
 
-                if (left == col) left = 0; // oh well
+                if (left == col)
+                    left = 0; // oh well
 
                 for (int j = col-1; j >= left; j--)
                 {
                     if (!m_table->IsEmptyCell(row+l, j))
                     {
                         if (GetCellOverflow(row+l, j))
                         {
                             wxGridCellCoords cell(row+l, j);
@@ -6923,35 +6952,38 @@
                             for (int k = 0; k < numCells; k++)
                             {
                                 if ( cell == cells[k] )
                                 {
                                     marked = true;
                                     break;
                                 }
                             }
+
                             if (!marked)
                             {
                                 int count = redrawCells.GetCount();
                                 for (int k = 0; k < count; k++)
                                 {
                                     if ( cell == redrawCells[k] )
                                     {
                                         marked = true;
                                         break;
                                     }
                                 }
-                                if (!marked) redrawCells.Add( cell );
+                                if (!marked)
+                                    redrawCells.Add( cell );
                             }
                         }
                         break;
                     }
                 }
             }
         }
+
         DrawCell( dc, cells[i] );
     }
 
     numCells = redrawCells.GetCount();
 
     for ( i = numCells - 1; i >= 0;  i-- )
     {
         DrawCell( dc, redrawCells[i] );
@@ -7049,38 +7081,38 @@
 
     if (penWidth > 0)
     {
         // The center of th drawn line is where the position/width/height of
         // the rectangle is actually at, (on wxMSW atr least,) so we will
         // reduce the size of the rectangle to compensate for the thickness of
         // the line.  If this is too strange on non wxMSW platforms then
         // please #ifdef this appropriately.
-        rect.x += penWidth/2;
-        rect.y += penWidth/2;
-        rect.width -= penWidth-1;
-        rect.height -= penWidth-1;
+        rect.x += penWidth / 2;
+        rect.y += penWidth / 2;
+        rect.width -= penWidth - 1;
+        rect.height -= penWidth - 1;
 
 
         // Now draw the rectangle
         // use the cellHighlightColour if the cell is inside a selection, this
         // will ensure the cell is always visible.
-        dc.SetPen(wxPen(IsInSelection(row,col)?m_selectionForeground:m_cellHighlightColour, penWidth, wxSOLID));
+        dc.SetPen(wxPen(IsInSelection(row,col) ? m_selectionForeground : m_cellHighlightColour, penWidth, wxSOLID));
         dc.SetBrush(*wxTRANSPARENT_BRUSH);
         dc.DrawRectangle(rect);
     }
 
 #if 0
         // VZ: my experiments with 3d borders...
 
         // how to properly set colours for arbitrary bg?
         wxCoord x1 = rect.x,
                 y1 = rect.y,
-                x2 = rect.x + rect.width -1,
-                y2 = rect.y + rect.height -1;
+                x2 = rect.x + rect.width - 1,
+                y2 = rect.y + rect.height - 1;
 
         dc.SetPen(*wxWHITE_PEN);
         dc.DrawLine(x1, y1, x2, y1);
         dc.DrawLine(x1, y1, x1, y2);
 
         dc.DrawLine(x1 + 1, y2 - 1, x2 - 1, y2 - 1);
         dc.DrawLine(x2 - 1, y1 + 1, x2 - 1, y2 );
 
@@ -7153,17 +7185,18 @@
 void wxGrid::DrawAllGridLines( wxDC& dc, const wxRegion & WXUNUSED(reg) )
 {
 #if !WXGRID_DRAW_LINES
     return;
 #endif
 
     if ( !m_gridLinesEnabled ||
          !m_numRows ||
-         !m_numCols ) return;
+         !m_numCols )
+         return;
 
     int top, bottom, left, right;
 
 #if 0  //#ifndef __WXGTK__
     if (reg.IsEmpty())
     {
       int cw, ch;
       m_gridWin->GetClientSize(&cw, &ch);
@@ -7265,17 +7298,16 @@
         }
 
         if ( bot >= top )
         {
             dc.DrawLine( left, bot, right, bot );
         }
     }
 
-
     // vertical grid lines
     //
     for ( i = internalXToCol(left); i < m_numCols; i++ )
     {
         int colRight = GetColRight(i) - 1;
         if ( colRight > right )
         {
             break;
@@ -7284,31 +7316,30 @@
         if ( colRight >= left )
         {
             dc.DrawLine( colRight, top, colRight, bottom );
         }
     }
     dc.DestroyClippingRegion();
 }
 
-
 void wxGrid::DrawRowLabels( wxDC& dc ,const wxArrayInt& rows)
 {
-    if ( !m_numRows ) return;
+    if ( !m_numRows )
+        return;
 
     size_t i;
     size_t numLabels = rows.GetCount();
 
     for ( i = 0;  i < numLabels;  i++ )
     {
         DrawRowLabel( dc, rows[i] );
     }
 }
 
-
 void wxGrid::DrawRowLabel( wxDC& dc, int row )
 {
     if ( GetRowHeight(row) <= 0 || m_rowLabelWidth <= 0 )
         return;
 
     wxRect rect;
 #ifdef __WXGTK20__
     rect.SetX( 1 );
@@ -7346,31 +7377,30 @@
 
     rect.SetX( 2 );
     rect.SetY( GetRowTop(row) + 2 );
     rect.SetWidth( m_rowLabelWidth - 4 );
     rect.SetHeight( GetRowHeight(row) - 4 );
     DrawTextRectangle( dc, GetRowLabelValue( row ), rect, hAlign, vAlign );
 }
 
-
 void wxGrid::DrawColLabels( wxDC& dc,const wxArrayInt& cols )
 {
-    if ( !m_numCols ) return;
+    if ( !m_numCols )
+        return;
 
     size_t i;
     size_t numLabels = cols.GetCount();
 
     for ( i = 0;  i < numLabels;  i++ )
     {
         DrawColLabel( dc, cols[i] );
     }
 }
 
-
 void wxGrid::DrawColLabel( wxDC& dc, int col )
 {
     if ( GetColWidth(col) <= 0 || m_colLabelHeight <= 0 )
         return;
 
     int colLeft = GetColLeft(col);
 
     wxRect rect;
@@ -7420,17 +7450,16 @@
                                 int horizAlign,
                                 int vertAlign,
                                 int textOrientation )
 {
     wxArrayString lines;
 
     StringToLines( value, lines );
 
-
     //Forward to new API.
     DrawTextRectangle(  dc,
         lines,
         rect,
         horizAlign,
         vertAlign,
         textOrientation );
 
@@ -7445,93 +7474,94 @@
 {
     long textWidth, textHeight;
     long lineWidth, lineHeight;
     int nLines;
 
     dc.SetClippingRegion( rect );
 
     nLines = lines.GetCount();
-    if( nLines > 0 )
+    if ( nLines > 0 )
     {
         int l;
         float x = 0.0, y = 0.0;
 
-        if( textOrientation == wxHORIZONTAL )
+        if ( textOrientation == wxHORIZONTAL )
             GetTextBoxSize(dc, lines, &textWidth, &textHeight);
         else
             GetTextBoxSize( dc, lines, &textHeight, &textWidth );
 
         switch( vertAlign )
         {
         case wxALIGN_BOTTOM:
-            if( textOrientation == wxHORIZONTAL )
+            if ( textOrientation == wxHORIZONTAL )
                 y = rect.y + (rect.height - textHeight - 1);
             else
                 x = rect.x + rect.width - textWidth;
             break;
 
         case wxALIGN_CENTRE:
-            if( textOrientation == wxHORIZONTAL )
+            if ( textOrientation == wxHORIZONTAL )
                 y = rect.y + ((rect.height - textHeight)/2);
             else
                 x = rect.x + ((rect.width - textWidth)/2);
             break;
 
         case wxALIGN_TOP:
         default:
-            if( textOrientation == wxHORIZONTAL )
+            if ( textOrientation == wxHORIZONTAL )
                 y = rect.y + 1;
             else
                 x = rect.x + 1;
             break;
         }
 
         // Align each line of a multi-line label
-        for( l = 0; l < nLines; l++ )
+        for ( l = 0; l < nLines; l++ )
         {
             dc.GetTextExtent(lines[l], &lineWidth, &lineHeight);
 
             switch( horizAlign )
             {
             case wxALIGN_RIGHT:
-                if( textOrientation == wxHORIZONTAL )
+                if ( textOrientation == wxHORIZONTAL )
                     x = rect.x + (rect.width - lineWidth - 1);
                 else
                     y = rect.y + lineWidth + 1;
                 break;
 
             case wxALIGN_CENTRE:
-                if( textOrientation == wxHORIZONTAL )
+                if ( textOrientation == wxHORIZONTAL )
                     x = rect.x + ((rect.width - lineWidth)/2);
                 else
                     y = rect.y + rect.height - ((rect.height - lineWidth)/2);
                 break;
 
             case wxALIGN_LEFT:
             default:
-                if( textOrientation == wxHORIZONTAL )
+                if ( textOrientation == wxHORIZONTAL )
                     x = rect.x + 1;
                 else
                     y = rect.y + rect.height - 1;
                 break;
             }
 
-            if( textOrientation == wxHORIZONTAL )
+            if ( textOrientation == wxHORIZONTAL )
             {
                 dc.DrawText( lines[l], (int)x, (int)y );
                 y += lineHeight;
             }
             else
             {
                 dc.DrawRotatedText( lines[l], (int)x, (int)y, 90.0 );
                 x += lineHeight;
             }
         }
     }
+
     dc.DestroyClippingRegion();
 }
 
 
 // Split multi line text up into an array of strings.  Any existing
 // contents of the string array are preserved.
 //
 void wxGrid::StringToLines( const wxString& value, wxArrayString& lines )
@@ -7551,18 +7581,19 @@
         else if ( pos == 0 )
         {
             lines.Add( wxEmptyString );
         }
         else
         {
             lines.Add( value.Mid(startPos, pos) );
         }
-        startPos += pos+1;
+        startPos += pos + 1;
     }
+
     if ( startPos < (int)value.Length() )
     {
         lines.Add( value.Mid( startPos ) );
     }
 }
 
 
 void wxGrid::GetTextBoxSize( const wxDC& dc,
@@ -7620,33 +7651,33 @@
         return false;
 
     // redraw in the new state
     m_gridWin->Refresh();
 
     return true;
 }
 
+
 //
 // ------ Edit control functions
 //
 
-
 void wxGrid::EnableEditing( bool edit )
 {
     // TODO: improve this ?
     //
     if ( edit != m_editable )
     {
-        if(!edit) EnableCellEditControl(edit);
+        if (!edit)
+            EnableCellEditControl(edit);
         m_editable = edit;
     }
 }
 
-
 void wxGrid::EnableCellEditControl( bool enable )
 {
     if (! m_editable)
         return;
 
     if ( m_currentCellCoords == wxGridNoCellCoords )
         SetCurrentCell( 0, 0 );
 
@@ -7802,16 +7833,17 @@
             wxString value = GetCellValue(row, col);
             if ( (value != wxEmptyString) && (attr->GetOverflow()) )
             {
                 int y;
                 GetTextExtent(value, &maxWidth, &y,
                         NULL, NULL, &attr->GetFont());
                 if (maxWidth < rect.width) maxWidth = rect.width;
             }
+
             int client_right = m_gridWin->GetClientSize().GetWidth();
             if (rect.x+maxWidth > client_right)
                 maxWidth = client_right - rect.x;
 
             if ((maxWidth > rect.width) && (col < m_numCols) && m_table)
             {
                 GetCellSize( row, col, &cell_rows, &cell_cols );
                 // may have changed earlier
@@ -7821,18 +7853,19 @@
                     GetCellSize( row, i, &c_rows, &c_cols );
                     // looks weird going over a multicell
                     if (m_table->IsEmptyCell(row,i) &&
                             (rect.width < maxWidth) && (c_rows == 1))
                         rect.width += GetColWidth(i);
                     else
                         break;
                 }
+
                 if (rect.GetRight() > client_right)
-                    rect.SetRight(client_right-1);
+                    rect.SetRight(client_right - 1);
             }
 
             editor->SetCellAttr(attr);
             editor->SetSize( rect );
             editor->Show( true, attr );
 
             // recalc dimensions in case we need to
             // expand the scrolled window to account for editor
@@ -7842,17 +7875,16 @@
             editor->SetCellAttr(NULL);
 
             editor->DecRef();
             attr->DecRef();
         }
     }
 }
 
-
 void wxGrid::HideCellEditControl()
 {
     if ( IsCellEditControlEnabled() )
     {
         int row = m_currentCellCoords.GetRow();
         int col = m_currentCellCoords.GetCol();
 
         wxGridCellAttr* attr = GetCellAttr(row, col);
@@ -7864,47 +7896,46 @@
         m_gridWin->SetFocus();
 
         // refresh whole row to the right
         wxRect rect( CellToRect(row, col) );
         CalcScrolledPosition(rect.x, rect.y, &rect.x, &rect.y );
         rect.width = m_gridWin->GetClientSize().GetWidth() - rect.x;
 #ifdef __WXMAC__
         // ensure that the pixels under the focus ring get refreshed as well
-        rect.Inflate(10,10);
+        rect.Inflate(10, 10);
 #endif
         m_gridWin->Refresh( false, &rect );
     }
 }
 
-
 void wxGrid::SaveEditControlValue()
 {
     if ( IsCellEditControlEnabled() )
     {
         int row = m_currentCellCoords.GetRow();
         int col = m_currentCellCoords.GetCol();
 
-        wxString oldval = GetCellValue(row,col);
+        wxString oldval = GetCellValue(row, col);
 
         wxGridCellAttr* attr = GetCellAttr(row, col);
         wxGridCellEditor* editor = attr->GetEditor(this, row, col);
         bool changed = editor->EndEdit(row, col, this);
 
         editor->DecRef();
         attr->DecRef();
 
         if (changed)
         {
             if ( SendEvent( wxEVT_GRID_CELL_CHANGE,
                        m_currentCellCoords.GetRow(),
-                       m_currentCellCoords.GetCol() ) < 0 ) {
-
+                       m_currentCellCoords.GetCol() ) < 0 )
+            {
                 // Event has been vetoed, set the data back.
-                SetCellValue(row,col,oldval);
+                SetCellValue(row, col, oldval);
             }
         }
     }
 }
 
 
 //
 // ------ Grid location functions
@@ -7933,49 +7964,49 @@
 // (unscrolled) coordinate value, using either
 // m_defaultRowHeight/m_defaultColWidth or binary search on array
 // of m_rowBottoms/m_ColRights to speed up the search!
 
 static int CoordToRowOrCol(int coord, int defaultDist, int minDist,
                            const wxArrayInt& BorderArray, int nMax,
                            bool clipToMinMax)
 {
-
     if (coord < 0)
         return clipToMinMax && (nMax > 0) ? 0 : -1;
 
-
     if (!defaultDist)
         defaultDist = 1;
 
     size_t i_max = coord / defaultDist,
            i_min = 0;
 
     if (BorderArray.IsEmpty())
     {
-        if((int) i_max < nMax)
+        if ((int) i_max < nMax)
             return i_max;
         return clipToMinMax ? nMax - 1 : -1;
     }
 
     if ( i_max >= BorderArray.GetCount())
         i_max = BorderArray.GetCount() - 1;
     else
     {
         if ( coord >= BorderArray[i_max])
         {
             i_min = i_max;
             if (minDist)
                 i_max = coord / minDist;
             else
                 i_max =  BorderArray.GetCount() - 1;
         }
+
         if ( i_max >= BorderArray.GetCount())
             i_max = BorderArray.GetCount() - 1;
     }
+
     if ( coord >= BorderArray[i_max])
         return clipToMinMax ? (int)i_max : -1;
     if ( coord < BorderArray[0] )
         return 0;
 
     while ( i_max - i_min > 0 )
     {
         wxCHECK_MSG(BorderArray[i_min] <= coord && coord < BorderArray[i_max],
@@ -7985,77 +8016,74 @@
         else
             i_max--;
         int median = i_min + (i_max - i_min + 1) / 2;
         if (coord < BorderArray[median])
             i_max = median;
         else
             i_min = median;
     }
+
     return i_max;
 }
 
 int wxGrid::YToRow( int y )
 {
     return CoordToRowOrCol(y, m_defaultRowHeight,
                            m_minAcceptableRowHeight, m_rowBottoms, m_numRows, false);
 }
 
-
 int wxGrid::XToCol( int x )
 {
     return CoordToRowOrCol(x, m_defaultColWidth,
                            m_minAcceptableColWidth, m_colRights, m_numCols, false);
 }
 
-
 // return the row number that that the y coord is near the edge of, or
 // -1 if not near an edge
 //
 int wxGrid::YToEdgeOfRow( int y )
 {
     int i;
     i = internalYToRow(y);
 
     if ( GetRowHeight(i) > WXGRID_LABEL_EDGE_ZONE )
     {
         // We know that we are in row i, test whether we are
         // close enough to lower or upper border, respectively.
         if ( abs(GetRowBottom(i) - y) < WXGRID_LABEL_EDGE_ZONE )
             return i;
-        else if( i > 0 && y - GetRowTop(i) < WXGRID_LABEL_EDGE_ZONE )
+        else if ( i > 0 && y - GetRowTop(i) < WXGRID_LABEL_EDGE_ZONE )
             return i - 1;
     }
 
     return -1;
 }
 
-
 // return the col number that that the x coord is near the edge of, or
 // -1 if not near an edge
 //
 int wxGrid::XToEdgeOfCol( int x )
 {
     int i;
     i = internalXToCol(x);
 
     if ( GetColWidth(i) > WXGRID_LABEL_EDGE_ZONE )
     {
         // We know that we are in column i,  test whether we are
         // close enough to right or left border, respectively.
         if ( abs(GetColRight(i) - x) < WXGRID_LABEL_EDGE_ZONE )
             return i;
-        else if( i > 0 && x - GetColLeft(i) < WXGRID_LABEL_EDGE_ZONE )
+        else if ( i > 0 && x - GetColLeft(i) < WXGRID_LABEL_EDGE_ZONE )
             return i - 1;
     }
 
     return -1;
 }
 
-
 wxRect wxGrid::CellToRect( int row, int col )
 {
     wxRect rect( -1, -1, -1, -1 );
 
     if ( row >= 0  &&  row < m_numRows  &&
          col >= 0  &&  col < m_numCols )
     {
         int i, cell_rows, cell_cols;
@@ -8070,24 +8098,25 @@
         rect.y = GetRowTop(row);
         for (i=col; i<col+cell_cols; i++)
             rect.width  += GetColWidth(i);
         for (i=row; i<row+cell_rows; i++)
             rect.height += GetRowHeight(i);
     }
 
     // if grid lines are enabled, then the area of the cell is a bit smaller
-    if (m_gridLinesEnabled) {
+    if (m_gridLinesEnabled)
+    {
         rect.width -= 1;
         rect.height -= 1;
     }
+
     return rect;
 }
 
-
 bool wxGrid::IsVisible( int row, int col, bool wholeCellVisible )
 {
     // get the cell rectangle in logical coords
     //
     wxRect r( CellToRect( row, col ) );
 
     // convert to device coords
     //
@@ -8111,23 +8140,21 @@
     {
         // is the cell partly visible ?
         //
         return ( ((left >=0 && left < cw) || (right > 0 && right <= cw))  &&
                  ((top >=0 && top < ch) || (bottom > 0 && bottom <= ch)) );
     }
 }
 
-
 // make the specified cell location visible by doing a minimal amount
 // of scrolling
 //
 void wxGrid::MakeCellVisible( int row, int col )
 {
-
     int i;
     int xpos = -1, ypos = -1;
 
     if ( row >= 0  &&  row < m_numRows  &&
          col >= 0  &&  col < m_numCols )
     {
         // get the cell rectangle in logical coords
         //
@@ -8223,16 +8250,17 @@
             ClearSelection();
             MakeCellVisible( m_currentCellCoords.GetRow() - 1,
                              m_currentCellCoords.GetCol() );
             SetCurrentCell( m_currentCellCoords.GetRow() - 1,
                             m_currentCellCoords.GetCol() );
         }
         else
             return false;
+
         return true;
     }
 
     return false;
 }
 
 
 bool wxGrid::MoveCursorDown( bool expandSelection )
@@ -8257,23 +8285,23 @@
             ClearSelection();
             MakeCellVisible( m_currentCellCoords.GetRow() + 1,
                              m_currentCellCoords.GetCol() );
             SetCurrentCell( m_currentCellCoords.GetRow() + 1,
                             m_currentCellCoords.GetCol() );
         }
         else
             return false;
+
         return true;
     }
 
     return false;
 }
 
-
 bool wxGrid::MoveCursorLeft( bool expandSelection )
 {
     if ( m_currentCellCoords != wxGridNoCellCoords  &&
          m_currentCellCoords.GetCol() >= 0 )
     {
         if ( expandSelection )
         {
             if ( m_selectingKeyboard == wxGridNoCellCoords )
@@ -8291,23 +8319,23 @@
             ClearSelection();
             MakeCellVisible( m_currentCellCoords.GetRow(),
                              m_currentCellCoords.GetCol() - 1 );
             SetCurrentCell( m_currentCellCoords.GetRow(),
                             m_currentCellCoords.GetCol() - 1 );
         }
         else
             return false;
+
         return true;
     }
 
     return false;
 }
 
-
 bool wxGrid::MoveCursorRight( bool expandSelection )
 {
     if ( m_currentCellCoords != wxGridNoCellCoords  &&
          m_currentCellCoords.GetCol() < m_numCols )
     {
         if ( expandSelection )
         {
             if ( m_selectingKeyboard == wxGridNoCellCoords )
@@ -8325,26 +8353,27 @@
             ClearSelection();
             MakeCellVisible( m_currentCellCoords.GetRow(),
                              m_currentCellCoords.GetCol() + 1 );
             SetCurrentCell( m_currentCellCoords.GetRow(),
                             m_currentCellCoords.GetCol() + 1 );
         }
         else
             return false;
+
         return true;
     }
 
     return false;
 }
 
-
 bool wxGrid::MovePageUp()
 {
-    if ( m_currentCellCoords == wxGridNoCellCoords ) return false;
+    if ( m_currentCellCoords == wxGridNoCellCoords )
+        return false;
 
     int row = m_currentCellCoords.GetRow();
     if ( row > 0 )
     {
         int cw, ch;
         m_gridWin->GetClientSize( &cw, &ch );
 
         int y = GetRowTop(row);
@@ -8362,17 +8391,18 @@
         return true;
     }
 
     return false;
 }
 
 bool wxGrid::MovePageDown()
 {
-    if ( m_currentCellCoords == wxGridNoCellCoords ) return false;
+    if ( m_currentCellCoords == wxGridNoCellCoords )
+        return false;
 
     int row = m_currentCellCoords.GetRow();
     if ( (row+1) < m_numRows )
     {
         int cw, ch;
         m_gridWin->GetClientSize( &cw, &ch );
 
         int y = GetRowTop(row);
@@ -8404,28 +8434,30 @@
         if ( m_table->IsEmptyCell(row, col) )
         {
             // starting in an empty cell: find the next block of
             // non-empty cells
             //
             while ( row > 0 )
             {
                 row-- ;
-                if ( !(m_table->IsEmptyCell(row, col)) ) break;
+                if ( !(m_table->IsEmptyCell(row, col)) )
+                    break;
             }
         }
         else if ( m_table->IsEmptyCell(row-1, col) )
         {
             // starting at the top of a block: find the next block
             //
             row--;
             while ( row > 0 )
             {
                 row-- ;
-                if ( !(m_table->IsEmptyCell(row, col)) ) break;
+                if ( !(m_table->IsEmptyCell(row, col)) )
+                    break;
             }
         }
         else
         {
             // starting within a block: find the top of the block
             //
             while ( row > 0 )
             {
@@ -8444,16 +8476,17 @@
             m_selectingKeyboard = wxGridCellCoords( row, col );
             HighlightBlock( m_currentCellCoords, m_selectingKeyboard );
         }
         else
         {
             ClearSelection();
             SetCurrentCell( row, col );
         }
+
         return true;
     }
 
     return false;
 }
 
 bool wxGrid::MoveCursorDownBlock( bool expandSelection )
 {
@@ -8467,28 +8500,30 @@
         if ( m_table->IsEmptyCell(row, col) )
         {
             // starting in an empty cell: find the next block of
             // non-empty cells
             //
             while ( row < m_numRows-1 )
             {
                 row++ ;
-                if ( !(m_table->IsEmptyCell(row, col)) ) break;
+                if ( !(m_table->IsEmptyCell(row, col)) )
+                    break;
             }
         }
         else if ( m_table->IsEmptyCell(row+1, col) )
         {
             // starting at the bottom of a block: find the next block
             //
             row++;
             while ( row < m_numRows-1 )
             {
                 row++ ;
-                if ( !(m_table->IsEmptyCell(row, col)) ) break;
+                if ( !(m_table->IsEmptyCell(row, col)) )
+                    break;
             }
         }
         else
         {
             // starting within a block: find the bottom of the block
             //
             while ( row < m_numRows-1 )
             {
@@ -8531,28 +8566,30 @@
         if ( m_table->IsEmptyCell(row, col) )
         {
             // starting in an empty cell: find the next block of
             // non-empty cells
             //
             while ( col > 0 )
             {
                 col-- ;
-                if ( !(m_table->IsEmptyCell(row, col)) ) break;
+                if ( !(m_table->IsEmptyCell(row, col)) )
+                    break;
             }
         }
         else if ( m_table->IsEmptyCell(row, col-1) )
         {
             // starting at the left of a block: find the next block
             //
             col--;
             while ( col > 0 )
             {
                 col-- ;
-                if ( !(m_table->IsEmptyCell(row, col)) ) break;
+                if ( !(m_table->IsEmptyCell(row, col)) )
+                    break;
             }
         }
         else
         {
             // starting within a block: find the left of the block
             //
             while ( col > 0 )
             {
@@ -8595,28 +8632,30 @@
         if ( m_table->IsEmptyCell(row, col) )
         {
             // starting in an empty cell: find the next block of
             // non-empty cells
             //
             while ( col < m_numCols-1 )
             {
                 col++ ;
-                if ( !(m_table->IsEmptyCell(row, col)) ) break;
+                if ( !(m_table->IsEmptyCell(row, col)) )
+                    break;
             }
         }
         else if ( m_table->IsEmptyCell(row, col+1) )
         {
             // starting at the right of a block: find the next block
             //
             col++;
             while ( col < m_numCols-1 )
             {
                 col++ ;
-                if ( !(m_table->IsEmptyCell(row, col)) ) break;
+                if ( !(m_table->IsEmptyCell(row, col)) )
+                    break;
             }
         }
         else
         {
             // starting within a block: find the right of the block
             //
             while ( col < m_numCols-1 )
             {
@@ -8856,17 +8895,17 @@
 //       does not support vertical printing
 //
 // Example: wxFont font(9, wxSWISS, wxNORMAL, wxBOLD);
 //                      pGrid->SetLabelFont(font);
 //                      pGrid->SetColLabelTextOrientation(wxVERTICAL);
 //
 void wxGrid::SetColLabelTextOrientation( int textOrientation )
 {
-    if( textOrientation == wxHORIZONTAL || textOrientation == wxVERTICAL )
+    if ( textOrientation == wxHORIZONTAL || textOrientation == wxVERTICAL )
     {
         m_colLabelTextOrientation = textOrientation;
     }
 
     if ( !GetBatchCount() )
     {
         m_colLabelWin->Refresh();
     }
@@ -8934,33 +8973,35 @@
         wxGridCellAttr* attr = GetCellAttr(m_currentCellCoords);
         DrawCellHighlight(dc, attr);
         attr->DecRef();
     }
 }
 
 void wxGrid::SetCellHighlightPenWidth(int width)
 {
-    if (m_cellHighlightPenWidth != width) {
+    if (m_cellHighlightPenWidth != width)
+    {
         m_cellHighlightPenWidth = width;
 
         // Just redrawing the cell highlight is not enough since that won't
         // make any visible change if the the thickness is getting smaller.
         int row = m_currentCellCoords.GetRow();
         int col = m_currentCellCoords.GetCol();
         if ( GetColWidth(col) <= 0 || GetRowHeight(row) <= 0 )
             return;
         wxRect rect = CellToRect(row, col);
         m_gridWin->Refresh(true, &rect);
     }
 }
 
 void wxGrid::SetCellHighlightROPenWidth(int width)
 {
-    if (m_cellHighlightROPenWidth != width) {
+    if (m_cellHighlightROPenWidth != width)
+    {
         m_cellHighlightROPenWidth = width;
 
         // Just redrawing the cell highlight is not enough since that won't
         // make any visible change if the the thickness is getting smaller.
         int row = m_currentCellCoords.GetRow();
         int col = m_currentCellCoords.GetCol();
         if ( GetColWidth(col) <= 0 || GetRowHeight(row) <= 0 )
             return;
@@ -9104,17 +9145,17 @@
 
 wxGridCellRenderer *wxGrid::GetDefaultRenderer() const
 {
     return m_defaultCellAttr->GetRenderer(NULL, 0, 0);
 }
 
 wxGridCellEditor *wxGrid::GetDefaultEditor() const
 {
-    return m_defaultCellAttr->GetEditor(NULL,0,0);
+    return m_defaultCellAttr->GetEditor(NULL, 0, 0);
 }
 
 // ----------------------------------------------------------------------------
 // access to cell attributes
 // ----------------------------------------------------------------------------
 
 wxColour wxGrid::GetCellBackgroundColour(int row, int col)
 {
@@ -9147,16 +9188,17 @@
     attr->DecRef();
 }
 
 bool wxGrid::GetCellOverflow( int row, int col )
 {
     wxGridCellAttr *attr = GetCellAttr(row, col);
     bool allow = attr->GetOverflow();
     attr->DecRef();
+
     return allow;
 }
 
 void wxGrid::GetCellSize( int row, int col, int *num_rows, int *num_cols )
 {
     wxGridCellAttr *attr = GetCellAttr(row, col);
     attr->GetSize( num_rows, num_cols );
     attr->DecRef();
@@ -9180,16 +9222,17 @@
     return editor;
 }
 
 bool wxGrid::IsReadOnly(int row, int col) const
 {
     wxGridCellAttr* attr = GetCellAttr(row, col);
     bool isReadOnly = attr->IsReadOnly();
     attr->DecRef();
+
     return isReadOnly;
 }
 
 // ----------------------------------------------------------------------------
 // attribute support: cache, automatic provider creation, ...
 // ----------------------------------------------------------------------------
 
 bool wxGrid::CanHaveAttributes()
@@ -9239,16 +9282,17 @@
 
         return true;
     }
     else
     {
 #ifdef DEBUG_ATTR_CACHE
         gs_nAttrCacheMisses++;
 #endif
+
         return false;
     }
 }
 
 wxGridCellAttr *wxGrid::GetCellAttr(int row, int col) const
 {
     wxGridCellAttr *attr = NULL;
     // Additional test to avoid looking at the cache e.g. for
@@ -9257,16 +9301,17 @@
     {
         if ( !LookupAttr(row, col, &attr) )
         {
             attr = m_table ? m_table->GetAttr(row, col , wxGridCellAttr::Any)
                            : (wxGridCellAttr *)NULL;
             CacheAttr(row, col, attr);
         }
     }
+
     if (attr)
     {
         attr->SetDefAttr(m_defaultCellAttr);
     }
     else
     {
         attr = m_defaultCellAttr;
         attr->IncRef();
@@ -9319,17 +9364,17 @@
     }
 
     SetColFormatCustom(col, typeName);
 }
 
 void wxGrid::SetColFormatCustom(int col, const wxString& typeName)
 {
     wxGridCellAttr *attr = m_table->GetAttr(-1, col, wxGridCellAttr::Col );
-    if(!attr)
+    if (!attr)
         attr = new wxGridCellAttr;
     wxGridCellRenderer *renderer = GetDefaultRendererForType(typeName);
     attr->SetRenderer(renderer);
 
     SetColAttr(col, attr);
 
 }
 
@@ -9540,49 +9585,54 @@
 }
 
 wxGridCellEditor*
 wxGrid::GetDefaultEditorForType(const wxString& typeName) const
 {
     int index = m_typeRegistry->FindOrCloneDataType(typeName);
     if ( index == wxNOT_FOUND )
     {
-        wxFAIL_MSG(wxT("Unknown data type name"));
+    wxString	errStr;
+
+        errStr.Printf(wxT("Unknown data type name [%s]"), typeName.c_str());
+        wxFAIL_MSG(errStr.c_str());
 
         return NULL;
     }
 
     return m_typeRegistry->GetEditor(index);
 }
 
 wxGridCellRenderer*
 wxGrid::GetDefaultRendererForType(const wxString& typeName) const
 {
     int index = m_typeRegistry->FindOrCloneDataType(typeName);
     if ( index == wxNOT_FOUND )
     {
-        wxFAIL_MSG(wxT("Unknown data type name"));
+    wxString	errStr;
 
+        errStr.Printf(wxT("Unknown data type name [%s]"), typeName.c_str());
+        wxFAIL_MSG(errStr.c_str());
+
         return NULL;
     }
 
     return m_typeRegistry->GetRenderer(index);
 }
 
 
 // ----------------------------------------------------------------------------
 // row/col size
 // ----------------------------------------------------------------------------
 
 void wxGrid::EnableDragRowSize( bool enable )
 {
     m_canDragRowSize = enable;
 }
 
-
 void wxGrid::EnableDragColSize( bool enable )
 {
     m_canDragColSize = enable;
 }
 
 void wxGrid::EnableDragGridSize( bool enable )
 {
     m_canDragGridSize = enable;
@@ -9610,17 +9660,18 @@
     }
 }
 
 void wxGrid::SetRowSize( int row, int height )
 {
     wxCHECK_RET( row >= 0 && row < m_numRows, _T("invalid row index") );
 
     // See comment in SetColSize
-    if ( height < GetRowMinimalAcceptableHeight()) { return; }
+    if ( height < GetRowMinimalAcceptableHeight())
+        return;
 
     if ( m_rowHeights.IsEmpty() )
     {
         // need to really create the array
         InitRowHeights();
     }
 
     int h = wxMax( 0, height );
@@ -9660,26 +9711,27 @@
     // should we check that it's bigger than GetColMinimalWidth(col) here?
     //                                                                 (VZ)
     // No, because it is reasonable to assume the library user know's
     // what he is doing. However whe should test against the weaker
     // constariant of minimalAcceptableWidth, as this breaks rendering
     //
     // This test then fixes sf.net bug #645734
 
-    if ( width < GetColMinimalAcceptableWidth()) { return; }
+    if ( width < GetColMinimalAcceptableWidth())
+        return;
 
     if ( m_colWidths.IsEmpty() )
     {
         // need to really create the array
         InitColWidths();
     }
 
     // if < 0 calc new width from label
-    if( width < 0 )
+    if ( width < 0 )
     {
       long w, h;
       wxArrayString lines;
       wxClientDC dc(m_colLabelWin);
       dc.SetFont(GetLabelFont());
       StringToLines(GetColLabelValue(col), lines);
       GetTextBoxSize(dc, lines, &w, &h);
       width = w + 6;
@@ -9692,28 +9744,29 @@
     for ( i = col;  i < m_numCols;  i++ )
     {
         m_colRights[i] += diff;
     }
     if ( !GetBatchCount() )
         CalcDimensions();
 }
 
-
 void wxGrid::SetColMinimalWidth( int col, int width )
 {
-    if (width > GetColMinimalAcceptableWidth()) {
+    if (width > GetColMinimalAcceptableWidth())
+    {
         wxLongToLongHashMap::key_type key = (wxLongToLongHashMap::key_type)col;
         m_colMinWidths[key] = width;
     }
 }
 
 void wxGrid::SetRowMinimalHeight( int row, int width )
 {
-    if (width > GetRowMinimalAcceptableHeight()) {
+    if (width > GetRowMinimalAcceptableHeight())
+    {
         wxLongToLongHashMap::key_type key = (wxLongToLongHashMap::key_type)row;
         m_rowMinHeights[key] = width;
     }
 }
 
 int wxGrid::GetColMinimalWidth(int col) const
 {
     wxLongToLongHashMap::key_type key = (wxLongToLongHashMap::key_type)col;
@@ -9727,26 +9780,26 @@
     wxLongToLongHashMap::const_iterator it = m_rowMinHeights.find(key);
     return it != m_rowMinHeights.end() ? (int)it->second : m_minAcceptableRowHeight;
 }
 
 void wxGrid::SetColMinimalAcceptableWidth( int width )
 {
     // We do allow a width of 0 since this gives us
     // an easy way to temporarily hidding columns.
-    if ( width<0 )
+    if ( width < 0 )
         return;
     m_minAcceptableColWidth = width;
 }
 
 void wxGrid::SetRowMinimalAcceptableHeight( int height )
 {
     // We do allow a height of 0 since this gives us
     // an easy way to temporarily hidding rows.
-    if ( height<0 )
+    if ( height < 0 )
         return;
     m_minAcceptableRowHeight = height;
 }
 
 int  wxGrid::GetColMinimalAcceptableWidth() const
 {
     return m_minAcceptableColWidth;
 }
@@ -9804,17 +9857,17 @@
 
     // now also compare with the column label extent
     wxCoord w, h;
     dc.SetFont( GetLabelFont() );
 
     if ( column )
     {
         dc.GetTextExtent( GetColLabelValue(col), &w, &h );
-        if( GetColLabelTextOrientation() == wxVERTICAL )
+        if ( GetColLabelTextOrientation() == wxVERTICAL )
             w = h;
     }
     else
         dc.GetTextExtent( GetRowLabelValue(row), &w, &h );
 
     extent = column ? w : h;
     if ( extent > extentMax )
     {
@@ -9997,103 +10050,106 @@
 }
 
 void wxGrid::AutoSizeRowLabelSize( int row )
 {
     wxArrayString lines;
     long w, h;
 
     // Hide the edit control, so it
-    // won't interfer with drag-shrinking.
-    if( IsCellEditControlShown() )
+    // won't interfere with drag-shrinking.
+    if ( IsCellEditControlShown() )
     {
         HideCellEditControl();
         SaveEditControlValue();
     }
 
     // autosize row height depending on label text
     StringToLines( GetRowLabelValue( row ), lines );
     wxClientDC dc( m_rowLabelWin );
     GetTextBoxSize( dc, lines, &w, &h);
-    if( h < m_defaultRowHeight )
+    if ( h < m_defaultRowHeight )
         h = m_defaultRowHeight;
     SetRowSize(row, h);
     ForceRefresh();
 }
 
 void wxGrid::AutoSizeColLabelSize( int col )
 {
     wxArrayString lines;
     long w, h;
 
     // Hide the edit control, so it
     // won't interfer with drag-shrinking.
-    if( IsCellEditControlShown() )
+    if ( IsCellEditControlShown() )
     {
         HideCellEditControl();
         SaveEditControlValue();
     }
 
     // autosize column width depending on label text
     StringToLines( GetColLabelValue( col ), lines );
     wxClientDC dc( m_colLabelWin );
-    if( GetColLabelTextOrientation() == wxHORIZONTAL )
+    if ( GetColLabelTextOrientation() == wxHORIZONTAL )
         GetTextBoxSize( dc, lines, &w, &h);
     else
         GetTextBoxSize( dc, lines, &h, &w);
-    if( w < m_defaultColWidth )
+    if ( w < m_defaultColWidth )
         w = m_defaultColWidth;
     SetColSize(col, w);
     ForceRefresh();
 }
 
 wxSize wxGrid::DoGetBestSize() const
 {
     // don't set sizes, only calculate them
     wxGrid *self = (wxGrid *)this;  // const_cast
 
     int width, height;
     width = self->SetOrCalcColumnSizes(true);
     height = self->SetOrCalcRowSizes(true);
-
-    if (!width) width=100;
-    if (!height) height=80;
 
-    // Round up to a multiple the scroll rate NOTE: this still doesn't get rid
-    // of the scrollbars, is there any magic incantaion for that?
+    if (!width)
+        width = 100;
+    if (!height)
+        height = 80;
+
+    // Round up to a multiple the scroll rate
+    // NOTE: this still doesn't get rid  of the scrollbars;
+    // is there any magic incantation for that?
     int xpu, ypu;
     GetScrollPixelsPerUnit(&xpu, &ypu);
     if (xpu)
         width  += 1 + xpu - (width  % xpu);
     if (ypu)
         height += 1 + ypu - (height % ypu);
 
     // limit to 1/4 of the screen size
     int maxwidth, maxheight;
-    wxDisplaySize( & maxwidth, & maxheight );
+    wxDisplaySize( &maxwidth, &maxheight );
     maxwidth /= 2;
     maxheight /= 2;
-    if ( width > maxwidth ) width = maxwidth;
-    if ( height > maxheight ) height = maxheight;
+    if ( width > maxwidth )
+        width = maxwidth;
+    if ( height > maxheight )
+        height = maxheight;
 
-
     wxSize best(width, height);
     // NOTE: This size should be cached, but first we need to add calls to
     // InvalidateBestSize everywhere that could change the results of this
     // calculation.
     // CacheBestSize(size);
     return best;
 }
 
 void wxGrid::Fit()
 {
     AutoSize();
 }
 
-
 wxPen& wxGrid::GetDividerPen() const
 {
     return wxNullPen;
 }
 
 // ----------------------------------------------------------------------------
 // cell value accessor functions
 // ----------------------------------------------------------------------------
@@ -10135,39 +10191,36 @@
 {
     if ( IsSelection() && !addToSelected )
         ClearSelection();
 
     if ( m_selection )
         m_selection->SelectRow( row, false, addToSelected );
 }
 
-
 void wxGrid::SelectCol( int col, bool addToSelected )
 {
     if ( IsSelection() && !addToSelected )
         ClearSelection();
 
     if ( m_selection )
         m_selection->SelectCol( col, false, addToSelected );
 }
 
-
 void wxGrid::SelectBlock( int topRow, int leftCol, int bottomRow, int rightCol,
                           bool addToSelected )
 {
     if ( IsSelection() && !addToSelected )
         ClearSelection();
 
     if ( m_selection )
         m_selection->SelectBlock( topRow, leftCol, bottomRow, rightCol,
                                   false, addToSelected );
 }
 
-
 void wxGrid::SelectAll()
 {
     if ( m_numRows > 0 && m_numCols > 0 )
     {
         if ( m_selection )
             m_selection->SelectBlock( 0, 0, m_numRows-1, m_numCols-1 );
     }
 }
@@ -10237,41 +10290,69 @@
              ( row >= m_selectingTopLeft.GetRow() &&
                col >= m_selectingTopLeft.GetCol() &&
                row <= m_selectingBottomRight.GetRow() &&
                col <= m_selectingBottomRight.GetCol() )) );
 }
 
 wxGridCellCoordsArray wxGrid::GetSelectedCells() const
 {
-    if (!m_selection) { wxGridCellCoordsArray a; return a; }
+    if (!m_selection)
+    {
+        wxGridCellCoordsArray a;
+        return a;
+    }
+
     return m_selection->m_cellSelection;
 }
+
 wxGridCellCoordsArray wxGrid::GetSelectionBlockTopLeft() const
 {
-    if (!m_selection) { wxGridCellCoordsArray a; return a; }
+    if (!m_selection)
+    {
+        wxGridCellCoordsArray a;
+        return a;
+    }
+
     return m_selection->m_blockSelectionTopLeft;
 }
+
 wxGridCellCoordsArray wxGrid::GetSelectionBlockBottomRight() const
 {
-    if (!m_selection) { wxGridCellCoordsArray a; return a; }
+    if (!m_selection)
+    {
+        wxGridCellCoordsArray a;
+        return a;
+    }
+
     return m_selection->m_blockSelectionBottomRight;
 }
+
 wxArrayInt wxGrid::GetSelectedRows() const
 {
-    if (!m_selection) { wxArrayInt a; return a; }
+    if (!m_selection)
+    {
+        wxArrayInt a;
+        return a;
+    }
+
     return m_selection->m_rowSelection;
 }
+
 wxArrayInt wxGrid::GetSelectedCols() const
 {
-    if (!m_selection) { wxArrayInt a; return a; }
+    if (!m_selection)
+    {
+        wxArrayInt a;
+        return a;
+    }
+
     return m_selection->m_colSelection;
 }
 
-
 void wxGrid::ClearSelection()
 {
     m_selectingTopLeft = wxGridNoCellCoords;
     m_selectingBottomRight = wxGridNoCellCoords;
     if ( m_selection )
         m_selection->ClearSelection();
 }
 
@@ -10317,17 +10398,17 @@
     int bottomRow = bottomRight.GetRow();
 
     if (left > right)
     {
         i = left;
         left = right;
         right = i;
         i = leftCol;
-        leftCol=rightCol;
+        leftCol = rightCol;
         rightCol = i;
     }
 
     if (top > bottom)
     {
         i = top;
         top = bottom;
         bottom = i;
@@ -10336,30 +10417,33 @@
         bottomRow = i;
     }
 
 
     for ( j = topRow; j <= bottomRow; j++ )
     {
         for ( i = leftCol; i <= rightCol; i++ )
         {
-            if ((j==topRow) || (j==bottomRow) || (i==leftCol) || (i==rightCol))
+            if ((j == topRow) || (j == bottomRow) || (i == leftCol) || (i == rightCol))
             {
                 cellRect = CellToRect( j, i );
 
                 if (cellRect.x < left)
                     left = cellRect.x;
                 if (cellRect.y < top)
                     top = cellRect.y;
                 if (cellRect.x + cellRect.width > right)
                     right = cellRect.x + cellRect.width;
                 if (cellRect.y + cellRect.height > bottom)
                     bottom = cellRect.y + cellRect.height;
+            }
+            else
+            {
+                i = rightCol; // jump over inner cells.
             }
-            else i = rightCol; // jump over inner cells.
         }
     }
 
     // convert to scrolled coords
     //
     CalcScrolledPosition( left, top, &left, &top );
     CalcScrolledPosition( right, bottom, &right, &bottom );
 

 	  	 
