diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/build/bakefiles/files.bkl wxWidgets-2.6.3-cvsp17/build/bakefiles/files.bkl
--- wxWidgets-cvs-20060425/build/bakefiles/files.bkl	2006-04-25 19:49:39.830200000 +0200
+++ wxWidgets-2.6.3-cvsp17/build/bakefiles/files.bkl	2006-04-25 20:10:54.734563500 +0200
@@ -54,6 +54,9 @@
 <!--                               UNIX                                     -->
 <!-- =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- -->
 <set var="BASE_UNIX_SRC" hints="files">
+    src/unix/app.cpp
+    src/unix/apptbase.cpp
+    src/unix/socketstable.cpp
     src/unix/baseunix.cpp
     src/unix/dir.cpp
     src/unix/dlunix.cpp
@@ -62,11 +65,13 @@
     src/unix/stackwalk.cpp
     src/unix/stdpaths.cpp
     src/unix/threadpsx.cpp
+    src/unix/timer.cpp
 </set>
 <set var="BASE_AND_GUI_UNIX_SRC" hints="files">
     src/unix/utilsunx.cpp
 </set>
 <set var="BASE_UNIX_HDR" hints="files">
+    wx/unix/app.h
     wx/unix/apptbase.h
     wx/unix/apptrait.h
     wx/unix/execute.h
@@ -74,12 +79,14 @@
     wx/unix/pipe.h
     wx/unix/stackwalk.h
     wx/unix/stdpaths.h
+    wx/unix/timer.h
 </set>
 
 <!-- =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- -->
 <!--                             Windows                                    -->
 <!-- =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- -->
 <set var="BASE_WIN32_SRC" hints="files">
+    src/msw/appcon.cpp
     src/msw/basemsw.cpp
     src/msw/crashrpt.cpp
     src/msw/debughlp.cpp
@@ -93,6 +100,7 @@
     src/msw/stackwalk.cpp
     src/msw/stdpaths.cpp
     src/msw/thread.cpp
+    src/msw/timer.cpp
     src/msw/utils.cpp
     src/msw/utilsexc.cpp
 </set>
@@ -100,11 +108,13 @@
     src/msw/main.cpp
     src/msw/mslu.cpp
     src/msw/volume.cpp
+    src/msw/gsockmsw.cpp
 </set>
 <set var="BASE_WINCE_SRC" hints="files">
     <if cond="TOOLKIT=='WINCE'">src/msw/wince/time.cpp</if>
 </set>
 <set var="BASE_WIN32_HDR" hints="files">
+    wx/msw/appcon.h
     wx/msw/apptrait.h
     wx/msw/apptbase.h
     wx/msw/chkconf.h
@@ -116,6 +126,7 @@
     wx/msw/mimetype.h
     wx/msw/stackwalk.h
     wx/msw/stdpaths.h
+    wx/msw/timer.h
     wx/msw/winundef.h
     wx/msw/wrapcctl.h
     wx/msw/wrapcdlg.h
@@ -325,6 +336,7 @@
     src/common/sysopt.cpp
     src/common/textbuf.cpp
     src/common/textfile.cpp
+    src/common/timercmn.cpp
     src/common/tokenzr.cpp
     src/common/txtstrm.cpp
     src/common/uri.cpp
@@ -600,7 +612,6 @@
     src/common/stockitem.cpp
     src/common/tbarbase.cpp
     src/common/textcmn.cpp
-    src/common/timercmn.cpp
     src/common/toplvcmn.cpp
     src/common/treebase.cpp
     src/common/valgen.cpp
@@ -1251,7 +1262,6 @@
     src/msw/fontutil.cpp
     src/msw/gdiimage.cpp
     src/msw/gdiobj.cpp
-    src/msw/gsockmsw.cpp
     src/msw/icon.cpp
     src/msw/minifram.cpp
     src/msw/ole/dataobj.cpp
@@ -1266,7 +1276,6 @@
     src/msw/region.cpp
     src/msw/renderer.cpp
     src/msw/settings.cpp
-    src/msw/timer.cpp
     src/msw/tooltip.cpp
     src/msw/toplevel.cpp
     src/msw/utilsgui.cpp
@@ -1420,7 +1429,6 @@
     wx/msw/tbarmsw.h
     wx/msw/textctrl.h
     wx/msw/tglbtn.h
-    wx/msw/timer.h
     wx/msw/tooltip.h
     wx/msw/toplevel.h
     wx/msw/treectrl.h
Files wxWidgets-cvs-20060425/build/bakefiles/wxwin.pyc and wxWidgets-2.6.3-cvsp17/build/bakefiles/wxwin.pyc differ
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/configure.in wxWidgets-2.6.3-cvsp17/configure.in
--- wxWidgets-cvs-20060425/configure.in	2006-04-25 19:49:33.725818500 +0200
+++ wxWidgets-2.6.3-cvsp17/configure.in	2006-04-25 20:10:54.754564750 +0200
@@ -1721,6 +1721,9 @@
   ;;
 esac
 
+dnl defines HAVE_SYS_EPOLL_H - for epoll mainloop implementation in wxbase
+AC_CHECK_HEADERS(sys/epoll.h)
+
 dnl ---------------------------------------------------------------------------
 dnl Checks for compiler characteristics
 dnl ---------------------------------------------------------------------------
@@ -6874,7 +6877,7 @@
         SAMPLES_SUBDIRS="$SAMPLES_SUBDIRS ownerdrw"
     fi
 else
-    SAMPLES_SUBDIRS="console"
+    SAMPLES_SUBDIRS="console sockbase"
 fi
 
 
@@ -7377,7 +7380,7 @@
             dnl don't take all samples/utils, just those which build with
             dnl wxBase
             if test ${subdir} = "samples"; then
-                makefiles="samples/Makefile.in samples/console/Makefile.in"
+                makefiles="samples/Makefile.in samples/console/Makefile.in samples/sockbase/Makefile.in"
             elif test ${subdir} = "utils"; then
                 makefiles=""
                 for util in HelpGen tex2rtf ; do
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/include/wx/app.h wxWidgets-2.6.3-cvsp17/include/wx/app.h
--- wxWidgets-cvs-20060425/include/wx/app.h	2006-04-25 19:50:54.698879000 +0200
+++ wxWidgets-2.6.3-cvsp17/include/wx/app.h	2006-04-25 20:10:54.758565000 +0200
@@ -578,8 +578,18 @@
         #include "wx/os2/app.h"
     #endif
 #else // !GUI
-    // allow using just wxApp (instead of wxAppConsole) in console programs
-    typedef wxAppConsole wxApp;
+    //wxApp is defined in core and we cannot define another one in wxBase
+    //We create different class and typedef it to wxApp instead
+    #if defined(__UNIX__)
+        #include "wx/unix/app.h"
+        typedef wxEventApp wxApp;
+    #elif defined(__WXMSW__)
+        #include "wx/msw/appcon.h"
+        typedef wxEventApp wxApp;
+    #else
+      // allow using just wxApp (instead of wxAppConsole) in console programs
+      typedef wxAppConsole wxApp;
+    #endif
 #endif // GUI/!GUI
 
 // ----------------------------------------------------------------------------
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/include/wx/mac/carbon/gsockmac.h wxWidgets-2.6.3-cvsp17/include/wx/mac/carbon/gsockmac.h
--- wxWidgets-cvs-20060425/include/wx/mac/carbon/gsockmac.h	2005-05-04 20:52:58.000000000 +0200
+++ wxWidgets-2.6.3-cvsp17/include/wx/mac/carbon/gsockmac.h	2006-04-25 20:10:54.758565000 +0200
@@ -67,7 +67,8 @@
     GSocketError SetSockOpt(int level, int optname,
         const void *optval, int optlen)
     {   return GSOCK_INVOP; }
-
+    //needed in wxBase for adding and removing socket descriptor from mainloop set
+    void Notify(bool pFlag) {};
 protected:
     bool m_ok;
 
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/include/wx/msw/appcon.h wxWidgets-2.6.3-cvsp17/include/wx/msw/appcon.h
--- wxWidgets-cvs-20060425/include/wx/msw/appcon.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.6.3-cvsp17/include/wx/msw/appcon.h	2006-04-25 20:10:54.758565000 +0200
@@ -0,0 +1,47 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/msw/appcon.h
+// Purpose:     wxAppConsole with wxMainLoop implementation
+// Author:      Lukasz Michalski
+// Modified by:
+// Created:     15/09/2005
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) Lukasz Michalski
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#include "wx/msw/gsockmsw.h"
+#include <wx/socket.h>
+
+#ifndef _APPCON_H_
+#define _APPCON_H_
+
+//Main application class
+class WXDLLIMPEXP_BASE wxEventApp : public wxAppConsole 
+{
+  public:
+    wxEventApp();
+    ~wxEventApp();
+    //Start program execution by entering main loop and waiting for events
+    virtual bool Initialize(int& argc, wxChar** argv);
+    virtual int OnRun();
+    virtual int MainLoop();
+    virtual void WakeUpIdle();
+    virtual void ExitMainLoop();
+    virtual void CleanUp();
+    virtual void Dispatch(); 
+
+    static bool initSocket(GSocket* pSocket, wxIPV4address* pAddress);
+    
+  private:
+    wxCriticalSection mWakeupCS;
+    bool mIsProcessingEvent;
+
+  protected:
+    bool mExiting;
+    int mExitCode;
+#if wxUSE_THREADS
+    DWORD mMSWThreadID;
+#endif
+};
+
+#endif //_APPCON_H_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/include/wx/msw/gsockmsw.h wxWidgets-2.6.3-cvsp17/include/wx/msw/gsockmsw.h
--- wxWidgets-cvs-20060425/include/wx/msw/gsockmsw.h	2005-05-04 20:53:02.000000000 +0200
+++ wxWidgets-2.6.3-cvsp17/include/wx/msw/gsockmsw.h	2006-04-25 20:10:54.758565000 +0200
@@ -78,6 +78,8 @@
     void *optval, int *optlen);
   GSocketError SetSockOpt(int level, int optname,
     const void *optval, int optlen);
+  //needed in wxBase for adding and removing socket descriptor from mainloop set
+  void Notify(bool) {};
 protected:
   GSocketError Input_Timeout();
   GSocketError Output_Timeout();
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/include/wx/timer.h wxWidgets-2.6.3-cvsp17/include/wx/timer.h
--- wxWidgets-cvs-20060425/include/wx/timer.h	2006-04-25 19:51:05.103529250 +0200
+++ wxWidgets-2.6.3-cvsp17/include/wx/timer.h	2006-04-25 20:10:54.758565000 +0200
@@ -19,7 +19,7 @@
 
 #include "wx/defs.h"
 
-#if wxUSE_GUI && wxUSE_TIMER
+#if wxUSE_TIMER && (!wxUSE_GUI || defined(__UNIX__) || defined(__WXMSW__))
 
 #include "wx/object.h"
 #include "wx/longlong.h"
@@ -112,6 +112,8 @@
 // wxTimer itself
 // ----------------------------------------------------------------------------
 
+#if wxUSE_GUI
+
 #if defined(__WXMSW__)
     #include "wx/msw/timer.h"
 #elif defined(__WXMOTIF__)
@@ -128,6 +130,14 @@
     #include "wx/os2/timer.h"
 #endif
 
+#else 
+  #if defined(__UNIX__)
+    #include "wx/unix/timer.h"
+  #elif defined(__WXMSW__)
+    #include "wx/msw/timer.h"
+  #endif
+#endif
+
 // ----------------------------------------------------------------------------
 // wxTimerRunner: starts the timer in its ctor, stops in the dtor
 // ----------------------------------------------------------------------------
@@ -195,7 +205,7 @@
 #define EVT_TIMER(timerid, func) \
     wx__DECLARE_EVT1(wxEVT_TIMER, timerid, wxTimerEventHandler(func))
 
-#endif // wxUSE_GUI && wxUSE_TIMER
+#endif // wxUSE_TIMER
 
 #endif
     // _WX_TIMER_H_BASE_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/include/wx/unix/app.h wxWidgets-2.6.3-cvsp17/include/wx/unix/app.h
--- wxWidgets-cvs-20060425/include/wx/unix/app.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.6.3-cvsp17/include/wx/unix/app.h	2006-04-25 20:10:54.758565000 +0200
@@ -0,0 +1,40 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/unix/app.h
+// Purpose:     wxAppConsole with wxMainLoop implementation
+// Author:      Lukasz Michalski
+// Modified by:
+// Created:     28/01/2005
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) Lukasz Michalski
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+extern "C" {
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+};
+
+//flag for timer set in handler
+extern volatile sig_atomic_t sig_alrm_catched;
+
+//Main application class
+class WXDLLIMPEXP_BASE wxEventApp : public wxAppConsole {
+    friend class GSocketGUIFunctionsTableBase;
+  public:
+    //Start program execution by entering main loop and waiting for events
+    virtual bool Initialize(int& argc, wxChar** argv);
+    virtual int OnRun();
+    virtual int MainLoop();
+    virtual void WakeUpIdle();
+    virtual void ExitMainLoop();
+    virtual void CleanUp();
+    virtual void Dispatch();
+  private:
+    bool mExiting;
+    //pipe for wake up messages.
+    //when child thread wants to wake up main thread it writes one byte to mWakeupPipe[1].
+    //Main thread goes out of select() [or epoll_wait()] and start processing events.
+    int mWakeupPipe[2];
+    int mExitCode;
+};
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/include/wx/unix/apptbase.h wxWidgets-2.6.3-cvsp17/include/wx/unix/apptbase.h
--- wxWidgets-cvs-20060425/include/wx/unix/apptbase.h	2004-09-26 18:28:51.000000000 +0200
+++ wxWidgets-2.6.3-cvsp17/include/wx/unix/apptbase.h	2006-04-25 20:10:54.758565000 +0200
@@ -48,6 +48,10 @@
     // ----------------
 
     // TODO
+
+    // Signal handling for unix
+    //-------------------------
+    virtual void BlockAllUnixSignals(bool pFlag);
 };
 
 #endif // _WX_UNIX_APPTBASE_H_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/include/wx/unix/gsockunx.h wxWidgets-2.6.3-cvsp17/include/wx/unix/gsockunx.h
--- wxWidgets-cvs-20060425/include/wx/unix/gsockunx.h	2005-05-04 20:53:05.000000000 +0200
+++ wxWidgets-2.6.3-cvsp17/include/wx/unix/gsockunx.h	2006-04-25 20:10:54.758565000 +0200
@@ -66,9 +66,15 @@
     GSocketError GetSockOpt(int level, int optname, void *optval, int *optlen);
     GSocketError SetSockOpt(int level, int optname,
         const void *optval, int optlen);
+    /**
+      Adds or removes socket from list of sockets that are watched for data by application
+      This function has no effect when used in child thread
+    */
+    void Notify(bool pFlag);
     virtual void Detected_Read();
     virtual void Detected_Write();
 protected:
+    void EnableEvents(bool pFlag);
     void Enable(GSocketEvent event);
     void Disable(GSocketEvent event);
     GSocketError Input_Timeout();
@@ -98,6 +104,7 @@
   GSocketCallback m_cbacks[GSOCK_MAX_EVENT];
   char *m_data[GSOCK_MAX_EVENT];
 
+  bool m_use_events;
   char *m_gui_dependent;
 
 };
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/include/wx/unix/socketstable.h wxWidgets-2.6.3-cvsp17/include/wx/unix/socketstable.h
--- wxWidgets-cvs-20060425/include/wx/unix/socketstable.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.6.3-cvsp17/include/wx/unix/socketstable.h	2006-04-25 20:10:54.758565000 +0200
@@ -0,0 +1,44 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/unix/socketstable.h
+// Purpose:     Sockets table for MainLoop implemented using select() call
+// Author:      Lukasz Michalski
+// Modified by:
+// Created:     28/01/2005
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) Lukasz Michalski
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#include "wx/unix/gsockunx.h"
+#include "wx/hashmap.h"
+#include "wx/thread.h"
+
+#ifndef HAVE_SYS_EPOLL_H
+
+WX_DECLARE_HASH_MAP(int,GSocket*,wxIntegerHash,wxIntegerEqual,SocketsTableType);
+
+class wxSocketsTable {
+  public:
+    wxSocketsTable();
+    void addGSocket(GSocket* pSocket);
+    void setWakeupPipeReadFd(int pFd);
+    void removeGSocket(GSocket* pSocket);
+    void enableGSockEvents(GSocket *pSocket, GSocketEvent event);
+    void disableGSockEvents(GSocket *pSocket, GSocketEvent event);
+    GSocket* findSocket(int pFd);
+    int getHigestFd() const{ return mHigestFd; };
+    fd_set getReadFdSet() const { return ar_fds; };
+    fd_set getWriteFdSet() const { return aw_fds; };
+    fd_set getExeptFdSet() const { return ae_fds; };
+  private:
+    SocketsTableType mSockets;
+    fd_set ar_fds;
+    fd_set aw_fds;
+    fd_set ae_fds;
+#ifdef wxUSE_THREADS
+    wxCriticalSection mSocketMapLocker;
+#endif
+    int mHigestFd;
+};
+
+#endif
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/include/wx/unix/timer.h wxWidgets-2.6.3-cvsp17/include/wx/unix/timer.h
--- wxWidgets-cvs-20060425/include/wx/unix/timer.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.6.3-cvsp17/include/wx/unix/timer.h	2006-05-30 10:19:14.164450500 +0200
@@ -0,0 +1,80 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/unix/timer.h
+// Purpose:     wxTimer for wxBase (unix)
+// Author:      Lukasz Michalski
+// Created:     15/01/2005
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) Lukasz Michalski
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_TIMER_H_UNIX_
+#define _WX_TIMER_H_UNIX_
+
+#include "wx/list.h"
+#include "wx/hashmap.h"
+#include "wx/event.h"
+
+class wxTimerEvent;
+
+/**@brief Defines interface for cooperation with global timer
+  *@author Lukasz Michalski
+  */
+class wxTimer : public wxTimerBase {
+  public:
+    wxTimer();
+    wxTimer(wxEvtHandler *owner, int timerid = wxID_ANY);
+    virtual ~wxTimer();
+
+    bool IsRunning() const;
+    bool Start(int pMilliseconds = -1, bool pOneShot = false);
+    void Stop();
+
+  protected:
+    bool mRunning;
+    friend class TimerScheduler;
+};
+
+struct wxTimerSchedule
+{
+    wxLongLong mExpire;
+    wxTimer *mTimer;
+};
+WX_DECLARE_LIST(wxTimerSchedule,TimerList);
+
+class TimerScheduler {
+  public:
+    TimerScheduler();
+    ~TimerScheduler() throw();
+
+    static void catch_alarm(int pSig);
+
+    /**
+      Adds request for notify to timer.
+      @param pRequester - pointer of requestor
+      @param pWhen - date when requestor wants to be notified
+    */
+    void addTimer(wxTimer* pRequester, wxLongLong pExpire);
+    /**
+      Remove requestor from timer queue. Called automatically in requestor destructor.
+    */
+    void removeTimer(wxTimer* pRequester);
+    /**
+      Called by wxApp::Dispatch() when global timer flag is set from catch_alarm signal handler
+    */
+    void processSignal();
+    void calculateSchedule();
+  private:
+    bool Start(long pMilliseconds);
+    void Stop();
+    void notifyCurrent();
+    void onTimerEvent(wxTimerEvent& pEvent);
+
+    TimerList mData;
+    bool mTimerRunning;
+    wxLongLong mNextExpiry;
+};
+
+extern TimerScheduler *gs_scheduler;
+
+#endif
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/include/wx/wx.h wxWidgets-2.6.3-cvsp17/include/wx/wx.h
--- wxWidgets-cvs-20060425/include/wx/wx.h	2005-05-04 20:52:06.000000000 +0200
+++ wxWidgets-2.6.3-cvsp17/include/wx/wx.h	2006-04-25 20:10:54.762565250 +0200
@@ -25,6 +25,11 @@
 #include "wx/utils.h"
 #include "wx/stream.h"
 
+#if defined (__WXMSW__) || defined(__UNIX__) || wxUSE_GUI
+  #include "wx/timer.h"
+#endif //defined (__WXMSW__) || defined(__UNIX__)
+
+
 #if wxUSE_GUI
 
 #include "wx/window.h"
@@ -85,6 +90,8 @@
     #include "wx/valtext.h"
 #endif // wxUSE_VALIDATORS
 
+#else
+
 #endif // wxUSE_GUI
 
 #endif // _WX_WX_H_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/samples/samples.bkl wxWidgets-2.6.3-cvsp17/samples/samples.bkl
--- wxWidgets-cvs-20060425/samples/samples.bkl	2006-04-25 19:51:46.854138500 +0200
+++ wxWidgets-2.6.3-cvsp17/samples/samples.bkl	2006-04-25 20:10:54.762565250 +0200
@@ -70,6 +70,7 @@
     <subproject id="scrollsub" template="sub"/>
     <subproject id="shaped" template="sub"/>
     <subproject id="sockets" template="sub"/>
+    <subproject id="sockbase" template="sub"/>
     <subproject id="sound" template="sub"/>
     <subproject id="splash" template="sub"/>
     <subproject id="splitter" template="sub"/>
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/samples/sockbase/sockbase.bkl wxWidgets-2.6.3-cvsp17/samples/sockbase/sockbase.bkl
--- wxWidgets-cvs-20060425/samples/sockbase/sockbase.bkl	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.6.3-cvsp17/samples/sockbase/sockbase.bkl	2006-04-25 20:10:54.762565250 +0200
@@ -0,0 +1,12 @@
+<?xml version="1.0" ?>
+<makefile>
+
+    <include file="../../build/bakefiles/common_samples.bkl"/>
+
+    <exe id="sockbase" template="wx_sample_console" template_append="wx_append_base">
+        <sources>sockbase.cpp</sources>
+        <wx-lib>net</wx-lib>
+        <wx-lib>base</wx-lib>
+    </exe>
+
+</makefile>
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/samples/sockbase/sockbase.cpp wxWidgets-2.6.3-cvsp17/samples/sockbase/sockbase.cpp
--- wxWidgets-cvs-20060425/samples/sockbase/sockbase.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.6.3-cvsp17/samples/sockbase/sockbase.cpp	2006-04-25 20:10:54.762565250 +0200
@@ -0,0 +1,587 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        samples/sockbase/client.cpp
+// Purpose:     Sockets sample for wxBase
+// Author:      Lukasz Michalski
+// Modified by:
+// Created:     27.06.2005
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) 2005 Lukasz Michalski <lmichalski@user.sourceforge.net>
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+
+// ============================================================================
+// declarations
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// headers
+// ----------------------------------------------------------------------------
+
+#include <wx/wx.h>
+#include <wx/socket.h>
+#include <wx/event.h>
+
+class EventServer;
+class EventClient;
+
+const wxEventType WXDLLEXPORT wxEVT_WORKER = wxNewEventType();
+#define EVT_WORKER(func) DECLARE_EVENT_TABLE_ENTRY( wxEVT_WORKER, -1, -1, (wxObjectEventFunction) (wxEventFunction) (WorkerEventFunction) & func, (wxObject *) NULL ),
+
+class WorkerEvent : public wxEvent {
+  public:
+    WorkerEvent(wxThread* pSender) {
+      SetId(-1);
+      SetEventType(wxEVT_WORKER);
+      mSender = pSender;
+    };
+    virtual wxEvent* Clone() const {
+      return new WorkerEvent(*this);
+    };
+  wxThread* mSender;
+};
+
+typedef void (wxEvtHandler::*WorkerEventFunction)(WorkerEvent&);
+
+
+class BaseSockTestApp : public wxApp {
+  public:
+    BaseSockTestApp();
+    virtual bool OnInit();
+    void onTestDone();
+    ~BaseSockTestApp() throw() {};
+    EventServer* mServer;
+  private:
+    enum {
+      tTWTC,
+      tTWTCW,
+      tEWEC
+    };
+    void TWTC();
+    void TWTCWait();
+    void EWEC();
+    EventClient* mClient;
+    void doNextTest();
+    bool mDone;
+    int mCurrentTest;
+};
+
+DECLARE_APP(BaseSockTestApp);
+
+static const int DATA_SIZE = 10;
+static const int READ_SIZE = 1;
+static const int WRITE_SIZE = 1;
+
+class EventClient : public wxEvtHandler {
+    DECLARE_EVENT_TABLE();
+  public:
+    EventClient(bool pIdle = false);
+    void start();
+    bool isTestEnded() const;
+    void onSocketEvent(wxSocketEvent& pEvent);
+    void doWrite();
+  private:
+    wxSocketClient* mClient;
+    char mBuf[DATA_SIZE];
+    int mToSend;
+    int mToRead;
+};
+
+class ThreadClient : public wxThread {
+  public:
+    ThreadClient();
+    void setWaitConnection(bool pFlag);
+    virtual ExitCode Entry();
+  private:
+    wxSocketClient* mClient;
+    bool mWaitConnection;
+};
+
+class ThreadWorker : public wxThread {
+  public:
+    ThreadWorker(wxSocketBase* pSocket);
+    virtual ExitCode Entry();
+  private:
+    wxSocketBase* mSocket;
+};  
+
+class EventWorker : public wxEvtHandler {
+    DECLARE_EVENT_TABLE();
+  public:
+    EventWorker(wxSocketBase* pSock);
+    ~EventWorker();
+    void start();
+    void onSocketEvent(wxSocketEvent& pEvent);
+    void doWrite();
+  private:
+    wxSocketBase* mSocket;
+    char mBuf[10000];
+    int mFill;
+};
+
+WX_DECLARE_LIST(ThreadWorker, TList);
+WX_DECLARE_LIST(EventWorker, EList);
+
+#include <wx/listimpl.cpp>
+WX_DEFINE_LIST(TList);
+WX_DEFINE_LIST(EList);
+
+class EventServer : public wxEvtHandler {
+    DECLARE_EVENT_TABLE();
+  public:
+    EventServer();
+    ~EventServer();
+    void setCreateThreads(bool pFlag);
+    void start();
+    void onSocketEvent(wxSocketEvent& pEvent);
+    void reinit();
+    void onWorkerEvent(WorkerEvent& pEvent);
+  private:
+    bool mCreateThreads;
+    wxSocketServer* mServer;
+    TList mThreadWorkers;
+    EList mEventWorkers;
+};
+
+/******************* Implementation ******************/
+
+EventClient::EventClient(bool) 
+{
+  mClient = new wxSocketClient(wxSOCKET_NOWAIT);
+  mClient->SetEventHandler(*this);
+  mToSend = DATA_SIZE;
+  mToRead = DATA_SIZE;
+};
+
+void 
+EventClient::start() {
+  wxIPV4address ca;
+  ca.Hostname(wxT("127.0.0.1"));
+  ca.Service(5678);
+  mClient->SetNotify(wxSOCKET_CONNECTION_FLAG|wxSOCKET_LOST_FLAG|wxSOCKET_OUTPUT_FLAG|wxSOCKET_INPUT_FLAG);
+  mClient->Notify(true);
+  wxLogDebug(wxT("EventClient: Connecting....."));
+  mClient->Connect(ca,false);
+};
+
+bool 
+EventClient::isTestEnded() const {
+  return mClient == NULL;
+};
+
+void 
+EventClient::onSocketEvent(wxSocketEvent& pEvent) {
+  switch(pEvent.GetSocketEvent()) {
+    case wxSOCKET_INPUT:
+      wxLogDebug(wxT("EventClient: INPUT"));
+      int readed;
+      do {
+        mClient->Read(mBuf,10000);
+        if (mClient->Error()) {
+          if (mClient->LastError() != wxSOCKET_WOULDBLOCK) {
+            wxLogError(wxT("Read error"));
+            mClient->Close();
+          } else {
+            readed = 0;
+          };
+        } else {
+          readed = mClient->LastCount();
+          wxLogDebug(wxT("EventClient: readed %d bytes"),readed);
+          mToRead -= readed;
+        };
+      } while (readed != 0);
+      if (mToRead == 0) {
+        mClient->Destroy();
+        mClient = NULL;
+        wxLogDebug(wxT("EventClient: done"));
+        wxGetApp().onTestDone();
+      };
+    break;
+    case wxSOCKET_OUTPUT:
+      wxLogDebug(wxT("EventClient: OUTPUT"));
+      doWrite();
+    break;
+    case wxSOCKET_CONNECTION:
+      wxLogDebug(wxT("EventClient: got connection"));
+    break;
+    case wxSOCKET_LOST:
+      wxLogDebug(wxT("EventClient: Connection lost"));
+    break;
+  };
+};
+
+void 
+EventClient::doWrite() {
+  if (mToSend == 0)
+    return;
+  mClient->Write(mBuf,mToSend);
+  if (mClient->Error()) {
+    if (mClient->LastError() != wxSOCKET_WOULDBLOCK) {
+      wxLogError(wxT("EventClient: Write error"));
+      return;
+    };
+  } else {
+    mToSend -= mClient->LastCount();
+  };
+  wxLogDebug(wxT("EventClient: written %d bytes, todo %d"),mClient->LastCount(),mToSend);
+};
+
+BEGIN_EVENT_TABLE(EventClient,wxEvtHandler)
+  EVT_SOCKET(wxID_ANY,EventClient::onSocketEvent)
+END_EVENT_TABLE()
+
+
+ThreadClient::ThreadClient() 
+  : wxThread(wxTHREAD_DETACHED)
+{
+  mWaitConnection = false;
+};
+
+void 
+ThreadClient::setWaitConnection(bool pFlag) {
+  mWaitConnection = pFlag;
+};
+
+wxThread::ExitCode 
+ThreadClient::Entry() {
+  mClient = new wxSocketClient(wxSOCKET_WAITALL|wxSOCKET_BLOCK);
+  wxIPV4address ca;
+  ca.Hostname(wxT("127.0.0.1"));
+  ca.Service(5678);
+  wxLogDebug(wxT("ThreadClient: Connecting....."));
+  if (!mClient->Connect(ca,!mWaitConnection)) {
+    if (mWaitConnection) {
+      do {
+        wxLogDebug(wxT("ThreadClient: failed, but waiting on connect....."));
+        if (mClient->WaitOnConnect(10))
+          break;
+      } while(true);
+    };
+  };
+  if (!mClient->IsConnected()) {
+    wxLogError(wxT("Connection failed"));
+    return 0;
+  };
+  wxLogDebug(wxT("ThreadClient: Connected. Sending data"));
+  int toSend = DATA_SIZE;
+  int toRead = DATA_SIZE;
+  int written = 0;
+  char buf[DATA_SIZE];
+  srand((unsigned int)this);
+  while(toSend) {
+    int to_write = WRITE_SIZE;
+    /*while(to_write == 0)
+      to_write = rand()%toSend;*/
+    wxLogDebug(wxT("ThreadClient: Writing data"));
+    mClient->Write(buf,to_write);
+    if (mClient->Error()) {
+      wxLogError(wxT("ThreadClient: Write error"));
+      mClient->Destroy();
+      return 0;
+    };
+    toRead = to_write;
+    toSend -= to_write;
+    written += to_write;
+    wxLogDebug(wxT("ThreadClient: %d bytes written"),written);
+    int to_read = READ_SIZE;
+    /* while(to_read == 0)
+      to_read = rand()%written;*/
+    wxLogDebug(wxT("ThreadClient: Reading data"));
+    mClient->Read(buf,to_read);
+    if (mClient->Error()) {
+      wxLogError(wxT("ThreadClient: Read error"));
+      mClient->Destroy();
+      return 0;
+    };
+    wxLogDebug(wxT("ThreadClient: %d bytes readed"),mClient->LastCount());
+    toRead -= to_read;
+  };
+  wxLogDebug(wxT("ThreadClient: Finished"));
+  mClient->Destroy();
+  mClient = NULL;
+  return 0;
+};
+
+ThreadWorker::ThreadWorker(wxSocketBase* pSocket) 
+  : wxThread(wxTHREAD_JOINABLE)
+{
+  mSocket = pSocket;
+};    
+
+wxThread::ExitCode 
+ThreadWorker::Entry() {
+  wxLogDebug(wxT("ThreadWorker: starting"));
+  mSocket->Notify(false);
+  mSocket->SetFlags(wxSOCKET_NONE|wxSOCKET_BLOCK);
+  if (!mSocket->IsConnected()) {
+    wxLogError(wxT("ThreadWorker: not connected"));
+    return 0;
+  };
+  while(mSocket->IsConnected()) {
+    char buf[10000];
+    wxLogDebug(wxT("ThreadWorker: reading data"));
+    mSocket->Read(buf,READ_SIZE);
+    if (mSocket->Error()) {
+      wxLogError(wxT("ThreadWorker: Read error"));
+      break;
+    };
+    int size = mSocket->LastCount();
+    wxLogDebug(wxT("ThreadWorker: %d bytes readed"),mSocket->LastCount());
+    while(size) {
+      wxLogDebug(wxT("ThreadWorker: writing data"));
+      mSocket->Write(buf,WRITE_SIZE);
+      if (mSocket->Error()) {
+        wxLogError(wxT("ThreadWorker: Write error"));
+        return 0;
+      };
+      wxLogDebug(wxT("ThreadWorker: %d bytes written"),mSocket->LastCount());
+      size -= mSocket->LastCount();
+    };
+  };
+  wxLogDebug(wxT("ThreadWorker: done"));
+  mSocket->Destroy();
+  WorkerEvent e(this);
+  wxGetApp().mServer->AddPendingEvent(e);
+  return 0;
+};
+
+EventWorker::EventWorker(wxSocketBase* pSock) {
+  wxLogDebug(wxT("Created event worker"));
+  mSocket = pSock;
+  mSocket->SetNotify(wxSOCKET_LOST_FLAG|wxSOCKET_INPUT_FLAG|wxSOCKET_OUTPUT_FLAG);
+  mSocket->Notify(true);
+  mSocket->SetEventHandler(*this);
+  mSocket->SetFlags(wxSOCKET_NOWAIT);
+  mFill = 0;
+};
+
+EventWorker::~EventWorker() {
+  mSocket->Destroy();
+};
+
+void 
+EventWorker::start() {
+  wxLogDebug(wxT("Event worker started"));
+  doWrite();
+};
+
+void 
+EventWorker::onSocketEvent(wxSocketEvent& pEvent) {
+  switch(pEvent.GetSocketEvent()) {
+    case wxSOCKET_INPUT:
+      mSocket->Read(mBuf,10000);
+      if (mSocket->Error()) {
+        if (mSocket->LastError() != wxSOCKET_WOULDBLOCK) {
+          wxLogError(wxT("Read error"));
+          mSocket->Close();
+        };
+      } else {
+        mFill = mSocket->LastCount();
+        doWrite();
+      };
+    break;
+    case wxSOCKET_OUTPUT:
+      doWrite();
+    break;
+    case wxSOCKET_CONNECTION:
+      wxLogError(wxT("Unexpected wxSOCKET_CONNECTION in EventWorker"));
+    break;
+    case wxSOCKET_LOST:
+      wxLogDebug(wxT("Connection lost"));
+    break;
+  };
+};  
+
+void 
+EventWorker::doWrite() {
+  if (mFill == 0)
+    return;
+  mSocket->Write(mBuf,mFill);
+  if (mSocket->Error()) {
+    if (mSocket->LastError() != wxSOCKET_WOULDBLOCK) {
+      wxLogError(wxT("Write error"));
+      return;
+    };
+  } else {
+    mFill -= mSocket->LastCount();
+  };
+  wxLogDebug(wxT("Written %d bytes, todo %d"),mSocket->LastCount(),mFill);
+};
+
+BEGIN_EVENT_TABLE(EventWorker,wxEvtHandler)
+  EVT_SOCKET(wxID_ANY,EventWorker::onSocketEvent)
+END_EVENT_TABLE()
+
+EventServer::EventServer() {
+  wxIPV4address la;
+  la.Service(5678);
+  mServer = new wxSocketServer(la,wxSOCKET_NOWAIT|wxSOCKET_REUSEADDR);
+  mServer->SetEventHandler(*this);
+  mCreateThreads = false;
+};
+
+EventServer::~EventServer() {
+  mServer->Destroy();
+};
+
+void 
+EventServer::setCreateThreads(bool pFlag) {
+  mCreateThreads = pFlag;
+};
+
+void 
+EventServer::start() {
+  mServer->SetNotify(wxSOCKET_CONNECTION_FLAG);
+  mServer->Notify(true);
+  wxASSERT(mServer->Ok());
+  wxLogDebug(wxT("Server started"));
+};
+
+void 
+EventServer::onSocketEvent(wxSocketEvent& pEvent) {
+  wxLogDebug(wxT("Server got event"));
+  switch(pEvent.GetSocketEvent()) {
+    case wxSOCKET_INPUT:
+      wxLogError(wxT("Unexpected wxSOCKET_INPUT in wxSocketServer"));
+    break;
+    case wxSOCKET_OUTPUT:
+      wxLogError(wxT("Unexpected wxSOCKET_OUTPUT in wxSocketServer"));
+    break;
+    case wxSOCKET_CONNECTION:
+    {
+      wxLogDebug(wxT("SOCK CONNECTION"));
+      wxSocketBase* sock = mServer->Accept();
+      if (mCreateThreads) {
+        ThreadWorker* c = new ThreadWorker(sock);
+        c->Create();
+        c->Run();
+        mThreadWorkers.Append(c);
+      } else {
+        EventWorker* w = new EventWorker(sock);
+        w->start();
+        mEventWorkers.Append(w);
+      };
+    }
+    break;
+    case wxSOCKET_LOST:
+      wxLogError(wxT("Unexpected wxSOCKET_LOST in wxSocketServer"));
+    break;
+  };
+};
+
+void 
+EventServer::reinit() {
+  for(TList::Node* it = mThreadWorkers.GetFirst(); it ; it = it->GetNext()) {
+    wxLogDebug(wxT("Deleting worker thread"));
+    it->GetData()->Wait();
+    delete it->GetData();
+  };
+  for(EList::Node* it = mEventWorkers.GetFirst(); it ; it->GetNext()) {
+    delete it->GetData();
+  };
+  mThreadWorkers.Clear();
+  mEventWorkers.Clear();
+};
+
+void 
+EventServer::onWorkerEvent(WorkerEvent& pEvent) {
+  wxLogDebug(wxT("Got worker event"));
+  pEvent.mSender->Wait();
+  for(TList::Node* it = mThreadWorkers.GetFirst(); it ; it = it->GetNext()) {
+    if (it->GetData() == pEvent.mSender) {
+      wxLogDebug(wxT("Deleting worker thread"));
+      it->GetData()->Wait();
+      delete it->GetData();
+      mThreadWorkers.DeleteNode(it);
+      if (mThreadWorkers.GetCount() == 0)
+        wxGetApp().onTestDone();
+      return;
+    };
+  };
+  wxASSERT(false);
+};
+
+BEGIN_EVENT_TABLE(EventServer,wxEvtHandler)
+  EVT_SOCKET(wxID_ANY,EventServer::onSocketEvent)
+  EVT_WORKER(EventServer::onWorkerEvent)
+END_EVENT_TABLE()
+
+WX_DECLARE_LIST(EventClient,ClientList);
+
+IMPLEMENT_APP(BaseSockTestApp)
+
+void
+BaseSockTestApp::TWTC() {
+  mCurrentTest = tTWTC;
+  //thread worker and thread client
+  mServer->reinit();
+  mServer->setCreateThreads(true);
+  ThreadClient* c = new ThreadClient();
+  c->Create();
+  c->Run();
+};
+
+void
+BaseSockTestApp::TWTCWait() {
+  mCurrentTest = tTWTCW;
+  //thread worker and thread client
+  mServer->reinit();
+  mServer->setCreateThreads(true);
+  ThreadClient* c = new ThreadClient();
+  c->setWaitConnection(true);
+  c->Create();
+  c->Run();
+};
+
+
+void
+BaseSockTestApp::EWEC() {
+  mCurrentTest = tEWEC;
+  mServer->reinit();
+  mServer->setCreateThreads(false);
+  mClient = new EventClient();
+  mClient->start();
+};
+
+
+bool
+BaseSockTestApp::OnInit() {
+  wxLog* logger = new wxLogStderr();
+  wxLog::AddTraceMask(wxT("baseapp"));
+  wxLog::AddTraceMask(wxT("wxSocket"));
+  wxLog::AddTraceMask(wxT("epoll"));
+  wxLog::AddTraceMask(wxT("thread"));
+  wxLog::SetActiveTarget(logger);
+  mServer = new EventServer();
+  mServer->start();
+//  TWTCWait();
+  TWTC();
+//  EWEC();
+  return true;
+};
+
+void 
+BaseSockTestApp::doNextTest() {
+  switch(mCurrentTest) {
+    case tTWTC:
+      TWTCWait();
+    break;
+    case tTWTCW:
+      EWEC();
+    break;
+    case tEWEC:
+      ExitMainLoop();
+    break;
+  };
+};
+
+void
+BaseSockTestApp::onTestDone() {
+  doNextTest();
+};
+
+BaseSockTestApp::BaseSockTestApp() 
+  : wxApp() 
+{
+  mDone = false;
+};
+
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/setup.h.in wxWidgets-2.6.3-cvsp17/setup.h.in
--- wxWidgets-cvs-20060425/setup.h.in	2006-04-25 19:49:33.733819000 +0200
+++ wxWidgets-2.6.3-cvsp17/setup.h.in	2006-04-25 20:10:54.782566500 +0200
@@ -947,6 +947,9 @@
 /* Define if you have the <langinfo.h> header file.  */
 #undef HAVE_LANGINFO_H
 
+/* Define if you have the <sys/epoll.h> header file.  */
+#undef HAVE_SYS_EPOLL_H
+
 /* Define if you have the <w32api.h> header file (mingw,cygwin).  */
 #undef HAVE_W32API_H
 
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/src/common/appbase.cpp wxWidgets-2.6.3-cvsp17/src/common/appbase.cpp
--- wxWidgets-cvs-20060425/src/common/appbase.cpp	2006-04-25 19:52:45.429799250 +0200
+++ wxWidgets-2.6.3-cvsp17/src/common/appbase.cpp	2006-04-25 20:10:54.782566500 +0200
@@ -272,35 +272,48 @@
     if ( !wxPendingEventsLocker )
         return;
 #endif
-    
+
+//All unix signals shoule be blocked inside pendig events 
+//loop because installed signal handler can try to call AddPedningEvent
+//when wxPendingEventsLocker is locked and this will cause deadlock.
+#if defined (__UNIX__)
+    GetTraits()->BlockAllUnixSignals(true);
+#endif
     // ensure that we're the only thread to modify the pending events list
     wxENTER_CRIT_SECT( *wxPendingEventsLocker );
 
-    if ( !wxPendingEvents )
+    if ( wxPendingEvents )
     {
-        wxLEAVE_CRIT_SECT( *wxPendingEventsLocker );
-        return;
-    }
+      // iterate until the list becomes empty
+      wxList::compatibility_iterator node = wxPendingEvents->GetFirst();
+      while (node)
+      {
+          wxEvtHandler *handler = (wxEvtHandler *)node->GetData();
+          wxPendingEvents->Erase(node);
+
+          // In ProcessPendingEvents(), new handlers might be add
+          // and we can safely leave the critical section here.
+          wxLEAVE_CRIT_SECT( *wxPendingEventsLocker );
+
+          #if defined (__UNIX__)
+          GetTraits()->BlockAllUnixSignals(false);
+          #endif
+
+          handler->ProcessPendingEvents();
+
+          #if defined (__UNIX__)
+          GetTraits()->BlockAllUnixSignals(true);
+          #endif
+          wxENTER_CRIT_SECT( *wxPendingEventsLocker );
 
-    // iterate until the list becomes empty
-    wxList::compatibility_iterator node = wxPendingEvents->GetFirst();
-    while (node)
-    {
-        wxEvtHandler *handler = (wxEvtHandler *)node->GetData();
-        wxPendingEvents->Erase(node);
-
-        // In ProcessPendingEvents(), new handlers might be add
-        // and we can safely leave the critical section here.
-        wxLEAVE_CRIT_SECT( *wxPendingEventsLocker );
-        
-        handler->ProcessPendingEvents();
-
-        wxENTER_CRIT_SECT( *wxPendingEventsLocker );
-
-        node = wxPendingEvents->GetFirst();
+          node = wxPendingEvents->GetFirst();
+      }
     }
 
     wxLEAVE_CRIT_SECT( *wxPendingEventsLocker );
+#if defined (__UNIX__)
+    GetTraits()->BlockAllUnixSignals(false);
+#endif
 }
 
 int wxAppConsole::FilterEvent(wxEvent& WXUNUSED(event))
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/src/common/event.cpp wxWidgets-2.6.3-cvsp17/src/common/event.cpp
--- wxWidgets-cvs-20060425/src/common/event.cpp	2006-04-25 19:52:48.950019250 +0200
+++ wxWidgets-2.6.3-cvsp17/src/common/event.cpp	2006-04-25 20:10:54.782566500 +0200
@@ -39,6 +39,7 @@
     #include "wx/defs.h"
     #include "wx/app.h"
     #include "wx/list.h"
+    #include "wx/apptrait.h"
 
     #if wxUSE_GUI
         #include "wx/control.h"
@@ -162,6 +163,9 @@
 DEFINE_EVENT_TYPE(wxEVT_NULL)
 DEFINE_EVENT_TYPE(wxEVT_IDLE)
 DEFINE_EVENT_TYPE(wxEVT_SOCKET)
+#if defined(__UNIX__) || defined(__WXMSW__)
+DEFINE_EVENT_TYPE(wxEVT_TIMER)
+#endif
 
 #endif // !WXWIN_COMPATIBILITY_EVENT_TYPES
 
@@ -188,9 +192,6 @@
 DEFINE_EVENT_TYPE(wxEVT_COMMAND_TOOL_ENTER)
 DEFINE_EVENT_TYPE(wxEVT_COMMAND_SPINCTRL_UPDATED)
 
-// Sockets and timers send events, too
-DEFINE_EVENT_TYPE(wxEVT_TIMER)
-
 // Mouse event types
 DEFINE_EVENT_TYPE(wxEVT_LEFT_DOWN)
 DEFINE_EVENT_TYPE(wxEVT_LEFT_UP)
@@ -1100,6 +1101,12 @@
     wxCHECK_RET( eventCopy,
                  _T("events of this type aren't supposed to be posted") );
 
+    //don't allow signal handlers to add peing events when we are
+    //inside critial sections
+    #if defined (__UNIX__)
+    wxTheApp->GetTraits()->BlockAllUnixSignals(true);
+    #endif
+
     wxENTER_CRIT_SECT( Lock() );
 
     if ( !m_pendingEvents )
@@ -1120,6 +1127,10 @@
 
     wxLEAVE_CRIT_SECT(*wxPendingEventsLocker);
 
+    #if defined (__UNIX__)
+    wxTheApp->GetTraits()->BlockAllUnixSignals(false);
+    #endif
+
     // 3) Inform the system that new pending events are somwehere,
     //    and that these should be processed in idle time.
     wxWakeUpIdle();
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/src/common/socket.cpp wxWidgets-2.6.3-cvsp17/src/common/socket.cpp
--- wxWidgets-cvs-20060425/src/common/socket.cpp	2006-04-25 19:52:49.410048000 +0200
+++ wxWidgets-2.6.3-cvsp17/src/common/socket.cpp	2006-04-25 20:10:54.782566500 +0200
@@ -179,7 +179,7 @@
   m_type         = wxSOCKET_UNINIT;
 
   // state
-  m_flags        = 0;
+  SetFlags(0);
   m_connected    =
   m_establishing =
   m_reading      =
@@ -218,7 +218,7 @@
 {
   Init();
 
-  m_flags = flags;
+  SetFlags(flags);
   m_type  = type;
 }
 
@@ -909,7 +909,11 @@
 
 void wxSocketBase::SetFlags(wxSocketFlags flags)
 {
+#ifdef wxUSE_GUI
   m_flags = flags;
+#else
+  m_flags = flags & wxSOCKET_BLOCK;
+#endif
 }
 
 
@@ -1014,6 +1018,8 @@
 void wxSocketBase::Notify(bool notify)
 {
   m_notify = notify;
+  if (m_socket)
+    m_socket->Notify(notify);
 }
 
 void wxSocketBase::SetNotify(wxSocketEventFlags flags)
@@ -1101,8 +1107,8 @@
         return;
     }
 
-        // Setup the socket as server
-
+    // Setup the socket as server
+    m_socket->Notify(m_notify);
     m_socket->SetLocal(addr_man.GetAddress());
 
     if (GetFlags() & wxSOCKET_REUSEADDR) {
@@ -1246,6 +1252,7 @@
   if (!m_socket)
     return false;
 
+  m_socket->Notify(m_notify);
   m_socket->SetTimeout(m_timeout * 1000);
   m_socket->SetCallback(GSOCK_INPUT_FLAG | GSOCK_OUTPUT_FLAG |
                                 GSOCK_LOST_FLAG | GSOCK_CONNECTION_FLAG,
@@ -1306,6 +1313,8 @@
     wxASSERT_MSG( 0, _T("datagram socket not new'd") );
     return;
   }
+  
+  m_socket->Notify(m_notify);
   // Setup the socket as non connection oriented
   m_socket->SetLocal(addr.GetAddress());
   if( m_socket->SetNonOriented() != GSOCK_NOERROR )
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/src/msw/appcon.cpp wxWidgets-2.6.3-cvsp17/src/msw/appcon.cpp
--- wxWidgets-cvs-20060425/src/msw/appcon.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.6.3-cvsp17/src/msw/appcon.cpp	2006-04-25 20:10:54.782566500 +0200
@@ -0,0 +1,117 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        appcon.cpp
+// Purpose:     wxApp for wxBase
+// Author:      Lukasz Michalski
+// Modified by:
+// Created:     04/01/98
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) Lukasz Michalski
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+// ===========================================================================
+// declarations
+// ===========================================================================
+
+// ---------------------------------------------------------------------------
+// headers
+// ---------------------------------------------------------------------------
+
+// For compilers that support precompilation, includes "wx.h".
+#include "wx/wxprec.h"
+
+wxEventApp::wxEventApp()
+ : mExiting(false)
+{
+};
+
+bool
+wxEventApp::Initialize(int& argc, wxChar** argv) 
+{
+  if (!wxAppConsole::Initialize(argc,argv))
+    return false;
+#if wxUSE_THREADS
+  mMSWThreadID = GetCurrentThreadId();
+#endif
+  wxPendingEventsLocker = new wxCriticalSection();
+  return true;
+};
+
+int
+wxEventApp::OnRun() {
+  return MainLoop();
+};
+
+int 
+wxEventApp::MainLoop()
+{
+  DWORD result;
+  HANDLE* lphObjects = NULL;
+  int cObjects = 0;
+
+  while(!mExiting) {
+#if wxUSE_EXCEPTIONS
+    try {    
+#endif
+      result = MsgWaitForMultipleObjects(cObjects, lphObjects, FALSE, INFINITE, QS_ALLEVENTS);
+      if (result == (WAIT_OBJECT_0 + cObjects)) {
+        Dispatch();
+      };
+#if wxUSE_EXCEPTIONS
+    } catch (...) {
+      if ( !wxTheApp || !wxTheApp->OnExceptionInMainLoop() )
+        return -1;
+    };
+#endif
+  };
+  return 0;
+};
+
+void
+wxEventApp::Dispatch() 
+{
+  MSG msg;
+
+  while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
+    if (msg.message == WM_QUIT) {
+      return;
+    } else if (msg.message == WM_TIMER) {
+      TIMERPROC proc = (TIMERPROC)msg.lParam;
+      (*proc)(NULL,0,msg.wParam,0);
+    } else {
+      ::DispatchMessage(&msg);
+    };
+  };
+  ProcessPendingEvents();
+};
+
+void
+wxEventApp::ExitMainLoop()
+{
+  mExiting = true;
+  WakeUpIdle();
+};
+
+void
+wxEventApp::CleanUp() 
+{
+  delete wxPendingEvents;
+  wxPendingEvents = NULL;
+
+  delete wxPendingEventsLocker;
+  wxPendingEventsLocker = NULL;
+};
+
+void
+wxEventApp::WakeUpIdle()
+{
+  if (!::PostThreadMessage(mMSWThreadID, WM_NULL, 0, 0) )
+  {
+    // should never happen
+    wxLogLastError(wxT("PostMessage(WM_NULL)"));
+  }
+};
+
+wxEventApp::~wxEventApp() 
+{
+};
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/src/msw/gsocket.cpp wxWidgets-2.6.3-cvsp17/src/msw/gsocket.cpp
--- wxWidgets-cvs-20060425/src/msw/gsocket.cpp	2006-04-25 19:53:31.244662500 +0200
+++ wxWidgets-2.6.3-cvsp17/src/msw/gsocket.cpp	2006-04-25 20:10:54.782566500 +0200
@@ -133,7 +133,7 @@
 
   if (!gs_gui_functions)
   {
-    static GSocketGUIFunctionsTableNull table;
+    static GSocketGUIFunctionsTableConcrete table;
     gs_gui_functions = &table;
   }
   if ( !gs_gui_functions->OnInit() )
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/src/unix/app.cpp wxWidgets-2.6.3-cvsp17/src/unix/app.cpp
--- wxWidgets-cvs-20060425/src/unix/app.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.6.3-cvsp17/src/unix/app.cpp	2006-04-25 20:10:54.786566750 +0200
@@ -0,0 +1,265 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/unix/app.cpp
+// Purpose:     wxAppConsole with wxMainLoop implementation
+// Author:      Lukasz Michalski
+// Modified by:
+// Created:     28/01/2005
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) Lukasz Michalski
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#include "wx/app.h"
+#include "wx/unix/gsockunx.h"
+#include "wx/log.h"
+#include "wx/list.h"
+#include "wx/timer.h"
+#include <signal.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#define wxBaseAppTrace wxT("baseapp")
+
+#include "wx/unix/gsockunx.h"
+#ifdef HAVE_SYS_EPOLL_H
+  #include <sys/epoll.h>
+#else
+  #include "wx/unix/socketstable.h"
+#endif
+
+volatile sig_atomic_t sig_alrm_catched = 0;
+
+int
+wxEventApp::OnRun() {
+  mExiting = false;
+  int ret = MainLoop();
+  return ret;
+};
+
+
+#ifdef HAVE_SYS_EPOLL_H 
+
+extern int wxBaseSocketsWatchEpollDescriptor;
+
+void 
+wxEventApp::Dispatch() {
+    epoll_event events[10];
+    wxLogTrace(wxBaseAppTrace,wxT("processing events"));
+    wxASSERT(wxTheApp != NULL);
+    wxTheApp->ProcessPendingEvents();
+    int e_num = epoll_wait(wxBaseSocketsWatchEpollDescriptor,events,10,-1);
+    if (e_num == -1) {
+      if (errno != EINTR) {
+        wxLogError(wxT("Call epoll_wait on epoll descriptor %d failed: %s"),wxBaseSocketsWatchEpollDescriptor,wxSysErrorMsg(errno));
+        mExitCode = -1;
+        mExiting = true;
+        return;
+      } else {
+        if (sig_alrm_catched == 1) {
+          gs_scheduler->processSignal();
+        };
+      };
+    };
+    for(int n = 0; n < e_num; n++) {
+      if (events[n].data.fd == mWakeupPipe[0]) {
+        //got wakeup from child thread
+        char s;
+        int size;
+        do {
+          errno = 0;
+          size = read(mWakeupPipe[0],&s,4);
+          if (size == 0) {
+            //Unexpected EOF on wakeup pipe
+            break;
+          };
+          if (size < 4) {
+            //bytes read from wakeup pipe
+            break;
+          };
+          if ((size == -1)&&(errno != EAGAIN)) {
+            //"Error reading data from wakeup pipe
+            break;
+          };
+        } while (errno != EAGAIN);
+      } else {
+        GSocket* s = (GSocket*)(events[n].data.ptr);
+        if ((events[n].events & EPOLLIN) || (events[n].events & EPOLLERR) || (events[n].events & EPOLLHUP)) {
+          if (s->m_fd != -1) {
+            //got read on s->m_fd
+            s->Detected_Read();
+          };
+        } else if (events[n].events & EPOLLOUT) {
+          if (s->m_fd != -1) {
+            //"got write on s->m_fd 
+            s->Detected_Write();
+          };
+        } else {
+          //got unknown event on s->m_fd
+        };
+      };
+    };
+};
+
+#else
+
+wxSocketsTable* gs_sockets;
+
+void
+wxEventApp::Dispatch() {
+  wxLogTrace(wxBaseAppTrace,wxT("processing events"));
+  wxASSERT(wxTheApp != NULL);
+  wxTheApp->ProcessPendingEvents();
+  fd_set read_fds = gs_sockets->getReadFdSet();
+  fd_set write_fds = gs_sockets->getWriteFdSet();
+  fd_set exept_fds = gs_sockets->getExeptFdSet();
+  wxLogTrace(wxBaseAppTrace,wxT("waiting for io [higest: %d]"),gs_sockets->getHigestFd());
+  errno = 0;
+  select(gs_sockets->getHigestFd(),&read_fds,&write_fds,&exept_fds,NULL);
+  if (errno != EINTR) {
+    wxLogTrace(wxBaseAppTrace,wxT("got io"));
+    for(int i = 0; i < gs_sockets->getHigestFd(); i++) {
+      if ((i == mWakeupPipe[0])&&(FD_ISSET(i,&read_fds))) {
+        wxLogTrace(wxBaseAppTrace,wxT("got wakeup from child thread"));
+        char s;
+        int size;
+        do {
+          errno = 0;
+          size = read(mWakeupPipe[0],&s,4);
+          if (size == 0) {
+            //Unexpected EOF on wakeup pipe
+            break;
+          };
+          if (size < 4) {
+            //bytes read from wakeup pipe
+            break;
+          };
+          if ((size == -1)&&(errno != EAGAIN)) {
+            printf("Error reading data from wakeup pipe");
+            break;
+          };
+        } while (errno != EAGAIN);
+      } else {
+        GSocket* sock = NULL;
+        if (FD_ISSET(i,&read_fds) || FD_ISSET(i,&write_fds) || FD_ISSET(i,&exept_fds)) {
+          sock = gs_sockets->findSocket(i);
+          if (sock != NULL) {
+            if (FD_ISSET(i,&read_fds)) {
+              wxLogTrace(wxBaseAppTrace,wxT("read avaiable on socket %d"),i);
+              sock->Detected_Read();
+            };
+            if (FD_ISSET(i,&write_fds)) {
+              wxLogTrace(wxBaseAppTrace,wxT("write avaiable on socket %d"),i);
+              sock->Detected_Write();
+            };
+            if (FD_ISSET(i,&exept_fds)) {
+              wxLogTrace(wxBaseAppTrace,wxT("exeption on socket %d"),i);
+              sock->Detected_Read();
+            };
+          } else {
+            wxLogError(wxT("(select) No such socket: %d"),i);
+          };
+        };
+      };
+    };
+  } else {
+    wxLogTrace(wxBaseAppTrace,wxT("got signal"));
+    if (sig_alrm_catched == 1) {
+      gs_scheduler->processSignal();
+    };
+  };
+};
+
+#endif
+
+int
+wxEventApp::MainLoop() {
+  wxLogTrace(wxBaseAppTrace,wxT("entering main loop"));
+  wxLogTrace(wxBaseAppTrace,wxT("Creted pipe, read on %d, write on %d"),mWakeupPipe[0],mWakeupPipe[1]);
+  while(!mExiting) {
+    Dispatch();
+  };
+  return mExitCode;
+};
+
+bool 
+wxEventApp::Initialize(int& argc, wxChar** argv) {
+  if (!wxAppConsole::Initialize(argc,argv))
+    return false;
+  // initialize missing parts of wxWindows
+  wxPendingEventsLocker = new wxCriticalSection();
+  int ret = pipe(mWakeupPipe);
+  if (ret != 0) {
+    wxLogFatalError(wxT("wxApp: cannot craete wakeup pipe. exiting."));
+    return false;
+  };
+  
+  int oldflags = fcntl(mWakeupPipe[0],F_GETFL,0);
+  if (oldflags == -1) {
+    wxLogError(wxT("wxApp: Error reading file status flags on read pipe descriptor %d"),mWakeupPipe[0]);
+    return false;
+  };
+  
+  oldflags |= O_NONBLOCK;
+  
+  if (fcntl(mWakeupPipe[0],F_SETFL,oldflags) == -1) {
+    wxLogError(wxT("wxApp: Error setting O_NONBLOCK flag on read pipe descriptor %d"),mWakeupPipe[0]);
+    return false;
+  };
+  
+#ifdef HAVE_SYS_EPOLL_H
+  wxBaseSocketsWatchEpollDescriptor = epoll_create(1024);
+  if (wxBaseSocketsWatchEpollDescriptor == -1) {
+    wxLogError(wxT("Error initializing sockets module: Cannot create epoll descriptor: %s"),wxSysErrorMsg(errno));
+    return false;
+  };
+  epoll_event ev;
+  ev.events = EPOLLIN;
+  ev.data.fd = mWakeupPipe[0];
+  ret = epoll_ctl(wxBaseSocketsWatchEpollDescriptor,EPOLL_CTL_ADD,mWakeupPipe[0],&ev);
+  if (ret != 0) {
+    wxLogError(wxT("wxApp: Cannot add wakeup pipe read descriptor %d to epoll descriptor %d: %s"),mWakeupPipe[0],wxBaseSocketsWatchEpollDescriptor,wxSysErrorMsg(errno));
+    return -1;
+  };
+#else
+  gs_sockets = new wxSocketsTable();
+  wxLogTrace(wxBaseAppTrace,wxT("Creted pipe, read on %d, write on %d"),mWakeupPipe[0],mWakeupPipe[1]);
+  gs_sockets->setWakeupPipeReadFd(mWakeupPipe[0]);
+#endif
+  mExitCode = 0;
+  return true;
+};
+
+
+void
+wxEventApp::ExitMainLoop() {
+  wxLogTrace(wxBaseAppTrace,wxT("baseapp: exiting..."));
+  mExiting = true;
+  WakeUpIdle();
+};
+
+void 
+wxEventApp::CleanUp() {
+  delete wxPendingEvents;
+  wxPendingEvents = NULL;
+  
+  delete wxPendingEventsLocker;
+  wxPendingEventsLocker = NULL;
+#ifdef HAVE_SYS_EPOLL_H
+  close(wxBaseSocketsWatchEpollDescriptor);
+  wxBaseSocketsWatchEpollDescriptor = -1;
+#else
+  delete gs_sockets;
+#endif
+};
+
+
+//do not put wxLog* here: it will cause deadlocks on trace critical secions
+void
+wxEventApp::WakeUpIdle() {
+  int size = write(mWakeupPipe[1],"s",1);
+  if(size != 1)
+    perror("write");
+};
+
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/src/unix/apptbase.cpp wxWidgets-2.6.3-cvsp17/src/unix/apptbase.cpp
--- wxWidgets-cvs-20060425/src/unix/apptbase.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.6.3-cvsp17/src/unix/apptbase.cpp	2006-04-25 20:10:54.786566750 +0200
@@ -0,0 +1,36 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/unix/apptbase.cpp
+// Purpose:     wxAppTraits common functions for GUI and Base Unix
+// Author:      Lukasz Michalski
+// Modified by:
+// Created:     28/01/2005
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) Lukasz Michalski
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+#include "wx/app.h"
+#include "wx/apptrait.h"
+#include <signal.h>
+
+void 
+wxAppTraits::BlockAllUnixSignals(bool pFlag) {
+//  printf("block signal=%d\n",pBlock);
+  sigset_t all_signals;
+  sigfillset(&all_signals);
+#if wxUSE_THREADS
+  if (pFlag) 
+  {
+    pthread_sigmask(SIG_BLOCK,&all_signals,NULL);
+  } else {
+    pthread_sigmask(SIG_UNBLOCK,&all_signals,NULL);
+  };
+#else
+  if (pFlag) 
+  {
+    sigprocmask(SIG_BLOCK,&all_signals,NULL);
+  } else {
+    sigprocmask(SIG_UNBLOCK,&all_signals,NULL);
+  };
+#endif
+};
+
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/src/unix/baseunix.cpp wxWidgets-2.6.3-cvsp17/src/unix/baseunix.cpp
--- wxWidgets-cvs-20060425/src/unix/baseunix.cpp	2005-04-25 12:28:59.000000000 +0200
+++ wxWidgets-2.6.3-cvsp17/src/unix/baseunix.cpp	2006-04-25 20:10:54.786566750 +0200
@@ -32,11 +32,25 @@
 #include "wx/apptrait.h"
 #include "wx/utils.h"
 #include "wx/unix/execute.h"
+#include "wx/unix/gsockunx.h"
+
+//for epoll calls
+#if HAVE_SYS_EPOLL_H
+  #include <sys/epoll.h>
+  #define wxTRACE_epoll wxT("epoll")
+#else
+  #include "wx/unix/socketstable.h"
+#endif
+
+#include "wx/thread.h"
 
 // for waitpid()
 #include <sys/types.h>
 #include <sys/wait.h>
 
+//errno
+#include <errno.h>
+
 // ============================================================================
 // wxConsoleAppTraits implementation
 // ============================================================================
@@ -81,6 +95,165 @@
     return exitcode;
 }
 
+// Sockets table for wxBase
+//
+//
+
+#ifdef HAVE_SYS_EPOLL_H
+int wxBaseSocketsWatchEpollDescriptor = -1;
+
+bool GSocketGUIFunctionsTableConcrete::OnInit()
+{   
+  return true;
+}
+
+void GSocketGUIFunctionsTableConcrete::OnExit()
+{
+}
+
+bool GSocketGUIFunctionsTableConcrete::CanUseEventLoop()
+{   return true; }
+
+bool GSocketGUIFunctionsTableConcrete::Init_Socket(GSocket *socket)
+{   return true; }
+
+void GSocketGUIFunctionsTableConcrete::Destroy_Socket(GSocket *socket)
+{
+  if (socket->m_fd == -1)
+    return;
+#ifdef wxUSE_THREADS
+  if (!wxThread::IsMain())
+    return;
+#endif
+  epoll_event ev;
+  ev.events = 0;
+  ev.data.ptr = (void*)socket;
+  int ret = epoll_ctl(wxBaseSocketsWatchEpollDescriptor,EPOLL_CTL_DEL,socket->m_fd,&ev);
+  if (ret != 0) {
+    wxLogError(wxT("Sockets module: Cannot remove socket %d from epoll descriptor %d: %s"),socket->m_fd,wxBaseSocketsWatchEpollDescriptor,wxSysErrorMsg(errno));
+  };
+}
+
+void GSocketGUIFunctionsTableConcrete::Install_Callback(GSocket *socket, GSocketEvent event)
+{
+  if (socket->m_fd == -1)
+    return;
+#ifdef wxUSE_THREADS
+  if (!wxThread::IsMain())
+    return;
+#endif
+  epoll_event ev;
+  ev.events = EPOLLERR | EPOLLHUP;
+  if ((socket->m_detected & GSOCK_INPUT_FLAG) == 0) {
+    wxLogTrace(wxTRACE_epoll,wxT("Adding EPOLLIN to socket %d"),socket->m_fd);
+    ev.events |= EPOLLIN;
+  }
+  if ((socket->m_detected & GSOCK_OUTPUT_FLAG) == 0) {
+    wxLogTrace(wxTRACE_epoll,wxT("Adding EPOLLOUT to socket %d"),socket->m_fd);
+    ev.events |= EPOLLOUT;
+  }
+  ev.data.ptr = (void*)socket;
+  int ret = epoll_ctl(wxBaseSocketsWatchEpollDescriptor,EPOLL_CTL_MOD,socket->m_fd,&ev);
+  if (ret != 0) {
+    wxLogError(wxT("Sockets module: Cannot modify socket %d on epoll descriptor %d: %s"),socket->m_fd,wxBaseSocketsWatchEpollDescriptor,wxSysErrorMsg(errno));
+  };
+}
+
+void GSocketGUIFunctionsTableConcrete::Uninstall_Callback(GSocket *socket, GSocketEvent event)
+{
+  if (socket->m_fd == -1)
+    return;
+#ifdef wxUSE_THREADS
+  if (!wxThread::IsMain())
+    return;
+#endif
+  epoll_event ev;
+  ev.events = EPOLLERR | EPOLLHUP;
+  if ((socket->m_detected & GSOCK_INPUT_FLAG) == GSOCK_INPUT_FLAG) {
+    wxLogTrace(wxTRACE_epoll,wxT("Removing EPOLLIN from socket %d"),socket->m_fd);
+    ev.events = EPOLLERR | EPOLLHUP | EPOLLOUT;
+  }
+  if ((socket->m_detected & GSOCK_OUTPUT_FLAG)== GSOCK_OUTPUT_FLAG) {
+    wxLogTrace(wxTRACE_epoll,wxT("Removing EPOLLOUT from socket %d"),socket->m_fd);
+    ev.events = EPOLLERR | EPOLLHUP | EPOLLIN;
+  }
+  ev.data.ptr = (void*)socket;
+  int ret = epoll_ctl(wxBaseSocketsWatchEpollDescriptor,EPOLL_CTL_MOD,socket->m_fd,&ev);
+  if (ret != 0) {
+    wxLogError(wxT("Sockets module: Cannot modify socket %d on epoll descriptor %d: %s"),socket->m_fd,wxBaseSocketsWatchEpollDescriptor,wxSysErrorMsg(errno));
+  };
+}
+
+void GSocketGUIFunctionsTableConcrete::Enable_Events(GSocket *socket)
+{
+  if (socket->m_fd == -1)
+    return;
+#ifdef wxUSE_THREADS
+  if (!wxThread::IsMain())
+    return;
+#endif
+  epoll_event ev;
+  ev.events = EPOLLERR | EPOLLHUP | EPOLLIN | EPOLLOUT;
+  ev.data.ptr = (void*)socket;
+  int ret = epoll_ctl(wxBaseSocketsWatchEpollDescriptor,EPOLL_CTL_ADD,socket->m_fd,&ev);
+  if (ret != 0) {
+    wxLogError(wxT("Sockets module: Cannot add socket %d to epoll descriptor %d: %s"),socket->m_fd,wxBaseSocketsWatchEpollDescriptor,wxSysErrorMsg(errno));
+  };
+  wxLogTrace(wxTRACE_epoll,wxT("Added socket %d to epoll %d"),socket->m_fd,wxBaseSocketsWatchEpollDescriptor);
+}
+
+void GSocketGUIFunctionsTableConcrete::Disable_Events(GSocket *socket)
+{
+  if (socket->m_fd == -1)
+    return;
+  epoll_event ev;
+  ev.events = 0;
+  ev.data.ptr = (void*)socket;
+  int ret = epoll_ctl(wxBaseSocketsWatchEpollDescriptor,EPOLL_CTL_DEL,socket->m_fd,&ev);
+  if (ret != 0) {
+    wxLogError(wxT("Sockets module: Cannot remove socket %d from epoll descriptor %d: (%d) %s"),socket->m_fd,wxBaseSocketsWatchEpollDescriptor,errno,wxSysErrorMsg(errno));
+  };
+  wxLogTrace(wxTRACE_epoll,wxT("Removed socket %d from epoll %d"),socket->m_fd,wxBaseSocketsWatchEpollDescriptor);
+}
+
+#else
+
+extern wxSocketsTable* gs_sockets;
+
+bool GSocketGUIFunctionsTableConcrete::OnInit()
+{ 
+  return true;
+}
+void GSocketGUIFunctionsTableConcrete::OnExit()
+{
+}
+bool GSocketGUIFunctionsTableConcrete::CanUseEventLoop()
+{   return true; }
+bool GSocketGUIFunctionsTableConcrete::Init_Socket(GSocket *socket)
+{   return true; }
+void GSocketGUIFunctionsTableConcrete::Destroy_Socket(GSocket *socket)
+{
+  gs_sockets->removeGSocket(socket);
+}
+void GSocketGUIFunctionsTableConcrete::Install_Callback(GSocket *socket, GSocketEvent event)
+{
+  gs_sockets->enableGSockEvents(socket,event);
+}
+void GSocketGUIFunctionsTableConcrete::Uninstall_Callback(GSocket *socket, GSocketEvent event)
+{
+  gs_sockets->disableGSockEvents(socket,event);
+}
+void GSocketGUIFunctionsTableConcrete::Enable_Events(GSocket *socket)
+{
+  gs_sockets->addGSocket(socket);
+}
+void GSocketGUIFunctionsTableConcrete::Disable_Events(GSocket *socket)
+{
+  gs_sockets->removeGSocket(socket);
+}
+#endif //HAVE_EPOLL_H
+
+
 // ----------------------------------------------------------------------------
 // misc other stuff
 // ----------------------------------------------------------------------------
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/src/unix/gsocket.cpp wxWidgets-2.6.3-cvsp17/src/unix/gsocket.cpp
--- wxWidgets-cvs-20060425/src/unix/gsocket.cpp	2006-04-25 19:53:49.229786500 +0200
+++ wxWidgets-2.6.3-cvsp17/src/unix/gsocket.cpp	2006-04-25 20:10:54.786566750 +0200
@@ -204,38 +204,6 @@
 
 static GSocketGUIFunctionsTable *gs_gui_functions;
 
-class GSocketGUIFunctionsTableNull: public GSocketGUIFunctionsTable
-{
-public:
-    virtual bool OnInit();
-    virtual void OnExit();
-    virtual bool CanUseEventLoop();
-    virtual bool Init_Socket(GSocket *socket);
-    virtual void Destroy_Socket(GSocket *socket);
-    virtual void Install_Callback(GSocket *socket, GSocketEvent event);
-    virtual void Uninstall_Callback(GSocket *socket, GSocketEvent event);
-    virtual void Enable_Events(GSocket *socket);
-    virtual void Disable_Events(GSocket *socket);
-};
-
-bool GSocketGUIFunctionsTableNull::OnInit()
-{   return true; }
-void GSocketGUIFunctionsTableNull::OnExit()
-{}
-bool GSocketGUIFunctionsTableNull::CanUseEventLoop()
-{   return false; }
-bool GSocketGUIFunctionsTableNull::Init_Socket(GSocket *WXUNUSED(socket))
-{   return true; }
-void GSocketGUIFunctionsTableNull::Destroy_Socket(GSocket *WXUNUSED(socket))
-{}
-void GSocketGUIFunctionsTableNull::Install_Callback(GSocket *WXUNUSED(socket), GSocketEvent WXUNUSED(event))
-{}
-void GSocketGUIFunctionsTableNull::Uninstall_Callback(GSocket *WXUNUSED(socket), GSocketEvent WXUNUSED(event))
-{}
-void GSocketGUIFunctionsTableNull::Enable_Events(GSocket *WXUNUSED(socket))
-{}
-void GSocketGUIFunctionsTableNull::Disable_Events(GSocket *WXUNUSED(socket))
-{}
 /* Global initialisers */
 
 void GSocket_SetGUIFunctions(GSocketGUIFunctionsTable *guifunc)
@@ -247,7 +215,7 @@
 {
   if (!gs_gui_functions)
   {
-    static GSocketGUIFunctionsTableNull table;
+    static GSocketGUIFunctionsTableConcrete table;
     gs_gui_functions = &table;
   }
   if ( !gs_gui_functions->OnInit() )
@@ -286,7 +254,8 @@
   m_timeout             = 10*60*1000;
                                 /* 10 minutes * 60 sec * 1000 millisec */
   m_establishing        = false;
-
+  m_use_events      = false;
+  
   assert(gs_gui_functions);
   /* Per-socket GUI-specific initialization */
   m_ok = gs_gui_functions->Init_Socket(this);
@@ -294,7 +263,8 @@
 
 void GSocket::Close()
 {
-    gs_gui_functions->Disable_Events(this);
+    if (m_use_events)
+      EnableEvents(false);
     /* gsockosx.c calls CFSocketInvalidate which closes the socket for us */
 #if !(defined(__DARWIN__) && (defined(__WXMAC__) || defined(__WXCOCOA__)))
     close(m_fd);
@@ -516,7 +486,8 @@
 #endif
 
   ioctl(m_fd, FIONBIO, &arg);
-  gs_gui_functions->Enable_Events(this);
+  if (m_use_events)
+    EnableEvents(true);
 
   /* allow a socket to re-bind if the socket is in the TIME_WAIT
      state after being previously closed.
@@ -542,6 +513,24 @@
   return GSOCK_NOERROR;
 }
 
+void 
+GSocket::Notify(bool pFlag) {
+  if (pFlag == m_use_events)
+    return;
+  m_use_events = pFlag;
+  EnableEvents(pFlag);
+};
+
+void
+GSocket::EnableEvents(bool pFlag) {
+  if (pFlag) {
+    gs_gui_functions->Enable_Events(this);
+  } else {
+    gs_gui_functions->Disable_Events(this);
+  };
+};
+
+
 /* GSocket_WaitConnection:
  *  Waits for an incoming client connection. Returns a pointer to
  *  a GSocket object, or NULL if there was an error, in which case
@@ -628,8 +617,6 @@
 #else
   ioctl(connection->m_fd, FIONBIO, &arg);
 #endif
-  gs_gui_functions->Enable_Events(connection);
-
   return connection;
 }
 
@@ -727,9 +714,9 @@
    * call to Enable_Events now.  
    */
   
-  if (m_non_blocking || ret == 0)
+  if (m_use_events && (m_non_blocking || ret == 0))
   {
-    gs_gui_functions->Enable_Events(this);
+    EnableEvents(true);
   }
 
   if (ret == -1)
@@ -835,7 +822,6 @@
 #else
   ioctl(m_fd, FIONBIO, &arg);
 #endif
-  gs_gui_functions->Enable_Events(this);
 
   /* Bind to the local address,
    * and retrieve the actual address bound.
@@ -968,7 +954,7 @@
  */
 GSocketEventFlags GSocket::Select(GSocketEventFlags flags)
 {
-  if (!gs_gui_functions->CanUseEventLoop())
+  if (!m_use_events)
   {
 
     GSocketEventFlags result = 0;
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/src/unix/socketstable.cpp wxWidgets-2.6.3-cvsp17/src/unix/socketstable.cpp
--- wxWidgets-cvs-20060425/src/unix/socketstable.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.6.3-cvsp17/src/unix/socketstable.cpp	2006-04-25 20:10:54.786566750 +0200
@@ -0,0 +1,142 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/unix/socketstable.h
+// Purpose:     Sockets table implementation 
+// Author:      Lukasz Michalski
+// Modified by:
+// Created:     28/01/2005
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) Lukasz Michalski
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#include "wx/unix/socketstable.h"
+
+#ifndef HAVE_SYS_EPOLL_H
+
+wxSocketsTable::wxSocketsTable() {
+  mHigestFd = 0;
+  FD_ZERO(&ar_fds);
+  FD_ZERO(&aw_fds);
+  FD_ZERO(&ae_fds);
+};
+
+void 
+wxSocketsTable::setWakeupPipeReadFd(int pFd) {
+  if (mHigestFd <= pFd)
+    mHigestFd = pFd + 1;
+  FD_SET(pFd,&ar_fds);
+};
+
+
+GSocket*
+wxSocketsTable::findSocket(int pFd) {
+#ifdef wxUSE_THREADS
+  wxCriticalSectionLocker l(mSocketMapLocker);
+#endif
+  SocketsTableType::iterator it = mSockets.find(pFd);
+  if (it == mSockets.end())
+    return NULL;
+  return it->second;
+};
+
+void
+wxSocketsTable::addGSocket(GSocket* pSocket) {
+  int fd = pSocket->m_fd;
+  if (fd <= 0)
+    return;
+#ifdef wxUSE_THREADS
+  if (!wxThread::IsMain())
+    return;
+  wxCriticalSectionLocker l(mSocketMapLocker);
+#endif
+  if (mHigestFd <= fd)
+    mHigestFd = fd + 1;
+//  wxLogTrace(wxBaseAppTrace,wxT("addGSocket %d"),fd);
+  mSockets[fd] = pSocket;
+  FD_SET(fd,&ar_fds);
+  FD_SET(fd,&aw_fds);
+  FD_SET(fd,&ae_fds);
+};
+
+void
+wxSocketsTable::removeGSocket(GSocket* pSocket) {
+  int fd = pSocket->m_fd;
+  if (fd <= 0)
+    return;
+//  wxLogTrace(wxBaseAppTrace,wxT("removeSocket %d"),fd);
+#ifdef wxUSE_THREADS
+  wxCriticalSectionLocker l(mSocketMapLocker);
+#endif
+  SocketsTableType::iterator it = mSockets.find(fd);
+  if (it != mSockets.end()) {
+    mSockets.erase(it);
+    FD_CLR(fd,&ar_fds);
+    FD_CLR(fd,&aw_fds);
+    FD_CLR(fd,&ae_fds);
+  };
+};
+
+void
+wxSocketsTable::enableGSockEvents(GSocket *pSocket, GSocketEvent event) {
+  int fd = pSocket->m_fd;
+  if (fd <= 0)
+    return;
+#ifdef wxUSE_THREADS
+  if (!wxThread::IsMain())
+    return;
+#endif
+  switch(event) {
+    case GSOCK_INPUT:
+//      wxLogTrace(wxBaseAppTrace,wxT("enableGSEvents: INPUT on %d"),pSocket->m_fd);
+      FD_SET(pSocket -> m_fd,&ar_fds);
+    break;
+    case GSOCK_OUTPUT:
+//      wxLogTrace(wxBaseAppTrace,wxT("enableGSEvents: OUTPUT on %d"),pSocket->m_fd);
+      FD_SET(pSocket -> m_fd,&aw_fds);
+    break;
+
+    //what to do here?
+    case GSOCK_CONNECTION:
+    break;
+
+    case GSOCK_LOST:
+    break;
+
+    default:
+//      wxLogTrace(wxBaseAppTrace,wxT("enableGSockEvents: unknown GSocketEvent %d"),event);
+    break;
+  };
+};
+
+void
+wxSocketsTable::disableGSockEvents(GSocket *pSocket, GSocketEvent event) {
+  int fd = pSocket->m_fd;
+  if (fd <= 0)
+    return;
+  if (!wxThread::IsMain())
+    return;
+  switch(event) {
+    case GSOCK_INPUT:
+//      wxLogTrace(wxBaseAppTrace,wxT("disableGSEvents: INPUT on %d"),pSocket->m_fd);
+      FD_CLR(pSocket -> m_fd,&ar_fds);
+    break;
+    case GSOCK_OUTPUT:
+//      wxLogTrace(wxBaseAppTrace,wxT("disableGSEvents: OUTPUT on %d"),pSocket->m_fd);
+      FD_CLR(pSocket -> m_fd,&aw_fds);
+    break;
+    //what to do here?
+
+    case GSOCK_CONNECTION:
+    break;
+
+
+    case GSOCK_LOST:
+    break;
+
+    default:
+//      wxLogTrace(wxBaseAppTrace,wxT("enableGSockEvents: unknown GSocketEvent %d"), event);
+    break;
+  };
+};
+
+#endif
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-cvs-20060425/src/unix/timer.cpp wxWidgets-2.6.3-cvsp17/src/unix/timer.cpp
--- wxWidgets-cvs-20060425/src/unix/timer.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.6.3-cvsp17/src/unix/timer.cpp	2006-05-30 10:26:10.874493250 +0200
@@ -0,0 +1,276 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        src/unix/timer.cpp
+// Purpose:     wxTimer implementation for wxBase (unix)
+// Author:      Lukasz Michalski
+// Created:     15/01/2005
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) Lukasz Michalski
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#include "wx/timer.h"
+#include "wx/log.h"
+#include "wx/module.h"
+#include "wx/app.h"
+#include <sys/time.h> 
+#include <signal.h>
+
+TimerScheduler *gs_scheduler = NULL;
+
+#define wxTrace_Timer wxT("timer")
+
+#include "wx/listimpl.cpp"
+WX_DEFINE_LIST(TimerList);
+
+TimerScheduler::TimerScheduler()
+{
+    if (signal(SIGALRM,catch_alarm) == SIG_ERR)
+    {
+      // cannot install handler for SIGALRM
+      wxLogFatalError(wxT("TimerScheduler: cannot install handler for SIGALRM"));
+    }
+
+    mTimerRunning = false;
+    mNextExpiry = 0;
+}
+
+TimerScheduler::~TimerScheduler() throw() 
+{
+    TimerList::Node *node;
+    for(node = mData.GetFirst(); node != 0; node = node->GetNext())
+      delete node->GetData();
+}
+
+void TimerScheduler::addTimer(wxTimer* pRequester, wxLongLong expire) 
+{
+    wxTimerSchedule *s = new wxTimerSchedule;
+    s->mExpire = expire;
+    s->mTimer = pRequester;
+
+    // Do an insertion sort
+    TimerList::Node *node;
+    for(node = mData.GetFirst(); node != 0; node = node->GetNext())
+    {
+      if (node->GetData()->mExpire > expire)
+      {
+        mData.Insert(node, s);
+          break;
+      }
+    }
+    if (node == 0)
+      mData.Append(s);
+
+    wxLogTrace(wxTrace_Timer,
+      wxT("TimerScheduler::addTimer requestor %d expire=%ld"),
+          pRequester->GetId(), expire.GetLo());
+}
+
+void TimerScheduler::removeTimer(wxTimer* pRequester)
+{
+    wxLogTrace(wxTrace_Timer,wxT("TimerScheduler::removeTimer requestor %d"),
+               pRequester->GetId());
+
+    TimerList::Node *node;
+    for(node = mData.GetFirst(); node != 0; node = node->GetNext())
+    {
+      if (node->GetData()->mTimer == pRequester)
+      {
+        delete node->GetData();
+        mData.DeleteNode(node);
+        break;
+      }
+    }
+}
+
+void TimerScheduler::calculateSchedule()
+{
+    if (mData.IsEmpty())
+      return;
+
+    wxTimerSchedule *s = mData.GetFirst()->GetData();
+
+    if (s != 0)
+    {
+      if (s->mExpire != mNextExpiry)
+      {
+        // Only have to reschule if the timeout of the first item
+        // on the list changes.
+        wxLongLong now = wxGetLocalTimeMillis();
+        long delta = (s->mExpire - now).ToLong();
+        // If the timer would expire immediately then reschedule for
+        // 1ms
+        if (delta < 1)
+          delta = 1;
+
+        if (mTimerRunning)
+          Stop();
+
+        Start(delta);
+        mNextExpiry = s->mExpire;
+      }
+    }
+    else
+    {
+      if (mTimerRunning)
+        Stop();
+      mNextExpiry = 0;
+    }
+}
+
+void TimerScheduler::notifyCurrent()
+{
+    if (mData.IsEmpty())
+      return;
+
+    wxTimerSchedule *s = mData.GetFirst()->GetData();
+    if (s == 0)
+      return;
+
+    wxLongLong now = wxGetLocalTimeMillis();
+
+    TimerList::Node *node, *next_node;
+    for(node = mData.GetFirst(); node != 0; node = next_node)
+    {
+      wxTimerSchedule *s = node->GetData();
+      if (s->mExpire > now)
+        break;
+
+      // Calculate next node as we will delete the nodes we add events for
+      next_node = node->GetNext();
+
+      wxTimer* req = s->mTimer;
+        if (req->IsOneShot())
+          req->mRunning = false;
+        else
+        {
+          // Prevent a fast timer from swamping the system
+          wxLongLong t = node->GetData()->mExpire + req->GetInterval();
+          if (t < now)
+            t = now;
+          addTimer(req, t);
+        }
+
+        //we have to remove requester from current first, because it can call 
+        //removeTimer
+        mData.DeleteNode(node);
+        delete s;
+
+        wxTimerEvent evt(req->GetId(), req->GetInterval());
+        if (req->GetOwner() != NULL) 
+          // we are adding pending event because notifyCurrent() is
+          // called from signal handler and it is safer not to execute
+          // user code from signal handler but in wxApp::MainLoop()
+          req->GetOwner()->AddPendingEvent(evt);
+        else 
+          req->Notify();
+    }
+    calculateSchedule();
+}
+
+void TimerScheduler::catch_alarm(int pSigNum)
+{
+    sig_alrm_catched = 1;
+}
+
+void TimerScheduler::processSignal()
+{
+    sig_alrm_catched = 0;
+    gs_scheduler->notifyCurrent();
+}
+
+bool TimerScheduler::Start(long pMilliseconds)
+{
+    if (pMilliseconds < 0)
+      return false;
+
+    struct itimerval data;
+    long sec = pMilliseconds/1000;
+    long usec = (pMilliseconds - (sec * 1000)) * 1000;
+    if (usec < 0)
+      usec = 0;
+    data.it_interval.tv_sec = sec;
+    data.it_interval.tv_usec = usec;
+    data.it_value.tv_sec = sec;
+    data.it_value.tv_usec = usec;
+    if (setitimer(ITIMER_REAL,&data,NULL) < 0)
+      return false;
+
+    mTimerRunning = true;
+
+    return true;
+}
+
+void TimerScheduler::Stop()
+{
+    struct itimerval data;
+    data.it_interval.tv_sec = 0;
+    data.it_interval.tv_usec = 0;
+    data.it_value.tv_sec = 0;
+    data.it_value.tv_usec = 0;
+    setitimer(ITIMER_REAL, &data, NULL);
+
+    mTimerRunning = false;
+}
+
+//-----------------------------------------------------------
+
+wxTimer::wxTimer() 
+{
+    Init();
+    mRunning = false;
+}
+
+wxTimer::wxTimer(wxEvtHandler *owner, int timerid) 
+  : wxTimerBase(owner,timerid)
+{
+    mRunning = false;
+}
+
+
+bool wxTimer::Start(int milliseconds, bool oneShot)
+{
+    // Will stop already running timers
+    wxTimerBase::Start(milliseconds, oneShot);
+
+    wxLongLong now = wxGetLocalTimeMillis();
+    gs_scheduler->addTimer(this, now + GetInterval());
+    gs_scheduler->calculateSchedule();
+    mRunning = true;
+    return mRunning;
+}
+
+void wxTimer::Stop()
+{
+    if (mRunning)
+    {
+      gs_scheduler->removeTimer(this);
+      gs_scheduler->calculateSchedule();
+      mRunning = false;
+    }
+}
+
+bool wxTimer::IsRunning() const
+{
+    return mRunning;
+}
+
+wxTimer::~wxTimer()
+{
+  if (mRunning)
+    gs_scheduler->removeTimer(this);
+}
+
+
+// A module to deallocate memory properly
+class wxTimerModule: public wxModule {
+    DECLARE_DYNAMIC_CLASS(wxTimerModule)
+  public:
+    wxTimerModule() {}
+    bool OnInit() { gs_scheduler = new TimerScheduler; return true; }
+    void OnExit() { delete gs_scheduler; gs_scheduler = NULL; }
+};
+
+IMPLEMENT_DYNAMIC_CLASS(wxTimerModule, wxModule)
+

 	  	 

 	  	 
