diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/build/bakefiles/files.bkl wxWidgets-2.8.0-p22/build/bakefiles/files.bkl
--- wxWidgets-2.8.0/build/bakefiles/files.bkl	2006-12-14 15:57:56.000000000 +0100
+++ wxWidgets-2.8.0-p22/build/bakefiles/files.bkl	2006-12-04 19:06:00.000000000 +0100
@@ -54,6 +54,8 @@
 <!--                               UNIX                                     -->
 <!-- =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- -->
 <set var="BASE_UNIX_SRC" hints="files">
+    src/unix/app.cpp
+    src/unix/socketstable.cpp
     src/unix/baseunix.cpp
     src/unix/dir.cpp
     src/unix/dlunix.cpp
@@ -62,11 +64,13 @@
     src/unix/stackwalk.cpp
     src/unix/stdpaths.cpp
     src/unix/threadpsx.cpp
+    src/unix/timer.cpp
 </set>
 <set var="BASE_AND_GUI_UNIX_SRC" hints="files">
     src/unix/utilsunx.cpp
 </set>
 <set var="BASE_UNIX_HDR" hints="files">
+    wx/unix/app.h
     wx/unix/apptbase.h
     wx/unix/apptrait.h
     wx/unix/execute.h
@@ -81,6 +85,7 @@
 <!--                             Windows                                    -->
 <!-- =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- -->
 <set var="BASE_WIN32_SRC" hints="files">
+    src/msw/appcon.cpp
     src/msw/basemsw.cpp
     src/msw/crashrpt.cpp
     src/msw/debughlp.cpp
@@ -95,6 +100,7 @@
     src/msw/stackwalk.cpp
     src/msw/stdpaths.cpp
     src/msw/thread.cpp
+    src/msw/timer.cpp
     src/msw/utils.cpp
     src/msw/utilsexc.cpp
 </set>
@@ -102,11 +108,13 @@
     src/msw/main.cpp
     src/msw/mslu.cpp
     src/msw/volume.cpp
+    src/msw/gsockmsw.cpp
 </set>
 <set var="BASE_WINCE_SRC" hints="files">
     <if cond="TOOLKIT=='WINCE'">src/msw/wince/time.cpp</if>
 </set>
 <set var="BASE_WIN32_HDR" hints="files">
+    wx/msw/appcon.h
     wx/msw/apptrait.h
     wx/msw/apptbase.h
     wx/msw/chkconf.h
@@ -344,6 +352,8 @@
     src/common/tarstrm.cpp
     src/common/textbuf.cpp
     src/common/textfile.cpp
+    src/common/timercmn.cpp
+    src/common/timerimpl.cpp
     src/common/tokenzr.cpp
     src/common/txtstrm.cpp
     src/common/uri.cpp
@@ -642,7 +652,6 @@
     src/common/stockitem.cpp
     src/common/tbarbase.cpp
     src/common/textcmn.cpp
-    src/common/timercmn.cpp
     src/common/toplvcmn.cpp
     src/common/treebase.cpp
     src/common/valgen.cpp
@@ -737,7 +746,6 @@
     wx/generic/spinctlg.h
     wx/generic/splitter.h
     wx/generic/textdlgg.h
-    wx/generic/timer.h
     wx/generic/treectlg.h
     wx/graphics.h
     wx/helphtml.h
@@ -960,7 +968,6 @@
     wx/gtk/pen.h
     wx/gtk/popupwin.h
     wx/gtk/region.h
-    wx/gtk/timer.h
     wx/gtk/tooltip.h
     wx/gtk/toplevel.h
     wx/gtk/win_gtk.h
@@ -1139,7 +1146,6 @@
     wx/gtk1/pen.h
     wx/gtk1/popupwin.h
     wx/gtk1/region.h
-    wx/gtk1/timer.h
     wx/gtk1/tooltip.h
     wx/gtk1/toplevel.h
     wx/gtk1/win_gtk.h
@@ -1381,7 +1387,6 @@
     wx/motif/stattext.h
     wx/motif/textctrl.h
     wx/motif/tglbtn.h
-    wx/motif/timer.h
     wx/motif/toolbar.h
     wx/motif/toplevel.h
     wx/motif/window.h
@@ -1490,7 +1495,6 @@
     src/msw/gdiimage.cpp
     src/msw/gdiobj.cpp
     src/msw/graphics.cpp
-    src/msw/gsockmsw.cpp
     src/msw/icon.cpp
     src/msw/imaglist.cpp
     src/msw/minifram.cpp
@@ -1506,7 +1510,6 @@
     src/msw/region.cpp
     src/msw/renderer.cpp
     src/msw/settings.cpp
-    src/msw/timer.cpp
     src/msw/tooltip.cpp
     src/msw/toplevel.cpp
     src/msw/utilsgui.cpp
@@ -1658,7 +1661,6 @@
     wx/msw/tbar95.h
     wx/msw/textctrl.h
     wx/msw/tglbtn.h
-    wx/msw/timer.h
     wx/msw/tooltip.h
     wx/msw/toplevel.h
     wx/msw/treectrl.h
@@ -1786,7 +1788,6 @@
     wx/generic/icon.h
     wx/generic/imaglist.h
     wx/generic/mask.h
-    wx/generic/timer.h
     wx/mgl/app.h
     wx/mgl/bitmap.h
     wx/mgl/brush.h
@@ -1848,7 +1849,6 @@
     wx/generic/icon.h
     wx/generic/imaglist.h
     wx/generic/mask.h
-    wx/generic/timer.h
     wx/dfb/app.h
     wx/dfb/bitmap.h
     wx/dfb/brush.h
@@ -2031,7 +2031,6 @@
     wx/os2/tabctrl.h
     wx/os2/textctrl.h
     wx/os2/tglbtn.h
-    wx/os2/timer.h
     wx/os2/toolbar.h
     wx/os2/tooltip.h
     wx/os2/toplevel.h
@@ -2235,7 +2234,6 @@
     wx/mac/tabctrl.h
     wx/mac/taskbarosx.h
     wx/mac/textctrl.h
-    wx/mac/timer.h
     wx/mac/tglbtn.h
     wx/mac/toolbar.h
     wx/mac/tooltip.h
@@ -2317,7 +2315,6 @@
     wx/mac/carbon/statusbr.h
     wx/mac/carbon/tabctrl.h
     wx/mac/carbon/textctrl.h
-    wx/mac/carbon/timer.h
     wx/mac/carbon/tglbtn.h
     wx/mac/carbon/toolbar.h
     wx/mac/carbon/tooltip.h
@@ -2505,7 +2502,6 @@
     wx/cocoa/statline.h
     wx/cocoa/stattext.h
     wx/cocoa/textctrl.h
-    wx/cocoa/timer.h
     wx/cocoa/toolbar.h
     wx/cocoa/toplevel.h
     wx/cocoa/window.h
Files wxWidgets-2.8.0/build/bakefiles/wxwin.pyc and wxWidgets-2.8.0-p22/build/bakefiles/wxwin.pyc differ
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/configure.in wxWidgets-2.8.0-p22/configure.in
--- wxWidgets-2.8.0/configure.in	2006-12-14 15:57:56.000000000 +0100
+++ wxWidgets-2.8.0-p22/configure.in	2006-12-14 16:15:33.000000000 +0100
@@ -1851,6 +1851,9 @@
     AC_CHECK_HEADERS([sys/select.h])
 fi
 
+dnl defines HAVE_SYS_EPOLL_H - for epoll mainloop implementation in wxbase
+AC_CHECK_HEADERS(sys/epoll.h)
+
 dnl ---------------------------------------------------------------------------
 dnl Checks for compiler characteristics
 dnl ---------------------------------------------------------------------------
@@ -7488,7 +7491,7 @@
         SAMPLES_SUBDIRS="$SAMPLES_SUBDIRS ownerdrw"
     fi
 else
-    SAMPLES_SUBDIRS="console"
+    SAMPLES_SUBDIRS="console sockbase"
 fi
 
 
@@ -8069,7 +8072,7 @@
             dnl don't take all samples/utils, just those which build with
             dnl wxBase
             if test ${subdir} = "samples"; then
-                makefiles="samples/Makefile.in samples/console/Makefile.in"
+                makefiles="samples/Makefile.in samples/console/Makefile.in samples/sockbase/Makefile.in"
             elif test ${subdir} = "utils"; then
                 makefiles=""
                 for util in HelpGen tex2rtf ; do
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/app.h wxWidgets-2.8.0-p22/include/wx/app.h
--- wxWidgets-2.8.0/include/wx/app.h	2006-12-14 15:58:25.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/app.h	2006-12-04 19:06:24.000000000 +0100
@@ -580,8 +580,18 @@
         #include "wx/os2/app.h"
     #endif
 #else // !GUI
-    // allow using just wxApp (instead of wxAppConsole) in console programs
-    typedef wxAppConsole wxApp;
+    //wxApp is defined in core and we cannot define another one in wxBase
+    //We create different class and typedef it to wxApp instead
+    #if defined(__UNIX__)
+        #include "wx/unix/app.h"
+        typedef wxEventApp wxApp;
+    #elif defined(__WXMSW__)
+        #include "wx/msw/appcon.h"
+        typedef wxEventApp wxApp;
+    #else
+      // allow using just wxApp (instead of wxAppConsole) in console programs
+      typedef wxAppConsole wxApp;
+    #endif
 #endif // GUI/!GUI
 
 // ----------------------------------------------------------------------------
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/apptrait.h wxWidgets-2.8.0-p22/include/wx/apptrait.h
--- wxWidgets-2.8.0/include/wx/apptrait.h	2006-12-14 15:58:25.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/apptrait.h	2006-12-04 19:06:24.000000000 +0100
@@ -14,6 +14,7 @@
 
 #include "wx/string.h"
 #include "wx/platinfo.h"
+#include "wx/private/timerimpl.h"
 
 class WXDLLIMPEXP_BASE wxObject;
 class WXDLLEXPORT wxAppTraits;
@@ -24,6 +25,7 @@
 class WXDLLIMPEXP_BASE wxMessageOutput;
 class WXDLLEXPORT wxRendererNative;
 class WXDLLIMPEXP_BASE wxString;
+class WXDLLIMPEXP_BASE wxTimer;
 
 class GSocketGUIFunctionsTable;
 
@@ -110,6 +112,11 @@
     virtual GSocketGUIFunctionsTable* GetSocketGUIFunctionsTable() = 0;
 #endif
 
+#if wxUSE_TIMER
+    // return platform and toolkit dependent wxTimer implementation
+    virtual wxTimerImpl *CreateTimerImpl(wxTimer *timer) = 0;
+#endif
+
     // return information about the (native) toolkit currently used and its
     // runtime (not compile-time) version.
     // returns wxPORT_BASE for console applications and one of the remaining
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/cocoa/private/timer.h wxWidgets-2.8.0-p22/include/wx/cocoa/private/timer.h
--- wxWidgets-2.8.0/include/wx/cocoa/private/timer.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/cocoa/private/timer.h	2006-11-07 13:22:36.000000000 +0100
@@ -0,0 +1,44 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        timer.h
+// Purpose:     Cocoa wxTimer class
+// Author:      Ryan Norton
+// Id:          $Id: timer.h,v 1.4 2006/09/05 20:45:19 VZ Exp $
+// Copyright:   (c) Ryan Norton
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+
+#ifndef __WX_TIMER_H__
+#define __WX_TIMER_H__
+
+#include "wx/private/timerimpl.h"
+#include "wx/cocoa/ObjcRef.h"
+
+//-----------------------------------------------------------------------------
+// wxTimer
+//-----------------------------------------------------------------------------
+
+DECLARE_WXCOCOA_OBJC_CLASS(NSTimer);
+
+class WXDLLEXPORT wxCocoaTimerImpl : public wxTimerImpl
+{
+public:
+    wxCocoaTimerImpl(wxTimer* p_timer) : wxTimerImpl(p_timer) { Init(); }
+    virtual ~wxCocoaTimerImpl();
+
+    virtual bool Start(int millisecs = -1, bool oneShot = false);
+    virtual void Stop();
+
+    virtual bool IsRunning() const;
+
+    inline WX_NSTimer GetNSTimer()
+    {   return m_cocoaNSTimer; }
+
+protected:
+    void Init();
+
+private:
+    WX_NSTimer m_cocoaNSTimer;
+};
+
+#endif // __WX_TIMER_H__
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/cocoa/timer.h wxWidgets-2.8.0-p22/include/wx/cocoa/timer.h
--- wxWidgets-2.8.0/include/wx/cocoa/timer.h	2006-11-07 12:01:37.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/cocoa/timer.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,47 +0,0 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        timer.h
-// Purpose:     Cocoa wxTimer class
-// Author:      Ryan Norton
-// Id:          $Id: timer.h,v 1.4 2006/09/05 20:45:19 VZ Exp $
-// Copyright:   (c) Ryan Norton
-// Licence:     wxWindows licence
-/////////////////////////////////////////////////////////////////////////////
-
-
-#ifndef __WX_TIMER_H__
-#define __WX_TIMER_H__
-
-#include "wx/cocoa/ObjcRef.h"
-
-//-----------------------------------------------------------------------------
-// wxTimer
-//-----------------------------------------------------------------------------
-
-DECLARE_WXCOCOA_OBJC_CLASS(NSTimer);
-
-class WXDLLEXPORT wxTimer : public wxTimerBase
-{
-public:
-    wxTimer() { Init(); }
-    wxTimer(wxEvtHandler *owner, int timerid = -1) : wxTimerBase(owner, timerid)
-        { Init(); }
-    virtual ~wxTimer();
-
-    virtual bool Start(int millisecs = -1, bool oneShot = false);
-    virtual void Stop();
-
-    virtual bool IsRunning() const;
-
-    inline WX_NSTimer GetNSTimer()
-    {   return m_cocoaNSTimer; }
-
-protected:
-    void Init();
-
-private:
-    WX_NSTimer m_cocoaNSTimer;
-
-    DECLARE_ABSTRACT_CLASS(wxTimer)
-};
-
-#endif // __WX_TIMER_H__
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/generic/private/timer.h wxWidgets-2.8.0-p22/include/wx/generic/private/timer.h
--- wxWidgets-2.8.0/include/wx/generic/private/timer.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/generic/private/timer.h	2006-11-07 13:22:36.000000000 +0100
@@ -0,0 +1,43 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        timer.h
+// Purpose:     Generic implementation of wxTimer class
+// Author:      Vaclav Slavik
+// Id:          $Id: timer.h,v 1.10 2006/09/05 20:45:26 VZ Exp $
+// Copyright:   (c) Vaclav Slavik
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+
+#ifndef __WX_TIMER_H__
+#define __WX_TIMER_H__
+
+#include "wx/private/timerimpl.h"
+
+//-----------------------------------------------------------------------------
+// wxTimer
+//-----------------------------------------------------------------------------
+
+class wxTimerDesc;
+
+class WXDLLEXPORT wxGenericTimerImpl : public wxTimerImpl
+{
+public:
+    wxGenericTimerImpl(wxTimer* p_timer) : wxTimerImpl(p_timer) { Init(); }
+    virtual ~wxGenericTimerImpl();
+
+    virtual bool Start(int millisecs = -1, bool oneShot = false);
+    virtual void Stop();
+
+    virtual bool IsRunning() const;
+
+    // implementation
+    static void NotifyTimers();
+
+protected:
+    void Init();
+
+private:
+    wxTimerDesc *m_desc;
+};
+
+#endif // __WX_TIMER_H__
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/generic/timer.h wxWidgets-2.8.0-p22/include/wx/generic/timer.h
--- wxWidgets-2.8.0/include/wx/generic/timer.h	2006-11-07 12:01:33.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/generic/timer.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,45 +0,0 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        timer.h
-// Purpose:     Generic implementation of wxTimer class
-// Author:      Vaclav Slavik
-// Id:          $Id: timer.h,v 1.10 2006/09/05 20:45:26 VZ Exp $
-// Copyright:   (c) Vaclav Slavik
-// Licence:     wxWindows licence
-/////////////////////////////////////////////////////////////////////////////
-
-
-#ifndef __WX_TIMER_H__
-#define __WX_TIMER_H__
-
-//-----------------------------------------------------------------------------
-// wxTimer
-//-----------------------------------------------------------------------------
-
-class wxTimerDesc;
-
-class WXDLLEXPORT wxTimer : public wxTimerBase
-{
-public:
-    wxTimer() { Init(); }
-    wxTimer(wxEvtHandler *owner, int timerid = -1) : wxTimerBase(owner, timerid)
-        { Init(); }
-    virtual ~wxTimer();
-
-    virtual bool Start(int millisecs = -1, bool oneShot = false);
-    virtual void Stop();
-
-    virtual bool IsRunning() const;
-
-    // implementation
-    static void NotifyTimers();
-
-protected:
-    void Init();
-
-private:
-    wxTimerDesc *m_desc;
-
-    DECLARE_ABSTRACT_CLASS(wxTimer)
-};
-
-#endif // __WX_TIMER_H__
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/gtk/private/timer.h wxWidgets-2.8.0-p22/include/wx/gtk/private/timer.h
--- wxWidgets-2.8.0/include/wx/gtk/private/timer.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/gtk/private/timer.h	2006-11-07 13:22:36.000000000 +0100
@@ -0,0 +1,35 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/gtk/timer.h
+// Purpose:
+// Author:      Robert Roebling
+// Id:          $Id: timer.h,v 1.14 2006/09/05 20:45:32 VZ Exp $
+// Copyright:   (c) 1998 Robert Roebling
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef __GTKTIMERH__
+#define __GTKTIMERH__
+
+#include "wx/private/timerimpl.h"
+
+//-----------------------------------------------------------------------------
+// wxTimer
+//-----------------------------------------------------------------------------
+
+class WXDLLIMPEXP_CORE wxGTKTimerImpl : public wxTimerImpl
+{
+public:
+    wxGTKTimerImpl(wxTimer* p_timer) : wxTimerImpl(p_timer) { m_tag = -1; };
+    virtual void Init();
+    virtual ~wxGTKTimerImpl();
+
+    virtual bool Start( int millisecs = -1, bool oneShot = false );
+    virtual void Stop();
+
+    virtual bool IsRunning() const { return m_tag != -1; }
+
+protected:
+    int  m_tag;
+};
+
+#endif // __GTKTIMERH__
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/gtk/timer.h wxWidgets-2.8.0-p22/include/wx/gtk/timer.h
--- wxWidgets-2.8.0/include/wx/gtk/timer.h	2006-11-07 12:01:25.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/gtk/timer.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,39 +0,0 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        wx/gtk/timer.h
-// Purpose:
-// Author:      Robert Roebling
-// Id:          $Id: timer.h,v 1.14 2006/09/05 20:45:32 VZ Exp $
-// Copyright:   (c) 1998 Robert Roebling
-// Licence:     wxWindows licence
-/////////////////////////////////////////////////////////////////////////////
-
-#ifndef __GTKTIMERH__
-#define __GTKTIMERH__
-
-//-----------------------------------------------------------------------------
-// wxTimer
-//-----------------------------------------------------------------------------
-
-class WXDLLIMPEXP_CORE wxTimer : public wxTimerBase
-{
-public:
-    wxTimer() { Init(); }
-    wxTimer(wxEvtHandler *owner, int id = -1) : wxTimerBase(owner, id)
-        { Init(); }
-    virtual ~wxTimer();
-
-    virtual bool Start( int millisecs = -1, bool oneShot = FALSE );
-    virtual void Stop();
-
-    virtual bool IsRunning() const { return m_tag != -1; }
-
-protected:
-    void Init();
-
-    int  m_tag;
-
-private:
-    DECLARE_ABSTRACT_CLASS(wxTimer)
-};
-
-#endif // __GTKTIMERH__
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/gtk1/private/timer.h wxWidgets-2.8.0-p22/include/wx/gtk1/private/timer.h
--- wxWidgets-2.8.0/include/wx/gtk1/private/timer.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/gtk1/private/timer.h	2006-11-07 13:22:33.000000000 +0100
@@ -0,0 +1,36 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/gtk1/timer.h
+// Purpose:
+// Author:      Robert Roebling
+// Id:          $Id: timer.h,v 1.15 2006/09/05 20:45:41 VZ Exp $
+// Copyright:   (c) 1998 Robert Roebling
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef __GTKTIMERH__
+#define __GTKTIMERH__
+
+#include "wx/private/timerimpl.h"
+
+//-----------------------------------------------------------------------------
+// wxTimer
+//-----------------------------------------------------------------------------
+
+class WXDLLIMPEXP_CORE wxGTK1TimerImpl : public wxTimerImpl
+{
+public:
+    wxGTK1TimerImpl(wxTimer *p_timer) : wxTimerImpl(p_timer) { Init(); }
+    virtual ~wxGTK1TimerImpl();
+
+    virtual bool Start( int millisecs = -1, bool oneShot = FALSE );
+    virtual void Stop();
+
+    virtual bool IsRunning() const { return m_tag != -1; }
+
+protected:
+    void Init();
+
+    int  m_tag;
+};
+
+#endif // __GTKTIMERH__
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/gtk1/timer.h wxWidgets-2.8.0-p22/include/wx/gtk1/timer.h
--- wxWidgets-2.8.0/include/wx/gtk1/timer.h	2006-11-07 12:00:32.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/gtk1/timer.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,39 +0,0 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        wx/gtk1/timer.h
-// Purpose:
-// Author:      Robert Roebling
-// Id:          $Id: timer.h,v 1.15 2006/09/05 20:45:41 VZ Exp $
-// Copyright:   (c) 1998 Robert Roebling
-// Licence:     wxWindows licence
-/////////////////////////////////////////////////////////////////////////////
-
-#ifndef __GTKTIMERH__
-#define __GTKTIMERH__
-
-//-----------------------------------------------------------------------------
-// wxTimer
-//-----------------------------------------------------------------------------
-
-class WXDLLIMPEXP_CORE wxTimer : public wxTimerBase
-{
-public:
-    wxTimer() { Init(); }
-    wxTimer(wxEvtHandler *owner, int id = -1) : wxTimerBase(owner, id)
-        { Init(); }
-    virtual ~wxTimer();
-
-    virtual bool Start( int millisecs = -1, bool oneShot = FALSE );
-    virtual void Stop();
-
-    virtual bool IsRunning() const { return m_tag != -1; }
-
-protected:
-    void Init();
-
-    int  m_tag;
-
-private:
-    DECLARE_ABSTRACT_CLASS(wxTimer)
-};
-
-#endif // __GTKTIMERH__
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/mac/carbon/apptrait.h wxWidgets-2.8.0-p22/include/wx/mac/carbon/apptrait.h
--- wxWidgets-2.8.0/include/wx/mac/carbon/apptrait.h	2006-11-07 12:00:44.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/mac/carbon/apptrait.h	2006-11-07 13:22:35.000000000 +0100
@@ -19,6 +19,10 @@
 class WXDLLEXPORT wxConsoleAppTraits : public wxConsoleAppTraitsBase
 {
 public:
+    // no timer support in wxBase
+#if wxUSE_TIMER
+    virtual wxTimerImpl *CreateTimerImpl(wxTimer *timer) { return NULL; };
+#endif
     // other miscellaneous helpers
     // ---------------------------
 
@@ -30,6 +34,9 @@
 class WXDLLEXPORT wxGUIAppTraits : public wxGUIAppTraitsBase
 {
 public:
+#if wxUSE_TIMER
+    virtual wxTimerImpl *CreateTimerImpl(wxTimer *timer);
+#endif
     // other miscellaneous helpers
     // ---------------------------
 
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/mac/carbon/gsockmac.h wxWidgets-2.8.0-p22/include/wx/mac/carbon/gsockmac.h
--- wxWidgets-2.8.0/include/wx/mac/carbon/gsockmac.h	2006-11-07 12:00:44.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/mac/carbon/gsockmac.h	2006-11-08 13:56:34.000000000 +0100
@@ -67,7 +67,8 @@
     GSocketError SetSockOpt(int level, int optname,
         const void *optval, int optlen)
     {   return GSOCK_INVOP; }
-
+    //needed in wxBase for adding and removing socket descriptor from mainloop set
+    void Notify(bool pFlag) {};
 protected:
     bool m_ok;
 
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/mac/carbon/private/timer.h wxWidgets-2.8.0-p22/include/wx/mac/carbon/private/timer.h
--- wxWidgets-2.8.0/include/wx/mac/carbon/private/timer.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/mac/carbon/private/timer.h	2006-11-07 13:22:34.000000000 +0100
@@ -0,0 +1,41 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        timer.h
+// Purpose:     wxTimer class
+// Author:      Stefan Csomor
+// Modified by:
+// Created:     1998-01-01
+// RCS-ID:      $Id: timer.h,v 1.6 2006/09/05 20:45:53 VZ Exp $
+// Copyright:   (c) Stefan Csomor
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_TIMER_H_
+#define _WX_TIMER_H_
+
+#include "wx/object.h"
+#include "wx/mac/macnotfy.h"
+#include "wx/private/timerimpl.h"
+
+class wxTimer ;
+
+struct MacTimerInfo ;
+
+class WXDLLEXPORT wxCarbonTimerImpl: public wxTimerImpl
+{
+public:
+    wxCarbonTimerImpl(wxTimer *p_timer) : wxTimerImpl(p_timer) { Init(); }
+    virtual ~wxCarbonTimerImpl();
+
+    virtual bool Start(int milliseconds = -1,
+                       bool one_shot = false); // Start timer
+    virtual void Stop();                       // Stop timer
+
+    virtual bool IsRunning() const ;
+
+    MacTimerInfo* m_info;
+protected :
+    void Init();
+};
+
+#endif
+    // _WX_TIMER_H_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/mac/carbon/timer.h wxWidgets-2.8.0-p22/include/wx/mac/carbon/timer.h
--- wxWidgets-2.8.0/include/wx/mac/carbon/timer.h	2006-11-07 12:00:44.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/mac/carbon/timer.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,44 +0,0 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        timer.h
-// Purpose:     wxTimer class
-// Author:      Stefan Csomor
-// Modified by:
-// Created:     1998-01-01
-// RCS-ID:      $Id: timer.h,v 1.6 2006/09/05 20:45:53 VZ Exp $
-// Copyright:   (c) Stefan Csomor
-// Licence:     wxWindows licence
-/////////////////////////////////////////////////////////////////////////////
-
-#ifndef _WX_TIMER_H_
-#define _WX_TIMER_H_
-
-#include "wx/object.h"
-#include "wx/mac/macnotfy.h"
-
-class wxTimer ;
-
-struct MacTimerInfo ;
-
-class WXDLLEXPORT wxTimer: public wxTimerBase
-{
-public:
-    wxTimer() { Init(); }
-    wxTimer(wxEvtHandler *owner, int id = -1) : wxTimerBase(owner, id) { Init(); }
-    virtual ~wxTimer();
-
-    virtual bool Start(int milliseconds = -1,
-                       bool one_shot = FALSE); // Start timer
-    virtual void Stop();                       // Stop timer
-
-    virtual bool IsRunning() const ;
-
-    MacTimerInfo* m_info;
-protected :
-    void Init();
-private:
-
-    DECLARE_ABSTRACT_CLASS(wxTimer)
-};
-
-#endif
-    // _WX_TIMER_H_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/mac/classic/apptrait.h wxWidgets-2.8.0-p22/include/wx/mac/classic/apptrait.h
--- wxWidgets-2.8.0/include/wx/mac/classic/apptrait.h	2006-11-07 12:00:38.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/mac/classic/apptrait.h	2006-11-07 13:22:34.000000000 +0100
@@ -19,6 +19,10 @@
 class WXDLLEXPORT wxConsoleAppTraits : public wxConsoleAppTraitsBase
 {
 public:
+#if wxUSE_TIMER
+    // no timer suport in wxBase
+    virtual wxTimerImpl *CreateTimerImpl(wxTimer *timer) { return NULL; };
+#endif
     // other miscellaneous helpers
     // ---------------------------
 
@@ -30,6 +34,10 @@
 class WXDLLEXPORT wxGUIAppTraits : public wxGUIAppTraitsBase
 {
 public:
+#if wxUSE_TIMER
+    // return platform and toolkit dependent wxTimer implementation
+    virtual wxTimerImpl *CreateTimerImpl(wxTimer *timer);
+#endif
     // other miscellaneous helpers
     // ---------------------------
 
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/mac/classic/private/timer.h wxWidgets-2.8.0-p22/include/wx/mac/classic/private/timer.h
--- wxWidgets-2.8.0/include/wx/mac/classic/private/timer.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/mac/classic/private/timer.h	2006-11-07 13:22:34.000000000 +0100
@@ -0,0 +1,39 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        timer.h
+// Purpose:     wxTimer class
+// Author:      Stefan Csomor
+// Modified by:
+// Created:     1998-01-01
+// RCS-ID:      $Id: timer.h,v 1.5 2006/09/05 20:46:01 VZ Exp $
+// Copyright:   (c) Stefan Csomor
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_TIMER_H_
+#define _WX_TIMER_H_
+
+#include "wx/object.h"
+#include "wx/mac/macnotfy.h"
+#inlcude "wx/mac/timer.h"
+
+struct MacTimerInfo ;
+
+class WXDLLEXPORT wxMacClassicTimerImpl: public wxTimerImpl
+{
+public:
+    wxMacClassicTimerImpl(wxTimer* p_timer) : wxTimerImpl(p_timer) { Init(); }
+    virtual ~wxMacClassicTimerImpl();
+
+    virtual bool Start(int milliseconds = -1,
+                       bool one_shot = FALSE); // Start timer
+    virtual void Stop();                       // Stop timer
+
+    virtual bool IsRunning() const ;
+
+    MacTimerInfo* m_info;
+protected :
+    void Init();
+};
+
+#endif
+    // _WX_TIMER_H_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/mac/classic/timer.h wxWidgets-2.8.0-p22/include/wx/mac/classic/timer.h
--- wxWidgets-2.8.0/include/wx/mac/classic/timer.h	2006-11-07 12:00:38.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/mac/classic/timer.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,44 +0,0 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        timer.h
-// Purpose:     wxTimer class
-// Author:      Stefan Csomor
-// Modified by:
-// Created:     1998-01-01
-// RCS-ID:      $Id: timer.h,v 1.5 2006/09/05 20:46:01 VZ Exp $
-// Copyright:   (c) Stefan Csomor
-// Licence:     wxWindows licence
-/////////////////////////////////////////////////////////////////////////////
-
-#ifndef _WX_TIMER_H_
-#define _WX_TIMER_H_
-
-#include "wx/object.h"
-#include "wx/mac/macnotfy.h"
-
-class wxTimer ;
-
-struct MacTimerInfo ;
-
-class WXDLLEXPORT wxTimer: public wxTimerBase
-{
-public:
-    wxTimer() { Init(); }
-    wxTimer(wxEvtHandler *owner, int id = -1) : wxTimerBase(owner, id) { Init(); }
-    virtual ~wxTimer();
-
-    virtual bool Start(int milliseconds = -1,
-                       bool one_shot = FALSE); // Start timer
-    virtual void Stop();                       // Stop timer
-
-    virtual bool IsRunning() const ;
-
-    MacTimerInfo* m_info;
-protected :
-    void Init();
-private:
-
-    DECLARE_ABSTRACT_CLASS(wxTimer)
-};
-
-#endif
-    // _WX_TIMER_H_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/mac/private/timer.h wxWidgets-2.8.0-p22/include/wx/mac/private/timer.h
--- wxWidgets-2.8.0/include/wx/mac/private/timer.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/mac/private/timer.h	2006-11-07 13:22:34.000000000 +0100
@@ -0,0 +1,5 @@
+#ifdef __WXMAC_CLASSIC__
+#include "wx/mac/classic/private/timer.h"
+#else
+#include "wx/mac/carbon/private/timer.h"
+#endif
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/mac/timer.h wxWidgets-2.8.0-p22/include/wx/mac/timer.h
--- wxWidgets-2.8.0/include/wx/mac/timer.h	2006-11-07 12:00:44.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/mac/timer.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-#ifdef __WXMAC_CLASSIC__
-#include "wx/mac/classic/timer.h"
-#else
-#include "wx/mac/carbon/timer.h"
-#endif
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/motif/private/timer.h wxWidgets-2.8.0-p22/include/wx/motif/private/timer.h
--- wxWidgets-2.8.0/include/wx/motif/private/timer.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/motif/private/timer.h	2006-11-07 13:22:33.000000000 +0100
@@ -0,0 +1,37 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/motif/timer.h
+// Purpose:     wxTimer class
+// Author:      Julian Smart
+// Modified by:
+// Created:     17/09/98
+// RCS-ID:      $Id: timer.h,v 1.14 2006/09/05 20:46:14 VZ Exp $
+// Copyright:   (c) Julian Smart
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_TIMER_H_
+#define _WX_TIMER_H_
+
+#include "wx/private/timerimpl.h"
+
+class WXDLLEXPORT wxMotifTimerImpl : public wxTimerImpl
+{
+    friend void wxTimerCallback(wxMotifTimerImpl * timer);
+
+public:
+    wxMotifTimerImpl(wxTimer* p_timer) : wxTimerImpl(p_timer) { Init(); }
+    virtual ~wxMotifTimerImpl();
+
+    virtual bool Start(int milliseconds = -1, bool oneShot = false);
+    virtual void Stop();
+
+    virtual bool IsRunning() const { return m_id != 0; }
+
+protected:
+    void Init();
+
+    long m_id;
+};
+
+#endif
+// _WX_TIMER_H_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/motif/timer.h wxWidgets-2.8.0-p22/include/wx/motif/timer.h
--- wxWidgets-2.8.0/include/wx/motif/timer.h	2006-11-07 12:00:29.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/motif/timer.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,40 +0,0 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        wx/motif/timer.h
-// Purpose:     wxTimer class
-// Author:      Julian Smart
-// Modified by:
-// Created:     17/09/98
-// RCS-ID:      $Id: timer.h,v 1.14 2006/09/05 20:46:14 VZ Exp $
-// Copyright:   (c) Julian Smart
-// Licence:     wxWindows licence
-/////////////////////////////////////////////////////////////////////////////
-
-#ifndef _WX_TIMER_H_
-#define _WX_TIMER_H_
-
-class WXDLLEXPORT wxTimer : public wxTimerBase
-{
-    friend void wxTimerCallback(wxTimer * timer);
-
-public:
-    wxTimer() { Init(); }
-    wxTimer(wxEvtHandler *owner, int id = -1) : wxTimerBase(owner, id)
-    { Init(); }
-    virtual ~wxTimer();
-
-    virtual bool Start(int milliseconds = -1, bool oneShot = false);
-    virtual void Stop();
-
-    virtual bool IsRunning() const { return m_id != 0; }
-
-protected:
-    void Init();
-
-    long m_id;
-
-private:
-    DECLARE_DYNAMIC_CLASS(wxTimer)
-};
-
-#endif
-// _WX_TIMER_H_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/msw/appcon.h wxWidgets-2.8.0-p22/include/wx/msw/appcon.h
--- wxWidgets-2.8.0/include/wx/msw/appcon.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/msw/appcon.h	2006-11-10 14:25:34.000000000 +0100
@@ -0,0 +1,50 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/msw/appcon.h
+// Purpose:     wxAppConsole with wxMainLoop implementation
+// Author:      Lukasz Michalski
+// Modified by:
+// Created:     15/09/2005
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) Lukasz Michalski
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#include "wx/msw/gsockmsw.h"
+#include <wx/socket.h>
+
+#ifndef _APPCON_H_
+#define _APPCON_H_
+
+//Main application class
+class WXDLLIMPEXP_BASE wxEventApp : public wxAppConsole 
+{
+  public:
+    wxEventApp();
+    ~wxEventApp();
+    //Start program execution by entering main loop and waiting for events
+    virtual bool Initialize(int& argc, wxChar** argv);
+    virtual int OnRun();
+    virtual int MainLoop();
+    virtual void WakeUpIdle();
+    virtual void ExitMainLoop();
+    virtual void CleanUp();
+    virtual void Dispatch(); 
+#if wxUSE_EXCEPTIONS
+    virtual bool OnExceptionInMainLoop();
+#endif // wxUSE_EXCEPTIONS
+
+    static bool initSocket(GSocket* pSocket, wxIPV4address* pAddress);
+    
+  private:
+    wxCriticalSection mWakeupCS;
+    bool mIsProcessingEvent;
+
+  protected:
+    bool mExiting;
+    int mExitCode;
+#if wxUSE_THREADS
+    DWORD mMSWThreadID;
+#endif
+};
+
+#endif //_APPCON_H_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/msw/apptrait.h wxWidgets-2.8.0-p22/include/wx/msw/apptrait.h
--- wxWidgets-2.8.0/include/wx/msw/apptrait.h	2006-11-07 12:01:04.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/msw/apptrait.h	2006-11-07 13:22:35.000000000 +0100
@@ -22,7 +22,9 @@
     virtual void *BeforeChildWaitLoop();
     virtual void AlwaysYield();
     virtual void AfterChildWaitLoop(void *data);
-
+#if wxUSE_TIMER
+    virtual wxTimerImpl *CreateTimerImpl(wxTimer *timer);
+#endif
     virtual bool DoMessageFromThreadWait();
 };
 
@@ -34,7 +36,9 @@
     virtual void *BeforeChildWaitLoop();
     virtual void AlwaysYield();
     virtual void AfterChildWaitLoop(void *data);
-
+#if wxUSE_TIMER
+    virtual wxTimerImpl *CreateTimerImpl(wxTimer *timer);
+#endif
     virtual bool DoMessageFromThreadWait();
     virtual wxPortId GetToolkitVersion(int *majVer, int *minVer) const;
 };
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/msw/gsockmsw.h wxWidgets-2.8.0-p22/include/wx/msw/gsockmsw.h
--- wxWidgets-2.8.0/include/wx/msw/gsockmsw.h	2006-11-07 12:01:04.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/msw/gsockmsw.h	2006-11-08 13:56:34.000000000 +0100
@@ -78,6 +78,8 @@
     void *optval, int *optlen);
   GSocketError SetSockOpt(int level, int optname,
     const void *optval, int optlen);
+  //needed in wxBase for adding and removing socket descriptor from mainloop set
+  void Notify(bool) {};
 protected:
   GSocketError Input_Timeout();
   GSocketError Output_Timeout();
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/msw/private/timer.h wxWidgets-2.8.0-p22/include/wx/msw/private/timer.h
--- wxWidgets-2.8.0/include/wx/msw/private/timer.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/msw/private/timer.h	2006-11-10 14:25:34.000000000 +0100
@@ -0,0 +1,37 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        timer.h
+// Purpose:     wxTimer class
+// Author:      Julian Smart
+// Modified by:
+// Created:     01/02/97
+// RCS-ID:      $Id: timer.h,v 1.20 2006/09/05 20:46:21 VZ Exp $
+// Copyright:   (c) Julian Smart
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_TIMER_H_
+#define _WX_TIMER_H_
+
+#include "wx/private/timerimpl.h"
+
+class WXDLLEXPORT wxMSWTimerImpl : public wxTimerImpl
+{
+friend void wxProcessTimer(wxMSWTimerImpl& timer);
+
+public:
+    wxMSWTimerImpl(wxTimer *p_timer) : wxTimerImpl(p_timer) { Init(); }
+    virtual ~wxMSWTimerImpl();
+
+    virtual bool Start(int milliseconds = -1, bool oneShot = false);
+    virtual void Stop();
+
+    virtual bool IsRunning() const { return m_id != 0; }
+
+protected:
+    void Init();
+
+    unsigned long m_id;
+};
+
+#endif
+    // _WX_TIMERH_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/msw/timer.h wxWidgets-2.8.0-p22/include/wx/msw/timer.h
--- wxWidgets-2.8.0/include/wx/msw/timer.h	2006-11-07 12:01:04.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/msw/timer.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,40 +0,0 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        timer.h
-// Purpose:     wxTimer class
-// Author:      Julian Smart
-// Modified by:
-// Created:     01/02/97
-// RCS-ID:      $Id: timer.h,v 1.20 2006/09/05 20:46:21 VZ Exp $
-// Copyright:   (c) Julian Smart
-// Licence:     wxWindows licence
-/////////////////////////////////////////////////////////////////////////////
-
-#ifndef _WX_TIMER_H_
-#define _WX_TIMER_H_
-
-class WXDLLEXPORT wxTimer : public wxTimerBase
-{
-friend void wxProcessTimer(wxTimer& timer);
-
-public:
-    wxTimer() { Init(); }
-    wxTimer(wxEvtHandler *owner, int id = wxID_ANY) : wxTimerBase(owner, id)
-        { Init(); }
-    virtual ~wxTimer();
-
-    virtual bool Start(int milliseconds = -1, bool oneShot = false);
-    virtual void Stop();
-
-    virtual bool IsRunning() const { return m_id != 0; }
-
-protected:
-    void Init();
-
-    unsigned long m_id;
-
-private:
-    DECLARE_DYNAMIC_CLASS_NO_COPY(wxTimer)
-};
-
-#endif
-    // _WX_TIMERH_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/os2/apptrait.h wxWidgets-2.8.0-p22/include/wx/os2/apptrait.h
--- wxWidgets-2.8.0/include/wx/os2/apptrait.h	2006-11-29 12:34:12.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/os2/apptrait.h	2006-11-29 12:32:21.000000000 +0100
@@ -19,6 +19,9 @@
 class WXDLLIMPEXP_BASE wxConsoleAppTraits : public wxConsoleAppTraitsBase
 {
 public:
+#if wxUSE_TIMER
+    virtual wxTimerImpl *CreateTimerImpl(wxTimer *timer) { return NULL; };
+#endif
 };
 
 #if wxUSE_GUI
@@ -26,6 +29,9 @@
 class WXDLLIMPEXP_CORE wxGUIAppTraits : public wxGUIAppTraitsBase
 {
 public:
+#if wxUSE_TIMER
+    virtual wxTimerImpl *CreateTimerImpl(wxTimer *timer);
+#endif
     virtual wxPortId GetToolkitVersion(int *majVer, int *minVer) const;
 
     // wxThread helpers
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/os2/private/timer.h wxWidgets-2.8.0-p22/include/wx/os2/private/timer.h
--- wxWidgets-2.8.0/include/wx/os2/private/timer.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/os2/private/timer.h	2006-11-07 13:22:36.000000000 +0100
@@ -0,0 +1,47 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        timer.h
+// Purpose:     wxTimer class
+// Author:      David Webster
+// Modified by:
+// Created:     10/17/99
+// RCS-ID:      $Id: timer.h,v 1.14 2006/09/05 20:46:30 VZ Exp $
+// Copyright:   (c) David Webster
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_TIMER_H_
+#define _WX_TIMER_H_
+
+#include "wx/private/timerimpl.h"
+
+class WXDLLEXPORT wxOS2TimerImpl: public wxTimerImpl
+{
+friend void wxProcessTimer(wxOS2TimerImpl& timer);
+
+public:
+    wxOS2TimerImpl(wxTimer *p_timer) : wxTimerImpl(p_timer) { Init(); }
+    virtual ~wxOS2TimerImpl();
+
+    virtual void Notify(void);
+    virtual bool Start( int  nMilliseconds = -1
+                       ,bool bOneShot = FALSE
+                      );
+    virtual void Stop(void);
+
+    inline virtual bool IsRunning(void) const { return m_ulId != 0L; }
+    inline          int GetTimerId(void) const { return m_idTimer; }
+
+protected:
+    void Init(void);
+
+    ULONG                            m_ulId;
+    HAB                              m_Hab;
+};
+
+extern ULONG wxTimerProc( HWND  WXUNUSED(hwnd)
+                         ,ULONG
+                         ,int   nIdTimer
+                         ,ULONG
+                        );
+#endif
+    // _WX_TIMER_H_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/os2/timer.h wxWidgets-2.8.0-p22/include/wx/os2/timer.h
--- wxWidgets-2.8.0/include/wx/os2/timer.h	2006-11-07 12:01:15.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/os2/timer.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,57 +0,0 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        timer.h
-// Purpose:     wxTimer class
-// Author:      David Webster
-// Modified by:
-// Created:     10/17/99
-// RCS-ID:      $Id: timer.h,v 1.14 2006/09/05 20:46:30 VZ Exp $
-// Copyright:   (c) David Webster
-// Licence:     wxWindows licence
-/////////////////////////////////////////////////////////////////////////////
-
-#ifndef _WX_TIMER_H_
-#define _WX_TIMER_H_
-
-#include "wx/object.h"
-
-class WXDLLEXPORT wxTimer: public wxTimerBase
-{
-friend void wxProcessTimer(wxTimer& timer);
-
-public:
-    wxTimer() { Init(); }
-    wxTimer( wxEvtHandler* pOwner
-            ,int           nId = -1
-           )
-           : wxTimerBase( pOwner
-                         ,nId
-                        )
-        { Init(); }
-    virtual ~wxTimer();
-
-    virtual void Notify(void);
-    virtual bool Start( int  nMilliseconds = -1
-                       ,bool bOneShot = FALSE
-                      );
-    virtual void Stop(void);
-
-    inline virtual bool IsRunning(void) const { return m_ulId != 0L; }
-    inline          int GetTimerId(void) const { return m_idTimer; }
-
-protected:
-    void Init(void);
-
-    ULONG                            m_ulId;
-    HAB                              m_Hab;
-
-private:
-    DECLARE_ABSTRACT_CLASS(wxTimer)
-};
-
-extern ULONG wxTimerProc( HWND  WXUNUSED(hwnd)
-                         ,ULONG
-                         ,int   nIdTimer
-                         ,ULONG
-                        );
-#endif
-    // _WX_TIMER_H_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/palmos/apptrait.h wxWidgets-2.8.0-p22/include/wx/palmos/apptrait.h
--- wxWidgets-2.8.0/include/wx/palmos/apptrait.h	2006-11-07 12:00:51.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/palmos/apptrait.h	2006-11-07 13:22:35.000000000 +0100
@@ -22,7 +22,9 @@
     virtual void *BeforeChildWaitLoop();
     virtual void AlwaysYield();
     virtual void AfterChildWaitLoop(void *data);
-
+#if wxUSE_TIMER
+    virtual wxTimerImpl *CreateTimerImpl(wxTimer *timer) { return NULL; };
+#endif
     virtual bool DoMessageFromThreadWait();
 };
 
@@ -34,7 +36,10 @@
     virtual void *BeforeChildWaitLoop();
     virtual void AlwaysYield();
     virtual void AfterChildWaitLoop(void *data);
-
+#if wxUSE_TIMER
+    //there is no wxTimer support yet 
+    virtual wxTimerImpl *CreateTimerImpl(wxTimer *timer);
+#endif
     virtual bool DoMessageFromThreadWait();
     virtual wxPortId GetToolkitVersion(int *majVer, int *minVer) const;
 };
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/palmos/private/timer.h wxWidgets-2.8.0-p22/include/wx/palmos/private/timer.h
--- wxWidgets-2.8.0/include/wx/palmos/private/timer.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/palmos/private/timer.h	2006-11-07 13:22:35.000000000 +0100
@@ -0,0 +1,37 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/palmos/timer.h
+// Purpose:     wxTimer class
+// Author:      William Osborne - minimal working wxPalmOS port
+// Modified by:
+// Created:     10/13/04
+// RCS-ID:      $Id: timer.h,v 1.4 2006/09/05 20:46:35 VZ Exp $
+// Copyright:   (c) William Osborne
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_TIMER_H_
+#define _WX_TIMER_H_
+
+#include "wx/private/timerimpl.h"
+
+class WXDLLEXPORT wxPalmOSTimerImpl : public wxTimerImpl
+{
+friend void wxProcessTimer(wxTimer& timer);
+
+public:
+    wxPalmOSTimerImpl(wxTimer* p_timer) : wxTimerImpl(p_timer) { Init(); }
+    virtual ~wxPalmOSTimerImpl();
+
+    virtual bool Start(int milliseconds = -1, bool oneShot = FALSE);
+    virtual void Stop();
+
+    virtual bool IsRunning() const { return m_id != 0; }
+
+protected:
+    void Init();
+
+    unsigned long m_id;
+};
+
+#endif
+    // _WX_TIMERH_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/palmos/timer.h wxWidgets-2.8.0-p22/include/wx/palmos/timer.h
--- wxWidgets-2.8.0/include/wx/palmos/timer.h	2006-11-07 12:00:51.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/palmos/timer.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,40 +0,0 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        wx/palmos/timer.h
-// Purpose:     wxTimer class
-// Author:      William Osborne - minimal working wxPalmOS port
-// Modified by:
-// Created:     10/13/04
-// RCS-ID:      $Id: timer.h,v 1.4 2006/09/05 20:46:35 VZ Exp $
-// Copyright:   (c) William Osborne
-// Licence:     wxWindows licence
-/////////////////////////////////////////////////////////////////////////////
-
-#ifndef _WX_TIMER_H_
-#define _WX_TIMER_H_
-
-class WXDLLEXPORT wxTimer : public wxTimerBase
-{
-friend void wxProcessTimer(wxTimer& timer);
-
-public:
-    wxTimer() { Init(); }
-    wxTimer(wxEvtHandler *owner, int id = -1) : wxTimerBase(owner, id)
-        { Init(); }
-    virtual ~wxTimer();
-
-    virtual bool Start(int milliseconds = -1, bool oneShot = FALSE);
-    virtual void Stop();
-
-    virtual bool IsRunning() const { return m_id != 0; }
-
-protected:
-    void Init();
-
-    unsigned long m_id;
-
-private:
-    DECLARE_DYNAMIC_CLASS_NO_COPY(wxTimer)
-};
-
-#endif
-    // _WX_TIMERH_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/private/timerimpl.h wxWidgets-2.8.0-p22/include/wx/private/timerimpl.h
--- wxWidgets-2.8.0/include/wx/private/timerimpl.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/private/timerimpl.h	2006-11-07 13:22:36.000000000 +0100
@@ -0,0 +1,46 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/private/timerimpl.h
+// Purpose:     Base class for wxTimer implementations
+// Author:      Lukasz Michalski <lmichalski@sf.net>
+// Modified by: 
+//              
+// Created:     31.10.2006
+// RCS-ID:      $Id: timer.h,v 1.58 2006/08/27 09:41:26 VS Exp $
+// Copyright:   (c) 
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_TIMERIMPL_H_BASE_
+#define _WX_TIMERIMPL_H_BASE_
+
+#include "wx/defs.h"
+#include "wx/event.h"
+
+class wxTimer;
+
+// abstract base class for wxTimer implementations
+class wxTimerImpl 
+{
+public:
+    wxTimerImpl(wxTimer* p_owner);
+
+    // start the timer. When overriding call base version first.
+    virtual bool Start(int milliseconds = -1, bool oneShot = false);
+
+    // stop the timer
+    virtual void Stop() = 0;
+
+    // return true if the timer is running
+    virtual bool IsRunning() const = 0;
+
+    //post event to event handler when timer expires
+    virtual void Notify();
+
+    wxEvtHandler *m_owner;
+    bool    m_oneShot;      // true if one shot
+    long    m_idTimer;      // id passed to wxTimerEvent
+    int     m_milli;        // the timer interval
+};
+
+#endif
+    // _WX_TIMERIMPL_H_BASE_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/timer.h wxWidgets-2.8.0-p22/include/wx/timer.h
--- wxWidgets-2.8.0/include/wx/timer.h	2006-11-07 12:01:40.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/timer.h	2006-11-08 14:04:18.000000000 +0100
@@ -15,13 +15,13 @@
 
 #include "wx/defs.h"
 
-#if wxUSE_GUI && wxUSE_TIMER
+#if wxUSE_TIMER && (!wxUSE_GUI || defined(__UNIX__) || defined(__WXMSW__))
 
 #include "wx/object.h"
 #include "wx/longlong.h"
 #include "wx/event.h"
 #include "wx/stopwatch.h" // for backwards compatibility
-
+#include "wx/utils.h"
 
 // more readable flags for Start():
 
@@ -31,8 +31,10 @@
 // only send the notification once and then stop the timer
 #define wxTIMER_ONE_SHOT true
 
+class wxTimerImpl;
+
 // the interface of wxTimer class
-class WXDLLEXPORT wxTimerBase : public wxEvtHandler
+class WXDLLEXPORT wxTimer : public wxEvtHandler
 {
 public:
     // ctors and initializers
@@ -40,24 +42,25 @@
 
     // default: if you don't call SetOwner(), your only chance to get timer
     // notifications is to override Notify() in the derived class
-    wxTimerBase()
+    wxTimer()
         { Init(); SetOwner(this); }
 
     // ctor which allows to avoid having to override Notify() in the derived
     // class: the owner will get timer notifications which can be handled with
     // EVT_TIMER
-    wxTimerBase(wxEvtHandler *owner, int timerid = wxID_ANY)
+    wxTimer(wxEvtHandler *owner, int timerid = wxID_ANY)
         { Init(); SetOwner(owner, timerid); }
 
     // same as ctor above
-    void SetOwner(wxEvtHandler *owner, int timerid = wxID_ANY)
-        { m_owner = owner; m_idTimer = timerid == wxID_ANY ? wxNewId() : timerid; }
-    wxEvtHandler * GetOwner() const { return m_owner; }
+    void SetOwner(wxEvtHandler *owner, int timerid = wxID_ANY);
+    
+    wxEvtHandler * GetOwner() const;
 
-    virtual ~wxTimerBase();
+    virtual ~wxTimer();
 
     // working with the timer
     // ----------------------
+    // Timer implementation is forwareded to wxTimerImpl
 
     // start the timer: if milliseconds == -1, use the same value as for the
     // last Start()
@@ -67,7 +70,7 @@
     virtual bool Start(int milliseconds = -1, bool oneShot = false);
 
     // stop the timer
-    virtual void Stop() = 0;
+    virtual void Stop();
 
     // override this in your wxTimer-derived class if you want to process timer
     // messages in it, use non default ctor or SetOwner() otherwise
@@ -77,53 +80,27 @@
     // ------------
 
     // return true if the timer is running
-    virtual bool IsRunning() const = 0;
+    virtual bool IsRunning() const;
 
     // return the timer ID
-    int GetId() const { return m_idTimer; }
+    int GetId() const;
 
     // get the (last) timer interval in milliseconds
-    int GetInterval() const { return m_milli; }
+    int GetInterval() const;
 
     // return true if the timer is one shot
-    bool IsOneShot() const { return m_oneShot; }
+    bool IsOneShot() const;
 
 protected:
     // common part of all ctors
-    void Init()
-        { m_owner = NULL; m_idTimer = wxID_ANY; m_milli = 0; m_oneShot = false; }
+    void Init();
 
-    wxEvtHandler *m_owner;
-    int     m_idTimer;
-    int     m_milli;        // the timer interval
-    bool    m_oneShot;      // true if one shot
+    wxTimerImpl *m_impl;
 
-    DECLARE_NO_COPY_CLASS(wxTimerBase)
+    DECLARE_NO_COPY_CLASS(wxTimer)
 };
 
 // ----------------------------------------------------------------------------
-// wxTimer itself
-// ----------------------------------------------------------------------------
-
-#if defined(__WXMSW__)
-    #include "wx/msw/timer.h"
-#elif defined(__WXMOTIF__)
-    #include "wx/motif/timer.h"
-#elif defined(__WXGTK20__)
-    #include "wx/gtk/timer.h"
-#elif defined(__WXGTK__)
-    #include "wx/gtk1/timer.h"
-#elif defined(__WXX11__) || defined(__WXMGL__) || defined(__WXDFB__)
-    #include "wx/generic/timer.h"
-#elif defined (__WXCOCOA__)
-    #include "wx/cocoa/timer.h"
-#elif defined(__WXMAC__)
-    #include "wx/mac/timer.h"
-#elif defined(__WXPM__)
-    #include "wx/os2/timer.h"
-#endif
-
-// ----------------------------------------------------------------------------
 // wxTimerRunner: starts the timer in its ctor, stops in the dtor
 // ----------------------------------------------------------------------------
 
@@ -190,7 +167,7 @@
 #define EVT_TIMER(timerid, func) \
     wx__DECLARE_EVT1(wxEVT_TIMER, timerid, wxTimerEventHandler(func))
 
-#endif // wxUSE_GUI && wxUSE_TIMER
+#endif // wxUSE_TIMER
 
 #endif
     // _WX_TIMER_H_BASE_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/unix/app.h wxWidgets-2.8.0-p22/include/wx/unix/app.h
--- wxWidgets-2.8.0/include/wx/unix/app.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/unix/app.h	2006-11-08 13:56:34.000000000 +0100
@@ -0,0 +1,54 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/unix/app.h
+// Purpose:     wxAppConsole with wxMainLoop implementation
+// Author:      Lukasz Michalski
+// Modified by:
+// Created:     28/01/2005
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) Lukasz Michalski
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+extern "C" {
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+};
+
+//flag for timer set in handler
+
+//Main application class
+class WXDLLIMPEXP_BASE wxEventApp : public wxAppConsole {
+    friend class GSocketGUIFunctionsTableBase;
+  public:
+    //Start program execution by entering main loop and waiting for events
+    virtual bool Initialize(int& argc, wxChar** argv);
+    virtual int OnRun();
+    virtual int MainLoop();
+    virtual void WakeUpIdle();
+    virtual void ExitMainLoop();
+    virtual void CleanUp();
+    virtual void Dispatch();
+
+    // Some unix specific synchronous signal handler code
+    typedef void (*SignalHandler)(int);
+    // Can reset by setting handler to SIG_DFL or SIG_IGN
+    void SetSignalHandler(int signal, SignalHandler handler);
+
+    bool IsExiting() const { return mExiting; }
+  private:
+    bool mExiting;
+    //pipe for wake up messages.
+    //when child thread wants to wake up main thread it writes one byte to mWakeupPipe[1].
+    //Main thread goes out of select() [or epoll_wait()] and start processing events.
+    int mWakeupPipe[2];
+    int mExitCode;
+
+    // General unix signal handling code
+    sigset_t mSignalCatched;
+    WX_DECLARE_HASH_MAP(int, SignalHandler, wxIntegerHash, wxIntegerEqual, SignalHandlerHash );
+    SignalHandlerHash mSignalHandlerHash;
+
+    static void HandleSignal(int signal);
+    void CheckSignal();
+};
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/unix/apptrait.h wxWidgets-2.8.0-p22/include/wx/unix/apptrait.h
--- wxWidgets-2.8.0/include/wx/unix/apptrait.h	2006-12-14 15:58:43.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/unix/apptrait.h	2006-12-04 19:06:44.000000000 +0100
@@ -23,6 +23,9 @@
     virtual bool IsWriteFDOfEndProcessPipe(wxExecuteData& execData, int fd);
     virtual void DetachWriteFDOfEndProcessPipe(wxExecuteData& execData);
     virtual int WaitForChild(wxExecuteData& execData);
+#if wxUSE_TIMER
+    virtual wxTimerImpl *CreateTimerImpl(wxTimer *timer);
+#endif
 };
 
 #if wxUSE_GUI
@@ -34,6 +37,9 @@
     virtual bool IsWriteFDOfEndProcessPipe(wxExecuteData& execData, int fd);
     virtual void DetachWriteFDOfEndProcessPipe(wxExecuteData& execData);
     virtual int WaitForChild(wxExecuteData& execData);
+#if wxUSE_TIMER
+    virtual wxTimerImpl *CreateTimerImpl(wxTimer *timer);
+#endif
 
 #if defined(__WXMAC__) || defined(__WXCOCOA__)
     virtual wxStandardPathsBase& GetStandardPaths();
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/unix/gsockunx.h wxWidgets-2.8.0-p22/include/wx/unix/gsockunx.h
--- wxWidgets-2.8.0/include/wx/unix/gsockunx.h	2006-11-07 12:00:25.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/unix/gsockunx.h	2006-11-08 13:56:34.000000000 +0100
@@ -66,9 +66,15 @@
     GSocketError GetSockOpt(int level, int optname, void *optval, int *optlen);
     GSocketError SetSockOpt(int level, int optname,
         const void *optval, int optlen);
+    /**
+      Adds or removes socket from list of sockets that are watched for data by application
+      This function has no effect when used in child thread
+    */
+    void Notify(bool pFlag);
     virtual void Detected_Read();
     virtual void Detected_Write();
 protected:
+    void EnableEvents(bool pFlag);
     void Enable(GSocketEvent event);
     void Disable(GSocketEvent event);
     GSocketError Input_Timeout();
@@ -98,6 +104,7 @@
   GSocketCallback m_cbacks[GSOCK_MAX_EVENT];
   char *m_data[GSOCK_MAX_EVENT];
 
+  bool m_use_events;
   char *m_gui_dependent;
 
 };
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/unix/private/timer.h wxWidgets-2.8.0-p22/include/wx/unix/private/timer.h
--- wxWidgets-2.8.0/include/wx/unix/private/timer.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/unix/private/timer.h	2006-11-08 14:34:27.000000000 +0100
@@ -0,0 +1,69 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/unix/timer.h
+// Purpose:     wxTimer for wxBase (unix)
+// Author:      Lukasz Michalski
+// Created:     15/01/2005
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) Lukasz Michalski
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_TIMER_H_UNIX_
+#define _WX_TIMER_H_UNIX_
+
+#include "wx/list.h"
+#include "wx/hashmap.h"
+#include "wx/event.h"
+#include "wx/longlong.h"
+#include "wx/private/timerimpl.h"
+
+class wxTimerEvent;
+
+/**@brief Defines interface for cooperation with global timer
+  *@author Lukasz Michalski
+  */
+class wxUnixTimerImpl : public wxTimerImpl {
+  public:
+    wxUnixTimerImpl(wxTimer *p_timer);
+    virtual ~wxUnixTimerImpl();
+
+    bool IsRunning() const;
+    bool Start(int pMilliseconds = -1, bool pOneShot = false);
+    void Stop();
+
+  protected:
+    bool mRunning;
+    friend class TimerScheduler;
+};
+
+struct wxTimerSchedule
+{
+    wxLongLong mExpire;
+    wxUnixTimerImpl *mTimer;
+};
+WX_DECLARE_LIST(wxTimerSchedule,TimerList);
+
+class TimerScheduler {
+  public:
+    TimerScheduler();
+    ~TimerScheduler() throw();
+
+    /**
+      Adds request for notify to timer.
+      @param pRequester - pointer of requestor
+      @param pWhen - date when requestor wants to be notified
+    */
+    void addTimer(wxUnixTimerImpl* pRequester, wxLongLong pExpire);
+    /**
+      Remove requestor from timer queue. Called automatically in requestor destructor.
+    */
+    void removeTimer(wxUnixTimerImpl* pRequester);
+    void notifyCurrent();
+    bool getTimeToNextExpire(struct timeval *tv);
+  private:
+    TimerList mData;
+};
+
+extern TimerScheduler *gs_scheduler;
+
+#endif
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/unix/socketstable.h wxWidgets-2.8.0-p22/include/wx/unix/socketstable.h
--- wxWidgets-2.8.0/include/wx/unix/socketstable.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/unix/socketstable.h	2006-11-08 13:56:34.000000000 +0100
@@ -0,0 +1,44 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/unix/socketstable.h
+// Purpose:     Sockets table for MainLoop implemented using select() call
+// Author:      Lukasz Michalski
+// Modified by:
+// Created:     28/01/2005
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) Lukasz Michalski
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#include "wx/unix/gsockunx.h"
+#include "wx/hashmap.h"
+#include "wx/thread.h"
+
+#ifndef HAVE_SYS_EPOLL_H
+
+WX_DECLARE_HASH_MAP(int,GSocket*,wxIntegerHash,wxIntegerEqual,SocketsTableType);
+
+class wxSocketsTable {
+  public:
+    wxSocketsTable();
+    void addGSocket(GSocket* pSocket);
+    void setWakeupPipeReadFd(int pFd);
+    void removeGSocket(GSocket* pSocket);
+    void enableGSockEvents(GSocket *pSocket, GSocketEvent event);
+    void disableGSockEvents(GSocket *pSocket, GSocketEvent event);
+    GSocket* findSocket(int pFd);
+    int getHigestFd() const{ return mHigestFd; };
+    fd_set getReadFdSet() const { return ar_fds; };
+    fd_set getWriteFdSet() const { return aw_fds; };
+    fd_set getExeptFdSet() const { return ae_fds; };
+  private:
+    SocketsTableType mSockets;
+    fd_set ar_fds;
+    fd_set aw_fds;
+    fd_set ae_fds;
+#ifdef wxUSE_THREADS
+    wxCriticalSection mSocketMapLocker;
+#endif
+    int mHigestFd;
+};
+
+#endif
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/utils.h wxWidgets-2.8.0-p22/include/wx/utils.h
--- wxWidgets-2.8.0/include/wx/utils.h	2006-11-29 12:33:45.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/utils.h	2006-11-29 12:31:55.000000000 +0100
@@ -272,21 +272,20 @@
 // Returns the current state of the mouse position, buttons and modifers
 WXDLLEXPORT wxMouseState wxGetMouseState();
 
+#endif // wxUSE_GUI
 
 // ----------------------------------------------------------------------------
 // Window ID management
 // ----------------------------------------------------------------------------
 
-// Generate a unique ID
-WXDLLEXPORT long wxNewId();
-
 // Ensure subsequent IDs don't clash with this one
 WXDLLEXPORT void wxRegisterId(long id);
 
 // Return the current ID
 WXDLLEXPORT long wxGetCurrentId();
 
-#endif // wxUSE_GUI
+// Generate a unique ID
+WXDLLEXPORT long wxNewId();
 
 // ----------------------------------------------------------------------------
 // Various conversions
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/wx.h wxWidgets-2.8.0-p22/include/wx/wx.h
--- wxWidgets-2.8.0/include/wx/wx.h	2006-11-07 12:01:40.000000000 +0100
+++ wxWidgets-2.8.0-p22/include/wx/wx.h	2006-11-08 13:56:34.000000000 +0100
@@ -31,6 +31,11 @@
 #include "wx/stopwatch.h"
 #include "wx/module.h"
 
+#if defined (__WXMSW__) || defined(__UNIX__) || wxUSE_GUI
+  #include "wx/timer.h"
+#endif //defined (__WXMSW__) || defined(__UNIX__)
+
+
 #if wxUSE_GUI
 
 #include "wx/window.h"
@@ -100,6 +105,8 @@
     #include "wx/valtext.h"
 #endif // wxUSE_VALIDATORS
 
+#else
+
 #endif // wxUSE_GUI
 
 #endif // _WX_WX_H_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/samples/samples.bkl wxWidgets-2.8.0-p22/samples/samples.bkl
--- wxWidgets-2.8.0/samples/samples.bkl	2006-11-29 12:35:48.000000000 +0100
+++ wxWidgets-2.8.0-p22/samples/samples.bkl	2006-11-29 12:33:08.000000000 +0100
@@ -76,6 +76,7 @@
     <subproject id="scrollsub" template="sub"/>
     <subproject id="shaped" template="sub"/>
     <subproject id="sockets" template="sub"/>
+    <subproject id="sockbase" template="sub"/>
     <subproject id="sound" template="sub"/>
     <subproject id="splash" template="sub"/>
     <subproject id="splitter" template="sub"/>
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/samples/sockbase/client.cpp wxWidgets-2.8.0-p22/samples/sockbase/client.cpp
--- wxWidgets-2.8.0/samples/sockbase/client.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/samples/sockbase/client.cpp	2006-11-10 17:27:57.000000000 +0100
@@ -0,0 +1,493 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        samples/sockbase/client.cpp
+// Purpose:     Sockets sample for wxBase
+// Author:      Lukasz Michalski
+// Modified by:
+// Created:     27.06.2005
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) 2005 Lukasz Michalski <lmichalski@sf.net>
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+
+// ============================================================================
+// declarations
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// headers
+// ----------------------------------------------------------------------------
+
+#include <wx/wx.h>
+#include <wx/socket.h>
+#include <wx/event.h>
+#include <wx/list.h>
+#include <wx/cmdline.h>
+#include <wx/ffile.h>
+#include <wx/datetime.h>
+
+const wxEventType WXDLLEXPORT wxEVT_WORKER = wxNewEventType();
+#define EVT_WORKER(func) DECLARE_EVENT_TABLE_ENTRY( wxEVT_WORKER, -1, -1, (wxObjectEventFunction) (wxEventFunction) (WorkerEventFunction) & func, (wxObject *) NULL ),
+
+class WorkerEvent : public wxEvent 
+{
+  public:
+    WorkerEvent(void* pSender) 
+    {
+      SetId(-1);
+      SetEventType(wxEVT_WORKER);
+      m_sender = pSender;
+    };
+    virtual wxEvent* Clone() const 
+    {
+      return new WorkerEvent(*this);
+    };
+  void* m_sender;
+};
+
+typedef void (wxEvtHandler::*WorkerEventFunction)(WorkerEvent&);
+
+class ThreadWorker;
+class EventWorker;
+
+WX_DECLARE_LIST(ThreadWorker, TList);
+WX_DECLARE_LIST(EventWorker, EList);
+
+class Client : public wxApp 
+{
+    DECLARE_EVENT_TABLE();
+  public:
+    void RemoveEventWorker(EventWorker* p_worker);
+  private:
+    typedef enum {
+      THREADS,
+      EVENTS
+    } workMode;
+
+    typedef enum {
+      SEND_RANDOM,
+      SEND_MESSAGE,
+      STRESS_TEST
+    } sendType;
+
+    workMode m_workMode;
+    sendType m_sendType;
+    wxString m_message;
+    wxString m_host;
+    long m_stressWorkers;
+
+    virtual bool OnInit();
+    virtual int OnRun();
+    virtual int OnExit();
+    void OnInitCmdLine(wxCmdLineParser& pParser);
+    bool OnCmdLineParsed(wxCmdLineParser& pParser);
+    void OnWorkerEvent(WorkerEvent& pEvent);
+
+    void StartWorker(workMode pMode, const wxString& pMessage);
+    void StartWorker(workMode pMode);
+
+    TList m_threadWorkers;
+    EList m_eventWorkers;
+};
+
+DECLARE_APP(Client);
+
+class ThreadWorker : public wxThread 
+{
+  public:
+    ThreadWorker(const wxString& p_host, char* p_buf, int p_size);
+    virtual ExitCode Entry();
+  private:
+    wxString m_host;
+    wxSocketClient* m_clientSocket;
+    char* m_inbuf;
+    char* m_outbuf;
+    int m_outsize;
+    int m_insize;
+};
+
+class EventWorker : public wxEvtHandler 
+{
+    DECLARE_EVENT_TABLE();
+  public:
+    EventWorker(const wxString& p_host, char* p_buf, int p_size);
+    void Run();
+    virtual ~EventWorker();
+  private:
+    wxString m_host;
+    wxSocketClient* m_clientSocket;
+    char* m_inbuf;
+    char* m_outbuf;
+    int m_outsize;
+    int m_written;
+    int m_insize;
+    int m_readed;
+
+    void OnSocketEvent(wxSocketEvent& pEvent);    
+};
+
+/******************* Implementation ******************/
+IMPLEMENT_APP(Client);
+
+#include <wx/listimpl.cpp>
+WX_DEFINE_LIST(TList);
+WX_DEFINE_LIST(EList);
+
+void 
+Client::OnInitCmdLine(wxCmdLineParser& pParser) 
+{
+  wxApp::OnInitCmdLine(pParser);
+  pParser.AddSwitch(wxT("e"),wxT("event"),_("Use event based worker (default)"),wxCMD_LINE_PARAM_OPTIONAL);
+  pParser.AddSwitch(wxT("t"),wxT("thread"),_("Use thread based worker"),wxCMD_LINE_PARAM_OPTIONAL);
+  pParser.AddSwitch(wxT("r"),wxT("random"),_("Send radnom data (default)"),wxCMD_LINE_PARAM_OPTIONAL);
+  pParser.AddOption(wxT("m"),wxT("message"),_("Send message from <str>"),wxCMD_LINE_VAL_STRING,wxCMD_LINE_PARAM_OPTIONAL);
+  pParser.AddOption(wxT("f"),wxT("file"),_("Send contents of <file>"),wxCMD_LINE_VAL_STRING,wxCMD_LINE_PARAM_OPTIONAL);
+  pParser.AddOption(wxT("H"),wxT("hostname"),_("IP or name of host to connect to"),wxCMD_LINE_VAL_STRING,wxCMD_LINE_PARAM_OPTIONAL);
+  pParser.AddOption(wxT("s"),wxT("stress"),_("stress test with <num> concurrent connections"),wxCMD_LINE_VAL_NUMBER,wxCMD_LINE_PARAM_OPTIONAL);
+};
+
+
+bool 
+Client::OnCmdLineParsed(wxCmdLineParser& pParser) 
+{
+  wxString fname;
+  m_workMode = EVENTS;
+  m_stressWorkers = 50;
+  if (pParser.Found(wxT("t")))
+    m_workMode = THREADS;
+  m_sendType = SEND_RANDOM;
+  if (pParser.Found(wxT("m"),&m_message))
+    m_sendType = SEND_MESSAGE;
+  else if (pParser.Found(wxT("f"),&fname)) {
+    wxFFile file(fname);
+    if (!file.IsOpened()) {
+      wxLogError(wxT("Cannot open file %s"),fname.c_str());
+      return false;
+    };
+    if (!file.ReadAll(&m_message)) {
+      wxLogError(wxT("Cannot read conten of file %s"),fname.c_str());
+      return false;
+    }; 
+    m_sendType = SEND_MESSAGE;
+  } else if (pParser.Found(wxT("s"),&m_stressWorkers))
+    m_sendType = STRESS_TEST;
+  m_host = wxT("127.0.0.1");
+  pParser.Found(wxT("m"),&m_host);
+  return wxApp::OnCmdLineParsed(pParser);
+};
+
+bool
+Client::OnInit() 
+{
+  if (!wxApp::OnInit())
+    return false;
+  srand(wxDateTime::Now().GetTicks());
+  return true;
+};
+
+int
+Client::OnRun() 
+{
+  switch(m_sendType)
+  {
+    case STRESS_TEST:
+      switch(m_workMode)
+      {
+        case THREADS: 
+          for (int i = 0; i < m_stressWorkers; i++) {
+            StartWorker(THREADS);
+          };
+        break;
+        case EVENTS:
+          for (int i = 0; i < m_stressWorkers; i++) {
+            StartWorker(EVENTS);
+          };
+        break;
+        default:
+          for (int i = 0; i < m_stressWorkers; i++) {
+            StartWorker(i % 5 == 0 ? THREADS : EVENTS);
+          };
+        break;
+      };
+    break;
+    case SEND_MESSAGE:
+      StartWorker(m_workMode,m_message);
+    break;
+    case SEND_RANDOM:
+      StartWorker(m_workMode);
+    break;
+  };
+  return wxApp::OnRun();
+};
+
+int 
+Client::OnExit() 
+{
+  for(EList::Node* it = m_eventWorkers.GetFirst(); it ; it->GetNext()) {
+    delete it->GetData();
+  };
+  return 0;
+};
+
+void
+Client::StartWorker(workMode pMode) {
+  int bufsize = 1 + (int) (250000.0 * (rand() / (RAND_MAX + 1.0)));
+  int size = bufsize;
+  char* buf;
+  if (size > 250) {
+    size = size/1024 + 1;
+    bufsize = size*1024+2;
+    buf = new char[bufsize];
+    buf[1] = 1;
+    buf[0] = (char)size;
+  } else {
+    bufsize = size+2;
+    buf = new char[bufsize];
+    buf[1] = 0;
+    buf[0] = (char)size;
+  };
+  for (int i = 0; i < (bufsize-2); i++) {
+    buf[i+2] = i % 256;
+  };  
+
+  if (pMode == THREADS) {
+    ThreadWorker* c = new ThreadWorker(m_host,buf,bufsize);
+    if (c->Create() != wxTHREAD_NO_ERROR) {
+      wxLogError(wxT("Cannot create more threads"));
+    } else {
+      c->Run();
+      m_threadWorkers.Append(c);
+    };      
+  } else {
+    EventWorker* e = new EventWorker(m_host,buf,bufsize);
+    e->Run();
+    m_eventWorkers.Append(e);
+  };  
+};
+
+void
+Client::StartWorker(workMode pMode, const wxString& pMessage) {
+  char* tmpbuf = strdup(pMessage.mb_str());
+  int size = strlen(tmpbuf);
+  char* buf;
+  if (size > 250) {
+    size = size/1024 + 1;
+    buf = new char[size];
+    buf[1] = 1;
+    buf[0] = (char)size;
+  } else {
+    buf = new char[size];
+    buf[1] = 0;
+    buf[0] = (char)size;
+  };
+  memset(buf+2,0x0,size-2);
+  memcpy(buf+2,tmpbuf,strlen(buf));
+  free(tmpbuf);
+
+  if (pMode == THREADS) {
+    ThreadWorker* c = new ThreadWorker(m_host,buf,size);
+    if (c->Create() != wxTHREAD_NO_ERROR) {
+      wxLogError(wxT("Cannot create more threads"));
+    } else {
+      c->Run();
+      m_threadWorkers.Append(c);
+    };      
+  } else {
+    EventWorker* e = new EventWorker(m_host,buf,size);
+    e->Run();
+    m_eventWorkers.Append(e);
+  };  
+};
+
+void 
+Client::OnWorkerEvent(WorkerEvent& pEvent) {
+  wxLogMessage(wxT("Got worker event"));
+  for(TList::Node* it = m_threadWorkers.GetFirst(); it ; it = it->GetNext()) {
+    if (it->GetData() == pEvent.m_sender) {
+      m_threadWorkers.DeleteNode(it);
+      break;
+    };
+  };
+  for(EList::Node* it = m_eventWorkers.GetFirst(); it ; it = it->GetNext()) {
+    if (it->GetData() == pEvent.m_sender) {
+      delete it->GetData();
+      m_eventWorkers.DeleteNode(it);
+      break;
+    };
+  };
+  if ((m_threadWorkers.GetCount() == 0) && (m_eventWorkers.GetCount() == 0))
+    ExitMainLoop();
+};
+
+void 
+Client::RemoveEventWorker(EventWorker* p_worker) {
+  for(EList::Node* it = m_eventWorkers.GetFirst(); it ; it = it->GetNext()) {
+    if (it->GetData() == p_worker) {
+      wxLogDebug(wxT("Deleting event worker"));
+      delete it->GetData();
+      m_eventWorkers.DeleteNode(it);
+      return;
+    };
+  };
+};
+
+BEGIN_EVENT_TABLE(Client,wxEvtHandler)
+  EVT_WORKER(Client::OnWorkerEvent)
+END_EVENT_TABLE()
+
+
+
+EventWorker::EventWorker(const wxString& p_host, char* p_buf, int p_size) 
+  : m_host(p_host),
+    m_outbuf(p_buf),
+    m_outsize(p_size),
+    m_written(0),
+    m_readed(0) 
+{
+  m_clientSocket = new wxSocketClient(wxSOCKET_NOWAIT);
+  m_clientSocket->SetEventHandler(*this);
+  m_insize = m_outsize - 2;
+  m_inbuf = new char[m_insize];
+};
+
+void 
+EventWorker::Run() {
+  wxIPV4address ca;
+  ca.Hostname(m_host);
+  ca.Service(5678);
+  m_clientSocket->SetNotify(wxSOCKET_CONNECTION_FLAG|wxSOCKET_LOST_FLAG|wxSOCKET_OUTPUT_FLAG|wxSOCKET_INPUT_FLAG);
+  m_clientSocket->Notify(true);
+  wxLogMessage(wxT("EventWorker: Connecting....."));
+  m_clientSocket->Connect(ca,false);
+};
+
+void 
+EventWorker::OnSocketEvent(wxSocketEvent& pEvent) {
+  switch(pEvent.GetSocketEvent()) {
+    case wxSOCKET_INPUT:
+      wxLogDebug(wxT("EventWorker: INPUT"));
+      do {
+        if (m_readed == m_insize)
+          return; //event already posted
+        m_clientSocket->Read(m_inbuf + m_readed, m_insize - m_readed);
+        if (m_clientSocket->Error()) {
+          if (m_clientSocket->LastError() != wxSOCKET_WOULDBLOCK) {
+            wxLogError(wxT("Read error"));
+            m_clientSocket->Close();
+            return;
+          };
+        };
+        m_readed += m_clientSocket->LastCount();
+        wxLogDebug(wxT("EventWorker: readed %d bytes, %d bytes to do"),m_clientSocket->LastCount(), m_insize - m_readed);
+        if (m_readed == m_insize) {
+          if (!memcmp(m_inbuf,m_outbuf,m_insize)) {
+            wxLogError(wxT("Data mismatch"));
+          };
+          m_clientSocket->Close();
+          WorkerEvent e(this);
+          wxGetApp().AddPendingEvent(e);
+        };
+      } while (!m_clientSocket->Error());
+    break;
+    case wxSOCKET_OUTPUT:
+      wxLogDebug(wxT("EventWorker: OUTPUT"));
+      do {
+        if (m_written == m_outsize)
+          return;
+        m_clientSocket->Write(m_outbuf + m_written, m_outsize - m_written);
+        if (m_clientSocket->Error()) {
+          if (m_clientSocket->LastError() != wxSOCKET_WOULDBLOCK) {
+            wxLogError(wxT("Write error"));
+            m_clientSocket->Close();
+            return;
+          };
+        };
+        m_written += m_clientSocket->LastCount();
+        wxLogDebug(wxT("EventWorker: written %d bytes, %d bytes to do"),m_clientSocket->LastCount(),m_outsize - m_written);
+      } while(!m_clientSocket->Error());
+    break;
+    case wxSOCKET_CONNECTION:
+      wxLogMessage(wxT("EventWorker: got connection"));
+      wxLogMessage(wxT("Starting writing message (2 bytes for signature and %d bytes of data to write)"),m_outsize-2);
+    break;
+    case wxSOCKET_LOST:
+    {
+      wxLogDebug(wxT("EventWorker: Connection lost"));
+      WorkerEvent e(this);
+      wxGetApp().AddPendingEvent(e);
+    }
+    break;
+  };
+};
+
+EventWorker::~EventWorker() {
+  m_clientSocket->Destroy();
+  delete [] m_outbuf;
+  delete [] m_inbuf;
+};
+
+BEGIN_EVENT_TABLE(EventWorker,wxEvtHandler)
+  EVT_SOCKET(wxID_ANY,EventWorker::OnSocketEvent)
+END_EVENT_TABLE()
+
+
+ThreadWorker::ThreadWorker(const wxString& p_host, char* p_buf, int p_size) 
+  : wxThread(wxTHREAD_DETACHED),
+    m_host(p_host),
+    m_outbuf(p_buf),
+    m_outsize(p_size)
+{
+  m_clientSocket = new wxSocketClient(wxSOCKET_BLOCK|wxSOCKET_WAITALL);
+  m_insize = m_outsize - 2;
+  m_inbuf = new char[m_insize];
+};
+
+wxThread::ExitCode 
+ThreadWorker::Entry() {
+  wxIPV4address ca;
+  ca.Hostname(m_host);
+  ca.Service(5678);
+  wxLogDebug(wxT("ThreadWorker: Connecting....."));
+  m_clientSocket->SetTimeout(60);
+  if (!m_clientSocket->Connect(ca)) {
+    wxLogError(wxT("Cannot connect to %s:%d"),ca.IPAddress().c_str(), ca.Service());
+  } else {
+    wxLogMessage(wxT("ThreadWorker: Connected. Sending %d bytes of data"),m_outsize);
+    int to_process = m_outsize;
+    do {
+      m_clientSocket->Write(m_outbuf,m_outsize);
+      if (m_clientSocket->Error()) {
+        wxLogError(wxT("ThreadWorker: Write error"));
+        WorkerEvent e(this);
+        wxGetApp().AddPendingEvent(e);
+        return 0;
+      };
+      to_process -= m_clientSocket->LastCount();
+      wxLogDebug(wxT("EventWorker: written %d bytes, %d bytes to do"),m_clientSocket->LastCount(),to_process);
+    } while(!m_clientSocket->Error() && to_process != 0);
+    to_process = m_insize;
+    do {
+      m_clientSocket->Read(m_inbuf,m_insize);
+      if (m_clientSocket->Error()) {
+        wxLogError(wxT("ThreadWorker: Read error"));
+        WorkerEvent e(this);
+        wxGetApp().AddPendingEvent(e);
+        return 0;
+      }
+      to_process -= m_clientSocket->LastCount();
+      wxLogDebug(wxT("EventWorker: readed %d bytes, %d bytes to do"),m_clientSocket->LastCount(),to_process);
+    } while(!m_clientSocket->Error() && to_process != 0);
+    if (!memcmp(m_inbuf,m_outbuf+2,m_insize)) {
+      wxLogError(wxT("Data mismatch"));
+    };
+  };
+  wxLogDebug(wxT("ThreadWorker: Finished"));
+  m_clientSocket->Close();
+  m_clientSocket->Destroy();
+  m_clientSocket = NULL;
+  delete [] m_outbuf;
+  delete [] m_inbuf;
+  WorkerEvent e(this);
+  wxGetApp().AddPendingEvent(e);
+  return 0;
+};
+
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/samples/sockbase/server.cpp wxWidgets-2.8.0-p22/samples/sockbase/server.cpp
--- wxWidgets-2.8.0/samples/sockbase/server.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/samples/sockbase/server.cpp	2006-11-10 17:29:31.000000000 +0100
@@ -0,0 +1,581 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        samples/sockbase/client.cpp
+// Purpose:     Sockets sample for wxBase
+// Author:      Lukasz Michalski
+// Modified by:
+// Created:     27.06.2005
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) 2005 Lukasz Michalski <lmichalski@user.sourceforge.net>
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+
+// ============================================================================
+// declarations
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// headers
+// ----------------------------------------------------------------------------
+
+#include <wx/wx.h>
+#include <wx/socket.h>
+#include <wx/event.h>
+#include <wx/list.h>
+#include <wx/cmdline.h>
+#include <wx/datetime.h>
+
+wxChar*
+GetSocketErrorMsg(int pSockError) {
+  switch(pSockError) {
+    case wxSOCKET_NOERROR:
+      return wxT("wxSOCKET_NOERROR");
+    break;
+    case wxSOCKET_INVOP:
+      return wxT("wxSOCKET_INVOP");
+    break;
+    case wxSOCKET_IOERR:
+      return wxT("wxSOCKET_IOERR");
+    break;
+    case wxSOCKET_INVADDR:
+      return wxT("wxSOCKET_INVADDR");
+    break;
+    case wxSOCKET_NOHOST:
+      return wxT("wxSOCKET_NOHOST");
+    break;
+    case wxSOCKET_INVPORT:
+      return wxT("wxSOCKET_INVPORT");
+    break;
+    case wxSOCKET_WOULDBLOCK:
+      return wxT("wxSOCKET_WOULDBLOCK");
+    break;
+    case wxSOCKET_TIMEDOUT:
+      return wxT("wxSOCKET_TIMEDOUT");
+    break;
+    case wxSOCKET_MEMERR:
+      return wxT("wxSOCKET_MEMERR");
+    break;
+    default:
+      return wxT("Unknown");
+    break;
+  };
+};
+
+typedef enum {
+  LOG_MESSAGE,
+  LOG_ERROR
+} logWorker_t;
+
+void
+LogWorker(const wxIPV4address& pAddr, const wxString& pMessage, logWorker_t pType = LOG_MESSAGE) {
+  wxString msg(wxString::Format(wxT("%s:%d "),pAddr.IPAddress().c_str(),pAddr.Service()));
+  msg += pMessage;
+  switch (pType) {
+    case LOG_MESSAGE:
+      wxLogMessage(msg);
+    break;
+    case LOG_ERROR:
+      wxLogError(msg);
+    break;
+  };
+};
+
+const wxEventType WXDLLEXPORT wxEVT_WORKER = wxNewEventType();
+#define EVT_WORKER(func) DECLARE_EVENT_TABLE_ENTRY( wxEVT_WORKER, -1, -1, (wxObjectEventFunction) (wxEventFunction) (WorkerEventFunction) & func, (wxObject *) NULL ),
+
+class WorkerEvent : public wxEvent {
+  public:
+    WorkerEvent(void* pSender) {
+      SetId(-1);
+      SetEventType(wxEVT_WORKER);
+      m_sender = pSender;
+      m_exit = false;
+    };
+    virtual wxEvent* Clone() const {
+      return new WorkerEvent(*this);
+    };
+  void* m_sender;
+  bool m_exit;
+  int m_dataReceived;
+  int m_dataSent;
+  int m_sockError;
+};
+
+typedef void (wxEvtHandler::*WorkerEventFunction)(WorkerEvent&);
+
+class ThreadWorker;
+class EventWorker;
+
+WX_DECLARE_LIST(ThreadWorker, TList);
+WX_DECLARE_LIST(EventWorker, EList);
+
+class Server : public wxApp {
+    DECLARE_EVENT_TABLE();
+  public:
+    void RemoveEventWorker(EventWorker* p_worker);
+    void dumpStatistics();
+  private:
+    typedef enum {
+      MIXED,
+      THREADS,
+      EVENTS
+    } workMode;
+
+    virtual bool OnInit();
+    virtual int OnExit();
+
+    void OnInitCmdLine(wxCmdLineParser& pParser);
+    bool OnCmdLineParsed(wxCmdLineParser& pParser);
+
+    void OnSocketEvent(wxSocketEvent& pEvent);
+    void OnWorkerEvent(WorkerEvent& pEvent);
+    void OnTimerEvent(wxTimerEvent& pEvent);
+
+    TList m_threadWorkers;
+    EList m_eventWorkers;
+    workMode m_workMode;
+    wxSocketServer* m_listeningSocket; 
+
+    //staticstics
+    unsigned m_threadWorkersCreated;
+    unsigned m_threadWorkersDone;
+    unsigned m_threadWorkersFailed;
+    unsigned m_maxThreadWorkers;
+
+    unsigned m_eventWorkersCreated;
+    unsigned m_eventWorkersDone;
+    unsigned m_eventWorkersFailed;
+    unsigned m_maxEventWorkers;
+
+    unsigned m_dataSent;
+    unsigned m_dataReceived;
+
+    wxTimer mTimer;
+};
+
+DECLARE_APP(Server);
+
+class ThreadWorker : public wxThread {
+  public:
+    ThreadWorker(wxSocketBase* pSocket);
+    virtual ExitCode Entry();
+  private:
+    wxSocketBase* m_socket;
+    wxIPV4address m_peer;
+};  
+
+class EventWorker : public wxEvtHandler {
+    DECLARE_EVENT_TABLE();
+  public:
+    EventWorker(wxSocketBase* pSock);
+    ~EventWorker();
+    void Run();
+  private:
+    wxSocketBase* m_socket;
+    wxIPV4address m_peer;
+
+    unsigned char m_signature[2];
+    char* m_inbuf;
+    int m_infill;
+    int m_size;
+    char* m_outbuf;
+    int m_outfill;
+    int m_written;
+
+    void OnSocketEvent(wxSocketEvent& pEvent);
+    void DoWrite();
+};
+
+/******************* Implementation ******************/
+IMPLEMENT_APP(Server)
+
+#include <wx/listimpl.cpp>
+WX_DEFINE_LIST(TList);
+WX_DEFINE_LIST(EList);
+
+
+void 
+Server::OnInitCmdLine(wxCmdLineParser& pParser) {
+  wxApp::OnInitCmdLine(pParser);
+  pParser.AddSwitch(wxT("t"),wxT("threads"),_("Use thread based workers only"));
+  pParser.AddSwitch(wxT("e"),wxT("events"),_("Use event based workers only"));
+};
+
+void 
+Server::dumpStatistics() {
+  wxString mode;
+  switch(m_workMode) {
+    case EVENTS:
+      mode = _("Event based workers");
+    break;
+    case THREADS:
+      mode = _("Thread based workers");
+    break;
+    case MIXED:
+      mode = _("Event and thread based workers");
+    break;
+  };
+  wxLogMessage(wxString::Format(wxT("Server mode: %s"),mode.c_str()));
+  wxLogMessage(wxString::Format(wxT("Data: sent %d received %d")),m_dataSent,m_dataReceived);
+  wxLogMessage(wxString::Format(wxT("\t\t\t\tThreads\tEvents\tTotal")));
+  wxLogMessage(wxString::Format(wxT("Workers created:\t\t%d\t%d\t%d"),m_threadWorkersCreated,m_eventWorkersCreated,m_threadWorkersCreated+m_eventWorkersCreated));
+  wxLogMessage(wxString::Format(wxT("Max concurrent workers:\t%d\t%d\t%d"),m_maxThreadWorkers,m_maxEventWorkers,m_maxThreadWorkers+m_maxEventWorkers));
+  wxLogMessage(wxString::Format(wxT("Workers failed:\t\t%d\t%d\t%d"),m_threadWorkersFailed,m_eventWorkersFailed,m_threadWorkersFailed+m_eventWorkersFailed));
+  wxLogMessage(wxString::Format(wxT("Workers done:\t\t\t%d\t%d\t%d"),m_threadWorkersDone,m_eventWorkersDone,m_threadWorkersDone+m_eventWorkersDone));
+};
+
+
+bool 
+Server::OnCmdLineParsed(wxCmdLineParser& pParser) {
+  if (pParser.Found(_("verbose"))) {
+    wxLog::AddTraceMask(wxT("baseapp"));
+    wxLog::AddTraceMask(wxT("wxSocket"));
+    wxLog::AddTraceMask(wxT("epoll"));
+    wxLog::AddTraceMask(wxT("thread"));
+  };
+  if (pParser.Found(wxT("t")))
+    m_workMode = THREADS;
+  else if (pParser.Found(wxT("e")))
+    m_workMode = EVENTS;
+  else
+    m_workMode = MIXED;
+  return wxApp::OnCmdLineParsed(pParser);
+};
+
+bool
+Server::OnInit() {
+  wxLog* logger = new wxLogStderr();
+  wxLog::SetActiveTarget(logger);
+  //send interesting things to console
+  if (!wxApp::OnInit())
+    return false;
+
+  //setup listening socket
+  wxIPV4address la;
+  la.Service(5678);
+  m_listeningSocket = new wxSocketServer(la,wxSOCKET_NOWAIT|wxSOCKET_REUSEADDR);
+  m_listeningSocket->SetEventHandler(*this);
+  m_listeningSocket->SetNotify(wxSOCKET_CONNECTION_FLAG);
+  m_listeningSocket->Notify(true);
+  if (!m_listeningSocket->Ok()) {
+    wxLogError(wxT("Cannot bind listening socket"));
+    return false;
+  };
+
+  m_threadWorkersCreated = 0;
+  m_threadWorkersDone = 0;
+  m_threadWorkersFailed = 0;
+  m_maxThreadWorkers = 0;
+
+  m_eventWorkersCreated = 0;
+  m_eventWorkersDone = 0;
+  m_eventWorkersFailed = 0;
+  m_maxEventWorkers = 0;
+
+  m_dataSent = 0;
+  m_dataReceived = 0;
+
+  wxLogMessage(wxT("Server listening at port 5678, waiting for connections"));
+  return true;
+};
+
+
+int
+Server::OnExit() {
+  for(TList::Node* it = m_threadWorkers.GetFirst(); it ; it = it->GetNext()) {
+    wxLogMessage(wxT("Deleting worker thread"));
+    it->GetData()->Wait();
+    delete it->GetData();
+  };
+  for(EList::Node* it = m_eventWorkers.GetFirst(); it ; it->GetNext()) {
+    delete it->GetData();
+  };
+  m_threadWorkers.Clear();
+  m_eventWorkers.Clear();
+  m_listeningSocket->Destroy();
+  return 0;
+};
+
+void 
+Server::OnSocketEvent(wxSocketEvent& pEvent) {
+  switch(pEvent.GetSocketEvent()) {
+    case wxSOCKET_INPUT:
+      wxLogError(wxT("Unexpected wxSOCKET_INPUT in wxSocketServer"));
+    break;
+    case wxSOCKET_OUTPUT:
+      wxLogError(wxT("Unexpected wxSOCKET_OUTPUT in wxSocketServer"));
+    break;
+    case wxSOCKET_CONNECTION:
+    {
+      wxSocketBase* sock = m_listeningSocket->Accept();
+      wxIPV4address addr;
+      if (!sock->GetPeer(addr)) {
+        wxLogError(wxT("Server: cannot get peer info"));
+      } else {
+        wxLogMessage(wxT("Got connection from %s:%d"),addr.IPAddress().c_str(), addr.Service());
+      };
+      bool createThread;
+      if (m_workMode != MIXED)
+        createThread = m_workMode == THREADS;
+      else
+        createThread = (wxDateTime::Now().GetSecond())%2 == 0;
+
+      if (createThread) {
+        ThreadWorker* c = new ThreadWorker(sock);
+        c->Create();
+        m_threadWorkers.Append(c);
+        if (m_threadWorkers.GetCount() > m_maxThreadWorkers)
+          m_maxThreadWorkers++;      
+        m_threadWorkersCreated++;
+        c->Run();
+      } else {
+        EventWorker* w = new EventWorker(sock);
+        m_eventWorkers.Append(w);
+        if (m_eventWorkers.GetCount() > m_maxEventWorkers)
+          m_maxEventWorkers++;      
+        m_eventWorkersCreated++;
+        w->Run();
+      };
+    }
+    break;
+    case wxSOCKET_LOST:
+      wxLogError(wxT("Unexpected wxSOCKET_LOST in wxSocketServer"));
+    break;
+  };
+};
+
+void 
+Server::OnWorkerEvent(WorkerEvent& pEvent) {
+  wxLogMessage(wxT("Got worker event"));
+  for(TList::Node* it = m_threadWorkers.GetFirst(); it ; it = it->GetNext()) {
+    if (it->GetData() == pEvent.m_sender) {
+      wxLogDebug(wxT("Deleting thread worker (%d left)"),m_threadWorkers.GetCount());
+      it->GetData()->Wait();
+      delete it->GetData();
+      m_threadWorkers.DeleteNode(it);
+      if (pEvent.m_sockError != wxSOCKET_NOERROR)
+        m_threadWorkersDone++;
+      else
+        m_threadWorkersFailed++;
+      break;
+    };
+  };
+  for(EList::Node* it = m_eventWorkers.GetFirst(); it ; it = it->GetNext()) {
+    if (it->GetData() == pEvent.m_sender) {
+      wxLogDebug(wxT("Deleting event worker (%d left)"),m_eventWorkers.GetCount());
+      delete it->GetData();
+      m_eventWorkers.DeleteNode(it);
+      if (pEvent.m_sockError != wxSOCKET_NOERROR)
+        m_eventWorkersDone++;
+      else
+        m_eventWorkersFailed++;
+      break;
+    };
+  };
+  if (m_eventWorkers.GetCount() == 0 && m_threadWorkers.GetCount() == 0) {
+    mTimer.Start(1000,true);
+  };
+};
+
+void
+Server::OnTimerEvent(wxTimerEvent& pEvent) {
+  dumpStatistics();
+};
+
+
+BEGIN_EVENT_TABLE(Server,wxEvtHandler)
+  EVT_SOCKET(wxID_ANY,Server::OnSocketEvent)
+  EVT_WORKER(Server::OnWorkerEvent)
+  EVT_TIMER(wxID_ANY,Server::OnTimerEvent)
+END_EVENT_TABLE()
+
+
+ThreadWorker::ThreadWorker(wxSocketBase* pSocket) 
+  : wxThread(wxTHREAD_JOINABLE)
+{
+  m_socket = pSocket;
+  pSocket->GetPeer(m_peer);
+};    
+
+wxThread::ExitCode 
+ThreadWorker::Entry() {
+  WorkerEvent e(this);
+  m_socket->Notify(false);
+  m_socket->SetFlags(wxSOCKET_WAITALL|wxSOCKET_BLOCK);
+  if (!m_socket->IsConnected()) {
+    LogWorker(m_peer,wxT("ThreadWorker: not connected"),LOG_ERROR);
+    return 0;
+  };
+  while(m_socket->IsConnected()) {
+    unsigned char signature[1];
+    LogWorker(m_peer,wxT("ThreadWorker: waiting for data"));
+    int to_process = 2;
+    do {
+      m_socket->Read(&signature,to_process);
+      if (m_socket->Error()) {
+        LogWorker(m_peer,wxT("ThreadWorker: Read error"),LOG_ERROR);
+        wxGetApp().AddPendingEvent(e);
+        return 0;
+      };
+      to_process -= m_socket->LastCount();
+      LogWorker(m_peer,wxString::Format(wxT("to_process: %d"),to_process));
+    } while (!m_socket->Error() && to_process != 0);
+
+    if (signature[0] == 0) {
+      e.m_exit = true;
+      return 0;
+    };
+    int size = signature[0] * (signature[1] == 0 ? 1 : 1024);
+    char* buf = new char[size];
+    LogWorker(m_peer,wxString::Format(wxT("Message signature: chunks: %d, kilobytes: %d, size: %d (bytes)"),signature[0],signature[1],size));
+
+    to_process = size;
+    wxLogMessage(wxT("ThreadWorker: reading %d bytes of data"),to_process);
+    do {
+      m_socket->Read(buf,to_process);
+      if (m_socket->Error()) {
+        wxLogError(wxT("ThreadWorker: Read error"));
+        wxGetApp().AddPendingEvent(e);
+        return 0;
+      };
+      to_process -= m_socket->LastCount();
+      wxLogDebug(wxT("ThreadWorker: %d bytes readed, %d todo"),m_socket->LastCount(),to_process);
+    } while(!m_socket->Error() && to_process != 0);
+
+    to_process = size;
+    wxLogDebug(wxT("ThreadWorker: writing data"));
+    do {
+      m_socket->Write(buf,to_process);
+      if (m_socket->Error()) {
+        wxLogError(wxT("ThreadWorker: Write error"));
+        wxGetApp().AddPendingEvent(e);
+        return 0;
+      };
+      to_process -= m_socket->LastCount();
+      wxLogDebug(wxT("ThreadWorker: %d bytes written, %d todo"),m_socket->LastCount(),to_process);
+    } while(!m_socket->Error() && to_process != 0);
+  };
+  wxLogDebug(wxT("ThreadWorker: done"));
+  m_socket->Destroy();
+  wxGetApp().AddPendingEvent(e);
+  return 0;
+};
+
+EventWorker::EventWorker(wxSocketBase* pSock) 
+  : m_socket(pSock),
+    m_inbuf(NULL),
+    m_infill(0),
+    m_outbuf(NULL),
+    m_outfill(0)
+{
+  m_socket->SetNotify(wxSOCKET_LOST_FLAG|wxSOCKET_INPUT_FLAG|wxSOCKET_OUTPUT_FLAG);
+  m_socket->Notify(true);
+  m_socket->SetEventHandler(*this);
+  m_socket->SetFlags(wxSOCKET_NOWAIT);
+  m_socket->GetPeer(m_peer);
+};
+
+EventWorker::~EventWorker() {
+  m_socket->Destroy();
+  delete [] m_inbuf;
+  delete [] m_outbuf;
+};
+
+void 
+EventWorker::Run() {
+  wxLogDebug(wxT("Event worker started"));
+};
+
+void 
+EventWorker::OnSocketEvent(wxSocketEvent& pEvent) {
+  switch(pEvent.GetSocketEvent()) {
+    case wxSOCKET_INPUT:
+      if (m_inbuf == NULL) {
+        do {
+          m_socket->Read(m_signature,2 - m_infill);
+          if (m_socket->Error()) {
+            if (m_socket->LastError() != wxSOCKET_WOULDBLOCK) {
+              LogWorker(m_peer,wxString::Format(wxT("Read error (%d): %s"),m_socket->LastError(),GetSocketErrorMsg(m_socket->LastError())));
+              m_socket->Close();
+            };
+          } else {
+            m_infill += m_socket->LastCount();
+            if (m_infill == 2) {
+              int chunks = m_signature[0];
+              int type = m_signature[1];
+              m_size = m_signature[0] * (m_signature[1] == 0 ? 1 : 1024);
+              m_inbuf = new char[m_size];
+              m_outbuf = new char[m_size];
+              m_infill = 0;
+              m_outfill = 0;
+              m_written = 0;
+              LogWorker(m_peer,wxString::Format(wxT("Message signature: chunks: %d, kilobytes: %d, size: %d (bytes)"),chunks,type,m_size));
+              break;
+            };
+          };
+        } while(!m_socket->Error() && (2 - m_infill != 0));
+      } 
+      if (m_inbuf != NULL) {
+        if (m_size - m_infill == 0)
+          return;
+        do {
+          m_socket->Read(m_inbuf + m_infill,m_size - m_infill);
+          if (m_socket->Error()) {
+            if (m_socket->LastError() != wxSOCKET_WOULDBLOCK) {
+              LogWorker(m_peer,wxString::Format(wxT("Read error (%d): %s"),m_socket->LastError(),GetSocketErrorMsg(m_socket->LastError())));
+              m_socket->Close();
+            };
+          } else {
+            memcpy(m_outbuf+m_outfill,m_inbuf+m_infill,m_socket->LastCount());
+            m_infill += m_socket->LastCount();
+            m_outfill += m_socket->LastCount();
+            DoWrite();
+          };
+        } while(!m_socket->Error() && (m_size - m_infill != 0));
+      };
+    break;
+    case wxSOCKET_OUTPUT:
+      if (m_inbuf != NULL)
+        DoWrite();
+    break;
+    case wxSOCKET_CONNECTION:
+      LogWorker(m_peer,wxString::Format(wxT("Unexpected wxSOCKET_CONNECTION in EventWorker")),LOG_ERROR);
+    break;
+    case wxSOCKET_LOST:
+    {
+      LogWorker(m_peer,wxString::Format(wxT("Connection lost")));
+      WorkerEvent e(this);
+      wxGetApp().AddPendingEvent(e);
+    }
+    break;
+  };
+};  
+
+void 
+EventWorker::DoWrite() {
+  if (m_written == m_size) {
+    LogWorker(m_peer,wxString::Format(wxT("All data written, waiting for disconnect")));
+    return;
+  };
+  do {
+    if (m_outfill - m_written == 0) {
+      return;
+    };
+    m_socket->Write(m_outbuf + m_written,m_outfill - m_written);
+    if (m_socket->Error()) {
+      if (m_socket->LastError() != wxSOCKET_WOULDBLOCK) {
+        LogWorker(m_peer,wxString::Format(wxT("Write error (%d): %s"),m_socket->LastError(),GetSocketErrorMsg(m_socket->LastError())));
+        m_socket->Close();
+      } else {
+        LogWorker(m_peer,wxString::Format(wxT("Write would block, waiting for OUTPUT event")));
+      };
+    } else {
+      memcpy(m_outbuf,m_outbuf+m_socket->LastCount(),m_outfill-m_socket->LastCount());
+      m_written += m_socket->LastCount();
+    };
+    LogWorker(m_peer,wxString::Format(wxT("Written %d of %d bytes, todo %d"),m_socket->LastCount(),m_size,m_size - m_written));
+  } while (!m_socket->Error());
+};
+
+BEGIN_EVENT_TABLE(EventWorker,wxEvtHandler)
+  EVT_SOCKET(wxID_ANY,EventWorker::OnSocketEvent)
+END_EVENT_TABLE()
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/samples/sockbase/sockbase.bkl wxWidgets-2.8.0-p22/samples/sockbase/sockbase.bkl
--- wxWidgets-2.8.0/samples/sockbase/sockbase.bkl	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/samples/sockbase/sockbase.bkl	2006-11-08 17:23:21.000000000 +0100
@@ -0,0 +1,15 @@
+<?xml version="1.0" ?>
+<makefile>
+
+    <include file="../../build/bakefiles/common_samples.bkl"/>
+    <exe id="server" template="wx_sample_console" template_append="wx_append_base">
+        <sources>server.cpp</sources>
+        <wx-lib>net</wx-lib>
+        <wx-lib>base</wx-lib>
+    </exe>
+    <exe id="client" template="wx_sample_console" template_append="wx_append_base">
+        <sources>client.cpp</sources>
+        <wx-lib>net</wx-lib>
+        <wx-lib>base</wx-lib>
+    </exe>
+</makefile>
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/setup.h.in wxWidgets-2.8.0-p22/setup.h.in
--- wxWidgets-2.8.0/setup.h.in	2006-12-14 15:57:56.000000000 +0100
+++ wxWidgets-2.8.0-p22/setup.h.in	2006-12-04 19:05:41.000000000 +0100
@@ -1070,6 +1070,9 @@
 /* Define if you have the <langinfo.h> header file.  */
 #undef HAVE_LANGINFO_H
 
+/* Define if you have the <sys/epoll.h> header file.  */
+#undef HAVE_SYS_EPOLL_H
+
 /* Define if you have the <w32api.h> header file (mingw,cygwin).  */
 #undef HAVE_W32API_H
 
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/cocoa/timer.mm wxWidgets-2.8.0-p22/src/cocoa/timer.mm
--- wxWidgets-2.8.0/src/cocoa/timer.mm	2006-11-07 11:56:16.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/cocoa/timer.mm	2006-11-07 13:22:25.000000000 +0100
@@ -22,7 +22,7 @@
 
 #if wxUSE_TIMER
 
-#include "wx/timer.h"
+#include "wx/cocoa/timer.h"
 
 #ifndef WX_PRECOMP
 #endif
@@ -83,17 +83,17 @@
 // wxTimer
 // ----------------------------------------------------------------------------
 
-wxTimer::~wxTimer()
+wxCocoaTimerImpl::~wxCocoaTimerImpl()
 {
     Stop();
 }
 
-void wxTimer::Init()
+void wxCocoaTimerImpl::Init()
 {
     m_cocoaNSTimer = NULL;
 }
 
-bool wxTimer::Start(int millisecs, bool oneShot)
+bool wxCocoaTimerImpl::Start(int millisecs, bool oneShot)
 {
     Stop();
 
@@ -111,7 +111,7 @@
     return IsRunning();
 }
 
-void wxTimer::Stop()
+void wxCocoaTimerImpl::Stop()
 {
     if (m_cocoaNSTimer)
     {
@@ -122,7 +122,7 @@
     }
 }
 
-bool wxTimer::IsRunning() const
+bool wxCocoaTimerImpl::IsRunning() const
 {
     return m_cocoaNSTimer != NULL && [m_cocoaNSTimer isValid];
 }
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/cocoa/utils.cpp wxWidgets-2.8.0-p22/src/cocoa/utils.cpp
--- wxWidgets-2.8.0/src/cocoa/utils.cpp	2006-11-07 11:56:16.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/cocoa/utils.cpp	2006-11-07 13:22:25.000000000 +0100
@@ -62,6 +62,10 @@
     return wxPORT_COCOA;
 }
 
+wxTimerImpl* wxGUIAppTraits::CreateTimerImpl(wxTimer* p_timer) {
+    return new wxCocoaTimerImpl(p_timer);
+}
+
 wxWindow* wxFindWindowAtPoint(const wxPoint& pt)
 {
     return wxGenericFindWindowAtPoint(pt);
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/common/event.cpp wxWidgets-2.8.0-p22/src/common/event.cpp
--- wxWidgets-2.8.0/src/common/event.cpp	2006-11-29 12:37:08.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/common/event.cpp	2006-11-29 12:34:56.000000000 +0100
@@ -147,6 +147,7 @@
 DEFINE_EVENT_TYPE(wxEVT_NULL)
 DEFINE_EVENT_TYPE(wxEVT_IDLE)
 DEFINE_EVENT_TYPE(wxEVT_SOCKET)
+DEFINE_EVENT_TYPE(wxEVT_TIMER)
 
 #endif // !WXWIN_COMPATIBILITY_EVENT_TYPES
 
@@ -173,9 +174,6 @@
 DEFINE_EVENT_TYPE(wxEVT_COMMAND_TOOL_ENTER)
 DEFINE_EVENT_TYPE(wxEVT_COMMAND_SPINCTRL_UPDATED)
 
-// Sockets and timers send events, too
-DEFINE_EVENT_TYPE(wxEVT_TIMER)
-
 // Mouse event types
 DEFINE_EVENT_TYPE(wxEVT_LEFT_DOWN)
 DEFINE_EVENT_TYPE(wxEVT_LEFT_UP)
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/common/socket.cpp wxWidgets-2.8.0-p22/src/common/socket.cpp
--- wxWidgets-2.8.0/src/common/socket.cpp	2006-11-07 11:57:15.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/common/socket.cpp	2006-11-08 13:56:08.000000000 +0100
@@ -178,7 +178,7 @@
   m_type         = wxSOCKET_UNINIT;
 
   // state
-  m_flags        = 0;
+  SetFlags(0);
   m_connected    =
   m_establishing =
   m_reading      =
@@ -217,7 +217,7 @@
 {
   Init();
 
-  m_flags = flags;
+  SetFlags(flags);
   m_type  = type;
 }
 
@@ -906,7 +906,11 @@
 
 void wxSocketBase::SetFlags(wxSocketFlags flags)
 {
+#ifdef wxUSE_GUI
     m_flags = flags;
+#else
+    m_flags = flags & wxSOCKET_BLOCK;
+#endif
 }
 
 
@@ -1011,6 +1015,8 @@
 void wxSocketBase::Notify(bool notify)
 {
     m_notify = notify;
+    if (m_socket)
+      m_socket->Notify(notify);
 }
 
 void wxSocketBase::SetNotify(wxSocketEventFlags flags)
@@ -1098,8 +1104,8 @@
         return;
     }
 
-        // Setup the socket as server
-
+    // Setup the socket as server
+    m_socket->Notify(m_notify);
     m_socket->SetLocal(addr_man.GetAddress());
 
     if (GetFlags() & wxSOCKET_REUSEADDR) {
@@ -1258,6 +1264,7 @@
   if (!m_socket)
     return false;
 
+  m_socket->Notify(m_notify);
   m_socket->SetTimeout(m_timeout * 1000);
   m_socket->SetCallback(GSOCK_INPUT_FLAG | GSOCK_OUTPUT_FLAG |
                                 GSOCK_LOST_FLAG | GSOCK_CONNECTION_FLAG,
@@ -1349,6 +1356,8 @@
         wxFAIL_MSG( _T("datagram socket not new'd") );
         return;
     }
+
+    m_socket->Notify(m_notify);
     // Setup the socket as non connection oriented
     m_socket->SetLocal(addr.GetAddress());
     if( m_socket->SetNonOriented() != GSOCK_NOERROR )
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/common/timercmn.cpp wxWidgets-2.8.0-p22/src/common/timercmn.cpp
--- wxWidgets-2.8.0/src/common/timercmn.cpp	2006-11-07 11:57:15.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/common/timercmn.cpp	2006-11-07 13:22:27.000000000 +0100
@@ -28,9 +28,13 @@
 #if wxUSE_TIMER
 
 #ifndef WX_PRECOMP
-    #include "wx/timer.h"
+    #include "wx/app.h"
 #endif
 
+#include "wx/timer.h"
+#include "wx/apptrait.h"
+#include "wx/private/timerimpl.h"
+
 // ----------------------------------------------------------------------------
 // wxWin macros
 // ----------------------------------------------------------------------------
@@ -41,48 +45,70 @@
 // wxTimerBase implementation
 // ============================================================================
 
-wxTimerBase::~wxTimerBase()
+wxTimer::~wxTimer()
 {
     // this destructor is required for Darwin
+    delete m_impl;
 }
 
-void wxTimerBase::Notify()
+void wxTimer::Init()
 {
-    // the base class version generates an event if it has owner - which it
-    // should because otherwise nobody can process timer events
-    wxCHECK_RET( m_owner, _T("wxTimer::Notify() should be overridden.") );
+    wxAppTraits *traits = wxAppConsole::GetInstance() ?
+                            wxAppConsole::GetInstance()->GetTraits() : NULL;
+    m_impl = traits ? traits->CreateTimerImpl(this) : NULL;
+    wxASSERT_MSG(m_impl != NULL, _("No timer implementation for this platform"));
+    m_impl->m_oneShot = false; 
+}
+
+// ============================================================================
+// rest of wxTimer implementation forwarded to wxTimerImpl
+// ============================================================================
 
-    wxTimerEvent event(m_idTimer, m_milli);
-    event.SetEventObject(this);
-    (void)m_owner->ProcessEvent(event);
+void wxTimer::SetOwner(wxEvtHandler *owner, int timerid)
+{ 
+    m_impl->m_owner = owner; 
+    m_impl->m_idTimer = timerid == wxID_ANY ? wxNewId() : timerid; 
 }
 
-bool wxTimerBase::Start(int milliseconds, bool oneShot)
-{
-    // under MSW timers only work when they're started from the main thread so
-    // let the caller know about it
-#if wxUSE_THREADS
-    wxASSERT_MSG( wxThread::IsMain(),
-                  _T("timer can only be started from the main thread") );
-#endif // wxUSE_THREADS
-
-    if ( IsRunning() )
-    {
-        // not stopping the already running timer might work for some
-        // platforms (no problems under MSW) but leads to mysterious crashes
-        // on the others (GTK), so to be on the safe side do it here
-        Stop();
-    }
-
-    if ( milliseconds != -1 )
-    {
-        m_milli = milliseconds;
-    }
+wxEvtHandler* wxTimer::GetOwner() const 
+{ 
+    return m_impl->m_owner; 
+}
 
-    m_oneShot = oneShot;
+bool wxTimer::Start(int milliseconds, bool oneShot) 
+{ 
+    return m_impl->Start(milliseconds,oneShot); 
+};
+
+void wxTimer::Stop() 
+{ 
+    m_impl->Stop(); 
+};
+
+void wxTimer::Notify() 
+{ 
+    m_impl->Notify(); 
+};
+
+bool wxTimer::IsRunning() const 
+{ 
+    return m_impl->IsRunning(); 
+};
+
+int wxTimer::GetId() const 
+{ 
+    return m_impl->m_idTimer; 
+}
 
-    return true;
+int wxTimer::GetInterval() const { 
+    return m_impl->m_milli; 
 }
 
+bool wxTimer::IsOneShot() const 
+{ 
+    return m_impl->m_oneShot; 
+}
+
+
 #endif // wxUSE_TIMER
 
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/common/timerimpl.cpp wxWidgets-2.8.0-p22/src/common/timerimpl.cpp
--- wxWidgets-2.8.0/src/common/timerimpl.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/common/timerimpl.cpp	2006-11-07 13:22:26.000000000 +0100
@@ -0,0 +1,80 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        common/timercmn.cpp
+// Purpose:     wxTimerBase implementation
+// Author:      Julian Smart, Guillermo Rodriguez, Vadim Zeitlin
+// Modified by: VZ: extracted all non-wxTimer stuff in stopwatch.cpp (20.06.03)
+// Created:     04/01/98
+// RCS-ID:      $Id: timercmn.cpp,v 1.75 2005/09/23 12:53:09 MR Exp $
+// Copyright:   (c) Julian Smart
+//              (c) 1999 Guillermo Rodriguez <guille@iies.es>
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+// ============================================================================
+// declarations
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// wxWin headers
+// ----------------------------------------------------------------------------
+
+// For compilers that support precompilation, includes "wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#if wxUSE_TIMER
+
+#include "wx/private/timerimpl.h"
+#include "wx/timer.h" //for class declaration
+
+wxTimerImpl::wxTimerImpl(wxTimer* p_owner) 
+    : m_idTimer(wxID_ANY), 
+      m_milli(0)
+{
+    m_owner = p_owner;
+};
+
+void wxTimerImpl::Notify()
+{
+    // the base class version generates an event if it has owner - which it
+    // should because otherwise nobody can process timer events
+    wxCHECK_RET( m_owner, _T("wxTimer::Notify() should be overridden.") );
+
+    wxTimerEvent event(m_idTimer, m_milli);
+    event.SetEventObject(m_owner);
+    (void)m_owner->ProcessEvent(event);
+}
+
+bool wxTimerImpl::Start(int milliseconds, bool oneShot)
+{
+    // under MSW timers only work when they're started from the main thread so
+    // let the caller know about it
+#if wxUSE_THREADS
+    wxASSERT_MSG( wxThread::IsMain(),
+                  _T("timer can only be started from the main thread") );
+#endif // wxUSE_THREADS
+
+    if ( IsRunning() )
+    {
+        // not stopping the already running timer might work for some
+        // platforms (no problems under MSW) but leads to mysterious crashes
+        // on the others (GTK), so to be on the safe side do it here
+        Stop();
+    }
+
+    if ( milliseconds != -1 )
+    {
+        m_milli = milliseconds;
+    }
+
+    m_oneShot = oneShot;
+
+    return true;
+}
+
+
+#endif // wxUSE_TIMER
+
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/common/utilscmn.cpp wxWidgets-2.8.0-p22/src/common/utilscmn.cpp
--- wxWidgets-2.8.0/src/common/utilscmn.cpp	2006-11-29 12:37:16.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/common/utilscmn.cpp	2006-11-29 12:35:08.000000000 +0100
@@ -936,14 +936,6 @@
     return wxTheApp && wxTheApp->Yield(true);
 }
 
-#endif // wxUSE_BASE
-
-// ============================================================================
-// GUI-only functions from now on
-// ============================================================================
-
-#if wxUSE_GUI
-
 // Id generation
 static long wxCurrentId = 100;
 
@@ -966,6 +958,13 @@
     wxCurrentId = id + 1;
 }
 
+#endif // wxUSE_BASE
+
+// ============================================================================
+// GUI-only functions from now on
+// ============================================================================
+#if wxUSE_GUI
+
 // ----------------------------------------------------------------------------
 // Menu accelerators related functions
 // ----------------------------------------------------------------------------
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/generic/timer.cpp wxWidgets-2.8.0-p22/src/generic/timer.cpp
--- wxWidgets-2.8.0/src/generic/timer.cpp	2006-11-07 11:55:49.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/generic/timer.cpp	2006-11-07 13:22:25.000000000 +0100
@@ -22,7 +22,8 @@
 
 #if wxUSE_TIMER
 
-#include "wx/timer.h"
+#include "wx/generic/private/timer.h"
+#include "wx/stopwatch.h" //for wxGetLocalTimeMillis
 
 #ifndef WX_PRECOMP
     #include "wx/log.h"
@@ -93,15 +94,15 @@
 class wxTimerDesc
 {
 public:
-    wxTimerDesc(wxTimer *t) :
+    wxTimerDesc(wxGenericTimerImpl *t) :
         timer(t), running(false), next(NULL), prev(NULL),
         shotTime(0), deleteFlag(NULL) {}
 
-    wxTimer         *timer;
-    bool             running;
-    wxTimerDesc     *next, *prev;
-    wxTimerTick_t    shotTime;
-    volatile bool   *deleteFlag; // see comment in ~wxTimer
+    wxGenericTimerImpl  *timer;
+    bool                running;
+    wxTimerDesc         *next, *prev;
+    wxTimerTick_t        shotTime;
+    volatile bool       *deleteFlag; // see comment in ~wxTimer
 };
 
 class wxTimerScheduler
@@ -123,7 +124,7 @@
         return; // already scheduled
 
     if ( when == 0 )
-        when = GetMillisecondsTime() + desc->timer->GetInterval();
+        when = GetMillisecondsTime() + desc->timer->m_milli;
     desc->shotTime = when;
     desc->running = true;
 
@@ -172,7 +173,7 @@
         {
             if ( desc->running && wxTickGreaterEqual(now, desc->shotTime) )
             {
-                oneShot = desc->timer->IsOneShot();
+                oneShot = desc->timer->m_oneShot;
                 RemoveTimer(desc);
 
                 timerDeleted = false;
@@ -189,7 +190,7 @@
 
                     desc->deleteFlag = NULL;
                     if ( !oneShot )
-                        QueueTimer(desc, now + desc->timer->GetInterval());
+                        QueueTimer(desc, now + desc->timer->m_milli);
                 }
                 else
                 {
@@ -207,18 +208,16 @@
 // wxTimer
 // ----------------------------------------------------------------------------
 
-IMPLEMENT_ABSTRACT_CLASS(wxTimer, wxEvtHandler)
-
 wxTimerScheduler *gs_scheduler = NULL;
 
-void wxTimer::Init()
+void wxGenericTimerImpl::Init()
 {
     if ( !gs_scheduler )
         gs_scheduler = new wxTimerScheduler;
     m_desc = new wxTimerDesc(this);
 }
 
-wxTimer::~wxTimer()
+wxGenericTimerImpl::~wxGenericTimerImpl()
 {
     wxLogTrace( wxT("timer"), wxT("destroying timer %p..."), this);
     if ( IsRunning() )
@@ -235,31 +234,31 @@
     wxLogTrace( wxT("timer"), wxT("    ...done destroying timer %p..."), this);
 }
 
-bool wxTimer::IsRunning() const
+bool wxGenericTimerImpl::IsRunning() const
 {
     return m_desc->running;
 }
 
-bool wxTimer::Start(int millisecs, bool oneShot)
+bool wxGenericTimerImpl::Start(int millisecs, bool oneShot)
 {
     wxLogTrace( wxT("timer"), wxT("started timer %p: %i ms, oneshot=%i"),
                this, millisecs, oneShot);
 
-    if ( !wxTimerBase::Start(millisecs, oneShot) )
-        return false;
+     if ( !wxTimerImpl::Start(millisecs, oneShot) )
+         return false;
 
     gs_scheduler->QueueTimer(m_desc);
     return true;
 }
 
-void wxTimer::Stop()
+void wxGenericTimerImpl::Stop()
 {
     if ( !m_desc->running ) return;
 
     gs_scheduler->RemoveTimer(m_desc);
 }
 
-/*static*/ void wxTimer::NotifyTimers()
+/*static*/ void wxGenericTimerImpl::NotifyTimers()
 {
     if ( gs_scheduler )
         gs_scheduler->NotifyTimers();
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/gtk/timer.cpp wxWidgets-2.8.0-p22/src/gtk/timer.cpp
--- wxWidgets-2.8.0/src/gtk/timer.cpp	2006-11-07 11:54:18.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/gtk/timer.cpp	2006-11-07 13:22:19.000000000 +0100
@@ -12,24 +12,22 @@
 
 #if wxUSE_TIMER
 
-#include "wx/timer.h"
+#include "wx/gtk/private/timer.h"
 
 #include "gtk/gtk.h"
 
 // ----------------------------------------------------------------------------
-// wxTimer
+// wxTimerImpl
 // ----------------------------------------------------------------------------
 
-IMPLEMENT_ABSTRACT_CLASS(wxTimer, wxEvtHandler)
-
 extern "C" {
 static gint timeout_callback( gpointer data )
 {
-    wxTimer *timer = (wxTimer*)data;
+    wxGTKTimerImpl *timer = (wxGTKTimerImpl*)data;
 
     // Don't change the order of anything in this callback!
 
-    if (timer->IsOneShot())
+    if (timer->m_oneShot)
     {
         // This sets m_tag to -1
         timer->Stop();
@@ -45,37 +43,36 @@
     // Release lock again.
     gdk_threads_leave();
 
-    if (timer->IsOneShot())
-        return FALSE;
+    if (timer->m_oneShot)
+        return false;
 
-    return TRUE;
+    return true;
 }
 }
 
-void wxTimer::Init()
+void wxGTKTimerImpl::Init()
 {
     m_tag = -1;
     m_milli = 1000;
 }
 
-wxTimer::~wxTimer()
+wxGTKTimerImpl::~wxGTKTimerImpl()
 {
-    wxTimer::Stop();
 }
 
-bool wxTimer::Start( int millisecs, bool oneShot )
+bool wxGTKTimerImpl::Start( int millisecs, bool oneShot )
 {
-    (void)wxTimerBase::Start(millisecs, oneShot);
+    (void)wxTimerImpl::Start(millisecs, oneShot);
 
     if (m_tag != -1)
         g_source_remove( m_tag );
 
     m_tag = g_timeout_add( m_milli, timeout_callback, this );
 
-    return TRUE;
+    return true;
 }
 
-void wxTimer::Stop()
+void wxGTKTimerImpl::Stop()
 {
     if (m_tag != -1)
     {
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/gtk/utilsgtk.cpp wxWidgets-2.8.0-p22/src/gtk/utilsgtk.cpp
--- wxWidgets-2.8.0/src/gtk/utilsgtk.cpp	2006-12-14 16:00:07.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/gtk/utilsgtk.cpp	2006-12-06 09:46:02.000000000 +0100
@@ -24,6 +24,8 @@
 
 #include "wx/unix/execute.h"
 
+#include "wx/gtk/private/timer.h"
+
 #ifdef __WXDEBUG__
     #include "wx/gtk/assertdlg_gtk.h"
     #if wxUSE_STACKWALKER
@@ -297,6 +299,12 @@
     return wxPORT_GTK;
 }
 
+wxTimerImpl*
+wxGUIAppTraits::CreateTimerImpl(wxTimer *timer) 
+{
+    return new wxGTKTimerImpl(timer); 
+}
+
 #if wxUSE_DETECT_SM
 static wxString GetSM()
 {
@@ -457,5 +465,3 @@
     return wxEmptyString;
 }
 
-
-
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/gtk1/timer.cpp wxWidgets-2.8.0-p22/src/gtk1/timer.cpp
--- wxWidgets-2.8.0/src/gtk1/timer.cpp	2006-11-07 11:57:46.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/gtk1/timer.cpp	2006-11-07 13:22:30.000000000 +0100
@@ -12,7 +12,7 @@
 
 #if wxUSE_TIMER
 
-#include "wx/timer.h"
+#include "wx/gtk1/private/timer.h"
 
 #include "gtk/gtk.h"
 
@@ -20,16 +20,14 @@
 // wxTimer
 // ----------------------------------------------------------------------------
 
-IMPLEMENT_ABSTRACT_CLASS(wxTimer, wxEvtHandler)
-
 extern "C" {
 static gint timeout_callback( gpointer data )
 {
-    wxTimer *timer = (wxTimer*)data;
+    wxGTK1TimerImpl *timer = (wxGTK1TimerImpl*)data;
 
     // Don't change the order of anything in this callback!
 
-    if (timer->IsOneShot())
+    if (timer->m_oneShot)
     {
         // This sets m_tag to -1
         timer->Stop();
@@ -45,37 +43,36 @@
     // Release lock again.
     gdk_threads_leave();
 
-    if (timer->IsOneShot())
-        return FALSE;
+    if (timer->m_oneShot)
+        return false;
 
-    return TRUE;
+    return true;
 }
 }
 
-void wxTimer::Init()
+void wxGTK1TimerImpl::Init()
 {
     m_tag = -1;
     m_milli = 1000;
 }
 
-wxTimer::~wxTimer()
+wxGTK1TimerImpl::~wxGTK1TimerImpl()
 {
-    wxTimer::Stop();
 }
 
-bool wxTimer::Start( int millisecs, bool oneShot )
+bool wxGTK1TimerImpl::Start( int millisecs, bool oneShot )
 {
-    (void)wxTimerBase::Start(millisecs, oneShot);
+    (void)wxTimerImpl::Start(millisecs, oneShot);
 
     if (m_tag != -1)
         gtk_timeout_remove( m_tag );
 
     m_tag = gtk_timeout_add( m_milli, timeout_callback, this );
 
-    return TRUE;
+    return true;
 }
 
-void wxTimer::Stop()
+void wxGTK1TimerImpl::Stop()
 {
     if (m_tag != -1)
     {
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/gtk1/utilsgtk.cpp wxWidgets-2.8.0-p22/src/gtk1/utilsgtk.cpp
--- wxWidgets-2.8.0/src/gtk1/utilsgtk.cpp	2006-11-29 12:37:57.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/gtk1/utilsgtk.cpp	2006-11-29 12:35:39.000000000 +0100
@@ -19,7 +19,7 @@
 #endif
 
 #include "wx/apptrait.h"
-
+#include "wx/gtk1/private/timer.h"
 #include "wx/process.h"
 
 #include "wx/unix/execute.h"
@@ -196,8 +196,15 @@
 
     return wxPORT_GTK;
 }
+<<<<<<< utilsgtk.cpp
+
+wxTimerImpl* wxGUIAppTraits::CreateTimerImpl(wxTimer *p_timer) {
+    return new wxGTK1TimerImpl(p_timer);
+}
+=======
 
 wxString wxGUIAppTraits::GetDesktopEnvironment() const
 {
     return wxEmptyString;
 }
+>>>>>>> 1.69
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/mac/carbon/timer.cpp wxWidgets-2.8.0-p22/src/mac/carbon/timer.cpp
--- wxWidgets-2.8.0/src/mac/carbon/timer.cpp	2006-11-29 12:38:10.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/mac/carbon/timer.cpp	2006-11-29 12:35:47.000000000 +0100
@@ -17,7 +17,7 @@
     #include "wx/dynarray.h"
 #endif
 
-#include "wx/timer.h"
+#include "wx/mac/private/timer.h"
 
 #ifdef __WXMAC__
     #include "wx/mac/private.h"
@@ -27,15 +27,13 @@
     #include <Timer.h>
 #endif
 
-IMPLEMENT_ABSTRACT_CLASS(wxTimer, wxEvtHandler)
-
 #define wxMAC_USE_CARBON_TIMER 1
 
 #if wxMAC_USE_CARBON_TIMER
 
 struct MacTimerInfo
 {
-    wxTimer* m_timer;
+    wxCarbonTimerImpl* m_timer;
     EventLoopTimerUPP m_proc;
     EventLoopTimerRef   m_timerRef;
 };
@@ -46,15 +44,15 @@
     if ( data == NULL )
         return;
 
-    wxTimer* timer = (wxTimer*)data;
+    wxCarbonTimerImpl* timer = (wxCarbonTimerImpl*)data;
 
-    if ( timer->IsOneShot() )
+    if ( timer->m_oneShot )
         timer->Stop();
 
     timer->Notify();
 }
 
-void wxTimer::Init()
+void wxCarbonTimerImpl::Init()
 {
     m_info = new MacTimerInfo();
     m_info->m_timer = this;
@@ -62,12 +60,12 @@
     m_info->m_timerRef = kInvalidID;
 }
 
-bool wxTimer::IsRunning() const
+bool wxCarbonTimerImpl::IsRunning() const
 {
     return ( m_info->m_timerRef != kInvalidID );
 }
 
-wxTimer::~wxTimer()
+wxCarbonTimerImpl::~wxCarbonTimerImpl()
 {
     Stop();
     if (m_info != NULL)
@@ -77,9 +75,9 @@
     }
 }
 
-bool wxTimer::Start( int milliseconds, bool mode )
+bool wxCarbonTimerImpl::Start( int milliseconds, bool mode )
 {
-    (void)wxTimerBase::Start(milliseconds, mode);
+    (void)wxTimerImpl::Start(milliseconds, mode);
 
     wxCHECK_MSG( m_milli > 0, false, wxT("invalid value for timer timeout") );
     wxCHECK_MSG( m_info->m_timerRef == NULL, false, wxT("attempting to restart a timer") );
@@ -99,7 +97,7 @@
     return true;
 }
 
-void wxTimer::Stop()
+void wxCarbonTimerImpl::Stop()
 {
     if (m_info->m_timerRef)
         RemoveEventLoopTimer( m_info->m_timerRef );
@@ -116,7 +114,7 @@
 {
     TMTask m_task;
     wxMacNotifierTableRef m_table;
-    wxTimer* m_timer;
+    wxCarbonTimerImpl* m_timer;
 };
 
 static void wxProcessTimer( unsigned long event, void *data );
@@ -138,8 +136,8 @@
     if ( data == NULL )
         return;
 
-    wxTimer* timer = (wxTimer*) data;
-    if ( timer->IsOneShot() )
+    wxCarbonTimerImpl* timer = (wxCarbonTimerImpl*) data;
+    if ( timer->m_oneShot )
         timer->Stop();
 
     gTimersInProcess.Add( timer );
@@ -155,7 +153,7 @@
     }
 }
 
-void wxTimer::Init()
+void wxCarbonTimerImpl::Init()
 {
     m_info = new MacTimerInfo();
     m_info->m_task.tmAddr = NULL;
@@ -166,14 +164,14 @@
     m_info->m_timer = this;
 }
 
-bool wxTimer::IsRunning() const
+bool wxCarbonTimerImpl::IsRunning() const
 {
     // as the qType may already indicate it is elapsed, but it
     // was not handled internally yet
     return ( m_info->m_task.tmAddr != NULL );
 }
 
-wxTimer::~wxTimer()
+wxCarbonTimerImpl::~wxCarbonTimerImpl()
 {
     Stop();
     if (m_info != NULL)
@@ -187,7 +185,7 @@
         gTimersInProcess.RemoveAt( index );
 }
 
-bool wxTimer::Start( int milliseconds, bool mode )
+bool wxCarbonTimerImpl::Start( int milliseconds, bool mode )
 {
     (void)wxTimerBase::Start( milliseconds, mode );
 
@@ -205,7 +203,7 @@
     return true;
 }
 
-void wxTimer::Stop()
+void wxCarbonTimerImpl::Stop()
 {
     if ( m_info->m_task.tmAddr )
     {
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/mac/carbon/utils.cpp wxWidgets-2.8.0-p22/src/mac/carbon/utils.cpp
--- wxWidgets-2.8.0/src/mac/carbon/utils.cpp	2006-12-14 16:00:25.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/mac/carbon/utils.cpp	2006-12-14 16:17:34.000000000 +0100
@@ -23,6 +23,7 @@
 #endif
 
 #include "wx/apptrait.h"
+#include "wx/mac/private/timer.h"
 
 #if wxUSE_GUI
     #include "wx/mac/uma.h"
@@ -378,6 +379,11 @@
     return wxPORT_MAC;
 }
 
+wxTimerImpl* wxGUIAppTraits::CreateTimerImpl(wxTimer* p_timer) 
+{
+    return new wxCarbonTimerImpl(p_timer);
+}
+
 // Reading and writing resources (eg WIN.INI, .Xdefaults)
 #if wxUSE_RESOURCES
 bool wxWriteResource(const wxString& section, const wxString& entry, const wxString& value, const wxString& file)
@@ -865,8 +871,15 @@
 {
     wxASSERT_MSG( IsValidControlHandle(m_controlRef) , wxT("Invalid Control Handle (maybe already released) in Dispose") );
 
+<<<<<<< utils.cpp
+    CFIndex count = CFGetRetainCount( m_controlRef ) ;
+    wxASSERT_MSG( count == 1 , wxT("Reference Count of native control was not 1 in Dispose") );
+
+    ::DisposeControl( m_controlRef );
+=======
     // we cannot check the ref count here anymore, as autorelease objects might delete their refs later
     CFRelease(m_controlRef);
+>>>>>>> 1.138
     m_controlRef = NULL;
 }
 
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/mac/classic/timer.cpp wxWidgets-2.8.0-p22/src/mac/classic/timer.cpp
--- wxWidgets-2.8.0/src/mac/classic/timer.cpp	2006-11-07 11:54:46.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/mac/classic/timer.cpp	2006-11-07 13:22:20.000000000 +0100
@@ -12,14 +12,12 @@
 // for compilers that support precompilation, includes "wx.h".
 #include "wx/wxprec.h"
 
-#include "wx/timer.h"
+#include "wx/mac/private/timer.h"
 
 #ifndef WX_PRECOMP
     #include "wx/dynarray.h"
 #endif
 
-IMPLEMENT_ABSTRACT_CLASS(wxTimer, wxEvtHandler)
-
 #ifdef __WXMAC__
 #include "wx/mac/private.h"
 #endif
@@ -31,7 +29,7 @@
 {
     TMTask m_task;
     wxMacNotifierTableRef m_table ;
-    wxTimer* m_timer ;
+    wxMacClassicTimerImpl* m_timer ;
 } ;
 
 static void wxProcessTimer( unsigned long event , void *data ) ;
@@ -53,9 +51,9 @@
     if ( !data )
         return ;
 
-    wxTimer* timer = (wxTimer*) data ;
+    wxMacClassicTimerImpl* timer = (wxMacClassicTimerImpl*) data ;
 
-    if ( timer->IsOneShot() )
+    if ( timer->m_oneShot )
         timer->Stop() ;
 
     gTimersInProcess.Add( timer ) ;
@@ -75,7 +73,7 @@
     }
 }
 
-void wxTimer::Init()
+void wxMacClassicTimerImpl::Init()
 {
     m_info = new MacTimerInfo() ;
     m_info->m_task.tmAddr = NULL ;
@@ -86,14 +84,14 @@
     m_info->m_timer = this ;
 }
 
-bool wxTimer::IsRunning() const
+bool wxMacClassicTimerImpl::IsRunning() const
 {
     // as the qType may already indicate it is elapsed, but it
     // was not handled internally yet
     return ( m_info->m_task.tmAddr != NULL ) ;
 }
 
-wxTimer::~wxTimer()
+wxMacClassicTimerImpl::~wxMacClassicTimerImpl()
 {
     Stop();
     if (m_info != NULL) {
@@ -105,9 +103,9 @@
         gTimersInProcess.RemoveAt( index ) ;
 }
 
-bool wxTimer::Start(int milliseconds,bool mode)
+bool wxMacClassicTimerImpl::Start(int milliseconds,bool mode)
 {
-    (void)wxTimerBase::Start(milliseconds, mode);
+    (void)wxTimerImpl::Start(milliseconds, mode);
 
     wxCHECK_MSG( m_milli > 0, false, wxT("invalid value for timer timeout") );
     wxCHECK_MSG( m_info->m_task.tmAddr == NULL , false, wxT("attempting to restart a timer") );
@@ -126,7 +124,7 @@
     return true;
 }
 
-void wxTimer::Stop()
+void wxMacClassicTimerImpl::Stop()
 {
     if ( m_info->m_task.tmAddr )
     {
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/mac/classic/utils.cpp wxWidgets-2.8.0-p22/src/mac/classic/utils.cpp
--- wxWidgets-2.8.0/src/mac/classic/utils.cpp	2006-11-07 11:54:46.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/mac/classic/utils.cpp	2006-11-07 13:22:21.000000000 +0100
@@ -22,6 +22,7 @@
 #endif
 
 #include "wx/apptrait.h"
+#include "wx/mac/private/timer.h"
 
 #if wxUSE_GUI
     #include "wx/mac/uma.h"
@@ -231,6 +232,11 @@
     return wxPORT_MAC;
 }
 
+wxTimerImpl* wxGUIAppTraits::CreateTimerImpl(wxTimer* p_timer)
+{
+    return new wxMacClassicTimerImpl(p_timer);
+}
+
 // Reading and writing resources (eg WIN.INI, .Xdefaults)
 #if wxUSE_RESOURCES
 bool wxWriteResource(const wxString& section, const wxString& entry, const wxString& value, const wxString& file)
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/motif/timer.cpp wxWidgets-2.8.0-p22/src/motif/timer.cpp
--- wxWidgets-2.8.0/src/motif/timer.cpp	2006-11-07 11:56:44.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/motif/timer.cpp	2006-11-07 13:22:26.000000000 +0100
@@ -12,7 +12,7 @@
 // For compilers that support precompilation, includes "wx.h".
 #include "wx/wxprec.h"
 
-#include "wx/timer.h"
+#include "wx/motif/private/timer.h"
 
 #ifndef WX_PRECOMP
     #include "wx/app.h"
@@ -29,13 +29,11 @@
 
 #include "wx/motif/private.h"
 
-IMPLEMENT_ABSTRACT_CLASS(wxTimer, wxEvtHandler)
-
-WX_DECLARE_VOIDPTR_HASH_MAP(wxTimer*, wxTimerHashMap);
+WX_DECLARE_VOIDPTR_HASH_MAP(wxMotifTimerImpl*, wxTimerHashMap);
 
 static wxTimerHashMap s_timers;
 
-void wxTimerCallback (wxTimer * timer)
+void wxTimerCallback (wxMotifTimerImpl *timer)
 {
   // Check to see if it's still on
   if (s_timers.find(timer) == s_timers.end())
@@ -55,23 +53,23 @@
   timer->Notify();
 }
 
-void wxTimer::Init()
+void wxMotifTimerImpl::Init()
 {
     m_id = 0;
     m_milli = 1000;
 }
 
-wxTimer::~wxTimer()
+wxMotifTimerImpl::~wxMotifTimerImpl()
 {
     Stop();
     s_timers.erase(this);
 }
 
-bool wxTimer::Start(int milliseconds, bool mode)
+bool wxMotifTimerImpl::Start(int milliseconds, bool mode)
 {
     Stop();
 
-    (void)wxTimerBase::Start(milliseconds, mode);
+    (void)wxTimerImpl::Start(milliseconds, mode);
 
     if (s_timers.find(this) == s_timers.end())
         s_timers[this] = this;
@@ -83,7 +81,7 @@
     return true;
 }
 
-void wxTimer::Stop()
+void wxMotifTimerImpl::Stop()
 {
     if (m_id > 0)
     {
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/motif/utils.cpp wxWidgets-2.8.0-p22/src/motif/utils.cpp
--- wxWidgets-2.8.0/src/motif/utils.cpp	2006-11-29 12:38:26.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/motif/utils.cpp	2006-11-29 12:36:01.000000000 +0100
@@ -34,6 +34,7 @@
 
 #include "wx/apptrait.h"
 #include "wx/evtloop.h"
+#include "wx/motif/private/timer.h"
 
 #include <string.h>
 
@@ -154,6 +155,11 @@
     return wxPORT_MOTIF;
 }
 
+wxTimerImpl* wxGUIAppTraits::CreateTimerImpl(wxTimer* p_timer) 
+{
+    return new wxMotifTimerImpl(p_timer);
+}
+
 
 // ----------------------------------------------------------------------------
 // Reading and writing resources (eg WIN.INI, .Xdefaults)
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/msw/appcon.cpp wxWidgets-2.8.0-p22/src/msw/appcon.cpp
--- wxWidgets-2.8.0/src/msw/appcon.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/msw/appcon.cpp	2006-11-10 14:25:29.000000000 +0100
@@ -0,0 +1,123 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        appcon.cpp
+// Purpose:     wxApp for wxBase
+// Author:      Lukasz Michalski
+// Modified by:
+// Created:     04/01/98
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) Lukasz Michalski
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+// ===========================================================================
+// declarations
+// ===========================================================================
+
+// ---------------------------------------------------------------------------
+// headers
+// ---------------------------------------------------------------------------
+
+// For compilers that support precompilation, includes "wx.h".
+#include "wx/wxprec.h"
+
+wxEventApp::wxEventApp()
+ : mExiting(false)
+{
+};
+
+bool
+wxEventApp::Initialize(int& argc, wxChar** argv) 
+{
+  if (!wxAppConsole::Initialize(argc,argv))
+    return false;
+#if wxUSE_THREADS
+  mMSWThreadID = GetCurrentThreadId();
+#endif
+  wxPendingEventsLocker = new wxCriticalSection();
+  return true;
+};
+
+int
+wxEventApp::OnRun() {
+  return MainLoop();
+};
+
+int 
+wxEventApp::MainLoop()
+{
+  DWORD result;
+  HANDLE* lphObjects = NULL;
+  int cObjects = 0;
+
+  while(!mExiting) {
+#if wxUSE_EXCEPTIONS
+    try {    
+#endif
+      result = MsgWaitForMultipleObjects(cObjects, lphObjects, FALSE, INFINITE, QS_ALLEVENTS);
+      if (result == (WAIT_OBJECT_0 + cObjects)) {
+        Dispatch();
+      };
+#if wxUSE_EXCEPTIONS
+    } catch (...) {
+      if ( !wxTheApp || !wxTheApp->OnExceptionInMainLoop() )
+        return -1;
+    };
+#endif
+  };
+  return 0;
+};
+
+bool 
+wxEventApp::OnExceptionInMainLoop() {
+  wxLogFatalError(_("An unhandled exception occured"));
+  throw;
+};
+
+void
+wxEventApp::Dispatch() 
+{
+  MSG msg;
+
+  while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
+    if (msg.message == WM_QUIT) {
+      return;
+    } else if (msg.message == WM_TIMER) {
+      TIMERPROC proc = (TIMERPROC)msg.lParam;
+      (*proc)(NULL,0,msg.wParam,0);
+    } else {
+      ::DispatchMessage(&msg);
+    };
+  };
+  ProcessPendingEvents();
+};
+
+void
+wxEventApp::ExitMainLoop()
+{
+  mExiting = true;
+  WakeUpIdle();
+};
+
+void
+wxEventApp::CleanUp() 
+{
+  delete wxPendingEvents;
+  wxPendingEvents = NULL;
+
+  delete wxPendingEventsLocker;
+  wxPendingEventsLocker = NULL;
+};
+
+void
+wxEventApp::WakeUpIdle()
+{
+  if (!::PostThreadMessage(mMSWThreadID, WM_NULL, 0, 0) )
+  {
+    // should never happen
+    wxLogLastError(wxT("PostMessage(WM_NULL)"));
+  }
+};
+
+wxEventApp::~wxEventApp() 
+{
+};
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/msw/app.cpp wxWidgets-2.8.0-p22/src/msw/app.cpp
--- wxWidgets-2.8.0/src/msw/app.cpp	2006-11-07 11:57:39.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/msw/app.cpp	2006-11-07 13:22:29.000000000 +0100
@@ -52,6 +52,7 @@
 
 #include "wx/msw/private.h"
 #include "wx/msw/ole/oleutils.h"
+#include "wx/msw/private/timer.h"
 
 #if wxUSE_TOOLTIPS
     #include "wx/tooltip.h"
@@ -248,6 +249,11 @@
 #endif
 }
 
+wxTimerImpl *
+wxGUIAppTraits::CreateTimerImpl(wxTimer *timer) {
+  return new wxMSWTimerImpl(timer);
+};
+
 // ===========================================================================
 // wxApp implementation
 // ===========================================================================
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/msw/basemsw.cpp wxWidgets-2.8.0-p22/src/msw/basemsw.cpp
--- wxWidgets-2.8.0/src/msw/basemsw.cpp	2006-11-07 11:57:39.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/msw/basemsw.cpp	2006-11-10 14:25:29.000000000 +0100
@@ -28,6 +28,7 @@
 #endif //WX_PRECOMP
 
 #include "wx/apptrait.h"
+#include "wx/msw/private/timer.h"
 // MBN: this is a workaround for MSVC 5: if it is not #included in
 // some wxBase file, wxRecursionGuard methods won't be exported from
 // wxBase.dll, and MSVC 5 will give linker errors
@@ -71,3 +72,10 @@
     return true;
 }
 
+wxTimerImpl *
+wxConsoleAppTraits::CreateTimerImpl(wxTimer *timer) 
+{
+    return new wxMSWTimerImpl(timer);
+}
+
+
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/msw/gsocket.cpp wxWidgets-2.8.0-p22/src/msw/gsocket.cpp
--- wxWidgets-2.8.0/src/msw/gsocket.cpp	2006-11-07 11:57:39.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/msw/gsocket.cpp	2006-11-08 13:56:34.000000000 +0100
@@ -132,7 +132,7 @@
 
   if (!gs_gui_functions)
   {
-    static GSocketGUIFunctionsTableNull table;
+    static GSocketGUIFunctionsTableConcrete table;
     gs_gui_functions = &table;
   }
   if ( !gs_gui_functions->OnInit() )
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/msw/timer.cpp wxWidgets-2.8.0-p22/src/msw/timer.cpp
--- wxWidgets-2.8.0/src/msw/timer.cpp	2006-11-07 11:57:39.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/msw/timer.cpp	2006-11-07 13:22:29.000000000 +0100
@@ -18,7 +18,7 @@
 
 #if wxUSE_TIMER
 
-#include "wx/timer.h"
+#include "wx/msw/private/timer.h"
 
 #ifndef WX_PRECOMP
     #include "wx/list.h"
@@ -38,7 +38,7 @@
 
 // define a hash containing all the timers: it is indexed by timer id and
 // contains the corresponding timer
-WX_DECLARE_HASH_MAP(unsigned long, wxTimer *, wxIntegerHash, wxIntegerEqual,
+WX_DECLARE_HASH_MAP(unsigned long, wxMSWTimerImpl *, wxIntegerHash, wxIntegerEqual,
                     wxTimerMap);
 
 // instead of using a global here, wrap it in a static function as otherwise it
@@ -58,33 +58,27 @@
 // timer callback used for all timers
 void WINAPI wxTimerProc(HWND hwnd, UINT msg, UINT_PTR idTimer, DWORD dwTime);
 
-// ----------------------------------------------------------------------------
-// macros
-// ----------------------------------------------------------------------------
-
-IMPLEMENT_ABSTRACT_CLASS(wxTimer, wxEvtHandler)
-
 // ============================================================================
 // implementation
 // ============================================================================
 
 // ----------------------------------------------------------------------------
-// wxTimer class
+// wxMSWTimerImpl class
 // ----------------------------------------------------------------------------
 
-void wxTimer::Init()
+void wxMSWTimerImpl::Init()
 {
     m_id = 0;
 }
 
-wxTimer::~wxTimer()
+wxMSWTimerImpl::~wxMSWTimerImpl()
 {
-    wxTimer::Stop();
+    Stop();
 }
 
-bool wxTimer::Start(int milliseconds, bool oneShot)
+bool wxMSWTimerImpl::Start(int milliseconds, bool oneShot)
 {
-    (void)wxTimerBase::Start(milliseconds, oneShot);
+    (void)wxTimerImpl::Start(milliseconds, oneShot);
 
     wxCHECK_MSG( m_milli > 0, false, wxT("invalid value for timer timeout") );
 
@@ -121,7 +115,7 @@
     return true;
 }
 
-void wxTimer::Stop()
+void wxMSWTimerImpl::Stop()
 {
     if ( m_id )
     {
@@ -137,11 +131,11 @@
 // private functions
 // ----------------------------------------------------------------------------
 
-void wxProcessTimer(wxTimer& timer)
+void wxProcessTimer(wxMSWTimerImpl& timer)
 {
     wxASSERT_MSG( timer.m_id != 0, _T("bogus timer id") );
 
-    if ( timer.IsOneShot() )
+    if ( timer.m_oneShot )
         timer.Stop();
 
     timer.Notify();
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/msw/utils.cpp wxWidgets-2.8.0-p22/src/msw/utils.cpp
--- wxWidgets-2.8.0/src/msw/utils.cpp	2006-11-29 12:38:44.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/msw/utils.cpp	2006-11-29 12:36:06.000000000 +0100
@@ -30,7 +30,6 @@
     #include "wx/app.h"
     #include "wx/intl.h"
     #include "wx/log.h"
-    #include "wx/timer.h"
 #endif  //WX_PRECOMP
 
 #include "wx/msw/registry.h"
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/os2/timer.cpp wxWidgets-2.8.0-p22/src/os2/timer.cpp
--- wxWidgets-2.8.0/src/os2/timer.cpp	2006-11-07 11:55:36.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/os2/timer.cpp	2006-11-07 13:22:24.000000000 +0100
@@ -12,7 +12,7 @@
 // For compilers that support precompilation, includes "wx.h".
 #include "wx/wxprec.h"
 
-#include "wx/timer.h"
+#include "wx/os2/private/timer.h"
 
 #ifndef WX_PRECOMP
     #include "wx/list.h"
@@ -36,7 +36,7 @@
 
 // define a hash containing all the timers: it is indexed by timer id and
 // contains the corresponding timer
-WX_DECLARE_HASH_MAP(unsigned long, wxTimer *, wxIntegerHash, wxIntegerEqual,
+WX_DECLARE_HASH_MAP(unsigned long, wxOS2TimerImpl *, wxIntegerHash, wxIntegerEqual,
                     wxTimerMap);
 
 // instead of using a global here, wrap it in a static function as otherwise it
@@ -56,12 +56,6 @@
 // timer callback used for all timers
 ULONG wxTimerProc(HWND hwnd, ULONG, int nIdTimer, ULONG);
 
-// ----------------------------------------------------------------------------
-// macros
-// ----------------------------------------------------------------------------
-
-IMPLEMENT_ABSTRACT_CLASS(wxTimer, wxEvtHandler)
-
 // ============================================================================
 // implementation
 // ============================================================================
@@ -70,17 +64,17 @@
 // wxTimer class
 // ----------------------------------------------------------------------------
 
-void wxTimer::Init()
+void wxOS2TimerImpl::Init()
 {
     m_ulId = 0;
 }
 
-wxTimer::~wxTimer()
+wxOS2TimerImpl::~wxOS2TimerImpl()
 {
-    wxTimer::Stop();
+    wxOS2TimerImpl::Stop();
 }
 
-void wxTimer::Notify()
+void wxOS2TimerImpl::Notify()
 {
     //
     // The base class version generates an event if it has owner - which it
@@ -96,9 +90,9 @@
     (void)m_owner->ProcessEvent(vEvent);
 } // end of wxTimer::Notify
 
-bool wxTimer::Start( int nMilliseconds, bool bOneShot )
+bool wxOS2TimerImpl::Start( int nMilliseconds, bool bOneShot )
 {
-    (void)wxTimerBase::Start( nMilliseconds, bOneShot );
+    (void)wxTimerImpl::Start( nMilliseconds, bOneShot );
 
     wxCHECK_MSG( m_milli > 0L, false, wxT("invalid value for timer") );
 
@@ -147,7 +141,7 @@
     }
 }
 
-void wxTimer::Stop()
+void wxOS2TimerImpl::Stop()
 {
     if ( m_ulId )
     {
@@ -170,7 +164,7 @@
 // ----------------------------------------------------------------------------
 
 void wxProcessTimer(
-  wxTimer&                          rTimer
+  wxOS2TimerImpl&                          rTimer
 )
 {
     //
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/os2/utilsgui.cpp wxWidgets-2.8.0-p22/src/os2/utilsgui.cpp
--- wxWidgets-2.8.0/src/os2/utilsgui.cpp	2006-11-07 11:55:36.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/os2/utilsgui.cpp	2006-11-07 13:22:25.000000000 +0100
@@ -33,6 +33,7 @@
 #endif //WX_PRECOMP
 
 #include "wx/apptrait.h"
+#include "wx/os2/private/timer.h"
 
 #include "wx/os2/private.h"     // includes <windows.h>
 
@@ -445,6 +446,11 @@
     return wxPORT_OS2;
 }
 
+wxTimerImpl* wxGUIAppTraits::CreateTimerImpl(wxTimer *p_timer) 
+{
+    return new wxOS2TimerImpl(p_timer);
+}
+
 
 // ---------------------------------------------------------------------------
 // window information functions
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/palmos/app.cpp wxWidgets-2.8.0-p22/src/palmos/app.cpp
--- wxWidgets-2.8.0/src/palmos/app.cpp	2006-11-07 11:55:26.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/palmos/app.cpp	2006-11-07 13:22:24.000000000 +0100
@@ -119,6 +119,10 @@
     return wxPORT_PALMOS;
 }
 
+wxTimerImpl* wxGUIAppTraits::CreateTimerImpl(wxTimer *p_timer) 
+{
+    return new wxPalmOSTimerImpl(p_timer);
+};
 // ===========================================================================
 // wxApp implementation
 // ===========================================================================
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/palmos/timer.cpp wxWidgets-2.8.0-p22/src/palmos/timer.cpp
--- wxWidgets-2.8.0/src/palmos/timer.cpp	2006-11-07 11:55:26.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/palmos/timer.cpp	2006-11-07 13:22:23.000000000 +0100
@@ -18,7 +18,7 @@
 
 #if wxUSE_TIMER
 
-#include "wx/timer.h"
+#include "wx/palmos/private/timer.h"
 
 #ifndef WX_PRECOMP
     #include "wx/list.h"
@@ -42,7 +42,7 @@
 
 // define a hash containing all the timers: it is indexed by timer id and
 // contains the corresponding timer
-WX_DECLARE_HASH_MAP(unsigned long, wxTimer *, wxIntegerHash, wxIntegerEqual,
+WX_DECLARE_HASH_MAP(unsigned long, wxPalmOSTimerImpl*, wxIntegerHash, wxIntegerEqual,
                     wxTimerMap);
 
 static wxTimerMap g_timerMap;
@@ -53,12 +53,6 @@
 
 void WINAPI wxTimerProc(HWND hwnd, WORD, int idTimer, DWORD);
 
-// ----------------------------------------------------------------------------
-// macros
-// ----------------------------------------------------------------------------
-
-IMPLEMENT_ABSTRACT_CLASS(wxTimer, wxEvtHandler)
-
 // ============================================================================
 // implementation
 // ============================================================================
@@ -67,20 +61,20 @@
 // wxTimer class
 // ----------------------------------------------------------------------------
 
-void wxTimer::Init()
+void wxPalmOSTimerImpl::Init()
 {
 }
 
-wxTimer::~wxTimer()
+wxPalmOSTimerImpl::~wxPalmOSTimerImpl()
 {
 }
 
-bool wxTimer::Start(int milliseconds, bool oneShot)
+bool wxPalmOSTimerImpl::Start(int milliseconds, bool oneShot)
 {
     return false;
 }
 
-void wxTimer::Stop()
+void wxPalmOSTimerImpl::Stop()
 {
 }
 
@@ -88,7 +82,7 @@
 // private functions
 // ----------------------------------------------------------------------------
 
-void wxProcessTimer(wxTimer& timer)
+void wxProcessTimer(wxPalmOSTimerImpl& timer)
 {
 }
 
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/unix/app.cpp wxWidgets-2.8.0-p22/src/unix/app.cpp
--- wxWidgets-2.8.0/src/unix/app.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/unix/app.cpp	2006-11-09 12:40:41.000000000 +0100
@@ -0,0 +1,318 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/unix/app.cpp
+// Purpose:     wxAppConsole with wxMainLoop implementation
+// Author:      Lukasz Michalski
+// Modified by:
+// Created:     28/01/2005
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) Lukasz Michalski
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#include "wx/app.h"
+#include "wx/unix/gsockunx.h"
+#include "wx/log.h"
+#include "wx/list.h"
+#include <signal.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#include "wx/unix/private/timer.h"
+
+
+#define wxBaseAppTrace wxT("baseapp")
+
+#include "wx/unix/gsockunx.h"
+#ifdef HAVE_SYS_EPOLL_H
+  #include <sys/epoll.h>
+#else
+  #include "wx/unix/socketstable.h"
+#endif
+
+int
+wxEventApp::OnRun() {
+  mExiting = false;
+  int ret = MainLoop();
+  return ret;
+};
+
+
+#ifdef HAVE_SYS_EPOLL_H 
+
+extern int wxBaseSocketsWatchEpollDescriptor;
+
+void 
+wxEventApp::Dispatch() {
+    epoll_event events[10];
+    wxLogTrace(wxBaseAppTrace,wxT("processing events"));
+    wxASSERT(wxTheApp != NULL);
+    wxTheApp->ProcessPendingEvents();
+
+    struct timeval tv;
+    long timeout;
+    if (gs_scheduler->getTimeToNextExpire(&tv))
+        timeout = tv.tv_sec * 1000 + tv.tv_usec / 1000;
+    else
+        timeout = -1;
+    int e_num = epoll_wait(wxBaseSocketsWatchEpollDescriptor,events,10,timeout);
+    if (e_num == -1) {
+      if (errno != EINTR) {
+        wxLogError(wxT("Call epoll_wait on epoll descriptor %d failed: %s"),wxBaseSocketsWatchEpollDescriptor,wxSysErrorMsg(errno));
+        mExitCode = -1;
+        mExiting = true;
+        return;
+      } 
+    };
+    for(int n = 0; n < e_num; n++) {
+      if (events[n].data.fd == mWakeupPipe[0]) {
+        //got wakeup from child thread
+        char s;
+        int size;
+        do {
+          errno = 0;
+          size = read(mWakeupPipe[0],&s,4);
+          if (size == 0) {
+            //Unexpected EOF on wakeup pipe
+            break;
+          };
+          if (size < 4) {
+            //bytes read from wakeup pipe
+            break;
+          };
+          if ((size == -1)&&(errno != EAGAIN)) {
+            //"Error reading data from wakeup pipe
+            break;
+          };
+        } while (errno != EAGAIN);
+      } else {
+        GSocket* s = (GSocket*)(events[n].data.ptr);
+        if ((events[n].events & EPOLLIN) || (events[n].events & EPOLLERR) || (events[n].events & EPOLLHUP)) {
+          if (s->m_fd != -1) {
+            //got read on s->m_fd
+            s->Detected_Read();
+          };
+        } else if (events[n].events & EPOLLOUT) {
+          if (s->m_fd != -1) {
+            //"got write on s->m_fd 
+            s->Detected_Write();
+          };
+        } else {
+          //got unknown event on s->m_fd
+        };
+      };
+    };
+    CheckSignal();
+    gs_scheduler->notifyCurrent();
+};
+
+#else
+
+wxSocketsTable* gs_sockets;
+
+void
+wxEventApp::Dispatch() {
+  wxLogTrace(wxBaseAppTrace,wxT("processing events"));
+  wxASSERT(wxTheApp != NULL);
+  wxTheApp->ProcessPendingEvents();
+  fd_set read_fds = gs_sockets->getReadFdSet();
+  fd_set write_fds = gs_sockets->getWriteFdSet();
+  fd_set exept_fds = gs_sockets->getExeptFdSet();
+  wxLogTrace(wxBaseAppTrace,wxT("waiting for io [higest: %d]"),gs_sockets->getHigestFd());
+  errno = 0;
+
+  // Calculate the time to the next wxTimer expiry. If no timers expiring
+  // then no select timeout
+  struct timeval tv, *tvp;
+  if (gs_scheduler->getTimeToNextExpire(&tv))
+    tvp = &tv;
+  else
+    tvp = NULL;
+  select(gs_sockets->getHigestFd(),&read_fds,&write_fds,&exept_fds,tvp);
+  if (errno != EINTR) {
+    wxLogTrace(wxBaseAppTrace,wxT("got io"));
+    for(int i = 0; i < gs_sockets->getHigestFd(); i++) {
+      if ((i == mWakeupPipe[0])&&(FD_ISSET(i,&read_fds))) {
+        wxLogTrace(wxBaseAppTrace,wxT("got wakeup from child thread"));
+        char s;
+        int size;
+        do {
+          errno = 0;
+          size = read(mWakeupPipe[0],&s,4);
+          if (size == 0) {
+            //Unexpected EOF on wakeup pipe
+            break;
+          };
+          if (size < 4) {
+            //bytes read from wakeup pipe
+            break;
+          };
+          if ((size == -1)&&(errno != EAGAIN)) {
+            printf("Error reading data from wakeup pipe");
+            break;
+          };
+        } while (errno != EAGAIN);
+      } else {
+        GSocket* sock = NULL;
+        if (FD_ISSET(i,&read_fds) || FD_ISSET(i,&write_fds) || FD_ISSET(i,&exept_fds)) {
+          sock = gs_sockets->findSocket(i);
+          if (sock != NULL) {
+            if (FD_ISSET(i,&read_fds)) {
+              wxLogTrace(wxBaseAppTrace,wxT("read avaiable on socket %d"),i);
+              sock->Detected_Read();
+            };
+            if (FD_ISSET(i,&write_fds)) {
+              wxLogTrace(wxBaseAppTrace,wxT("write avaiable on socket %d"),i);
+              sock->Detected_Write();
+            };
+            if (FD_ISSET(i,&exept_fds)) {
+              wxLogTrace(wxBaseAppTrace,wxT("exeption on socket %d"),i);
+              sock->Detected_Read();
+            };
+          } else {
+            wxLogError(wxT("(select) No such socket: %d"),i);
+          };
+        };
+      };
+    };
+  }
+  CheckSignal();
+  gs_scheduler->notifyCurrent();
+};
+
+#endif
+
+int
+wxEventApp::MainLoop() {
+  wxLogTrace(wxBaseAppTrace,wxT("entering main loop"));
+  wxLogTrace(wxBaseAppTrace,wxT("Creted pipe, read on %d, write on %d"),mWakeupPipe[0],mWakeupPipe[1]);
+  while(!mExiting) {
+    Dispatch();
+  };
+  return mExitCode;
+};
+
+bool 
+wxEventApp::Initialize(int& argc, wxChar** argv) {
+    if (!wxAppConsole::Initialize(argc,argv))
+    return false;
+  // initialize missing parts of wxWindows
+  wxPendingEventsLocker = new wxCriticalSection();
+  int ret = pipe(mWakeupPipe);
+  if (ret != 0) {
+    wxLogFatalError(wxT("wxApp: cannot craete wakeup pipe. exiting."));
+    return false;
+  };
+  
+  int oldflags = fcntl(mWakeupPipe[0],F_GETFL,0);
+  if (oldflags == -1) {
+    wxLogError(wxT("wxApp: Error reading file status flags on read pipe descriptor %d"),mWakeupPipe[0]);
+    return false;
+  };
+  
+  oldflags |= O_NONBLOCK;
+  
+  if (fcntl(mWakeupPipe[0],F_SETFL,oldflags) == -1) {
+    wxLogError(wxT("wxApp: Error setting O_NONBLOCK flag on read pipe descriptor %d"),mWakeupPipe[0]);
+    return false;
+  };
+  
+#ifdef HAVE_SYS_EPOLL_H
+  wxBaseSocketsWatchEpollDescriptor = epoll_create(1024);
+  if (wxBaseSocketsWatchEpollDescriptor == -1) {
+    wxLogError(wxT("Error initializing sockets module: Cannot create epoll descriptor: %s"),wxSysErrorMsg(errno));
+    return false;
+  };
+  epoll_event ev;
+  ev.events = EPOLLIN;
+  ev.data.fd = mWakeupPipe[0];
+  ret = epoll_ctl(wxBaseSocketsWatchEpollDescriptor,EPOLL_CTL_ADD,mWakeupPipe[0],&ev);
+  if (ret != 0) {
+    wxLogError(wxT("wxApp: Cannot add wakeup pipe read descriptor %d to epoll descriptor %d: %s"),mWakeupPipe[0],wxBaseSocketsWatchEpollDescriptor,wxSysErrorMsg(errno));
+    return -1;
+  };
+#else
+  gs_sockets = new wxSocketsTable();
+  wxLogTrace(wxBaseAppTrace,wxT("Creted pipe, read on %d, write on %d"),mWakeupPipe[0],mWakeupPipe[1]);
+  gs_sockets->setWakeupPipeReadFd(mWakeupPipe[0]);
+#endif
+
+  sigemptyset(&mSignalCatched);
+
+  mExitCode = 0;
+  return true;
+};
+
+
+void
+wxEventApp::ExitMainLoop() {
+  wxLogTrace(wxBaseAppTrace,wxT("baseapp: exiting..."));
+  mExiting = true;
+  WakeUpIdle();
+};
+
+void 
+wxEventApp::CleanUp() {
+  delete wxPendingEvents;
+  wxPendingEvents = NULL;
+  
+  delete wxPendingEventsLocker;
+  wxPendingEventsLocker = NULL;
+#ifdef HAVE_SYS_EPOLL_H
+  close(wxBaseSocketsWatchEpollDescriptor);
+  wxBaseSocketsWatchEpollDescriptor = -1;
+#else
+  delete gs_sockets;
+#endif
+};
+
+
+//do not put wxLog* here: it will cause deadlocks on trace critical secions
+void
+wxEventApp::WakeUpIdle() {
+  int size = write(mWakeupPipe[1],"s",1);
+  if(size != 1)
+    perror("write");
+};
+
+void
+wxEventApp::HandleSignal(int signal) {
+  sigaddset(&(wxTheApp->mSignalCatched), signal);
+  wxTheApp->WakeUpIdle();
+}
+
+void
+wxEventApp::CheckSignal() {
+  SignalHandlerHash::iterator it;
+  for( it = mSignalHandlerHash.begin(); it != mSignalHandlerHash.end(); ++it )
+  {
+    int sig = it->first;
+    if (sigismember(&mSignalCatched, sig))
+    {
+      // FIXME There is a race hash between testing signal and clearing
+      // signal but it should not really matter
+      sigdelset(&mSignalCatched, sig);
+      SignalHandler h = it->second;
+      if (h != 0)
+        h(sig);
+    }
+  }
+}
+
+void
+wxEventApp::SetSignalHandler(int signal, SignalHandler handler)
+{
+  struct sigaction sa;
+  memset(&sa, 0, sizeof(sa));
+  sa.sa_handler = HandleSignal;
+  sa.sa_flags = SA_RESTART;
+  int res = sigaction(signal, &sa, 0);
+  if (res < 0)
+    wxLogFatalError(wxT("wxEventApp: cannot install signal handler"));
+
+  if (handler == SIG_DFL || handler == SIG_IGN)
+    mSignalHandlerHash[signal] = 0;
+  else
+    mSignalHandlerHash[signal] = handler;
+}
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/unix/baseunix.cpp wxWidgets-2.8.0-p22/src/unix/baseunix.cpp
--- wxWidgets-2.8.0/src/unix/baseunix.cpp	2006-11-07 11:56:12.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/unix/baseunix.cpp	2006-11-10 16:31:10.000000000 +0100
@@ -32,15 +32,190 @@
 
 #include "wx/apptrait.h"
 #include "wx/unix/execute.h"
+#include "wx/unix/gsockunx.h"
+
+//for epoll calls
+#ifdef HAVE_SYS_EPOLL_H
+  #include <sys/epoll.h>
+  #define wxTRACE_epoll wxT("epoll")
+#else
+  #include "wx/unix/socketstable.h"
+#endif
+#include "wx/unix/private/timer.h"
+
+
+#include "wx/thread.h"
 
 // for waitpid()
 #include <sys/types.h>
 #include <sys/wait.h>
 
+//errno
+#include <errno.h>
+
 // ============================================================================
 // wxConsoleAppTraits implementation
 // ============================================================================
 
+// Sockets table for wxBase
+//
+//
+
+#ifdef HAVE_SYS_EPOLL_H
+int wxBaseSocketsWatchEpollDescriptor = -1;
+
+bool GSocketGUIFunctionsTableConcrete::OnInit()
+{   
+  return true;
+}
+
+void GSocketGUIFunctionsTableConcrete::OnExit()
+{
+}
+
+bool GSocketGUIFunctionsTableConcrete::CanUseEventLoop()
+{   return true; }
+
+bool GSocketGUIFunctionsTableConcrete::Init_Socket(GSocket *socket)
+{   return true; }
+
+void GSocketGUIFunctionsTableConcrete::Destroy_Socket(GSocket *socket)
+{
+  if (socket->m_fd == -1)
+    return;
+#ifdef wxUSE_THREADS
+  if (!wxThread::IsMain())
+    return;
+#endif
+  epoll_event ev;
+  ev.events = 0;
+  ev.data.ptr = (void*)socket;
+  int ret = epoll_ctl(wxBaseSocketsWatchEpollDescriptor,EPOLL_CTL_DEL,socket->m_fd,&ev);
+  if (ret != 0) {
+    wxLogError(wxT("Sockets module: Cannot remove socket %d from epoll descriptor %d: %s"),socket->m_fd,wxBaseSocketsWatchEpollDescriptor,wxSysErrorMsg(errno));
+  };
+}
+
+void GSocketGUIFunctionsTableConcrete::Install_Callback(GSocket *socket, GSocketEvent event)
+{
+  if (socket->m_fd == -1)
+    return;
+#ifdef wxUSE_THREADS
+  if (!wxThread::IsMain())
+    return;
+#endif
+  epoll_event ev;
+  ev.events = EPOLLERR | EPOLLHUP;
+  if ((socket->m_detected & GSOCK_INPUT_FLAG) == 0) {
+    wxLogTrace(wxTRACE_epoll,wxT("Adding EPOLLIN to socket %d"),socket->m_fd);
+    ev.events |= EPOLLIN;
+  }
+  if ((socket->m_detected & GSOCK_OUTPUT_FLAG) == 0) {
+    wxLogTrace(wxTRACE_epoll,wxT("Adding EPOLLOUT to socket %d"),socket->m_fd);
+    ev.events |= EPOLLOUT;
+  }
+  ev.data.ptr = (void*)socket;
+  int ret = epoll_ctl(wxBaseSocketsWatchEpollDescriptor,EPOLL_CTL_MOD,socket->m_fd,&ev);
+  if (ret != 0) {
+    wxLogError(wxT("Sockets module: Cannot modify socket %d on epoll descriptor %d: %s"),socket->m_fd,wxBaseSocketsWatchEpollDescriptor,wxSysErrorMsg(errno));
+  };
+}
+
+void GSocketGUIFunctionsTableConcrete::Uninstall_Callback(GSocket *socket, GSocketEvent event)
+{
+  if (socket->m_fd == -1)
+    return;
+#ifdef wxUSE_THREADS
+  if (!wxThread::IsMain())
+    return;
+#endif
+  epoll_event ev;
+  ev.events = EPOLLERR | EPOLLHUP;
+  if ((socket->m_detected & GSOCK_INPUT_FLAG) == GSOCK_INPUT_FLAG) {
+    wxLogTrace(wxTRACE_epoll,wxT("Removing EPOLLIN from socket %d"),socket->m_fd);
+    ev.events = EPOLLERR | EPOLLHUP | EPOLLOUT;
+  }
+  if ((socket->m_detected & GSOCK_OUTPUT_FLAG)== GSOCK_OUTPUT_FLAG) {
+    wxLogTrace(wxTRACE_epoll,wxT("Removing EPOLLOUT from socket %d"),socket->m_fd);
+    ev.events = EPOLLERR | EPOLLHUP | EPOLLIN;
+  }
+  ev.data.ptr = (void*)socket;
+  int ret = epoll_ctl(wxBaseSocketsWatchEpollDescriptor,EPOLL_CTL_MOD,socket->m_fd,&ev);
+  if (ret != 0) {
+    wxLogError(wxT("Sockets module: Cannot modify socket %d on epoll descriptor %d: %s"),socket->m_fd,wxBaseSocketsWatchEpollDescriptor,wxSysErrorMsg(errno));
+  };
+}
+
+void GSocketGUIFunctionsTableConcrete::Enable_Events(GSocket *socket)
+{
+  if (socket->m_fd == -1)
+    return;
+#ifdef wxUSE_THREADS
+  if (!wxThread::IsMain())
+    return;
+#endif
+  epoll_event ev;
+  ev.events = EPOLLERR | EPOLLHUP | EPOLLIN | EPOLLOUT;
+  ev.data.ptr = (void*)socket;
+  int ret = epoll_ctl(wxBaseSocketsWatchEpollDescriptor,EPOLL_CTL_ADD,socket->m_fd,&ev);
+  if (ret != 0) {
+    wxLogError(wxT("Sockets module: Cannot add socket %d to epoll descriptor %d: %s"),socket->m_fd,wxBaseSocketsWatchEpollDescriptor,wxSysErrorMsg(errno));
+  };
+  wxLogTrace(wxTRACE_epoll,wxT("Added socket %d to epoll %d"),socket->m_fd,wxBaseSocketsWatchEpollDescriptor);
+}
+
+void GSocketGUIFunctionsTableConcrete::Disable_Events(GSocket *socket)
+{
+  if (socket->m_fd == -1)
+    return;
+  epoll_event ev;
+  ev.events = 0;
+  ev.data.ptr = (void*)socket;
+  int ret = epoll_ctl(wxBaseSocketsWatchEpollDescriptor,EPOLL_CTL_DEL,socket->m_fd,&ev);
+  if (ret != 0) {
+    wxLogError(wxT("Sockets module: Cannot remove socket %d from epoll descriptor %d: (%d) %s"),socket->m_fd,wxBaseSocketsWatchEpollDescriptor,errno,wxSysErrorMsg(errno));
+  };
+  wxLogTrace(wxTRACE_epoll,wxT("Removed socket %d from epoll %d"),socket->m_fd,wxBaseSocketsWatchEpollDescriptor);
+}
+
+#else
+
+extern wxSocketsTable* gs_sockets;
+
+bool GSocketGUIFunctionsTableConcrete::OnInit()
+{ 
+  return true;
+}
+void GSocketGUIFunctionsTableConcrete::OnExit()
+{
+}
+bool GSocketGUIFunctionsTableConcrete::CanUseEventLoop()
+{   return true; }
+bool GSocketGUIFunctionsTableConcrete::Init_Socket(GSocket *socket)
+{   return true; }
+void GSocketGUIFunctionsTableConcrete::Destroy_Socket(GSocket *socket)
+{
+  gs_sockets->removeGSocket(socket);
+}
+void GSocketGUIFunctionsTableConcrete::Install_Callback(GSocket *socket, GSocketEvent event)
+{
+  gs_sockets->enableGSockEvents(socket,event);
+}
+void GSocketGUIFunctionsTableConcrete::Uninstall_Callback(GSocket *socket, GSocketEvent event)
+{
+  gs_sockets->disableGSockEvents(socket,event);
+}
+void GSocketGUIFunctionsTableConcrete::Enable_Events(GSocket *socket)
+{
+  gs_sockets->addGSocket(socket);
+}
+void GSocketGUIFunctionsTableConcrete::Disable_Events(GSocket *socket)
+{
+  gs_sockets->removeGSocket(socket);
+}
+#endif // HAVE_SYS_EPOLL_H
+
+
 // ----------------------------------------------------------------------------
 // wxExecute support
 // ----------------------------------------------------------------------------
@@ -81,3 +256,8 @@
     return exitcode;
 }
 
+wxTimerImpl*
+wxConsoleAppTraits::CreateTimerImpl(wxTimer *timer) 
+{
+    return new wxUnixTimerImpl(timer);
+}
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/unix/gsocket.cpp wxWidgets-2.8.0-p22/src/unix/gsocket.cpp
--- wxWidgets-2.8.0/src/unix/gsocket.cpp	2006-11-07 11:56:12.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/unix/gsocket.cpp	2006-11-08 13:56:08.000000000 +0100
@@ -21,6 +21,7 @@
 #ifndef __GSOCKET_STANDALONE__
 #include "wx/defs.h"
 #endif
+#include <wx/app.h>
 
 #if defined(__VISAGECPP__)
 #define BSD_SELECT /* use Berkeley Sockets select */
@@ -377,38 +378,6 @@
 
 static GSocketGUIFunctionsTable *gs_gui_functions;
 
-class GSocketGUIFunctionsTableNull: public GSocketGUIFunctionsTable
-{
-public:
-    virtual bool OnInit();
-    virtual void OnExit();
-    virtual bool CanUseEventLoop();
-    virtual bool Init_Socket(GSocket *socket);
-    virtual void Destroy_Socket(GSocket *socket);
-    virtual void Install_Callback(GSocket *socket, GSocketEvent event);
-    virtual void Uninstall_Callback(GSocket *socket, GSocketEvent event);
-    virtual void Enable_Events(GSocket *socket);
-    virtual void Disable_Events(GSocket *socket);
-};
-
-bool GSocketGUIFunctionsTableNull::OnInit()
-{   return true; }
-void GSocketGUIFunctionsTableNull::OnExit()
-{}
-bool GSocketGUIFunctionsTableNull::CanUseEventLoop()
-{   return false; }
-bool GSocketGUIFunctionsTableNull::Init_Socket(GSocket *WXUNUSED(socket))
-{   return true; }
-void GSocketGUIFunctionsTableNull::Destroy_Socket(GSocket *WXUNUSED(socket))
-{}
-void GSocketGUIFunctionsTableNull::Install_Callback(GSocket *WXUNUSED(socket), GSocketEvent WXUNUSED(event))
-{}
-void GSocketGUIFunctionsTableNull::Uninstall_Callback(GSocket *WXUNUSED(socket), GSocketEvent WXUNUSED(event))
-{}
-void GSocketGUIFunctionsTableNull::Enable_Events(GSocket *WXUNUSED(socket))
-{}
-void GSocketGUIFunctionsTableNull::Disable_Events(GSocket *WXUNUSED(socket))
-{}
 /* Global initialisers */
 
 void GSocket_SetGUIFunctions(GSocketGUIFunctionsTable *guifunc)
@@ -420,7 +389,7 @@
 {
   if (!gs_gui_functions)
   {
-    static GSocketGUIFunctionsTableNull table;
+    static GSocketGUIFunctionsTableConcrete table;
     gs_gui_functions = &table;
   }
   if ( !gs_gui_functions->OnInit() )
@@ -459,7 +428,8 @@
   m_timeout             = 10*60*1000;
                                 /* 10 minutes * 60 sec * 1000 millisec */
   m_establishing        = false;
-
+  m_use_events      = false;
+  
   assert(gs_gui_functions);
   /* Per-socket GUI-specific initialization */
   m_ok = gs_gui_functions->Init_Socket(this);
@@ -467,7 +437,8 @@
 
 void GSocket::Close()
 {
-    gs_gui_functions->Disable_Events(this);
+    if (m_use_events)
+      EnableEvents(false);
     /* gsockosx.c calls CFSocketInvalidate which closes the socket for us */
 #if !(defined(__DARWIN__) && (defined(__WXMAC__) || defined(__WXCOCOA__)))
     close(m_fd);
@@ -689,7 +660,8 @@
 #endif
 
   ioctl(m_fd, FIONBIO, &arg);
-  gs_gui_functions->Enable_Events(this);
+  if (m_use_events)
+    EnableEvents(true);
 
   /* allow a socket to re-bind if the socket is in the TIME_WAIT
      state after being previously closed.
@@ -720,6 +692,24 @@
   return GSOCK_NOERROR;
 }
 
+void 
+GSocket::Notify(bool pFlag) {
+  if (pFlag == m_use_events)
+    return;
+  m_use_events = pFlag;
+  EnableEvents(pFlag);
+};
+
+void
+GSocket::EnableEvents(bool pFlag) {
+  if (pFlag) {
+    gs_gui_functions->Enable_Events(this);
+  } else {
+    gs_gui_functions->Disable_Events(this);
+  };
+};
+
+
 /* GSocket_WaitConnection:
  *  Waits for an incoming client connection. Returns a pointer to
  *  a GSocket object, or NULL if there was an error, in which case
@@ -808,8 +798,6 @@
 #else
   ioctl(connection->m_fd, FIONBIO, &arg);
 #endif
-  gs_gui_functions->Enable_Events(connection);
-
   return connection;
 }
 
@@ -925,8 +913,8 @@
    * call to Enable_Events now.
    */
 
-  if (m_non_blocking || ret == 0)
-    gs_gui_functions->Enable_Events(this);
+  if (m_non_blocking && (m_non_blocking || ret == 0))
+    EnableEvents(true);
 
   if (ret == -1)
   {
@@ -1032,7 +1020,6 @@
 #else
   ioctl(m_fd, FIONBIO, &arg);
 #endif
-  gs_gui_functions->Enable_Events(this);
 
   /* Bind to the local address,
    * and retrieve the actual address bound.
@@ -1177,7 +1164,7 @@
  */
 GSocketEventFlags GSocket::Select(GSocketEventFlags flags)
 {
-  if (!gs_gui_functions->CanUseEventLoop())
+  if (!m_use_events)
   {
 
     GSocketEventFlags result = 0;
@@ -1447,9 +1434,17 @@
 
   if (!m_non_blocking)
   {
-    wxFD_ZERO(&readfds);
-    wxFD_SET(m_fd, &readfds);
-    ret = select(m_fd + 1, &readfds, NULL, NULL, &tv);
+    // Restart the select call if it is interrupted by a signal
+    do
+    {
+      wxFD_ZERO(&readfds);
+      wxFD_SET(m_fd, &readfds);
+      ret = select(m_fd + 1, &readfds, NULL, NULL, &tv);
+      if (wxTheApp->IsExiting())
+        break;
+    }
+    while (ret == -1 && errno == EINTR);
+
     if (ret == 0)
     {
       GSocket_Debug(( "GSocket_Input_Timeout, select returned 0\n" ));
@@ -1490,9 +1485,16 @@
 
   if (!m_non_blocking)
   {
-    wxFD_ZERO(&writefds);
-    wxFD_SET(m_fd, &writefds);
-    ret = select(m_fd + 1, NULL, &writefds, NULL, &tv);
+    do
+    {
+      wxFD_ZERO(&writefds);
+      wxFD_SET(m_fd, &writefds);
+      ret = select(m_fd + 1, NULL, &writefds, NULL, &tv);
+      if (wxTheApp->IsExiting())
+        break;
+    }
+    while (ret == -1 && errno == EINTR);
+
     if (ret == 0)
     {
       GSocket_Debug(( "GSocket_Output_Timeout, select returned 0\n" ));
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/unix/socketstable.cpp wxWidgets-2.8.0-p22/src/unix/socketstable.cpp
--- wxWidgets-2.8.0/src/unix/socketstable.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/unix/socketstable.cpp	2006-11-08 13:56:08.000000000 +0100
@@ -0,0 +1,142 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/unix/socketstable.h
+// Purpose:     Sockets table implementation 
+// Author:      Lukasz Michalski
+// Modified by:
+// Created:     28/01/2005
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) Lukasz Michalski
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#include "wx/unix/socketstable.h"
+
+#ifndef HAVE_SYS_EPOLL_H
+
+wxSocketsTable::wxSocketsTable() {
+  mHigestFd = 0;
+  FD_ZERO(&ar_fds);
+  FD_ZERO(&aw_fds);
+  FD_ZERO(&ae_fds);
+};
+
+void 
+wxSocketsTable::setWakeupPipeReadFd(int pFd) {
+  if (mHigestFd <= pFd)
+    mHigestFd = pFd + 1;
+  FD_SET(pFd,&ar_fds);
+};
+
+
+GSocket*
+wxSocketsTable::findSocket(int pFd) {
+#ifdef wxUSE_THREADS
+  wxCriticalSectionLocker l(mSocketMapLocker);
+#endif
+  SocketsTableType::iterator it = mSockets.find(pFd);
+  if (it == mSockets.end())
+    return NULL;
+  return it->second;
+};
+
+void
+wxSocketsTable::addGSocket(GSocket* pSocket) {
+  int fd = pSocket->m_fd;
+  if (fd <= 0)
+    return;
+#ifdef wxUSE_THREADS
+  if (!wxThread::IsMain())
+    return;
+  wxCriticalSectionLocker l(mSocketMapLocker);
+#endif
+  if (mHigestFd <= fd)
+    mHigestFd = fd + 1;
+//  wxLogTrace(wxBaseAppTrace,wxT("addGSocket %d"),fd);
+  mSockets[fd] = pSocket;
+  FD_SET(fd,&ar_fds);
+  FD_SET(fd,&aw_fds);
+  FD_SET(fd,&ae_fds);
+};
+
+void
+wxSocketsTable::removeGSocket(GSocket* pSocket) {
+  int fd = pSocket->m_fd;
+  if (fd <= 0)
+    return;
+//  wxLogTrace(wxBaseAppTrace,wxT("removeSocket %d"),fd);
+#ifdef wxUSE_THREADS
+  wxCriticalSectionLocker l(mSocketMapLocker);
+#endif
+  SocketsTableType::iterator it = mSockets.find(fd);
+  if (it != mSockets.end()) {
+    mSockets.erase(it);
+    FD_CLR(fd,&ar_fds);
+    FD_CLR(fd,&aw_fds);
+    FD_CLR(fd,&ae_fds);
+  };
+};
+
+void
+wxSocketsTable::enableGSockEvents(GSocket *pSocket, GSocketEvent event) {
+  int fd = pSocket->m_fd;
+  if (fd <= 0)
+    return;
+#ifdef wxUSE_THREADS
+  if (!wxThread::IsMain())
+    return;
+#endif
+  switch(event) {
+    case GSOCK_INPUT:
+//      wxLogTrace(wxBaseAppTrace,wxT("enableGSEvents: INPUT on %d"),pSocket->m_fd);
+      FD_SET(pSocket -> m_fd,&ar_fds);
+    break;
+    case GSOCK_OUTPUT:
+//      wxLogTrace(wxBaseAppTrace,wxT("enableGSEvents: OUTPUT on %d"),pSocket->m_fd);
+      FD_SET(pSocket -> m_fd,&aw_fds);
+    break;
+
+    //what to do here?
+    case GSOCK_CONNECTION:
+    break;
+
+    case GSOCK_LOST:
+    break;
+
+    default:
+//      wxLogTrace(wxBaseAppTrace,wxT("enableGSockEvents: unknown GSocketEvent %d"),event);
+    break;
+  };
+};
+
+void
+wxSocketsTable::disableGSockEvents(GSocket *pSocket, GSocketEvent event) {
+  int fd = pSocket->m_fd;
+  if (fd <= 0)
+    return;
+  if (!wxThread::IsMain())
+    return;
+  switch(event) {
+    case GSOCK_INPUT:
+//      wxLogTrace(wxBaseAppTrace,wxT("disableGSEvents: INPUT on %d"),pSocket->m_fd);
+      FD_CLR(pSocket -> m_fd,&ar_fds);
+    break;
+    case GSOCK_OUTPUT:
+//      wxLogTrace(wxBaseAppTrace,wxT("disableGSEvents: OUTPUT on %d"),pSocket->m_fd);
+      FD_CLR(pSocket -> m_fd,&aw_fds);
+    break;
+    //what to do here?
+
+    case GSOCK_CONNECTION:
+    break;
+
+
+    case GSOCK_LOST:
+    break;
+
+    default:
+//      wxLogTrace(wxBaseAppTrace,wxT("enableGSockEvents: unknown GSocketEvent %d"), event);
+    break;
+  };
+};
+
+#endif
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/unix/timer.cpp wxWidgets-2.8.0-p22/src/unix/timer.cpp
--- wxWidgets-2.8.0/src/unix/timer.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/unix/timer.cpp	2006-11-10 16:32:11.000000000 +0100
@@ -0,0 +1,224 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        src/unix/timer.cpp
+// Purpose:     wxTimer implementation for wxBase (unix)
+// Author:      Lukasz Michalski
+// Created:     15/01/2005
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) Lukasz Michalski
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#include "wx/log.h"
+#include "wx/module.h"
+#include "wx/app.h"
+#include <sys/time.h> 
+#include <signal.h>
+
+#include "wx/timer.h"
+#include "wx/unix/private/timer.h"
+
+
+TimerScheduler *gs_scheduler = NULL;
+
+#define wxTrace_Timer wxT("timer")
+
+#include "wx/listimpl.cpp"
+WX_DEFINE_LIST(TimerList);
+
+TimerScheduler::TimerScheduler()
+{
+}
+
+TimerScheduler::~TimerScheduler() throw() 
+{
+    TimerList::iterator node;
+    for(node = mData.begin(); node != mData.end(); ++node)
+      delete *node;
+}
+
+void TimerScheduler::addTimer(wxUnixTimerImpl* pRequester, wxLongLong expire) 
+{
+    wxTimerSchedule *s = new wxTimerSchedule;
+    s->mExpire = expire;
+    s->mTimer = pRequester;
+
+    // Do an insertion sort
+    TimerList::iterator node;
+    for(node = mData.begin(); node != mData.end(); ++node)
+    {
+      if ((*node)->mExpire > expire)
+      {
+        mData.insert(node, s);
+          break;
+      }
+    }
+    if (node == mData.end())
+      mData.Append(s);
+
+    wxLogTrace(wxTrace_Timer,
+      wxT("TimerScheduler::addTimer requestor %d expire=%ld"),
+          pRequester->m_idTimer, expire.GetLo());
+}
+
+void TimerScheduler::removeTimer(wxUnixTimerImpl* pRequester)
+{
+    wxLogTrace(wxTrace_Timer,wxT("TimerScheduler::removeTimer requestor %d"),
+               pRequester->m_idTimer);
+
+    TimerList::iterator node;
+    for(node = mData.begin(); node != mData.end(); ++node)
+    {
+      if ((*node)->mTimer == pRequester)
+      {
+        delete (*node);
+        mData.erase(node);
+        break;
+      }
+    }
+}
+
+#ifdef HAVE_GETTIMEOFDAY
+#ifdef WX_GETTIMEOFDAY_NO_TZ
+    struct timezone;
+    #define wxGetTimeOfDay(tv, tz)      gettimeofday(tv)
+#else
+    #define wxGetTimeOfDay(tv, tz)      gettimeofday((tv), (tz))
+#endif
+#endif // HAVE_GETTIMEOFDAY
+	
+wxLongLong getTimeMicroSeconds()
+{
+
+    struct timeval tp;
+    if ( wxGetTimeOfDay(&tp, (struct timezone *)NULL) != -1 )
+    {
+        wxLongLong val = 1000000L;
+        val *= tp.tv_sec;
+        return val + tp.tv_usec;
+    }
+    else
+    {
+        return wxGetLocalTimeMillis() * 1000L;
+    }
+}
+ 
+bool TimerScheduler::getTimeToNextExpire(struct timeval *tv)
+{
+    if (mData.IsEmpty())
+      return false;
+
+    wxTimerSchedule *s = mData.GetFirst()->GetData();
+    wxASSERT(s != 0);
+
+    wxLongLong now = getTimeMicroSeconds();
+    long delta = (s->mExpire - now).ToLong();
+    if (delta < 0)
+        delta = 0;
+    tv->tv_sec = delta/1000000L;
+    tv->tv_usec = delta % 1000000L;
+
+    return true;
+}
+
+void TimerScheduler::notifyCurrent()
+{
+    if (mData.IsEmpty())
+      return;
+
+    wxTimerSchedule *s = mData.GetFirst()->GetData();
+    wxASSERT(s != 0);
+
+    wxLongLong now = getTimeMicroSeconds();
+
+    TimerList::iterator node, next_node;
+    for(node = mData.begin(); node != mData.end(); node = next_node)
+    {
+      wxTimerSchedule *s = (*node);
+      if (s->mExpire > now)
+        break;
+
+      // Calculate next node as we will delete the nodes we add events for
+      next_node = node;
+      next_node++;
+
+      wxUnixTimerImpl* req = s->mTimer;
+        if (req->m_oneShot)
+          req->mRunning = false;
+        else
+        {
+          wxLongLong t = (*node)->mExpire;
+          t += req->m_milli * 1000L;
+          addTimer(req, t);
+        }
+
+        //we have to remove requester from current first, because it can call 
+        //removeTimer
+        mData.erase(node);
+        delete s;
+
+        wxTimerEvent evt(req->m_idTimer, req->m_milli);
+        if (req->m_owner != NULL) 
+          // FIXME Is this still true
+          // we are adding pending event because notifyCurrent() is
+          // called from signal handler and it is safer not to execute
+          // user code from signal handler but in wxApp::MainLoop()
+          req->m_owner->AddPendingEvent(evt);
+        else 
+          req->Notify();
+    }
+}
+
+//-----------------------------------------------------------
+
+wxUnixTimerImpl::wxUnixTimerImpl(wxTimer* p_timer) 
+  : wxTimerImpl(p_timer)
+{
+    mRunning = false;
+}
+
+bool wxUnixTimerImpl::Start(int milliseconds, bool oneShot)
+{
+    // Will stop already running timers
+    wxTimerImpl::Start(milliseconds, oneShot);
+
+    wxLongLong expire = getTimeMicroSeconds();
+    expire += m_milli * 1000L;
+    gs_scheduler->addTimer(this, expire);
+    mRunning = true;
+    return mRunning;
+}
+
+void wxUnixTimerImpl::Stop()
+{
+    if (mRunning)
+    {
+      gs_scheduler->removeTimer(this);
+      mRunning = false;
+    }
+}
+
+bool wxUnixTimerImpl::IsRunning() const
+{
+    return mRunning;
+}
+
+wxUnixTimerImpl::~wxUnixTimerImpl()
+{
+  if (mRunning)
+    gs_scheduler->removeTimer(this);
+}
+
+
+// A module to deallocate memory properly
+class wxTimerModule: public wxModule {
+    DECLARE_DYNAMIC_CLASS(wxTimerModule)
+  public:
+    wxTimerModule() {}
+    bool OnInit() { gs_scheduler = new TimerScheduler; return true; }
+    void OnExit() { delete gs_scheduler; gs_scheduler = NULL; }
+};
+
+IMPLEMENT_DYNAMIC_CLASS(wxTimerModule, wxModule)
+
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/x11/app.cpp wxWidgets-2.8.0-p22/src/x11/app.cpp
--- wxWidgets-2.8.0/src/x11/app.cpp	2006-11-29 12:38:58.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/x11/app.cpp	2006-11-29 12:36:38.000000000 +0100
@@ -22,7 +22,6 @@
     #include "wx/frame.h"
     #include "wx/icon.h"
     #include "wx/dialog.h"
-    #include "wx/timer.h"
     #include "wx/memory.h"
     #include "wx/gdicmn.h"
     #include "wx/module.h"
@@ -33,6 +32,7 @@
 
 #include "wx/univ/theme.h"
 #include "wx/univ/renderer.h"
+#include "wx/generic/private/timer.h"
 
 #if wxUSE_THREADS
     #include "wx/thread.h"
@@ -812,7 +812,7 @@
             wxTheApp->Dispatch();
 
 #if wxUSE_TIMER
-        wxTimer::NotifyTimers();
+        wxGenericTimerImpl::NotifyTimers();
 #endif
         ProcessIdle();
 
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/x11/evtloop.cpp wxWidgets-2.8.0-p22/src/x11/evtloop.cpp
--- wxWidgets-2.8.0/src/x11/evtloop.cpp	2006-12-14 16:01:04.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/x11/evtloop.cpp	2006-12-14 16:17:40.000000000 +0100
@@ -26,7 +26,6 @@
     #include "wx/hash.h"
     #include "wx/app.h"
     #include "wx/window.h"
-    #include "wx/timer.h"
     #include "wx/module.h"
 #endif
 
@@ -34,6 +33,7 @@
 #include "wx/unix/private.h"
 #include "wx/x11/private.h"
 #include "X11/Xlib.h"
+#include "wx/generic/private/timer.h"
 
 #if wxUSE_THREADS
     #include "wx/thread.h"
@@ -377,7 +377,7 @@
         while ( ! Pending() )
         {
 #if wxUSE_TIMER
-            wxTimer::NotifyTimers(); // TODO: is this the correct place for it?
+            wxGenericTimerImpl::NotifyTimers(); // TODO: is this the correct place for it?
 #endif
             if (!m_impl->SendIdleEvent())
             {
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/x11/reparent.cpp wxWidgets-2.8.0-p22/src/x11/reparent.cpp
--- wxWidgets-2.8.0/src/x11/reparent.cpp	2006-11-07 11:57:50.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/x11/reparent.cpp	2006-11-07 13:22:31.000000000 +0100
@@ -31,7 +31,6 @@
 #ifndef WX_PRECOMP
     #include "wx/log.h"
     #include "wx/app.h"
-    #include "wx/timer.h"
 #endif
 
 #include "wx/evtloop.h"
@@ -39,6 +38,7 @@
 #include "wx/x11/private.h"
 #include "X11/Xatom.h"
 
+#include "wx/generic/private/timer.h"
 /*
  * wxAdoptedWindow
  */
@@ -173,7 +173,7 @@
         else
         {
 #if wxUSE_TIMER
-            wxTimer::NotifyTimers();
+            wxGenericTimerImpl::NotifyTimers();
             wxTheApp->ProcessIdle();
 #endif
         }
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/x11/utils.cpp wxWidgets-2.8.0-p22/src/x11/utils.cpp
--- wxWidgets-2.8.0/src/x11/utils.cpp	2006-12-14 16:01:04.000000000 +0100
+++ wxWidgets-2.8.0-p22/src/x11/utils.cpp	2006-12-04 19:08:25.000000000 +0100
@@ -34,6 +34,7 @@
 #endif
 
 #include "wx/apptrait.h"
+#include "wx/generic/private/timer.h"
 
 #include <ctype.h>
 #include <stdarg.h>
@@ -169,6 +170,10 @@
     return wxPORT_X11;
 }
 
+wxTimerImpl *
+wxGUIAppTraits::CreateTimerImpl(wxTimer* p_timer) {
+    return new wxGenericTimerImpl(p_timer);
+}
 
 // ----------------------------------------------------------------------------
 // display info

 	  	 
