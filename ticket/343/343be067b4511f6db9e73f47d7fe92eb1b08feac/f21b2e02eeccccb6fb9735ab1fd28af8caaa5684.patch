diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/build/bakefiles/files.bkl wxWidgets-2.8.0-wxapp/build/bakefiles/files.bkl
--- wxWidgets-2.8.0/build/bakefiles/files.bkl	2007-04-20 09:21:09.458416500 +0200
+++ wxWidgets-2.8.0-wxapp/build/bakefiles/files.bkl	2007-04-20 13:00:05.698948500 +0200
@@ -54,6 +54,7 @@
 <!--                               UNIX                                     -->
 <!-- =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- -->
 <set var="BASE_UNIX_SRC" hints="files">
+    src/unix/app.cpp
     src/unix/baseunix.cpp
     src/unix/dir.cpp
     src/unix/dlunix.cpp
@@ -68,6 +69,7 @@
     src/unix/utilsunx.cpp
 </set>
 <set var="BASE_UNIX_HDR" hints="files">
+    wx/unix/app.h
     wx/unix/apptbase.h
     wx/unix/apptrait.h
     wx/unix/execute.h
@@ -82,6 +84,7 @@
 <!--                             Windows                                    -->
 <!-- =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- -->
 <set var="BASE_WIN32_SRC" hints="files">
+    src/msw/appcon.cpp
     src/msw/basemsw.cpp
     src/msw/crashrpt.cpp
     src/msw/debughlp.cpp
@@ -109,6 +112,7 @@
     <if cond="TOOLKIT=='WINCE'">src/msw/wince/time.cpp</if>
 </set>
 <set var="BASE_WIN32_HDR" hints="files">
+    wx/msw/appcon.h
     wx/msw/apptrait.h
     wx/msw/apptbase.h
     wx/msw/chkconf.h
@@ -308,6 +312,7 @@
     src/common/dynlib.cpp
     src/common/dynload.cpp
     src/common/encconv.cpp
+    src/common/epolldispatcher.cpp
     src/common/extended.c
     src/common/ffile.cpp
     src/common/file.cpp
@@ -338,6 +343,7 @@
     src/common/powercmn.cpp
     src/common/process.cpp
     src/common/regex.cpp
+    src/common/selectdispatcher.cpp
     src/common/stdpbase.cpp
     src/common/sstream.cpp
     src/common/stopwatch.cpp
@@ -1419,7 +1425,6 @@
 <set var="X11_LOWLEVEL_SRC" hints="files">
     $(XWIN_LOWLEVEL_SRC)
     src/common/gsocketiohandler.cpp
-    src/common/selectdispatcher.cpp
     src/generic/icon.cpp
     src/generic/timer.cpp
     src/x11/app.cpp
Files wxWidgets-2.8.0/build/bakefiles/wxwin.pyc and wxWidgets-2.8.0-wxapp/build/bakefiles/wxwin.pyc differ
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/configure.in wxWidgets-2.8.0-wxapp/configure.in
--- wxWidgets-2.8.0/configure.in	2007-04-20 09:21:09.326408250 +0200
+++ wxWidgets-2.8.0-wxapp/configure.in	2007-04-20 13:05:31.241168000 +0200
@@ -1859,6 +1859,9 @@
     AC_CHECK_HEADER([sys/select.h],,, [AC_INCLUDES_DEFAULT()])
 fi
 
+dnl defines HAVE_SYS_EPOLL_H - for epoll mainloop implementation in wxbase
+AC_CHECK_HEADERS(sys/epoll.h)
+
 dnl ---------------------------------------------------------------------------
 dnl Checks for compiler characteristics
 dnl ---------------------------------------------------------------------------
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/app.h wxWidgets-2.8.0-wxapp/include/wx/app.h
--- wxWidgets-2.8.0/include/wx/app.h	2007-04-10 10:05:27.776216000 +0200
+++ wxWidgets-2.8.0-wxapp/include/wx/app.h	2007-04-20 09:34:50.521729750 +0200
@@ -560,8 +560,18 @@
         #include "wx/os2/app.h"
     #endif
 #else // !GUI
-    // allow using just wxApp (instead of wxAppConsole) in console programs
-    typedef wxAppConsole wxApp;
+    //wxApp is defined in core and we cannot define another one in wxBase
+    //We create different class and typedef it to wxApp instead
+    #if defined(__UNIX__)
+        #include "wx/unix/app.h"
+        typedef wxEventApp wxApp;
+    #elif defined(__WXMSW__)
+        #include "wx/msw/appcon.h"
+        typedef wxEventApp wxApp;
+    #else
+      // allow using just wxApp (instead of wxAppConsole) in console programs
+      typedef wxAppConsole wxApp;
+    #endif
 #endif // GUI/!GUI
 
 // ----------------------------------------------------------------------------
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/msw/appcon.h wxWidgets-2.8.0-wxapp/include/wx/msw/appcon.h
--- wxWidgets-2.8.0/include/wx/msw/appcon.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-wxapp/include/wx/msw/appcon.h	2007-04-20 11:22:38.000000000 +0200
@@ -0,0 +1,47 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/msw/appcon.h
+// Purpose:     wxAppConsole with wxMainLoop implementation
+// Author:      Lukasz Michalski
+// Modified by:
+// Created:     15/09/2005
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) Lukasz Michalski
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _APPCON_H_
+#define _APPCON_H_
+
+#include "wx/app.h"
+
+//Main application class
+class WXDLLIMPEXP_BASE wxEventApp : public wxAppConsole 
+{
+  public:
+    wxEventApp();
+    virtual ~wxEventApp();
+    //Start program execution by entering main loop and waiting for events
+    virtual bool Initialize(int& argc, wxChar** argv);
+    virtual int OnRun();
+    virtual int MainLoop();
+    virtual void WakeUpIdle();
+    virtual void ExitMainLoop();
+    virtual void CleanUp();
+    virtual void Dispatch(); 
+#if wxUSE_EXCEPTIONS
+    virtual bool OnExceptionInMainLoop();
+#endif // wxUSE_EXCEPTIONS
+
+   
+  private:
+    wxCriticalSection m_WakeupCS;
+    bool m_IsProcessingEvent;
+
+  protected:
+    bool m_exiting;
+#if wxUSE_THREADS
+    WXDWORD m_MSWThreadID;
+#endif
+};
+
+#endif //_APPCON_H_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/private/epolldispatcher.h wxWidgets-2.8.0-wxapp/include/wx/private/epolldispatcher.h
--- wxWidgets-2.8.0/include/wx/private/epolldispatcher.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-wxapp/include/wx/private/epolldispatcher.h	2007-04-20 13:34:49.327041500 +0200
@@ -0,0 +1,42 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/private/epolldispatcher.h
+// Purpose:     wxEpollDispatcher class
+// Authors:     Lukasz Michalski
+// Modified by:
+// Created:     April 2007
+// Copyright:   (c) Lukasz Michalski
+// RCS-ID:      $Id: epolldispatcher.h,v 1.3 2007/03/19 02:27:34 VZ Exp $
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_PRIVATE_EPOLLDISPATCHER_H_
+#define _WX_PRIVATE_EPOLLDISPATCHER_H_
+
+#include "wx/defs.h"
+#include "wx/private/fdiodispatcher.h"
+
+#ifdef HAVE_SYS_EPOLL_H
+
+#include <sys/epoll.h>
+
+class WXDLLIMPEXP_CORE wxEpollDispatcher : public wxFDIODispatcher
+{
+public:
+    wxEpollDispatcher() { m_epollDescriptor = -1; }
+    bool Init();
+    virtual ~wxEpollDispatcher() {}
+    virtual void RegisterFD(int fd, wxFDIOHandler* handler, int flags = wxFDIO_ALL);
+    virtual void ModifyFD(int fd, wxFDIOHandler* handler, int flags = wxFDIO_ALL);
+    //UnregisterFD and FindHandler always returns NULL in this dispatcher
+    //because there is no way to fetch user data passed to epoll_ctl sys call
+    virtual wxFDIOHandler* UnregisterFD(int fd, int flags = wxFDIO_ALL);
+    virtual wxFDIOHandler* FindHandler(int fd);
+    virtual void RunLoop(int timeout = FDIO_TIMEOUT_INFINITE);
+
+private:
+    int m_epollDescriptor;
+};
+
+#endif // HAVE_SYS_EPOLL_H
+
+#endif // _WX_PRIVATE_SOCKETEVTDISPATCH_H_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/private/fdiodispatcher.h wxWidgets-2.8.0-wxapp/include/wx/private/fdiodispatcher.h
--- wxWidgets-2.8.0/include/wx/private/fdiodispatcher.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-wxapp/include/wx/private/fdiodispatcher.h	2007-04-20 14:30:52.550537750 +0200
@@ -0,0 +1,70 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/private/selectdispatcher.h
+// Purpose:     wxSelectDispatcher class
+// Authors:     Lukasz Michalski
+// Modified by:
+// Created:     December 2006
+// Copyright:   (c) Lukasz Michalski
+// RCS-ID:      $Id: selectdispatcher.h,v 1.3 2007/03/19 02:27:34 VZ Exp $
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_PRIVATE_FDIODISPATCHER_H_
+#define _WX_PRIVATE_FDIODISPATCHER_H_
+
+#include "wx/defs.h"
+
+#include "wx/hashmap.h"
+
+
+// handler used to process events on descriptors
+class wxFDIOHandler
+{
+public:
+    // called when descriptor is available for non-blocking read
+    virtual void OnReadWaiting() = 0;
+
+    // called when descriptor is available  for non-blocking write
+    virtual void OnWriteWaiting() = 0;
+
+    // called when there is exception on descriptor
+    virtual void OnExceptionWaiting() = 0;
+
+    // virtual dtor for the base class
+    virtual ~wxFDIOHandler() { }
+};
+
+// those flags describes sets where descriptor should be added
+typedef enum {
+    wxFDIO_INPUT = 1,
+    wxFDIO_OUTPUT = 2,
+    wxFDIO_EXCEPTION = 4,
+    wxFDIO_ALL = wxFDIO_INPUT | wxFDIO_OUTPUT | wxFDIO_EXCEPTION
+} wxFDIODispatcherEntryFlags;
+
+// interface for SelectDispatcher and EpollDispatcher
+class WXDLLIMPEXP_CORE wxFDIODispatcher
+{
+public:
+    static const int FDIO_TIMEOUT_INFINITE = -1;
+
+    // register descriptor in sets.
+    virtual void RegisterFD(int fd, wxFDIOHandler* handler, int flags) = 0;
+
+    //modify descriptor flags or handler
+    virtual void ModifyFD(int fd, wxFDIOHandler* handler, int flags) = 0;
+
+    // unregister descriptor from sets and return handler for cleanup
+    virtual wxFDIOHandler* UnregisterFD(int fd, int flags) = 0;
+
+    // return handler for descriptor or null if fd is not registered
+    virtual wxFDIOHandler* FindHandler(int fd) = 0;
+
+    // calls select on registered descriptors
+    virtual void RunLoop(int timeout) = 0;
+
+    virtual ~wxFDIODispatcher() { };
+};
+
+
+#endif // _WX_PRIVATE_FDIODISPATCHER_H_
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/private/gsocketiohandler.h wxWidgets-2.8.0-wxapp/include/wx/private/gsocketiohandler.h
--- wxWidgets-2.8.0/include/wx/private/gsocketiohandler.h	2007-03-16 16:45:04.000000000 +0100
+++ wxWidgets-2.8.0-wxapp/include/wx/private/gsocketiohandler.h	2007-04-20 14:30:51.202453500 +0200
@@ -25,13 +25,13 @@
 public:
     wxGSocketIOHandler(GSocket* socket);
     int GetFlags() const;
-    void RemoveFlag(wxSelectDispatcherEntryFlags flag);
-    void AddFlag(wxSelectDispatcherEntryFlags flag);
+    void RemoveFlag(wxFDIODispatcherEntryFlags flag);
+    void AddFlag(wxFDIODispatcherEntryFlags flag);
 
 private:
-    virtual void OnReadWaiting(int fd);
-    virtual void OnWriteWaiting(int fd);
-    virtual void OnExceptionWaiting(int fd);
+    virtual void OnReadWaiting();
+    virtual void OnWriteWaiting();
+    virtual void OnExceptionWaiting();
 
     GSocket* m_socket;
     int m_flags;
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/private/selectdispatcher.h wxWidgets-2.8.0-wxapp/include/wx/private/selectdispatcher.h
--- wxWidgets-2.8.0/include/wx/private/selectdispatcher.h	2007-03-19 03:27:34.000000000 +0100
+++ wxWidgets-2.8.0-wxapp/include/wx/private/selectdispatcher.h	2007-04-20 13:12:02.393613500 +0200
@@ -13,36 +13,9 @@
 #define _WX_PRIVATE_SELECTDISPATCHER_H_
 
 #include "wx/defs.h"
-
 #include "wx/hashmap.h"
 
-static const int wxSELECT_TIMEOUT_INFINITE = -1;
-
-// handler used to process events on descriptors
-class wxFDIOHandler
-{
-public:
-    // called when descriptor is available for non-blocking read
-    virtual void OnReadWaiting(int fd) = 0;
-
-    // called when descriptor is available  for non-blocking write
-    virtual void OnWriteWaiting(int fd) = 0;
-
-    // called when there is exception on descriptor
-    virtual void OnExceptionWaiting(int fd) = 0;
-
-    // virtual dtor for the base class
-    virtual ~wxFDIOHandler() { }
-};
-
-// those flags describes sets where descriptor should be added
-enum wxSelectDispatcherEntryFlags
-{
-    wxSelectInput = 1,
-    wxSelectOutput = 2,
-    wxSelectException = 4,
-    wxSelectAll = wxSelectInput | wxSelectOutput | wxSelectException
-};
+#include "wx/private/fdiodispatcher.h"
 
 WX_DECLARE_HASH_MAP(
   int,
@@ -52,7 +25,7 @@
   wxFDIOHandlerMap
 );
 
-class WXDLLIMPEXP_CORE wxSelectDispatcher
+class WXDLLIMPEXP_CORE wxSelectDispatcher : public wxFDIODispatcher
 {
 public:
     // returns instance of the table
@@ -62,17 +35,11 @@
     {
     }
 
-    // register descriptor in sets.
-    void RegisterFD(int fd, wxFDIOHandler* handler, int flags = wxSelectAll);
-
-    // unregister descriptor from sets and return handler for cleanup
-    wxFDIOHandler* UnregisterFD(int fd, int flags = wxSelectAll);
-
-    // return handler for descriptor or null if fd is not registered
-    wxFDIOHandler* FindHandler(int fd);
-
-    // calls select on registered descriptors and
-    void RunLoop(int timeout = wxSELECT_TIMEOUT_INFINITE);
+    virtual void RegisterFD(int fd, wxFDIOHandler* handler, int flags = wxFDIO_ALL);
+    virtual void ModifyFD(int fd, wxFDIOHandler* handler, int flags = wxFDIO_ALL);
+    virtual wxFDIOHandler* UnregisterFD(int fd, int flags = wxFDIO_ALL);
+    virtual wxFDIOHandler* FindHandler(int fd);
+    virtual void RunLoop(int timeout = FDIO_TIMEOUT_INFINITE);
 
 protected:
     wxSelectDispatcher() { m_maxFD = -1; }
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/include/wx/unix/app.h wxWidgets-2.8.0-wxapp/include/wx/unix/app.h
--- wxWidgets-2.8.0/include/wx/unix/app.h	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-wxapp/include/wx/unix/app.h	2007-04-20 14:18:44.381030000 +0200
@@ -0,0 +1,78 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/unix/app.h
+// Purpose:     wxAppConsole with wxMainLoop implementation
+// Author:      Lukasz Michalski
+// Modified by:
+// Created:     28/01/2005
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) Lukasz Michalski
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+extern "C" {
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+};
+
+#include "wx/private/fdiodispatcher.h"
+#include "wx/unix/private/timer.h"
+
+//flag for timer set in handler
+
+//Main application class
+class WXDLLIMPEXP_BASE wxEventApp : public wxAppConsole {
+    friend class GSocketGUIFunctionsTableBase;
+  public:
+    //Start program execution by entering main loop and waiting for events
+    virtual bool Initialize(int& argc, wxChar** argv);
+    virtual int OnRun();
+    virtual int MainLoop();
+    virtual void WakeUpIdle();
+    virtual void ExitMainLoop();
+    virtual void CleanUp();
+    virtual void Dispatch();
+
+    // Some unix specific synchronous signal handler code
+    typedef void (*SignalHandler)(int);
+    // Can reset by setting handler to SIG_DFL or SIG_IGN
+    void SetSignalHandler(int signal, SignalHandler handler);
+  private:
+    //pipe for wake up messages.
+    //when child thread wants to wake up main thread it writes one byte to PipeIOHander fd.
+    //Main thread goes out of select() [or epoll_wait()] and start processing events.
+    class PipeIOHandler : public wxFDIOHandler 
+    {
+    public:
+        PipeIOHandler();
+        //initialize pipe descriptors
+        bool Init();
+        //this method can be called from different threads
+        //do not put wxLog* here: it will cause deadlocks on trace critical secions
+        void WakeUp() {
+            int size = write(m_wakeupPipe[1],"s",1);
+            if(size != 1)
+                perror("write");
+        };
+        int getReadFd() { return m_wakeupPipe[0]; };
+    private:
+        virtual void OnReadWaiting();
+        virtual void OnWriteWaiting() {};
+        virtual void OnExceptionWaiting() {};
+        int m_wakeupPipe[2];
+    };
+
+    PipeIOHandler m_wakeupPipe;
+    wxFDIODispatcher* m_FdDispatcher;
+
+    bool m_exiting;
+    bool m_usingEpoll;
+
+    // General unix signal handling code
+    sigset_t m_signalCatched;
+    WX_DECLARE_HASH_MAP(int, SignalHandler, wxIntegerHash, wxIntegerEqual, SignalHandlerHash );
+    SignalHandlerHash m_signalHandlerHash;
+
+    static void HandleSignal(int signal);
+    void CheckSignal();
+};
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/setup.h.in wxWidgets-2.8.0-wxapp/setup.h.in
--- wxWidgets-2.8.0/setup.h.in	2007-04-20 09:21:09.330408500 +0200
+++ wxWidgets-2.8.0-wxapp/setup.h.in	2007-04-20 13:08:40.180976000 +0200
@@ -1140,6 +1140,9 @@
 /* Define if you have the <sys/select.h> header file.  */
 #undef HAVE_SYS_SELECT_H
 
+/* Define if you have the <sys/epoll.h> header file.  */
+#undef HAVE_SYS_EPOLL_H
+
 /* Define if fdopen is available.  */
 #undef HAVE_FDOPEN
 
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/common/epolldispatcher.cpp wxWidgets-2.8.0-wxapp/src/common/epolldispatcher.cpp
--- wxWidgets-2.8.0/src/common/epolldispatcher.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-wxapp/src/common/epolldispatcher.cpp	2007-04-20 13:35:57.551305250 +0200
@@ -0,0 +1,159 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        src/common/epolldispatcher.cpp
+// Purpose:     implements dispatcher for epoll_wait() call
+// Author:      Lukasz Michalski
+// Created:     April 2007
+// RCS-ID:      $Id: epolldispatcher.cpp,v 1.2 2007/03/19 02:29:49 VZ Exp $
+// Copyright:   (c) 2007 Lukasz Michalski
+// License:     wxWindows licence
+///////////////////////////////////////////////////////////////////////////////
+
+// ============================================================================
+// declarations
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// headers
+// ----------------------------------------------------------------------------
+
+// for compilers that support precompilation, includes "wx.h".
+#include "wx/wxprec.h"
+
+#include "wx/private/epolldispatcher.h"
+#include "wx/unix/private.h"
+#include "wx/log.h"
+
+#include <errno.h>
+
+#ifdef HAVE_SYS_EPOLL_H
+
+#define wxEpollDispatcher_Trace wxT("epolldispatcher")
+
+// ============================================================================
+// implementation
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// wxEpollDispatcher
+// ----------------------------------------------------------------------------
+
+bool 
+wxEpollDispatcher::Init() {
+    m_epollDescriptor = epoll_create(1024);
+    if (m_epollDescriptor == -1) {
+        wxLogError(wxT("Cannot create epoll descriptor: %s"),wxSysErrorMsg(errno));
+        return false;
+    };
+    return true;
+};
+
+void
+wxEpollDispatcher::RegisterFD(int fd, wxFDIOHandler* handler, int flags)
+{
+    epoll_event ev;
+    ev.events = 0;
+
+    if ((flags & wxFDIO_INPUT) == wxFDIO_INPUT) 
+    {
+        ev.events |= EPOLLIN;
+        wxLogTrace(wxEpollDispatcher_Trace,wxT("Registered fd %d for input events"),fd);
+    };
+
+    if ((flags & wxFDIO_OUTPUT) == wxFDIO_OUTPUT)
+    {
+        ev.events |= EPOLLOUT;
+        wxLogTrace(wxEpollDispatcher_Trace,wxT("Registered fd %d for output events"),fd);
+    }
+
+    //reduntant - epoll docs says that ERR and HUP are always set
+    if ((flags & wxFDIO_EXCEPTION) == wxFDIO_EXCEPTION)
+    {
+        ev.events = EPOLLERR | EPOLLHUP;
+        wxLogTrace(wxEpollDispatcher_Trace,wxT("Registered fd %d for exception events"),fd);
+    };
+
+    ev.data.ptr = (void*)handler;
+    int ret = epoll_ctl(m_epollDescriptor,EPOLL_CTL_ADD,fd,&ev);
+    if (ret != 0) {
+        wxLogSysError(wxT("Cannot register fd %d on epoll descriptor %d: %s"),fd,m_epollDescriptor,wxSysErrorMsg(errno));
+    };
+}
+
+void
+wxEpollDispatcher::ModifyFD(int fd, wxFDIOHandler* handler, int flags)
+{
+    epoll_event ev;
+    ev.events = 0;
+
+    if ((flags & wxFDIO_INPUT) == wxFDIO_INPUT) 
+    {
+        ev.events |= EPOLLIN;
+        wxLogTrace(wxEpollDispatcher_Trace,wxT("Registered fd %d for input events"),fd);
+    };
+
+    if ((flags & wxFDIO_OUTPUT) == wxFDIO_OUTPUT)
+    {
+        ev.events |= EPOLLOUT;
+        wxLogTrace(wxEpollDispatcher_Trace,wxT("Registered fd %d for output events"),fd);
+    }
+
+    //reduntant - epoll docs says that ERR and HUP are always set
+    if ((flags & wxFDIO_EXCEPTION) == wxFDIO_EXCEPTION)
+    {
+        ev.events = EPOLLERR | EPOLLHUP;
+        wxLogTrace(wxEpollDispatcher_Trace,wxT("Registered fd %d for exception events"),fd);
+    };
+
+    ev.data.ptr = (void*)handler;
+    int ret = epoll_ctl(m_epollDescriptor,EPOLL_CTL_MOD,fd,&ev);
+    if (ret != 0) {
+        wxLogSysError(wxT("Cannot register fd %d on epoll descriptor %d: %s"),fd,m_epollDescriptor,wxSysErrorMsg(errno));
+    };
+}
+
+wxFDIOHandler*
+wxEpollDispatcher::UnregisterFD(int fd, int flags)
+{
+    epoll_event ev;
+    ev.events = 0;
+    ev.data.ptr = NULL;
+    int ret = epoll_ctl(m_epollDescriptor,EPOLL_CTL_DEL,fd,&ev);
+    if (ret != 0) {
+        wxLogSysError(wxT("Cannot unregister fd %d on epoll descriptor %d: %s"),fd,m_epollDescriptor,wxSysErrorMsg(errno));
+    };
+    //it is not possible to get pointer to passed FDIOHandler
+    return NULL;
+}
+
+wxFDIOHandler* wxEpollDispatcher::FindHandler(int fd)
+{
+    wxASSERT_MSG(false,wxT("This dispatcher does not support FDIOHandler searching"));
+    return NULL;
+};
+
+void wxEpollDispatcher::RunLoop(int timeout)
+{
+    epoll_event events[10];
+
+    int e_num = epoll_wait(m_epollDescriptor,events,10,timeout);
+    if (e_num == -1) {
+        if (errno != EINTR) {
+            wxLogSysError(wxT("Call epoll_wait on epoll descriptor %d failed: %s"), m_epollDescriptor, wxSysErrorMsg(errno));
+            return;
+        } 
+    };
+    for(int n = 0; n < e_num; n++) {
+        wxFDIOHandler* handler = (wxFDIOHandler*)(events[n].data.ptr);
+        if ((events[n].events & EPOLLIN)) {
+            handler->OnExceptionWaiting();
+        };
+        if ((events[n].events & EPOLLIN)) {
+            handler->OnReadWaiting();
+        };
+        if ((events[n].events & EPOLLOUT)) {
+            handler->OnWriteWaiting();
+        };
+    };
+}
+
+#endif // HAVE_SYS_EPOLL_H
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/common/fdiodispatcher.cpp wxWidgets-2.8.0-wxapp/src/common/fdiodispatcher.cpp
--- wxWidgets-2.8.0/src/common/fdiodispatcher.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-wxapp/src/common/fdiodispatcher.cpp	2007-04-20 11:48:29.037070500 +0200
@@ -0,0 +1,41 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        src/common/socketevtdispatch.cpp
+// Purpose:     implements dispatcher for select() call
+// Author:      Lukasz Michalski
+// Created:     December 2006
+// RCS-ID:      $Id: selectdispatcher.cpp,v 1.2 2007/03/19 02:29:49 VZ Exp $
+// Copyright:   (c) 2006 Lukasz Michalski
+// License:     wxWindows licence
+///////////////////////////////////////////////////////////////////////////////
+
+// ============================================================================
+// declarations
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// headers
+// ----------------------------------------------------------------------------
+
+// for compilers that support precompilation, includes "wx.h".
+#include "wx/wxprec.h"
+
+#include "wx/private/selectdispatcher.h"
+#include "wx/unix/private.h"
+#include "wx/log.h"
+
+#ifndef WX_PRECOMP
+    #include "wx/hash.h"
+#endif
+
+#include <sys/time.h>
+#include <unistd.h>
+
+
+// ============================================================================
+// implementation
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// wxSelectDispatcher
+// ----------------------------------------------------------------------------
+
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/common/gsocketiohandler.cpp wxWidgets-2.8.0-wxapp/src/common/gsocketiohandler.cpp
--- wxWidgets-2.8.0/src/common/gsocketiohandler.cpp	2007-03-16 16:45:08.000000000 +0100
+++ wxWidgets-2.8.0-wxapp/src/common/gsocketiohandler.cpp	2007-04-20 14:38:11.549973500 +0200
@@ -42,17 +42,17 @@
 
 };
 
-void wxGSocketIOHandler::OnReadWaiting(int fd)
+void wxGSocketIOHandler::OnReadWaiting()
 {
     m_socket->Detected_Read();
 };
 
-void wxGSocketIOHandler::OnWriteWaiting(int fd) 
+void wxGSocketIOHandler::OnWriteWaiting() 
 {
     m_socket->Detected_Write();
 };
 
-void wxGSocketIOHandler::OnExceptionWaiting(int fd) 
+void wxGSocketIOHandler::OnExceptionWaiting() 
 {
     m_socket->Detected_Read();
 };
@@ -63,12 +63,12 @@
 };
 
 
-void wxGSocketIOHandler::RemoveFlag(wxSelectDispatcherEntryFlags flag)
+void wxGSocketIOHandler::RemoveFlag(wxFDIODispatcherEntryFlags flag)
 {
     m_flags &= ~flag;
 };
 
-void wxGSocketIOHandler::AddFlag(wxSelectDispatcherEntryFlags flag)
+void wxGSocketIOHandler::AddFlag(wxFDIODispatcherEntryFlags flag)
 {
     m_flags |= flag;
 };
@@ -136,12 +136,12 @@
   if (c == 0)
   {
       m_id[0] = socket->m_fd;
-      handler->AddFlag(wxSelectInput);
+      handler->AddFlag(wxFDIO_INPUT);
   }
   else
   {
       m_id[1] = socket->m_fd;
-      handler->AddFlag(wxSelectOutput);
+      handler->AddFlag(wxFDIO_OUTPUT);
   }
 
   wxSelectDispatcher::Get().RegisterFD(socket->m_fd,handler,handler->GetFlags());
@@ -167,15 +167,15 @@
   {
       if ( c == 0 )
       {
-          handler = (wxGSocketIOHandler*)wxSelectDispatcher::Get().UnregisterFD(m_id[c], wxSelectInput);
+          handler = (wxGSocketIOHandler*)wxSelectDispatcher::Get().UnregisterFD(m_id[c], wxFDIO_INPUT);
           if (handler != NULL)
-              handler->RemoveFlag(wxSelectInput);
+              handler->RemoveFlag(wxFDIO_INPUT);
       }
       else
       {
-          handler = (wxGSocketIOHandler*)wxSelectDispatcher::Get().UnregisterFD(m_id[c], wxSelectOutput);
+          handler = (wxGSocketIOHandler*)wxSelectDispatcher::Get().UnregisterFD(m_id[c], wxFDIO_OUTPUT);
           if (handler != NULL)
-              handler->RemoveFlag(wxSelectOutput);
+              handler->RemoveFlag(wxFDIO_OUTPUT);
       }
       if (handler && handler->GetFlags() == 0)
           delete handler;
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/common/selectdispatcher.cpp wxWidgets-2.8.0-wxapp/src/common/selectdispatcher.cpp
--- wxWidgets-2.8.0/src/common/selectdispatcher.cpp	2007-03-19 03:29:49.000000000 +0100
+++ wxWidgets-2.8.0-wxapp/src/common/selectdispatcher.cpp	2007-04-20 13:17:34.686380500 +0200
@@ -1,5 +1,5 @@
 ///////////////////////////////////////////////////////////////////////////////
-// Name:        src/common/socketevtdispatch.cpp
+// Name:        src/common/selectdispatcher.cpp
 // Purpose:     implements dispatcher for select() call
 // Author:      Lukasz Michalski
 // Created:     December 2006
@@ -59,19 +59,19 @@
 void
 wxSelectDispatcher::RegisterFD(int fd, wxFDIOHandler* handler, int flags)
 {
-    if ((flags & wxSelectInput) == wxSelectInput) 
+    if ((flags & wxFDIO_INPUT) == wxFDIO_INPUT) 
     {
         wxFD_SET(fd, &m_readset);
         wxLogTrace(wxSelectDispatcher_Trace,wxT("Registered fd %d for input events"),fd);
     };
 
-    if ((flags & wxSelectOutput) == wxSelectOutput)
+    if ((flags & wxFDIO_OUTPUT) == wxFDIO_OUTPUT)
     {
         wxFD_SET(fd, &m_writeset);
         wxLogTrace(wxSelectDispatcher_Trace,wxT("Registered fd %d for output events"),fd);
     }
 
-    if ((flags & wxSelectException) == wxSelectException)
+    if ((flags & wxFDIO_EXCEPTION) == wxFDIO_EXCEPTION)
     {
         wxFD_SET(fd, &m_exeptset);
         wxLogTrace(wxSelectDispatcher_Trace,wxT("Registered fd %d for exception events"),fd);
@@ -82,6 +82,41 @@
       m_maxFD = fd;
 }
 
+void
+wxSelectDispatcher::ModifyFD(int fd, wxFDIOHandler* handler, int flags)
+{
+    wxASSERT(fd <= m_maxFD);
+    if ((flags & wxFDIO_INPUT) == wxFDIO_INPUT) 
+    {
+        wxFD_SET(fd, &m_readset);
+        wxLogTrace(wxSelectDispatcher_Trace,wxT("Modified fd %d: added input events"),fd);
+    } else {
+        wxFD_CLR(fd, &m_readset);
+        wxLogTrace(wxSelectDispatcher_Trace,wxT("Modified fd %d: removed input events"),fd);
+    };
+
+    if ((flags & wxFDIO_OUTPUT) == wxFDIO_OUTPUT)
+    {
+        wxFD_SET(fd, &m_writeset);
+        wxLogTrace(wxSelectDispatcher_Trace,wxT("Modified fd %d: added output events"),fd);
+    } else {
+        wxFD_CLR(fd, &m_writeset);
+        wxLogTrace(wxSelectDispatcher_Trace,wxT("Modified fd %d: removed output events"),fd);
+    };
+
+    if ((flags & wxFDIO_EXCEPTION) == wxFDIO_EXCEPTION)
+    {
+        wxFD_SET(fd, &m_exeptset);
+        wxLogTrace(wxSelectDispatcher_Trace,wxT("Modified fd %d: added exception events"),fd);
+    } else {
+        wxFD_CLR(fd, &m_exeptset);
+        wxLogTrace(wxSelectDispatcher_Trace,wxT("Modified fd %d: removed exception events"),fd);
+    };
+
+    m_handlers[fd] = handler;
+}
+
+
 wxFDIOHandler*
 wxSelectDispatcher::UnregisterFD(int fd, int flags)
 {
@@ -89,19 +124,19 @@
     if (fd == -1)
       return NULL;
 
-    if ((flags & wxSelectInput) == wxSelectInput)
+    if ((flags & wxFDIO_INPUT) == wxFDIO_INPUT)
     {
         wxLogTrace(wxSelectDispatcher_Trace,wxT("Unregistered fd %d from input events"),fd);
         wxFD_CLR(fd, &m_readset);
     }
 
-    if ((flags & wxSelectOutput) == wxSelectOutput)
+    if ((flags & wxFDIO_OUTPUT) == wxFDIO_OUTPUT)
     {
         wxLogTrace(wxSelectDispatcher_Trace,wxT("Unregistered fd %d from output events"),fd);
         wxFD_CLR(fd, &m_writeset);
     }
 
-    if ((flags & wxSelectException) == wxSelectException)
+    if ((flags & wxFDIO_EXCEPTION) == wxFDIO_EXCEPTION)
     {
         wxLogTrace(wxSelectDispatcher_Trace,wxT("Unregistered fd %d from exeption events"),fd);
         wxFD_CLR(fd, &m_exeptset);
@@ -135,7 +170,7 @@
             wxLogTrace(wxSelectDispatcher_Trace,wxT("Got read event on fd %d"),i);
             handler = FindHandler(i);
             if (handler != NULL && wxFD_ISSET(i,&m_readset))
-                handler->OnReadWaiting(i);
+                handler->OnReadWaiting();
             else
             {
               wxLogError(wxT("Lost fd in read fdset: %d, removing"),i);
@@ -149,7 +184,7 @@
             if (handler == NULL)
                 handler = FindHandler(i);
             if (handler != NULL && wxFD_ISSET(i,&m_writeset))
-                handler->OnWriteWaiting(i);
+                handler->OnWriteWaiting();
             else
             {
               wxLogError(wxT("Lost fd in write fdset: %d, removing"),i);
@@ -163,7 +198,7 @@
             if (handler == NULL)
                 handler = FindHandler(i);
             if (handler != NULL && wxFD_ISSET(i,&m_writeset))
-                handler->OnExceptionWaiting(i);
+                handler->OnExceptionWaiting();
             else
             {
               wxLogError(wxT("Lost fd in exept fdset: %d, removing"),i);
@@ -184,7 +219,7 @@
 void wxSelectDispatcher::RunLoop(int timeout)
 {
     struct timeval tv, *ptv = NULL;
-    if ( timeout != wxSELECT_TIMEOUT_INFINITE )
+    if ( timeout != FDIO_TIMEOUT_INFINITE )
     {
         ptv = &tv;
         tv.tv_sec = 0;
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/msw/appcon.cpp wxWidgets-2.8.0-wxapp/src/msw/appcon.cpp
--- wxWidgets-2.8.0/src/msw/appcon.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-wxapp/src/msw/appcon.cpp	2007-04-20 11:15:28.000000000 +0200
@@ -0,0 +1,124 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        appcon.cpp
+// Purpose:     wxApp for wxBase
+// Author:      Lukasz Michalski
+// Modified by:
+// Created:     04/01/98
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) Lukasz Michalski
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+// ===========================================================================
+// declarations
+// ===========================================================================
+
+// ---------------------------------------------------------------------------
+// headers
+// ---------------------------------------------------------------------------
+
+// For compilers that support precompilation, includes "wx.h".
+#include "wx/wxprec.h"
+#include "wx/msw/appcon.h"
+
+wxEventApp::wxEventApp()
+ : m_exiting(false)
+{
+};
+
+bool
+wxEventApp::Initialize(int& argc, wxChar** argv) 
+{
+  if (!wxAppConsole::Initialize(argc,argv))
+    return false;
+#if wxUSE_THREADS
+  m_MSWThreadID = GetCurrentThreadId();
+#endif
+  wxPendingEventsLocker = new wxCriticalSection();
+  return true;
+};
+
+int
+wxEventApp::OnRun() {
+  return MainLoop();
+};
+
+int 
+wxEventApp::MainLoop()
+{
+  DWORD result;
+  HANDLE* lphObjects = NULL;
+  int cObjects = 0;
+
+  while(!m_exiting) {
+#if wxUSE_EXCEPTIONS
+    try {    
+#endif
+      result = MsgWaitForMultipleObjects(cObjects, lphObjects, FALSE, INFINITE, QS_ALLEVENTS);
+      if (result == (WAIT_OBJECT_0 + cObjects)) {
+        Dispatch();
+      };
+#if wxUSE_EXCEPTIONS
+    } catch (...) {
+      if ( !wxTheApp || !wxTheApp->OnExceptionInMainLoop() )
+        return -1;
+    };
+#endif
+  };
+  return 0;
+};
+
+bool 
+wxEventApp::OnExceptionInMainLoop() {
+  wxLogFatalError(_("An unhandled exception occured"));
+  throw;
+};
+
+void
+wxEventApp::Dispatch() 
+{
+  MSG msg;
+
+  while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
+    if (msg.message == WM_QUIT) {
+      return;
+    } else if (msg.message == WM_TIMER) {
+      TIMERPROC proc = (TIMERPROC)msg.lParam;
+      (*proc)(NULL,0,msg.wParam,0);
+    } else {
+      ::DispatchMessage(&msg);
+    };
+  };
+  ProcessPendingEvents();
+};
+
+void
+wxEventApp::ExitMainLoop()
+{
+  m_exiting = true;
+  WakeUpIdle();
+};
+
+void
+wxEventApp::CleanUp() 
+{
+  delete wxPendingEvents;
+  wxPendingEvents = NULL;
+
+  delete wxPendingEventsLocker;
+  wxPendingEventsLocker = NULL;
+};
+
+void
+wxEventApp::WakeUpIdle()
+{
+  if (!::PostThreadMessage(m_MSWThreadID, WM_NULL, 0, 0) )
+  {
+    // should never happen
+    wxLogLastError(wxT("PostMessage(WM_NULL)"));
+  }
+};
+
+wxEventApp::~wxEventApp() 
+{
+};
diff -ruN -xCVS -x '*.spec' -x'*.orig' -x'.#*' -x'*~' -x'makefile.*' -x'Makefile.*' -x'*.m4' -x'*.dsp' -x'*.kdev*' -x '.*' -xconfigure -x autom4te.cache -x '*.local.bkgen' -x '*.vc' -x '*.dsw' -x Doxyfile wxWidgets-2.8.0/src/unix/app.cpp wxWidgets-2.8.0-wxapp/src/unix/app.cpp
--- wxWidgets-2.8.0/src/unix/app.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wxWidgets-2.8.0-wxapp/src/unix/app.cpp	2007-04-20 14:18:29.984130250 +0200
@@ -0,0 +1,216 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        wx/unix/app.cpp
+// Purpose:     wxAppConsole with wxMainLoop implementation
+// Author:      Lukasz Michalski
+// Modified by:
+// Created:     28/01/2005
+// RCS-ID:      $Id: zork-mainloop-0.19.patch,v 1.1 2006/05/30 09:14:25 zork Exp $
+// Copyright:   (c) Lukasz Michalski
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#include "wx/app.h"
+#include "wx/log.h"
+#include "wx/list.h"
+#include "wx/private/epolldispatcher.h"
+#include "wx/private/selectdispatcher.h"
+#include <signal.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#define wxBaseAppTrace wxT("baseapp")
+
+wxEventApp::PipeIOHandler::PipeIOHandler() 
+{
+};
+
+bool
+wxEventApp::PipeIOHandler::Init()
+{
+    int ret = pipe(m_wakeupPipe);
+    if (ret != 0) {
+        wxLogSysError(wxT("wxApp: cannot craete wakeup pipe. exiting."));
+        return false;
+    };
+    
+    int oldflags = fcntl(m_wakeupPipe[0],F_GETFL,0);
+    if (oldflags == -1) {
+        wxLogSysError(wxT("wxApp: Error reading file status flags on read pipe descriptor %d"),m_wakeupPipe[0]);
+        return false;
+    };
+    
+    oldflags |= O_NONBLOCK;
+    
+    if (fcntl(m_wakeupPipe[0],F_SETFL,oldflags) == -1) {
+        wxLogSysError(wxT("wxApp: Error setting O_NONBLOCK flag on read pipe descriptor %d"),m_wakeupPipe[0]);
+        return false;
+    };
+    wxLogTrace(wxBaseAppTrace,wxT("Creted pipe, read on %d, write on %d"),m_wakeupPipe[0],m_wakeupPipe[1]);
+    return true;
+};
+
+void wxEventApp::PipeIOHandler::OnReadWaiting()
+{
+    //got wakeup from child thread
+    //read all data available in pipe
+    //just to make it empty.
+    char s;
+    int size;
+    do {
+        errno = 0;
+        size = read(m_wakeupPipe[0],&s,4);
+        if (size == 0) {
+            //Unexpected EOF on wakeup pipe
+            break;
+        };
+        if (size < 4) {
+            //bytes read from wakeup pipe
+            break;
+        };
+        if ((size == -1)&&(errno != EAGAIN)) {
+            //"Error reading data from wakeup pipe
+            wxLogSysError(wxT("wxApp: Error reading data from wakeup pipe descriptor %d"),m_wakeupPipe[0]);
+            break;
+        };
+    } while (errno != EAGAIN);
+    //no matter if data was readed or not
+    //someone want to wake main thread
+    //so process pending events now
+    wxTheApp->ProcessPendingEvents();
+};
+
+
+int
+wxEventApp::OnRun() {
+    m_exiting = false;
+    int ret = MainLoop();
+    return ret;
+};
+
+void
+wxEventApp::Dispatch() {
+    wxLogTrace(wxBaseAppTrace,wxT("processing events"));
+    wxTheApp->ProcessPendingEvents();
+    // Calculate the time to the next wxTimer expiry. If no timers expiring
+    // then no select timeout
+    wxUsecClock_t timeout;
+    if (!wxTimerScheduler::Get().GetNext(&timeout)) {
+        timeout = 0;
+    } else {
+        timeout = timeout/100;
+    };
+    //run event fd loop only to the next timer expiration
+    m_FdDispatcher->RunLoop(timeout.GetLo());
+    wxTimerScheduler::Get().NotifyExpired();
+    //check if there are any unix signals pending
+    CheckSignal();
+};
+
+int
+wxEventApp::MainLoop() {
+    wxLogTrace(wxBaseAppTrace,wxT("entering main loop"));
+    while(!m_exiting) {
+        Dispatch();
+    };
+    return EXIT_SUCCESS;
+};
+
+bool 
+wxEventApp::Initialize(int& argc, wxChar** argv) {
+    if (!wxAppConsole::Initialize(argc,argv))
+        return false;
+    wxPendingEventsLocker = new wxCriticalSection();
+
+    if (!m_wakeupPipe.Init())
+        return false;
+
+#ifdef HAVE_SYS_EPOLL_H
+    wxEpollDispatcher* disp = new wxEpollDispatcher();
+    if (!disp->Init()) {
+        wxLogWarning(wxT("Cannot initialize epoll descriptor on this system, falling back to select() based main loop"));
+        delete m_FdDispatcher;
+        m_FdDispatcher = &wxSelectDispatcher::Get();
+        m_usingEpoll = false;
+    } else {
+        m_FdDispatcher = disp;
+        m_usingEpoll = true;
+    };
+#else
+    m_FdDispatcher = &wxSelectDispatcher::Get();
+    m_usingEpoll = false;
+#endif
+
+    m_FdDispatcher->RegisterFD(m_wakeupPipe.getReadFd(), &m_wakeupPipe, wxFDIO_INPUT);
+
+    sigemptyset(&m_signalCatched);
+
+    return true;
+};
+
+
+void
+wxEventApp::ExitMainLoop() {
+    wxLogTrace(wxBaseAppTrace,wxT("baseapp: exiting..."));
+    m_exiting = true;
+    WakeUpIdle();
+};
+
+void 
+wxEventApp::CleanUp() {
+    if (m_usingEpoll)
+        delete m_FdDispatcher;
+
+    delete wxPendingEvents;
+    wxPendingEvents = NULL;
+    
+    delete wxPendingEventsLocker;
+    wxPendingEventsLocker = NULL;
+};
+
+void
+wxEventApp::WakeUpIdle() {
+    m_wakeupPipe.WakeUp();
+};
+
+void
+wxEventApp::HandleSignal(int signal) {
+    sigaddset(&(wxTheApp->m_signalCatched), signal);
+    wxTheApp->WakeUpIdle();
+}
+
+void
+wxEventApp::CheckSignal() {
+    SignalHandlerHash::iterator it;
+    for( it = m_signalHandlerHash.begin(); it != m_signalHandlerHash.end(); ++it )
+    {
+        int sig = it->first;
+        if (sigismember(&m_signalCatched, sig))
+        {
+        // FIXME There is a race hash between testing signal and clearing
+        // signal but it should not really matter
+        sigdelset(&m_signalCatched, sig);
+        SignalHandler h = it->second;
+        if (h != 0)
+            h(sig);
+        }
+    }
+}
+
+void
+wxEventApp::SetSignalHandler(int signal, SignalHandler handler)
+{
+    struct sigaction sa;
+    memset(&sa, 0, sizeof(sa));
+    sa.sa_handler = HandleSignal;
+    sa.sa_flags = SA_RESTART;
+    int res = sigaction(signal, &sa, 0);
+    if (res < 0)
+        wxLogFatalError(wxT("wxEventApp: cannot install signal handler"));
+    
+    if (handler == SIG_DFL || handler == SIG_IGN)
+        m_signalHandlerHash[signal] = 0;
+    else
+        m_signalHandlerHash[signal] = handler;
+}

 	  	 
