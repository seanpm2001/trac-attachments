diff --git a/configure.in b/configure.in
index b1c305a..8dde1bf 100755
--- a/configure.in
+++ b/configure.in
@@ -7167,7 +7167,7 @@ USE_AUI=0
 if test "$wxUSE_AUI" = "yes"; then
    AC_DEFINE(wxUSE_AUI)
    USE_AUI=1
-   SAMPLES_SUBDIRS="$SAMPLES_SUBDIRS aui"
+   SAMPLES_SUBDIRS="$SAMPLES_SUBDIRS aui auinew"
 fi
 
 USE_PROPGRID=0
diff --git a/include/wx/aui/auibook.h b/include/wx/aui/auibook.h
index fa04c51..18e9ef2 100755
--- a/include/wx/aui/auibook.h
+++ b/include/wx/aui/auibook.h
@@ -6,7 +6,7 @@
 // Modified by: Jens Lody
 // Created:     2006-06-28
 // Copyright:   (C) Copyright 2006, Kirix Corporation, All Rights Reserved.
-//                            2012, Jens Lody for the code related to left
+//                            2012, Jens Lody for the code related to left 
 //                                  and right positioning
 // Licence:     wxWindows Library Licence, Version 3.1
 ///////////////////////////////////////////////////////////////////////////////
@@ -73,7 +73,7 @@ public:
         m_dragSource = c.m_dragSource;
     }
 #endif
-    wxEvent *Clone() const { return new wxAuiNotebookEvent(*this); }
+    wxEvent* Clone() const { return new wxAuiNotebookEvent(*this); }
 
     void SetDragSource(wxAuiNotebook* s) { m_dragSource = s; }
     wxAuiNotebook* GetDragSource() const { return m_dragSource; }
@@ -96,7 +96,7 @@ public:
     void SetActiveColour(const wxColour& colour);
 
 
-    wxAuiNotebook() { }
+    wxAuiNotebook() { };
     wxAuiNotebook(wxWindow* parent,
                   wxWindowID id = wxID_ANY,
                   const wxPoint& pos = wxDefaultPosition,
@@ -171,14 +171,14 @@ public:
     // Gets the tab control height
     int GetTabCtrlHeight() const;
 
-    // Gets the tab control width
-    int GetTabCtrlWidth() const;
+    // Gets the tab control width 
+    int GetTabCtrlWidth() const; 
 
     // Gets the height of the notebook for a given page height
     int GetHeightForPageHeight(int pageHeight);
 
-    // Gets the width of the notebook for a given page width
-    int GetWidthForPageWidth(int pageWidth);
+    // Gets the width of the notebook for a given page width 
+    int GetWidthForPageWidth(int pageWidth); 
 
     // Advances the selection, generation page selection events
     void AdvanceSelection(bool forward = true);
@@ -200,7 +200,7 @@ public:
     virtual int GetPageImage(size_t n) const;
     virtual bool SetPageImage(size_t n, int imageId);
 
-    wxWindow* GetCurrentPage() const;
+    wxWindow* GetCurrentPage () const;
 
     virtual int ChangeSelection(size_t n);
 
@@ -208,10 +208,10 @@ public:
     virtual bool DeleteAllPages();
     virtual bool InsertPage(size_t index, wxWindow* page, const wxString& text, bool select, int imageId);
 
-    // Returns true if the tabart has the given flag bit set
-    bool HasFlag(int flag) const    { return m_mgr.HasFlag(flag); }
-    // returns true if we have wxAUI_NB_TOP or wxAUI_NB_BOTTOM style
-    bool IsHorizontal() const { return HasFlag(wxAUI_NB_TOP | wxAUI_NB_BOTTOM); }
+    // Returns true if the tabart has the given flag bit set 
+    bool HasFlag(int flag) const    { return m_mgr.HasFlag(flag); } 
+    // returns true if we have wxAUI_NB_TOP or wxAUI_NB_BOTTOM style 
+    bool IsHorizontal() const { return HasFlag(wxAUI_NB_TOP | wxAUI_NB_BOTTOM); } 
 
 protected:
     // choose the default border for this window
diff --git a/include/wx/aui/dockart.h b/include/wx/aui/dockart.h
index c414825..0dbc006 100755
--- a/include/wx/aui/dockart.h
+++ b/include/wx/aui/dockart.h
@@ -99,33 +99,33 @@ public:
     wxFont GetFont(int id);
 
     void DrawSash(wxDC& dc,
-                  wxWindow *window,
+                  wxWindow* window,
                   int orientation,
                   const wxRect& rect);
 
     void DrawBackground(wxDC& dc,
-                  wxWindow *window,
+                  wxWindow* window,
                   int orientation,
                   const wxRect& rect);
 
     void DrawCaption(wxDC& dc,
-                  wxWindow *window,
+                  wxWindow* window,
                   const wxString& text,
                   const wxRect& rect,
                   wxAuiPaneInfo& pane);
 
     void DrawGripper(wxDC& dc,
-                  wxWindow *window,
+                  wxWindow* window,
                   const wxRect& rect,
                   wxAuiPaneInfo& pane);
 
     void DrawBorder(wxDC& dc,
-                  wxWindow *window,
+                  wxWindow* window,
                   const wxRect& rect,
                   wxAuiPaneInfo& pane);
 
     void DrawPaneButton(wxDC& dc,
-                  wxWindow *window,
+                  wxWindow* window,
                   int button,
                   int buttonState,
                   const wxRect& rect,
@@ -208,7 +208,7 @@ public:
     void SetFlags(unsigned int flags);
     unsigned int GetFlags() const;
     bool HasFlag(int flag) const;
-
+    
     // returns true if we have wxAUI_NB_TOP or wxAUI_NB_BOTTOM style
     bool IsHorizontal() const;
 
@@ -255,7 +255,7 @@ public:
 protected:
 
     virtual void Render(wxDC* dc, wxWindow* wnd);
-
+  
 
     void OnChildKeyDown(wxKeyEvent& evt);
 
diff --git a/include/wx/aui/framemanager.h b/include/wx/aui/framemanager.h
index 17adb1e..966f23f 100755
--- a/include/wx/aui/framemanager.h
+++ b/include/wx/aui/framemanager.h
@@ -54,7 +54,7 @@ enum wxAuiManagerOption
     wxAUI_MGR_NB_LEFT                  = 1 << 11,
     wxAUI_MGR_NB_RIGHT                 = 1 << 12,
     wxAUI_MGR_NB_BOTTOM                = 1 << 13,
-    wxAUI_MGR_NB_TAB_MOVE              = 1 << 14,
+    wxAUI_MGR_NB_TAB_MOVE              = 1 << 14,  
     wxAUI_MGR_ALLOW_EXTERNAL_MOVE      = 1 << 15,
     wxAUI_MGR_NB_TAB_FIXED_WIDTH       = 1 << 16,
     wxAUI_MGR_NB_SCROLL_BUTTONS        = 1 << 17,
@@ -230,7 +230,7 @@ public:
         m_state = 0;
         return SetDirectionCenter().SetBorder().SetResizable();
     );
-    wxDEPRECATED_INLINE( wxAuiPaneInfo& DefaultPane() ,
+    wxDEPRECATED_INLINE( wxAuiPaneInfo& DefaultPane() , 
         wxAuiPaneInfo test(*this);
         test.m_state |= optionTopDockable | optionBottomDockable | optionLeftDockable | optionRightDockable | optionFloatable | optionMovable | optionResizable | optionCaption | optionPaneBorder | buttonClose;
         wxCHECK_MSG(test.IsValid(), *this, "window settings and pane settings are incompatible");
@@ -266,7 +266,7 @@ public:
       wxCHECK_MSG(test.IsValid(), *this,
                   "window settings and pane settings are incompatible");
       this->m_window = w;
-      return *this;
+      return *this; 
     }
 
     // get/set the floating frame window that holds the pane
@@ -318,7 +318,7 @@ public:
         return HasFlag(optionTopDockable | optionBottomDockable |
                         optionLeftDockable | optionRightDockable);
     }
-
+    
 
     // get/set if pane can be undocked and displayed as a floating window.
     bool IsFloatable() const { return HasFlag(optionFloatable); }
@@ -375,12 +375,12 @@ public:
     // get/set the caption of the pane.
     wxString GetCaption() const { return m_caption; }
     wxAuiPaneInfo& SetCaption(const wxString& c) { m_caption = c; return *this; }
-
+    
     // get/set the tooltip of the pane.
     wxString GetToolTip() const { return m_tooltip; }
     wxAuiPaneInfo& SetToolTip(const wxString& t) { m_tooltip = t; return *this; }
-
-
+    
+    
     // get/set the icon of the pane.
     const wxBitmap* GetIcon() const { return &m_icon; }
     wxAuiPaneInfo& SetIcon(const wxBitmap& b) { m_icon = b; return *this; }
@@ -728,7 +728,7 @@ protected:
     void LayoutAddNotebook(wxAuiTabArt* tabArt, wxAuiTabContainer* notebookContainer, wxSizer* notebookSizer, wxAuiDockUIPart& part, wxAuiDockInfo& dock, wxAuiDockUIPartArray& uiparts, wxAuiTabContainerPointerArray& tabContainerRecalcList, wxAuiSizerItemPointerArray& tabContainerRecalcSizers, wxAuiPaneInfo* pane, int orient);
     wxSizer* LayoutAll(wxAuiPaneInfoArray& panes, wxAuiDockInfoArray& docks, wxAuiDockUIPartArray& uiParts, bool spacerOnly = false);
 
-    //Functions for handling pane drag and drop.
+    //Functions for handling pane drag and drop. 
     bool DoDrop(wxAuiDockInfoArray& docks, wxAuiPaneInfoArray& panes, wxAuiPaneInfo& drop, const wxPoint& pt, const wxPoint& actionOffset = wxPoint(0,0));
     bool DoDropExternal(wxAuiPaneInfo& drop, const wxPoint& pt, const wxPoint& actionOffset = wxPoint(0,0));
     virtual bool ProcessDockResult(wxAuiPaneInfo& target, const wxAuiPaneInfo& newPos);
@@ -741,12 +741,12 @@ protected:
     void ShowToolTip(wxAuiPaneInfo* pane);
     void HideToolTip();
 
-    void UpdateHintWindowConfig();
+    void UpdateHintWindowConfig();    
 
     wxAuiDockUIPart* HitTest(int x, int y);
     wxAuiDockUIPart* GetPanePart(wxWindow* pane);
     int GetDockPixelOffset(wxAuiPaneInfo& test);
-
+    
     void ProcessMgrEvent(wxAuiManagerEvent& event);
     void UpdateButtonOnScreen(wxAuiDockUIPart* buttonUiPart, const wxMouseEvent& event);
     void GetPanePositionsAndSizes(wxAuiDockInfo& dock, wxArrayInt& positions, wxArrayInt& sizes);
@@ -804,7 +804,7 @@ protected:
 
     wxWindow* m_frame;               // the window being managed
     wxAuiDockArt* m_art;             // dock art object which does all drawing
-    wxAuiTabArt* m_tab_art;          // tab art object which does all teh drawing for notebooks.
+    wxAuiTabArt* m_tab_art;          // tab art object which does all the drawing for notebooks.
     unsigned int m_flags;            // manager flags wxAUI_MGR_*
 
     wxAuiPaneInfoArray m_panes;      // array of panes structures
@@ -826,6 +826,7 @@ protected:
     int  m_currentDragItem;
     bool m_skipping;
     bool m_hasMaximized;
+    bool m_doingHintCalculation;     // set to true if we are in the process of calculating a hint.
 
     double m_dockConstraintX;        // 0.0 .. 1.0; max pct of window width a dock can consume
     double m_dockConstraintY;        // 0.0 .. 1.0; max pct of window height a dock can consume
@@ -871,7 +872,7 @@ public:
         dc = c.dc;
     }
 #endif
-    wxEvent *Clone() const { return new wxAuiManagerEvent(*this); }
+    wxEvent* Clone() const { return new wxAuiManagerEvent(*this); }
 
     void SetManager(wxAuiManager* mgr) { manager = mgr; }
     void SetPane(wxAuiPaneInfo* p) { pane = p; }
@@ -971,7 +972,7 @@ public:
     bool fixed;               // flag indicating that the dock operates on
                               // absolute coordinates as opposed to proportional
     bool reserved1;
-
+    
     bool IsValid() const;
 };
 
diff --git a/include/wx/aui/tabart.h b/include/wx/aui/tabart.h
index bbcc971..b8f445f 100755
--- a/include/wx/aui/tabart.h
+++ b/include/wx/aui/tabart.h
@@ -7,8 +7,8 @@
 // Created:     2012-03-21
 // RCS-ID:      $Id:$
 // Copyright:   (C) Copyright 2006, Kirix Corporation, All Rights Reserved.
-//                            2012, Jens Lody for the code related to left
-//                                  and right positioning
+//                            2012, Jens Lody for the code related to left 
+//                                  and right positioning 
 // Licence:     wxWindows Library Licence, Version 3.1
 ///////////////////////////////////////////////////////////////////////////////
 
@@ -100,9 +100,9 @@ public:
 
     virtual int GetIndentSize() = 0;
 
-    virtual wxSize GetBestTabSize(
-                         wxWindow* wnd,
-                         const wxAuiPaneInfoPtrArray& pages,
+    virtual wxSize GetBestTabSize( 
+                         wxWindow* wnd, 
+                         const wxAuiPaneInfoPtrArray& pages, 
                          const wxSize& requiredBmpSize) = 0;
 
     virtual int GetBestTabCtrlSize(
@@ -180,17 +180,17 @@ public:
                  const wxAuiPaneInfoPtrArray& pages,
                  const wxSize& requiredBmpSize);
 
-    int GetBestTabCtrlSize(wxWindow* wnd,
-                 const wxAuiPaneInfoPtrArray& pages,
-                 const wxSize& requiredBmpSize)
-                 {
-                     return GetBestTabSize(wnd, pages, requiredBmpSize).GetHeight();
-                 }
-
-    // Returns true if the tabart has the given flag bit set
-    bool HasFlag(int flag) const    { return (m_flags & flag) != 0; }
-    // returns true if we have wxAUI_NB_TOP or wxAUI_NB_BOTTOM style
-    bool IsHorizontal() const { return HasFlag(wxAUI_NB_TOP | wxAUI_NB_BOTTOM); }
+    int GetBestTabCtrlSize(wxWindow* wnd, 
+                 const wxAuiPaneInfoPtrArray& pages, 
+                 const wxSize& requiredBmpSize) 
+                 { 
+                     return GetBestTabSize(wnd, pages, requiredBmpSize).GetHeight(); 
+                 } 
+ 
+    // Returns true if the tabart has the given flag bit set 
+    bool HasFlag(int flag) const    { return (m_flags & flag) != 0; } 
+    // returns true if we have wxAUI_NB_TOP or wxAUI_NB_BOTTOM style 
+    bool IsHorizontal() const { return HasFlag(wxAUI_NB_TOP | wxAUI_NB_BOTTOM); } 
 
 protected:
 
@@ -206,9 +206,9 @@ protected:
     wxBitmap m_disabledCloseBmp;
     wxBitmap m_activeLeftBmp;
     wxBitmap m_disabledLeftBmp;
-    wxBitmap m_activeUpBmp;
-    wxBitmap m_disabledUpBmp;
-    wxBitmap m_activeDownBmp;
+    wxBitmap m_activeUpBmp; 
+    wxBitmap m_disabledUpBmp; 
+    wxBitmap m_activeDownBmp; 
     wxBitmap m_disabledDownBmp;
     wxBitmap m_activeRightBmp;
     wxBitmap m_disabledRightBmp;
@@ -281,17 +281,17 @@ public:
                  const wxAuiPaneInfoPtrArray& pages,
                  const wxSize& requiredBmpSize);
 
-    int GetBestTabCtrlSize(wxWindow* wnd,
-                 const wxAuiPaneInfoPtrArray& pages,
-                 const wxSize& requiredBmpSize)
-                 {
-                     return GetBestTabSize(wnd, pages, requiredBmpSize).GetHeight();
-                 }
-
-    // Returns true if the tabart has the given flag bit set
-    bool HasFlag(int flag) const    { return (m_flags & flag) != 0; }
-    // returns true if we have wxAUI_NB_TOP or wxAUI_NB_BOTTOM style
-    bool IsHorizontal() const { return HasFlag(wxAUI_NB_TOP | wxAUI_NB_BOTTOM); }
+    int GetBestTabCtrlSize(wxWindow* wnd, 
+                 const wxAuiPaneInfoPtrArray& pages, 
+                 const wxSize& requiredBmpSize) 
+                 { 
+                     return GetBestTabSize(wnd, pages, requiredBmpSize).GetHeight(); 
+                 } 
+ 
+    // Returns true if the tabart has the given flag bit set 
+    bool HasFlag(int flag) const    { return (m_flags & flag) != 0; } 
+    // returns true if we have wxAUI_NB_TOP or wxAUI_NB_BOTTOM style 
+    bool IsHorizontal() const { return HasFlag(wxAUI_NB_TOP | wxAUI_NB_BOTTOM); } 
 
 protected:
 
@@ -307,9 +307,9 @@ protected:
     wxBitmap m_disabledCloseBmp;
     wxBitmap m_activeLeftBmp;
     wxBitmap m_disabledLeftBmp;
-    wxBitmap m_activeUpBmp;
-    wxBitmap m_disabledUpBmp;
-    wxBitmap m_activeDownBmp;
+    wxBitmap m_activeUpBmp; 
+    wxBitmap m_disabledUpBmp; 
+    wxBitmap m_activeDownBmp; 
     wxBitmap m_disabledDownBmp;
     wxBitmap m_activeRightBmp;
     wxBitmap m_disabledRightBmp;
@@ -318,7 +318,7 @@ protected:
 };
 
 #ifndef __WXUNIVERSAL__
-    #if defined(__WXGTK20__) && !defined(__WXGTK3__)
+    #if defined(__WXGTK20__) && !defined(__WXGTK3__) 
         #define wxHAS_NATIVE_TABART
         #include "wx/aui/tabartgtk.h"
         #define wxAuiDefaultTabArt wxAuiGtkTabArt
diff --git a/include/wx/aui/tabartgtk.h b/include/wx/aui/tabartgtk.h
index 58fbcef..49c05dc 100755
--- a/include/wx/aui/tabartgtk.h
+++ b/include/wx/aui/tabartgtk.h
@@ -8,8 +8,8 @@
 // RCS-ID:      $Id:$
 // Copyright:   (c) 2012 Jens Lody <jens@codeblocks.org>
 //                  and Teodor Petrov
-//              2012, Jens Lody for the code related to left and right
-//                  positioning
+//              2012, Jens Lody for the code related to left and right 
+//                  positioning 
 // Licence:     wxWindows licence
 /////////////////////////////////////////////////////////////////////////////
 
@@ -26,7 +26,7 @@
 
 #include "wx/aui/tabart.h"
 #include "wx/gdicmn.h"
-#include "wx/aui/auibook.h"
+#include "wx/aui/auibook.h" 
 
 class wxWindow;
 class wxDC;
@@ -49,13 +49,13 @@ public:
                          int* xExtent);
     void DrawButton(wxDC& dc, wxWindow* wnd, const wxRect& inRect, int bitmapID, int buttonState, int orientation, wxRect* outRect);
     wxSize GetBestTabSize(wxWindow* wnd, const wxAuiPaneInfoPtrArray& pages, const wxSize& requiredBmpSize);
-    int GetBestTabCtrlSize(wxWindow* wnd, const wxAuiPaneInfoPtrArray& pages, const wxSize& requiredBmpSize)
-                         {
-                             return GetBestTabSize(wnd, pages, requiredBmpSize).GetHeight();
-                         }
-    virtual wxSize GetTabSize(wxDC& dc, wxWindow* wnd, const wxString& caption,
-                              const wxBitmap& bitmap, bool active,
-                              int closeButtonState, int* extent);
+    int GetBestTabCtrlSize(wxWindow* wnd, const wxAuiPaneInfoPtrArray& pages, const wxSize& requiredBmpSize) 
+                         { 
+                             return GetBestTabSize(wnd, pages, requiredBmpSize).GetHeight(); 
+                         } 
+    virtual wxSize GetTabSize(wxDC& dc, wxWindow* wnd, const wxString& caption, 
+                              const wxBitmap& bitmap, bool active, 
+                              int closeButtonState, int* extent); 
 };
 
 #endif  // wxUSE_AUI
diff --git a/interface/wx/aui/framemanager.h b/interface/wx/aui/framemanager.h
index 5bc78e3..f9e01fe 100755
--- a/interface/wx/aui/framemanager.h
+++ b/interface/wx/aui/framemanager.h
@@ -123,7 +123,7 @@ enum wxAuiManagerOption
     @li Page: More then one pane can be docked in the exact same Direction,
         Position, Row and Layer. When this happens a tabbed notebook will be formed.
         Tab position will be decided based on the Page values of the panes with
-        those that have a lower value appearing on the left, with 0 being the
+        those that have a lower value appearing on the left, with 0 being the 
         absolute left.
 
     @beginStyleTable
@@ -171,7 +171,7 @@ enum wxAuiManagerOption
         custom draw your wxAuiManager window (not recommended).
     @endEventTable
 
-    @library{wxaui}
+    @library{wxbase}
     @category{aui}
 
     @see @ref overview_aui, wxAuiNotebook, wxAuiDockArt, wxAuiPaneInfo
@@ -889,7 +889,7 @@ public:
     int GetDirection() const;
     /**
         SetDirection() determines the direction of the docked pane. It is functionally the
-        same as calling SetDirectionLeft(), SetDirectionRight(), SetDirectionTop() or SetDirectionBottom(),
+        same as calling SetDirectionLeft(), SetDirectionRight(), SetDirectionTop() or SetDirectionBottom(), 
         except that docking direction may be specified programmatically via the parameter.
     */
     wxAuiPaneInfo& SetDirection(int direction);
diff --git a/samples/aui/auidemo.cpp b/samples/aui/auidemo.cpp
index b634bb8..27f8122 100755
--- a/samples/aui/auidemo.cpp
+++ b/samples/aui/auidemo.cpp
@@ -310,7 +310,9 @@ public:
         //vert->Add(1, 1, 1, wxEXPAND);
 
         wxBoxSizer* s1 = new wxBoxSizer(wxHORIZONTAL);
-        m_border_size = new wxSpinCtrl(this, ID_PaneBorderSize, wxString::Format(wxT("%d"), frame->GetDockArt()->GetMetric(wxAUI_DOCKART_PANE_BORDER_SIZE)), wxDefaultPosition, wxSize(50,20), wxSP_ARROW_KEYS, 0, 100, frame->GetDockArt()->GetMetric(wxAUI_DOCKART_PANE_BORDER_SIZE));
+        m_border_size = new wxSpinCtrl(this, ID_PaneBorderSize, wxString::Format(wxT("%d"), 
+frame->GetDockArt()->GetMetric(wxAUI_DOCKART_PANE_BORDER_SIZE)), wxDefaultPosition, wxSize(50,20), wxSP_ARROW_KEYS, 0, 100, 
+frame->GetDockArt()->GetMetric(wxAUI_DOCKART_PANE_BORDER_SIZE));
         s1->Add(1, 1, 1, wxEXPAND);
         s1->Add(new wxStaticText(this, wxID_ANY, wxT("Pane Border Size:")));
         s1->Add(m_border_size);
@@ -319,7 +321,8 @@ public:
         //vert->Add(s1, 0, wxEXPAND | wxLEFT | wxBOTTOM, 5);
 
         wxBoxSizer* s2 = new wxBoxSizer(wxHORIZONTAL);
-        m_sash_size = new wxSpinCtrl(this, ID_SashSize, wxString::Format(wxT("%d"), frame->GetDockArt()->GetMetric(wxAUI_DOCKART_SASH_SIZE)), wxDefaultPosition, wxSize(50,20), wxSP_ARROW_KEYS, 0, 100, frame->GetDockArt()->GetMetric(wxAUI_DOCKART_SASH_SIZE));
+        m_sash_size = new wxSpinCtrl(this, ID_SashSize, wxString::Format(wxT("%d"), frame->GetDockArt()->GetMetric(wxAUI_DOCKART_SASH_SIZE)), 
+wxDefaultPosition, wxSize(50,20), wxSP_ARROW_KEYS, 0, 100, frame->GetDockArt()->GetMetric(wxAUI_DOCKART_SASH_SIZE));
         s2->Add(1, 1, 1, wxEXPAND);
         s2->Add(new wxStaticText(this, wxID_ANY, wxT("Sash Size:")));
         s2->Add(m_sash_size);
@@ -328,7 +331,9 @@ public:
         //vert->Add(s2, 0, wxEXPAND | wxLEFT | wxBOTTOM, 5);
 
         wxBoxSizer* s3 = new wxBoxSizer(wxHORIZONTAL);
-        m_caption_size = new wxSpinCtrl(this, ID_CaptionSize, wxString::Format(wxT("%d"), frame->GetDockArt()->GetMetric(wxAUI_DOCKART_CAPTION_SIZE)), wxDefaultPosition, wxSize(50,20), wxSP_ARROW_KEYS, 0, 100, frame->GetDockArt()->GetMetric(wxAUI_DOCKART_CAPTION_SIZE));
+        m_caption_size = new wxSpinCtrl(this, ID_CaptionSize, wxString::Format(wxT("%d"), 
+frame->GetDockArt()->GetMetric(wxAUI_DOCKART_CAPTION_SIZE)), wxDefaultPosition, wxSize(50,20), wxSP_ARROW_KEYS, 0, 100, 
+frame->GetDockArt()->GetMetric(wxAUI_DOCKART_CAPTION_SIZE));
         s3->Add(1, 1, 1, wxEXPAND);
         s3->Add(new wxStaticText(this, wxID_ANY, wxT("Caption Size:")));
         s3->Add(m_caption_size);
@@ -578,7 +583,6 @@ BEGIN_EVENT_TABLE(SettingsPanel, wxPanel)
     EVT_BUTTON(ID_GripperColor, SettingsPanel::OnSetColor)
 END_EVENT_TABLE()
 
-
 bool MyApp::OnInit()
 {
     if ( !wxApp::OnInit() )
@@ -749,7 +753,7 @@ MyFrame::MyFrame(wxWindow* parent,
     notebook_menu->AppendRadioItem(ID_NotebookArtDefault, _("Default Theme"));
     notebook_menu->AppendRadioItem(ID_NotebookArtSimple, _("Simple Theme"));
 #ifdef wxHAS_NATIVE_TABART
-    notebook_menu->AppendRadioItem(ID_NotebookArtGeneric, _("Generic Theme"));
+    notebook_menu->AppendRadioItem(ID_NotebookArtGeneric, _("GenericTheme"));
 #endif
     notebook_menu->AppendSeparator();
     notebook_menu->AppendRadioItem(ID_NotebookNoCloseButton, _("No Close Button"));
@@ -769,10 +773,10 @@ MyFrame::MyFrame(wxWindow* parent,
     notebook_menu->AppendCheckItem(ID_NotebookWindowList, _("Window List Button Visible"));
     notebook_menu->AppendCheckItem(ID_NotebookTabFixedWidth, _("Fixed-width Tabs"));
     notebook_menu->AppendSeparator();
-    notebook_menu->Append(ID_NotebookSplitLeft, _("Move Active Tab to Left"));
-    notebook_menu->Append(ID_NotebookSplitRight, _("Move Active Tab to Right"));
-    notebook_menu->Append(ID_NotebookSplitTop, _("Move Active Tab to Top"));
-    notebook_menu->Append(ID_NotebookSplitBottom, _("Move Active Tab to Bottom"));
+    notebook_menu->Append         (ID_NotebookSplitLeft, _("Move Active Tab to Left"));
+    notebook_menu->Append         (ID_NotebookSplitRight, _("Move Active Tab to Right"));
+    notebook_menu->Append         (ID_NotebookSplitTop, _("Move Active Tab to Top"));
+    notebook_menu->Append         (ID_NotebookSplitBottom, _("Move Active Tab to Bottom"));
 
     m_perspectives_menu = new wxMenu;
     m_perspectives_menu->Append(ID_CreatePerspective, _("Create Perspective"));
@@ -1238,7 +1242,7 @@ void MyFrame::OnNotebookFlag(wxCommandEvent& event)
                 m_notebook_theme = 1;
             }
 #ifdef wxHAS_NATIVE_TABART
-            else if (id == ID_NotebookArtGeneric)
+             else if (id == ID_NotebookArtGeneric)
             {
                 nb->SetArtProvider(new wxAuiGenericTabArt);
                 m_notebook_theme = 1;
@@ -1590,9 +1594,9 @@ void MyFrame::OnTabAlignment(wxCommandEvent &evt)
 
 void MyFrame::OnTabSplit(wxCommandEvent &evt)
 {
+    size_t i, count;
     wxAuiPaneInfoArray& all_panes = m_mgr.GetAllPanes();
-    const size_t count = all_panes.GetCount();
-    for (size_t i = 0; i < count; ++i)
+    for (i = 0, count = all_panes.GetCount(); i < count; ++i)
     {
         wxAuiPaneInfo& pane = all_panes.Item(i);
         if (pane.window->IsKindOf(CLASSINFO(wxAuiNotebook)))
@@ -1834,3 +1838,4 @@ wxString MyFrame::GetIntroText()
 
     return wxString::FromAscii(text);
 }
+
diff --git a/samples/auinew/auidemo.bkl b/samples/auinew/auidemo.bkl
new file mode 100644
index 0000000..eef8bf9
--- /dev/null
+++ b/samples/auinew/auidemo.bkl
@@ -0,0 +1,17 @@
+<?xml version="1.0" ?>
+<makefile>
+
+    <include file="../../build/bakefiles/common_samples.bkl"/>
+
+    <exe id="auinewdemo" template="wx_sample" template_append="wx_append">
+        <sources>
+            auidemo.cpp
+        </sources>
+        <wx-lib>aui</wx-lib>
+        <wx-lib>html</wx-lib>
+        <wx-lib>adv</wx-lib>
+        <wx-lib>core</wx-lib>
+        <wx-lib>xml</wx-lib>
+        <wx-lib>base</wx-lib>
+    </exe>
+</makefile>
diff --git a/samples/auinew/auidemo.cpp b/samples/auinew/auidemo.cpp
new file mode 100644
index 0000000..ce95179
--- /dev/null
+++ b/samples/auinew/auidemo.cpp
@@ -0,0 +1,1246 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        auidemo.cpp
+// Purpose:     wxaui: wx advanced user interface - sample/test program
+// Author:      Benjamin I. Williams
+// Modified by: Malcolm MacLeod
+// Created:     2005-10-03
+// RCS-ID:      $Id: auidemo.cpp 59860 2009-03-26 08:34:27Z BIW $
+// Copyright:   (C) Copyright 2005, Kirix Corporation, All Rights Reserved.
+// Licence:     wxWindows Library Licence, Version 3.1
+///////////////////////////////////////////////////////////////////////////////
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#include "wx/app.h"
+#include "wx/grid.h"
+#include "wx/treectrl.h"
+#include "wx/spinctrl.h"
+#include "wx/artprov.h"
+#include "wx/clipbrd.h"
+#include "wx/image.h"
+#include "wx/colordlg.h"
+#include "wx/wxhtml.h"
+#include "wx/imaglist.h"
+#include "wx/dataobj.h"
+#include "wx/dcclient.h"
+#include "wx/bmpbuttn.h"
+#include "wx/menu.h"
+#include "wx/toolbar.h"
+#include "wx/statusbr.h"
+#include "wx/msgdlg.h"
+#include "wx/textdlg.h"
+
+#include "wx/aui/aui.h"
+#include "../sample.xpm"
+
+// -- application --
+
+class MyApp : public wxApp
+{
+public:
+    bool OnInit();
+};
+
+DECLARE_APP(MyApp)
+IMPLEMENT_APP(MyApp)
+
+
+class wxSizeReportCtrl;
+
+// -- frame --
+
+class MyFrame : public wxFrame
+{
+    enum
+    {
+        ID_CreateTree = wxID_HIGHEST+1,
+        ID_CreateGrid,
+        ID_CreateText,
+        ID_CreateHTML,
+        ID_CreateSizeReport,
+        ID_GridContent,
+        ID_TextContent,
+        ID_TreeContent,
+        ID_HTMLContent,
+        ID_SizeReportContent,
+        ID_CreatePerspective,
+        ID_CopyPerspectiveCode,
+        ID_AllowFloating,
+        ID_AllowActivePane,
+        ID_TabsDefault,
+        ID_TabsGeneric,
+        ID_TabsSimple,
+        #ifdef wxHAS_NATIVE_TABART
+        ID_TabsNative,
+        #endif
+        ID_TabsTop,
+        ID_TabsLeft,
+        ID_TabsRight,
+        ID_TabsBottom,
+        ID_TabWindowList,
+        ID_FixedWidth,
+        ID_CloseButton,
+        ID_CloseButtonActiveTab,
+        ID_CloseButtonAllTabs,
+        ID_NoCloseButton,
+        ID_TransparentHint,
+        ID_VenetianBlindsHint,
+        ID_RectangleHint,
+        ID_NoHint,
+        ID_HintFade,
+        ID_NoVenetianFade,
+        ID_TransparentDrag,
+        ID_NoGradient,
+        ID_VerticalGradient,
+        ID_HorizontalGradient,
+        ID_LiveUpdate,
+        ID_Settings,
+        ID_CustomizeToolbar,
+        ID_DropDownToolbarItem,
+        ID_SampleItem,
+        ID_FirstPerspective = ID_CreatePerspective+1000
+    };
+
+public:
+    MyFrame(wxWindow* parent,
+            wxWindowID id,
+            const wxString& title,
+            const wxPoint& pos = wxDefaultPosition,
+            const wxSize& size = wxDefaultSize,
+            long style = wxDEFAULT_FRAME_STYLE | wxSUNKEN_BORDER);
+
+    ~MyFrame();
+
+    wxAuiDockArt* GetDockArt();
+    void DoUpdate();
+
+private:
+    wxTextCtrl* CreateTextCtrl(const wxString& text = wxEmptyString);
+    wxGrid* CreateGrid();
+    wxTreeCtrl* CreateTreeCtrl();
+    wxSizeReportCtrl* CreateSizeReportCtrl(int width = 80, int height = 80);
+    wxPoint GetStartPosition();
+    wxHtmlWindow* CreateHTMLCtrl(wxWindow* parent = NULL);
+
+    wxString GetIntroText();
+
+private:
+
+    void OnEraseBackground(wxEraseEvent& evt);
+    void OnSize(wxSizeEvent& evt);
+
+    void OnCreateTree(wxCommandEvent& evt);
+    void OnCreateGrid(wxCommandEvent& evt);
+    void OnCreateHTML(wxCommandEvent& evt);
+    void OnCreateText(wxCommandEvent& evt);
+    void OnCreateSizeReport(wxCommandEvent& evt);
+    void OnChangeContentPane(wxCommandEvent& evt);
+    void OnDropDownToolbarItem(wxAuiToolBarEvent& evt);
+    void OnCreatePerspective(wxCommandEvent& evt);
+    void OnCopyPerspectiveCode(wxCommandEvent& evt);
+    void OnRestorePerspective(wxCommandEvent& evt);
+    void OnSettings(wxCommandEvent& evt);
+    void OnCustomizeToolbar(wxCommandEvent& evt);
+    void OnExit(wxCommandEvent& evt);
+    void OnAbout(wxCommandEvent& evt);
+    void OnGradient(wxCommandEvent& evt);
+    void OnManagerFlag(wxCommandEvent& evt);
+    void OnUpdateUI(wxUpdateUIEvent& evt);
+
+    void OnPaneClose(wxAuiManagerEvent& evt);
+
+private:
+
+    wxAuiManager m_mgr;
+    wxArrayString m_perspectives;
+    wxMenu* m_perspectives_menu;
+
+    DECLARE_EVENT_TABLE()
+};
+
+
+// -- wxSizeReportCtrl --
+// (a utility control that always reports it's client size)
+
+class wxSizeReportCtrl : public wxControl
+{
+public:
+
+    wxSizeReportCtrl(wxWindow* parent, wxWindowID id = wxID_ANY,
+                     const wxPoint& pos = wxDefaultPosition,
+                     const wxSize& size = wxDefaultSize,
+                     wxAuiManager* mgr = NULL)
+                     : wxControl(parent, id, pos, size, wxNO_BORDER)
+    {
+        m_mgr = mgr;
+    }
+
+private:
+
+    void OnPaint(wxPaintEvent& WXUNUSED(evt))
+    {
+        wxPaintDC dc(this);
+        wxSize size = GetClientSize();
+        wxString s;
+        int h, w, height;
+
+        s.Printf(wxT("Size: %d x %d"), size.x, size.y);
+
+        dc.SetFont(*wxNORMAL_FONT);
+        dc.GetTextExtent(s, &w, &height);
+        height += 3;
+        dc.SetBrush(*wxWHITE_BRUSH);
+        dc.SetPen(*wxWHITE_PEN);
+        dc.DrawRectangle(0, 0, size.x, size.y);
+        dc.SetPen(*wxLIGHT_GREY_PEN);
+        dc.DrawLine(0, 0, size.x, size.y);
+        dc.DrawLine(0, size.y, size.x, 0);
+        dc.DrawText(s, (size.x-w)/2, ((size.y-(height*5))/2));
+
+        if (m_mgr)
+        {
+            wxAuiPaneInfo pi = m_mgr->GetPane(this);
+
+            s.Printf(wxT("Layer: %d"), pi.GetLayer());
+            dc.GetTextExtent(s, &w, &h);
+            dc.DrawText(s, (size.x-w)/2, ((size.y-(height*5))/2)+(height*1));
+
+            s.Printf(wxT("Dock: %d Row: %d"), pi.GetDirection(), pi.GetRow());
+            dc.GetTextExtent(s, &w, &h);
+            dc.DrawText(s, (size.x-w)/2, ((size.y-(height*5))/2)+(height*2));
+
+            s.Printf(wxT("Position: %d"), pi.GetPosition());
+            dc.GetTextExtent(s, &w, &h);
+            dc.DrawText(s, (size.x-w)/2, ((size.y-(height*5))/2)+(height*3));
+
+            s.Printf(wxT("Proportion: %d"), pi.GetProportion());
+            dc.GetTextExtent(s, &w, &h);
+            dc.DrawText(s, (size.x-w)/2, ((size.y-(height*5))/2)+(height*4));
+        }
+    }
+
+    void OnEraseBackground(wxEraseEvent& WXUNUSED(evt))
+    {
+        // intentionally empty
+    }
+
+    void OnSize(wxSizeEvent& WXUNUSED(evt))
+    {
+        Refresh();
+    }
+private:
+
+    wxAuiManager* m_mgr;
+
+    DECLARE_EVENT_TABLE()
+};
+
+BEGIN_EVENT_TABLE(wxSizeReportCtrl, wxControl)
+    EVT_PAINT(wxSizeReportCtrl::OnPaint)
+    EVT_SIZE(wxSizeReportCtrl::OnSize)
+    EVT_ERASE_BACKGROUND(wxSizeReportCtrl::OnEraseBackground)
+END_EVENT_TABLE()
+
+
+class SettingsPanel : public wxPanel
+{
+    enum
+    {
+        ID_PaneBorderSize = wxID_HIGHEST+1,
+        ID_SashSize,
+        ID_CaptionSize,
+        ID_BackgroundColor,
+        ID_SashColor,
+        ID_InactiveCaptionColor,
+        ID_InactiveCaptionGradientColor,
+        ID_InactiveCaptionTextColor,
+        ID_ActiveCaptionColor,
+        ID_ActiveCaptionGradientColor,
+        ID_ActiveCaptionTextColor,
+        ID_BorderColor,
+        ID_GripperColor
+    };
+
+public:
+
+    SettingsPanel(wxWindow* parent, MyFrame* frame)
+            : wxPanel(parent, wxID_ANY, wxDefaultPosition, wxDefaultSize),
+              m_frame(frame)
+    {
+        //wxBowxSizer* vert = new wxBoxSizer(wxVERTICAL);
+
+        //vert->Add(1, 1, 1, wxEXPAND);
+
+        wxBoxSizer* s1 = new wxBoxSizer(wxHORIZONTAL);
+        m_border_size = new wxSpinCtrl(this, ID_PaneBorderSize, wxString::Format(wxT("%d"), frame->GetDockArt()->GetMetric(wxAUI_DOCKART_PANE_BORDER_SIZE)), wxDefaultPosition, wxSize(50,20), wxSP_ARROW_KEYS, 0, 100, frame->GetDockArt()->GetMetric(wxAUI_DOCKART_PANE_BORDER_SIZE));
+        s1->Add(1, 1, 1, wxEXPAND);
+        s1->Add(new wxStaticText(this, wxID_ANY, wxT("Pane Border Size:")));
+        s1->Add(m_border_size);
+        s1->Add(1, 1, 1, wxEXPAND);
+        s1->SetItemMinSize((size_t)1, 180, 20);
+        //vert->Add(s1, 0, wxEXPAND | wxLEFT | wxBOTTOM, 5);
+
+        wxBoxSizer* s2 = new wxBoxSizer(wxHORIZONTAL);
+        m_sash_size = new wxSpinCtrl(this, ID_SashSize, wxString::Format(wxT("%d"), frame->GetDockArt()->GetMetric(wxAUI_DOCKART_SASH_SIZE)), wxDefaultPosition, wxSize(50,20), wxSP_ARROW_KEYS, 0, 100, frame->GetDockArt()->GetMetric(wxAUI_DOCKART_SASH_SIZE));
+        s2->Add(1, 1, 1, wxEXPAND);
+        s2->Add(new wxStaticText(this, wxID_ANY, wxT("Sash Size:")));
+        s2->Add(m_sash_size);
+        s2->Add(1, 1, 1, wxEXPAND);
+        s2->SetItemMinSize((size_t)1, 180, 20);
+        //vert->Add(s2, 0, wxEXPAND | wxLEFT | wxBOTTOM, 5);
+
+        wxBoxSizer* s3 = new wxBoxSizer(wxHORIZONTAL);
+        m_caption_size = new wxSpinCtrl(this, ID_CaptionSize, wxString::Format(wxT("%d"), frame->GetDockArt()->GetMetric(wxAUI_DOCKART_CAPTION_SIZE)), wxDefaultPosition, wxSize(50,20), wxSP_ARROW_KEYS, 0, 100, frame->GetDockArt()->GetMetric(wxAUI_DOCKART_CAPTION_SIZE));
+        s3->Add(1, 1, 1, wxEXPAND);
+        s3->Add(new wxStaticText(this, wxID_ANY, wxT("Caption Size:")));
+        s3->Add(m_caption_size);
+        s3->Add(1, 1, 1, wxEXPAND);
+        s3->SetItemMinSize((size_t)1, 180, 20);
+        //vert->Add(s3, 0, wxEXPAND | wxLEFT | wxBOTTOM, 5);
+
+        //vert->Add(1, 1, 1, wxEXPAND);
+
+
+        wxBitmap b = CreateColorBitmap(*wxBLACK);
+
+        wxBoxSizer* s4 = new wxBoxSizer(wxHORIZONTAL);
+        m_background_color = new wxBitmapButton(this, ID_BackgroundColor, b, wxDefaultPosition, wxSize(50,25));
+        s4->Add(1, 1, 1, wxEXPAND);
+        s4->Add(new wxStaticText(this, wxID_ANY, wxT("Background Color:")));
+        s4->Add(m_background_color);
+        s4->Add(1, 1, 1, wxEXPAND);
+        s4->SetItemMinSize((size_t)1, 180, 20);
+
+        wxBoxSizer* s5 = new wxBoxSizer(wxHORIZONTAL);
+        m_sash_color = new wxBitmapButton(this, ID_SashColor, b, wxDefaultPosition, wxSize(50,25));
+        s5->Add(1, 1, 1, wxEXPAND);
+        s5->Add(new wxStaticText(this, wxID_ANY, wxT("Sash Color:")));
+        s5->Add(m_sash_color);
+        s5->Add(1, 1, 1, wxEXPAND);
+        s5->SetItemMinSize((size_t)1, 180, 20);
+
+        wxBoxSizer* s6 = new wxBoxSizer(wxHORIZONTAL);
+        m_inactive_caption_color = new wxBitmapButton(this, ID_InactiveCaptionColor, b, wxDefaultPosition, wxSize(50,25));
+        s6->Add(1, 1, 1, wxEXPAND);
+        s6->Add(new wxStaticText(this, wxID_ANY, wxT("Normal Caption:")));
+        s6->Add(m_inactive_caption_color);
+        s6->Add(1, 1, 1, wxEXPAND);
+        s6->SetItemMinSize((size_t)1, 180, 20);
+
+        wxBoxSizer* s7 = new wxBoxSizer(wxHORIZONTAL);
+        m_inactive_caption_gradient_color = new wxBitmapButton(this, ID_InactiveCaptionGradientColor, b, wxDefaultPosition, wxSize(50,25));
+        s7->Add(1, 1, 1, wxEXPAND);
+        s7->Add(new wxStaticText(this, wxID_ANY, wxT("Normal Caption Gradient:")));
+        s7->Add(m_inactive_caption_gradient_color);
+        s7->Add(1, 1, 1, wxEXPAND);
+        s7->SetItemMinSize((size_t)1, 180, 20);
+
+        wxBoxSizer* s8 = new wxBoxSizer(wxHORIZONTAL);
+        m_inactive_caption_text_color = new wxBitmapButton(this, ID_InactiveCaptionTextColor, b, wxDefaultPosition, wxSize(50,25));
+        s8->Add(1, 1, 1, wxEXPAND);
+        s8->Add(new wxStaticText(this, wxID_ANY, wxT("Normal Caption Text:")));
+        s8->Add(m_inactive_caption_text_color);
+        s8->Add(1, 1, 1, wxEXPAND);
+        s8->SetItemMinSize((size_t)1, 180, 20);
+
+        wxBoxSizer* s9 = new wxBoxSizer(wxHORIZONTAL);
+        m_active_caption_color = new wxBitmapButton(this, ID_ActiveCaptionColor, b, wxDefaultPosition, wxSize(50,25));
+        s9->Add(1, 1, 1, wxEXPAND);
+        s9->Add(new wxStaticText(this, wxID_ANY, wxT("Active Caption:")));
+        s9->Add(m_active_caption_color);
+        s9->Add(1, 1, 1, wxEXPAND);
+        s9->SetItemMinSize((size_t)1, 180, 20);
+
+        wxBoxSizer* s10 = new wxBoxSizer(wxHORIZONTAL);
+        m_active_caption_gradient_color = new wxBitmapButton(this, ID_ActiveCaptionGradientColor, b, wxDefaultPosition, wxSize(50,25));
+        s10->Add(1, 1, 1, wxEXPAND);
+        s10->Add(new wxStaticText(this, wxID_ANY, wxT("Active Caption Gradient:")));
+        s10->Add(m_active_caption_gradient_color);
+        s10->Add(1, 1, 1, wxEXPAND);
+        s10->SetItemMinSize((size_t)1, 180, 20);
+
+        wxBoxSizer* s11 = new wxBoxSizer(wxHORIZONTAL);
+        m_active_caption_text_color = new wxBitmapButton(this, ID_ActiveCaptionTextColor, b, wxDefaultPosition, wxSize(50,25));
+        s11->Add(1, 1, 1, wxEXPAND);
+        s11->Add(new wxStaticText(this, wxID_ANY, wxT("Active Caption Text:")));
+        s11->Add(m_active_caption_text_color);
+        s11->Add(1, 1, 1, wxEXPAND);
+        s11->SetItemMinSize((size_t)1, 180, 20);
+
+        wxBoxSizer* s12 = new wxBoxSizer(wxHORIZONTAL);
+        m_border_color = new wxBitmapButton(this, ID_BorderColor, b, wxDefaultPosition, wxSize(50,25));
+        s12->Add(1, 1, 1, wxEXPAND);
+        s12->Add(new wxStaticText(this, wxID_ANY, wxT("Border Color:")));
+        s12->Add(m_border_color);
+        s12->Add(1, 1, 1, wxEXPAND);
+        s12->SetItemMinSize((size_t)1, 180, 20);
+
+        wxBoxSizer* s13 = new wxBoxSizer(wxHORIZONTAL);
+        m_gripper_color = new wxBitmapButton(this, ID_GripperColor, b, wxDefaultPosition, wxSize(50,25));
+        s13->Add(1, 1, 1, wxEXPAND);
+        s13->Add(new wxStaticText(this, wxID_ANY, wxT("Gripper Color:")));
+        s13->Add(m_gripper_color);
+        s13->Add(1, 1, 1, wxEXPAND);
+        s13->SetItemMinSize((size_t)1, 180, 20);
+
+        wxGridSizer* grid_sizer = new wxGridSizer(2);
+        grid_sizer->SetHGap(5);
+        grid_sizer->Add(s1);  grid_sizer->Add(s4);
+        grid_sizer->Add(s2);  grid_sizer->Add(s5);
+        grid_sizer->Add(s3);  grid_sizer->Add(s13);
+        grid_sizer->Add(1,1); grid_sizer->Add(s12);
+        grid_sizer->Add(s6);  grid_sizer->Add(s9);
+        grid_sizer->Add(s7);  grid_sizer->Add(s10);
+        grid_sizer->Add(s8);  grid_sizer->Add(s11);
+
+        wxBoxSizer* cont_sizer = new wxBoxSizer(wxVERTICAL);
+        cont_sizer->Add(grid_sizer, 1, wxEXPAND | wxALL, 5);
+        SetSizer(cont_sizer);
+        GetSizer()->SetSizeHints(this);
+
+        m_border_size->SetValue(frame->GetDockArt()->GetMetric(wxAUI_DOCKART_PANE_BORDER_SIZE));
+        m_sash_size->SetValue(frame->GetDockArt()->GetMetric(wxAUI_DOCKART_SASH_SIZE));
+        m_caption_size->SetValue(frame->GetDockArt()->GetMetric(wxAUI_DOCKART_CAPTION_SIZE));
+
+        UpdateColors();
+    }
+
+private:
+
+    wxBitmap CreateColorBitmap(const wxColour& c)
+    {
+        wxImage image;
+        image.Create(25,14);
+        for (int x = 0; x < 25; ++x)
+            for (int y = 0; y < 14; ++y)
+            {
+                wxColour pixcol = c;
+                if (x == 0 || x == 24 || y == 0 || y == 13)
+                    pixcol = *wxBLACK;
+                image.SetRGB(x, y, pixcol.Red(), pixcol.Green(), pixcol.Blue());
+            }
+        return wxBitmap(image);
+    }
+
+    void UpdateColors()
+    {
+        wxColour bk = m_frame->GetDockArt()->GetColor(wxAUI_DOCKART_BACKGROUND_COLOUR);
+        m_background_color->SetBitmapLabel(CreateColorBitmap(bk));
+
+        wxColour cap = m_frame->GetDockArt()->GetColor(wxAUI_DOCKART_INACTIVE_CAPTION_COLOUR);
+        m_inactive_caption_color->SetBitmapLabel(CreateColorBitmap(cap));
+
+        wxColour capgrad = m_frame->GetDockArt()->GetColor(wxAUI_DOCKART_INACTIVE_CAPTION_GRADIENT_COLOUR);
+        m_inactive_caption_gradient_color->SetBitmapLabel(CreateColorBitmap(capgrad));
+
+        wxColour captxt = m_frame->GetDockArt()->GetColor(wxAUI_DOCKART_INACTIVE_CAPTION_TEXT_COLOUR);
+        m_inactive_caption_text_color->SetBitmapLabel(CreateColorBitmap(captxt));
+
+        wxColour acap = m_frame->GetDockArt()->GetColor(wxAUI_DOCKART_ACTIVE_CAPTION_COLOUR);
+        m_active_caption_color->SetBitmapLabel(CreateColorBitmap(acap));
+
+        wxColour acapgrad = m_frame->GetDockArt()->GetColor(wxAUI_DOCKART_ACTIVE_CAPTION_GRADIENT_COLOUR);
+        m_active_caption_gradient_color->SetBitmapLabel(CreateColorBitmap(acapgrad));
+
+        wxColour acaptxt = m_frame->GetDockArt()->GetColor(wxAUI_DOCKART_ACTIVE_CAPTION_TEXT_COLOUR);
+        m_active_caption_text_color->SetBitmapLabel(CreateColorBitmap(acaptxt));
+
+        wxColour sash = m_frame->GetDockArt()->GetColor(wxAUI_DOCKART_SASH_COLOUR);
+        m_sash_color->SetBitmapLabel(CreateColorBitmap(sash));
+
+        wxColour border = m_frame->GetDockArt()->GetColor(wxAUI_DOCKART_BORDER_COLOUR);
+        m_border_color->SetBitmapLabel(CreateColorBitmap(border));
+
+        wxColour gripper = m_frame->GetDockArt()->GetColor(wxAUI_DOCKART_GRIPPER_COLOUR);
+        m_gripper_color->SetBitmapLabel(CreateColorBitmap(gripper));
+    }
+
+    void OnPaneBorderSize(wxSpinEvent& event)
+    {
+        m_frame->GetDockArt()->SetMetric(wxAUI_DOCKART_PANE_BORDER_SIZE,
+                                         event.GetPosition());
+        m_frame->DoUpdate();
+    }
+
+    void OnSashSize(wxSpinEvent& event)
+    {
+        m_frame->GetDockArt()->SetMetric(wxAUI_DOCKART_SASH_SIZE,
+                                         event.GetPosition());
+        m_frame->DoUpdate();
+    }
+
+    void OnCaptionSize(wxSpinEvent& event)
+    {
+        m_frame->GetDockArt()->SetMetric(wxAUI_DOCKART_CAPTION_SIZE,
+                                         event.GetPosition());
+        m_frame->DoUpdate();
+    }
+
+    void OnSetColor(wxCommandEvent& event)
+    {
+        wxColourDialog dlg(m_frame);
+        dlg.SetTitle(_("Color Picker"));
+        if (dlg.ShowModal() != wxID_OK)
+            return;
+
+        int var = 0;
+        switch (event.GetId())
+        {
+            case ID_BackgroundColor:              var = wxAUI_DOCKART_BACKGROUND_COLOUR; break;
+            case ID_SashColor:                    var = wxAUI_DOCKART_SASH_COLOUR; break;
+            case ID_InactiveCaptionColor:         var = wxAUI_DOCKART_INACTIVE_CAPTION_COLOUR; break;
+            case ID_InactiveCaptionGradientColor: var = wxAUI_DOCKART_INACTIVE_CAPTION_GRADIENT_COLOUR; break;
+            case ID_InactiveCaptionTextColor:     var = wxAUI_DOCKART_INACTIVE_CAPTION_TEXT_COLOUR; break;
+            case ID_ActiveCaptionColor:           var = wxAUI_DOCKART_ACTIVE_CAPTION_COLOUR; break;
+            case ID_ActiveCaptionGradientColor:   var = wxAUI_DOCKART_ACTIVE_CAPTION_GRADIENT_COLOUR; break;
+            case ID_ActiveCaptionTextColor:       var = wxAUI_DOCKART_ACTIVE_CAPTION_TEXT_COLOUR; break;
+            case ID_BorderColor:                  var = wxAUI_DOCKART_BORDER_COLOUR; break;
+            case ID_GripperColor:                 var = wxAUI_DOCKART_GRIPPER_COLOUR; break;
+            default: return;
+        }
+
+        m_frame->GetDockArt()->SetColor(var, dlg.GetColourData().GetColour());
+        m_frame->DoUpdate();
+        UpdateColors();
+    }
+
+private:
+
+    MyFrame* m_frame;
+    wxSpinCtrl* m_border_size;
+    wxSpinCtrl* m_sash_size;
+    wxSpinCtrl* m_caption_size;
+    wxBitmapButton* m_inactive_caption_text_color;
+    wxBitmapButton* m_inactive_caption_gradient_color;
+    wxBitmapButton* m_inactive_caption_color;
+    wxBitmapButton* m_active_caption_text_color;
+    wxBitmapButton* m_active_caption_gradient_color;
+    wxBitmapButton* m_active_caption_color;
+    wxBitmapButton* m_sash_color;
+    wxBitmapButton* m_background_color;
+    wxBitmapButton* m_border_color;
+    wxBitmapButton* m_gripper_color;
+
+    DECLARE_EVENT_TABLE()
+};
+
+BEGIN_EVENT_TABLE(SettingsPanel, wxPanel)
+    EVT_SPINCTRL(ID_PaneBorderSize, SettingsPanel::OnPaneBorderSize)
+    EVT_SPINCTRL(ID_SashSize, SettingsPanel::OnSashSize)
+    EVT_SPINCTRL(ID_CaptionSize, SettingsPanel::OnCaptionSize)
+    EVT_BUTTON(ID_BackgroundColor, SettingsPanel::OnSetColor)
+    EVT_BUTTON(ID_SashColor, SettingsPanel::OnSetColor)
+    EVT_BUTTON(ID_InactiveCaptionColor, SettingsPanel::OnSetColor)
+    EVT_BUTTON(ID_InactiveCaptionGradientColor, SettingsPanel::OnSetColor)
+    EVT_BUTTON(ID_InactiveCaptionTextColor, SettingsPanel::OnSetColor)
+    EVT_BUTTON(ID_ActiveCaptionColor, SettingsPanel::OnSetColor)
+    EVT_BUTTON(ID_ActiveCaptionGradientColor, SettingsPanel::OnSetColor)
+    EVT_BUTTON(ID_ActiveCaptionTextColor, SettingsPanel::OnSetColor)
+    EVT_BUTTON(ID_BorderColor, SettingsPanel::OnSetColor)
+    EVT_BUTTON(ID_GripperColor, SettingsPanel::OnSetColor)
+END_EVENT_TABLE()
+
+
+bool MyApp::OnInit()
+{
+    if ( !wxApp::OnInit() )
+        return false;
+
+    wxFrame* frame = new MyFrame(NULL,
+                                 wxID_ANY,
+                                 wxT("wxAUI Sample Application"),
+                                 wxDefaultPosition,
+                                 wxSize(800, 600));
+    SetTopWindow(frame);
+    frame->Show();
+
+    return true;
+}
+
+BEGIN_EVENT_TABLE(MyFrame, wxFrame)
+    EVT_ERASE_BACKGROUND(MyFrame::OnEraseBackground)
+    EVT_SIZE(MyFrame::OnSize)
+    EVT_MENU(MyFrame::ID_CreateTree, MyFrame::OnCreateTree)
+    EVT_MENU(MyFrame::ID_CreateGrid, MyFrame::OnCreateGrid)
+    EVT_MENU(MyFrame::ID_CreateText, MyFrame::OnCreateText)
+    EVT_MENU(MyFrame::ID_CreateHTML, MyFrame::OnCreateHTML)
+    EVT_MENU(MyFrame::ID_CreateSizeReport, MyFrame::OnCreateSizeReport)
+    EVT_MENU(MyFrame::ID_CreatePerspective, MyFrame::OnCreatePerspective)
+    EVT_MENU(MyFrame::ID_CopyPerspectiveCode, MyFrame::OnCopyPerspectiveCode)
+    EVT_MENU(ID_AllowFloating, MyFrame::OnManagerFlag)
+    EVT_MENU(ID_TabsDefault, MyFrame::OnManagerFlag)
+    EVT_MENU(ID_TabsGeneric, MyFrame::OnManagerFlag)
+    EVT_MENU(ID_TabsSimple, MyFrame::OnManagerFlag)
+    #ifdef wxHAS_NATIVE_TABART
+    EVT_MENU(ID_TabsNative, MyFrame::OnManagerFlag)
+    #endif
+    EVT_MENU(ID_TabsTop, MyFrame::OnManagerFlag)
+    EVT_MENU(ID_TabsLeft, MyFrame::OnManagerFlag)
+    EVT_MENU(ID_TabsRight, MyFrame::OnManagerFlag)
+    EVT_MENU(ID_TabsBottom, MyFrame::OnManagerFlag)
+    EVT_MENU(ID_TabWindowList, MyFrame::OnManagerFlag)
+    EVT_MENU(ID_FixedWidth, MyFrame::OnManagerFlag)
+    EVT_MENU(ID_CloseButton, MyFrame::OnManagerFlag)
+    EVT_MENU(ID_CloseButtonActiveTab, MyFrame::OnManagerFlag)
+    EVT_MENU(ID_CloseButtonAllTabs, MyFrame::OnManagerFlag)
+    EVT_MENU(ID_NoCloseButton, MyFrame::OnManagerFlag)
+    EVT_MENU(ID_TransparentHint, MyFrame::OnManagerFlag)
+    EVT_MENU(ID_VenetianBlindsHint, MyFrame::OnManagerFlag)
+    EVT_MENU(ID_RectangleHint, MyFrame::OnManagerFlag)
+    EVT_MENU(ID_NoHint, MyFrame::OnManagerFlag)
+    EVT_MENU(ID_HintFade, MyFrame::OnManagerFlag)
+    EVT_MENU(ID_NoVenetianFade, MyFrame::OnManagerFlag)
+    EVT_MENU(ID_TransparentDrag, MyFrame::OnManagerFlag)
+    EVT_MENU(ID_LiveUpdate, MyFrame::OnManagerFlag)
+    EVT_MENU(ID_AllowActivePane, MyFrame::OnManagerFlag)
+    EVT_MENU(ID_NoGradient, MyFrame::OnGradient)
+    EVT_MENU(ID_VerticalGradient, MyFrame::OnGradient)
+    EVT_MENU(ID_HorizontalGradient, MyFrame::OnGradient)
+    EVT_MENU(ID_Settings, MyFrame::OnSettings)
+    EVT_MENU(ID_CustomizeToolbar, MyFrame::OnCustomizeToolbar)
+    EVT_MENU(ID_GridContent, MyFrame::OnChangeContentPane)
+    EVT_MENU(ID_TreeContent, MyFrame::OnChangeContentPane)
+    EVT_MENU(ID_TextContent, MyFrame::OnChangeContentPane)
+    EVT_MENU(ID_SizeReportContent, MyFrame::OnChangeContentPane)
+    EVT_MENU(ID_HTMLContent, MyFrame::OnChangeContentPane)
+    EVT_MENU(wxID_EXIT, MyFrame::OnExit)
+    EVT_MENU(wxID_ABOUT, MyFrame::OnAbout)
+    EVT_UPDATE_UI(ID_AllowFloating, MyFrame::OnUpdateUI)
+    EVT_UPDATE_UI(ID_TransparentHint, MyFrame::OnUpdateUI)
+    EVT_UPDATE_UI(ID_VenetianBlindsHint, MyFrame::OnUpdateUI)
+    EVT_UPDATE_UI(ID_RectangleHint, MyFrame::OnUpdateUI)
+    EVT_UPDATE_UI(ID_NoHint, MyFrame::OnUpdateUI)
+    EVT_UPDATE_UI(ID_HintFade, MyFrame::OnUpdateUI)
+    EVT_UPDATE_UI(ID_NoVenetianFade, MyFrame::OnUpdateUI)
+    EVT_UPDATE_UI(ID_TransparentDrag, MyFrame::OnUpdateUI)
+    EVT_UPDATE_UI(ID_LiveUpdate, MyFrame::OnUpdateUI)
+    EVT_UPDATE_UI(ID_NoGradient, MyFrame::OnUpdateUI)
+    EVT_UPDATE_UI(ID_VerticalGradient, MyFrame::OnUpdateUI)
+    EVT_UPDATE_UI(ID_HorizontalGradient, MyFrame::OnUpdateUI)
+    EVT_MENU_RANGE(MyFrame::ID_FirstPerspective, MyFrame::ID_FirstPerspective+1000,
+                   MyFrame::OnRestorePerspective)
+    EVT_AUITOOLBAR_TOOL_DROPDOWN(ID_DropDownToolbarItem, MyFrame::OnDropDownToolbarItem)
+    EVT_AUI_PANE_CLOSE(MyFrame::OnPaneClose)
+END_EVENT_TABLE()
+
+
+MyFrame::MyFrame(wxWindow* parent,
+                 wxWindowID id,
+                 const wxString& title,
+                 const wxPoint& pos,
+                 const wxSize& size,
+                 long style)
+        : wxFrame(parent, id, title, pos, size, style)
+{
+    // tell wxAuiManager to manage this frame
+    m_mgr.SetManagedWindow(this);
+
+    // set frame icon
+    SetIcon(wxIcon(sample_xpm));
+
+    // create menu
+    wxMenuBar* mb = new wxMenuBar;
+
+    wxMenu* file_menu = new wxMenu;
+    file_menu->Append(wxID_EXIT);
+
+    wxMenu* view_menu = new wxMenu;
+    view_menu->Append(ID_CreateText, _("Create Text Control"));
+    view_menu->Append(ID_CreateHTML, _("Create HTML Control"));
+    view_menu->Append(ID_CreateTree, _("Create Tree"));
+    view_menu->Append(ID_CreateGrid, _("Create Grid"));
+    view_menu->Append(ID_CreateSizeReport, _("Create Size Reporter"));
+    view_menu->AppendSeparator();
+    view_menu->Append(ID_GridContent, _("Use a Grid for the Content Pane"));
+    view_menu->Append(ID_TextContent, _("Use a Text Control for the Content Pane"));
+    view_menu->Append(ID_HTMLContent, _("Use an HTML Control for the Content Pane"));
+    view_menu->Append(ID_TreeContent, _("Use a Tree Control for the Content Pane"));
+    view_menu->Append(ID_SizeReportContent, _("Use a Size Reporter for the Content Pane"));
+
+    wxMenu* options_menu = new wxMenu;
+    options_menu->AppendRadioItem(ID_TabsDefault, _("Default theme"));
+    options_menu->AppendRadioItem(ID_TabsGeneric, _("Generic Theme (glossy)"));
+    options_menu->AppendRadioItem(ID_TabsSimple, _("Simple Theme"));
+    #ifdef wxHAS_NATIVE_TABART
+    options_menu->AppendRadioItem(ID_TabsNative, _("Native Theme"));
+    #endif
+    options_menu->AppendSeparator();
+    options_menu->AppendRadioItem(ID_TabsTop, _("Notebook tabs at top"));
+    options_menu->AppendRadioItem(ID_TabsBottom, _("Notebook tabs at bottom"));
+    options_menu->AppendRadioItem(ID_TabsLeft, _("Notebook tabs on left"));
+    options_menu->AppendRadioItem(ID_TabsRight, _("Notebook tabs on right"));
+    options_menu->AppendSeparator();
+    options_menu->AppendCheckItem(ID_TabWindowList, _("Show pulldown list of tabs in notebook"));
+    options_menu->AppendSeparator();
+    options_menu->AppendCheckItem(ID_FixedWidth, _("Use fixed tab width for notebook tabs"));
+    options_menu->AppendSeparator();
+    options_menu->AppendRadioItem(ID_CloseButtonActiveTab, _("Close button on active tab of notebook"));
+    options_menu->AppendRadioItem(ID_CloseButtonAllTabs, _("Close button on all tabs of notebook"));
+    options_menu->AppendRadioItem(ID_CloseButton, _("Close button on right of notebook"));
+    options_menu->AppendRadioItem(ID_NoCloseButton, _("No close button on notebook"));
+    options_menu->AppendSeparator();
+    options_menu->AppendRadioItem(ID_TransparentHint, _("Transparent Hint"));
+    options_menu->AppendRadioItem(ID_VenetianBlindsHint, _("Venetian Blinds Hint"));
+    options_menu->AppendRadioItem(ID_RectangleHint, _("Rectangle Hint"));
+    options_menu->AppendRadioItem(ID_NoHint, _("No Hint"));
+    options_menu->AppendSeparator();
+    options_menu->AppendCheckItem(ID_HintFade, _("Hint Fade-in"));
+    options_menu->AppendCheckItem(ID_AllowFloating, _("Allow Floating"));
+    options_menu->AppendCheckItem(ID_NoVenetianFade, _("Disable Venetian Blinds Hint Fade-in"));
+    options_menu->AppendCheckItem(ID_TransparentDrag, _("Transparent Drag"));
+    options_menu->AppendCheckItem(ID_AllowActivePane, _("Allow Active Pane"));
+    options_menu->AppendCheckItem(ID_LiveUpdate, _("Live Resize Update"));
+    options_menu->AppendSeparator();
+    options_menu->AppendRadioItem(ID_NoGradient, _("No Caption Gradient"));
+    options_menu->AppendRadioItem(ID_VerticalGradient, _("Vertical Caption Gradient"));
+    options_menu->AppendRadioItem(ID_HorizontalGradient, _("Horizontal Caption Gradient"));
+    options_menu->AppendSeparator();
+    options_menu->Append(ID_Settings, _("Settings Pane"));
+
+    m_perspectives_menu = new wxMenu;
+    m_perspectives_menu->Append(ID_CreatePerspective, _("Create Perspective"));
+    m_perspectives_menu->Append(ID_CopyPerspectiveCode, _("Copy Perspective Data To Clipboard"));
+    m_perspectives_menu->AppendSeparator();
+    m_perspectives_menu->Append(ID_FirstPerspective+0, _("Default Startup"));
+    m_perspectives_menu->Append(ID_FirstPerspective+1, _("All Panes"));
+
+    wxMenu* help_menu = new wxMenu;
+    help_menu->Append(wxID_ABOUT);
+
+    mb->Append(file_menu, _("&File"));
+    mb->Append(view_menu, _("&View"));
+    mb->Append(m_perspectives_menu, _("&Perspectives"));
+    mb->Append(options_menu, _("&Options"));
+    mb->Append(help_menu, _("&Help"));
+
+    SetMenuBar(mb);
+
+    CreateStatusBar();
+    GetStatusBar()->SetStatusText(_("Ready"));
+
+
+    // min size for the frame itself isn't completely done.
+    // see the end up wxAuiManager::Update() for the test
+    // code. For now, just hard code a frame minimum size
+    SetMinSize(wxSize(400,300));
+
+
+
+    m_mgr.AddPane(CreateTextCtrl(wxT("This is a movable pane. Its dock position can be changed but it cannot be floated.")), wxAuiPaneInfo().
+                  SetName(wxT("move1")).SetCaption(wxT("Movable")).
+                  SetDirectionLeft().SetLayer(1).SetPosition(0).
+                  SetCloseButton(true).SetMaximizeButton(true).SetBitmap(wxArtProvider::GetBitmap(wxART_QUESTION)).SetFloatable(false).SetMovable(true));
+    m_mgr.AddPane(CreateTextCtrl(wxT("This is a standard floatable pane, because it does not share the same position and layer as any other panes it will not form a notebook. It can become part of a notebook if you drop another pane on its caption or drop it on the caption of another pane (or into the tab area of an existing notebook)")), wxAuiPaneInfo().
+                  SetName(wxT("float1")).SetCaption(wxT("Floatable1")).
+                  SetDirectionLeft().SetLayer(1).SetPosition(4).
+                  SetCloseButton(true).SetMaximizeButton(true));
+     
+
+    //create some more panes that should form into a notebook
+    {
+        m_mgr.AddPane(CreateTextCtrl(wxT("This is a floatable pane with a long caption, for demonstrating the difference between fixed/unfixed tab widths.")), wxAuiPaneInfo().
+                  SetName(wxT("float2")).SetCaption(wxT("Floatable pane 2 (Long Caption)")).
+                  SetDirectionLeft().SetLayer(1).SetPosition(1).
+                  SetCloseButton(true).SetMaximizeButton(true).SetPage(1).SetBitmap(wxArtProvider::GetBitmap(wxART_ERROR)));
+        m_mgr.AddPane(CreateTextCtrl(wxT("This is a standard floatable pane, because it shares the same position and layer as other panes it will form a notebook. It can be removed from the notebook by dragging on the tab and it can reform new notebooks by dropping it on the caption of other panes.")), wxAuiPaneInfo().
+                  SetName(wxT("float3")).SetCaption(wxT("Floatable3")).
+                  SetDirectionLeft().SetLayer(1).SetPosition(1).
+                  SetCloseButton(true).SetMaximizeButton(true).SetPage(3));
+        m_mgr.AddPane(CreateTextCtrl(wxT("This is a standard floatable pane, because it shares the same position and layer as other panes it will form a notebook. It can be removed from the notebook by dragging on the tab and it can reform new notebooks by dropping it on the caption of other panes.")), wxAuiPaneInfo().
+                  SetName(wxT("float4")).SetCaption(wxT("Floatable4")).
+                  SetDirectionLeft().SetLayer(1).SetPosition(1).
+                  SetCloseButton(true).SetMaximizeButton(true).SetPage(2).SetFlag(wxAuiPaneInfo::optionActiveNotebook,true));
+        m_mgr.AddPane(CreateHTMLCtrl(), wxAuiPaneInfo().SetCenterPane().
+                  SetName(wxT("float5")).SetCaption(wxT("Floatable5")).
+                  SetCloseButton(true).SetMaximizeButton(true).SetPage(1).SetFloatable(true).SetDockable(true));
+        m_mgr.AddPane(CreateHTMLCtrl(), wxAuiPaneInfo().SetCenterPane().SetName(wxT("toolTip1")).SetCaption(wxT("ToolTip1")).SetToolTip(wxT("lorem ipsem")).
+                  SetCloseButton(true).SetMaximizeButton(true).SetPage(2).SetFloatable(true).SetDockable(true));
+    }
+
+
+
+
+    // "commit" all changes made to wxAuiManager
+    m_mgr.Update();
+
+    // make some default perspectives
+    wxString perspective_all = m_mgr.SavePerspective();
+
+    m_perspectives.Add(perspective_all);
+}
+
+MyFrame::~MyFrame()
+{
+    m_mgr.UnInit();
+}
+
+wxAuiDockArt* MyFrame::GetDockArt()
+{
+    return m_mgr.GetArtProvider();
+}
+
+void MyFrame::DoUpdate()
+{
+    m_mgr.Update();
+}
+
+void MyFrame::OnEraseBackground(wxEraseEvent& event)
+{
+    event.Skip();
+}
+
+void MyFrame::OnSize(wxSizeEvent& event)
+{
+    event.Skip();
+}
+
+void MyFrame::OnSettings(wxCommandEvent& WXUNUSED(evt))
+{
+    // show the settings pane, and float it
+    wxAuiPaneInfo& floating_pane = m_mgr.GetPane(wxT("settings")).Float().Show();
+
+    if (floating_pane.GetFloatingPosition() == wxDefaultPosition)
+        floating_pane.SetFloatingPosition(GetStartPosition());
+
+    m_mgr.Update();
+}
+
+void MyFrame::OnCustomizeToolbar(wxCommandEvent& WXUNUSED(evt))
+{
+    wxMessageBox(_("Customize Toolbar clicked"));
+}
+
+void MyFrame::OnGradient(wxCommandEvent& event)
+{
+    int gradient = 0;
+
+    switch (event.GetId())
+    {
+        case ID_NoGradient:         gradient = wxAUI_GRADIENT_NONE; break;
+        case ID_VerticalGradient:   gradient = wxAUI_GRADIENT_VERTICAL; break;
+        case ID_HorizontalGradient: gradient = wxAUI_GRADIENT_HORIZONTAL; break;
+    }
+
+    m_mgr.GetArtProvider()->SetMetric(wxAUI_DOCKART_GRADIENT_TYPE, gradient);
+    m_mgr.Update();
+}
+
+void MyFrame::OnManagerFlag(wxCommandEvent& event)
+{
+#if !defined(__WXMSW__) && !defined(__WXMAC__) && !defined(__WXGTK__)
+    if (event.GetId() == ID_TransparentDrag ||
+        event.GetId() == ID_TransparentHint ||
+        event.GetId() == ID_HintFade)
+    {
+        wxMessageBox(wxT("This option is presently only available on wxGTK, wxMSW and wxMac"));
+        return;
+    }
+#endif
+
+    int id = event.GetId();
+
+    if (id == ID_CloseButton ||
+        id == ID_CloseButtonActiveTab ||
+        id == ID_CloseButtonAllTabs ||
+        id == ID_NoCloseButton)
+    {
+        m_mgr.SetFlag(wxAUI_MGR_NB_CLOSE_BUTTON,false);
+        m_mgr.SetFlag(wxAUI_MGR_NB_CLOSE_ON_ACTIVE_TAB,false);
+        m_mgr.SetFlag(wxAUI_MGR_NB_CLOSE_ON_ALL_TABS,false);
+    }
+    else if (id == ID_TabWindowList)
+    {
+        m_mgr.SetFlag(wxAUI_MGR_NB_WINDOWLIST_BUTTON,event.IsChecked());
+    }
+    else if(id == ID_FixedWidth)
+    {
+        m_mgr.SetFlag(wxAUI_MGR_NB_TAB_FIXED_WIDTH,event.IsChecked());
+    }
+    else if (id == ID_TabsTop ||
+        id == ID_TabsLeft ||
+        id == ID_TabsRight ||
+        id == ID_TabsBottom
+        )
+    {
+        m_mgr.SetFlag(wxAUI_MGR_NB_TOP,false);
+        m_mgr.SetFlag(wxAUI_MGR_NB_LEFT,false);
+        m_mgr.SetFlag(wxAUI_MGR_NB_RIGHT,false);
+        m_mgr.SetFlag(wxAUI_MGR_NB_BOTTOM,false);
+    }
+    else if (id == ID_TransparentHint ||
+        id == ID_VenetianBlindsHint ||
+        id == ID_RectangleHint ||
+        id == ID_NoHint)
+    {
+        m_mgr.SetFlag(wxAUI_MGR_TRANSPARENT_HINT,false);
+        m_mgr.SetFlag(wxAUI_MGR_VENETIAN_BLINDS_HINT,false);
+        m_mgr.SetFlag(wxAUI_MGR_RECTANGLE_HINT,false);
+    }
+    else if (id == ID_TabsDefault)
+    {
+        m_mgr.SetTabArtProvider(new wxAuiDefaultTabArt);
+    }
+    else if (id == ID_TabsGeneric)
+    {
+        m_mgr.SetTabArtProvider(new wxAuiGenericTabArt);
+    }
+    else if (id == ID_TabsSimple)
+    {
+        m_mgr.SetTabArtProvider(new wxAuiSimpleTabArt);
+    }
+    #ifdef wxHAS_NATIVE_TABART
+    else if (id == ID_TabsNative)
+    {
+        m_mgr.SetTabArtProvider(new wxAuiNativeTabArt);
+    }
+    #endif
+
+    switch (id)
+    {
+        case ID_AllowFloating: m_mgr.SetFlag(wxAUI_MGR_ALLOW_FLOATING,true); break;
+        case ID_TransparentDrag: m_mgr.SetFlag(wxAUI_MGR_TRANSPARENT_DRAG,true); break;
+        case ID_HintFade: m_mgr.SetFlag(wxAUI_MGR_HINT_FADE,true); break;
+        case ID_NoVenetianFade: m_mgr.SetFlag(wxAUI_MGR_NO_VENETIAN_BLINDS_FADE,true); break;
+        case ID_AllowActivePane: m_mgr.SetFlag(wxAUI_MGR_ALLOW_ACTIVE_PANE,true); break;
+        case ID_TransparentHint: m_mgr.SetFlag(wxAUI_MGR_TRANSPARENT_HINT,true); break;
+        case ID_VenetianBlindsHint: m_mgr.SetFlag(wxAUI_MGR_VENETIAN_BLINDS_HINT,true); break;
+        case ID_RectangleHint: m_mgr.SetFlag(wxAUI_MGR_RECTANGLE_HINT,true); break;
+        case ID_LiveUpdate: m_mgr.SetFlag(wxAUI_MGR_LIVE_RESIZE,true); break;
+        case ID_TabsTop: m_mgr.SetFlag(wxAUI_MGR_NB_TOP,true); break;
+        case ID_TabsLeft: m_mgr.SetFlag(wxAUI_MGR_NB_LEFT,true); break;
+        case ID_TabsRight: m_mgr.SetFlag(wxAUI_MGR_NB_RIGHT,true); break;
+        case ID_TabsBottom: m_mgr.SetFlag(wxAUI_MGR_NB_BOTTOM,true); break;
+        case ID_CloseButton: m_mgr.SetFlag(wxAUI_MGR_NB_CLOSE_BUTTON,true); break;
+        case ID_CloseButtonActiveTab: m_mgr.SetFlag(wxAUI_MGR_NB_CLOSE_ON_ACTIVE_TAB,true); break;
+        case ID_CloseButtonAllTabs: m_mgr.SetFlag(wxAUI_MGR_NB_CLOSE_ON_ALL_TABS,true); break;
+    }
+
+    m_mgr.Update();
+}
+
+
+void MyFrame::OnUpdateUI(wxUpdateUIEvent& event)
+{
+    unsigned int flags = m_mgr.GetFlags();
+
+    switch (event.GetId())
+    {
+        case ID_NoGradient:
+            event.Check(m_mgr.GetArtProvider()->GetMetric(wxAUI_DOCKART_GRADIENT_TYPE) == wxAUI_GRADIENT_NONE);
+            break;
+        case ID_VerticalGradient:
+            event.Check(m_mgr.GetArtProvider()->GetMetric(wxAUI_DOCKART_GRADIENT_TYPE) == wxAUI_GRADIENT_VERTICAL);
+            break;
+        case ID_HorizontalGradient:
+            event.Check(m_mgr.GetArtProvider()->GetMetric(wxAUI_DOCKART_GRADIENT_TYPE) == wxAUI_GRADIENT_HORIZONTAL);
+            break;
+        case ID_AllowFloating:
+            event.Check((flags & wxAUI_MGR_ALLOW_FLOATING) != 0);
+            break;
+        case ID_TransparentDrag:
+            event.Check((flags & wxAUI_MGR_TRANSPARENT_DRAG) != 0);
+            break;
+        case ID_TransparentHint:
+            event.Check((flags & wxAUI_MGR_TRANSPARENT_HINT) != 0);
+            break;
+        case ID_LiveUpdate:
+            event.Check((flags & wxAUI_MGR_LIVE_RESIZE) != 0);
+            break;
+        case ID_VenetianBlindsHint:
+            event.Check((flags & wxAUI_MGR_VENETIAN_BLINDS_HINT) != 0);
+            break;
+        case ID_RectangleHint:
+            event.Check((flags & wxAUI_MGR_RECTANGLE_HINT) != 0);
+            break;
+        case ID_NoHint:
+            event.Check(((wxAUI_MGR_TRANSPARENT_HINT |
+                          wxAUI_MGR_VENETIAN_BLINDS_HINT |
+                          wxAUI_MGR_RECTANGLE_HINT) & flags) == 0);
+            break;
+        case ID_HintFade:
+            event.Check((flags & wxAUI_MGR_HINT_FADE) != 0);
+            break;
+        case ID_NoVenetianFade:
+            event.Check((flags & wxAUI_MGR_NO_VENETIAN_BLINDS_FADE) != 0);
+            break;
+    }
+}
+
+void MyFrame::OnPaneClose(wxAuiManagerEvent& evt)
+{
+    if (evt.pane->GetName() == wxT("test10"))
+    {
+        int res = wxMessageBox(wxT("Are you sure you want to close/hide this pane?"),
+                               wxT("wxAUI"),
+                               wxYES_NO,
+                               this);
+        if (res != wxYES)
+            evt.Veto();
+    }
+}
+
+void MyFrame::OnCreatePerspective(wxCommandEvent& WXUNUSED(event))
+{
+    wxTextEntryDialog dlg(this, wxT("Enter a name for the new perspective:"),
+                          wxT("wxAUI Test"));
+
+    dlg.SetValue(wxString::Format(wxT("Perspective %u"), unsigned(m_perspectives.GetCount() + 1)));
+    if (dlg.ShowModal() != wxID_OK)
+        return;
+
+    if (m_perspectives.GetCount() == 0)
+    {
+        m_perspectives_menu->AppendSeparator();
+    }
+
+    m_perspectives_menu->Append(ID_FirstPerspective + m_perspectives.GetCount(), dlg.GetValue());
+    m_perspectives.Add(m_mgr.SavePerspective());
+}
+
+void MyFrame::OnCopyPerspectiveCode(wxCommandEvent& WXUNUSED(evt))
+{
+    wxString s = m_mgr.SavePerspective();
+
+#if wxUSE_CLIPBOARD
+    if (wxTheClipboard->Open())
+    {
+        wxTheClipboard->SetData(new wxTextDataObject(s));
+        wxTheClipboard->Close();
+    }
+#endif
+}
+
+void MyFrame::OnRestorePerspective(wxCommandEvent& evt)
+{
+    m_mgr.LoadPerspective(m_perspectives.Item(evt.GetId() - ID_FirstPerspective));
+}
+
+
+wxPoint MyFrame::GetStartPosition()
+{
+    static int x = 0;
+    x += 20;
+    wxPoint pt = ClientToScreen(wxPoint(0,0));
+    return wxPoint(pt.x + x, pt.y + x);
+}
+
+void MyFrame::OnCreateTree(wxCommandEvent& WXUNUSED(event))
+{
+    m_mgr.AddPane(CreateTreeCtrl(), wxAuiPaneInfo().
+                  SetCaption(wxT("Tree Control")).
+                  Float().SetFloatingPosition(GetStartPosition()).
+                  SetFloatingSize(wxSize(150,300)));
+    m_mgr.Update();
+}
+
+void MyFrame::OnCreateGrid(wxCommandEvent& WXUNUSED(event))
+{
+    m_mgr.AddPane(CreateGrid(), wxAuiPaneInfo().
+                  SetCaption(wxT("Grid")).
+                  Float().SetFloatingPosition(GetStartPosition()).
+                  SetFloatingSize(wxSize(300,200)));
+    m_mgr.Update();
+}
+
+void MyFrame::OnCreateHTML(wxCommandEvent& WXUNUSED(event))
+{
+    m_mgr.AddPane(CreateHTMLCtrl(), wxAuiPaneInfo().
+                  SetCaption(wxT("HTML Control")).
+                  Float().SetFloatingPosition(GetStartPosition()).
+                  SetFloatingSize(wxSize(300,200)));
+    m_mgr.Update();
+}
+
+void MyFrame::OnCreateText(wxCommandEvent& WXUNUSED(event))
+{
+    m_mgr.AddPane(CreateTextCtrl(), wxAuiPaneInfo().
+                  SetCaption(wxT("Text Control")).
+                  Float().SetFloatingPosition(GetStartPosition()));
+    m_mgr.Update();
+}
+
+void MyFrame::OnCreateSizeReport(wxCommandEvent& WXUNUSED(event))
+{
+    m_mgr.AddPane(CreateSizeReportCtrl(), wxAuiPaneInfo().
+                  SetCaption(wxT("Client Size Reporter")).
+                  Float().SetFloatingPosition(GetStartPosition()).
+                  SetCloseButton(true).SetMaximizeButton(true));
+    m_mgr.Update();
+}
+
+void MyFrame::OnChangeContentPane(wxCommandEvent& evt)
+{
+    m_mgr.GetPane(wxT("grid_content")).Show(evt.GetId() == ID_GridContent);
+    m_mgr.GetPane(wxT("text_content")).Show(evt.GetId() == ID_TextContent);
+    m_mgr.GetPane(wxT("tree_content")).Show(evt.GetId() == ID_TreeContent);
+    m_mgr.GetPane(wxT("sizereport_content")).Show(evt.GetId() == ID_SizeReportContent);
+    m_mgr.GetPane(wxT("html_content")).Show(evt.GetId() == ID_HTMLContent);
+    m_mgr.Update();
+}
+
+void MyFrame::OnDropDownToolbarItem(wxAuiToolBarEvent& evt)
+{
+    if (evt.IsDropDownClicked())
+    {
+        wxAuiToolBar* tb = static_cast<wxAuiToolBar*>(evt.GetEventObject());
+
+        tb->SetToolSticky(evt.GetId(), true);
+
+        // create the popup menu
+        wxMenu menuPopup;
+
+        wxBitmap bmp = wxArtProvider::GetBitmap(wxART_QUESTION, wxART_OTHER, wxSize(16,16));
+
+        wxMenuItem* m1 =  new wxMenuItem(&menuPopup, 10001, _("Drop Down Item 1"));
+        m1->SetBitmap(bmp);
+        menuPopup.Append(m1);
+
+        wxMenuItem* m2 =  new wxMenuItem(&menuPopup, 10002, _("Drop Down Item 2"));
+        m2->SetBitmap(bmp);
+        menuPopup.Append(m2);
+
+        wxMenuItem* m3 =  new wxMenuItem(&menuPopup, 10003, _("Drop Down Item 3"));
+        m3->SetBitmap(bmp);
+        menuPopup.Append(m3);
+
+        wxMenuItem* m4 =  new wxMenuItem(&menuPopup, 10004, _("Drop Down Item 4"));
+        m4->SetBitmap(bmp);
+        menuPopup.Append(m4);
+
+        // line up our menu with the button
+        wxRect rect = tb->GetToolRect(evt.GetId());
+        wxPoint pt = tb->ClientToScreen(rect.GetBottomLeft());
+        pt = ScreenToClient(pt);
+
+
+        PopupMenu(&menuPopup, pt);
+
+
+        // make sure the button is "un-stuck"
+        tb->SetToolSticky(evt.GetId(), false);
+    }
+}
+
+
+void MyFrame::OnExit(wxCommandEvent& WXUNUSED(event))
+{
+    Close(true);
+}
+
+void MyFrame::OnAbout(wxCommandEvent& WXUNUSED(event))
+{
+    wxMessageBox(_("wxAUI Demo\nAn advanced window management library for wxWidgets\n(c) Copyright 2005-2006, Kirix Corporation"), _("About wxAUI Demo"), wxOK, this);
+}
+
+
+wxTextCtrl* MyFrame::CreateTextCtrl(const wxString& ctrl_text)
+{
+    static int n = 0;
+
+    wxString text;
+    if (ctrl_text.Length() > 0)
+        text = ctrl_text;
+    else
+        text.Printf(wxT("This is text box %d"), ++n);
+
+    return new wxTextCtrl(this,wxID_ANY, text,
+                          wxPoint(0,0), wxSize(150,90),
+                          wxNO_BORDER | wxTE_MULTILINE);
+}
+
+
+wxGrid* MyFrame::CreateGrid()
+{
+    wxGrid* grid = new wxGrid(this, wxID_ANY,
+                              wxPoint(0,0),
+                              wxSize(150,250),
+                              wxNO_BORDER | wxWANTS_CHARS);
+    grid->CreateGrid(50, 20);
+    return grid;
+}
+
+wxTreeCtrl* MyFrame::CreateTreeCtrl()
+{
+    wxTreeCtrl* tree = new wxTreeCtrl(this, wxID_ANY,
+                                      wxPoint(0,0), wxSize(160,250),
+                                      wxTR_DEFAULT_STYLE | wxNO_BORDER);
+
+    wxImageList* imglist = new wxImageList(16, 16, true, 2);
+    imglist->Add(wxArtProvider::GetBitmap(wxART_FOLDER, wxART_OTHER, wxSize(16,16)));
+    imglist->Add(wxArtProvider::GetBitmap(wxART_NORMAL_FILE, wxART_OTHER, wxSize(16,16)));
+    tree->AssignImageList(imglist);
+
+    wxTreeItemId root = tree->AddRoot(wxT("wxAUI Project"), 0);
+    wxArrayTreeItemIds items;
+
+
+
+    items.Add(tree->AppendItem(root, wxT("Item 1"), 0));
+    items.Add(tree->AppendItem(root, wxT("Item 2"), 0));
+    items.Add(tree->AppendItem(root, wxT("Item 3"), 0));
+    items.Add(tree->AppendItem(root, wxT("Item 4"), 0));
+    items.Add(tree->AppendItem(root, wxT("Item 5"), 0));
+
+
+    int i, count;
+    for (i = 0, count = items.Count(); i < count; ++i)
+    {
+        wxTreeItemId id = items.Item(i);
+        tree->AppendItem(id, wxT("Subitem 1"), 1);
+        tree->AppendItem(id, wxT("Subitem 2"), 1);
+        tree->AppendItem(id, wxT("Subitem 3"), 1);
+        tree->AppendItem(id, wxT("Subitem 4"), 1);
+        tree->AppendItem(id, wxT("Subitem 5"), 1);
+    }
+
+
+    tree->Expand(root);
+
+    return tree;
+}
+
+wxSizeReportCtrl* MyFrame::CreateSizeReportCtrl(int width, int height)
+{
+    wxSizeReportCtrl* ctrl = new wxSizeReportCtrl(this, wxID_ANY,
+                                   wxDefaultPosition,
+                                   wxSize(width, height), &m_mgr);
+    return ctrl;
+}
+
+wxHtmlWindow* MyFrame::CreateHTMLCtrl(wxWindow* parent)
+{
+    if (!parent)
+        parent = this;
+
+    wxHtmlWindow* ctrl = new wxHtmlWindow(parent, wxID_ANY,
+                                   wxDefaultPosition,
+                                   wxSize(400,300));
+    ctrl->SetPage(GetIntroText());
+    return ctrl;
+}
+
+wxString MyFrame::GetIntroText()
+{
+    const char* text =
+        "<html><body>"
+        "<p>Welcome to the new AUI sample.</p>"
+        "<p>This sample is designed to demonstrate various new features that have been added to wxAUI.</p>"
+        "<p>1) Movable panes - It is now possible to set a pane so that it can be dragged to new dock positions without being allowed to float. Please try to drag/move the pane in the top left hand corner to see this in action.</p>"
+        "<p>2) 'Dynamic' notebooks.</p>"
+        "<p>    2.1) Panes now have a new 'page' property, when two panes occupy the same space (Direction/Layer/Position) they dynamically form a notebook with the page property deciding what order the tabs should be in.</p>"
+        "<p>    2.2) Panes can be floated or moved (If floatable or movable properties are set) out of a notebook by dragging the tab out of the tab bar.</p>"
+        "<p>    2.3) Panes can be added into a notebook by dragging them into the tab bar.</p>"
+        "<p>    2.4) New notebooks can be formed by dragging one pane onto the caption of another (Or programatically simply by setting two panes to share the same properties (Direction/Layer/Position).</p>"
+        "<p>    2.5) As notebooks are formed dynamically based on pane properties and not by use of actual notebook controls, all notebook information (Including the selected tab and the currently selected/visible tab) are automatically serialised/restored when saving/loading a perspective.</p>"
+        "<p>* Note the above functionality does not make use of wxAuiNotebook in any way - and for many purposes makes wxAuiNotebook almost redundant. wxAuiNotebook has been refactored and now exists merely as a convenience class (It is essentially just a frame with a standard manager and a little bit of wrapper code, with all the actual work done by the manager with dynamic notebooks as mentioned above)</p>"
+        "<p></p>"
+        "<p>In addition to the above the following changes have been made since the last version of wxAUI:</p>"
+        "<p>1) API has been refactored to be more like the rest of wxWidgets - e.g. 'SetCaption()' instead of 'Caption()', for now in order to allow backwards compatibility the older API will continue to work as long as WXWIN_COMPATIBILITY_2_8 is set.</p>"
+        "</body></html>";
+    return wxString::FromAscii(text);
+}
diff --git a/samples/samples.bkl b/samples/samples.bkl
index 7e0e997..1060330 100755
--- a/samples/samples.bkl
+++ b/samples/samples.bkl
@@ -1,5 +1,5 @@
 <?xml version="1.0" ?>
-<!-- $Id$ -->
+<!-- $Id: samples.bkl 61587 2009-08-02 21:28:49Z MJM $ -->
 <makefile>
 
     <include file="../build/bakefiles/config.bkl"/>
@@ -17,27 +17,28 @@
     <subproject id="animate" template="sub"/>
     <subproject id="artprov" template="sub"/>
     <subproject id="aui" template="sub"/>
+    <subproject id="auinew" template="sub"/>
+    <subproject id="auimdi" template="sub"/>
     <subproject id="calendar" template="sub"/>
     <subproject id="caret" template="sub"/>
     <subproject id="clipboard" template="sub"/>
     <subproject id="collpane" template="sub"/>
-    <subproject id="combo" template="sub"/>
     <subproject id="config" template="sub"/>
+    <subproject id="combo" template="sub"/>
     <subproject id="console" template="sub"/>
     <subproject id="controls" template="sub"/>
     <subproject id="dataview" template="sub"/>
     <subproject id="dialogs" template="sub"/>
     <subproject id="dialup" template="sub"/>
     <subproject id="display" template="sub"/>
-    <subproject id="dll" template="sub"/>
     <subproject id="dnd" template="sub"/>
     <subproject id="docview" template="sub"/>
     <subproject id="dragimag" template="sub"/>
     <subproject id="drawing" template="sub"/>
     <subproject id="erase" template="sub"/>
     <subproject id="event" template="sub"/>
-    <subproject id="except" template="sub"/>
     <subproject id="exec" template="sub"/>
+    <subproject id="except" template="sub"/>
     <subproject id="font" template="sub"/>
     <subproject id="grid" template="sub"/>
     <subproject id="help" template="sub"/>
@@ -60,12 +61,10 @@
     <subproject id="opengl" template="sub"/>
     <subproject id="ownerdrw" template="sub"/>
     <subproject id="popup" template="sub"/>
-    <subproject id="power" template="sub"/>
     <subproject id="printing" template="sub"/>
     <subproject id="propgrid" template="sub"/>
     <subproject id="regtest" template="sub"/>
     <subproject id="render" template="sub"/>
-    <subproject id="ribbon" template="sub"/>
     <subproject id="richtext" template="sub"/>
     <subproject id="sashtest" template="sub"/>
     <subproject id="scroll" template="sub"/>
@@ -76,22 +75,17 @@
     <subproject id="splitter" template="sub"/>
     <subproject id="statbar" template="sub"/>
     <subproject id="stc" template="sub"/>
-    <subproject id="svg" template="sub"/>
-    <subproject id="taborder" template="sub"/>
     <subproject id="taskbar" template="sub"/>
     <subproject id="text" template="sub"/>
     <subproject id="thread" template="sub"/>
     <subproject id="toolbar" template="sub"/>
     <subproject id="treectrl" template="sub"/>
     <subproject id="typetest" template="sub"/>
-    <subproject id="uiaction" template="sub"/>
     <subproject id="validate" template="sub"/>
     <subproject id="vscroll" template="sub"/>
-    <subproject id="webview" template="sub"/>
     <subproject id="widgets" template="sub"/>
     <subproject id="wizard" template="sub"/>
     <subproject id="wrapsizer" template="sub"/>
-    <subproject id="xrc" template="sub"/>
 
     <!--
         These samples don't always build (they need non-default wxWidgets
diff --git a/src/aui/auibook.cpp b/src/aui/auibook.cpp
index 9c0c958..609d3ed 100755
--- a/src/aui/auibook.cpp
+++ b/src/aui/auibook.cpp
@@ -6,8 +6,8 @@
 // Modified by: Jens Lody
 // Created:     2006-06-28
 // Copyright:   (C) Copyright 2006, Kirix Corporation, All Rights Reserved
-//                            2012, Jens Lody for the code related to left
-//                                  and right positioning
+//                            2012, Jens Lody for the code related to left 
+//                                  and right positioning 
 // Licence:     wxWindows Library Licence, Version 3.1
 ///////////////////////////////////////////////////////////////////////////////
 
@@ -60,10 +60,10 @@ IMPLEMENT_CLASS(wxAuiNotebook, wxBookCtrlBase)
 IMPLEMENT_DYNAMIC_CLASS(wxAuiNotebookEvent, wxBookCtrlEvent)
 
 // extern functions from framemanager.cpp
-extern void wxAuiDoInsertDockLayer(wxAuiPaneInfoArray&,int,int);
-extern void wxAuiDoInsertDockRow(wxAuiPaneInfoArray&,int,int,int);
-extern void wxAuiDoInsertPane(wxAuiPaneInfoArray&,int,int,int,int);
-extern void wxAuiDoInsertPage(wxAuiPaneInfoArray&,int,int,int,int,int);
+extern void Aui_DoInsertDockLayer(wxAuiPaneInfoArray&,int,int);
+extern void Aui_DoInsertDockRow(wxAuiPaneInfoArray&,int,int,int);
+extern void Aui_DoInsertPane(wxAuiPaneInfoArray&,int,int,int,int);
+extern void Aui_DoInsertPage(wxAuiPaneInfoArray&,int,int,int,int,int);
 
 
 BEGIN_EVENT_TABLE(wxAuiNotebook, wxControl)
@@ -126,9 +126,9 @@ void wxAuiNotebook::SetTabCtrlHeight(int height)
     m_requestedTabCtrlHeight = height;
 }
 
-void wxAuiNotebook::SetTabCtrlWidth(int w)
-{
-    m_tabCtrlWidth = w;
+void wxAuiNotebook::SetTabCtrlWidth(int w) 
+{ 
+    m_tabCtrlWidth = w; 
 }
 
 
@@ -153,7 +153,7 @@ bool wxAuiNotebook::UpdateTabCtrlSize()
 
     // if the tab control height needs to change, update
     // all of our tab controls with the new height
-    if (m_tabCtrlHeight == size.y && m_tabCtrlWidth == size.x)
+    if (m_tabCtrlHeight == size.y && m_tabCtrlWidth == size.x) 
         return false;
 
     //fixme: (MJM) This has been broken in the merge and needs to be re-implemented
@@ -172,13 +172,13 @@ wxSize wxAuiNotebook::CalculateTabCtrlSize()
     {
         allPanes.Add(&m_mgr.GetPane(i));
     }
-
-    wxSize tab_size = m_mgr.GetTabArtProvider()->GetBestTabSize((wxWindow*)this, allPanes, m_requestedBmpSize);
-    // if a fixed tab ctrl height is specified,
-    // just use that instead of calculating a
-    // tab height
-    if (m_requestedTabCtrlHeight != -1)
-        tab_size.y = m_requestedTabCtrlHeight;
+    
+    wxSize tab_size = m_mgr.GetTabArtProvider()->GetBestTabSize((wxWindow*)this, allPanes, m_requestedBmpSize); 
+    // if a fixed tab ctrl height is specified, 
+    // just use that instead of calculating a 
+    // tab height 
+    if (m_requestedTabCtrlHeight != -1) 
+        tab_size.y = m_requestedTabCtrlHeight; 
 
     return tab_size;
 }
@@ -194,7 +194,7 @@ void wxAuiNotebook::SetWindowStyleFlag(long style)
     wxControl::SetWindowStyleFlag(style);
 
     m_mgr.SetFlags(style);
-
+    
     unsigned int i;
     for(i=0;i<m_mgr.GetAllPanes().size();i++)
     {
@@ -228,7 +228,7 @@ bool wxAuiNotebook::InsertPage(size_t pageIndex, wxWindow* page, const wxString&
         return false;
 
     // Shift other panes so that this one can go in between them if necessary
-    wxAuiDoInsertPage(m_mgr.GetAllPanes(),1,0,1,0,pageIndex);
+    Aui_DoInsertPage(m_mgr.GetAllPanes(),1,0,1,0,pageIndex);
 
     m_mgr.AddPane(page, wxAuiPaneInfo().SetDirectionCentre().SetLayer(1).SetPosition(1).SetCaption(caption).SetFloatable(false).SetMovable(true).SetPage(pageIndex).SetBitmap(bitmap).SetDockable(m_mgr.HasFlag(wxAUI_NB_TAB_SPLIT)));
 
@@ -473,7 +473,7 @@ void wxAuiNotebook::Split(size_t pageIndex, int direction)
 
         panes[pageIndex].SetDirection(direction);
 
-        wxAuiDoInsertDockLayer(panes,direction,panes[pageIndex].GetLayer());
+        Aui_DoInsertDockLayer(panes,direction,panes[pageIndex].GetLayer());
 
         m_mgr.SetActivePane(panes[pageIndex].GetWindow());
 
@@ -525,11 +525,11 @@ int wxAuiNotebook::GetTabCtrlHeight() const
     return m_tabCtrlHeight;
 }
 
-// Gets the tab control width
-int wxAuiNotebook::GetTabCtrlWidth() const
-{
-    return m_tabCtrlWidth;
-}
+// Gets the tab control width 
+int wxAuiNotebook::GetTabCtrlWidth() const 
+{ 
+    return m_tabCtrlWidth; 
+} 
 
 // Gets the height of the notebook for a given page height
 int wxAuiNotebook::GetHeightForPageHeight(int pageHeight)
@@ -541,15 +541,15 @@ int wxAuiNotebook::GetHeightForPageHeight(int pageHeight)
     return tabCtrlHeight + pageHeight + decorHeight;
 }
 
-// Gets the width of the notebook for a given page width
-int wxAuiNotebook::GetWidthForPageWidth(int pageWidth)
-{
-    UpdateTabCtrlSize();
+// Gets the width of the notebook for a given page width 
+int wxAuiNotebook::GetWidthForPageWidth(int pageWidth) 
+{ 
+    UpdateTabCtrlSize(); 
 
-    int tabCtrlWidth = GetTabCtrlWidth();
-    int decorWidth = 2;
-    return tabCtrlWidth + pageWidth + decorWidth;
-}
+    int tabCtrlWidth = GetTabCtrlWidth(); 
+    int decorWidth = 2; 
+    return tabCtrlWidth + pageWidth + decorWidth; 
+} 
 
 // Advances the selection, generation page selection events
 void wxAuiNotebook::AdvanceSelection(bool forward)
diff --git a/src/aui/dockart.cpp b/src/aui/dockart.cpp
index db986e5..a4a67d8 100755
--- a/src/aui/dockart.cpp
+++ b/src/aui/dockart.cpp
@@ -7,8 +7,8 @@
 // Created:     2005-05-17
 // RCS-ID:      $Id: dockart.cpp 61738 2009-08-23 07:52:17Z MJM $
 // Copyright:   (C) Copyright 2005-2006, Kirix Corporation, All Rights Reserved
-//                            2012, Jens Lody for the code related to left
-//                                  and right positioning
+//                            2012, Jens Lody for the code related to left 
+//                                  and right positioning 
 // Licence:     wxWindows Library Licence, Version 3.1
 ///////////////////////////////////////////////////////////////////////////////
 
@@ -53,8 +53,8 @@
 #else
    #define gtk_widget_is_drawable GTK_WIDGET_DRAWABLE
 #endif
-#ifdef __WXGTK3__
-    #include "wx/graphics.h"
+#ifdef __WXGTK3__ 
+    #include "wx/graphics.h" 
 #endif
 #endif
 
@@ -433,15 +433,15 @@ void wxAuiDefaultDockArt::DrawSash(wxDC& dc, wxWindow* window, int orientation,
     gtk_paint_handle
     (
         gtk_widget_get_style(window->m_wxwindow),
-#ifdef __WXGTK3__
-        static_cast<cairo_t*>(dc.GetGraphicsContext()->GetNativeContext()),
-#else
+#ifdef __WXGTK3__ 
+        static_cast<cairo_t*>(dc.GetGraphicsContext()->GetNativeContext()), 
+#else 
         window->GTKGetDrawingWindow(),
 #endif
         // flags & wxCONTROL_CURRENT ? GTK_STATE_PRELIGHT : GTK_STATE_NORMAL,
         GTK_STATE_NORMAL,
         GTK_SHADOW_NONE,
-#ifndef __WXGTK3__
+#ifndef __WXGTK3__ 
         NULL /* no clipping */,
 #endif
         window->m_wxwindow,
@@ -803,8 +803,8 @@ void wxAuiTabContainer::SetFlags(unsigned int flags)
     // check for new close button settings
     RemoveButton(wxAUI_BUTTON_LEFT);
     RemoveButton(wxAUI_BUTTON_RIGHT);
-    RemoveButton(wxAUI_BUTTON_UP);
-    RemoveButton(wxAUI_BUTTON_DOWN);
+    RemoveButton(wxAUI_BUTTON_UP); 
+    RemoveButton(wxAUI_BUTTON_DOWN); 
     RemoveButton(wxAUI_BUTTON_WINDOWLIST);
     RemoveButton(wxAUI_BUTTON_CLOSE);
 
@@ -1154,22 +1154,22 @@ void wxAuiTabContainer::CalculateRequiredHeight(wxDC& dc,wxWindow* wnd,int& tota
 
         if (IsHorizontal())
         {
-            totalSize = std::max(totalSize,size.y);
+            totalSize = std::max(totalSize,size.y); 
         }
-        else
+        else 
         {
-            totalSize += size.y;
+            totalSize += size.y; 
         }
         if (i >= m_tabOffset)
         {
             if (IsHorizontal())
             {
-                visibleSize = std::max(visibleSize,size.y);
+                visibleSize = std::max(visibleSize,size.y); 
             }
-            else
+            else 
             {
-                visibleSize += size.y;
-            }
+                visibleSize += size.y; 
+            }            
         }
     }
 }
@@ -1204,20 +1204,20 @@ void wxAuiTabContainer::CalculateRequiredWidth(wxDC& dc,wxWindow* wnd,int& total
         {
             totalSize += size.x;
         }
-        else
+        else 
         {
-             totalSize = std::max(totalSize,size.x);
+             totalSize = std::max(totalSize,size.x); 
         }
         if (i >= m_tabOffset)
         {
             if (IsHorizontal())
             {
-                visibleSize += size.x;
+                visibleSize += size.x; 
             }
-            else
+            else 
             {
-                visibleSize = std::max(visibleSize,size.x);
-            }
+                visibleSize = std::max(visibleSize,size.x); 
+            }            
         }
     }
 }
@@ -1248,78 +1248,78 @@ void wxAuiTabContainer::Render(wxDC* rawDC, wxWindow* wnd)
     if (!dc.IsOk())
         return;
 
-    // draw background
-    m_tab_art->DrawBackground(dc, wnd, m_rect);
-
-    // first we create all buttons on the right/bottom, except the forward arrows
-    // so we can determine, whether we need the backward- and forward-arrows
-
-    // draw buttons
-    int backwButtonsSize = 0;
-    int forwButtonsSize = 0;
-
-    int offset = 0;
-
-    int locationBtnRightTop;
-    int locationBtnLeftBottom;
-    int idBtnLeftBottom;
-    int idBtnArrowRightUp;
-    int testSize;
-
-    if (IsHorizontal())
-    {
-        locationBtnRightTop = wxRIGHT;
-        locationBtnLeftBottom = wxLEFT;
-        idBtnLeftBottom = wxAUI_BUTTON_LEFT;
-        idBtnArrowRightUp = wxAUI_BUTTON_RIGHT;
-        testSize = m_rect.GetWidth();
-    }
-    else
-    {
-        locationBtnRightTop = wxUP;
-        locationBtnLeftBottom = wxDOWN;
-        idBtnLeftBottom = wxAUI_BUTTON_DOWN;
-        idBtnArrowRightUp = wxAUI_BUTTON_UP;
-        testSize = m_rect.GetHeight();
-    }
-
-
-    // draw the forward buttons on the top
-    offset = m_rect.x + m_rect.width;
-    for (i = buttonCount; i > 0 ; --i)
-    {
-        wxAuiTabContainerButton& button = m_buttons.Item(i - 1);
-
-        if (button.location != locationBtnRightTop)
-            continue;
-        if (button.curState & wxAUI_BUTTON_STATE_HIDDEN)
-            continue;
-        if (button.id == idBtnArrowRightUp)
-            continue;
-
-        wxRect button_rect = m_rect;
-        button_rect.SetWidth(offset);
-        button_rect.SetX(1);
-        button_rect.SetY(1);
-
-        m_tab_art->DrawButton(dc,
-                          wnd,
-                          button_rect,
-                          button.id,
-                          button.curState,
-                          locationBtnRightTop,
-                          &button.rect);
-
-        offset -= button.rect.GetWidth();
-        if (IsHorizontal())
+    // draw background 
+    m_tab_art->DrawBackground(dc, wnd, m_rect); 
+ 
+    // first we create all buttons on the right/bottom, except the forward arrows 
+    // so we can determine, whether we need the backward- and forward-arrows 
+
+    // draw buttons 
+    int backwButtonsSize = 0; 
+    int forwButtonsSize = 0; 
+ 
+    int offset = 0; 
+
+    int locationBtnRightTop; 
+    int locationBtnLeftBottom; 
+    int idBtnLeftBottom; 
+    int idBtnArrowRightUp; 
+    int testSize; 
+
+    if (IsHorizontal()) 
+    { 
+        locationBtnRightTop = wxRIGHT; 
+        locationBtnLeftBottom = wxLEFT; 
+        idBtnLeftBottom = wxAUI_BUTTON_LEFT; 
+        idBtnArrowRightUp = wxAUI_BUTTON_RIGHT; 
+        testSize = m_rect.GetWidth(); 
+    } 
+    else 
+    { 
+        locationBtnRightTop = wxUP; 
+        locationBtnLeftBottom = wxDOWN; 
+        idBtnLeftBottom = wxAUI_BUTTON_DOWN; 
+        idBtnArrowRightUp = wxAUI_BUTTON_UP; 
+        testSize = m_rect.GetHeight(); 
+    } 
+
+
+    // draw the forward buttons on the top 
+    offset = m_rect.x + m_rect.width; 
+    for (i = buttonCount; i > 0 ; --i) 
+    { 
+        wxAuiTabContainerButton& button = m_buttons.Item(i - 1); 
+ 
+        if (button.location != locationBtnRightTop) 
+            continue; 
+        if (button.curState & wxAUI_BUTTON_STATE_HIDDEN) 
+            continue; 
+        if (button.id == idBtnArrowRightUp) 
+            continue; 
+
+        wxRect button_rect = m_rect; 
+        button_rect.SetWidth(offset); 
+        button_rect.SetX(1); 
+        button_rect.SetY(1); 
+
+        m_tab_art->DrawButton(dc, 
+                          wnd, 
+                          button_rect, 
+                          button.id, 
+                          button.curState, 
+                          locationBtnRightTop, 
+                          &button.rect); 
+
+        offset -= button.rect.GetWidth(); 
+        if (IsHorizontal()) 
         {
-            forwButtonsSize += button.rect.GetWidth();
+            forwButtonsSize += button.rect.GetWidth(); 
         }
-        else
+        else 
         {
-            backwButtonsSize = wxMax(backwButtonsSize, button.rect.GetHeight());
+            backwButtonsSize = wxMax(backwButtonsSize, button.rect.GetHeight()); 
         }
-
+ 
     }
 
     // find out if size of tabs is larger than can be
@@ -1336,8 +1336,8 @@ void wxAuiTabContainer::Render(wxDC* rawDC, wxWindow* wnd)
     }
 
     size_t tabOffset=m_tabOffset;
-    int btn_size;
-    if (IsHorizontal())
+    int btn_size; 
+    if (IsHorizontal()) 
     {
         btn_size = forwButtonsSize;
     }
@@ -1345,18 +1345,18 @@ void wxAuiTabContainer::Render(wxDC* rawDC, wxWindow* wnd)
     {
         // If all tabs can fit on screen then we don't want to apply offset even if we still have an offset, so set to 0.
         tabOffset=0;
-        btn_size = backwButtonsSize;
-    }
-
-    // show up/down buttons
-    for (i = 0; i < buttonCount; ++i)
-    {
-        wxAuiTabContainerButton& button = m_buttons.Item(i);
-        if (button.id == idBtnArrowRightUp || button.id == idBtnLeftBottom)
-        {
-            if (totalSize > (testSize - btn_size - m_tab_art->GetIndentSize()) || m_tabOffset != 0)
-                button.curState &= ~wxAUI_BUTTON_STATE_HIDDEN;
-            else
+        btn_size = backwButtonsSize; 
+    }
+
+    // show up/down buttons 
+    for (i = 0; i < buttonCount; ++i) 
+    { 
+        wxAuiTabContainerButton& button = m_buttons.Item(i); 
+        if (button.id == idBtnArrowRightUp || button.id == idBtnLeftBottom) 
+        { 
+            if (totalSize > (testSize - btn_size - m_tab_art->GetIndentSize()) || m_tabOffset != 0) 
+                button.curState &= ~wxAUI_BUTTON_STATE_HIDDEN; 
+            else 
                 button.curState |= wxAUI_BUTTON_STATE_HIDDEN;
         }
     }
@@ -1374,10 +1374,10 @@ void wxAuiTabContainer::Render(wxDC* rawDC, wxWindow* wnd)
         }
     }
 
-    // now draw forward arrows, keep the rect where it should be drawn, so we are
-    // able to redraw it, if it should be enabled. We can only determine this, if it is actually drawn
-    // because we do not know it's exact size
-    wxRect forw_btn_rect;
+    // now draw forward arrows, keep the rect where it should be drawn, so we are 
+    // able to redraw it, if it should be enabled. We can only determine this, if it is actually drawn 
+    // because we do not know it's exact size 
+    wxRect forw_btn_rect; 
 
     for (i = buttonCount; i > 0; --i)
     {
@@ -1394,7 +1394,7 @@ void wxAuiTabContainer::Render(wxDC* rawDC, wxWindow* wnd)
         button_rect.SetY(1);
         button_rect.SetWidth(offset);
 
-        if (IsHorizontal())
+        if (IsHorizontal()) 
         {
             forw_btn_rect = button_rect;
         }
@@ -1408,15 +1408,15 @@ void wxAuiTabContainer::Render(wxDC* rawDC, wxWindow* wnd)
                           &button.rect);
 
         offset -= button.rect.GetWidth();
-        if (IsHorizontal())
+        if (IsHorizontal()) 
         {
             forwButtonsSize += button.rect.GetWidth();
         }
-        else
+        else 
         {
             backwButtonsSize = wxMax(backwButtonsSize, button.rect.GetHeight());
-        }
-    }
+        } 
+    } 
 
 
     offset = 0;
@@ -1432,12 +1432,12 @@ void wxAuiTabContainer::Render(wxDC* rawDC, wxWindow* wnd)
         if (button.curState & wxAUI_BUTTON_STATE_HIDDEN)
             continue;
 
-        wxRect button_rect = m_rect;
-        button_rect.SetX(1);
-        button_rect.width -= offset;
-        button_rect.SetY(1);
+        wxRect button_rect = m_rect; 
+        button_rect.SetX(1); 
+        button_rect.width -= offset; 
+        button_rect.SetY(1); 
 
-        if (!IsHorizontal() && button.id == wxAUI_BUTTON_DOWN)
+        if (!IsHorizontal() && button.id == wxAUI_BUTTON_DOWN) 
         {
             forw_btn_rect = button_rect;
         }
@@ -1451,18 +1451,18 @@ void wxAuiTabContainer::Render(wxDC* rawDC, wxWindow* wnd)
                           &button.rect);
 
         offset += button.rect.GetWidth();
-        if (IsHorizontal())
+        if (IsHorizontal()) 
         {
-            backwButtonsSize += button.rect.GetWidth();
+            backwButtonsSize += button.rect.GetWidth(); 
         }
-        else
+        else 
         {
-            forwButtonsSize = wxMax(forwButtonsSize, button.rect.GetHeight());
+            forwButtonsSize = wxMax(forwButtonsSize, button.rect.GetHeight()); 
         }
     }
 
-    // this is not a typo, we use the size we determined when drawing the top (aka backw) buttons
-    offset = backwButtonsSize;
+    // this is not a typo, we use the size we determined when drawing the top (aka backw) buttons 
+    offset = backwButtonsSize; 
 
     if (offset == 0)
         offset += m_tab_art->GetIndentSize();
@@ -1490,26 +1490,26 @@ void wxAuiTabContainer::Render(wxDC* rawDC, wxWindow* wnd)
         m_tabCloseButtons.Item(i).curState = wxAUI_BUTTON_STATE_HIDDEN;
     }
 
-    // determine whether right/down button should be enabled
-    for (i = 0; i < buttonCount; ++i)
-    {
-        wxAuiTabContainerButton& button = m_buttons.Item(i);
-        if (button.id == wxAUI_BUTTON_RIGHT || button.id == wxAUI_BUTTON_DOWN)
-        {
-            if (visibleSize < testSize - (backwButtonsSize + forwButtonsSize))
-                button.curState |= wxAUI_BUTTON_STATE_DISABLED;
-            else
-                button.curState &= ~wxAUI_BUTTON_STATE_DISABLED;
-
-            m_tab_art->DrawButton(dc,
-                              wnd,
-                              forw_btn_rect,
-                              button.id,
-                              button.curState,
-                              button.location,
-                              &button.rect);
-        }
-    }
+    // determine whether right/down button should be enabled 
+    for (i = 0; i < buttonCount; ++i) 
+    { 
+        wxAuiTabContainerButton& button = m_buttons.Item(i); 
+        if (button.id == wxAUI_BUTTON_RIGHT || button.id == wxAUI_BUTTON_DOWN) 
+        { 
+            if (visibleSize < testSize - (backwButtonsSize + forwButtonsSize)) 
+                button.curState |= wxAUI_BUTTON_STATE_DISABLED; 
+            else 
+                button.curState &= ~wxAUI_BUTTON_STATE_DISABLED; 
+
+            m_tab_art->DrawButton(dc, 
+                              wnd, 
+                              forw_btn_rect, 
+                              button.id, 
+                              button.curState, 
+                              button.location, 
+                              &button.rect); 
+        } 
+    } 
 
     // draw the tabs
 
@@ -1519,23 +1519,23 @@ void wxAuiTabContainer::Render(wxDC* rawDC, wxWindow* wnd)
 
     int extent = 0;
     wxRect rect = m_rect;
-    if (IsHorizontal())
-    {
-        rect.y = 0;
-        rect.height = m_rect.height;
-    }
-    else
-    {
-        rect.x = 0;
-        rect.width = m_rect.width;
-    }
+    if (IsHorizontal()) 
+    { 
+        rect.y = 0; 
+        rect.height = m_rect.height; 
+    } 
+    else 
+    { 
+        rect.x = 0; 
+        rect.width = m_rect.width; 
+    } 
 
     for (i = tabOffset; i < pageCount; ++i)
     {
         wxAuiPaneInfo& page = *m_pages.Item(i);
         wxAuiTabContainerButton& tab_button = m_tabCloseButtons.Item(i);
 
-
+        
         if (TabHasCloseButton(m_flags,page))
         {
             if (tab_button.curState == wxAUI_BUTTON_STATE_HIDDEN)
@@ -1550,20 +1550,20 @@ void wxAuiTabContainer::Render(wxDC* rawDC, wxWindow* wnd)
             tab_button.curState = wxAUI_BUTTON_STATE_HIDDEN;
         }
 
-        if (IsHorizontal())
-        {
-            rect.x = offset;
-            rect.width = m_rect.width - forwButtonsSize - offset - 2;
-            if (rect.width <= 0)
-                break;
-        }
-        else
-        {
-             rect.y = offset;
-             rect.height = m_rect.height - forwButtonsSize - offset - 2;
-             if (rect.height <= 0)
-                 break;
-        }
+        if (IsHorizontal()) 
+        { 
+            rect.x = offset; 
+            rect.width = m_rect.width - forwButtonsSize - offset - 2; 
+            if (rect.width <= 0) 
+                break; 
+        } 
+        else 
+        { 
+             rect.y = offset; 
+             rect.height = m_rect.height - forwButtonsSize - offset - 2; 
+             if (rect.height <= 0) 
+                 break; 
+        } 
 
         m_tab_art->DrawTab(dc,
                        wnd,
@@ -1639,9 +1639,9 @@ bool wxAuiTabContainer::IsTabVisible(int tabPage, int tabOffset, wxDC* dc, wxWin
     {
         wxAuiTabContainerButton& button = m_buttons.Item(i);
         if (button.id == wxAUI_BUTTON_LEFT ||
-            button.id == wxAUI_BUTTON_RIGHT ||
-            button.id == wxAUI_BUTTON_UP ||
-            button.id == wxAUI_BUTTON_DOWN)
+            button.id == wxAUI_BUTTON_RIGHT || 
+            button.id == wxAUI_BUTTON_UP || 
+            button.id == wxAUI_BUTTON_DOWN) 
         {
             if ((button.curState & wxAUI_BUTTON_STATE_HIDDEN) == 0)
                 arrowButtonVisibleCount ++;
@@ -1662,79 +1662,79 @@ bool wxAuiTabContainer::IsTabVisible(int tabPage, int tabOffset, wxDC* dc, wxWin
 
     int offset = 0;
 
-    // calculate size of the buttons on the right/bottom side
+    // calculate size of the buttons on the right/bottom side 
     if (IsHorizontal())
     {
-        offset = m_rect.x + m_rect.width;
-        for (i = 0; i < buttonCount; ++i)
-        {
-            wxAuiTabContainerButton& button = m_buttons.Item(buttonCount - i - 1);
-            if (button.location != wxRIGHT)
-                continue;
-            if (button.curState & wxAUI_BUTTON_STATE_HIDDEN)
+        offset = m_rect.x + m_rect.width; 
+        for (i = 0; i < buttonCount; ++i) 
+        { 
+            wxAuiTabContainerButton& button = m_buttons.Item(buttonCount - i - 1); 
+            if (button.location != wxRIGHT) 
+                continue; 
+            if (button.curState & wxAUI_BUTTON_STATE_HIDDEN) 
                 continue;
 
-            offset -= button.rect.GetWidth();
-            forwButtonsSize += button.rect.GetWidth();
-        }
-    }
-    else // must be wxAUI_NB_TOP or wxAUI_NB_BOTTOM
-    {
-        for (i = 0; i < buttonCount; ++i)
-        {
-            wxAuiTabContainerButton& button = m_buttons.Item(buttonCount - i - 1);
-
-            if (button.location != wxDOWN)
-                continue;
-            if (button.curState & wxAUI_BUTTON_STATE_HIDDEN)
-                continue;
-
-            offset = wxMax(offset, button.rect.GetHeight());
-            forwButtonsSize = offset;
-        }
-    }
+            offset -= button.rect.GetWidth(); 
+            forwButtonsSize += button.rect.GetWidth(); 
+        } 
+    }
+    else // must be wxAUI_NB_TOP or wxAUI_NB_BOTTOM 
+    { 
+        for (i = 0; i < buttonCount; ++i) 
+        { 
+            wxAuiTabContainerButton& button = m_buttons.Item(buttonCount - i - 1); 
+ 
+            if (button.location != wxDOWN) 
+                continue; 
+            if (button.curState & wxAUI_BUTTON_STATE_HIDDEN) 
+                continue; 
+
+            offset = wxMax(offset, button.rect.GetHeight()); 
+            forwButtonsSize = offset; 
+        } 
+    } 
 
     offset = 0;
 
-    int location_btn_left_top;
-    int testSize;
+    int location_btn_left_top; 
+    int testSize; 
 
-    if (IsHorizontal())
-    {
-        location_btn_left_top = wxLEFT;
-        testSize = m_rect.GetWidth();
-    }
-    else
-    {
-        location_btn_left_top = wxUP;
-        testSize = m_rect.GetHeight();
-    }
+    if (IsHorizontal()) 
+    { 
+        location_btn_left_top = wxLEFT; 
+        testSize = m_rect.GetWidth(); 
+    } 
+    else 
+    { 
+        location_btn_left_top = wxUP; 
+        testSize = m_rect.GetHeight(); 
+    } 
 
 
     for (i = 0; i < buttonCount; ++i)
     {
         wxAuiTabContainerButton& button = m_buttons.Item(buttonCount - i - 1);
 
-        if (button.location != location_btn_left_top)
+        if (button.location != location_btn_left_top) 
             continue;
         if (button.curState & wxAUI_BUTTON_STATE_HIDDEN)
             continue;
 
-        if (IsHorizontal())
-        {
-            offset += button.rect.GetWidth();
-            backwButtonsSize += button.rect.GetWidth();
-        }
-        else
-        {
-            offset = wxMax(offset, button.rect.GetHeight());
-            backwButtonsSize = offset;
+        if (IsHorizontal()) 
+        { 
+            offset += button.rect.GetWidth(); 
+            backwButtonsSize += button.rect.GetWidth(); 
+        } 
+        else 
+        { 
+            offset = wxMax(offset, button.rect.GetHeight()); 
+            backwButtonsSize = offset; 
         }
     }
 
     offset = backwButtonsSize;
 
-    // calculate size of the buttons on the left/top side
+    // calculate size of the buttons on the left/top side 
     if (offset == 0)
         offset += m_tab_art->GetIndentSize();
 
@@ -1762,7 +1762,7 @@ bool wxAuiTabContainer::IsTabVisible(int tabPage, int tabOffset, wxDC* dc, wxWin
         {
             // If not all of the tab is visible, and supposing there's space to display it all,
             // we could do better so we return false.
-            if (((testSize - forwButtonsSize - offset - 2) <= 0) && ((testSize - forwButtonsSize - backwButtonsSize) > extent))
+            if (((testSize - forwButtonsSize - offset - 2) <= 0) && ((testSize - forwButtonsSize - backwButtonsSize) > extent))                
                 return false;
             else
                 return true;
@@ -1803,29 +1803,29 @@ bool wxAuiTabContainer::TabHitTest(int x, int y, wxAuiPaneInfo** hit) const
     x += m_rect.x-m_targetRect.x;
     y += m_rect.y-m_targetRect.y;
 
-    wxRect rect = m_rect;
-    if (m_flags & (wxAUI_NB_LEFT | wxAUI_NB_RIGHT))
-    {
-        int bottomSize = 0;
-        for (size_t i = m_buttons.GetCount(); i > 0 ; --i)
-        {
-            wxAuiTabContainerButton& button = m_buttons.Item(i - 1);
-            if (button.location == wxDOWN)
-            {
-                // if we have hit one of the bottom buttons step out, or we can not click it
-                if (button.rect.Contains(x,y))
-                {
-                    bottomSize = 0;
-                    break;
-                }
-                bottomSize = wxMax(bottomSize, button.rect.GetHeight());
-            }
-        }
-        if (bottomSize)
-           rect.height -= (bottomSize + 2);
-    }
-
-    if (!rect.Contains(x,y))
+    wxRect rect = m_rect; 
+    if (m_flags & (wxAUI_NB_LEFT | wxAUI_NB_RIGHT)) 
+    { 
+        int bottomSize = 0; 
+        for (size_t i = m_buttons.GetCount(); i > 0 ; --i) 
+        { 
+            wxAuiTabContainerButton& button = m_buttons.Item(i - 1); 
+            if (button.location == wxDOWN) 
+            { 
+                // if we have hit one of the bottom buttons step out, or we can not click it 
+                if (button.rect.Contains(x,y)) 
+                { 
+                    bottomSize = 0; 
+                    break; 
+                } 
+                bottomSize = wxMax(bottomSize, button.rect.GetHeight()); 
+            } 
+        } 
+        if (bottomSize) 
+           rect.height -= (bottomSize + 2); 
+    } 
+  
+    if (!rect.Contains(x,y)) 
         return false;
 
     wxAuiTabContainerButton* btn = NULL;
@@ -1879,29 +1879,29 @@ bool wxAuiTabContainer::ButtonHitTest(int x, int y,
     x += m_rect.x-m_targetRect.x;
     y += m_rect.y-m_targetRect.y;
 
-    wxRect rect = m_rect;
-    if (m_flags & (wxAUI_NB_LEFT | wxAUI_NB_RIGHT))
-    {
-        int bottomSize = 0;
-        for (size_t i = m_buttons.GetCount(); i > 0 ; --i)
-        {
-            wxAuiTabContainerButton& button = m_buttons.Item(i - 1);
-            if (button.location == wxDOWN)
-            {
-                // if we have hit one of the bottom buttons step out, or we can not click it
-                if (button.rect.Contains(x,y))
-                {
-                    bottomSize = 0;
-                    break;
-                }
-                bottomSize = wxMax(bottomSize, button.rect.GetHeight());
-            }
-        }
-        if (bottomSize)
-            rect.height -= (bottomSize + 2);
-    }
-
-    if (!rect.Contains(x,y))
+    wxRect rect = m_rect; 
+    if (m_flags & (wxAUI_NB_LEFT | wxAUI_NB_RIGHT)) 
+    { 
+        int bottomSize = 0; 
+        for (size_t i = m_buttons.GetCount(); i > 0 ; --i) 
+        { 
+            wxAuiTabContainerButton& button = m_buttons.Item(i - 1); 
+            if (button.location == wxDOWN) 
+            { 
+                // if we have hit one of the bottom buttons step out, or we can not click it 
+                if (button.rect.Contains(x,y)) 
+                { 
+                    bottomSize = 0; 
+                    break; 
+                } 
+                bottomSize = wxMax(bottomSize, button.rect.GetHeight()); 
+            } 
+        } 
+        if (bottomSize) 
+            rect.height -= (bottomSize + 2); 
+    } 
+
+    if (!rect.Contains(x,y))     
         return false;
 
     size_t i, buttonCount;
diff --git a/src/aui/framemanager.cpp b/src/aui/framemanager.cpp
index 87032e8..d2141fa 100755
--- a/src/aui/framemanager.cpp
+++ b/src/aui/framemanager.cpp
@@ -525,9 +525,9 @@ static int GetMaxRow(const wxAuiPaneInfoArray& panes, int direction, int layer)
 
 
 
-// wxAuiDoInsertDockLayer() is an internal function that inserts a new dock
+// Aui_DoInsertDockLayer() is an internal function that inserts a new dock
 // layer by incrementing all existing dock layer values by one
-void wxAuiDoInsertDockLayer(wxAuiPaneInfoArray& panes, int dockDirection, int dockLayer)
+void Aui_DoInsertDockLayer(wxAuiPaneInfoArray& panes, int dockDirection, int dockLayer)
 {
     int i, paneCount;
     for (i = 0, paneCount = panes.GetCount(); i < paneCount; ++i)
@@ -540,9 +540,9 @@ void wxAuiDoInsertDockLayer(wxAuiPaneInfoArray& panes, int dockDirection, int do
     }
 }
 
-// wxAuiDoInsertDockRow() is an internal function that inserts a new dock
+// Aui_DoInsertDockRow() is an internal function that inserts a new dock
 // row by incrementing all existing dock row values by one
-void wxAuiDoInsertDockRow(wxAuiPaneInfoArray& panes, int dockDirection, int dockLayer, int dockRow)
+void Aui_DoInsertDockRow(wxAuiPaneInfoArray& panes, int dockDirection, int dockLayer, int dockRow)
 {
     int i, paneCount;
     for (i = 0, paneCount = panes.GetCount(); i < paneCount; ++i)
@@ -556,9 +556,9 @@ void wxAuiDoInsertDockRow(wxAuiPaneInfoArray& panes, int dockDirection, int dock
     }
 }
 
-// wxAuiDoInsertPane() is an internal function that inserts a space for
+// Aui_DoInsertPane() is an internal function that inserts a space for
 // another dock pane by incrementing all existing dock position values by one
-void wxAuiDoInsertPane(wxAuiPaneInfoArray& panes, int dockDirection, int dockLayer, int dockRow, int dockPos)
+void Aui_DoInsertPane(wxAuiPaneInfoArray& panes, int dockDirection, int dockLayer, int dockRow, int dockPos)
 {
     int i, paneCount;
     for (i = 0, paneCount = panes.GetCount(); i < paneCount; ++i)
@@ -575,9 +575,9 @@ void wxAuiDoInsertPane(wxAuiPaneInfoArray& panes, int dockDirection, int dockLay
     }
 }
 
-// wxAuiDoInsertPane() is an internal function that inserts a space for
+// Aui_DoInsertPane() is an internal function that inserts a space for
 // another notebook page by incrementing all existing page values by one
-void wxAuiDoInsertPage(wxAuiPaneInfoArray& panes, int dockDirection, int dockLayer, int dockRow, int dockPos, int dockPage)
+void Aui_DoInsertPage(wxAuiPaneInfoArray& panes, int dockDirection, int dockLayer, int dockRow, int dockPos, int dockPage)
 {
     int i, paneCount;
     for (i = 0, paneCount = panes.GetCount(); i < paneCount; ++i)
@@ -758,7 +758,7 @@ int wxAuiManager::SetActivePane(wxWindow* activePane)
             }
         }
     }
-
+    
     // send the 'activated' event after all panes have been updated
     if ( activePaneInfo )
     {
@@ -767,7 +767,7 @@ int wxAuiManager::SetActivePane(wxWindow* activePane)
         evt.SetPane(activePaneInfo);
         ProcessMgrEvent(evt);
     }
-
+    
     return 0;
 }
 
@@ -904,13 +904,14 @@ wxAuiManager::wxAuiManager(wxWindow* managedWindow, unsigned int flags)
 {
     m_action = actionNone;
     m_lastMouseMove = wxPoint();
-
+    
     m_art = new wxAuiDefaultDockArt;
     m_tab_art = new wxAuiDefaultTabArt;
     m_flags = flags;
     m_skipping = false;
     m_hasMaximized = false;
-
+    m_doingHintCalculation = false;
+    
     m_dockConstraintX = 0.3;
     m_dockConstraintY = 0.3;
     m_currentDragItem = -1;
@@ -1525,20 +1526,20 @@ bool wxAuiManager::InsertPane(wxWindow* window, const wxAuiPaneInfo& paneInfo, i
     switch (insertLevel)
     {
         case wxAUI_INSERT_PANE:
-            wxAuiDoInsertPane(m_panes,
+            Aui_DoInsertPane(m_panes,
                  paneInfo.GetDirection(),
                  paneInfo.GetLayer(),
                  paneInfo.GetRow(),
                  paneInfo.GetPosition());
             break;
         case wxAUI_INSERT_ROW:
-            wxAuiDoInsertDockRow(m_panes,
+            Aui_DoInsertDockRow(m_panes,
                  paneInfo.GetDirection(),
                  paneInfo.GetLayer(),
                  paneInfo.GetRow());
             break;
         case wxAUI_INSERT_DOCK:
-            wxAuiDoInsertDockLayer(m_panes,
+            Aui_DoInsertDockLayer(m_panes,
                  paneInfo.GetDirection(),
                  paneInfo.GetLayer());
             break;
@@ -1638,9 +1639,9 @@ bool wxAuiManager::DetachPane(wxWindow* window)
 
 
 
-
-
-
+ 
+    
+    
 // ClosePane() destroys or hides the pane depending on its flags
 bool wxAuiManager::ClosePane(wxAuiPaneInfo& paneInfo)
 {
@@ -1654,14 +1655,14 @@ bool wxAuiManager::ClosePane(wxAuiPaneInfo& paneInfo)
         if (!e.IsAllowed())
             return false;
     }
-
+        
     // fire pane close event, allow opportunity for users to veto close
     wxAuiManagerEvent e(wxEVT_AUI_PANE_CLOSE);
     e.SetPane(&paneInfo);
     ProcessMgrEvent(e);
     if (e.GetVeto())
         return false;
-
+    
     // if we were maximized, restore
     if (paneInfo.IsMaximized())
     {
@@ -1702,7 +1703,7 @@ bool wxAuiManager::ClosePane(wxAuiPaneInfo& paneInfo)
     {
         paneInfo.Hide();
     }
-
+    
     // If we are a wxAuiNotebook then we must fire off a EVT_AUINOTEBOOK_PAGE_CLOSED event to notify user of change.
     if(wxDynamicCast(GetManagedWindow(),wxAuiNotebook))
     {
@@ -2341,23 +2342,23 @@ int wxAuiManager::GetNotebookFlags()
     {
         flags |= wxAUI_MGR_NB_TOP;
     }
-
+        
     if(HasFlag(wxAUI_MGR_NB_WINDOWLIST_BUTTON))
     {
         flags |= wxAUI_MGR_NB_WINDOWLIST_BUTTON;
     }
-
+    
     if(HasFlag(wxAUI_MGR_NB_SCROLL_BUTTONS))
     {
         flags |= wxAUI_MGR_NB_SCROLL_BUTTONS;
     }
-
+    
     if(HasFlag(wxAUI_MGR_NB_TAB_FIXED_WIDTH))
     {
         flags |= wxAUI_MGR_NB_TAB_FIXED_WIDTH;
     }
-
-
+    
+        
     if(HasFlag(wxAUI_MGR_NB_CLOSE_BUTTON))
     {
         flags |= wxAUI_MGR_NB_CLOSE_BUTTON;
@@ -2381,7 +2382,7 @@ void wxAuiManager::LayoutAddNotebook(wxAuiTabArt* tabArt,wxAuiTabContainer* note
     if(orient==wxHORIZONTAL)
     {
         //fixme: (MJM) This should be set via the art provider not hardcoded, temporary hardcoding while we iron out some issues with the tab art providers.
-        sizerItem = notebookSizer->Add(m_art->GetMetric(wxAUI_DOCKART_SASH_SIZE), /*tabArt->m_tabCtrlHeight*/notebookTabHeight, 0, wxEXPAND);
+        sizerItem = notebookSizer->Add(m_art->GetMetric(wxAUI_DOCKART_SASH_SIZE), /*tabArt->m_tabCtrlHeight*/notebookTabHeight, 0, wxEXPAND); 
     }
     else
     {
@@ -2449,7 +2450,7 @@ void wxAuiManager::LayoutAddDock(wxSizer* cont, wxAuiDockInfo& dock, wxAuiDockUI
         GetPanePositionsAndSizes(dock, panePositions, paneSizes);
 
         int offset = 0;
-
+        
         // Variables to keep track of the first page of a notebook we encounter so that we can add further panes
         // to the same notebook.
         wxAuiPaneInfo* firstPaneInNotebook = NULL;
@@ -2476,7 +2477,9 @@ void wxAuiManager::LayoutAddDock(wxSizer* cont, wxAuiDockInfo& dock, wxAuiDockUI
                 {
                     if(!activenotebookpagefound)
                     {
-                        ShowWnd(pane.GetWindow(),true);
+                        // Don't ever hide or show a window during hint calculation as this can affect display of windows other than the hint one.
+                        if(!m_doingHintCalculation)
+                            ShowWnd(pane.GetWindow(),true);
                         activenotebookpagefound = true;
                     }
                     else
@@ -2486,7 +2489,9 @@ void wxAuiManager::LayoutAddDock(wxSizer* cont, wxAuiDockInfo& dock, wxAuiDockUI
                         // a floating frame, hiding it in this case would make the floating frame blank.
                         if(pane.GetWindow()->GetParent()==m_frame)
                         {
-                            ShowWnd(pane.GetWindow(),false);
+                            // Don't ever hide or show a window during hint calculation as this can affect display of windows other than the hint one.
+                            if(!m_doingHintCalculation)
+                                ShowWnd(pane.GetWindow(),false);
                         }
                         // Add a debug warning?
                     }
@@ -2498,7 +2503,9 @@ void wxAuiManager::LayoutAddDock(wxSizer* cont, wxAuiDockInfo& dock, wxAuiDockUI
                     // a floating frame, hiding it in this case would make the floating frame blank.
                     if(pane.GetWindow()->GetParent()==m_frame)
                     {
-                        ShowWnd(pane.GetWindow(),false);
+                        // Don't ever hide or show a window during hint calculation as this can affect display of windows other than the hint one.
+                        if(!m_doingHintCalculation)
+                            ShowWnd(pane.GetWindow(),false);
                     }
                 }
                 // If we are only doing a drop calculation then we only want the first
@@ -2521,14 +2528,18 @@ void wxAuiManager::LayoutAddDock(wxSizer* cont, wxAuiDockInfo& dock, wxAuiDockUI
                     {
                         LayoutAddNotebook(m_tab_art,notebookContainer,notebookSizer,part,dock,uiparts,tabContainerRecalcList,tabContainerRecalcSizers,firstPaneInNotebook,wxHORIZONTAL);
                     }
-
+                    
                     if(!activenotebookpagefound)
                     {
                         // The previous page was a notebook that did not have an active page and we are not part of,
                         // set the first page in that notebook to be the active page.
-                        firstPaneInNotebook->SetFlag(wxAuiPaneInfo::optionActiveNotebook,true);
-                        ShowWnd(firstPaneInNotebook->GetWindow(),true);
-                        activenotebookpagefound=true;
+                        // Don't ever hide or show a window during hint calculation as this can affect display of windows other than the hint one.
+                        if(!m_doingHintCalculation)
+                        {
+                            firstPaneInNotebook->SetFlag(wxAuiPaneInfo::optionActiveNotebook,true);
+                            ShowWnd(firstPaneInNotebook->GetWindow(),true);
+                            activenotebookpagefound=true;
+                        }
                     }
                 }
 
@@ -2552,7 +2563,7 @@ void wxAuiManager::LayoutAddDock(wxSizer* cont, wxAuiDockInfo& dock, wxAuiDockUI
                     int flags = GetNotebookFlags();
                     notebookContainer->SetFlags(flags);
                     notebookContainer->AddPage(pane);
-
+                    
                     // Top/Left Notebook
                     if(HasFlag(wxAUI_MGR_NB_LEFT))
                     {
@@ -2565,7 +2576,9 @@ void wxAuiManager::LayoutAddDock(wxSizer* cont, wxAuiDockInfo& dock, wxAuiDockUI
 
                     if(pane.HasFlag(wxAuiPaneInfo::optionActiveNotebook))
                     {
-                        ShowWnd(pane.GetWindow(),true);
+                        // Don't ever hide or show a window during hint calculation as this can affect display of windows other than the hint one.
+                        if(!m_doingHintCalculation)
+                            ShowWnd(pane.GetWindow(),true);
                         activenotebookpagefound = true;
                     }
                     else
@@ -2576,7 +2589,9 @@ void wxAuiManager::LayoutAddDock(wxSizer* cont, wxAuiDockInfo& dock, wxAuiDockUI
                         // a floating frame, hiding it in this case would make the floating frame blank.
                         if(pane.GetWindow()->GetParent()==m_frame)
                         {
-                            ShowWnd(pane.GetWindow(),false);
+                            // Don't ever hide or show a window during hint calculation as this can affect display of windows other than the hint one.
+                            if(!m_doingHintCalculation)
+                                ShowWnd(pane.GetWindow(),false);
                         }
                     }
                 }
@@ -2588,7 +2603,7 @@ void wxAuiManager::LayoutAddDock(wxSizer* cont, wxAuiDockInfo& dock, wxAuiDockUI
                     notebookSizer = NULL;
                 }
             }
-
+            
             int amount = panePos - offset;
             if (amount > 0)
             {
@@ -2627,13 +2642,17 @@ void wxAuiManager::LayoutAddDock(wxSizer* cont, wxAuiDockInfo& dock, wxAuiDockUI
             {
                 LayoutAddNotebook(m_tab_art,notebookContainer,notebookSizer,part,dock,uiparts,tabContainerRecalcList,tabContainerRecalcSizers,firstPaneInNotebook,wxHORIZONTAL);
             }
-
-
+            
+            
             if(!activenotebookpagefound && firstPaneInNotebook)
             {
-                firstPaneInNotebook->SetFlag(wxAuiPaneInfo::optionActiveNotebook,true);
-                ShowWnd(firstPaneInNotebook->GetWindow(),true);
-                activenotebookpagefound=true;
+                // Don't ever hide or show a window during hint calculation as this can affect display of windows other than the hint one.
+                if(!m_doingHintCalculation)
+                {
+                    firstPaneInNotebook->SetFlag(wxAuiPaneInfo::optionActiveNotebook,true);
+                    ShowWnd(firstPaneInNotebook->GetWindow(),true);
+                    activenotebookpagefound=true;
+                }
             }
         }
 
@@ -2677,7 +2696,9 @@ void wxAuiManager::LayoutAddDock(wxSizer* cont, wxAuiDockInfo& dock, wxAuiDockUI
                 {
                     if(!activenotebookpagefound)
                     {
-                        ShowWnd(pane.GetWindow(),true);
+                        // Don't ever hide or show a window during hint calculation as this can affect display of windows other than the hint one.
+                        if(!m_doingHintCalculation)
+                            ShowWnd(pane.GetWindow(),true);
                         activenotebookpagefound = true;
                     }
                     //else
@@ -2690,7 +2711,9 @@ void wxAuiManager::LayoutAddDock(wxSizer* cont, wxAuiDockInfo& dock, wxAuiDockUI
                     // a floating frame, hiding it in this case would make the floating frame blank.
                     if(pane.GetWindow()->GetParent()==m_frame)
                     {
-                        ShowWnd(pane.GetWindow(),false);
+                        // Don't ever hide or show a window during hint calculation as this can affect display of windows other than the hint one.
+                        if(!m_doingHintCalculation)
+                            ShowWnd(pane.GetWindow(),false);
                     }
                 }
                 // If we are only doing a drop calculation then we only want the first
@@ -2713,15 +2736,19 @@ void wxAuiManager::LayoutAddDock(wxSizer* cont, wxAuiDockInfo& dock, wxAuiDockUI
                     {
                         LayoutAddNotebook(m_tab_art,notebookContainer,notebookSizer,part,dock,uiparts,tabContainerRecalcList,tabContainerRecalcSizers,firstPaneInNotebook,wxHORIZONTAL);
                     }
-
+                    
 
                     if(!activenotebookpagefound)
                     {
                         // The previous page was a notebook that did not have an active page and we are not part of,
                         // set the first page in that notebook to be the active page.
-                        firstPaneInNotebook->SetFlag(wxAuiPaneInfo::optionActiveNotebook,true);
-                        ShowWnd(firstPaneInNotebook->GetWindow(),true);
-                        activenotebookpagefound=true;
+                        // Don't ever hide or show a window during hint calculation as this can affect display of windows other than the hint one.
+                        if(!m_doingHintCalculation)
+                        {
+                            firstPaneInNotebook->SetFlag(wxAuiPaneInfo::optionActiveNotebook,true);
+                            ShowWnd(firstPaneInNotebook->GetWindow(),true);
+                            activenotebookpagefound=true;
+                        }
                     }
                 }
 
@@ -2761,7 +2788,7 @@ void wxAuiManager::LayoutAddDock(wxSizer* cont, wxAuiDockInfo& dock, wxAuiDockUI
                     int flags= GetNotebookFlags();
                     notebookContainer->SetFlags(flags);
                     notebookContainer->AddPage(pane);
-
+                    
                     // Left/Top Notebook
                     if(HasFlag(wxAUI_MGR_NB_LEFT))
                     {
@@ -2774,7 +2801,9 @@ void wxAuiManager::LayoutAddDock(wxSizer* cont, wxAuiDockInfo& dock, wxAuiDockUI
 
                     if(pane.HasFlag(wxAuiPaneInfo::optionActiveNotebook))
                     {
-                        ShowWnd(pane.GetWindow(),true);
+                        // Don't ever hide or show a window during hint calculation as this can affect display of windows other than the hint one.
+                        if(!m_doingHintCalculation)
+                            ShowWnd(pane.GetWindow(),true);
                         activenotebookpagefound = true;
                     }
                     else
@@ -2785,7 +2814,9 @@ void wxAuiManager::LayoutAddDock(wxSizer* cont, wxAuiDockInfo& dock, wxAuiDockUI
                         // a floating frame, hiding it in this case would make the floating frame blank.
                         if(pane.GetWindow()->GetParent()==m_frame)
                         {
-                            ShowWnd(pane.GetWindow(),false);
+                            // Don't ever hide or show a window during hint calculation as this can affect display of windows other than the hint one.
+                            if(!m_doingHintCalculation)
+                                ShowWnd(pane.GetWindow(),false);
                         }
                     }
                 }
@@ -2814,15 +2845,19 @@ void wxAuiManager::LayoutAddDock(wxSizer* cont, wxAuiDockInfo& dock, wxAuiDockUI
             {
                 LayoutAddNotebook(m_tab_art,notebookContainer,notebookSizer,part,dock,uiparts,tabContainerRecalcList,tabContainerRecalcSizers,firstPaneInNotebook,wxHORIZONTAL);
             }
-
-
+            
+            
             if(!activenotebookpagefound)
             {
                 // The previous page was a notebook that did not have an active page and we are not part of,
                 // set the first page in that notebook to be the active page.
-                firstPaneInNotebook->SetFlag(wxAuiPaneInfo::optionActiveNotebook,true);
-                ShowWnd(firstPaneInNotebook->GetWindow(),true);
-                activenotebookpagefound=true;
+                // Don't ever hide or show a window during hint calculation as this can affect display of windows other than the hint one.
+                if(!m_doingHintCalculation)
+                {
+                    firstPaneInNotebook->SetFlag(wxAuiPaneInfo::optionActiveNotebook,true);
+                    ShowWnd(firstPaneInNotebook->GetWindow(),true);
+                    activenotebookpagefound=true;
+                }
             }
         }
     }
@@ -3070,8 +3105,8 @@ wxSizer* wxAuiManager::LayoutAll(wxAuiPaneInfoArray& panes,
         dock.min_size = dockMinSize;
 
 
-        // if the pane's current size is less than it's
-        // minimum, increase the dock's size to it's minimum
+        // if the pane's current size is less than its
+        // minimum, increase the dock's size to its minimum
         if (dock.size < dock.min_size)
             dock.size = dock.min_size;
 
@@ -3404,9 +3439,9 @@ void wxAuiManager::Update()
             }
             else
             {
-                // frame already exists, make sure it's position
+                // frame already exists, make sure its position
                 // and size reflect the information in wxAuiPaneInfo
-                if ((p.GetFrame()->GetPosition() != p.GetFloatingPosition())
+                if ((p.GetFrame()->GetPosition() != p.GetFloatingPosition()) 
                     || (p.GetFrame()->GetSize() != p.GetFloatingSize()))
                 {
                     p.GetFrame()->SetSize(p.GetFloatingPosition().x, p.GetFloatingPosition().y,
@@ -3486,7 +3521,7 @@ void wxAuiManager::Update()
             }
         }
     }
-
+    
 
     // create a layout for all of the panes
     sizer = LayoutAll(m_panes, m_docks, m_uiParts, false);
@@ -3895,12 +3930,12 @@ bool wxAuiManager::DoDrop(wxAuiDockInfoArray& docks, wxAuiPaneInfoArray& panes,
             if ((part->dock->dock_direction == wxAUI_DOCK_TOP) || (part->dock->dock_direction == wxAUI_DOCK_LEFT))
             {
                 int row = drop.GetRow();
-                wxAuiDoInsertDockRow(panes, part->dock->dock_direction, part->dock->dock_layer, part->dock->dock_row);
+                Aui_DoInsertDockRow(panes, part->dock->dock_direction, part->dock->dock_layer, part->dock->dock_row);
                 drop.SetRow(row);
             }
             else
             {
-                wxAuiDoInsertDockRow(panes, part->dock->dock_direction, part->dock->dock_layer, part->dock->dock_row+1);
+                Aui_DoInsertDockRow(panes, part->dock->dock_direction, part->dock->dock_layer, part->dock->dock_row+1);
                 drop.SetRow(part->dock->dock_row+1);
             }
         }
@@ -3912,13 +3947,13 @@ bool wxAuiManager::DoDrop(wxAuiDockInfoArray& docks, wxAuiPaneInfoArray& panes,
         {
             if ((part->dock->dock_direction == wxAUI_DOCK_TOP) || (part->dock->dock_direction == wxAUI_DOCK_LEFT))
             {
-                wxAuiDoInsertDockRow(panes, part->dock->dock_direction, part->dock->dock_layer, part->dock->dock_row+1);
+                Aui_DoInsertDockRow(panes, part->dock->dock_direction, part->dock->dock_layer, part->dock->dock_row+1);
                 drop.SetRow(part->dock->dock_row+1);
             }
             else
             {
                 int row = drop.GetRow();
-                wxAuiDoInsertDockRow(panes, part->dock->dock_direction, part->dock->dock_layer, part->dock->dock_row);
+                Aui_DoInsertDockRow(panes, part->dock->dock_direction, part->dock->dock_layer, part->dock->dock_row);
                 drop.SetRow(row);
             }
         }
@@ -3975,9 +4010,9 @@ bool wxAuiManager::DoDrop(wxAuiDockInfoArray& docks, wxAuiPaneInfoArray& panes,
                 page = hitPane->GetPage();
             }
         }
+        
 
-
-        wxAuiDoInsertPage(panes, hitPane->GetDirection(), hitPane->GetLayer(), hitPane->GetRow(), hitPane->GetPosition(), page);
+        Aui_DoInsertPage(panes, hitPane->GetDirection(), hitPane->GetLayer(), hitPane->GetRow(), hitPane->GetPosition(), page);
         drop.Dock().SetDirection(hitPane->GetDirection()).SetLayer(hitPane->GetLayer()).SetRow(hitPane->GetRow()).SetPosition(hitPane->GetPosition()).SetPage(page);
         return ProcessDockResult(target, drop);
     }
@@ -4023,7 +4058,7 @@ bool wxAuiManager::DoDrop(wxAuiDockInfoArray& docks, wxAuiPaneInfoArray& panes,
                     break;
             }
 
-            wxAuiDoInsertDockRow(panes, part->dock->dock_direction, layer, 0);
+            Aui_DoInsertDockRow(panes, part->dock->dock_direction, layer, 0);
             drop.Dock(). SetDirection(part->dock->dock_direction). SetLayer(layer).SetRow(0).SetPosition(0);
             return ProcessDockResult(target, drop);
         }
@@ -4101,7 +4136,7 @@ bool wxAuiManager::DoDrop(wxAuiDockInfoArray& docks, wxAuiPaneInfoArray& panes,
 
         if (insertDockRow)
         {
-            wxAuiDoInsertDockRow(panes, insertDir, insertLayer, insertRow);
+            Aui_DoInsertDockRow(panes, insertDir, insertLayer, insertRow);
             drop.Dock().SetDirection(insertDir).SetLayer(insertLayer).SetRow(insertRow).SetPosition(0);
             return ProcessDockResult(target, drop);
         }
@@ -4129,7 +4164,7 @@ bool wxAuiManager::DoDrop(wxAuiDockInfoArray& docks, wxAuiPaneInfoArray& panes,
         if (offset <= size/2)
         {
             dropPosition = part->pane->GetPosition();
-            wxAuiDoInsertPane(panes, part->pane->GetDirection(), part->pane->GetLayer(), part->pane->GetRow(), part->pane->GetPosition());
+            Aui_DoInsertPane(panes, part->pane->GetDirection(), part->pane->GetLayer(), part->pane->GetRow(), part->pane->GetPosition());
         }
 
         // if we are in the bottom/right part of the pane,
@@ -4137,7 +4172,7 @@ bool wxAuiManager::DoDrop(wxAuiDockInfoArray& docks, wxAuiPaneInfoArray& panes,
         if (offset > size/2)
         {
             dropPosition = part->pane->GetPosition()+1;
-            wxAuiDoInsertPane(panes, part->pane->GetDirection(), part->pane->GetLayer(), part->pane->GetRow(), part->pane->GetPosition()+1);
+            Aui_DoInsertPane(panes, part->pane->GetDirection(), part->pane->GetLayer(), part->pane->GetRow(), part->pane->GetPosition()+1);
         }
 
         drop.Dock().SetDirection(part->dock->dock_direction).SetLayer(part->dock->dock_layer).SetRow(part->dock->dock_row).SetPosition(dropPosition);
@@ -4196,7 +4231,7 @@ bool wxAuiManager::DoDropExternal(wxAuiPaneInfo& drop, const wxPoint& pt, const
                     targetCtrl->GetEventHandler()->ProcessEvent(e);
 
                     if (!e.IsAllowed())
-                    {
+                    {   
                         // no answer or negative answer
                         return false;
                     }
@@ -4209,12 +4244,12 @@ bool wxAuiManager::DoDropExternal(wxAuiPaneInfo& drop, const wxPoint& pt, const
                     e.Veto(); // dropping must be explicitly approved by control owner
                     targetCtrl->GetEventHandler()->ProcessEvent(e);
                     if(e.GetVeto())
-                    {
+                    {   
                         // no answer or negative answer
                         return false;
                     }
                 }
-
+                
                 wxAuiPaneInfo dropExternal=drop;
                 dropExternal.SetFlag(wxAuiPaneInfo::optionActive,false);
                 dropExternal.SetFlag(wxAuiPaneInfo::optionActiveNotebook,false);
@@ -4226,9 +4261,18 @@ bool wxAuiManager::DoDropExternal(wxAuiPaneInfo& drop, const wxPoint& pt, const
                     DetachPane(drop.GetWindow());
                     drop.GetWindow()->Reparent(targetCtrl);
 
+                    //fixme: (MJM) The below (Double update) is inefficient and can probably be replaced with a better mechanism.
+                    // Ensure active before doing actual display.
+                    otherMgr->SetActivePane(drop.GetWindow());
+
                     // Update the layout to realize new position and e.g. form notebooks if needed.
                     otherMgr->Update();
-                    otherMgr->DoFrameLayout();
+
+                    // If a notebook formed we may have lost our active status so set it again.
+                    otherMgr->SetActivePane(drop.GetWindow());
+
+                    // Update once again so that notebook can reflect our new active status.
+                    otherMgr->Update();
 
                     // Make changes visible to user.
                     otherMgr->Repaint();
@@ -4430,7 +4474,8 @@ void wxAuiManager::StartPaneDrag(wxWindow* paneWindow, const wxPoint& offset)
 wxRect wxAuiManager::CalculateHintRect(wxWindow* paneWindow, const wxPoint& pt, const wxPoint& offset)
 {
     wxRect rect;
-
+    m_doingHintCalculation=true;
+    
     // we need to paint a hint rectangle; to find out the exact hint rectangle,
     // we will create a new temporary layout and then measure the resulting
     // rectangle; we will create a copy of the docking structures (m_dock)
@@ -4446,7 +4491,10 @@ wxRect wxAuiManager::CalculateHintRect(wxWindow* paneWindow, const wxPoint& pt,
     hint.Show();
 
     if (!hint.IsOk())
-        return rect;
+    {
+        m_doingHintCalculation=false;
+        return rect;        
+    }
 
     CopyDocksAndPanes(docks, panes, m_docks, m_panes);
 
@@ -4462,10 +4510,11 @@ wxRect wxAuiManager::CalculateHintRect(wxWindow* paneWindow, const wxPoint& pt,
         }
     }
 
-
+       
     // find out where the new pane would be
     if (!DoDrop(docks, panes, hint, pt, offset))
     {
+        m_doingHintCalculation=false;
         return rect;
     }
 
@@ -4490,8 +4539,13 @@ wxRect wxAuiManager::CalculateHintRect(wxWindow* paneWindow, const wxPoint& pt,
             {
                 if(pages[j]->GetName() == wxT("__HINT__"))
                 {
-                    rect = wxRect(part.m_tab_container->GetPage(part.m_tab_container->GetActivePage()).GetWindow()->GetPosition(),
-                    part.m_tab_container->GetPage(part.m_tab_container->GetActivePage()).GetWindow()->GetSize());
+                    int activePage=part.m_tab_container->GetActivePage();
+                    //It is possible in some instances (when forming a new notebook via drag) - that no page is yet active, if this is the case act as if the first one is active.
+                    if(activePage==-1)
+                        activePage=0;
+
+                    rect = wxRect(part.m_tab_container->GetPage(activePage).GetWindow()->GetPosition(),
+                    part.m_tab_container->GetPage(activePage).GetWindow()->GetSize());
                     break;
                 }
             }
@@ -4519,6 +4573,7 @@ wxRect wxAuiManager::CalculateHintRect(wxWindow* paneWindow, const wxPoint& pt,
 
     if (rect.IsEmpty())
     {
+        m_doingHintCalculation=false;
         return rect;
     }
 
@@ -4531,6 +4586,7 @@ wxRect wxAuiManager::CalculateHintRect(wxWindow* paneWindow, const wxPoint& pt,
         rect.x -= rect.GetWidth();
     }
 
+    m_doingHintCalculation=false;
     return rect;
 }
 
@@ -4587,7 +4643,7 @@ void wxAuiManager::DrawHintRect(wxWindow* paneWindow, const wxPoint& pt, const w
                     targetCtrl->GetEventHandler()->ProcessEvent(e);
 
                     if (!e.IsAllowed())
-                    {
+                    {   
                         // no answer or negative answer
                         HideHint();
                         return;
@@ -4601,13 +4657,13 @@ void wxAuiManager::DrawHintRect(wxWindow* paneWindow, const wxPoint& pt, const w
                     e.Veto(); // dropping must be explicitly approved by control owner
                     targetCtrl->GetEventHandler()->ProcessEvent(e);
                     if(e.GetVeto())
-                    {
+                    {   
                         // no answer or negative answer
                         HideHint();
                         return;
                     }
                 }
-
+                
                 otherMgr->AddPane(paneWindow);
                 wxPoint clientPt = otherMgr->GetManagedWindow()->ScreenToClient(screenPt);
                 wxRect hint_rect = otherMgr->CalculateHintRect(paneWindow, clientPt, offset);
@@ -4624,8 +4680,8 @@ void wxAuiManager::DrawHintRect(wxWindow* paneWindow, const wxPoint& pt, const w
             }
         }
     }
-
-    //Normal case: calculate and display hint for a drop in our own window.
+    
+    //Normal case: calculate and display hint for a drop in our own window.    
     wxRect rect = CalculateHintRect(paneWindow, pt, offset);
     if (rect.IsEmpty())
     {
@@ -4809,7 +4865,7 @@ void wxAuiManager::OnFloatingPaneMoved(wxWindow* wnd, wxDirection dir)
         DoDrop(m_docks, m_panes, pane, clientPt, actionOffset);
     }
 
-    // if the pane is still floating, update it's floating
+    // if the pane is still floating, update its floating
     // position (that we store)
     if (pane.IsFloating())
     {
@@ -4823,9 +4879,26 @@ void wxAuiManager::OnFloatingPaneMoved(wxWindow* wnd, wxDirection dir)
         RestoreMaximizedPane();
     }
 
+    HideHint();
+
+    //fixme: (MJM) The below (Triple update) is inefficient and can probably be replaced with a better mechanism.    
+    // Update the layout to realize new position and e.g. form notebooks if needed.
     Update();
 
-    HideHint();
+    // Ensure active before doing actual display.
+    SetActivePane(pane.GetWindow());
+
+    // Update the layout to realize new position and e.g. form notebooks if needed.
+    Update();
+
+    // If a notebook formed we may have lost our active status so set it again.
+    SetActivePane(pane.GetWindow());
+
+    // Update once again so that notebook can reflect our new active status.
+    Update();
+
+    // Make changes visible to user.
+    Repaint();
 }
 
 void wxAuiManager::OnFloatingPaneResized(wxWindow* wnd, const wxRect& rect)
@@ -5241,7 +5314,7 @@ void wxAuiManager::OnLeftDown(wxMouseEvent& evt)
                     GetManagedWindow()->GetEventHandler()->ProcessEvent(e);
                     vetoed = !e.IsAllowed();
                 }
-
+                
                 // Either no event sent or event not vetoed - either way go ahead and do the change
                 if(!vetoed)
                 {
@@ -5449,7 +5522,7 @@ bool wxAuiManager::DoEndResizeAction(wxMouseEvent& evt)
             wxAuiPaneInfo& p = *dock.panes.Item(i);
             if (p.GetWindow() == pane->GetWindow())
                 panePosition = i;
-
+            
             // Don't include all the panes from a notenook in the calculation, only the first one.
             if(i==0 || p.GetPosition()!=dock.panes.Item(i-1)->GetPosition())
             {
@@ -5523,7 +5596,7 @@ bool wxAuiManager::DoEndResizeAction(wxMouseEvent& evt)
         // check against the pane's minimum size, if specified. please note
         // that this is not enough to ensure that the minimum size will
         // not be violated, because the whole frame might later be shrunk,
-        // causing the size of the pane to violate it's minimum size
+        // causing the size of the pane to violate its minimum size
         if (pane->GetMinSize().IsFullySpecified())
         {
             minSize = 0;
@@ -5719,7 +5792,7 @@ void wxAuiManager::OnLeftUp(wxMouseEvent& evt)
             e.SetEventObject(GetManagedWindow());
             GetManagedWindow()->GetEventHandler()->ProcessEvent(e);
         }
-
+        
         m_frame->ReleaseMouse();
 
         // If we are a wxAuiNotebook then we must fire off a wxEVT_COMMAND_AUINOTEBOOK_END_DRAG event to notify user of change.
@@ -5741,7 +5814,7 @@ void wxAuiManager::OnLeftUp(wxMouseEvent& evt)
             e.SetEventObject(GetManagedWindow());
             GetManagedWindow()->GetEventHandler()->ProcessEvent(e);
         }
-
+        
         // Try to find the pane.
         wxAuiPaneInfo& pane = GetPane(m_actionWindow);
         wxASSERT_MSG(pane.IsOk(), wxT("Pane window not found"));
@@ -5755,7 +5828,10 @@ void wxAuiManager::OnLeftUp(wxMouseEvent& evt)
         {
             DoDrop(m_docks, m_panes, pane, pt, wxPoint(0,0));
         }
+        
 
+        //fixme: (MJM) The below (Triple update) is inefficient and can probably be replaced with a better mechanism.
+        GetManagedWindow()->Freeze();
 
         // Update the layout to realize new position and e.g. form notebooks if needed.
         Update();
@@ -5763,9 +5839,20 @@ void wxAuiManager::OnLeftUp(wxMouseEvent& evt)
         // Ensure active before doing actual display.
         SetActivePane(pane.GetWindow());
 
+        // Update the layout to realize new position and e.g. form notebooks if needed.
+        Update();
+
+        // If a notebook formed we may have lost our active status so set it again.
+        SetActivePane(pane.GetWindow());
+
+        // Update once again so that notebook can reflect our new active status.
+        Update();
+
+        GetManagedWindow()->Thaw();
         // Make changes visible to user.
         Repaint();
 
+        
         // Cancel the action and release the mouse.
         m_action = actionNone;
         m_frame->ReleaseMouse();
@@ -5865,7 +5952,7 @@ void wxAuiManager::OnRightUp(wxMouseEvent& evt)
 
 void wxAuiManager::OnMiddleDown(wxMouseEvent& evt)
 {
-    wxAuiDockUIPart* part = HitTest(evt.GetX(), evt.GetY());
+	wxAuiDockUIPart* part = HitTest(evt.GetX(), evt.GetY());
     if(part)
     {
         if(part->type == wxAuiDockUIPart::typePaneTab)
@@ -5936,7 +6023,7 @@ void wxAuiManager::OnMiddleUp(wxMouseEvent& evt)
 
 void wxAuiManager::ShowToolTip(wxAuiPaneInfo* pane)
 {
-    #if wxUSE_TOOLTIPS
+    #if wxUSE_TOOLTIPS 
     wxString toolTip(pane->GetToolTip());
     if(toolTip==wxT(""))
     {
@@ -5954,7 +6041,7 @@ void wxAuiManager::ShowToolTip(wxAuiPaneInfo* pane)
 
 void wxAuiManager::HideToolTip()
 {
-    #if wxUSE_TOOLTIPS
+    #if wxUSE_TOOLTIPS 
     m_frame->UnsetToolTip();
     #endif
 }
@@ -5984,7 +6071,7 @@ void wxAuiManager::OnMotion(wxMouseEvent& evt)
             m_actionDeadZone = NULL;
         }
     }
-
+    
 
     if (m_action == actionResize)
     {
@@ -6058,7 +6145,7 @@ void wxAuiManager::OnMotion(wxMouseEvent& evt)
                     e.SetEventObject(GetManagedWindow());
                     GetManagedWindow()->GetEventHandler()->ProcessEvent(e);
                 }
-
+        
                 // If it is a notebook pane then we don't want to float it unless we have left the notebook tab bar.
                 // Instead we want to move it around within the notebook.
                 if(m_actionPart->type==wxAuiDockUIPart::typePaneTab)
@@ -6086,14 +6173,14 @@ void wxAuiManager::OnMotion(wxMouseEvent& evt)
                                 m_actionPart->m_tab_container->TabHitTest(evt.GetX(), evt.GetY(),&hitPane);
                                 if(hitPane&&hitPane->GetPage()!=paneInfo->GetPage())
                                 {
-                                    wxMemoryDC Temp;
+                                    wxMemoryDC TempDC;
                                     bool closeButton = false;
                                     if(TabHasCloseButton(GetFlags(),*paneInfo))
                                     {
                                         closeButton = true;
                                     }
                                     int oldhitextent;
-                                    m_actionPart->m_tab_container->GetArtProvider()->GetTabSize(Temp,NULL, paneInfo->GetCaption(), paneInfo->GetBitmap(),true,closeButton ? wxAUI_BUTTON_STATE_NORMAL : wxAUI_BUTTON_STATE_HIDDEN,&oldhitextent);
+                                    m_actionPart->m_tab_container->GetArtProvider()->GetTabSize(TempDC,paneInfo->GetWindow(), paneInfo->GetCaption(), paneInfo->GetBitmap(),true,closeButton ? wxAUI_BUTTON_STATE_NORMAL : wxAUI_BUTTON_STATE_HIDDEN,&oldhitextent);
 
 
                                     closeButton=false;
@@ -6102,7 +6189,7 @@ void wxAuiManager::OnMotion(wxMouseEvent& evt)
                                         closeButton = true;
                                     }
                                     int newhitextent;
-                                    m_actionPart->m_tab_container->GetArtProvider()->GetTabSize(Temp,NULL,hitPane->GetCaption(),hitPane->GetBitmap(),false,closeButton ? wxAUI_BUTTON_STATE_NORMAL : wxAUI_BUTTON_STATE_HIDDEN,&newhitextent);
+                                    m_actionPart->m_tab_container->GetArtProvider()->GetTabSize(TempDC,hitPane->GetWindow(),hitPane->GetCaption(),hitPane->GetBitmap(),false,closeButton ? wxAUI_BUTTON_STATE_NORMAL : wxAUI_BUTTON_STATE_HIDDEN,&newhitextent);
 
                                     if(hitPane->GetPage()<paneInfo->GetPage() && newhitextent>oldhitextent)
                                     {
@@ -6119,7 +6206,7 @@ void wxAuiManager::OnMotion(wxMouseEvent& evt)
                         return;
                     }
                 }
-
+                
                 if (HasFlag(wxAUI_MGR_ALLOW_FLOATING) && paneInfo->IsFloatable())
                 {
                     m_action = actionDragFloatingPane;
@@ -6196,7 +6283,7 @@ void wxAuiManager::OnMotion(wxMouseEvent& evt)
     {
         HideToolTip();
 
-        // If the movable pane is part of a notebook and the mouse has moved back over the notebook tabs then we set the
+        // If the movable pane is part of a notebook and the mouse has moved back over the notebook tabs then we set the 
         // event type back to a caption click so that we can move the actual tab around instead of drawing hints.
         if(m_actionPart->type==wxAuiDockUIPart::typePaneTab)
         {
@@ -6220,7 +6307,7 @@ void wxAuiManager::OnMotion(wxMouseEvent& evt)
 
         // Reduces flicker.
         m_frame->Update();
-
+        
         // If we are a wxAuiNotebook then we must fire off a wxEVT_COMMAND_AUINOTEBOOK_DRAG_MOTION event to notify user of change.
         if(wxDynamicCast(GetManagedWindow(),wxAuiNotebook))
         {
@@ -6240,6 +6327,7 @@ void wxAuiManager::OnMotion(wxMouseEvent& evt)
         pane.SetFlag(wxAuiPaneInfo::actionPane, true);
 
         wxPoint pt = evt.GetPosition();
+
         DoDrop(m_docks, m_panes, pane, pt, m_actionOffset);
 
         // if DoDrop() decided to float the pane, set up
@@ -6284,7 +6372,7 @@ void wxAuiManager::OnMotion(wxMouseEvent& evt)
                 {
                     HideToolTip();
                 }
-
+                
                 wxAuiTabContainerButton* hitbutton;
                 if(part->m_tab_container->ButtonHitTest(evt.m_x,evt.m_y,&hitbutton))
                 {
@@ -6306,7 +6394,7 @@ void wxAuiManager::OnMotion(wxMouseEvent& evt)
                         m_hoverButton2->curState = wxAUI_BUTTON_STATE_HOVER;
                         Repaint();
                     }
-
+                    
                     return;
                 }
             }
@@ -6348,7 +6436,7 @@ void wxAuiManager::OnMotion(wxMouseEvent& evt)
         {
             HideToolTip();
         }
-
+        
         if (m_hoverButton||m_hoverButton2)
         {
             m_hoverButton = NULL;
@@ -6408,8 +6496,8 @@ void wxAuiManager::OnChildFocus(wxChildFocusEvent& evt)
             }
         }
     }
-
-    // when a child pane has it's focus set, we should change the
+ 
+    // when a child pane has its focus set, we should change the
     // pane's active state to reflect this. (this is only true if
     // active panes are allowed by the owner)
     if (HasFlag(wxAUI_MGR_ALLOW_ACTIVE_PANE))
@@ -6486,26 +6574,26 @@ void wxAuiManager::OnPaneButton(wxAuiManagerEvent& evt)
             Update();
         }
     }
-    else if (evt.button == wxAUI_BUTTON_PIN && (m_flags & wxAUI_MGR_ALLOW_FLOATING) && pane.IsFloatable())
-    {
-        if (pane.IsMaximized())
-        {
-             // If the pane is maximized, the original state must be restored
-             // before trying to float the pane, otherwise the other panels
-             // wouldn't appear correctly when it becomes floating.
-             wxAuiManagerEvent e(wxEVT_AUI_PANE_RESTORE);
-             e.SetManager(this);
-             e.SetPane(evt.pane);
-             ProcessMgrEvent(e);
-
-             if (e.GetVeto())
-             {
-                 // If it can't be restored, it can't be floated neither.
+    else if (evt.button == wxAUI_BUTTON_PIN && (m_flags & wxAUI_MGR_ALLOW_FLOATING) && pane.IsFloatable()) 
+    { 
+        if (pane.IsMaximized()) 
+        { 
+             // If the pane is maximized, the original state must be restored 
+             // before trying to float the pane, otherwise the other panels 
+             // wouldn't appear correctly when it becomes floating. 
+             wxAuiManagerEvent e(wxEVT_AUI_PANE_RESTORE); 
+             e.SetManager(this); 
+             e.SetPane(evt.pane); 
+             ProcessMgrEvent(e); 
+
+             if (e.GetVeto()) 
+             { 
+                 // If it can't be restored, it can't be floated neither. 
                  return;
-             }
-             RestorePane(pane);
-        }
-        pane.Float();
+             } 
+             RestorePane(pane); 
+        } 
+        pane.Float(); 
         Update();
     }
     else if (evt.button == wxAUI_BUTTON_LEFT || evt.button == wxAUI_BUTTON_UP)
diff --git a/src/aui/tabart.cpp b/src/aui/tabart.cpp
index 801ff48..5751a2b 100755
--- a/src/aui/tabart.cpp
+++ b/src/aui/tabart.cpp
@@ -7,8 +7,8 @@
 // Created:     2012-03-21
 // RCS-ID:      $Id:$
 // Copyright:   (C) Copyright 2006, Kirix Corporation, All Rights Reserved
-//                            2012, Jens Lody for the code related to left
-//                                  and right positioning
+//                            2012, Jens Lody for the code related to left 
+//                                  and right positioning 
 // Licence:     wxWindows Library Licence, Version 3.1
 ///////////////////////////////////////////////////////////////////////////////
 
@@ -132,15 +132,15 @@ static const unsigned char left_bits[] = {
    0x1f, 0xfe, 0x0f, 0xfe, 0x1f, 0xfe, 0x3f, 0xfe, 0x7f, 0xfe, 0xff, 0xfe,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
 
-static const unsigned char up_bits[] = {
-   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xfc,
-   0x3f, 0xf8, 0x1f, 0xf0, 0x0f, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+static const unsigned char up_bits[] = { 
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xfc, 
+   0x3f, 0xf8, 0x1f, 0xf0, 0x0f, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }; 
 
-static const unsigned char down_bits[] = {
-   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-   0xff, 0xff, 0x07, 0xf0, 0x0f, 0xf8, 0x1f, 0xfc, 0x3f, 0xfe, 0x7f, 0xff,
-   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+static const unsigned char down_bits[] = { 
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
+   0xff, 0xff, 0x07, 0xf0, 0x0f, 0xf8, 0x1f, 0xfc, 0x3f, 0xfe, 0x7f, 0xff, 
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }; 
 
 static const unsigned char right_bits[] = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0x9f, 0xff, 0x1f, 0xff,
@@ -198,10 +198,10 @@ wxAuiGenericTabArt::wxAuiGenericTabArt()
     m_activeLeftBmp = wxAuiBitmapFromBits(left_bits, 16, 16, *wxBLACK);
     m_disabledLeftBmp = wxAuiBitmapFromBits(left_bits, 16, 16, wxColour(128,128,128));
 
-    m_activeUpBmp = wxAuiBitmapFromBits(up_bits, 16, 16, *wxBLACK);
-    m_disabledUpBmp = wxAuiBitmapFromBits(up_bits, 16, 16, wxColour(128,128,128));
+    m_activeUpBmp = wxAuiBitmapFromBits(up_bits, 16, 16, *wxBLACK); 
+    m_disabledUpBmp = wxAuiBitmapFromBits(up_bits, 16, 16, wxColour(128,128,128)); 
 
-    m_activeDownBmp = wxAuiBitmapFromBits(down_bits, 16, 16, *wxBLACK);
+    m_activeDownBmp = wxAuiBitmapFromBits(down_bits, 16, 16, *wxBLACK); 
     m_disabledDownBmp = wxAuiBitmapFromBits(down_bits, 16, 16, wxColour(128,128,128));
 
     m_activeRightBmp = wxAuiBitmapFromBits(right_bits, 16, 16, *wxBLACK);
@@ -229,9 +229,9 @@ void wxAuiGenericTabArt::SetFlags(unsigned int flags)
 
 void wxAuiGenericTabArt::SetSizingInfo(const wxSize& tabCtrlSize, size_t tabCount)
 {
-    if (IsHorizontal())
-    {
-        m_fixedTabWidth = 100;
+    if (IsHorizontal()) 
+    { 
+        m_fixedTabWidth = 100; 
         int totWidth = (int)tabCtrlSize.x - GetIndentSize() - 4;
 
         if (m_flags & wxAUI_NB_CLOSE_BUTTON)
@@ -247,7 +247,7 @@ void wxAuiGenericTabArt::SetSizingInfo(const wxSize& tabCtrlSize, size_t tabCoun
 
         if (m_fixedTabWidth < 100)
             m_fixedTabWidth = 100;
-
+ 
         if (m_fixedTabWidth > totWidth/2)
             m_fixedTabWidth = totWidth/2;
 
@@ -256,33 +256,33 @@ void wxAuiGenericTabArt::SetSizingInfo(const wxSize& tabCtrlSize, size_t tabCoun
 
         m_tabCtrlHeight = tabCtrlSize.y;
     }
-    else
-    {
-        m_fixedTabWidth = 100;
+    else 
+    { 
+        m_fixedTabWidth = 100; 
 
         //Below is only necessary for left/right notebooks where the tabs themselves run upwards (instead of left to right) - we don't support this currently so commenting it out.
         #if 0
-        int totHeight = (int)tabCtrlSize.y - GetIndentSize() - 4;
-        if (m_flags & wxAUI_NB_CLOSE_BUTTON)
-            totHeight -= m_activeCloseBmp.GetHeight();
-        if (m_flags & wxAUI_NB_WINDOWLIST_BUTTON)
-            totHeight -= m_activeWindowListBmp.GetHeight();
-
-        if (tabCount > 0)
-        {
-            m_fixedTabWidth = totHeight/(int)tabCount;
+        int totHeight = (int)tabCtrlSize.y - GetIndentSize() - 4; 
+        if (m_flags & wxAUI_NB_CLOSE_BUTTON) 
+            totHeight -= m_activeCloseBmp.GetHeight(); 
+        if (m_flags & wxAUI_NB_WINDOWLIST_BUTTON) 
+            totHeight -= m_activeWindowListBmp.GetHeight(); 
+
+        if (tabCount > 0) 
+        { 
+            m_fixedTabWidth = totHeight/(int)tabCount; 
         }
-        if (m_fixedTabWidth < 20)
-           m_fixedTabWidth = 20;
-        if (m_fixedTabWidth > totHeight/2)
-           m_fixedTabWidth = totHeight/2;
-
-        if (m_fixedTabWidth > 60)
-            m_fixedTabWidth = 60;
+        if (m_fixedTabWidth < 20) 
+           m_fixedTabWidth = 20; 
+        if (m_fixedTabWidth > totHeight/2) 
+           m_fixedTabWidth = totHeight/2; 
+ 
+        if (m_fixedTabWidth > 60) 
+            m_fixedTabWidth = 60; 
         #endif
-
-        m_tabCtrlWidth = tabCtrlSize.x;
-    }
+ 
+        m_tabCtrlWidth = tabCtrlSize.x; 
+    } 
 }
 
 
@@ -292,44 +292,44 @@ void wxAuiGenericTabArt::DrawBackground(wxDC& dc, wxWindow* WXUNUSED(wnd), const
 
     wxColor topColor      = m_baseColour.ChangeLightness(90);
     wxColor bottomColor   = m_baseColour.ChangeLightness(170);
-    wxRect bgRect, baseRect;
+    wxRect bgRect, baseRect; 
 
-    wxDirection d;
-    if (!HasFlag(wxAUI_NB_TOP))
-        bgRect = wxRect(rect.x, rect.y, rect.width+2, rect.height);
-    else //for wxAUI_NB_TOP
-        bgRect = wxRect(rect.x, rect.y, rect.width+2, rect.height-3);
+    wxDirection d; 
+    if (!HasFlag(wxAUI_NB_TOP)) 
+        bgRect = wxRect(rect.x, rect.y, rect.width+2, rect.height); 
+    else //for wxAUI_NB_TOP 
+        bgRect = wxRect(rect.x, rect.y, rect.width+2, rect.height-3); 
 
     // draw base lines
 
     int y = rect.GetHeight();
     int w = rect.GetWidth();
 
-    if (HasFlag(wxAUI_NB_BOTTOM))
-    {
-         baseRect = wxRect(-1, 0, w + 2, 4);
-         d = wxNORTH;
-    }
-    else if (HasFlag(wxAUI_NB_LEFT))
-    {
-        baseRect = wxRect(w - 5, -1, w, y + 2);
-        d = wxEAST;
-    }
-    else if (HasFlag(wxAUI_NB_RIGHT))
-    {
-         baseRect = wxRect(0, -1, 5, y + 2);
-         d = wxWEST;
-    }
-    else //for wxAUI_NB_TOP
-    {
-        baseRect = wxRect (-1, y - 4, w + 2, 4);
-        d = wxSOUTH;
-    }
-
-    dc.SetPen(m_borderPen);
-    dc.SetBrush(m_baseColourBrush);
-    dc.GradientFillLinear(bgRect, topColor, bottomColor,d);
-    dc.DrawRectangle(baseRect);
+    if (HasFlag(wxAUI_NB_BOTTOM)) 
+    { 
+         baseRect = wxRect(-1, 0, w + 2, 4); 
+         d = wxNORTH; 
+    } 
+    else if (HasFlag(wxAUI_NB_LEFT)) 
+    { 
+        baseRect = wxRect(w - 5, -1, w, y + 2); 
+        d = wxEAST; 
+    } 
+    else if (HasFlag(wxAUI_NB_RIGHT)) 
+    { 
+         baseRect = wxRect(0, -1, 5, y + 2); 
+         d = wxWEST; 
+    } 
+    else //for wxAUI_NB_TOP 
+    { 
+        baseRect = wxRect (-1, y - 4, w + 2, 4); 
+        d = wxSOUTH; 
+    } 
+
+    dc.SetPen(m_borderPen); 
+    dc.SetBrush(m_baseColourBrush); 
+    dc.GradientFillLinear(bgRect, topColor, bottomColor,d); 
+    dc.DrawRectangle(baseRect); 
 }
 
 
@@ -369,29 +369,29 @@ void wxAuiGenericTabArt::DrawTab(wxDC& dc, wxWindow* wnd, const wxAuiPaneInfo& p
                                  closeButtonState,
                                  xExtent);
 
-    wxCoord tabHeight = tabSize.y + 1;
+    wxCoord tabHeight = tabSize.y + 1; 
     wxCoord tabWidth = tabSize.x;
     wxCoord tabX = inRect.x;
     wxCoord tabY = inRect.y + inRect.height - tabHeight;
 
-    if (HasFlag(wxAUI_NB_LEFT))
-    {
-        tabHeight += 1;
-        tabWidth = inRect.width - 5;
-        tabY = inRect.y - 1;
-    }
-    if (HasFlag(wxAUI_NB_RIGHT))
-    {
-        tabHeight += 1;
-        tabWidth = inRect.width - 5;
-        tabY = inRect.y - 1;
-        tabX += 4;
-    }
-    if (! page.GetBitmap().IsOk())
-    {
-        tabHeight += 1;
-        tabY -= 1;
-    }
+    if (HasFlag(wxAUI_NB_LEFT)) 
+    { 
+        tabHeight += 1; 
+        tabWidth = inRect.width - 5; 
+        tabY = inRect.y - 1; 
+    } 
+    if (HasFlag(wxAUI_NB_RIGHT)) 
+    { 
+        tabHeight += 1; 
+        tabWidth = inRect.width - 5; 
+        tabY = inRect.y - 1; 
+        tabX += 4; 
+    } 
+    if (! page.GetBitmap().IsOk()) 
+    { 
+        tabHeight += 1; 
+        tabY -= 1; 
+    } 
 
     caption = page.caption;
 
@@ -416,17 +416,17 @@ void wxAuiGenericTabArt::DrawTab(wxDC& dc, wxWindow* wnd, const wxAuiPaneInfo& p
     int clipWidth = tabWidth;
     if (tabX + clipWidth > inRect.x + inRect.width)
         clipWidth = (inRect.x + inRect.width) - tabX;
-    if (tabY + tabHeight > inRect.y + inRect.height)
-        clipHeight = (inRect.y + inRect.height) - tabY;
+    if (tabY + tabHeight > inRect.y + inRect.height) 
+        clipHeight = (inRect.y + inRect.height) - tabY; 
 
     // since the above code above doesn't play well with WXDFB or WXCOCOA,
     // we'll just use a rectangle for the clipping region for now --
     dc.SetClippingRegion(tabX, tabY, clipWidth+1, clipHeight+1);
 
-    wxDirection direction;
+    wxDirection direction; 
 
     wxPoint borderPoints[6];
-    if (HasFlag(wxAUI_NB_BOTTOM))
+    if (HasFlag(wxAUI_NB_BOTTOM)) 
     {
         borderPoints[0] = wxPoint(tabX,             tabY);
         borderPoints[1] = wxPoint(tabX,             tabY+tabHeight-6);
@@ -434,46 +434,46 @@ void wxAuiGenericTabArt::DrawTab(wxDC& dc, wxWindow* wnd, const wxAuiPaneInfo& p
         borderPoints[3] = wxPoint(tabX+tabWidth-2, tabY+tabHeight-4);
         borderPoints[4] = wxPoint(tabX+tabWidth,   tabY+tabHeight-6);
         borderPoints[5] = wxPoint(tabX+tabWidth,   tabY);
-        direction = wxNORTH;
-    }
-    else  if (HasFlag(wxAUI_NB_LEFT))
-    {
-        borderPoints[0] = wxPoint(tabX+tabWidth, tabY);
-        borderPoints[1] = wxPoint(tabX+2,         tabY);
-        borderPoints[2] = wxPoint(tabX,           tabY+2);
-        borderPoints[3] = wxPoint(tabX,           tabY+tabHeight-2);
-        borderPoints[4] = wxPoint(tabX+2,         tabY+tabHeight);
-        borderPoints[5] = wxPoint(tabX+tabWidth, tabY+tabHeight);
-        direction = wxEAST;
-    }
-    else  if (HasFlag(wxAUI_NB_RIGHT))
-    {
-        borderPoints[0] = wxPoint(tabX,             tabY);
-        borderPoints[1] = wxPoint(tabX+tabWidth-2, tabY);
-        borderPoints[2] = wxPoint(tabX+tabWidth,   tabY+2);
-        borderPoints[3] = wxPoint(tabX+tabWidth,   tabY+tabHeight-2);
-        borderPoints[4] = wxPoint(tabX+tabWidth-2, tabY+tabHeight);
-        borderPoints[5] = wxPoint(tabX,             tabY+tabHeight);
+        direction = wxNORTH; 
+    } 
+    else  if (HasFlag(wxAUI_NB_LEFT)) 
+    { 
+        borderPoints[0] = wxPoint(tabX+tabWidth, tabY); 
+        borderPoints[1] = wxPoint(tabX+2,         tabY); 
+        borderPoints[2] = wxPoint(tabX,           tabY+2); 
+        borderPoints[3] = wxPoint(tabX,           tabY+tabHeight-2); 
+        borderPoints[4] = wxPoint(tabX+2,         tabY+tabHeight); 
+        borderPoints[5] = wxPoint(tabX+tabWidth, tabY+tabHeight); 
+        direction = wxEAST; 
+    } 
+    else  if (HasFlag(wxAUI_NB_RIGHT)) 
+    { 
+        borderPoints[0] = wxPoint(tabX,             tabY); 
+        borderPoints[1] = wxPoint(tabX+tabWidth-2, tabY); 
+        borderPoints[2] = wxPoint(tabX+tabWidth,   tabY+2); 
+        borderPoints[3] = wxPoint(tabX+tabWidth,   tabY+tabHeight-2); 
+        borderPoints[4] = wxPoint(tabX+tabWidth-2, tabY+tabHeight); 
+        borderPoints[5] = wxPoint(tabX,             tabY+tabHeight); 
         direction = wxWEST;
     }
-    else // must be wxAUI_NB_TOP) {}
-    {
-        borderPoints[0] = wxPoint(tabX,             tabY+tabHeight-4);
-        borderPoints[1] = wxPoint(tabX,             tabY+2);
-        borderPoints[3] = wxPoint(tabX+tabWidth-2, tabY);
-        borderPoints[4] = wxPoint(tabX+tabWidth,   tabY+2);
-        borderPoints[5] = wxPoint(tabX+tabWidth,   tabY+tabHeight-4);
-        direction = wxSOUTH;
-    }
+    else // must be wxAUI_NB_TOP) {} 
+    { 
+        borderPoints[0] = wxPoint(tabX,             tabY+tabHeight-4); 
+        borderPoints[1] = wxPoint(tabX,             tabY+2); 
+        borderPoints[3] = wxPoint(tabX+tabWidth-2, tabY); 
+        borderPoints[4] = wxPoint(tabX+tabWidth,   tabY+2); 
+        borderPoints[5] = wxPoint(tabX+tabWidth,   tabY+tabHeight-4); 
+        direction = wxSOUTH; 
+    } 
 
     int drawnTabYOff = borderPoints[1].y;
     int drawnTabHeight = borderPoints[0].y - borderPoints[1].y;
 
-    if (!IsHorizontal())
-    {
-        drawnTabHeight = borderPoints[3].y - borderPoints[2].y;
-        drawnTabYOff = borderPoints[2].y;
-    }
+    if (!IsHorizontal()) 
+    { 
+        drawnTabHeight = borderPoints[3].y - borderPoints[2].y; 
+        drawnTabYOff = borderPoints[2].y; 
+    } 
 
 
     if (page.HasFlag(wxAuiPaneInfo::optionActiveNotebook))
@@ -484,76 +484,76 @@ void wxAuiGenericTabArt::DrawTab(wxDC& dc, wxWindow* wnd, const wxAuiPaneInfo& p
         wxRect r(tabX, tabY, tabWidth, tabHeight);
         dc.SetPen(wxPen(m_activeColour));
         dc.SetBrush(wxBrush(m_activeColour));
-        if (HasFlag(wxAUI_NB_RIGHT))
-            dc.DrawRectangle(r.x, r.y+1, r.width, r.height-1);
-        else if (HasFlag(wxAUI_NB_LEFT))
-            dc.DrawRectangle(r.x+1, r.y+1, r.width, r.height-1);
-        else // must be wxAUI_NB_TOP or wxAUI_NB_BOTTOM
-            dc.DrawRectangle(r.x+1, r.y+1, r.width-1, r.height-4);
-
+        if (HasFlag(wxAUI_NB_RIGHT)) 
+            dc.DrawRectangle(r.x, r.y+1, r.width, r.height-1); 
+        else if (HasFlag(wxAUI_NB_LEFT)) 
+            dc.DrawRectangle(r.x+1, r.y+1, r.width, r.height-1); 
+        else // must be wxAUI_NB_TOP or wxAUI_NB_BOTTOM 
+            dc.DrawRectangle(r.x+1, r.y+1, r.width-1, r.height-4); 
+ 
         // this white helps fill out the gradient at the top of the tab
         dc.SetPen(*wxWHITE_PEN);
         dc.SetBrush(*wxWHITE_BRUSH);
-        if (HasFlag(wxAUI_NB_RIGHT))
-            dc.DrawRectangle(r.x+1, r.y+1, r.width-2, r.height-1);
-        else if (HasFlag(wxAUI_NB_LEFT))
-            dc.DrawRectangle(r.x+2, r.y+1, r.width-2, r.height-1);
-        else // must be wxAUI_NB_TOP or wxAUI_NB_BOTTOM
+        if (HasFlag(wxAUI_NB_RIGHT)) 
+            dc.DrawRectangle(r.x+1, r.y+1, r.width-2, r.height-1); 
+        else if (HasFlag(wxAUI_NB_LEFT)) 
+            dc.DrawRectangle(r.x+2, r.y+1, r.width-2, r.height-1); 
+        else // must be wxAUI_NB_TOP or wxAUI_NB_BOTTOM 
             dc.DrawRectangle(r.x+2, r.y+1, r.width-3, r.height-4);
 
         // these two points help the rounded corners appear more antialiased
         dc.SetPen(wxPen(m_activeColour));
-        if (HasFlag(wxAUI_NB_RIGHT))
-        {
-            dc.DrawPoint(r.x+r.width-2, r.y+1);
-            dc.DrawPoint(r.x+r.width-2, r.y+r.height-1);
-        }
-        else if (HasFlag(wxAUI_NB_LEFT))
-        {
-            dc.DrawPoint(r.x+2, r.y+1);
-            dc.DrawPoint(r.x+2, r.y+r.height-1);
-        }
-        else if (HasFlag(wxAUI_NB_BOTTOM))
-        {
-            dc.DrawPoint(r.x+2, r.y+r.height-5);
-            dc.DrawPoint(r.x+r.width-2, r.y+r.height-5);
-        }
-        else // must be wxAUI_NB_TOP
-        {
-            dc.DrawPoint(r.x+2, r.y+1);
-            dc.DrawPoint(r.x+r.width-2, r.y+1);
-        }
-
-        if (HasFlag(wxAUI_NB_RIGHT))
-        {
-            // set rectangle down a bit for gradient drawing
-            r.SetWidth(r.GetWidth()/2);
-            r.y += 1;
-            r.height -= 1;
-        }
-        else if (HasFlag(wxAUI_NB_LEFT))
-        {
-            // set rectangle down a bit for gradient drawing
-            r.SetWidth(r.GetWidth()/2);
-            r.y += 1;
-            r.height -= 1;
-            r.x += r.width;
-        }
-        else if (HasFlag(wxAUI_NB_BOTTOM))
-        {
-            // set rectangle down a bit for gradient drawing
-            r.SetHeight(r.GetHeight()/2);
-            r.x += 2;
-            r.width -= 3;
-        }
-        else // must be wxAUI_NB_TOP
-        {
-            // set rectangle down a bit for gradient drawing
-            r.SetHeight(r.GetHeight()/2);
-            r.x += 2;
-            r.width -= 3;
-            r.y += (r.height - 2);
-        }
+        if (HasFlag(wxAUI_NB_RIGHT)) 
+        { 
+            dc.DrawPoint(r.x+r.width-2, r.y+1); 
+            dc.DrawPoint(r.x+r.width-2, r.y+r.height-1); 
+        } 
+        else if (HasFlag(wxAUI_NB_LEFT)) 
+        { 
+            dc.DrawPoint(r.x+2, r.y+1); 
+            dc.DrawPoint(r.x+2, r.y+r.height-1); 
+        } 
+        else if (HasFlag(wxAUI_NB_BOTTOM)) 
+        { 
+            dc.DrawPoint(r.x+2, r.y+r.height-5); 
+            dc.DrawPoint(r.x+r.width-2, r.y+r.height-5); 
+        } 
+        else // must be wxAUI_NB_TOP 
+        { 
+            dc.DrawPoint(r.x+2, r.y+1); 
+            dc.DrawPoint(r.x+r.width-2, r.y+1); 
+        } 
+
+        if (HasFlag(wxAUI_NB_RIGHT)) 
+        { 
+            // set rectangle down a bit for gradient drawing 
+            r.SetWidth(r.GetWidth()/2); 
+            r.y += 1; 
+            r.height -= 1; 
+        } 
+        else if (HasFlag(wxAUI_NB_LEFT)) 
+        { 
+            // set rectangle down a bit for gradient drawing 
+            r.SetWidth(r.GetWidth()/2); 
+            r.y += 1; 
+            r.height -= 1; 
+            r.x += r.width; 
+        } 
+        else if (HasFlag(wxAUI_NB_BOTTOM)) 
+        { 
+            // set rectangle down a bit for gradient drawing 
+            r.SetHeight(r.GetHeight()/2); 
+            r.x += 2; 
+            r.width -= 3; 
+        } 
+        else // must be wxAUI_NB_TOP 
+        { 
+            // set rectangle down a bit for gradient drawing 
+            r.SetHeight(r.GetHeight()/2); 
+            r.x += 2; 
+            r.width -= 3; 
+            r.y += (r.height - 2); 
+        } 
 
         // draw gradient background
         wxColor topColor = *wxWHITE;
@@ -564,54 +564,54 @@ void wxAuiGenericTabArt::DrawTab(wxDC& dc, wxWindow* wnd, const wxAuiPaneInfo& p
     {
         // draw inactive tab
 
-        wxRect rTop(tabX, tabY+1, tabWidth, tabHeight-3);
-        wxRect rBase;
+        wxRect rTop(tabX, tabY+1, tabWidth, tabHeight-3); 
+        wxRect rBase; 
 
         // start the gradent up a bit and leave the inside border inset
         // by a pixel for a 3D look.  Only the top half of the inactive
         // tab will have a slight gradient
-        if (IsHorizontal())
-        {
-            rTop.x += 3;
-            rTop.y++;
-            rTop.width -= 4;
-            rTop.height /= 2;
-            rTop.height--;
-
-            rBase = rTop;
-
-            if (HasFlag(wxAUI_NB_BOTTOM))
-            {
-                rTop.y += rTop.height;
-                rTop.y--;
-            }
-            else // must be wxAUI_NB_TOP
-            {
-                rBase.y += rBase.height;
-                rBase.y--;
-            }
-        }
-        else
-        {
-            rTop.x += 2;
-            rTop.y++;
-            rTop.width -= 2;
-            rTop.height += 3;
-            rTop.width /= 2;
-
-            rBase = rTop;
-
-            if (HasFlag(wxAUI_NB_RIGHT))
-            {
-                 rTop.x += rTop.width;
-                 rTop.x--;
-            }
-            else // must be wxAUI_NB_LEFT
-            {
-                rBase.x += rBase.width;
-                rBase.x--;
-            }
-        }
+        if (IsHorizontal()) 
+        { 
+            rTop.x += 3; 
+            rTop.y++; 
+            rTop.width -= 4; 
+            rTop.height /= 2; 
+            rTop.height--; 
+         
+            rBase = rTop; 
+
+            if (HasFlag(wxAUI_NB_BOTTOM)) 
+            { 
+                rTop.y += rTop.height; 
+                rTop.y--; 
+            } 
+            else // must be wxAUI_NB_TOP 
+            { 
+                rBase.y += rBase.height; 
+                rBase.y--; 
+            } 
+        } 
+        else 
+        { 
+            rTop.x += 2; 
+            rTop.y++; 
+            rTop.width -= 2; 
+            rTop.height += 3; 
+            rTop.width /= 2; 
+  
+            rBase = rTop; 
+
+            if (HasFlag(wxAUI_NB_RIGHT)) 
+            { 
+                 rTop.x += rTop.width; 
+                 rTop.x--; 
+            } 
+            else // must be wxAUI_NB_LEFT 
+            { 
+                rBase.x += rBase.width; 
+                rBase.x--; 
+            } 
+        } 
 
         // -- draw top gradient fill for glossy look
         wxColor topColor = m_baseColour;
@@ -635,22 +635,22 @@ void wxAuiGenericTabArt::DrawTab(wxDC& dc, wxWindow* wnd, const wxAuiPaneInfo& p
     // this gets rid of the top one of those lines in the tab control
     if (page.HasFlag(wxAuiPaneInfo::optionActiveNotebook))
     {
-        dc.SetPen(m_baseColourPen);
+        dc.SetPen(m_baseColourPen); 
 
-        if (IsHorizontal())
-        {
-            dc.DrawLine(borderPoints[0].x+1,
-                        borderPoints[0].y,
-                        borderPoints[5].x,
-                        borderPoints[5].y);
-        }
-        else
-        {
-            dc.DrawLine(borderPoints[0].x,
-                        borderPoints[0].y+1,
-                        borderPoints[5].x,
-                        borderPoints[5].y);
-        }
+        if (IsHorizontal()) 
+        { 
+            dc.DrawLine(borderPoints[0].x+1, 
+                        borderPoints[0].y, 
+                        borderPoints[5].x, 
+                        borderPoints[5].y); 
+        } 
+        else 
+        { 
+            dc.DrawLine(borderPoints[0].x, 
+                        borderPoints[0].y+1, 
+                        borderPoints[5].x, 
+                        borderPoints[5].y); 
+        } 
     }
 
 
@@ -761,14 +761,14 @@ wxSize wxAuiGenericTabArt::GetTabSize(wxDC& dc, wxWindow* WXUNUSED(wnd), const w
     wxCoord tabWidth = measuredTextX;
     wxCoord tabHeight = measuredTextY;
 
-    // if the close button is showing or the tab-position is left or right,
-    //  add space for it
-    if ((closeButtonState != wxAUI_BUTTON_STATE_HIDDEN) || (!IsHorizontal() && !(m_flags & wxAUI_NB_CLOSE_BUTTON)))
-     {
-         tabWidth += m_activeCloseBmp.GetWidth();
-         tabWidth += 3;
-         tabHeight = wxMax(tabHeight, m_activeCloseBmp.GetHeight());
-     }
+    // if the close button is showing or the tab-position is left or right, 
+    //  add space for it 
+    if ((closeButtonState != wxAUI_BUTTON_STATE_HIDDEN) || (!IsHorizontal() && !(m_flags & wxAUI_NB_CLOSE_BUTTON))) 
+     { 
+         tabWidth += m_activeCloseBmp.GetWidth(); 
+         tabWidth += 3; 
+         tabHeight = wxMax(tabHeight, m_activeCloseBmp.GetHeight()); 
+     } 
 
     // if there's a bitmap, add space for it
     if (bitmap.IsOk())
@@ -782,21 +782,21 @@ wxSize wxAuiGenericTabArt::GetTabSize(wxDC& dc, wxWindow* WXUNUSED(wnd), const w
     tabWidth += 16;
     tabHeight += 10;
 
-    if (IsHorizontal())
-    {
-        if (m_flags & wxAUI_NB_TAB_FIXED_WIDTH)
+    if (IsHorizontal()) 
+    { 
+        if (m_flags & wxAUI_NB_TAB_FIXED_WIDTH) 
         {
             tabWidth = m_fixedTabWidth;
         }
-        *extent = tabWidth;
-    }
-    else
-    {
-        if (m_flags & wxAUI_MGR_NB_TAB_FIXED_WIDTH)
+        *extent = tabWidth; 
+    } 
+    else 
+    { 
+        if (m_flags & wxAUI_MGR_NB_TAB_FIXED_WIDTH) 
         {
             tabWidth = m_fixedTabWidth;
         }
-        *extent = tabHeight;
+        *extent = tabHeight; 
     }
 
     return wxSize(tabWidth, tabHeight);
@@ -806,7 +806,7 @@ wxSize wxAuiGenericTabArt::GetTabSize(wxDC& dc, wxWindow* WXUNUSED(wnd), const w
 void wxAuiGenericTabArt::DrawButton(wxDC& dc, wxWindow* wnd, const wxRect& inRect, int bitmapID, int buttonState, int orientation, wxRect* outRect)
 {
     wxBitmap bmp;
-    wxRect rect = inRect;
+    wxRect rect = inRect; 
 
     switch (bitmapID)
     {
@@ -815,8 +815,8 @@ void wxAuiGenericTabArt::DrawButton(wxDC& dc, wxWindow* wnd, const wxRect& inRec
                 bmp = m_disabledCloseBmp;
             else
                 bmp = m_activeCloseBmp;
-            rect.x = inRect.x + inRect.width - bmp.GetWidth();
-            if (HasFlag(wxAUI_NB_LEFT))
+            rect.x = inRect.x + inRect.width - bmp.GetWidth(); 
+            if (HasFlag(wxAUI_NB_LEFT)) 
                 rect.x -= 5;
             break;
 
@@ -826,28 +826,28 @@ void wxAuiGenericTabArt::DrawButton(wxDC& dc, wxWindow* wnd, const wxRect& inRec
             else
                 bmp = m_activeLeftBmp;
             break;
-        case wxAUI_BUTTON_UP:
-            if (buttonState & wxAUI_BUTTON_STATE_DISABLED)
-                bmp = m_disabledUpBmp;
-            else
-                bmp = m_activeUpBmp;
-            rect.width = wnd->GetRect().GetWidth();
-            rect.x = ((rect.x + rect.width)/2) - (bmp.GetWidth()/2);
-            break;
-        case wxAUI_BUTTON_DOWN:
-            if (buttonState & wxAUI_BUTTON_STATE_DISABLED)
-                bmp = m_disabledDownBmp;
-            else
-                bmp = m_activeDownBmp;
+        case wxAUI_BUTTON_UP: 
+            if (buttonState & wxAUI_BUTTON_STATE_DISABLED) 
+                bmp = m_disabledUpBmp; 
+            else 
+                bmp = m_activeUpBmp; 
+            rect.width = wnd->GetRect().GetWidth(); 
+            rect.x = ((rect.x + rect.width)/2) - (bmp.GetWidth()/2); 
+            break; 
+        case wxAUI_BUTTON_DOWN: 
+            if (buttonState & wxAUI_BUTTON_STATE_DISABLED) 
+                bmp = m_disabledDownBmp; 
+            else 
+                bmp = m_activeDownBmp; 
             break;
         case wxAUI_BUTTON_RIGHT:
             if (buttonState & wxAUI_BUTTON_STATE_DISABLED)
                 bmp = m_disabledRightBmp;
             else
                 bmp = m_activeRightBmp;
-            rect.x = inRect.x + inRect.width - bmp.GetWidth();
-            if (HasFlag(wxAUI_NB_LEFT))
-                rect.x -= 5;
+            rect.x = inRect.x + inRect.width - bmp.GetWidth(); 
+            if (HasFlag(wxAUI_NB_LEFT)) 
+                rect.x -= 5; 
             break;
         case wxAUI_BUTTON_WINDOWLIST:
             if (buttonState & wxAUI_BUTTON_STATE_DISABLED)
@@ -863,25 +863,25 @@ void wxAuiGenericTabArt::DrawButton(wxDC& dc, wxWindow* wnd, const wxRect& inRec
 
     if (orientation == wxLEFT)
     {
-        rect.x = inRect.x;
-        rect.y = ((inRect.y + inRect.height)/2) - (bmp.GetHeight()/2);
-        rect.width = bmp.GetWidth();
-        rect.height = bmp.GetHeight();
-    }
-    else if (orientation == wxUP)
-    {
-        rect.y = inRect.y;
-        rect.width = bmp.GetWidth();
+        rect.x = inRect.x; 
+        rect.y = ((inRect.y + inRect.height)/2) - (bmp.GetHeight()/2); 
+        rect.width = bmp.GetWidth(); 
         rect.height = bmp.GetHeight();
     }
-    else if (orientation == wxDOWN)
-    {
-        rect.x = ((inRect.x + inRect.width)/2) - (bmp.GetWidth()/2);
-        rect.y = inRect.y  + inRect.height - bmp.GetHeight() - bmp.GetHeight() / 2;
-        rect.width = bmp.GetWidth();
-        rect.height = bmp.GetHeight();
-    }
-    else if (orientation == wxRIGHT)
+    else if (orientation == wxUP) 
+    { 
+        rect.y = inRect.y; 
+        rect.width = bmp.GetWidth(); 
+        rect.height = bmp.GetHeight(); 
+    } 
+    else if (orientation == wxDOWN) 
+    { 
+        rect.x = ((inRect.x + inRect.width)/2) - (bmp.GetWidth()/2); 
+        rect.y = inRect.y  + inRect.height - bmp.GetHeight() - bmp.GetHeight() / 2; 
+        rect.width = bmp.GetWidth(); 
+        rect.height = bmp.GetHeight(); 
+    } 
+    else if (orientation == wxRIGHT) 
     {
         rect = wxRect(inRect.x + inRect.width - bmp.GetWidth(),
                       ((inRect.y + inRect.height)/2) - (bmp.GetHeight()/2),
@@ -959,7 +959,7 @@ wxSize wxAuiGenericTabArt::GetBestTabSize(wxWindow* wnd, const wxAuiPaneInfoPtrA
         else
             bmp = page.GetBitmap();
 
-        int ext = 0;
+        int ext = 0; 
         wxSize s = GetTabSize(dc,
                               wnd,
                               page.caption,
@@ -968,13 +968,13 @@ wxSize wxAuiGenericTabArt::GetBestTabSize(wxWindow* wnd, const wxAuiPaneInfoPtrA
                               wxAUI_BUTTON_STATE_HIDDEN,
                               &ext);
 
-        maxSize.x = wxMax(maxSize.x, s.x);
+        maxSize.x = wxMax(maxSize.x, s.x); 
         maxSize.y = wxMax(maxSize.y, s.y);
     }
 
-    maxSize.IncBy(2, 2);
+    maxSize.IncBy(2, 2); 
 
-    return maxSize;
+    return maxSize; 
 }
 
 void wxAuiGenericTabArt::SetNormalFont(const wxFont& font)
@@ -1035,10 +1035,10 @@ wxAuiSimpleTabArt::wxAuiSimpleTabArt()
     m_activeLeftBmp = wxAuiBitmapFromBits(left_bits, 16, 16, *wxBLACK);
     m_disabledLeftBmp = wxAuiBitmapFromBits(left_bits, 16, 16, wxColour(128,128,128));
 
-    m_activeUpBmp = wxAuiBitmapFromBits(up_bits, 16, 16, *wxBLACK);
-    m_disabledUpBmp = wxAuiBitmapFromBits(up_bits, 16, 16, wxColour(128,128,128));
-
-    m_activeDownBmp = wxAuiBitmapFromBits(down_bits, 16, 16, *wxBLACK);
+    m_activeUpBmp = wxAuiBitmapFromBits(up_bits, 16, 16, *wxBLACK); 
+    m_disabledUpBmp = wxAuiBitmapFromBits(up_bits, 16, 16, wxColour(128,128,128)); 
+ 
+    m_activeDownBmp = wxAuiBitmapFromBits(down_bits, 16, 16, *wxBLACK); 
     m_disabledDownBmp = wxAuiBitmapFromBits(down_bits, 16, 16, wxColour(128,128,128));
 
     m_activeRightBmp = wxAuiBitmapFromBits(right_bits, 16, 16, *wxBLACK);
@@ -1065,8 +1065,8 @@ void wxAuiSimpleTabArt::SetFlags(unsigned int flags)
 
 void wxAuiSimpleTabArt::SetSizingInfo(const wxSize& tabCtrlSize, size_t tabCount)
 {
-    if (IsHorizontal())
-    {
+    if (IsHorizontal()) 
+    { 
         m_fixedTabWidth = 100;
 
         int totWidth = (int)tabCtrlSize.x - GetIndentSize() - 4;
@@ -1084,39 +1084,39 @@ void wxAuiSimpleTabArt::SetSizingInfo(const wxSize& tabCtrlSize, size_t tabCount
 
         if (m_fixedTabWidth < 100)
             m_fixedTabWidth = 100;
-
+ 
         if (m_fixedTabWidth > totWidth/2)
             m_fixedTabWidth = totWidth/2;
 
         if (m_fixedTabWidth > 220)
             m_fixedTabWidth = 220;
     }
-    else
-    {
-        m_fixedTabWidth = 100;
+    else 
+    { 
+        m_fixedTabWidth = 100; 
 
         //Below is only necessary for left/right notebooks where the tabs themselves run upwards (instead of left to right) - we don't support this currently so commenting it out.
         #if 0
-        int totHeight = (int)tabCtrlSize.y - GetIndentSize() - 4;
-        if (m_flags & wxAUI_NB_CLOSE_BUTTON)
-            totHeight -= m_activeCloseBmp.GetHeight();
-        if (m_flags & wxAUI_NB_WINDOWLIST_BUTTON)
-            totHeight -= m_activeWindowListBmp.GetHeight();
+        int totHeight = (int)tabCtrlSize.y - GetIndentSize() - 4; 
+        if (m_flags & wxAUI_NB_CLOSE_BUTTON) 
+            totHeight -= m_activeCloseBmp.GetHeight(); 
+        if (m_flags & wxAUI_NB_WINDOWLIST_BUTTON) 
+            totHeight -= m_activeWindowListBmp.GetHeight(); 
 
-        if (tabCount > 0)
-        {
-            m_fixedTabWidth = totHeight/(int)tabCount;
-        }
+        if (tabCount > 0) 
+        { 
+            m_fixedTabWidth = totHeight/(int)tabCount; 
+        } 
 
 
-        if (m_fixedTabWidth < 20)
-            m_fixedTabWidth = 20;
+        if (m_fixedTabWidth < 20) 
+            m_fixedTabWidth = 20; 
 
-        if (m_fixedTabWidth > totHeight/2)
-            m_fixedTabWidth = totHeight/2;
+        if (m_fixedTabWidth > totHeight/2) 
+            m_fixedTabWidth = totHeight/2; 
 
-        if (m_fixedTabWidth > 60)
-            m_fixedTabWidth = 60;
+        if (m_fixedTabWidth > 60) 
+            m_fixedTabWidth = 60; 
         #endif
     }
 }
@@ -1142,23 +1142,23 @@ void wxAuiSimpleTabArt::DrawBackground(wxDC& dc, wxWindow* WXUNUSED(wnd), const
     dc.DrawRectangle(-1, -1, rect.GetWidth()+2, rect.GetHeight()+2);
 
     // draw base line
-    dc.SetPen(*wxGREY_PEN);
-    if (HasFlag(wxAUI_NB_LEFT))
-    {
-        dc.DrawLine(rect.GetWidth(), 0, rect.GetWidth()-1, rect.GetHeight());
-    }
-    else if (HasFlag(wxAUI_NB_RIGHT))
-    {
-        dc.DrawLine(1, 0, 1, rect.GetHeight());
-    }
-    else if (HasFlag(wxAUI_NB_BOTTOM))
-    {
-        dc.DrawLine(0, 1, rect.GetWidth(), 1);
-    }
-    else // must be wxAUI_NB_TOP
-    {
-        dc.DrawLine(0, rect.GetHeight()-1, rect.GetWidth(), rect.GetHeight()-1);
-    }
+    dc.SetPen(*wxGREY_PEN); 
+    if (HasFlag(wxAUI_NB_LEFT)) 
+    { 
+        dc.DrawLine(rect.GetWidth(), 0, rect.GetWidth()-1, rect.GetHeight()); 
+    } 
+    else if (HasFlag(wxAUI_NB_RIGHT)) 
+    { 
+        dc.DrawLine(1, 0, 1, rect.GetHeight()); 
+    } 
+    else if (HasFlag(wxAUI_NB_BOTTOM)) 
+    { 
+        dc.DrawLine(0, 1, rect.GetWidth(), 1); 
+    } 
+    else // must be wxAUI_NB_TOP 
+    { 
+        dc.DrawLine(0, rect.GetHeight()-1, rect.GetWidth(), rect.GetHeight()-1); 
+    } 
 }
 
 
@@ -1200,13 +1200,13 @@ void wxAuiSimpleTabArt::DrawTab(wxDC& dc, wxWindow* wnd, const wxAuiPaneInfo& pa
     wxCoord tabHeight = tabSize.y;
     wxCoord tabWidth = tabSize.x;
     wxCoord tabX = inRect.x;
-    wxCoord tabY = inRect.y + inRect.height - tabHeight - 1;
-    if (!IsHorizontal())
-    {
-        tabWidth = inRect.width;
-        tabY = inRect.y - 1;
-        tabHeight += 2;
-    }
+    wxCoord tabY = inRect.y + inRect.height - tabHeight - 1; 
+    if (!IsHorizontal()) 
+    { 
+        tabWidth = inRect.width; 
+        tabY = inRect.y - 1; 
+        tabHeight += 2; 
+    } 
 
     caption = page.caption;
 
@@ -1230,83 +1230,83 @@ void wxAuiSimpleTabArt::DrawTab(wxDC& dc, wxWindow* wnd, const wxAuiPaneInfo& pa
     }
 
     // -- draw line --
-    wxPoint points[7];
-    if (HasFlag(wxAUI_NB_LEFT))
-    {
-        points[0].x = tabX;
-        points[0].y = tabY + tabHeight;
-        points[1].x = tabX;
-        points[1].y = tabY + tabHeight - 2;
-        points[2].x = tabX + tabHeight - 4;
-        points[2].y = tabY + 2;
-        points[3].x = tabX + tabHeight + 2;
-        points[3].y = tabY;
-        points[4].x = tabX + tabWidth - 1;
-        points[4].y = tabY;
-        points[5].x = tabX + tabWidth - 1;
-        points[5].y = tabY + tabHeight;
-        points[6] = points[0];
-    }
-    else if (HasFlag(wxAUI_NB_RIGHT))
-    {
-        points[0].x = tabX + 1;
-        points[0].y = tabY + tabHeight;
-        points[1].x = tabX + 1;
-        points[1].y = tabY;
-        points[2].x = tabX + tabWidth - tabHeight - 3;
-        points[2].y = tabY;
-        points[3].x = tabX + tabWidth - tabHeight + 3;
-        points[3].y = tabY + 2;
-        points[4].x = tabX + tabWidth;
-        points[4].y = tabY + tabHeight - 2;
-        points[5].x = tabX + tabWidth;
-        points[5].y = tabY + tabHeight;
-        points[6] = points[0];
-    }
-    else if (HasFlag(wxAUI_NB_BOTTOM))
-    {
-        points[0].x = tabX;
-        points[0].y = tabY - 1;
-        points[1].x = tabX + tabHeight - 3;
-        points[1].y = tabY + tabHeight - 4;
-        points[2].x = tabX + tabHeight + 3;
-        points[2].y = tabY + tabHeight - 2;
-        points[3].x = tabX + tabWidth - 2;
-        points[3].y = tabY + tabHeight - 2;
-        points[4].x = tabX + tabWidth;
-        points[4].y = tabY + tabHeight - 4;
-        points[5].x = tabX + tabWidth;
-        points[5].y = tabY - 1;
-        points[6] = points[0];
-     }
-     else // must be wxAUI_NB_TOP
-     {
-        points[0].x = tabX;
-        points[0].y = tabY + tabHeight;
-        points[1].x = tabX + tabHeight - 3;
-        points[1].y = tabY + 2;
-        points[2].x = tabX + tabHeight + 3;
-        points[2].y = tabY;
-        points[3].x = tabX + tabWidth - 2;
-        points[3].y = tabY;
-        points[4].x = tabX + tabWidth;
-        points[4].y = tabY + 2;
-        points[5].x = tabX + tabWidth;
-        points[5].y = tabY + tabHeight;
-        points[6] = points[0];
-    }
-
-    int clipWidth = tabWidth;
-    int clipHeight = tabHeight;
-
-    if (tabX + clipWidth > inRect.x + inRect.width)
-        clipWidth = (inRect.x + inRect.width) - tabX;
-    if (tabY + tabHeight > inRect.y + inRect.height)
-        clipHeight = (inRect.y + inRect.height) - tabY;
-    ++clipWidth;
-    ++clipHeight;
-
-    dc.SetClippingRegion(tabX, tabY, clipWidth, clipHeight);
+    wxPoint points[7]; 
+    if (HasFlag(wxAUI_NB_LEFT)) 
+    { 
+        points[0].x = tabX; 
+        points[0].y = tabY + tabHeight; 
+        points[1].x = tabX; 
+        points[1].y = tabY + tabHeight - 2; 
+        points[2].x = tabX + tabHeight - 4; 
+        points[2].y = tabY + 2; 
+        points[3].x = tabX + tabHeight + 2; 
+        points[3].y = tabY; 
+        points[4].x = tabX + tabWidth - 1; 
+        points[4].y = tabY; 
+        points[5].x = tabX + tabWidth - 1; 
+        points[5].y = tabY + tabHeight; 
+        points[6] = points[0]; 
+    } 
+    else if (HasFlag(wxAUI_NB_RIGHT)) 
+    { 
+        points[0].x = tabX + 1; 
+        points[0].y = tabY + tabHeight; 
+        points[1].x = tabX + 1; 
+        points[1].y = tabY; 
+        points[2].x = tabX + tabWidth - tabHeight - 3; 
+        points[2].y = tabY; 
+        points[3].x = tabX + tabWidth - tabHeight + 3; 
+        points[3].y = tabY + 2; 
+        points[4].x = tabX + tabWidth; 
+        points[4].y = tabY + tabHeight - 2; 
+        points[5].x = tabX + tabWidth; 
+        points[5].y = tabY + tabHeight; 
+        points[6] = points[0]; 
+    } 
+    else if (HasFlag(wxAUI_NB_BOTTOM)) 
+    { 
+        points[0].x = tabX; 
+        points[0].y = tabY - 1; 
+        points[1].x = tabX + tabHeight - 3; 
+        points[1].y = tabY + tabHeight - 4; 
+        points[2].x = tabX + tabHeight + 3; 
+        points[2].y = tabY + tabHeight - 2; 
+        points[3].x = tabX + tabWidth - 2; 
+        points[3].y = tabY + tabHeight - 2; 
+        points[4].x = tabX + tabWidth; 
+        points[4].y = tabY + tabHeight - 4; 
+        points[5].x = tabX + tabWidth; 
+        points[5].y = tabY - 1; 
+        points[6] = points[0]; 
+     } 
+     else // must be wxAUI_NB_TOP 
+     { 
+        points[0].x = tabX; 
+        points[0].y = tabY + tabHeight; 
+        points[1].x = tabX + tabHeight - 3; 
+        points[1].y = tabY + 2; 
+        points[2].x = tabX + tabHeight + 3; 
+        points[2].y = tabY; 
+        points[3].x = tabX + tabWidth - 2; 
+        points[3].y = tabY; 
+        points[4].x = tabX + tabWidth; 
+        points[4].y = tabY + 2; 
+        points[5].x = tabX + tabWidth; 
+        points[5].y = tabY + tabHeight; 
+        points[6] = points[0]; 
+    } 
+
+    int clipWidth = tabWidth; 
+    int clipHeight = tabHeight; 
+
+    if (tabX + clipWidth > inRect.x + inRect.width) 
+        clipWidth = (inRect.x + inRect.width) - tabX; 
+    if (tabY + tabHeight > inRect.y + inRect.height) 
+        clipHeight = (inRect.y + inRect.height) - tabY; 
+    ++clipWidth; 
+    ++clipHeight; 
+
+    dc.SetClippingRegion(tabX, tabY, clipWidth, clipHeight); 
 
     dc.DrawPolygon(WXSIZEOF(points) - 1, points);
 
@@ -1332,13 +1332,13 @@ void wxAuiSimpleTabArt::DrawTab(wxDC& dc, wxWindow* wnd, const wxAuiPaneInfo& pa
     if (textOffset < tabX + tabHeight)
         textOffset = tabX + tabHeight;
 
-    if (HasFlag(wxAUI_NB_RIGHT))
-        textOffset -= tabHeight;
+    if (HasFlag(wxAUI_NB_RIGHT)) 
+        textOffset -= tabHeight; 
     // chop text if necessary
     wxString drawText = wxAuiChopText(dc, caption, tabWidth - (HasFlag(wxAUI_NB_RIGHT)&&HasFlag(wxAUI_MGR_NB_TAB_FIXED_WIDTH)?tabHeight:0) - (textOffset-tabX) - closeButtonWidth);
 
     // draw tab text
-    dc.DrawText(drawText, textOffset, tabY + (tabHeight - texty) / 2 + 1);
+    dc.DrawText(drawText, textOffset, tabY + (tabHeight - texty) / 2 + 1); 
 
     // draw focus rectangle
     if (page.HasFlag(wxAuiPaneInfo::optionActiveNotebook) && haveFocus)
@@ -1365,8 +1365,8 @@ void wxAuiSimpleTabArt::DrawTab(wxDC& dc, wxWindow* wnd, const wxAuiPaneInfo& pa
                     closeButtonWidth,
                     tabHeight - 1);
 
-        if (HasFlag(wxAUI_NB_RIGHT))
-            rect.x -= tabHeight;
+        if (HasFlag(wxAUI_NB_RIGHT)) 
+            rect.x -= tabHeight; 
 
         DrawButtons(dc, rect, bmp, *wxWHITE, closeButtonState);
 
@@ -1391,7 +1391,7 @@ wxSize wxAuiSimpleTabArt::GetTabSize(wxDC& dc, wxWindow* WXUNUSED(wnd), const wx
     dc.SetFont(m_measuringFont);
     dc.GetTextExtent(caption, &measuredTextX, &measuredTextY);
 
-    dc.GetTextExtent(wxT("ABCDEFXj"), &tmp, &measuredTextY);
+    dc.GetTextExtent(wxT("ABCDEFXj"), &tmp, &measuredTextY); 
 
     wxCoord tabHeight = measuredTextY + 4;
     wxCoord tabWidth = measuredTextX + tabHeight + 5;
@@ -1399,26 +1399,26 @@ wxSize wxAuiSimpleTabArt::GetTabSize(wxDC& dc, wxWindow* WXUNUSED(wnd), const wx
     if (closeButtonState != wxAUI_BUTTON_STATE_HIDDEN)
         tabWidth += m_activeCloseBmp.GetWidth();
 
-    if (IsHorizontal())
-    {
+    if (IsHorizontal()) 
+    { 
         if (m_flags & wxAUI_MGR_NB_TAB_FIXED_WIDTH)
         {
             tabWidth = m_fixedTabWidth;
         }
-        *extent = tabWidth - (tabHeight/2) - 1;
-    }
-    else
-    {
-        if (m_flags & wxAUI_MGR_NB_TAB_FIXED_WIDTH)
+        *extent = tabWidth - (tabHeight/2) - 1; 
+    } 
+    else 
+    { 
+        if (m_flags & wxAUI_MGR_NB_TAB_FIXED_WIDTH) 
         {
              tabWidth = m_fixedTabWidth;
         }
         else
         {
-            tabWidth += 16;
+            tabWidth += 16; 
         }
-        *extent = tabHeight + 2;
-    }
+        *extent = tabHeight + 2; 
+    } 
 
     return wxSize(tabWidth, tabHeight);
 }
@@ -1438,20 +1438,20 @@ void wxAuiSimpleTabArt::DrawButton(wxDC& dc, wxWindow* wnd, const wxRect& inRect
                 bmp = m_activeCloseBmp;
             rect.x = inRect.x + inRect.width - bmp.GetWidth();
             break;
-        case wxAUI_BUTTON_UP:
-            if (buttonState & wxAUI_BUTTON_STATE_DISABLED)
-                bmp = m_disabledUpBmp;
-            else
-                bmp = m_activeUpBmp;
-            rect.width = wnd->GetRect().GetWidth();
-            rect.x = ((rect.x + rect.width)/2) - (bmp.GetWidth()/2);
-            break;
-        case wxAUI_BUTTON_DOWN:
-            if (buttonState & wxAUI_BUTTON_STATE_DISABLED)
-                bmp = m_disabledDownBmp;
-            else
-                bmp = m_activeDownBmp;
-            break;
+        case wxAUI_BUTTON_UP: 
+            if (buttonState & wxAUI_BUTTON_STATE_DISABLED) 
+                bmp = m_disabledUpBmp; 
+            else 
+                bmp = m_activeUpBmp; 
+            rect.width = wnd->GetRect().GetWidth(); 
+            rect.x = ((rect.x + rect.width)/2) - (bmp.GetWidth()/2); 
+            break; 
+        case wxAUI_BUTTON_DOWN: 
+            if (buttonState & wxAUI_BUTTON_STATE_DISABLED) 
+                bmp = m_disabledDownBmp; 
+            else 
+                bmp = m_activeDownBmp; 
+            break; 
         case wxAUI_BUTTON_LEFT:
             if (buttonState & wxAUI_BUTTON_STATE_DISABLED)
                 bmp = m_disabledLeftBmp;
@@ -1463,7 +1463,7 @@ void wxAuiSimpleTabArt::DrawButton(wxDC& dc, wxWindow* wnd, const wxRect& inRect
                 bmp = m_disabledRightBmp;
             else
                 bmp = m_activeRightBmp;
-            rect.x = inRect.x + inRect.width - bmp.GetWidth();
+            rect.x = inRect.x + inRect.width - bmp.GetWidth(); 
             break;
         case wxAUI_BUTTON_WINDOWLIST:
             if (buttonState & wxAUI_BUTTON_STATE_DISABLED)
@@ -1478,25 +1478,25 @@ void wxAuiSimpleTabArt::DrawButton(wxDC& dc, wxWindow* wnd, const wxRect& inRect
 
     if (orientation == wxLEFT)
     {
-        rect.x = inRect.x;
-        rect.y = ((inRect.y + inRect.height)/2) - (bmp.GetHeight()/2);
-        rect.width = bmp.GetWidth();
-        rect.height = bmp.GetHeight();
-    }
-    else if (orientation == wxUP)
-    {
-        rect.y = inRect.y;
-        rect.width = bmp.GetWidth();
+        rect.x = inRect.x; 
+        rect.y = ((inRect.y + inRect.height)/2) - (bmp.GetHeight()/2); 
+        rect.width = bmp.GetWidth(); 
         rect.height = bmp.GetHeight();
     }
-    else if (orientation == wxDOWN)
-    {
-        rect.x = ((inRect.x + inRect.width)/2) - (bmp.GetWidth()/2);
-        rect.y = inRect.y  + inRect.height - bmp.GetHeight() - bmp.GetHeight() / 2;
-        rect.width = bmp.GetWidth();
-        rect.height = bmp.GetHeight();
-    }
-    else if (orientation == wxRIGHT)
+    else if (orientation == wxUP) 
+    { 
+        rect.y = inRect.y; 
+        rect.width = bmp.GetWidth(); 
+        rect.height = bmp.GetHeight(); 
+    } 
+    else if (orientation == wxDOWN) 
+    { 
+        rect.x = ((inRect.x + inRect.width)/2) - (bmp.GetWidth()/2); 
+        rect.y = inRect.y  + inRect.height - bmp.GetHeight() - bmp.GetHeight() / 2; 
+        rect.width = bmp.GetWidth(); 
+        rect.height = bmp.GetHeight(); 
+    } 
+    else if (orientation == wxRIGHT) 
     {
         rect = wxRect(inRect.x + inRect.width - bmp.GetWidth(),
                       ((inRect.y + inRect.height)/2) - (bmp.GetHeight()/2),
@@ -1543,30 +1543,30 @@ int wxAuiSimpleTabArt::ShowDropDown(wxWindow* wnd, const wxAuiPaneInfoPtrArray&
 
 wxSize wxAuiSimpleTabArt::GetBestTabSize(wxWindow* wnd, const wxAuiPaneInfoPtrArray& pages, const wxSize& WXUNUSED(requiredBmpSize))
 {
-    wxClientDC dc(wnd);
-    dc.SetFont(m_measuringFont);
-
-    wxSize maxSize;
-    size_t i, pageCount = pages.GetCount();
-    for (i = 0; i < pageCount; ++i)
-    {
-        wxAuiPaneInfo* page = pages.Item(i);
-
-        int ext = 0;
-        wxSize s = GetTabSize(dc,
-                              wnd,
-                              page->caption,
-                              wxNullBitmap,
-                              true,
-                              wxAUI_BUTTON_STATE_HIDDEN,
-                              &ext);
-
-        maxSize.x = wxMax(maxSize.x, s.x);
-        maxSize.y = wxMax(maxSize.y, s.y);
-    }
-
-    maxSize.IncBy(3, 3);
-    return maxSize;
+    wxClientDC dc(wnd); 
+    dc.SetFont(m_measuringFont); 
+
+    wxSize maxSize; 
+    size_t i, pageCount = pages.GetCount(); 
+    for (i = 0; i < pageCount; ++i) 
+    { 
+        wxAuiPaneInfo* page = pages.Item(i); 
+
+        int ext = 0; 
+        wxSize s = GetTabSize(dc, 
+                              wnd, 
+                              page->caption, 
+                              wxNullBitmap, 
+                              true, 
+                              wxAUI_BUTTON_STATE_HIDDEN, 
+                              &ext); 
+
+        maxSize.x = wxMax(maxSize.x, s.x); 
+        maxSize.y = wxMax(maxSize.y, s.y); 
+    } 
+
+    maxSize.IncBy(3, 3); 
+    return maxSize; 
 }
 
 void wxAuiSimpleTabArt::SetNormalFont(const wxFont& font)
diff --git a/src/aui/tabartgtk.cpp b/src/aui/tabartgtk.cpp
index 8914580..5190e9b 100755
--- a/src/aui/tabartgtk.cpp
+++ b/src/aui/tabartgtk.cpp
@@ -8,8 +8,8 @@
 // RCS-ID:      $Id$
 // Copyright:   (c) 2012 Jens Lody <jens@codeblocks.org>
 //                  and Teodor Petrov
-//                  2012, Jens Lody for the code related to left and right
-//                        positioning
+//                  2012, Jens Lody for the code related to left and right 
+//                        positioning 
 // Licence:     wxWindows licence
 ///////////////////////////////////////////////////////////////////////////////
 
@@ -53,7 +53,7 @@ static int s_CloseIconSize = 16; // default size
 
 }
 
-wxString wxAuiChopText(wxDC& dc, const wxString& text, int max_size);
+wxString wxAuiChopText(wxDC& dc, const wxString& text, int max_size); 
 
 wxAuiGtkTabArt::wxAuiGtkTabArt()
 {
@@ -127,17 +127,17 @@ wxRect DrawCloseButton(wxDC& dc, GtkWidget* widget, int buttonState, wxRect cons
 
     wxRect outRect;
 
-    outRect.y = inRect.y + (inRect.height - buttonSize) / 2;
+    outRect.y = inRect.y + (inRect.height - buttonSize) / 2; 
 
     if (orientation == wxLEFT)
-        outRect.x = inRect.x - xthickness;
-    else if (orientation == wxRIGHT)
-        outRect.x = inRect.x + inRect.width - buttonSize;
-    else if (orientation == wxUP)
-    {
-        outRect.x = inRect.x + inRect.width - buttonSize - xthickness;
-        outRect.y = inRect.y + ythickness;
-    }
+        outRect.x = inRect.x - xthickness; 
+    else if (orientation == wxRIGHT) 
+        outRect.x = inRect.x + inRect.width - buttonSize; 
+    else if (orientation == wxUP) 
+    { 
+        outRect.x = inRect.x + inRect.width - buttonSize - xthickness; 
+        outRect.y = inRect.y + ythickness; 
+    } 
 
     outRect.width = buttonSize;
     outRect.height = buttonSize;
@@ -179,84 +179,84 @@ void wxAuiGtkTabArt::DrawTab(wxDC& dc, wxWindow* wnd, const wxAuiPaneInfo& page,
     wxSize tabSize = GetTabSize(dc, wnd, page.caption, page.GetBitmap(),
                                     page.HasFlag(wxAuiPaneInfo::optionActiveNotebook), closeButtonState, xExtent);
 
-    wxRect tabRect = inRect;
-    wxRect gapRect = wnd->GetRect();
-    int gapStart = 0, gapWidth = 0;
+    wxRect tabRect = inRect; 
+    wxRect gapRect = wnd->GetRect(); 
+    int gapStart = 0, gapWidth = 0; 
 
-    GtkPositionType gapBoxPos;
-    GtkPositionType gapPos;
+    GtkPositionType gapBoxPos; 
+    GtkPositionType gapPos; 
 
-    if (IsHorizontal())
+    if (IsHorizontal()) 
     {
-        tabRect.width = tabSize.x;
-        tabRect.height = tabSize.y;
-        if (page.HasFlag(wxAuiPaneInfo::optionActiveNotebook))
-            tabRect.height += 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
-        // if no bitmap is set, we need a tiny correction
-        if (! page.GetBitmap().IsOk())
-            tabRect.height += 1;
-        tabRect.y += GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder / 2;
-        gapRect.height = 6 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
-        gapRect.x = 1;
-        gapStart = tabRect.x - GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder / 2;
-        gapWidth = tabRect.width;
-
-        if (HasFlag(wxAUI_NB_TOP))
-        {
+        tabRect.width = tabSize.x; 
+        tabRect.height = tabSize.y; 
+        if (page.HasFlag(wxAuiPaneInfo::optionActiveNotebook)) 
+            tabRect.height += 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder; 
+        // if no bitmap is set, we need a tiny correction 
+        if (! page.GetBitmap().IsOk()) 
+            tabRect.height += 1; 
+        tabRect.y += GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder / 2; 
+        gapRect.height = 6 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder; 
+        gapRect.x = 1; 
+        gapStart = tabRect.x - GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder / 2; 
+        gapWidth = tabRect.width; 
+
+        if (HasFlag(wxAUI_NB_TOP)) 
+        { 
             if (!page.HasFlag(wxAuiPaneInfo::optionActiveNotebook))
                 tabRect.y += 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
-            gapRect.y = tabRect.y + tabRect.height;
-            gapBoxPos = GTK_POS_TOP;
-            gapPos = GTK_POS_BOTTOM;
-        }
+            gapRect.y = tabRect.y + tabRect.height; 
+            gapBoxPos = GTK_POS_TOP; 
+            gapPos = GTK_POS_BOTTOM; 
+        } 
         else//wxAUI_NB_BOTTOM
-        {
-            tabRect.y += 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
-            tabRect.height += 2;
-            gapRect.y = tabRect.y - gapRect.height;
-            gapRect.y += GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder / 2;
-            gapBoxPos = GTK_POS_BOTTOM;
-            gapPos = GTK_POS_TOP;
-        }
-    }
-    else
-    {
-        tabRect.width -= 4 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder;
-        tabRect.height = tabSize.y;
-        gapRect.width = 6 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
-        gapRect.y = 1;
-        gapStart = tabRect.y - GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder / 2;
-        gapWidth = tabRect.height;
-
-        if (HasFlag(wxAUI_NB_LEFT))
-        {
-            if (!page.HasFlag(wxAuiPaneInfo::optionActiveNotebook))
-            {
-                tabRect.x += 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder;
-                tabRect.width -= 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder;
-            }
-            gapRect.x = tabRect.x + tabRect.width;
-            gapBoxPos = GTK_POS_LEFT;
-            gapPos = GTK_POS_RIGHT;
-        }
+        { 
+            tabRect.y += 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder; 
+            tabRect.height += 2; 
+            gapRect.y = tabRect.y - gapRect.height; 
+            gapRect.y += GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder / 2; 
+            gapBoxPos = GTK_POS_BOTTOM; 
+            gapPos = GTK_POS_TOP; 
+        } 
+    } 
+    else 
+    { 
+        tabRect.width -= 4 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder; 
+        tabRect.height = tabSize.y; 
+        gapRect.width = 6 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder; 
+        gapRect.y = 1; 
+        gapStart = tabRect.y - GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder / 2; 
+        gapWidth = tabRect.height; 
+
+        if (HasFlag(wxAUI_NB_LEFT)) 
+        { 
+            if (!page.HasFlag(wxAuiPaneInfo::optionActiveNotebook)) 
+            { 
+                tabRect.x += 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder; 
+                tabRect.width -= 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder; 
+            } 
+            gapRect.x = tabRect.x + tabRect.width; 
+            gapBoxPos = GTK_POS_LEFT; 
+            gapPos = GTK_POS_RIGHT; 
+        } 
         else//wxAUI_NB_RIGHT
-        {
-            if (!page.HasFlag(wxAuiPaneInfo::optionActiveNotebook))
-                tabRect.width -= 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder;
-            gapRect.x = tabRect.x - gapRect.width;
-            gapBoxPos = GTK_POS_RIGHT;
-            gapPos = GTK_POS_LEFT;
-        }
+        { 
+            if (!page.HasFlag(wxAuiPaneInfo::optionActiveNotebook)) 
+                tabRect.width -= 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder; 
+            gapRect.x = tabRect.x - gapRect.width; 
+            gapBoxPos = GTK_POS_RIGHT; 
+            gapPos = GTK_POS_LEFT; 
+        }                
     }
 
     int padding = focusWidth + GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
 
     int clipWidth = tabRect.width;
-    int clipHeight = tabRect.height;
+    int clipHeight = tabRect.height; 
     if (tabRect.x + tabRect.width > inRect.x + inRect.width)
         clipWidth = (inRect.x + inRect.width) - tabRect.x;
-    if (tabRect.y + tabRect.height > inRect.y + inRect.height)
-        clipHeight = (inRect.y + inRect.height) - tabRect.y;
+    if (tabRect.y + tabRect.height > inRect.y + inRect.height) 
+        clipHeight = (inRect.y + inRect.height) - tabRect.y; 
 
     dc.SetClippingRegion(tabRect.x, tabRect.y, clipWidth, clipHeight);
 
@@ -264,34 +264,34 @@ void wxAuiGtkTabArt::DrawTab(wxDC& dc, wxWindow* wnd, const wxAuiPaneInfo& page,
     area.x = tabRect.x - GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder;
     area.y = tabRect.y - 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
     area.width = clipWidth + GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder;
-    area.height = clipHeight + 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
+    area.height = clipHeight + 2 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder; 
 
     wxGTKDCImpl* impldc = (wxGTKDCImpl*) dc.GetImpl();
     GdkWindow* window = impldc->GetGDKWindow();
 
-    // we draw a box here, because the gap-box is not drawn, if the active tab is not visible
-    gtk_paint_box(styleNotebook, window, GTK_STATE_NORMAL, GTK_SHADOW_OUT,
-                  NULL, widget,
-                  const_cast<char*>("notebook"),
-                  gapRect.x, gapRect.y,
-                  gapRect.width, gapRect.height);
+    // we draw a box here, because the gap-box is not drawn, if the active tab is not visible 
+    gtk_paint_box(styleNotebook, window, GTK_STATE_NORMAL, GTK_SHADOW_OUT, 
+                  NULL, widget, 
+                  const_cast<char*>("notebook"), 
+                  gapRect.x, gapRect.y, 
+                  gapRect.width, gapRect.height); 
 
-    if (page.HasFlag(wxAuiPaneInfo::optionActiveNotebook))
+    if (page.HasFlag(wxAuiPaneInfo::optionActiveNotebook)) 
     {
-        gtk_paint_box_gap(styleNotebook, window, GTK_STATE_NORMAL, GTK_SHADOW_OUT,
-                          NULL, widget,
-                          const_cast<char*>("notebook"),
-                          gapRect.x, gapRect.y,
-                          gapRect.width, gapRect.height,
+        gtk_paint_box_gap(styleNotebook, window, GTK_STATE_NORMAL, GTK_SHADOW_OUT, 
+                          NULL, widget, 
+                          const_cast<char*>("notebook"), 
+                          gapRect.x, gapRect.y, 
+                          gapRect.width, gapRect.height, 
                           gapBoxPos, gapStart , gapWidth);
     }
-    gtk_paint_extension(styleNotebook, window,
-                       page.HasFlag(wxAuiPaneInfo::optionActiveNotebook) ? GTK_STATE_NORMAL : GTK_STATE_ACTIVE, GTK_SHADOW_OUT,
-                       &area, widget,
-                       const_cast<char*>("tab"),
-                       tabRect.x, tabRect.y,
-                       tabRect.width, tabRect.height,
-                       gapPos);
+    gtk_paint_extension(styleNotebook, window, 
+                       page.HasFlag(wxAuiPaneInfo::optionActiveNotebook) ? GTK_STATE_NORMAL : GTK_STATE_ACTIVE, GTK_SHADOW_OUT, 
+                       &area, widget, 
+                       const_cast<char*>("tab"), 
+                       tabRect.x, tabRect.y, 
+                       tabRect.width, tabRect.height, 
+                       gapPos); 
 
     wxCoord textX = tabRect.x + padding + styleNotebook->xthickness;
 
@@ -346,17 +346,17 @@ void wxAuiGtkTabArt::DrawTab(wxDC& dc, wxWindow* wnd, const wxAuiPaneInfo& page,
         // clipping seems not to work here, so we we have to recalc the focus-area manually
         if((focusArea.x + focusArea.width) > (area.x + area.width))
             focusArea.width = area.x + area.width - focusArea.x + focusWidth - GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder;
-        if((focusArea.y + focusArea.height) > (area.y + area.height))
-            focusArea.height = area.y + area.height - focusArea.y + focusWidth - GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder;
+        if((focusArea.y + focusArea.height) > (area.y + area.height)) 
+            focusArea.height = area.y + area.height - focusArea.y + focusWidth - GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_hborder; 
         gtk_paint_focus (styleNotebook, window,
                          GTK_STATE_ACTIVE, NULL, widget, "tab",
                          focusArea.x, focusArea.y, focusArea.width, focusArea.height);
     }
 
-    int closeButtonWidth = (closeButtonState != wxAUI_BUTTON_STATE_HIDDEN) ? s_CloseIconSize + 3 * padding : 0;
-    wxString draw_text = wxAuiChopText(dc,page.caption, tabRect.width - (textX - tabRect.x) - closeButtonWidth);
+    int closeButtonWidth = (closeButtonState != wxAUI_BUTTON_STATE_HIDDEN) ? s_CloseIconSize + 3 * padding : 0; 
+    wxString draw_text = wxAuiChopText(dc,page.caption, tabRect.width - (textX - tabRect.x) - closeButtonWidth); 
 
-    dc.DrawText(draw_text, textX, textY);
+    dc.DrawText(draw_text, textX, textY); 
 
     // draw close-button on tab (if enabled)
     if (closeButtonState != wxAUI_BUTTON_STATE_HIDDEN)
@@ -394,15 +394,15 @@ wxRect DrawSimpleArrow(wxDC& dc, GtkWidget* widget, int buttonState, wxRect cons
 
     if (orientation == wxLEFT)
         outRect.x = inRect.x;
-    else if (orientation == wxUP || orientation == wxDOWN)
-        outRect.x = inRect.x + (inRect.width - scrollArrowHLength) / 2;
-    else  if (orientation == wxRIGHT)
+    else if (orientation == wxUP || orientation == wxDOWN) 
+        outRect.x = inRect.x + (inRect.width - scrollArrowHLength) / 2; 
+    else  if (orientation == wxRIGHT) 
         outRect.x = inRect.x + inRect.width - scrollArrowHLength;
-    if (orientation == wxDOWN)
-        outRect.y = inRect.y + inRect.height -  scrollArrowVLength;
-    else if (orientation == wxUP)
-        outRect.y = inRect.y;
-    else
+    if (orientation == wxDOWN) 
+        outRect.y = inRect.y + inRect.height -  scrollArrowVLength; 
+    else if (orientation == wxUP) 
+        outRect.y = inRect.y; 
+    else 
          outRect.y = (inRect.y + inRect.height - 3 * gtk_widget_get_style(wxGTKPrivate::GetNotebookWidget())->ythickness - scrollArrowVLength) / 2;
 
     outRect.width = scrollArrowHLength;
@@ -426,11 +426,11 @@ void wxAuiGtkTabArt::DrawButton(wxDC& dc, wxWindow* wnd, const wxRect& inRect, i
     switch (bitmapID)
     {
         case wxAUI_BUTTON_CLOSE:
-            if (orientation != wxUP)
-                rect.y -= 2 * gtk_widget_get_style(wxGTKPrivate::GetButtonWidget())->ythickness;
-            else
-                rect.y -= gtk_widget_get_style(wxGTKPrivate::GetButtonWidget())->ythickness;
-            if (HasFlag(wxAUI_NB_LEFT))
+            if (orientation != wxUP) 
+                rect.y -= 2 * gtk_widget_get_style(wxGTKPrivate::GetButtonWidget())->ythickness; 
+            else 
+                rect.y -= gtk_widget_get_style(wxGTKPrivate::GetButtonWidget())->ythickness; 
+            if (HasFlag(wxAUI_NB_LEFT)) 
                 rect.x -= 4 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder;
             rect = DrawCloseButton(dc, widget, buttonState, rect, orientation, NULL);
             break;
@@ -443,31 +443,31 @@ void wxAuiGtkTabArt::DrawButton(wxDC& dc, wxWindow* wnd, const wxRect& inRect, i
             rect = DrawSimpleArrow(dc, widget, buttonState, rect, orientation, GTK_ARROW_RIGHT);
             break;
 
-        case wxAUI_BUTTON_UP:
-            rect.width = wnd->GetRect().GetWidth();
-            rect = DrawSimpleArrow(dc, widget, buttonState, rect, orientation, GTK_ARROW_UP);
-            break;
-
-        case wxAUI_BUTTON_DOWN:
-            rect = DrawSimpleArrow(dc, widget, buttonState, rect, orientation, GTK_ARROW_DOWN);
-            break;
+        case wxAUI_BUTTON_UP: 
+            rect.width = wnd->GetRect().GetWidth(); 
+            rect = DrawSimpleArrow(dc, widget, buttonState, rect, orientation, GTK_ARROW_UP); 
+            break; 
+ 
+        case wxAUI_BUTTON_DOWN: 
+            rect = DrawSimpleArrow(dc, widget, buttonState, rect, orientation, GTK_ARROW_DOWN); 
+            break; 
 
         case wxAUI_BUTTON_WINDOWLIST:
             {
-                int scrollArrowHLength, scrollArrowVLength;
-                gtk_widget_style_get(widget,
-                                     "scroll-arrow-hlength", &scrollArrowHLength,
-                                     "scroll-arrow-vlength", &scrollArrowVLength,
-                                     NULL);
-                rect.height = 1.5 * scrollArrowVLength;
-                rect.width = 1.5 * scrollArrowHLength;
+                int scrollArrowHLength, scrollArrowVLength; 
+                gtk_widget_style_get(widget, 
+                                     "scroll-arrow-hlength", &scrollArrowHLength, 
+                                     "scroll-arrow-vlength", &scrollArrowVLength, 
+                                     NULL); 
+                rect.height = 1.5 * scrollArrowVLength; 
+                rect.width = 1.5 * scrollArrowHLength; 
                 rect.x = inRect.x + inRect.width - rect.width;
 
-                if (orientation == wxUP)
-                {
-                    if (HasFlag(wxAUI_NB_LEFT))
-                        rect.x -= 4 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder;
-                }
+                if (orientation == wxUP) 
+                { 
+                    if (HasFlag(wxAUI_NB_LEFT)) 
+                        rect.x -= 4 * GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget())->tab_vborder; 
+                } 
 
                 if (buttonState == wxAUI_BUTTON_STATE_HOVER)
                     wxRendererNative::Get().DrawComboBoxDropButton(wnd, dc, rect, wxCONTROL_CURRENT);
@@ -488,10 +488,10 @@ wxSize wxAuiGtkTabArt::GetBestTabSize(wxWindow* wnd, const wxAuiPaneInfoPtrArray
     SetMeasuringFont(m_normalFont);
     SetSelectedFont(m_normalFont);
 
-    wxSize tabSize = wxAuiGenericTabArt::GetBestTabSize(wnd, pages, requiredBmpSize);
-    tabSize.IncBy(3 * gtk_widget_get_style(wxGTKPrivate::GetNotebookWidget())->xthickness,
-                   3 * gtk_widget_get_style(wxGTKPrivate::GetNotebookWidget())->ythickness);
-    return tabSize;
+    wxSize tabSize = wxAuiGenericTabArt::GetBestTabSize(wnd, pages, requiredBmpSize); 
+    tabSize.IncBy(3 * gtk_widget_get_style(wxGTKPrivate::GetNotebookWidget())->xthickness, 
+                   3 * gtk_widget_get_style(wxGTKPrivate::GetNotebookWidget())->ythickness); 
+    return tabSize; 
 }
 
 wxSize wxAuiGtkTabArt::GetTabSize(wxDC& dc, wxWindow* wnd, const wxString& caption, const wxBitmap& bitmap, bool active, int closeButtonState, int* extent)