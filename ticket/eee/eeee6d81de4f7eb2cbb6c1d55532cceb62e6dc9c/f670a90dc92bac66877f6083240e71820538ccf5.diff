Index: src/mac/carbon/thread.cpp
===================================================================
--- src/mac/carbon/thread.cpp	(revision 52157)
+++ src/mac/carbon/thread.cpp	(working copy)
@@ -402,6 +402,7 @@ wxMutexError wxMutexInternal::Unlock()
     if (err != noErr)
     {
         wxLogSysError( wxT("Could not unlock mutex") );
+		wxFAIL;
         return wxMUTEX_MISC_ERROR;
     }
 
@@ -1096,7 +1097,7 @@ bool wxThreadInternal::Create( wxThread 
 
     if ( m_notifyQueueId == kInvalidID )
     {
-        OSStatus err = MPCreateQueue( &m_notifyQueueId );
+        err = MPCreateQueue( &m_notifyQueueId );
         if (err != noErr)
         {
             wxLogSysError( wxT("Cant create the thread event queue") );
@@ -1589,6 +1590,13 @@ unsigned long wxThread::GetId() const
     return (unsigned long)m_internal->GetId();
 }
 
+
+wxThreadIdType wxThread::GetMainThreadId()
+{
+	return gs_idMainThread;
+}
+
+
 // -----------------------------------------------------------------------------
 // state tests
 // -----------------------------------------------------------------------------

Property changes on: src/wxWindows.xcodeproj
___________________________________________________________________
Modified: svn:ignore
   - *.pbxuser

   + *.pbxuser
*.perspectivev3


Index: src/wxWindows.xcodeproj/project.pbxproj
===================================================================
--- src/wxWindows.xcodeproj/project.pbxproj	(revision 52157)
+++ src/wxWindows.xcodeproj/project.pbxproj	(working copy)
@@ -1127,6 +1127,8 @@
 		61048AE30B278C9A009C253D /* srchctrl.h in Headers */ = {isa = PBXBuildFile; fileRef = 61048AE10B278C9A009C253D /* srchctrl.h */; };
 		61048BE90B27B7D0009C253D /* srchctlg.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 61048BE80B27B7D0009C253D /* srchctlg.cpp */; };
 		61048BEA0B27B7D0009C253D /* srchctlg.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 61048BE80B27B7D0009C253D /* srchctlg.cpp */; };
+		A4A152C10E43EC420068CAF8 /* threadsafelog.cpp in Sources */ = {isa = PBXBuildFile; fileRef = A4A152C00E43EC420068CAF8 /* threadsafelog.cpp */; };
+		A4A152C20E43EC420068CAF8 /* threadsafelog.cpp in Sources */ = {isa = PBXBuildFile; fileRef = A4A152C00E43EC420068CAF8 /* threadsafelog.cpp */; };
 /* End PBXBuildFile section */
 
 /* Begin PBXBuildRule section */
@@ -1348,6 +1350,9 @@
 		61048A700B277DE5009C253D /* print.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = print.h; path = private/print.h; sourceTree = "<group>"; };
 		61048AE10B278C9A009C253D /* srchctrl.h */ = {isa = PBXFileReference; fileEncoding = 30; indentWidth = 4; lastKnownFileType = sourcecode.c.h; path = srchctrl.h; sourceTree = "<group>"; tabWidth = 4; usesTabs = 0; };
 		61048BE80B27B7D0009C253D /* srchctlg.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = srchctlg.cpp; sourceTree = "<group>"; };
+		A47AF7F60E2534190080D9AA /* apptrait.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = apptrait.h; sourceTree = "<group>"; };
+		A4A152BD0E43EC200068CAF8 /* threadsafelog.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = threadsafelog.h; sourceTree = "<group>"; };
+		A4A152C00E43EC420068CAF8 /* threadsafelog.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = threadsafelog.cpp; sourceTree = "<group>"; };
 		CA0CB57B0450773900000102 /* accesscmn.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = accesscmn.cpp; sourceTree = "<group>"; };
 		CA0CB57C0450773900000102 /* datacmn.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = datacmn.cpp; sourceTree = "<group>"; };
 		CA0CB57D0450773900000102 /* dpycmn.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = dpycmn.cpp; sourceTree = "<group>"; };
@@ -2319,6 +2324,7 @@
 			children = (
 				F5A85C1E01FA022A0175ACA7 /* accel.h */,
 				F5A85C1F01FA022A0175ACA7 /* app.h */,
+				A47AF7F60E2534190080D9AA /* apptrait.h */,
 				F5A85C2001FA022A0175ACA7 /* arrimpl.cpp */,
 				F5CC83D90379C17C01000133 /* artprov.h */,
 				F5A85C2101FA022A0175ACA7 /* bitmap.h */,
@@ -2511,6 +2517,7 @@
 				F5A85F3D01FA022B0175ACA7 /* textfile.h */,
 				F5A85F3E01FA022B0175ACA7 /* tglbtn.h */,
 				F5A85F3F01FA022B0175ACA7 /* thread.h */,
+				A4A152BD0E43EC200068CAF8 /* threadsafelog.h */,
 				F5CC83E80379C20901000133 /* thrimpl.cpp */,
 				F5A85F4101FA022B0175ACA7 /* timer.h */,
 				F5A85F4201FA022B0175ACA7 /* tipdlg.h */,
@@ -2906,6 +2913,7 @@
 				F5A8605201FA022C0175ACA7 /* textbuf.cpp */,
 				F5A8605301FA022C0175ACA7 /* textcmn.cpp */,
 				F5A8605401FA022C0175ACA7 /* textfile.cpp */,
+				A4A152C00E43EC420068CAF8 /* threadsafelog.cpp */,
 				F5A8605501FA022C0175ACA7 /* timercmn.cpp */,
 				F5A8605601FA022C0175ACA7 /* tokenzr.cpp */,
 				F5A8605701FA022C0175ACA7 /* toplvcmn.cpp */,
@@ -3354,10 +3362,12 @@
 		0867D690FE84028FC02AAC07 /* Project object */ = {
 			isa = PBXProject;
 			buildConfigurationList = 18B5B99E08564B5D002803C9 /* Build configuration list for PBXProject "wxWindows" */;
+			compatibilityVersion = "Xcode 2.4";
 			hasScannedForEncodings = 1;
 			mainGroup = 0867D691FE84028FC02AAC07 /* wxWindows */;
 			productRefGroup = 034768DDFF38A45A11DB9C8B /* Products */;
 			projectDirPath = "";
+			projectRoot = ..;
 			targets = (
 				4086C742063AB2FF00D4CD53 /* static */,
 				4086CA55063AB30000D4CD53 /* dynamic */,
@@ -3952,6 +3962,7 @@
 				40C8AA600C538FDD006D5BE9 /* utilscocoa.mm in Sources */,
 				40827E120CA0FABD00C14F94 /* xh_richtext.cpp in Sources */,
 				40827E130CA0FABD00C14F94 /* xh_propdlg.cpp in Sources */,
+				A4A152C20E43EC420068CAF8 /* threadsafelog.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -4498,6 +4509,7 @@
 				40C8AA610C538FDD006D5BE9 /* utilscocoa.mm in Sources */,
 				40827E140CA0FABD00C14F94 /* xh_richtext.cpp in Sources */,
 				40827E150CA0FABD00C14F94 /* xh_propdlg.cpp in Sources */,
+				A4A152C10E43EC420068CAF8 /* threadsafelog.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -4749,13 +4761,34 @@
 		18B5B99F08564B5D002803C9 /* Development */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
-				GCC_ENABLE_FIX_AND_CONTINUE = YES;
 				GCC_OPTIMIZATION_LEVEL = 1;
 				GCC_PREPROCESSOR_DEFINITIONS = "__WXDEBUG__\n";
+				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
 				GCC_WARN_ABOUT_DEPRECATED_FUNCTIONS = NO;
+				GCC_WARN_ABOUT_MISSING_NEWLINE = YES;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_HIDDEN_VIRTUAL_FUNCTIONS = YES;
+				GCC_WARN_INITIALIZER_NOT_FULLY_BRACKETED = YES;
+				GCC_WARN_MISSING_PARENTHESES = YES;
+				GCC_WARN_NON_VIRTUAL_DESTRUCTOR = YES;
+				GCC_WARN_PROTOTYPE_CONVERSION = YES;
+				GCC_WARN_SHADOW = YES;
+				GCC_WARN_SIGN_COMPARE = YES;
+				GCC_WARN_TYPECHECK_CALLS_TO_PRINTF = YES;
+				GCC_WARN_UNINITIALIZED_AUTOS = NO;
+				GCC_WARN_UNUSED_LABEL = YES;
+				GCC_WARN_UNUSED_PARAMETER = YES;
+				GCC_WARN_UNUSED_VALUE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				HEADER_SEARCH_PATHS = "$(SRCROOT)/../include";
 				PRODUCT_NAME = wx_mac;
 				SDKROOT = /Developer/SDKs/MacOSX10.4u.sdk;
-				ZERO_LINK = YES;
+				WARNING_CFLAGS = (
+					"-Wall",
+					"-Wundef",
+					"-Wno-ctor-dtor-privacy",
+				);
+				ZERO_LINK = NO;
 			};
 			name = Development;
 		};
@@ -4766,9 +4799,30 @@
 					ppc,
 					i386,
 				);
+				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
 				GCC_WARN_ABOUT_DEPRECATED_FUNCTIONS = NO;
+				GCC_WARN_ABOUT_MISSING_NEWLINE = YES;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_INITIALIZER_NOT_FULLY_BRACKETED = YES;
+				GCC_WARN_MISSING_PARENTHESES = YES;
+				GCC_WARN_NON_VIRTUAL_DESTRUCTOR = YES;
+				GCC_WARN_PROTOTYPE_CONVERSION = YES;
+				GCC_WARN_SHADOW = YES;
+				GCC_WARN_SIGN_COMPARE = YES;
+				GCC_WARN_TYPECHECK_CALLS_TO_PRINTF = YES;
+				GCC_WARN_UNINITIALIZED_AUTOS = YES;
+				GCC_WARN_UNUSED_LABEL = YES;
+				GCC_WARN_UNUSED_PARAMETER = YES;
+				GCC_WARN_UNUSED_VALUE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				HEADER_SEARCH_PATHS = "$(SRCROOT)/../include";
 				PRODUCT_NAME = wx_mac;
 				SDKROOT = /Developer/SDKs/MacOSX10.4u.sdk;
+				WARNING_CFLAGS = (
+					"-Wall",
+					"-Wundef",
+					"-Wno-ctor-dtor-privacy",
+				);
 				ZERO_LINK = NO;
 			};
 			name = Deployment;
Index: src/regex/regc_locale.c
===================================================================
--- src/regex/regc_locale.c	(revision 52157)
+++ src/regex/regc_locale.c	(working copy)
@@ -16,7 +16,9 @@
  *  for wxWidgets are under the wxWidgets licence, see README for details.
  */
 
+#ifndef CONST
 #define CONST const
+#endif
 
 /* ASCII character-name table */
 
Index: src/common/appbase.cpp
===================================================================
--- src/common/appbase.cpp	(revision 52157)
+++ src/common/appbase.cpp	(working copy)
@@ -41,6 +41,7 @@
 #include "wx/filename.h"
 #include "wx/msgout.h"
 #include "wx/tokenzr.h"
+#include "wx/threadsafelog.h"
 
 #if !defined(__WXMSW__) || defined(__WXMICROWIN__)
   #include  <signal.h>      // for SIGTRAP used by wxTrap()
@@ -135,6 +136,10 @@ wxAppConsole::wxAppConsole()
     m_traits = NULL;
 #endif
 #endif
+	
+#if wxUSE_THREAD_SAFE_LOG
+	m_pThreadSafeLogHandler = NULL;
+#endif	
 }
 
 wxAppConsole::~wxAppConsole()
@@ -198,11 +203,21 @@ bool wxAppConsole::OnInit()
         return false;
 #endif // wxUSE_CMDLINE_PARSER
 
+#if wxUSE_THREAD_SAFE_LOG
+	wxLog::GetActiveTarget();
+	m_pThreadSafeLogHandler = new wxThreadSafeLog;
+#endif
+	
     return true;
 }
 
 int wxAppConsole::OnExit()
 {
+#if wxUSE_THREAD_SAFE_LOG
+	delete m_pThreadSafeLogHandler;
+	m_pThreadSafeLogHandler = NULL;
+#endif
+	
 #if wxUSE_CONFIG
     // delete the config object if any (don't use Get() here, but Set()
     // because Get() could create a new config object)
Index: src/common/threadsafelog.cpp
===================================================================
--- src/common/threadsafelog.cpp	(revision 0)
+++ src/common/threadsafelog.cpp	(revision 52157)
@@ -0,0 +1,132 @@
+// --
+// --	threadsafelog.cpp
+// --
+// --
+// --	revision   	$Rev$
+// --	changed by	$Author$
+// --	modified	$Date$
+// --
+// --	Created by Hank Schultz on 8/31/07.
+// --
+// --
+
+#include "wx/wxprec.h"
+#include "wx/threadsafelog.h"
+
+#if wxUSE_LOG && wxUSE_THREADS && wxUSE_THREAD_SAFE_LOG
+
+#include "wx/listimpl.cpp"
+
+
+WX_DEFINE_LIST(wxThreadSafeLogList);
+
+
+#pragma mark  -- Constructors and Destructors --
+
+wxThreadSafeLog::wxThreadSafeLog( void )
+{
+}
+
+
+
+wxThreadSafeLog::~wxThreadSafeLog( void )
+{
+}
+
+
+void wxThreadSafeLog::Flush()
+{
+	if ( wxThread::IsMain() )
+	{
+		bool bWantsMore = false;
+		
+		wxUint32 count = 0;
+		
+		do
+		{
+			if ( ( count % 100 == 0 ) &&
+				 ( bWantsMore ) )
+			{
+				// This will prevent a program from appearing to hang
+				// due to massive amounts of logging from background threads.
+				//
+				// We also shouldn't be yielding if we own the mutex lock, so
+				// we do it up here.
+				wxYield();
+			}
+			
+			// We lock and unlock the mutex every time through the while loop
+			// so that we aren't holding up other threads in going through the
+			// queue.
+			wxMutexLocker zeus( m_queueMutex );
+			
+			if( !m_MsgQueue.empty() )
+			{
+				wxThreadSafeLogEntry * entryToPrint = m_MsgQueue.front();
+				
+				// We've already verified that we're in the main thread.  We
+				// only add to the queue in background threads, so this won't
+				// cause an infinite loop.  In fact, this makes subclassing
+				// easier.
+				DoLog(entryToPrint->level,entryToPrint->msg,entryToPrint->timestamp);
+				m_MsgQueue.pop_front();
+				delete entryToPrint;
+				
+				count++;
+				
+				bWantsMore = !m_MsgQueue.empty();
+			}
+			
+		} while ( bWantsMore );
+		
+		wxLogPassThrough::Flush();
+	}
+}
+
+
+void wxThreadSafeLog::DoLog(wxLogLevel level, const wxChar *msg, time_t timestamp)
+{
+	if ( !wxThread::IsMain() )
+	{
+	#ifdef __WXDEBUG__
+		if ( level == wxLOG_Debug )
+		{
+			// This is so that when you step over a wxLogDebug in the debugger
+			// it will actually show up right away instead of waiting for the
+			// GUI thread to flush the log entries.
+			wxMutexGuiEnter();
+			// The use of the mutex is because very rare random crashes have
+			// been observed inside this function on Mac OS X.  These crashes
+			// always coincide with the GUI thread being busy drawing.
+			wxMessageOutputDebug().Printf( wxT("Thread ID 0x%x - ") + wxString(msg) + wxT("\n"), wxUint32(wxThread::GetCurrentId()) );
+			wxMutexGuiLeave();
+		}
+		else
+		{
+	#endif
+		
+			wxThreadSafeLogEntry * entryToPush = new wxThreadSafeLogEntry;
+			entryToPush->level=level;
+			entryToPush->msg=msg;
+			entryToPush->timestamp=timestamp;
+			
+			wxMutexLocker theQLocker( m_queueMutex );
+			m_MsgQueue.push_back(entryToPush);
+		
+	#ifdef __WXDEBUG__
+			// This means that *all* wxLog* calls will show up in your console
+			// output when they come from secondary threads.
+			wxMutexGuiEnter();
+			wxMessageOutputDebug().Printf( wxT("Thread ID 0x%x - ") + wxString(msg) + wxT("\n"), wxUint32(wxThread::GetCurrentId()) );
+			wxMutexGuiLeave();
+		}
+	#endif
+	}
+	else
+	{	
+		wxLogPassThrough::DoLog(level, msg, timestamp);
+	}
+}
+
+#endif // wxUSE_LOG && wxUSE_THREADS
+
Index: include/wx/thrimpl.cpp
===================================================================
--- include/wx/thrimpl.cpp	(revision 52157)
+++ include/wx/thrimpl.cpp	(working copy)
@@ -60,6 +60,656 @@ wxMutexError wxMutex::Unlock()
     return m_internal->Unlock();
 }
 
+
+#if wxUSE_RW_MUTEX
+// ----------------------------------------------------------------------------
+// wxReadWriteMutexInternal
+// ----------------------------------------------------------------------------
+
+struct wxMutexReadCount
+{
+	wxMutexReadCount()
+	: m_ThreadId( wxThread::GetCurrentId() ),
+	m_RecursiveReadCount( 1 )
+	{}
+	
+	wxThreadIdType	m_ThreadId;
+	size_t			m_RecursiveReadCount;
+};
+
+#include <wx/list.h>
+WX_DECLARE_LIST(wxMutexReadCount,wxThreadIdList);
+#include <wx/listimpl.cpp>
+WX_DEFINE_LIST(wxThreadIdList);
+
+
+class wxReadWriteMutexInternal
+{
+public:
+	wxReadWriteMutexInternal( wxMutexType mutexType );
+	~wxReadWriteMutexInternal();
+	
+	wxMutexError ReadLock();
+	wxMutexError TryReadLock();
+	
+	wxMutexError WriteLock();
+	wxMutexError TryWriteLock();
+	
+	wxMutexError Unlock();
+	
+	bool IsOk() const
+	{ return m_isOk; }
+	
+private:
+	int					m_CurrentReaders; // number of *threads* with read locks, not number of locks.
+	wxSemaphore			m_ReadLockSemaphore;
+	wxMutex				m_StateChangeMutex;
+	wxMutex				m_WriteLockMutex;
+	
+	bool 				m_isOk;
+	wxThreadIdType		m_write_owner;
+	int					m_recursive_count;
+	wxThreadIdList		m_ActiveReaders; // number of locks per thread
+};
+
+
+
+
+wxReadWriteMutexInternal::wxReadWriteMutexInternal( wxMutexType mutexType )
+: m_CurrentReaders	( 0 ),
+m_ReadLockSemaphore	( 1, 1 ),
+m_StateChangeMutex	( wxMUTEX_DEFAULT ), // not recursive, regardless.
+m_WriteLockMutex	( wxMUTEX_DEFAULT ), // not recursive, regardless.
+m_isOk				( m_ReadLockSemaphore.IsOk() && m_StateChangeMutex.IsOk() && m_WriteLockMutex.IsOk() ),
+m_write_owner		( 0 ),
+m_recursive_count	( -1 ) // recursion is not allowed
+{
+    switch ( mutexType )
+    {
+		case wxMUTEX_SHARED_RECURSIVE:
+		case wxMUTEX_RECURSIVE:
+			m_recursive_count = 0; // recursion IS allowed
+            break;
+			
+        default:
+            wxFAIL_MSG( wxT("unknown mutex type") );
+            // fall through
+			
+		case wxMUTEX_SHARED:
+		case wxMUTEX_DEFAULT:
+            break;
+    }
+	
+    //	m_isOk &= m_ReadLockSemaphore.IsOk();
+}
+
+
+wxReadWriteMutexInternal::~wxReadWriteMutexInternal()
+{
+}
+
+
+wxMutexError wxReadWriteMutexInternal::ReadLock()
+{
+	bool bShouldWait = false;
+	
+	{
+		wxMutexLocker state( m_StateChangeMutex );
+		
+		const wxThreadIdType thread_id = wxThread::GetCurrentId();
+		
+		if ( m_write_owner == thread_id )
+		{
+			if ( m_recursive_count < 0 )
+			{
+				wxFAIL_MSG( wxT("mutex deadlock prevented") );
+				// then recursion isn't allowed AND
+				// we're in a deadlock condition.
+				return wxMUTEX_DEAD_LOCK;
+			}
+			
+			if ( m_recursive_count >= 0 )
+			{
+				// then recursion is allowed.
+				m_recursive_count++;
+				return wxMUTEX_NO_ERROR;
+			}
+			
+			wxFAIL; // That should have accounted for all possibilities.
+		}
+		else
+		{
+			wxThreadIdList::iterator iter = m_ActiveReaders.begin();
+			
+			while ( iter != m_ActiveReaders.end() )
+			{
+				if ( (*iter)->m_ThreadId == thread_id )
+				{
+					// We already have a read lock.  Increment the count.
+					wxASSERT( (*iter)->m_RecursiveReadCount != 0 );
+					(*iter)->m_RecursiveReadCount++;
+					return wxMUTEX_NO_ERROR;
+					break;
+				}
+				
+				iter++;
+			}
+			
+			if ( m_CurrentReaders == 0 )
+				bShouldWait = true;
+			
+			m_CurrentReaders++;
+			
+			m_ActiveReaders.push_back( new wxMutexReadCount() );
+		}
+		
+		// release state change mutex
+	}
+	
+	if ( bShouldWait )
+	{
+		wxMutexLocker starvation_mutex( m_WriteLockMutex );
+		m_ReadLockSemaphore.Wait();
+	}
+	
+	return wxMUTEX_NO_ERROR;
+}
+
+
+wxMutexError wxReadWriteMutexInternal::TryReadLock()
+{
+	bool bShouldWait = false;
+	wxThreadIdList::iterator relevant_iter;
+	
+	{
+		wxMutexLocker state( m_StateChangeMutex );
+		
+		const wxThreadIdType thread_id = wxThread::GetCurrentId();
+
+		if ( m_write_owner == thread_id )
+		{
+			if ( m_recursive_count < 0 )
+			{
+				wxFAIL_MSG( wxT("mutex deadlock prevented") );
+				// then recursion isn't allowed AND
+				// we're in a deadlock condition.
+				return wxMUTEX_DEAD_LOCK;
+			}
+			
+			if ( m_recursive_count >= 0 )
+			{
+				// then recursion is allowed.
+				m_recursive_count++;
+				return wxMUTEX_NO_ERROR;
+			}
+			
+			wxFAIL; // That should have accounted for all possibilities.
+		}
+		else if ( m_write_owner != 0 )
+		{
+			// Write lock has been aquired, and we don't have it.
+			return wxMUTEX_BUSY;
+		}
+		else
+		{
+			wxThreadIdList::iterator iter = m_ActiveReaders.begin();
+			
+			while ( iter != m_ActiveReaders.end() )
+			{
+				if ( (*iter)->m_ThreadId == thread_id )
+				{
+					// We already have a read lock.  Increment the count.
+					wxASSERT( (*iter)->m_RecursiveReadCount != 0 );
+					(*iter)->m_RecursiveReadCount++;
+					return wxMUTEX_NO_ERROR;
+					break;
+				}
+				
+				iter++;
+			}
+			
+			if ( m_CurrentReaders == 0 )
+				bShouldWait = true;
+			
+			m_CurrentReaders++;
+			
+			m_ActiveReaders.push_back( new wxMutexReadCount() );
+			relevant_iter = m_ActiveReaders.end()--;
+			
+			wxASSERT( (*relevant_iter)->m_ThreadId == thread_id );
+		}
+	}
+	
+	wxMutexError output = wxMUTEX_NO_ERROR;
+	
+	if ( bShouldWait )
+	{
+		wxSemaError sema_state = wxSEMA_NO_ERROR;
+		
+		{
+			wxMutexLocker starvation_mutex( m_WriteLockMutex );
+			sema_state = m_ReadLockSemaphore.TryWait();
+		}
+		
+		switch ( sema_state )
+		{
+			case wxSEMA_NO_ERROR:
+				{
+					wxMutexLocker state( m_StateChangeMutex );
+
+					if ( m_recursive_count >= 0 )
+						m_recursive_count++;
+					m_write_owner = wxThread::GetCurrentId();
+				}
+				output = wxMUTEX_NO_ERROR;
+				break;
+				
+			case wxSEMA_INVALID:
+				output = wxMUTEX_INVALID;
+				break;
+				
+			case wxSEMA_BUSY:
+				output = wxMUTEX_BUSY;
+				break;
+				
+			case wxSEMA_TIMEOUT:
+				wxFAIL_MSG(wxT("We didn't specify a timeout here!"));
+				output = wxMUTEX_BUSY;
+				break;
+				
+			case wxSEMA_OVERFLOW:
+				output = wxMUTEX_UNLOCKED;
+				break;
+				
+			case wxSEMA_MISC_ERROR:
+			default:
+				output = wxMUTEX_MISC_ERROR;
+				break;
+		}
+		
+		if ( sema_state != wxSEMA_NO_ERROR )
+		{
+			wxMutexLocker state( m_StateChangeMutex );
+
+			m_ActiveReaders.erase( relevant_iter );
+			m_CurrentReaders--;
+			wxFAIL_MSG( wxT("Failed to aquire semaphore when nothing should own it!") );
+		}
+	}
+
+	return output;
+}
+
+
+wxMutexError wxReadWriteMutexInternal::WriteLock()
+{
+	{
+		wxMutexLocker state( m_StateChangeMutex );
+		const wxThreadIdType thread_id = wxThread::GetCurrentId();
+
+		if ( m_write_owner == thread_id )
+		{
+			if ( m_recursive_count < 0 )
+			{
+				wxFAIL_MSG( wxT("mutex deadlock prevented") );
+				// then recursion isn't allowed AND
+				// we're in a deadlock condition.
+				return wxMUTEX_DEAD_LOCK;
+			}
+			
+			if ( m_recursive_count >= 0 )
+			{
+				// then recursion is allowed.
+				m_recursive_count++;
+				return wxMUTEX_NO_ERROR;
+			}
+		}
+	#ifdef __WXDEBUG__
+		else
+		{
+			wxThreadIdList::iterator iter = m_ActiveReaders.begin();
+			
+			while ( iter != m_ActiveReaders.end() )
+			{
+				if ( (*iter)->m_ThreadId == thread_id )
+				{
+					wxFAIL_MSG( wxT("mutex deadlock prevented.  Can't aquire a write lock from a thread owning a read lock.") );
+					return wxMUTEX_DEAD_LOCK;
+					break;
+				}
+				
+				iter++;
+			}
+		}
+	#endif
+	}
+	
+	wxMutexError output = m_WriteLockMutex.Lock();
+	
+	wxSemaError state = wxSEMA_NO_ERROR;
+	
+	if ( output == wxMUTEX_NO_ERROR )
+		state = m_ReadLockSemaphore.Wait();
+
+	
+	if ( state == wxSEMA_NO_ERROR )
+	{
+		if ( m_recursive_count >= 0 )
+			m_recursive_count++;
+		m_write_owner = wxThread::GetCurrentId();
+		
+		output = wxMUTEX_NO_ERROR;		
+	}
+	else
+	{
+		m_WriteLockMutex.Unlock();
+		
+		switch ( state )
+		{
+			case wxSEMA_NO_ERROR:
+				wxFAIL;
+				break;
+				
+			case wxSEMA_INVALID:
+				output = wxMUTEX_INVALID;
+				break;
+				
+			case wxSEMA_BUSY:
+				output = wxMUTEX_BUSY;
+				break;
+				
+			case wxSEMA_TIMEOUT:
+				wxFAIL_MSG(wxT("We didn't specify a timeout here!"));
+				output = wxMUTEX_BUSY;
+				break;
+				
+			case wxSEMA_OVERFLOW:
+				output = wxMUTEX_UNLOCKED;
+				break;
+				
+			case wxSEMA_MISC_ERROR:
+			default:
+				output = wxMUTEX_MISC_ERROR;
+				break;
+		}
+	}
+	
+	return output;
+}
+
+
+wxMutexError wxReadWriteMutexInternal::TryWriteLock()
+{
+	{
+		wxMutexLocker state( m_StateChangeMutex );
+		const wxThreadIdType thread_id = wxThread::GetCurrentId();
+
+		if ( m_write_owner == thread_id )
+		{
+			if ( m_recursive_count < 0 )
+			{
+				wxFAIL_MSG( wxT("mutex deadlock prevented") );
+				// then recursion isn't allowed AND
+				// we're in a deadlock condition.
+				return wxMUTEX_DEAD_LOCK;
+			}
+			
+			if ( m_recursive_count >= 0 )
+			{
+				// then recursion is allowed.
+				m_recursive_count++;
+				return wxMUTEX_NO_ERROR;
+			}
+		}
+	#ifdef __WXDEBUG__
+		else
+		{
+			wxThreadIdList::iterator iter = m_ActiveReaders.begin();
+			
+			while ( iter != m_ActiveReaders.end() )
+			{
+				if ( (*iter)->m_ThreadId == thread_id )
+				{
+					wxFAIL_MSG( wxT("mutex deadlock prevented.  Can't aquire a write lock from a thread owning a read lock.") );
+					return wxMUTEX_DEAD_LOCK;
+					break;
+				}
+				
+				iter++;
+			}
+		}
+	#endif		
+	}
+	
+	wxMutexError output = m_WriteLockMutex.TryLock();
+	wxSemaError state = wxSEMA_NO_ERROR;
+
+	if ( output == wxMUTEX_NO_ERROR )
+		state = m_ReadLockSemaphore.TryWait();
+	
+	
+	if ( state == wxSEMA_NO_ERROR )
+	{
+		if ( m_recursive_count >= 0 )
+			m_recursive_count++;
+		m_write_owner = wxThread::GetCurrentId();
+		
+		output = wxMUTEX_NO_ERROR;		
+	}
+	else
+	{
+		m_WriteLockMutex.Unlock();
+		
+		switch ( state )
+		{
+			case wxSEMA_NO_ERROR:
+				wxFAIL;
+				break;
+				
+			case wxSEMA_INVALID:
+				output = wxMUTEX_INVALID;
+				break;
+				
+			case wxSEMA_BUSY:
+				output = wxMUTEX_BUSY;
+				break;
+				
+			case wxSEMA_TIMEOUT:
+				wxFAIL_MSG(wxT("We didn't specify a timeout here!"));
+				output = wxMUTEX_BUSY;
+				break;
+				
+			case wxSEMA_OVERFLOW:
+				output = wxMUTEX_UNLOCKED;
+				break;
+				
+			case wxSEMA_MISC_ERROR:
+			default:
+				output = wxMUTEX_MISC_ERROR;
+				break;
+		}
+	}
+	
+	return output;
+}
+
+
+wxMutexError wxReadWriteMutexInternal::Unlock()
+{
+	wxMutexLocker state( m_StateChangeMutex );
+	const wxThreadIdType thread_id = wxThread::GetCurrentId();
+
+	wxMutexError output = wxMUTEX_NO_ERROR;
+	bool bShouldPost = false;
+	
+	if  ( m_write_owner == thread_id )
+	{
+		if ( m_recursive_count >= 0 )
+		{
+			// that is, if recursion is allowed and we own the write lock.
+			
+			if ( --m_recursive_count == 0 )
+				m_write_owner = 0;
+			else
+				return wxMUTEX_NO_ERROR;
+		}
+		else
+		{
+			// recursion is NOT allowed and we own the write lock
+			m_write_owner = 0;
+		}
+		
+		bShouldPost = true;
+		output = m_WriteLockMutex.Unlock();
+	}
+	else
+	{
+		if ( m_CurrentReaders <= 0 )
+		{
+			wxFAIL_MSG(wxT("We don't own a write lock, and no one owns a read lock.  This mutex can't be unlocked!"));
+			output = wxMUTEX_UNLOCKED;
+		}
+		else 
+		{
+			wxThreadIdList::iterator iter = m_ActiveReaders.begin();
+			
+			while ( iter != m_ActiveReaders.end() )
+			{
+				if ( (*iter)->m_ThreadId == thread_id )
+				{
+					wxASSERT( (*iter)->m_RecursiveReadCount != 0 );
+
+					if ( --(*iter)->m_RecursiveReadCount <= 0 )
+					{
+						m_ActiveReaders.erase( iter );
+					}
+					else
+					{
+						// Then we still have other read locks on this thread,
+						// so there's no reason to do anything else in this function.
+						return wxMUTEX_NO_ERROR;
+					}
+					break;
+				}
+				
+				iter++;
+			}
+			
+			
+			if ( --m_CurrentReaders == 0 )
+				bShouldPost = true;
+		}
+	}
+	
+	
+	if ( ( bShouldPost ) &&
+		 ( output == wxMUTEX_NO_ERROR ) )
+	{
+		wxSemaError sema_state = m_ReadLockSemaphore.Post();
+		
+		switch ( sema_state )
+		{
+			case wxSEMA_NO_ERROR:
+				output = wxMUTEX_NO_ERROR;
+				break;
+				
+			case wxSEMA_INVALID:
+				output = wxMUTEX_INVALID;
+				break;
+				
+			case wxSEMA_BUSY:
+				output = wxMUTEX_BUSY;
+				break;
+				
+			case wxSEMA_TIMEOUT:
+				wxFAIL_MSG(wxT("We didn't specify a timeout here!"));
+				output = wxMUTEX_BUSY;
+				break;
+				
+			case wxSEMA_OVERFLOW:
+				output = wxMUTEX_UNLOCKED;
+				break;
+				
+			case wxSEMA_MISC_ERROR:
+			default:
+				output = wxMUTEX_MISC_ERROR;
+				break;
+		}
+	}
+	
+	return output;
+}
+
+
+
+// ----------------------------------------------------------------------------
+// wxReadWriteMutex
+// ----------------------------------------------------------------------------
+
+
+wxReadWriteMutex::wxReadWriteMutex(wxMutexType mutexType)
+{
+    m_internal = new wxReadWriteMutexInternal(mutexType);
+	
+    if ( !m_internal->IsOk() )
+    {
+        delete m_internal;
+        m_internal = NULL;
+    }
+}
+
+wxReadWriteMutex::~wxReadWriteMutex()
+{
+    delete m_internal;
+}
+
+bool wxReadWriteMutex::IsOk() const
+{
+    return m_internal != NULL;
+}
+
+wxMutexError wxReadWriteMutex::ReadLock()
+{
+    wxCHECK_MSG( m_internal, wxMUTEX_INVALID,
+				_T("wxReadWriteMutex::ReadLock(): not initialized") );
+	
+    return m_internal->ReadLock();
+}
+
+wxMutexError wxReadWriteMutex::TryReadLock()
+{
+    wxCHECK_MSG( m_internal, wxMUTEX_INVALID,
+				_T("wxReadWriteMutex::TryReadLock(): not initialized") );
+	
+    return m_internal->TryReadLock();
+}
+
+wxMutexError wxReadWriteMutex::WriteLock()
+{
+    wxCHECK_MSG( m_internal, wxMUTEX_INVALID,
+				_T("wxReadWriteMutex::WriteLock(): not initialized") );
+	
+    return m_internal->WriteLock();
+}
+
+wxMutexError wxReadWriteMutex::TryWriteLock()
+{
+    wxCHECK_MSG( m_internal, wxMUTEX_INVALID,
+				_T("wxReadWriteMutex::TryWriteLock(): not initialized") );
+	
+    return m_internal->TryWriteLock();
+}
+
+wxMutexError wxReadWriteMutex::Unlock()
+{
+    wxCHECK_MSG( m_internal, wxMUTEX_INVALID,
+				_T("wxReadWriteMutex::Unlock(): not initialized") );
+	
+    return m_internal->Unlock();
+}
+#endif // #if wxUSE_RW_MUTEX
+
+
 // --------------------------------------------------------------------------
 // wxConditionInternal
 // --------------------------------------------------------------------------
Index: include/wx/app.h
===================================================================
--- include/wx/app.h	(revision 52157)
+++ include/wx/app.h	(working copy)
@@ -27,6 +27,7 @@ class WXDLLIMPEXP_FWD_BASE wxAppTraits;
 class WXDLLIMPEXP_FWD_BASE wxCmdLineParser;
 class WXDLLIMPEXP_FWD_BASE wxLog;
 class WXDLLIMPEXP_FWD_BASE wxMessageOutput;
+class WXDLLIMPEXP_FWD_BASE wxThreadSafeLog;
 
 #if wxUSE_GUI
     class WXDLLIMPEXP_FWD_BASE wxEventLoop;
@@ -315,6 +316,10 @@ protected:
     wxAppTraits *m_traits;
 
 
+#if	wxUSE_THREAD_SAFE_LOG
+	wxThreadSafeLog *	m_pThreadSafeLogHandler;
+#endif
+
     // the application object is a singleton anyhow, there is no sense in
     // copying it
     DECLARE_NO_COPY_CLASS(wxAppConsole)
Index: include/wx/threadsafelog.h
===================================================================
--- include/wx/threadsafelog.h	(revision 0)
+++ include/wx/threadsafelog.h	(revision 52157)
@@ -0,0 +1,93 @@
+///
+///	@file threadsafelog.h
+///
+///	@class wxThreadSafeLog wxThreadSafeLog.h wxThreadSafeLog.cpp
+///
+///	@brief wxThreadSafeLog ensures log entries are handled by the main thread
+///
+/// Log entries are automatically flushed in the main thread.  If you derive
+/// from this class, note that Flush() will call DoLog from the main thread,
+/// and entries are only queued in background threads.
+/// Therefore, if DoLog() is called in the main thread, you should output
+/// the log.  
+///
+///	$Rev$
+///	$Author$
+///	$Date$
+///
+///	Created by Hank Schultz on 8/31/07.
+///
+///
+
+
+#ifndef _WX_THREAD_SAFE_LOG_H_
+#define _WX_THREAD_SAFE_LOG_H_
+
+#include "wx/defs.h"
+
+#include "wx/list.h"
+#include "wx/log.h"
+#include "wx/thread.h"
+
+#if wxUSE_LOG && wxUSE_THREADS 
+
+#ifndef wxUSE_THREAD_SAFE_LOG
+#error This new flag has not been defined.
+#elif ( wxUSE_THREAD_SAFE_LOG == 0 )
+#error This new flag has not been defined.
+//#define wxUSE_THREAD_SAFE_LOG 1
+#endif
+
+#if wxUSE_THREAD_SAFE_LOG
+
+#ifdef _WIN32
+#	pragma warning ( disable: 4068 ) // unknown pragma
+#	pragma warning ( push )
+#	pragma warning ( disable: 4251 ) // DLL interface
+#endif
+
+struct wxThreadSafeLogEntry
+{
+	wxLogLevel level;
+	wxString msg;
+	time_t timestamp;
+};
+
+
+WX_DECLARE_LIST(wxThreadSafeLogEntry,wxThreadSafeLogList);
+
+
+#pragma mark  -- class wxThreadSafeLog --
+
+class WXDLLIMPEXP_BASE wxThreadSafeLog : public wxLogPassThrough
+{
+public:
+
+	#pragma mark  				-- Constructors and Destructors --
+
+								wxThreadSafeLog( void );
+
+	virtual						~wxThreadSafeLog( void );
+	
+	virtual void				DoLog(wxLogLevel level, const wxChar *msg, time_t timestamp);
+	
+	virtual void                Flush( void );
+
+
+protected:
+	#pragma mark 				-
+	#pragma mark  				-- Member Variables --
+	
+	
+	wxThreadSafeLogList		m_MsgQueue; ///< the thread-safe queue where messages are stored from non-main threads.
+	wxMutex				    m_queueMutex; ///< mutex to protect the queue.
+};
+
+
+#ifdef _WIN32
+#	pragma warning ( pop )
+#endif
+
+#endif // wxUSE_THREAD_SAFE_LOG
+#endif // wxUSE_LOG && wxUSE_THREADS
+#endif // _WX_THREAD_SAFE_LOG_H_
Index: include/wx/mac/setup0.h
===================================================================
--- include/wx/mac/setup0.h	(revision 52157)
+++ include/wx/mac/setup0.h	(working copy)
@@ -44,7 +44,7 @@
 // in the version after it completely.
 //
 // Recommended setting: 0 (please update your code)
-#define WXWIN_COMPATIBILITY_2_6 1
+#define WXWIN_COMPATIBILITY_2_6 0
 
 // MSW-only: Set to 0 for accurate dialog units, else 1 for old behaviour when
 // default system font is used for wxWindow::GetCharWidth/Height() instead of
@@ -158,7 +158,7 @@
 //
 // Recommended setting: 0 (unless you only plan to use Windows NT/2000/XP)
 #ifndef wxUSE_UNICODE
-    #define wxUSE_UNICODE 0
+    #define wxUSE_UNICODE 1
 #endif
 
 // Setting wxUSE_WCHAR_T to 1 gives you some degree of Unicode support without
@@ -246,6 +246,9 @@
 //
 // Recommended setting: 0 unless you do plan to develop MT applications
 #define wxUSE_THREADS 1
+#define wxUSE_RW_MUTEX 1
+#define wxUSE_SHARED_MUTEX 1
+#define wxUSE_THREAD_SAFE_LOG 1
 
 // If enabled, compiles wxWidgets streams classes
 //
@@ -435,6 +438,9 @@
 // Set to 1 to use socket classes
 #define wxUSE_SOCKETS       1
 
+// Set to 1 to use the new experimental Boost.Asio socket implementation
+#define wxUSE_ASIO_SOCKETS	1
+
 // Set to 1 to enable virtual file systems (required by wxHTML)
 #define wxUSE_FILESYSTEM    1
 
@@ -1243,7 +1249,7 @@
 #define wxUSE_LIBMSPACK     0
 
 // native toolbar does not support embedding controls yet, please test by setting to 1
-#define wxMAC_USE_NATIVE_TOOLBAR 0
+#define wxMAC_USE_NATIVE_TOOLBAR 1
 
 
 
Index: include/wx/mac/carbon/config_xcode.h
===================================================================
--- include/wx/mac/carbon/config_xcode.h	(revision 52157)
+++ include/wx/mac/carbon/config_xcode.h	(working copy)
@@ -112,6 +112,7 @@
 #define HAVE_VSWPRINTF 1
 #define HAVE_FSEEKO 1
 #define HAVE_SYS_SELECT_H 1
+#define HAVE_DLOPEN 1
 
 #define WXWIN_OS_DESCRIPTION "Darwin 7.9.0 Power Macintosh"
 #define PACKAGE_BUGREPORT "wx-dev@lists.wxwidgets.org"
Index: include/wx/thread.h
===================================================================
--- include/wx/thread.h	(revision 52157)
+++ include/wx/thread.h	(working copy)
@@ -109,11 +109,14 @@ enum wxMutexType
 };
 
 // forward declarations
-class WXDLLIMPEXP_BASE wxThreadHelper;
-class WXDLLIMPEXP_BASE wxConditionInternal;
-class WXDLLIMPEXP_BASE wxMutexInternal;
-class WXDLLIMPEXP_BASE wxSemaphoreInternal;
-class WXDLLIMPEXP_BASE wxThreadInternal;
+class WXDLLIMPEXP_FWD_BASE wxThreadHelper;
+class WXDLLIMPEXP_FWD_BASE wxConditionInternal;
+class WXDLLIMPEXP_FWD_BASE wxMutexInternal;
+class WXDLLIMPEXP_FWD_BASE wxSemaphoreInternal;
+class WXDLLIMPEXP_FWD_BASE wxThreadInternal;
+#if wxUSE_RW_MUTEX
+class WXDLLIMPEXP_FWD_BASE wxReadWriteMutexInternal;
+#endif
 
 // ----------------------------------------------------------------------------
 // A mutex object is a synchronization object whose state is set to signaled
@@ -192,6 +195,129 @@ private:
     wxMutex& m_mutex;
 };
 
+
+#if wxUSE_RW_MUTEX
+// ----------------------------------------------------------------------------
+// A read/write mutex is generally used to allow multiple readers but only one
+// writer.  This is often also referred to as a read/write mutex.
+//
+// Read locks on a shared mutex are always recursive.  Write locks are not
+// recursive unless wxMUTEX_RECURSIVE is passed as the type.
+//
+// This is NOT an upgradable mutex.  It is an error to attempt to aquire a write
+// lock on a thread that owns a read lock.  The reverse will succeed on a
+// recursive mutex.
+//
+// Note that aquiring a ReadLock on a recursive mutex when a write lock is owned
+// by the current thread will succeed.  This will simply increment the count.
+// You still must Unlock afterwards--which will appropriately decrement the
+// count.  The final Unlock releases the read lock.
+//
+// ----------------------------------------------------------------------------
+
+class WXDLLIMPEXP_BASE wxReadWriteMutex
+{
+public:
+    // constructor & destructor
+    // ------------------------
+	
+    // create either default (always safe) or recursive mutex
+    wxReadWriteMutex(wxMutexType mutexType = wxMUTEX_DEFAULT);
+	
+    // destroys the mutex kernel object
+    ~wxReadWriteMutex();
+	
+    // test if the mutex has been created successfully
+    bool IsOk() const;
+	
+    // mutex operations
+    // ----------------
+	
+    // Lock the mutex, blocking on it until it is unlocked by the other thread.
+    // The result of locking a mutex already locked by the current thread
+    // depend on the mutex type.
+    //
+    // The caller must call Unlock() later if ReadLock() returned wxMUTEX_NO_ERROR.
+    wxMutexError ReadLock();
+	
+    // Try to lock the mutex: if it is currently locked, return immediately
+    // with an error. Otherwise the caller must call Unlock().
+    wxMutexError TryReadLock();
+		
+	
+	// The caller must call Unlock() later if WriteLock() returned wxMUTEX_NO_ERROR.
+    wxMutexError WriteLock();
+	
+    // Try to lock the mutex: if it is currently locked, return immediately
+    // with an error. Otherwise the caller must call Unlock().
+    wxMutexError TryWriteLock();
+	
+	
+    // Unlock the mutex. It is an error to unlock an already unlocked mutex
+    wxMutexError Unlock();
+		
+	
+protected:
+    wxReadWriteMutexInternal *m_internal;
+	
+	
+    DECLARE_NO_COPY_CLASS(wxReadWriteMutex)
+};
+
+
+class WXDLLIMPEXP_BASE wxReadMutexLocker
+{
+public:
+    // lock the mutex in the ctor
+    wxReadMutexLocker(wxReadWriteMutex& mutex)
+	: m_isOk(false), m_mutex(mutex)
+	{ m_isOk = ( m_mutex.ReadLock() == wxMUTEX_NO_ERROR ); }
+	
+    // returns true if mutex was successfully locked in ctor
+    bool IsOk() const
+	{ return m_isOk; }
+	
+    // unlock the mutex in dtor
+    ~wxReadMutexLocker()
+	{ if ( IsOk() ) m_mutex.Unlock(); }
+	
+private:
+    // no assignment operator nor copy ctor
+    wxReadMutexLocker(const wxReadMutexLocker&);
+    wxReadMutexLocker& operator=(const wxReadMutexLocker&);
+	
+    bool     m_isOk;
+    wxReadWriteMutex& m_mutex;
+};
+
+
+class WXDLLIMPEXP_BASE wxWriteMutexLocker
+{
+public:
+    // lock the mutex in the ctor
+    wxWriteMutexLocker(wxReadWriteMutex& mutex)
+	: m_isOk(false), m_mutex(mutex)
+	{ m_isOk = ( m_mutex.WriteLock() == wxMUTEX_NO_ERROR ); }
+	
+    // returns true if mutex was successfully locked in ctor
+    bool IsOk() const
+	{ return m_isOk; }
+	
+    // unlock the mutex in dtor
+    ~wxWriteMutexLocker()
+	{ if ( IsOk() ) m_mutex.Unlock(); }
+	
+private:
+    // no assignment operator nor copy ctor
+    wxWriteMutexLocker(const wxWriteMutexLocker&);
+    wxReadMutexLocker& operator=(const wxReadMutexLocker&);
+	
+    bool     m_isOk;
+    wxReadWriteMutex& m_mutex;
+};
+
+#endif // wxUSE_RW_MUTEX
+
 // ----------------------------------------------------------------------------
 // Critical section: this is the same as mutex but is only visible to the
 // threads of the same process. For the platforms which don't have native
@@ -548,6 +674,8 @@ public:
     // identifies a thread inside a process
     wxThreadIdType GetId() const;
 
+	static wxThreadIdType GetMainThreadId();
+
     // called when the thread exits - in the context of this thread
     //
     // NB: this function will not be called if the thread is Kill()ed
Index: include/wx/chkconf.h
===================================================================
--- include/wx/chkconf.h	(revision 52157)
+++ include/wx/chkconf.h	(working copy)
@@ -68,6 +68,23 @@
 #ifdef wxNO_THREADS
 #   undef wxUSE_THREADS
 #   define wxUSE_THREADS 0
+#	undef wxUSE_THREAD_SAFE_LOG
+#	define wxUSE_THREAD_SAFE_LOG 0
+#else
+#	ifdef wxNO_RW_MUTEX
+#		undef wxUSE_RW_MUTEX
+#		define wxUSE_RW_MUTEX 0
+#	else
+#		undef wxUSE_RW_MUTEX
+#		define wxUSE_RW_MUTEX 1
+#	endif
+#	ifdef wxNO_THREAD_SAFE_LOG
+#		undef wxUSE_THREAD_SAFE_LOG
+#		define wxUSE_THREAD_SAFE_LOG 0
+#	else
+#		undef wxUSE_THREAD_SAFE_LOG
+#		define wxUSE_THREAD_SAFE_LOG 1
+#	endif
 #endif /* wxNO_THREADS */
 
 #ifdef wxNO_EXCEPTIONS
@@ -148,6 +165,8 @@
 #       error "wxUSE_LOG must be defined."
 #   else
 #       define wxUSE_LOG 0
+#		undef wxUSE_THREAD_SAFE_LOG
+#		define wxUSE_THREAD_SAFE_LOG 0
 #   endif
 #endif /* !defined(wxUSE_LOG) */
 
Index: include/wx/listimpl.cpp
===================================================================
--- include/wx/listimpl.cpp	(revision 52157)
+++ include/wx/listimpl.cpp	(working copy)
@@ -9,6 +9,9 @@
 // Licence:     wxWindows licence
 /////////////////////////////////////////////////////////////////////////////
 
+#ifndef __WX_LIST_IMPL_CPP__
+#define __WX_LIST_IMPL_CPP__
+
 #if wxUSE_STL
 
 #undef  WX_DEFINE_LIST
@@ -37,3 +40,4 @@
 
 #endif // wxUSE_STL/!wxUSE_STL
 
+#endif // __WX_LIST_IMPL_CPP__
Index: configure.in
===================================================================
--- configure.in	(revision 52157)
+++ configure.in	(working copy)
@@ -373,6 +373,8 @@ if test $DEBUG_CONFIGURE = 1; then
   DEFAULT_wxUSE_NANOX=no
 
   DEFAULT_wxUSE_THREADS=yes
+  DEFAULT_wxUSE_RW_MUTEX=no
+  DEFAULT_wxUSE_THREAD_SAFE_LOG=no
 
   DEFAULT_wxUSE_SHARED=${DEFAULT_wxUSE_SHARED:-yes}
   DEFAULT_wxUSE_OPTIMISE=no
@@ -598,6 +600,8 @@ else
   DEFAULT_wxUSE_NANOX=no
 
   DEFAULT_wxUSE_THREADS=yes
+  DEFAULT_wxUSE_RW_MUTEX=no
+  DEFAULT_wxUSE_THREAD_SAFE_LOG=no
 
   DEFAULT_wxUSE_SHARED=${DEFAULT_wxUSE_SHARED:-yes}
   DEFAULT_wxUSE_OPTIMISE=yes
@@ -1063,6 +1067,18 @@ dnl ------------------------------------
 
 WX_ARG_ENABLE(threads,     [  --enable-threads        use threads], wxUSE_THREADS)
 
+dnl ---------------------------------------------------------------------------
+dnl Other threading-related options
+dnl ---------------------------------------------------------------------------
+
+WX_ARG_ENABLE(rw_mutex,    [  --enable-rw_mutex       use read/write mutex], wxUSE_RW_MUTEX)
+
+if test "$wxUSE_LOG" = "yes"; then
+if test "$wxUSE_THREADS" = "yes"; then
+WX_ARG_ENABLE(thread_safe_log, [  --enable-thread_safe_log use thread-safe addition to logging system], wxUSE_THREAD_SAFE_LOG)
+fi
+fi
+
 if test "$wxUSE_GUI" = "yes"; then
 
 dnl ---------------------------------------------------------------------------
@@ -5690,6 +5706,14 @@ if test "$wxUSE_THREADS" = "yes"; then
   AC_DEFINE(wxUSE_THREADS)
 
   SAMPLES_SUBDIRS="$SAMPLES_SUBDIRS thread"
+  
+  if test "$wxUSE_RW_MUTEX" = "yes"; then
+    AC_DEFINE(wxUSE_RW_MUTEX)
+  fi
+  
+  if test "$wxUSE_LOG" = "yes"; then
+    AC_DEFINE(wxUSE_THREAD_SAFE_LOG)
+  fi
 else
   dnl on some systems, _REENTRANT should be defined if we want to use any _r()
   dnl functions - add tests for other functions here as well
Index: build/bakefiles/build_cfg.bkl
===================================================================
--- build/bakefiles/build_cfg.bkl	(revision 52157)
+++ build/bakefiles/build_cfg.bkl	(working copy)
@@ -37,6 +37,9 @@
                 @echo MSLU=$(MSLU) >>$(BUILD_CFG_FILE)
                 @echo USE_EXCEPTIONS=$(USE_EXCEPTIONS) >>$(BUILD_CFG_FILE)
                 @echo USE_THREADS=$(USE_THREADS) >>$(BUILD_CFG_FILE)
+                @echo USE_THREADSAFE_LOG=$(USE_THREADSAFE_LOG) >> $(BUILD_CFG_FILE)
+                @echo USE_SHARED_MUTEX=$(USE_SHARED_MUTEX) >>$(BUILD_CFG_FILE)
+                @echo USE_RW_MUTEX=$(USE_RW_MUTEX) >>$(BUILD_CFG_FILE)
                 @echo USE_GUI=$(USE_GUI) >>$(BUILD_CFG_FILE)
                 @echo USE_HTML=$(USE_HTML) >>$(BUILD_CFG_FILE)
                 @echo USE_MEDIA=$(USE_MEDIA) >>$(BUILD_CFG_FILE)
Index: build/bakefiles/common.bkl
===================================================================
--- build/bakefiles/common.bkl	(revision 52157)
+++ build/bakefiles/common.bkl	(working copy)
@@ -256,6 +256,15 @@
     <set var="THREAD_DEFINE">
         <if cond="USE_THREADS=='0'">wxNO_THREADS</if>
     </set>
+    <set var="RW_MUTEX_DEFINE">
+    	<if cond="USE_RW_MUTEX=='0'">wxNO_RW_MUTEX</if>
+    </set>
+    <set var="SHARED_MUTEX_DEFINE">
+    	<if cond="USE_SHARED_MUTEX=='0'">wxNO_SHARED_MUTEX</if>
+    </set>
+    <set var="THREADSAFE_LOG_DEFINE">
+    	<if cond="USE_THREADSAFE_LOG=='0'">wxNO_THREAD_SAFE_LOG</if>
+    </set>
 
     <set var="DEBUG_DEFINE">
         <if cond="FORMAT!='autoconf' and BUILD=='debug' and DEBUG_FLAG=='default'">__WXDEBUG__</if>
@@ -480,6 +489,9 @@ $(TAB)$(VC_COMPILER) /EP /nologo "$(DOLL
         <define>$(EXCEPTIONS_DEFINE)</define>
         <define>$(RTTI_DEFINE)</define>
         <define>$(THREAD_DEFINE)</define>
+        <define>$(RW_MUTEX_DEFINE)</define>
+		<define>$(SHARED_MUTEX_DEFINE)</define>
+        <define>$(THREADSAFE_LOG_DEFINE)</define>
         <define>$(UNICODE_DEFINE)</define>
         <define>$(MSLU_DEFINE)</define>
         <if cond="FORMAT!='autoconf'"><define>$(GFXCTX_DEFINE)</define></if>
Index: build/bakefiles/files.bkl
===================================================================
--- build/bakefiles/files.bkl	(revision 52157)
+++ build/bakefiles/files.bkl	(working copy)
@@ -344,6 +344,7 @@ IMPORTANT: please read docs/tech/tn0016.
     src/common/string.cpp
     src/common/sysopt.cpp
     src/common/tarstrm.cpp
+    src/common/threadsafelog.cpp
     src/common/textbuf.cpp
     src/common/textfile.cpp
     src/common/tokenzr.cpp
@@ -454,6 +455,7 @@ IMPORTANT: please read docs/tech/tn0016.
     wx/string.h
     wx/sysopt.h
     wx/tarstrm.h
+    wx/threadsafelog.h
     wx/textbuf.h
     wx/textfile.h
     wx/thread.h
Index: build/bakefiles/config.bkl
===================================================================
--- build/bakefiles/config.bkl	(revision 52157)
+++ build/bakefiles/config.bkl	(working copy)
@@ -266,6 +266,30 @@ Acts according to BUILD by default.
         </description>
     </option>
 
+    <option name="USE_SHARED_MUTEX">
+        <values>0,1</values>
+        <default-value>0</default-value>
+        <description>
+            Enable multi-process shared mutex. (USE_THREADS must be 1, only implemented on Mac OS X)
+        </description>
+    </option>
+
+    <option name="USE_RW_MUTEX">
+        <values>0,1</values>
+        <default-value>0</default-value>
+        <description>
+            Enable read/write mutex. (USE_THREADS must be 1)
+        </description>
+    </option>
+
+	<option name="USE_THREADSAFE_LOG">
+		<values>0,1</values>
+		<default-value>0</default-value>
+		<description>
+			Use thread-safe addition to logging system (USE_LOG must be 1, USE_THREADS must be 1)
+		</description>
+	</option>
+	
     <if cond="FORMAT!='autoconf'">
         <option name="USE_GDIPLUS">
             <values>0,1</values>
@@ -273,7 +297,7 @@ Acts according to BUILD by default.
             <description>
                 Link with gdiplus.lib? (Needed for wxGraphicsContext, will also set wxUSE_GRAPHICS_CONTEXT)
             </description>
-	</option>
+		</option>
     </if>
 
     <option name="OFFICIAL_BUILD">
@@ -454,6 +478,9 @@ Set the version of your Mingw installati
         <set var="USE_EXCEPTIONS">1</set>
         <set var="USE_RTTI">1</set>
         <set var="USE_THREADS">1</set>
+        <set var="USE_THREADSAFE_LOG">0</set>
+        <set var="USE_RW_MUTEX">0</set>
+        <set var="USE_SHARED_MUTEX">0</set>
         <if cond="FORMAT!='autoconf'"><set var="USE_GDIPLUS">0</set></if>
         <set var="DEBUG_INFO">$(DEBUG_INFO_DEFAULT)</set>
         <set var="DEBUG_FLAG">default</set>
Index: build/aclocal/bakefile-lang.m4
===================================================================
--- build/aclocal/bakefile-lang.m4	(revision 52157)
+++ build/aclocal/bakefile-lang.m4	(working copy)
@@ -1,5 +1,5 @@
 dnl
-dnl  This file is part of Bakefile (http://bakefile.sourceforge.net)
+dnl  This file is part of Bakefile (http://www.bakefile.org)
 dnl
 dnl  Copyright (C) 2003-2007 Vaclav Slavik, David Elliott and others
 dnl
@@ -23,77 +23,15 @@ dnl  DEALINGS IN THE SOFTWARE.
 dnl
 dnl  $Id$
 dnl
-dnl  Compiler detection macros by David Elliott
+dnl  Compiler detection macros by David Elliott and Vadim Zeitlin
 dnl
 
 
 dnl ===========================================================================
-dnl Macros to detect non-GNU compilers (MetroWerks, XLC)
+dnl Macros to detect different C/C++ compilers
 dnl ===========================================================================
 
 dnl Based on autoconf _AC_LANG_COMPILER_GNU
-AC_DEFUN([_AC_BAKEFILE_LANG_COMPILER_MWERKS],
-[AC_CACHE_CHECK([whether we are using the Metrowerks _AC_LANG compiler],
-    [bakefile_cv_[]_AC_LANG_ABBREV[]_compiler_mwerks],
-    [AC_TRY_COMPILE([],[#ifndef __MWERKS__
-       choke me
-#endif
-],
-        [bakefile_compiler_mwerks=yes],
-        [bakefile_compiler_mwerks=no])
-    bakefile_cv_[]_AC_LANG_ABBREV[]_compiler_mwerks=$bakefile_compiler_mwerks
-    ])
-])
-
-dnl Loosely based on autoconf AC_PROG_CC
-dnl TODO: Maybe this should wrap the call to AC_PROG_CC and be used instead.
-AC_DEFUN([AC_BAKEFILE_PROG_MWCC],
-[AC_LANG_PUSH(C)
-_AC_BAKEFILE_LANG_COMPILER_MWERKS
-MWCC=`test $bakefile_cv_c_compiler_mwerks = yes && echo yes`
-AC_LANG_POP(C)
-])
-
-dnl Loosely based on autoconf AC_PROG_CXX
-dnl TODO: Maybe this should wrap the call to AC_PROG_CXX and be used instead.
-AC_DEFUN([AC_BAKEFILE_PROG_MWCXX],
-[AC_LANG_PUSH(C++)
-_AC_BAKEFILE_LANG_COMPILER_MWERKS
-MWCXX=`test $bakefile_cv_cxx_compiler_mwerks = yes && echo yes`
-AC_LANG_POP(C++)
-])
-
-dnl Based on autoconf _AC_LANG_COMPILER_GNU
-AC_DEFUN([_AC_BAKEFILE_LANG_COMPILER_XLC],
-[AC_CACHE_CHECK([whether we are using the IBM xlC _AC_LANG compiler],
-    [bakefile_cv_[]_AC_LANG_ABBREV[]_compiler_xlc],
-    [AC_TRY_COMPILE([],[#ifndef __xlC__
-       choke me
-#endif
-],
-        [bakefile_compiler_xlc=yes],
-        [bakefile_compiler_xlc=no])
-    bakefile_cv_[]_AC_LANG_ABBREV[]_compiler_xlc=$bakefile_compiler_xlc
-    ])
-])
-
-dnl Loosely based on autoconf AC_PROG_CC
-AC_DEFUN([AC_BAKEFILE_PROG_XLCC],
-[AC_LANG_PUSH(C)
-_AC_BAKEFILE_LANG_COMPILER_XLC
-XLCC=`test $bakefile_cv_c_compiler_xlc = yes && echo yes`
-AC_LANG_POP(C)
-])
-
-dnl Loosely based on autoconf AC_PROG_CXX
-AC_DEFUN([AC_BAKEFILE_PROG_XLCXX],
-[AC_LANG_PUSH(C++)
-_AC_BAKEFILE_LANG_COMPILER_XLC
-XLCXX=`test $bakefile_cv_cxx_compiler_xlc = yes && echo yes`
-AC_LANG_POP(C++)
-])
-
-dnl Based on autoconf _AC_LANG_COMPILER_GNU
 dnl _AC_BAKEFILE_LANG_COMPILER(NAME, LANG, SYMBOL, IF-YES, IF-NO)
 AC_DEFUN([_AC_BAKEFILE_LANG_COMPILER],
 [
@@ -113,12 +51,34 @@ AC_DEFUN([_AC_BAKEFILE_LANG_COMPILER],
          )
         ]
     )
-    AC_LANG_POP($2)
     if test "x$bakefile_cv_[]_AC_LANG_ABBREV[]_compiler_[]$3" = "xyes"; then
         :; $4
     else
         :; $5
     fi
+    AC_LANG_POP($2)
+])
+
+dnl CodeWarrior Metrowerks compiler defines __MWERKS__ for both C and C++
+AC_DEFUN([AC_BAKEFILE_PROG_MWCC],
+[
+    _AC_BAKEFILE_LANG_COMPILER(Metrowerks, C, __MWERKS__, MWCC=yes)
+])
+
+AC_DEFUN([AC_BAKEFILE_PROG_MWCXX],
+[
+    _AC_BAKEFILE_LANG_COMPILER(Metrowerks, C++, __MWERKS__, MWCXX=yes)
+])
+
+dnl IBM xlC compiler defines __xlC__ for both C and C++
+AC_DEFUN([AC_BAKEFILE_PROG_XLCC],
+[
+    _AC_BAKEFILE_LANG_COMPILER([IBM xlC], C, __xlC__, XLCC=yes)
+])
+
+AC_DEFUN([AC_BAKEFILE_PROG_XLCXX],
+[
+    _AC_BAKEFILE_LANG_COMPILER([IBM xlC], C++, __xlC__, XLCXX=yes)
 ])
 
 dnl recent versions of SGI mipsPro compiler define _SGI_COMPILER_VERSION
@@ -228,7 +188,12 @@ dnl _AC_BAKEFILE_PROG_COMPILER(LANG)
 AC_DEFUN([_AC_BAKEFILE_PROG_COMPILER],
 [
     AC_PROG_$1
+
+    dnl Intel compiler can be used under several different OS and even
+    dnl different architectures (x86, amd64 and Itanium) so it's easier to just
+    dnl always test for it
     AC_BAKEFILE_PROG_INTEL$1
+
     dnl if we're using gcc, we can't be using any of incompatible compilers
     if test "x$G$1" != "xyes"; then
         if test "x$1" = "xC"; then
@@ -255,6 +220,11 @@ AC_DEFUN([_AC_BAKEFILE_PROG_COMPILER],
                 AC_BAKEFILE_PROG_SGI$1
                 ;;
 
+            Linux*)
+                dnl Sun CC is now available under Linux too
+                AC_BAKEFILE_PROG_SUN$1
+                ;;
+
             HP-UX*)
                 AC_BAKEFILE_PROG_HP$1
                 ;;
Index: build/aclocal/bakefile.m4
===================================================================
--- build/aclocal/bakefile.m4	(revision 52157)
+++ build/aclocal/bakefile.m4	(working copy)
@@ -1,5 +1,5 @@
 dnl
-dnl  This file is part of Bakefile (http://bakefile.sourceforge.net)
+dnl  This file is part of Bakefile (http://www.bakefile.org)
 dnl
 dnl  Copyright (C) 2003-2007 Vaclav Slavik and others
 dnl
@@ -126,8 +126,7 @@ AC_DEFUN([AC_BAKEFILE_PLATFORM],
                 PLATFORM_BEOS=1
             ;;
             * )
-                dnl wxWidgets-specific: allow unknown Unix systems
-                dnl AC_MSG_ERROR([Unknown platform: $BAKEFILE_FORCE_PLATFORM])
+                AC_MSG_ERROR([Unknown platform: $BAKEFILE_FORCE_PLATFORM])
             ;;
         esac
     fi
@@ -309,27 +308,17 @@ AC_DEFUN([AC_BAKEFILE_SHARED_LD],
       ;;
 
       *-*-linux* )
-        if test "x$GCC" != "xyes"; then
-            AC_CACHE_CHECK([for Intel compiler], bakefile_cv_prog_icc,
-            [
-                AC_TRY_COMPILE([],
-                    [
-                        #ifndef __INTEL_COMPILER
-                        This is not ICC
-                        #endif
-                    ],
-                    bakefile_cv_prog_icc=yes,
-                    bakefile_cv_prog_icc=no
-                )
-            ])
-            if test "$bakefile_cv_prog_icc" = "yes"; then
-                PIC_FLAG="-KPIC"
-            fi
+        if test "$INTELCC" = "yes"; then
+            PIC_FLAG="-KPIC"
+        elif test "x$SUNCXX" = "xyes"; then
+            SHARED_LD_CC="${CC} -G -o"
+            SHARED_LD_CXX="${CXX} -G -o"
+            PIC_FLAG="-KPIC"
         fi
       ;;
 
       *-*-solaris2* )
-        if test "x$GCC" != xyes ; then
+        if test "x$SUNCXX" = xyes ; then
             SHARED_LD_CC="${CC} -G -o"
             SHARED_LD_CXX="${CXX} -G -o"
             PIC_FLAG="-KPIC"
@@ -341,7 +330,7 @@ AC_DEFUN([AC_BAKEFILE_SHARED_LD],
         chmod +x shared-ld-sh
 
         SHARED_LD_MODULE_CC="`pwd`/shared-ld-sh -bundle -headerpad_max_install_names -o"
-        SHARED_LD_MODULE_CXX="$SHARED_LD_MODULE_CC"
+        SHARED_LD_MODULE_CXX="CXX=\$(CXX) $SHARED_LD_MODULE_CC"
 
         dnl Most apps benefit from being fully binded (its faster and static
         dnl variables initialized at startup work).
@@ -499,8 +488,13 @@ AC_DEFUN([AC_BAKEFILE_SHARED_VERSIONS],
     SONAME_FLAG=
 
     case "${BAKEFILE_HOST}" in
-      *-*-linux* | *-*-freebsd* | *-*-k*bsd*-gnu )
-        SONAME_FLAG="-Wl,-soname,"
+      *-*-linux* | *-*-freebsd* | *-*-openbsd* | *-*-netbsd* | \
+      *-*-k*bsd*-gnu | *-*-mirbsd* )
+        if test "x$SUNCXX" = "xyes"; then
+            SONAME_FLAG="-h "
+        else
+            SONAME_FLAG="-Wl,-soname,"
+        fi
         USE_SOVERSION=1
         USE_SOVERLINUX=1
         USE_SOSYMLINKS=1
@@ -645,18 +639,21 @@ AC_DEFUN([AC_BAKEFILE_CHECK_BASIC_STUFF]
     AC_CHECK_TOOL(STRIP, strip, :)
     AC_CHECK_TOOL(NM, nm, :)
 
-    case ${BAKEFILE_HOST} in
-        *-hp-hpux* )
-            dnl HP-UX install doesn't handle the "-d" switch so don't
-            dnl use it there
-            INSTALL_DIR="mkdir -p"
-            ;;
-        * )
-            dnl we must refer to makefile's $(INSTALL) variable and not
-            dnl current value of shell variable, hence the single quoting:
-            INSTALL_DIR='$(INSTALL) -d'
-            ;;
-    esac
+    dnl This check is necessary because "install -d" doesn't exist on
+    dnl all platforms (e.g. HP/UX), see http://www.bakefile.org/ticket/80
+    AC_MSG_CHECKING([for command to install directories])
+    INSTALL_TEST_DIR=acbftest$$
+    $INSTALL -d $INSTALL_TEST_DIR > /dev/null 2>&1
+    if test $? = 0 -a -d $INSTALL_TEST_DIR; then
+        rmdir $INSTALL_TEST_DIR
+        dnl we must refer to makefile's $(INSTALL) variable and not
+        dnl current value of shell variable, hence the single quoting:
+        INSTALL_DIR='$(INSTALL) -d'
+        AC_MSG_RESULT([$INSTALL -d])
+    else
+        INSTALL_DIR="mkdir -p"
+        AC_MSG_RESULT([mkdir -p])
+    fi
     AC_SUBST(INSTALL_DIR)
 
     LDFLAGS_GUI=
@@ -804,6 +801,12 @@ AC_DEFUN([AC_BAKEFILE],
 [
     AC_PREREQ([2.58])
 
+    dnl We need to always run C/C++ compiler tests, but it's also possible
+    dnl for the user to call these macros manually, hence this instead of
+    dnl simply calling these macros. See http://www.bakefile.org/ticket/64
+    AC_REQUIRE([AC_BAKEFILE_PROG_CC])
+    AC_REQUIRE([AC_BAKEFILE_PROG_CXX])
+
     if test "x$BAKEFILE_HOST" = "x"; then
                if test "x${host}" = "x" ; then
                        AC_MSG_ERROR([You must call the autoconf "CANONICAL_HOST" macro in your configure.ac (or .in) file.])
@@ -824,7 +827,7 @@ AC_DEFUN([AC_BAKEFILE],
     AC_BAKEFILE_DEPS
     AC_BAKEFILE_RES_COMPILERS
 
-    BAKEFILE_BAKEFILE_M4_VERSION="0.2.2"
+    BAKEFILE_BAKEFILE_M4_VERSION="0.2.3"
 
     dnl includes autoconf_inc.m4:
     $1
@@ -852,7 +855,7 @@ D='$'
 cat <<EOF >bk-deps
 #!/bin/sh
 
-# This script is part of Bakefile (http://bakefile.sourceforge.net) autoconf
+# This script is part of Bakefile (http://www.bakefile.org) autoconf
 # script. It is used to track C/C++ files dependencies in portable way.
 #
 # Permission is given to use this file in any way.
@@ -866,10 +869,8 @@ mkdir -p ${D}DEPSDIR
 if test ${D}DEPSMODE = gcc ; then
     ${D}* ${D}{DEPSFLAG}
     status=${D}?
-    if test ${D}{status} != 0 ; then
-        exit ${D}{status}
-    fi
-    # move created file to the location we want it in:
+
+    # determine location of created files:
     while test ${D}# -gt 0; do
         case "${D}1" in
             -o )
@@ -886,6 +887,14 @@ if test ${D}DEPSMODE = gcc ; then
     done
     depfile=\`basename ${D}srcfile | sed -e 's/\\..*${D}/.d/g'\`
     depobjname=\`echo ${D}depfile |sed -e 's/\\.d/.o/g'\`
+    
+    # if the compiler failed, we're done:
+    if test ${D}{status} != 0 ; then
+        rm -f ${D}depfile
+        exit ${D}{status}
+    fi
+
+    # move created file to the location we want it in:
     if test -f ${D}depfile ; then
         sed -e "s,${D}depobjname:,${D}objfile:,g" ${D}depfile >${D}{DEPSDIR}/${D}{objfile}.d
         rm -f ${D}depfile
@@ -975,6 +984,10 @@ objects=""
 linking_flag="-dynamiclib"
 ldargs="-r -keep_private_externs -nostdlib"
 
+if test "x${D}CXX" = "x"; then
+    CXX="c++"
+fi
+
 while test ${D}# -gt 0; do
     case ${D}1 in
 
@@ -987,6 +1000,12 @@ while test ${D}# -gt 0; do
         args="${D}{args} ${D}1 ${D}2"
         shift
         ;;
+       
+       -arch|-isysroot)
+        # collect these options and values
+        ldargs="${D}{ldargs} ${D}1 ${D}2"
+        shift
+        ;;
 
        -s|-Wl,*)
         # collect these load args
@@ -1027,9 +1046,9 @@ status=0
 # Link one module containing all the others
 #
 if test ${D}{verbose} = 1; then
-    echo "c++ ${D}{ldargs} ${D}{objects} -o master.${D}${D}.o"
+    echo "${D}CXX ${D}{ldargs} ${D}{objects} -o master.${D}${D}.o"
 fi
-c++ ${D}{ldargs} ${D}{objects} -o master.${D}${D}.o
+${D}CXX ${D}{ldargs} ${D}{objects} -o master.${D}${D}.o
 status=${D}?
 
 #
@@ -1038,9 +1057,9 @@ status=${D}?
 #
 if test ${D}{status} = 0; then
     if test ${D}{verbose} = 1; then
-        echo "c++ ${D}{linking_flag} master.${D}${D}.o ${D}{args}"
+        echo "${D}CXX ${D}{linking_flag} master.${D}${D}.o ${D}{args}"
     fi
-    c++ ${D}{linking_flag} master.${D}${D}.o ${D}{args}
+    ${D}CXX ${D}{linking_flag} master.${D}${D}.o ${D}{args}
     status=${D}?
 fi
 
@@ -1063,7 +1082,7 @@ D='$'
 cat <<EOF >bk-make-pch
 #!/bin/sh
 
-# This script is part of Bakefile (http://bakefile.sourceforge.net) autoconf
+# This script is part of Bakefile (http://www.bakefile.org) autoconf
 # script. It is used to generated precompiled headers.
 #
 # Permission is given to use this file in any way.
Index: aclocal.m4
===================================================================
--- aclocal.m4	(revision 52157)
+++ aclocal.m4	(working copy)
@@ -1,7 +1,7 @@
-# generated automatically by aclocal 1.10 -*- Autoconf -*-
+# generated automatically by aclocal 1.10.1 -*- Autoconf -*-
 
 # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
-# 2005, 2006  Free Software Foundation, Inc.
+# 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
