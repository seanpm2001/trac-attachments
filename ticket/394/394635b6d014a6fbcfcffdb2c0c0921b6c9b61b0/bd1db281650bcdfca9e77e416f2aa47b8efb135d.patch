Index: include/wx/datetime.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/include/wx/datetime.h,v
retrieving revision 1.64
diff -b -u -2 -r1.64 datetime.h
--- include/wx/datetime.h	2005/08/28 13:06:33	1.64
+++ include/wx/datetime.h	2005/09/30 19:20:01
@@ -1540,5 +1540,5 @@
 inline bool wxDateTime::IsInStdRange() const
 {
-    return m_time >= 0l && (m_time / TIME_T_FACTOR) < LONG_MAX;
+    return m_time >= 0l && (m_time / TIME_T_FACTOR) < ULONG_MAX;
 }
 
Index: src/common/datetime.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/common/datetime.cpp,v
retrieving revision 1.136
diff -b -u -2 -r1.136 datetime.cpp
--- src/common/datetime.cpp	2005/08/29 15:46:55	1.136
+++ src/common/datetime.cpp	2005/09/30 19:20:19
@@ -17,8 +17,4 @@
 ///////////////////////////////////////////////////////////////////////////////
 
-// TODO: for $DEITY sake, someone please fix the #ifdef __WXWINCE__ everywhere,
-//       the proper way to do it is to implement (subset of) wxStrftime() for
-//       CE instead of this horror!!
-
 /*
  * Implementation notes:
@@ -372,5 +368,4 @@
 }
 
-#ifndef __WXWINCE__
 // this function is a wrapper around strftime(3) adding error checking
 static wxString CallStrftime(const wxChar *format, const tm* tm)
@@ -390,5 +385,4 @@
     return s;
 }
-#endif
 
 #ifdef HAVE_STRPTIME
@@ -838,5 +832,4 @@
 {
     wxCHECK_MSG( month != Inv_Month, wxEmptyString, _T("invalid month") );
-#ifndef __WXWINCE__
     // notice that we must set all the fields to avoid confusing libc (GNU one
     // gets confused to a crash if we don't do this)
@@ -846,47 +839,4 @@
 
     return CallStrftime(flags == Name_Abbr ? _T("%b") : _T("%B"), &tm);
-#else
-    wxString ret;
-    switch(month)
-    {
-        case Jan:
-            ret = (flags == Name_Abbr ? wxT("Jan"): wxT("January"));
-            break;
-        case Feb:
-            ret = (flags == Name_Abbr ? wxT("Feb"): wxT("Febuary"));
-            break;
-        case Mar:
-            ret = (flags == Name_Abbr ? wxT("Mar"): wxT("March"));
-            break;
-        case Apr:
-            ret = (flags == Name_Abbr ? wxT("Apr"): wxT("April"));
-            break;
-        case May:
-            ret = (flags == Name_Abbr ? wxT("May"): wxT("May"));
-            break;
-        case Jun:
-            ret = (flags == Name_Abbr ? wxT("Jun"): wxT("June"));
-            break;
-        case Jul:
-            ret = (flags == Name_Abbr ? wxT("Jul"): wxT("July"));
-            break;
-        case Aug:
-            ret = (flags == Name_Abbr ? wxT("Aug"): wxT("August"));
-            break;
-        case Sep:
-            ret = (flags == Name_Abbr ? wxT("Sep"): wxT("September"));
-            break;
-        case Oct:
-            ret = (flags == Name_Abbr ? wxT("Oct"): wxT("October"));
-            break;
-        case Nov:
-            ret = (flags == Name_Abbr ? wxT("Nov"): wxT("November"));
-            break;
-        case Dec:
-            ret = (flags == Name_Abbr ? wxT("Dec"): wxT("December"));
-            break;
-    }
-    return ret;
-#endif
 }
 
@@ -896,5 +846,4 @@
 {
     wxCHECK_MSG( wday != Inv_WeekDay, wxEmptyString, _T("invalid weekday") );
-#ifndef __WXWINCE__
     // take some arbitrary Sunday (but notice that the day should be such that
     // after adding wday to it below we still have a valid date, e.g. don't
@@ -914,33 +863,4 @@
     // ... and call strftime()
     return CallStrftime(flags == Name_Abbr ? _T("%a") : _T("%A"), &tm);
-#else
-    wxString ret;
-    switch(wday)
-    {
-        case Sun:
-            ret = (flags == Name_Abbr ? wxT("Sun") : wxT("Sunday"));
-            break;
-        case Mon:
-            ret = (flags == Name_Abbr ? wxT("Mon") : wxT("Monday"));
-            break;
-        case Tue:
-            ret = (flags == Name_Abbr ? wxT("Tue") : wxT("Tuesday"));
-            break;
-        case Wed:
-            ret = (flags == Name_Abbr ? wxT("Wed") : wxT("Wednesday"));
-            break;
-        case Thu:
-            ret = (flags == Name_Abbr ? wxT("Thu") : wxT("Thursday"));
-            break;
-        case Fri:
-            ret = (flags == Name_Abbr ? wxT("Fri") : wxT("Friday"));
-            break;
-        case Sat:
-            ret = (flags == Name_Abbr ? wxT("Sat") : wxT("Saturday"));
-            break;
-    }
-    return ret;
-
-#endif
 }
 
@@ -985,5 +905,4 @@
 {
     // TODO use LOCALE_ICOUNTRY setting under Win32
-#ifndef __WXWINCE__
     if ( ms_country == Country_Unknown )
     {
@@ -1019,7 +938,4 @@
         }
     }
-#else
-     ms_country = USA;
-#endif
 
     return ms_country;
@@ -2216,11 +2132,8 @@
             }
         }
-#ifndef __WXWINCE__
-    //Windows CE doesn't support strftime or wcsftime, so we use the generic implementation
         if ( tm )
         {
             return CallStrftime(format, tm);
         }
-#endif
         //else: use generic code below
     }
@@ -2301,5 +2214,4 @@
                 case _T('c'):       // locale default date and time  representation
                 case _T('x'):       // locale default date representation
-#ifndef __WXWINCE__
                     //
                     // the problem: there is no way to know what do these format
@@ -2431,9 +2343,4 @@
                         res += str;
                     }
-#else
-                    //Use "%m/%d/%y %H:%M:%S" format instead
-                    res += wxString::Format(wxT("%02d/%02d/%04d %02d:%02d:%02d"),
-                            tm.mon+1,tm.mday, tm.year, tm.hour, tm.min, tm.sec);
-#endif
                     break;
 
@@ -2472,9 +2379,5 @@
 
                 case _T('p'):       // AM or PM string
-#ifndef __WXWINCE__
                     res += CallStrftime(_T("%p"), &tmTimeOnly);
-#else
-                    res += (tmTimeOnly.tm_hour > 12) ? wxT("pm") : wxT("am");
-#endif
                     break;
 
@@ -2499,9 +2402,5 @@
                 case _T('X'):       // locale default time representation
                     // just use strftime() to format the time for us
-#ifndef __WXWINCE__
                     res += CallStrftime(_T("%X"), &tmTimeOnly);
-#else
-                    res += wxString::Format(wxT("%02d:%02d:%02d"),tm.hour, tm.min, tm.sec);
-#endif
                     break;
 
@@ -2515,7 +2414,5 @@
 
                 case _T('Z'):       // timezone name
-#ifndef __WXWINCE__
                     res += CallStrftime(_T("%Z"), &tmTimeOnly);
-#endif
                     break;
 
Index: src/generic/logg.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/generic/logg.cpp,v
retrieving revision 1.94
diff -b -u -2 -r1.94 logg.cpp
--- src/generic/logg.cpp	2005/06/20 00:24:21	1.94
+++ src/generic/logg.cpp	2005/09/30 19:20:21
@@ -205,9 +205,5 @@
     wxASSERT( gs_pFrame == NULL ); // should be reset!
     gs_pFrame = pFrame;
-#ifdef __WXWINCE__
     wxLog::OnLog(wxLOG_Status, msg, 0);
-#else
-    wxLog::OnLog(wxLOG_Status, msg, time(NULL));
-#endif
     gs_pFrame = (wxFrame *) NULL;
   }
Index: src/msw/datectrl.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/msw/datectrl.cpp,v
retrieving revision 1.22
diff -b -u -2 -r1.22 datectrl.cpp
--- src/msw/datectrl.cpp	2005/05/31 09:20:30	1.22
+++ src/msw/datectrl.cpp	2005/09/30 19:20:24
@@ -105,4 +105,5 @@
     if ( !s_initDone )
     {
+#if ! defined( __WXWINCE__ )
         if ( wxApp::GetComCtl32Version() < 470 )
         {
@@ -125,5 +126,5 @@
             (*pfnInitCommonControlsEx)(&icex);
         }
-
+#endif
         s_initDone = true;
     }
Index: src/msw/wince/time.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/msw/wince/time.cpp,v
retrieving revision 1.11
diff -b -u -2 -r1.11 time.cpp
--- src/msw/wince/time.cpp	2005/09/09 20:49:05	1.11
+++ src/msw/wince/time.cpp	2005/09/30 19:20:25
@@ -45,24 +45,31 @@
 #define DO_GMTIME                   0
 #define DO_LOCALTIME                1
+#define TIMEZONEBIAS ( ( pTz.Bias + ( (pTz.StandardDate.wMonth != 0) ? pTz.StandardBias : 0 ) ) * 60 )
+#define DSTBIAS ( ( (pTz.DaylightDate.wMonth != 0) && (pTz.DaylightBias != 0) ) ? \
+					(pTz.DaylightBias - pTz.StandardBias) * 60 : 0 )
+#define ToSeconds(x)	((x)/10000000L)
+// Month in tm format (0-based)
+// -1 => localtime returns zero based
+#define DayOfYear( Leap, TmMonth, wDay )  ( __mon_yday[Leap][TmMonth] + wDay - 1 )
 
-
 long timezone ; // global variable
 
-
 ////////////////////////////////////////////////////////////////////////
 // Common code for localtime and gmtime (static)
 ////////////////////////////////////////////////////////////////////////
 
-static struct tm * __cdecl common_localtime(const time_t *t, BOOL bLocal)
-{
-    wxLongLong i64;
-    FILETIME   ft;
-    wxString str ;
-    SYSTEMTIME SystemTime;
-    TIME_ZONE_INFORMATION pTz;
-    static struct tm st_res ;             // data holder
-    static struct tm * res = &st_res ;    // data pointer
-    int iLeap;
-    const unsigned short int __mon_yday[2][13] =
+#include <wx/longlong.h>
+
+typedef struct {
+		int  yr;        // year
+		int  yd;        // day of year 
+		long ms;        // milli-seconds in the day 
+} DSTActionTime_t;
+
+static Initialized = 0;
+static TIME_ZONE_INFORMATION pTz;
+static wxLongLong FirstDayOf1970;
+static wxLongLong OffsetTill1970;
+static const unsigned short int __mon_yday[2][13] =
     {
         // Normal years
@@ -71,20 +78,197 @@
         { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
     };
+
+static wxLongLong FirstDayOfYear( int wYear ) {	
+	SYSTEMTIME SysTime;
+	FILETIME FileTime;
+	
+	SysTime.wYear         = wYear;
+	SysTime.wMonth        = 1;
+	SysTime.wDay          = 1;
+	SysTime.wDayOfWeek    = 1;
+	SysTime.wHour         = 0;
+	SysTime.wMinute       = 0;
+	SysTime.wSecond       = 0;
+	SysTime.wMilliseconds = 0;
+
+	SystemTimeToFileTime( &SysTime, &FileTime );
+	return wxLongLong( FileTime.dwHighDateTime, FileTime.dwLowDateTime );
+}
 
-    if (!*t)
-        ::GetLocalTime(&SystemTime);
+static void GetTimezoneInfo( void ) {
+	if( ! Initialized ) {
+		FirstDayOf1970 = FirstDayOfYear( 1970 );
+		// cache info (is slow on WinCE)
+		OffsetTill1970 = FirstDayOf1970 - FirstDayOfYear(1601);
+		::GetTimeZoneInformation(&pTz);
+		Initialized = 1;
+	}
+}
+
+static void ConvertDSTDate( bool StartOfDST, 
+							int year, int month, int week, int dayofweek,
+							int hour, int min, int sec, int msec,
+							DSTActionTime_t * pDST) {
+
+	const int START_DOW   = 4; // 01-01-70 was a Thursday 
+	const int ADJUST_LEAP = 17L; // for Leap years 1900 - 1970
+	bool IsLeapYear = is_leap( year );
+	int yearday;
+	int monthdow;
+
+	yearday = __mon_yday[IsLeapYear][month - 1];
+	monthdow = (yearday + ((year - 70) * 365) + ((year - 1) >> 2) -
+								ADJUST_LEAP + START_DOW) % 7;
+
+	if ( monthdow <= dayofweek )
+		yearday += (dayofweek - monthdow) + (week - 1) * 7;
     else
+		yearday += (dayofweek - monthdow) + week * 7;
+
+	if ((week == 5) && (yearday > (__mon_yday[IsLeapYear][month]-1) ) ) {
+		yearday -= 7;
+	}
+
+	if ( StartOfDST ) {   
+		// Converting date for the start of DST
+		pDST->yd = yearday;
+		pDST->ms = (long)msec + (1000L * (sec + 60L * (min + 60L * hour)));
+		pDST->yr = year;
+	} else 	{   
+		// Converting date for the end of DST
+		pDST->yd = yearday;
+		pDST->ms = (long)msec + (1000L * (sec + 60L * (min + 60L * hour)));
+		if ((pDST->ms += (DSTBIAS * 1000L)) < 0) 
+		{
+			pDST->ms += SECONDS_IN_ONE_DAY * 1000L;
+			pDST->ms--;
+		}
+		else if (pDST->ms >= SECONDS_IN_ONE_DAY * 1000L) 
     {
-        i64 = *t;
-        i64 = i64 * 10000000 + 116444736000000000;
+			pDST->ms -= SECONDS_IN_ONE_DAY * 1000L;
+			pDST->ms++;
+		}
+		pDST->yr = year;
+	}
+}
 
-        ft.dwLowDateTime  = i64.GetLo();
-        ft.dwHighDateTime = i64.GetHi();
+static bool DSTIsActive( SYSTEMTIME & pt ) {
 
-        ::FileTimeToSystemTime(&ft, &SystemTime);
+	DSTActionTime_t Begin = { -1, 0, 0L };
+	DSTActionTime_t End = { -1, 0, 0L };
+	int year = pt.wYear-1900; // year from 1970
+	int yday = DayOfYear(is_leap(pt.wYear), pt.wMonth-1, pt.wDay );
+ 
+	GetTimezoneInfo();
+
+	if (pTz.DaylightDate.wYear != 0 || pTz.StandardDate.wYear != 0)
+		return 0;
+
+	// get DST dates for requested year
+	ConvertDSTDate( 1,
+					year,
+					pTz.DaylightDate.wMonth,
+					pTz.DaylightDate.wDay,
+					pTz.DaylightDate.wDayOfWeek,
+					pTz.DaylightDate.wHour,
+					pTz.DaylightDate.wMinute,
+					pTz.DaylightDate.wSecond,
+					pTz.DaylightDate.wMilliseconds,
+					&Begin);
+
+	ConvertDSTDate( 0,
+					year,
+					pTz.StandardDate.wMonth,
+					pTz.StandardDate.wDay,
+					pTz.StandardDate.wDayOfWeek,
+					pTz.StandardDate.wHour,
+					pTz.StandardDate.wMinute,
+					pTz.StandardDate.wSecond,
+					pTz.StandardDate.wMilliseconds,
+					&End);
+
+	if ( Begin.yd < End.yd) {
+		// Northern hemisphere ordering
+		if ((yday < Begin.yd) || (yday > End.yd))
+			return 0;
+		if ((yday > Begin.yd) && (yday < End.yd))
+			return 1;
+	} else {
+		// Southern hemisphere ordering
+		if ( (yday < End.yd) || (yday > Begin.yd) )
+			return 1;
+		if ( (yday > End.yd) && (yday < Begin.yd) )
+			return 0;
     }
 
-    ::GetTimeZoneInformation(&pTz);
+	long ms = 1000L * (pt.wSecond + 60L * pt.wMinute + 3600L * pt.wHour );
+
+	if ( yday == Begin.yd ) {
+		return ( ms >= Begin.ms ) ? 1 : 0;
+	} else 	{
+		// yday == DSTEnd.yd
+		return ( ms < End.ms ) ? 1 : 0;
+	}
+}
+
+static wxLongLong SystemTimeToLongLong( SYSTEMTIME & ST ) {
+		FILETIME ft;
+
+		// Convert the FILETIME to a SYSTEMTIME
+		SystemTimeToFileTime( &ST, &ft );
+
+		return wxLongLong( ft.dwHighDateTime, ft.dwLowDateTime );
+}
+
+static SYSTEMTIME LongLongToSystemTime( const wxLongLong & L ) {
+		FILETIME ft;
+		SYSTEMTIME ST;
+		// Convert iTime to FILETIME
+		ft.dwHighDateTime = L.GetHi();
+		ft.dwLowDateTime = L.GetLo();
+
+		// Convert the FILETIME to a SYSTEMTIME
+		FileTimeToSystemTime( &ft, &ST );
+		return ST;
+}
+
+static SYSTEMTIME TmToSystemTime(struct tm &t) {
+	SYSTEMTIME s;
+
+	s.wYear      = t.tm_year + 1900;
+	s.wMonth     = t.tm_mon+1;
+	s.wDayOfWeek = t.tm_wday;
+	s.wDay       = t.tm_mday;
+	s.wHour      = t.tm_hour;
+	s.wMinute    = t.tm_min;
+	s.wSecond    = t.tm_sec;
+	s.wMilliseconds = 0;
+
+	return s;
+}
+
+static struct tm SystemTimeToTm( SYSTEMTIME &st, bool leap ) {
+	struct tm t;
 
+    t.tm_hour = st.wHour;
+    t.tm_min  = st.wMinute;
+    t.tm_sec  = st.wSecond;
+	t.tm_mday = st.wDay;
+	t.tm_year = st.wYear -1900;
+	t.tm_mon = st.wMonth-1;
+    t.tm_wday = st.wDayOfWeek;
+    t.tm_yday = DayOfYear( leap, t.tm_mon, st.wDay );
+	t.tm_isdst = 0;
+
+	return t;
+}
+
+static struct tm * __cdecl common_localtime(const time_t * t, BOOL bLocal) {
+    SYSTEMTIME SystemTime;
+    static struct tm st_res ;             // data holder
+    static struct tm * res = &st_res ;    // data pointer
+
+	GetTimezoneInfo();
+
     ///////////////////////////////////////////////
     // Set timezone
@@ -92,17 +276,28 @@
     ///////////////////////////////////////////////
 
-    iLeap = is_leap(SystemTime.wYear) ;
+	if( t == 0 ) {
+		// take system time
+	    ::GetLocalTime(&SystemTime) ;
+	} else {
+		// number of 100 nanosecond intervals since Jan. 1601.
+		// adjust with standard Timezone related bias
+		wxLongLong h_nano = ( wxLongLong( (*t) - TIMEZONEBIAS ) * wxLongLong( 10000000L ))
+							+ OffsetTill1970;
+
+		SystemTime = LongLongToSystemTime( h_nano );
+
+		if (bLocal && pTz.DaylightBias != 0) {
+			// what about DST ?
+			if( DSTIsActive( SystemTime ) ) {
+				// correct time becase DST is active
+				h_nano -= wxLongLong( DSTBIAS ) * wxLongLong( 10000000L );
+				SystemTime = LongLongToSystemTime( h_nano );
+			}
+		}
+	}
 
-    res->tm_hour = SystemTime.wHour;
-    res->tm_min  = SystemTime.wMinute;
-    res->tm_sec  = SystemTime.wSecond;
-
-    res->tm_mday = SystemTime.wDay;
-    res->tm_mon = SystemTime.wMonth - 1; // this the correct month but localtime returns month aligned to zero
-    res->tm_year = SystemTime.wYear;     // this the correct year
-    res->tm_year = res->tm_year - 1900;  // but localtime returns the value starting at the 1900
+    bool iLeap = is_leap(SystemTime.wYear) ;
 
-    res->tm_wday = SystemTime.wDayOfWeek;
-    res->tm_yday = __mon_yday[iLeap][res->tm_mon] + SystemTime.wDay - 1; // localtime returns year-day aligned to zero
+	*res = SystemTimeToTm( SystemTime, iLeap );
 
     // if localtime behavior and daylight saving
@@ -115,6 +310,4 @@
 }
 
-extern "C"
-{
 
 ////////////////////////////////////////////////////////////////////////
@@ -136,5 +329,4 @@
 }
 
-}
 
 ////////////////////////////////////////////////////////////////////////
@@ -143,4 +335,5 @@
 static time_t __cdecl common_tm_to_time(int day, int month, int year, int hour, int minute, int second)
 {
+	/*
     time_t prog = 0 ;
     static int mdays[12] = { 31,28,31,30,31,30,31,31,30,31,30,31 } ;
@@ -163,8 +356,29 @@
 
     return prog ;
+	*/
+
+	GetTimezoneInfo();
+
+	SYSTEMTIME st;
+	st.wYear      = year;
+	st.wMonth     = month;
+	st.wDayOfWeek = 0;
+	st.wDay       = day;
+	st.wHour      = hour;
+	st.wMinute    = minute;
+	st.wSecond    = second;
+	st.wMilliseconds = 0;
+
+	wxLongLong l = SystemTimeToLongLong( st );
+
+	// time zone and daylight savings time
+	int Bias = TIMEZONEBIAS;
+	if( DSTIsActive( st ) )
+		Bias += DSTBIAS;
+	
+	// Get the number of seconds since 1 Jan 1970
+	return (time_t)( ToSeconds(l-FirstDayOf1970) + Bias).GetLo();
 }
 
-extern "C"
-{
 
 ////////////////////////////////////////////////////////////////////////
@@ -176,11 +390,11 @@
     time_t prog = 0 ;
 
-    if (t != NULL)
-    {
         SYSTEMTIME SystemTime;
-
         ::GetLocalTime(&SystemTime) ;
-        prog = common_tm_to_time(SystemTime.wDay, SystemTime.wMonth, SystemTime.wYear,
+    prog = common_tm_to_time( SystemTime.wDay, SystemTime.wMonth, SystemTime.wYear,
                                  SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond) ;
+
+    if (t != NULL)
+    {
         *t = prog ;
     }
@@ -198,11 +412,1481 @@
 }
 
+// 
+// verbatim copy of strftime_l.c from glibc
+// just changed wxT to wxT for wide constants
+//
+
+//
+// these defines to make compile things
+// 
+#define HAVE_MBLEN 1
+#define COMPILE_WIDE 1
+#define __THROW
+#define bcopy( s, d, n ) memcpy( (d), (s), (n))
+#define __wcslen wcslen
+#define __mbsrtowcs(a,b,c,d) mbstowcs(a,*(b),c)
+#define MEMPCPY(d, s, n) ((char *) memcpy (d, s, n) + (n))
+
+static bool __localtime_r( time_t * t, struct tm * tm ) {
+	*tm = *(localtime(t));
+	return 1;
+}
+
+static bool __gmtime_r( time_t * t, struct tm * tm ) {
+	*tm = *(gmtime(t));
+	return 1;
+}
+
+// some places were not portable to WinCE -> def'd out by __WXWINCE__
+
+/* Copyright (C) 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#ifdef _LIBC
+# define USE_IN_EXTENDED_LOCALE_MODEL 1
+# define HAVE_LIMITS_H 1
+# define HAVE_MBLEN 1
+# define HAVE_MBRLEN 1
+# define HAVE_STRUCT_ERA_ENTRY 1
+# define HAVE_TM_GMTOFF 1
+# define HAVE_TM_ZONE 1
+# define HAVE_TZNAME 1
+# define HAVE_TZSET 1
+# define MULTIBYTE_IS_FORMAT_SAFE 1
+# define STDC_HEADERS 1
+# include "../locale/localeinfo.h"
+#endif
+
+#if defined emacs && !defined HAVE_BCOPY
+# define HAVE_MEMCPY 1
+#endif
+struct tm tt;
+
+#include <ctype.h>
+#if ! defined( __WXWINCE__ )
+#include <sys/types.h>		/* Some systems define `time_t' here.  */
+#endif
+
+#ifdef TIME_WITH_SYS_TIME
+# include <sys/time.h>
+# include <time.h>
+#else
+# ifdef HAVE_SYS_TIME_H
+#  include <sys/time.h>
+# else
+#if ! defined( __WXWINCE__ )
+#  include <time.h>
+#endif
+# endif
+#endif
+#if HAVE_TZNAME
+extern char *tzname[];
+#endif
+
+/* Do multibyte processing if multibytes are supported, unless
+   multibyte sequences are safe in formats.  Multibyte sequences are
+   safe if they cannot contain byte sequences that look like format
+   conversion specifications.  The GNU C Library uses UTF8 multibyte
+   encoding, which is safe for formats, but strftime.c can be used
+   with other C libraries that use unsafe encodings.  */
+#define DO_MULTIBYTE (HAVE_MBLEN && ! MULTIBYTE_IS_FORMAT_SAFE)
+
+#if DO_MULTIBYTE
+# if HAVE_MBRLEN
+#  include <wchar.h>
+# else
+   /* Simulate mbrlen with mblen as best we can.  */
+#  define mbstate_t int
+#  define mbrlen(s, n, ps) mblen (s, n)
+#  define mbsinit(ps) (*(ps) == 0)
+# endif
+  static const mbstate_t mbstate_zero;
+#endif
+
+#if HAVE_LIMITS_H
+# include <limits.h>
+#endif
+
+#if STDC_HEADERS
+# include <stddef.h>
+# include <stdlib.h>
+# include <string.h>
+#else
+# ifndef HAVE_MEMCPY
+#  define memcpy(d, s, n) bcopy ((s), (d), (n))
+# endif
+#endif
+
+#ifdef COMPILE_WIDE
+#if ! defined( __WXWINCE__ )
+# include <endian.h>
+# define wxT(Str) L##Str
+#endif
+# define CHAR_T wchar_t
+# define UCHAR_T unsigned int
+# define NLW(Sym) _NL_W##Sym
+# define MEMCPY(d, s, n) memcpy (d, s, n)
+# define STRLEN(s) __wcslen (s)
+
+#else
+# define CHAR_T char
+# define UCHAR_T unsigned char
+# define wxT(Str) Str
+# define NLW(Sym) Sym
+
+# if !defined STDC_HEADERS && !defined HAVE_MEMCPY
+#  define MEMCPY(d, s, n) bcopy ((s), (d), (n))
+# else
+#  define MEMCPY(d, s, n) memcpy ((d), (s), (n))
+# endif
+# define STRLEN(s) strlen (s)
+
+# ifdef _LIBC
+#  define MEMPCPY(d, s, n) __mempcpy (d, s, n)
+# else
+#  ifndef HAVE_MEMPCPY
+#   define MEMPCPY(d, s, n) ((void *) ((char *) memcpy (d, s, n) + (n)))
+#  endif
+# endif
+#endif
+
+#ifndef PTR
+# ifdef __STDC__
+#  define PTR void *
+# else
+#  define PTR char *
+# endif
+#endif
+
+#ifndef CHAR_BIT
+# define CHAR_BIT 8
+#endif
+
+#ifndef NULL
+# define NULL 0
+#endif
+
+#define TYPE_SIGNED(t) ((t) -1 < 0)
+
+/* Bound on length of the string representing an integer value of type t.
+   Subtract one for the sign bit if t is signed;
+   302 / 1000 is log10 (2) rounded up;
+   add one for integer division truncation;
+   add one more for a minus sign if t is signed.  */
+#define INT_STRLEN_BOUND(t) \
+ ((sizeof (t) * CHAR_BIT - TYPE_SIGNED (t)) * 302 / 1000 + 1 + TYPE_SIGNED (t))
+
+#define TM_YEAR_BASE 1900
+
+#ifndef __isleap
+/* Nonzero if YEAR is a leap year (every 4 years,
+   except every 100th isn't, and every 400th is).  */
+# define __isleap(year)	\
+  ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))
+#endif
+
 
-size_t __cdecl wcsftime(wchar_t *, size_t, const wchar_t *, const struct tm *)
+#ifdef _LIBC
+# define tzname __tzname
+# define tzset __tzset
+#endif
+
+#if ! defined( __WXWINCE__ )
+#if !HAVE_TM_GMTOFF
+/* Portable standalone applications should supply a "time_r.h" that
+   declares a POSIX-compliant localtime_r, for the benefit of older
+   implementations that lack localtime_r or have a nonstandard one.
+   Similarly for gmtime_r.  See the gnulib time_r module for one way
+   to implement this.  */
+# include "time_r.h"
+# undef __gmtime_r
+# undef __localtime_r
+# define __gmtime_r gmtime_r
+# define __localtime_r localtime_r
+#endif
+#endif
+
+
+#if !defined memset && !defined HAVE_MEMSET && !defined _LIBC
+/* Some systems lack the `memset' function and we don't want to
+   introduce additional dependencies.  */
+/* The SGI compiler reportedly barfs on the trailing null
+   if we use a string constant as the initializer.  28 June 1997, rms.  */
+static const CHAR_T spaces[16] = /* "                " */
+{
+  wxT(' '),wxT(' '),wxT(' '),wxT(' '),wxT(' '),wxT(' '),wxT(' '),wxT(' '),
+  wxT(' '),wxT(' '),wxT(' '),wxT(' '),wxT(' '),wxT(' '),wxT(' '),wxT(' ')
+};
+static const CHAR_T zeroes[16] = /* "0000000000000000" */
 {
-    // TODO : maybe copy something from wxString::Printf
+  wxT('0'),wxT('0'),wxT('0'),wxT('0'),wxT('0'),wxT('0'),wxT('0'),wxT('0'),
+  wxT('0'),wxT('0'),wxT('0'),wxT('0'),wxT('0'),wxT('0'),wxT('0'),wxT('0')
+};
+
+# define memset_space(P, Len) \
+  do {									      \
+    int _len = (Len);							      \
+									      \
+    do									      \
+      {									      \
+	int _this = _len > 16 ? 16 : _len;				      \
+	(P) = (CHAR_T *)MEMPCPY ((P), spaces, _this * sizeof (CHAR_T));		      \
+	_len -= _this;							      \
+      }									      \
+    while (_len > 0);							      \
+  } while (0)
+
+# define memset_zero(P, Len) \
+  do {									      \
+    int _len = (Len);							      \
+									      \
+    do									      \
+      {									      \
+	int _this = _len > 16 ? 16 : _len;				      \
+	(P) = (CHAR_T *)MEMPCPY ((P), zeroes, _this * sizeof (CHAR_T));		      \
+	_len -= _this;							      \
+      }									      \
+    while (_len > 0);							      \
+  } while (0)
+#else
+# ifdef COMPILE_WIDE
+#  define memset_space(P, Len) (wmemset ((P), L' ', (Len)), (P) += (Len))
+#  define memset_zero(P, Len) (wmemset ((P), L'0', (Len)), (P) += (Len))
+# else
+#  define memset_space(P, Len) (memset ((P), ' ', (Len)), (P) += (Len))
+#  define memset_zero(P, Len) (memset ((P), '0', (Len)), (P) += (Len))
+# endif
+#endif
+
+#define addnchars(n, f)							      \
+  do									      \
+    {									      \
+      int _n = (n);							      \
+      int _delta = width - _n;						      \
+      int _incr = _n + (_delta > 0 ? _delta : 0);			      \
+      if ((size_t) _incr >= maxsize - i)				      \
+	return 0;							      \
+      if (p)								      \
+	{								      \
+	  if (_delta > 0)						      \
+	    {								      \
+	      if (pad == wxT('0'))					      \
+		memset_zero (p, _delta);				      \
+	      else							      \
+		memset_space (p, _delta);				      \
+	    }								      \
+	  f;								      \
+	  p += _n;							      \
+	}								      \
+      i += _incr;							      \
+    } while (0)
+
+#define cpychars(n, s) \
+    addnchars ((n),								      \
+	 if (to_lowcase)						      \
+	   memcpy_lowcase (p, (s), _n LOCALE_ARG);			      \
+	 else if (to_uppcase)						      \
+	   memcpy_uppcase (p, (s), _n LOCALE_ARG);			      \
+	 else								      \
+	   MEMCPY ((PTR) p, (const PTR) (s), _n*sizeof(CHAR_T)))
+
+#ifdef COMPILE_WIDE
+# ifndef USE_IN_EXTENDED_LOCALE_MODEL
+#  undef __mbsrtowcs_l
+#  define __mbsrtowcs_l(d, s, l, st, loc) __mbsrtowcs (d, s, l, st)
+# endif
+# define widen(os, ws, l) \
+  {									      \
+    mbstate_t __st;							      \
+    const char *__s = os;						      \
+    memset (&__st, '\0', sizeof (__st));				      \
+    l = __mbsrtowcs_l (NULL, &__s, 0, &__st, loc);			      \
+    ws = (wchar_t *)alloca ((l + 1) * sizeof (wchar_t));				      \
+    (void) __mbsrtowcs_l (ws, &__s, l, &__st, loc);			      \
+  }
+#endif
+
+
+#if defined _LIBC && defined USE_IN_EXTENDED_LOCALE_MODEL
+/* We use this code also for the extended locale handling where the
+   function gets as an additional argument the locale which has to be
+   used.  To access the values we have to redefine the _NL_CURRENT
+   macro.  */
+# define strftime		__strftime_l
+# define wcsftime		__wcsftime_l
+# undef _NL_CURRENT
+# define _NL_CURRENT(category, item) \
+  (current->values[_NL_ITEM_INDEX (item)].string)
+# define LOCALE_PARAM , loc
+# define LOCALE_ARG , loc
+# define LOCALE_PARAM_DECL  __locale_t loc;
+# define LOCALE_PARAM_PROTO , __locale_t loc
+# define HELPER_LOCALE_ARG  , current
+#else
+# define LOCALE_PARAM
+# define LOCALE_PARAM_PROTO
+# define LOCALE_ARG
+# define LOCALE_PARAM_DECL
+# ifdef _LIBC
+#  define HELPER_LOCALE_ARG , _NL_CURRENT_DATA (LC_TIME)
+# else
+#  define HELPER_LOCALE_ARG
+# endif
+#endif
+
+#ifdef COMPILE_WIDE
+# ifdef USE_IN_EXTENDED_LOCALE_MODEL
+#  define TOUPPER(Ch, L) __towupper_l (Ch, L)
+#  define TOLOWER(Ch, L) __towlower_l (Ch, L)
+# else
+#  define TOUPPER(Ch, L) towupper (Ch)
+#  define TOLOWER(Ch, L) towlower (Ch)
+# endif
+#else
+# ifdef _LIBC
+#  ifdef USE_IN_EXTENDED_LOCALE_MODEL
+#   define TOUPPER(Ch, L) __toupper_l (Ch, L)
+#   define TOLOWER(Ch, L) __tolower_l (Ch, L)
+#  else
+#   define TOUPPER(Ch, L) toupper (Ch)
+#   define TOLOWER(Ch, L) tolower (Ch)
+#  endif
+# else
+#  define TOUPPER(Ch, L) (islower (Ch) ? toupper (Ch) : (Ch))
+#  define TOLOWER(Ch, L) (isupper (Ch) ? tolower (Ch) : (Ch))
+# endif
+#endif
+/* We don't use `isdigit' here since the locale dependent
+   interpretation is not what we want here.  We only need to accept
+   the arabic digits in the ASCII range.  One day there is perhaps a
+   more reliable way to accept other sets of digits.  */
+#define ISDIGIT(Ch) ((unsigned int) (Ch) - wxT('0') <= 9)
+
+static CHAR_T *memcpy_lowcase (CHAR_T *dest, const CHAR_T *src,
+			       size_t len LOCALE_PARAM_PROTO) __THROW;
+
+static CHAR_T *
+memcpy_lowcase ( CHAR_T * dest, const CHAR_T * src, size_t len LOCALE_PARAM_PROTO) {
+  while (len-- > 0)
+    dest[len] = TOLOWER ((UCHAR_T) src[len], loc);
+  return dest;
+}
+
+static CHAR_T *memcpy_uppcase (CHAR_T *dest, const CHAR_T *src,
+			       size_t len LOCALE_PARAM_PROTO) __THROW;
+
+static CHAR_T *
+memcpy_uppcase ( CHAR_T *dest, const CHAR_T *src, size_t len LOCALE_PARAM_PROTO ) {
+  while (len-- > 0)
+    dest[len] = TOUPPER ((UCHAR_T) src[len], loc);
+  return dest;
+}
+
+
+#if ! HAVE_TM_GMTOFF
+/* Yield the difference between *A and *B,
+   measured in seconds, ignoring leap seconds.  */
+# define tm_diff ftime_tm_diff
+static int tm_diff (const struct tm *, const struct tm *) __THROW;
+static int
+tm_diff ( const struct tm *a, const struct tm *b ) {
+  /* Compute intervening leap days correctly even if year is negative.
+     Take care to avoid int overflow in leap day calculations,
+     but it's OK to assume that A and B are close to each other.  */
+  int a4 = (a->tm_year >> 2) + (TM_YEAR_BASE >> 2) - ! (a->tm_year & 3);
+  int b4 = (b->tm_year >> 2) + (TM_YEAR_BASE >> 2) - ! (b->tm_year & 3);
+  int a100 = a4 / 25 - (a4 % 25 < 0);
+  int b100 = b4 / 25 - (b4 % 25 < 0);
+  int a400 = a100 >> 2;
+  int b400 = b100 >> 2;
+  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);
+  int years = a->tm_year - b->tm_year;
+  int days = (365 * years + intervening_leap_days
+	      + (a->tm_yday - b->tm_yday));
+  return (60 * (60 * (24 * days + (a->tm_hour - b->tm_hour))
+		+ (a->tm_min - b->tm_min))
+	  + (a->tm_sec - b->tm_sec));
+}
+#endif /* ! HAVE_TM_GMTOFF */
+
+
+
+/* The number of days from the first day of the first ISO week of this
+   year to the year day YDAY with week day WDAY.  ISO weeks start on
+   Monday; the first ISO week has the year's first Thursday.  YDAY may
+   be as small as YDAY_MINIMUM.  */
+#define ISO_WEEK_START_WDAY 1 /* Monday */
+#define ISO_WEEK1_WDAY 4 /* Thursday */
+#define YDAY_MINIMUM (-366)
+static int iso_week_days (int, int) __THROW;
+#ifdef __GNUC__
+__inline__
+#endif
+static int
+iso_week_days ( int yday, int wday) {
+  /* Add enough to the first operand of % to make it nonnegative.  */
+  int big_enough_multiple_of_7 = (-YDAY_MINIMUM / 7 + 2) * 7;
+  return (yday
+	  - (yday - wday + ISO_WEEK1_WDAY + big_enough_multiple_of_7) % 7
+	  + ISO_WEEK1_WDAY - ISO_WEEK_START_WDAY);
+}
+
+
+#if !(defined _NL_CURRENT || HAVE_STRFTIME)
+static CHAR_T const weekday_name[][10] =
+  {
+    wxT("Sunday"), wxT("Monday"), wxT("Tuesday"), wxT("Wednesday"),
+    wxT("Thursday"), wxT("Friday"), wxT("Saturday")
+  };
+static CHAR_T const month_name[][10] =
+  {
+    wxT("January"), wxT("February"), wxT("March"), wxT("April"), wxT("May"),
+    wxT("June"), wxT("July"), wxT("August"), wxT("September"), wxT("October"),
+    wxT("November"), wxT("December")
+  };
+#endif
+
+
+#ifdef emacs
+# define my_strftime emacs_strftimeu
+# define ut_argument , ut
+# define ut_argument_spec int ut;
+# define ut_argument_spec_iso , int ut
+#else
+# ifdef COMPILE_WIDE
+#  define my_strftime wcsftime
+#  define nL_get_alt_digit _nL_get_walt_digit
+# else
+#  define my_strftime strftime
+#  define nL_get_alt_digit _nL_get_alt_digit
+# endif
+# define ut_argument
+# define ut_argument_spec
+# define ut_argument_spec_iso
+/* We don't have this information in general.  */
+# define ut 0
+#endif
+
+#if !defined _LIBC && HAVE_TZNAME && HAVE_TZSET
+  /* Solaris 2.5 tzset sometimes modifies the storage returned by localtime.
+     Work around this bug by copying *tp before it might be munged.  */
+  size_t _strftime_copytm (char *, size_t, const char *,
+			   const struct tm * ut_argument_spec_iso) __THROW;
+  size_t
+  my_strftime (s, maxsize, format, tp ut_argument)
+      CHAR_T *s;
+      size_t maxsize;
+      const CHAR_T *format;
+      const struct tm *tp;
+      ut_argument_spec
+  {
+    struct tm tmcopy;
+    tmcopy = *tp;
+    return _strftime_copytm (s, maxsize, format, &tmcopy ut_argument);
+  }
+# undef my_strftime
+# define my_strftime _strftime_copytm
+#endif
+
+
+/* Write information from TP into S according to the format
+   string FORMAT, writing no more that MAXSIZE characters
+   (including the terminating '\0') and returning number of
+   characters written.  If S is NULL, nothing will be written
+   anywhere, so to determine how many characters would be
+   written, use NULL for S and (size_t) UINT_MAX for MAXSIZE.  */
+size_t
+my_strftime ( CHAR_T *s, size_t maxsize, const CHAR_T *format, const struct tm *tp
+#if ! defined( __WXWINCE__ )
+				, ut_argument_spec
+#endif
+			        LOCALE_PARAM_PROTO ) {
+#if defined _LIBC && defined USE_IN_EXTENDED_LOCALE_MODEL
+  struct locale_data *const current = loc->__locales[LC_TIME];
+#endif
+
+  int hour12 = tp->tm_hour;
+#ifdef _NL_CURRENT
+  /* We cannot make the following values variables since we must delay
+     the evaluation of these values until really needed since some
+     expressions might not be valid in every situation.  The `struct tm'
+     might be generated by a strptime() call that initialized
+     only a few elements.  Dereference the pointers only if the format
+     requires this.  Then it is ok to fail if the pointers are invalid.  */
+# define a_wkday \
+  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ABDAY_1) + tp->tm_wday))
+# define f_wkday \
+  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(DAY_1) + tp->tm_wday))
+# define a_month \
+  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ABMON_1) + tp->tm_mon))
+# define f_month \
+  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(MON_1) + tp->tm_mon))
+# define ampm \
+  ((const CHAR_T *) _NL_CURRENT (LC_TIME, tp->tm_hour > 11		      \
+				 ? NLW(PM_STR) : NLW(AM_STR)))
+
+# define aw_len STRLEN (a_wkday)
+# define am_len STRLEN (a_month)
+# define ap_len STRLEN (ampm)
+#else
+# if !HAVE_STRFTIME
+#  define f_wkday (weekday_name[tp->tm_wday])
+#  define f_month (month_name[tp->tm_mon])
+#  define a_wkday f_wkday
+#  define a_month f_month
+#  define ampm (wxT("AMPM") + 2 * (tp->tm_hour > 11))
+
+  size_t aw_len = 3;
+  size_t am_len = 3;
+  size_t ap_len = 2;
+# endif
+#endif
+  const char *zone;
+  size_t i = 0;
+  CHAR_T *p = s;
+  const CHAR_T *f;
+#if DO_MULTIBYTE && !defined COMPILE_WIDE
+  const char *format_end = NULL;
+#endif
+
+  zone = NULL;
+#if HAVE_TM_ZONE
+  /* The POSIX test suite assumes that setting
+     the environment variable TZ to a new value before calling strftime()
+     will influence the result (the %Z format) even if the information in
+     TP is computed with a totally different time zone.
+     This is bogus: though POSIX allows bad behavior like this,
+     POSIX does not require it.  Do the right thing instead.  */
+  zone = (const char *) tp->tm_zone;
+#endif
+#if HAVE_TZNAME
+  if (ut)
+    {
+      if (! (zone && *zone))
+	zone = "GMT";
+    }
+  else
+    {
+      /* POSIX.1 requires that local time zone information is used as
+	 though strftime called tzset.  */
+# if HAVE_TZSET
+      tzset ();
+# endif
+    }
+#endif
+
+  if (hour12 > 12)
+    hour12 -= 12;
+  else
+    if (hour12 == 0)
+      hour12 = 12;
+
+  for (f = format; *f != '\0'; ++f)
+    {
+      int pad = 0;		/* Padding for number ('-', '_', or 0).  */
+      int modifier;		/* Field modifier ('E', 'O', or 0).  */
+      int digits;		/* Max digits for numeric format.  */
+      int number_value; 	/* Numeric value to be printed.  */
+      int negative_number;	/* 1 if the number is negative.  */
+      const CHAR_T *subfmt;
+      CHAR_T *bufp;
+      CHAR_T buf[1 + (sizeof (int) < sizeof (time_t)
+		      ? INT_STRLEN_BOUND (time_t)
+		      : INT_STRLEN_BOUND (int))];
+      int width = -1;
+      int to_lowcase = 0;
+      int to_uppcase = 0;
+      int change_case = 0;
+      int format_char;
+
+#if DO_MULTIBYTE && !defined COMPILE_WIDE
+      switch (*f)
+	{
+	case wxT('%'):
+	  break;
+
+	case wxT('\b'): case wxT('\t'): case wxT('\n'):
+	case wxT('\v'): case wxT('\f'): case wxT('\r'):
+	case wxT(' '): case wxT('!'): case wxT('"'): case wxT('#'): case wxT('&'):
+	case wxT('\''): case wxT('('): case wxT(')'): case wxT('*'): case wxT('+'):
+	case wxT(','): case wxT('-'): case wxT('.'): case wxT('/'): case wxT('0'):
+	case wxT('1'): case wxT('2'): case wxT('3'): case wxT('4'): case wxT('5'):
+	case wxT('6'): case wxT('7'): case wxT('8'): case wxT('9'): case wxT(':'):
+	case wxT(';'): case wxT('<'): case wxT('='): case wxT('>'): case wxT('?'):
+	case wxT('A'): case wxT('B'): case wxT('C'): case wxT('D'): case wxT('E'):
+	case wxT('F'): case wxT('G'): case wxT('H'): case wxT('I'): case wxT('J'):
+	case wxT('K'): case wxT('L'): case wxT('M'): case wxT('N'): case wxT('O'):
+	case wxT('P'): case wxT('Q'): case wxT('R'): case wxT('S'): case wxT('T'):
+	case wxT('U'): case wxT('V'): case wxT('W'): case wxT('X'): case wxT('Y'):
+	case wxT('Z'): case wxT('['): case wxT('\\'): case wxT(']'): case wxT('^'):
+	case wxT('_'): case wxT('a'): case wxT('b'): case wxT('c'): case wxT('d'):
+	case wxT('e'): case wxT('f'): case wxT('g'): case wxT('h'): case wxT('i'):
+	case wxT('j'): case wxT('k'): case wxT('l'): case wxT('m'): case wxT('n'):
+	case wxT('o'): case wxT('p'): case wxT('q'): case wxT('r'): case wxT('s'):
+	case wxT('t'): case wxT('u'): case wxT('v'): case wxT('w'): case wxT('x'):
+	case wxT('y'): case wxT('z'): case wxT('{'): case wxT('|'): case wxT('}'):
+	case wxT('~'):
+	  /* The C Standard requires these 98 characters (plus '%') to
+	     be in the basic execution character set.  None of these
+	     characters can start a multibyte sequence, so they need
+	     not be analyzed further.  */
+	  addnchars (1, *p = *f);
+	  continue;
+
+	default:
+	  /* Copy this multibyte sequence until we reach its end, find
+	     an error, or come back to the initial shift state.  */
+	  {
+	    mbstate_t mbstate = mbstate_zero;
+	    size_t len = 0;
+	    size_t fsize;
+
+	    if (! format_end)
+	      format_end = f + strlen (f) + 1;
+	    fsize = format_end - f;
+
+	    do
+	      {
+		size_t bytes = mbrlen (f + len, fsize - len, &mbstate);
+
+		if (bytes == 0)
+		  break;
+
+		if (bytes == (size_t) -2)
+		  {
+		    len += strlen (f + len);
+		    break;
+		  }
+
+		if (bytes == (size_t) -1)
+		  {
+		    len++;
+		    break;
+		  }
+
+		len += bytes;
+	      }
+	    while (! mbsinit (&mbstate));
+
+	    cpychars (len, f);
+	    f += len - 1;
+	    continue;
+	  }
+	}
+
+#else /* ! DO_MULTIBYTE */
+
+      /* Either multibyte encodings are not supported, they are
+	 safe for formats, so any non-'%' byte can be copied through,
+	 or this is the wide character version.  */
+      if (*f != wxT('%'))
+	{
+	  addnchars (1, *p = *f);
+	  continue;
+	}
+
+#endif /* ! DO_MULTIBYTE */
+
+      /* Check for flags that can modify a format.  */
+      while (1)
+	{
+	  switch (*++f)
+	    {
+	      /* This influences the number formats.  */
+	    case wxT('_'):
+	    case wxT('-'):
+	    case wxT('0'):
+	      pad = *f;
+	      continue;
+
+	      /* This changes textual output.  */
+	    case wxT('^'):
+	      to_uppcase = 1;
+	      continue;
+	    case wxT('#'):
+	      change_case = 1;
+	      continue;
+
+	    default:
+	      break;
+	    }
+	  break;
+	}
+
+      /* As a GNU extension we allow to specify the field width.  */
+      if (ISDIGIT (*f))
+	{
+	  width = 0;
+	  do
+	    {
+	      if (width > INT_MAX / 10
+		  || (width == INT_MAX / 10 && *f - wxT('0') > INT_MAX % 10))
+		/* Avoid overflow.  */
+		width = INT_MAX;
+	      else
+		{
+		  width *= 10;
+		  width += *f - wxT('0');
+		}
+	      ++f;
+	    }
+	  while (ISDIGIT (*f));
+	}
 
+      /* Check for modifiers.  */
+      switch (*f)
+	{
+	case wxT('E'):
+	case wxT('O'):
+	  modifier = *f++;
+	  break;
+
+	default:
+	  modifier = 0;
+	  break;
+	}
+
+      /* Now do the specified format.  */
+      format_char = *f;
+      switch (format_char)
+	{
+#define DO_NUMBER(d, v) \
+	  digits = d > width ? d : width;				      \
+	  number_value = v; goto do_number
+#define DO_NUMBER_SPACEPAD(d, v) \
+	  digits = d > width ? d : width;				      \
+	  number_value = v; goto do_number_spacepad
+
+	case wxT('%'):
+	  if (modifier != 0)
+	    goto bad_format;
+	  addnchars (1, *p = *f);
+	  break;
+
+	case wxT('a'):
+	  if (modifier != 0)
+	    goto bad_format;
+	  if (change_case)
+	    {
+	      to_uppcase = 1;
+	      to_lowcase = 0;
+	    }
+#if defined _NL_CURRENT || !HAVE_STRFTIME
+	  cpychars (aw_len, a_wkday);
+	  break;
+#else
+	  goto underlying_strftime;
+#endif
+
+	case 'A':
+	  if (modifier != 0)
+	    goto bad_format;
+	  if (change_case)
+	    {
+	      to_uppcase = 1;
+	      to_lowcase = 0;
+	    }
+#if defined _NL_CURRENT || !HAVE_STRFTIME
+	  cpychars (STRLEN (f_wkday), f_wkday);
+	  break;
+#else
+	  goto underlying_strftime;
+#endif
+
+	case wxT('b'):
+	case wxT('h'):
+	  if (change_case)
+	    {
+	      to_uppcase = 1;
+	      to_lowcase = 0;
+	    }
+	  if (modifier != 0)
+	    goto bad_format;
+#if defined _NL_CURRENT || !HAVE_STRFTIME
+	  cpychars (am_len, a_month);
+	  break;
+#else
+	  goto underlying_strftime;
+#endif
+
+	case wxT('B'):
+	  if (modifier != 0)
+	    goto bad_format;
+	  if (change_case)
+	    {
+	      to_uppcase = 1;
+	      to_lowcase = 0;
+	    }
+#if defined _NL_CURRENT || !HAVE_STRFTIME
+	  cpychars (STRLEN (f_month), f_month);
+	  break;
+#else
+	  goto underlying_strftime;
+#endif
+
+	case wxT('c'):
+	  if (modifier == wxT('O'))
+	    goto bad_format;
+#ifdef _NL_CURRENT
+	  if (! (modifier == 'E'
+		 && (*(subfmt =
+		       (const CHAR_T *) _NL_CURRENT (LC_TIME,
+						     NLW(ERA_D_T_FMT)))
+		     != '\0')))
+	    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_T_FMT));
+#else
+# if HAVE_STRFTIME
+	  goto underlying_strftime;
+# else
+	  subfmt = wxT("%a %b %e %H:%M:%S %Y");
+# endif
+#endif
+
+	subformat:
+	  {
+	    CHAR_T *old_start = p;
+	    size_t len = my_strftime (NULL, (size_t) -1, subfmt,
+				      tp ut_argument LOCALE_ARG);
+	    addnchars (len, my_strftime (p, maxsize - i, subfmt,
+				   tp ut_argument LOCALE_ARG));
+
+	    if (to_uppcase)
+	      while (old_start < p)
+		{
+		  *old_start = TOUPPER ((UCHAR_T) *old_start, loc);
+		  ++old_start;
+		}
+	  }
+	  break;
+
+#if HAVE_STRFTIME && ! (defined _NL_CURRENT && HAVE_STRUCT_ERA_ENTRY)
+	underlying_strftime:
+	  {
+	    /* The relevant information is available only via the
+	       underlying strftime implementation, so use that.  */
+	    char ufmt[4];
+	    char *u = ufmt;
+	    char ubuf[1024]; /* enough for any single format in practice */
+	    size_t len;
+	    /* Make sure we're calling the actual underlying strftime.
+	       In some cases, config.h contains something like
+	       "#define strftime rpL_strftime".  */
+# ifdef strftime
+#  undef strftime
+	    size_t strftime ();
+# endif
+
+	    *u++ = '%';
+	    if (modifier != 0)
+	      *u++ = modifier;
+	    *u++ = format_char;
+	    *u = '\0';
+	    len = strftime (ubuf, sizeof ubuf, ufmt, tp);
+	    if (len == 0 && ubuf[0] != '\0')
     return 0;
+	    cpychars (len, ubuf);
+	  }
+	  break;
+#endif
+
+	case wxT('C'):
+	  if (modifier == wxT('O'))
+	    goto bad_format;
+	  if (modifier == wxT('E'))
+	    {
+#if HAVE_STRUCT_ERA_ENTRY
+	      struct era_entry *era = _nL_get_era_entry (tp HELPER_LOCALE_ARG);
+	      if (era)
+		{
+# ifdef COMPILE_WIDE
+		  size_t len = __wcslen (era->era_wname);
+		  cpychars (len, era->era_wname);
+# else
+		  size_t len = strlen (era->era_name);
+		  cpychars (len, era->era_name);
+# endif
+		  break;
+		}
+#else
+# if HAVE_STRFTIME
+	      goto underlying_strftime;
+# endif
+#endif
+	    }
+
+	  {
+	    int year = tp->tm_year + TM_YEAR_BASE;
+	    DO_NUMBER (1, year / 100 - (year % 100 < 0));
+	  }
+
+	case wxT('x'):
+	  if (modifier == wxT('O'))
+	    goto bad_format;
+#ifdef _NL_CURRENT
+	  if (! (modifier == wxT('E')
+		 && (*(subfmt =
+		       (const CHAR_T *)_NL_CURRENT (LC_TIME, NLW(ERA_D_FMT)))
+		     != wxT('\0'))))
+	    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_FMT));
+	  goto subformat;
+#else
+# if HAVE_STRFTIME
+	  goto underlying_strftime;
+# else
+	  /* Fall through.  */
+# endif
+#endif
+	case wxT('D'):
+	  if (modifier != 0)
+	    goto bad_format;
+	  subfmt = wxT("%m/%d/%y");
+	  goto subformat;
+
+	case wxT('d'):
+	  if (modifier == wxT('E'))
+	    goto bad_format;
+
+	  DO_NUMBER (2, tp->tm_mday);
+
+	case wxT('e'):
+	  if (modifier == wxT('E'))
+	    goto bad_format;
+
+	  DO_NUMBER_SPACEPAD (2, tp->tm_mday);
+
+	  /* All numeric formats set DIGITS and NUMBER_VALUE and then
+	     jump to one of these two labels.  */
+
+	do_number_spacepad:
+	  /* Force `_' flag unless overwritten by `0' or '-' flag.  */
+	  if (pad != wxT('0') && pad != wxT('-'))
+	    pad = wxT('_');
+
+	do_number:
+	  /* Format the number according to the MODIFIER flag.  */
+
+	  if (modifier == wxT('O') && 0 <= number_value)
+	    {
+#ifdef _NL_CURRENT
+	      /* Get the locale specific alternate representation of
+		 the number NUMBER_VALUE.  If none exist NULL is returned.  */
+	      const CHAR_T *cp = nL_get_alt_digit (number_value
+						   HELPER_LOCALE_ARG);
+
+	      if (cp != NULL)
+		{
+		  size_t digitlen = STRLEN (cp);
+		  if (digitlen != 0)
+		    {
+		      cpychars (digitlen, cp);
+		      break;
+		    }
+		}
+#else
+# if HAVE_STRFTIME
+	      goto underlying_strftime;
+# endif
+#endif
+	    }
+	  {
+	    unsigned int u = number_value;
+
+	    bufp = buf + sizeof (buf) / sizeof (buf[0]);
+	    negative_number = number_value < 0;
+
+	    if (negative_number)
+	      u = -negative_number;
+
+	    do
+	      *--bufp = u % 10 + wxT('0');
+	    while ((u /= 10) != 0);
+  	  }
+
+	do_number_sign_and_padding:
+	  if (negative_number)
+	    *--bufp = wxT('-');
+
+	  if (pad != wxT('-'))
+	    {
+	      int padding = digits - (buf + (sizeof (buf) / sizeof (buf[0]))
+				      - bufp);
+
+	      if (padding > 0)
+		{
+		  if (pad == wxT('_'))
+		    {
+		      if ((size_t) padding >= maxsize - i)
+			return 0;
+
+		      if (p)
+			memset_space (p, padding);
+		      i += padding;
+		      width = width > padding ? width - padding : 0;
+		    }
+		  else
+		    {
+		      if ((size_t) digits >= maxsize - i)
+			return 0;
+
+		      if (negative_number)
+			{
+			  ++bufp;
+
+			  if (p)
+			    *p++ = wxT('-');
+			  ++i;
+			}
+
+		      if (p)
+			memset_zero (p, padding);
+		      i += padding;
+		      width = 0;
+		    }
+		}
+	    }
+
+//	  cpychars (buf + sizeof (buf) / sizeof (buf[0]) - bufp, bufp);
+	  {  int n = buf + sizeof (buf) / sizeof (buf[0]) - bufp;
+		 do {							      
+			 int _n = (n);							      
+			 int _delta = width - _n;						      
+			 int _incr = _n + (_delta > 0 ? _delta : 0);			      
+			 if ((size_t) _incr >= maxsize - i)				      
+				 return 0;							      
+			 if (p) {								      
+				 if (_delta > 0){								      
+					 if (pad == wxT('0'))					      
+						 memset_zero (p, _delta);				      
+					 else							      
+						 memset_space (p, _delta);				  
+				 }								      
+				 if (to_lowcase)						      
+					 memcpy_lowcase (p, (bufp), _n LOCALE_ARG);			      
+				 else if (to_uppcase)						      
+					 memcpy_uppcase (p, (bufp), _n LOCALE_ARG);			      
+				 else								      
+					 MEMCPY ((PTR) p, (const PTR) (bufp), _n*sizeof(CHAR_T)); 
+				 p += _n;							      
+			 }
+			 i += _incr;							      
+		 } while (0);
+	  }
+
+	  break;
+
+	case wxT('F'):
+	  if (modifier != 0)
+	    goto bad_format;
+	  subfmt = wxT("%Y-%m-%d");
+	  goto subformat;
+
+	case wxT('H'):
+	  if (modifier == wxT('E'))
+	    goto bad_format;
+
+	  DO_NUMBER (2, tp->tm_hour);
+
+	case wxT('I'):
+	  if (modifier == wxT('E'))
+	    goto bad_format;
+
+	  DO_NUMBER (2, hour12);
+
+	case wxT('k'):		/* GNU extension.  */
+	  if (modifier == wxT('E'))
+	    goto bad_format;
+
+	  DO_NUMBER_SPACEPAD (2, tp->tm_hour);
+
+	case wxT('l'):		/* GNU extension.  */
+	  if (modifier == wxT('E'))
+	    goto bad_format;
+
+	  DO_NUMBER_SPACEPAD (2, hour12);
+
+	case wxT('j'):
+	  if (modifier == wxT('E'))
+	    goto bad_format;
+
+	  DO_NUMBER (3, 1 + tp->tm_yday);
+
+	case wxT('M'):
+	  if (modifier == wxT('E'))
+	    goto bad_format;
+
+	  DO_NUMBER (2, tp->tm_min);
+
+	case wxT('m'):
+	  if (modifier == wxT('E'))
+	    goto bad_format;
+
+	  DO_NUMBER (2, tp->tm_mon + 1);
+
+	case wxT('n'):
+	  addnchars (1, *p = wxT('\n'));
+	  break;
+
+	case wxT('P'):
+	  to_lowcase = 1;
+#if !defined _NL_CURRENT && HAVE_STRFTIME
+	  format_char = wxT('p');
+#endif
+	  /* FALLTHROUGH */
+
+	case wxT('p'):
+	  if (change_case)
+	    {
+	      to_uppcase = 0;
+	      to_lowcase = 1;
+	    }
+#if defined _NL_CURRENT || !HAVE_STRFTIME
+	  cpychars (ap_len, ampm);
+	  break;
+#else
+	  goto underlying_strftime;
+#endif
+
+	case wxT('R'):
+	  subfmt = wxT("%H:%M");
+	  goto subformat;
+
+	case wxT('r'):
+#if !defined _NL_CURRENT && HAVE_STRFTIME
+	  goto underlying_strftime;
+#else
+# ifdef _NL_CURRENT
+	  if (*(subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME,
+						       NLW(T_FMT_AMPM)))
+	      == wxT('\0'))
+# endif
+	    subfmt = wxT("%I:%M:%S %p");
+	  goto subformat;
+#endif
+
+	case wxT('S'):
+	  if (modifier == wxT('E'))
+	    goto bad_format;
+
+	  DO_NUMBER (2, tp->tm_sec);
+
+	case wxT('s'):		/* GNU extension.  */
+  	  {
+	    struct tm ltm;
+	    time_t t;
+
+	    ltm = *tp;
+	    t = mktime (&ltm);
+
+	    /* Generate string value for T using time_t arithmetic;
+	       this works even if sizeof (long) < sizeof (time_t).  */
+
+	    bufp = buf + sizeof (buf) / sizeof (buf[0]);
+	    negative_number = t < 0;
+
+	    do
+	      {
+		int d = t % 10;
+		t /= 10;
+
+		if (negative_number)
+		  {
+		    d = -d;
+
+		    /* Adjust if division truncates to minus infinity.  */
+		    if (0 < -1 % 10 && d < 0)
+		      {
+			t++;
+			d += 10;
+		      }
+		  }
+
+		*--bufp = d + wxT('0');
+	      }
+	    while (t != 0);
+
+	    digits = 1;
+	    goto do_number_sign_and_padding;
+	  }
+
+	case wxT('X'):
+	  if (modifier == wxT('O'))
+	    goto bad_format;
+#ifdef _NL_CURRENT
+	  if (! (modifier == wxT('E')
+		 && (*(subfmt =
+		       (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ERA_T_FMT)))
+		     != wxT('\0'))))
+	    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(T_FMT));
+	  goto subformat;
+#else
+# if HAVE_STRFTIME
+	  goto underlying_strftime;
+# else
+	  /* Fall through.  */
+# endif
+#endif
+	case wxT('T'):
+	  subfmt = wxT("%H:%M:%S");
+	  goto subformat;
+
+	case wxT('t'):
+	  addnchars (1, *p = wxT('\t'));
+	  break;
+
+	case wxT('u'):
+	  DO_NUMBER (1, (tp->tm_wday - 1 + 7) % 7 + 1);
+
+	case wxT('U'):
+	  if (modifier == wxT('E'))
+	    goto bad_format;
+
+	  DO_NUMBER (2, (tp->tm_yday - tp->tm_wday + 7) / 7);
+
+	case wxT('V'):
+	case wxT('g'):
+	case wxT('G'):
+	  if (modifier == wxT('E'))
+	    goto bad_format;
+	  {
+	    int year = tp->tm_year + TM_YEAR_BASE;
+	    int days = iso_week_days (tp->tm_yday, tp->tm_wday);
+
+	    if (days < 0)
+	      {
+		/* This ISO week belongs to the previous year.  */
+		year--;
+		days = iso_week_days (tp->tm_yday + (365 + __isleap (year)),
+				      tp->tm_wday);
+	      }
+	    else
+	      {
+		int d = iso_week_days (tp->tm_yday - (365 + __isleap (year)),
+				       tp->tm_wday);
+		if (0 <= d)
+		  {
+		    /* This ISO week belongs to the next year.  */
+		    year++;
+		    days = d;
+		  }
+	      }
+
+	    switch (*f)
+	      {
+	      case wxT('g'):
+		DO_NUMBER (2, (year % 100 + 100) % 100);
+
+	      case wxT('G'):
+		DO_NUMBER (1, year);
+
+	      default:
+		DO_NUMBER (2, days / 7 + 1);
+	      }
+	  }
+
+	case wxT('W'):
+	  if (modifier == wxT('E'))
+	    goto bad_format;
+
+	  DO_NUMBER (2, (tp->tm_yday - (tp->tm_wday - 1 + 7) % 7 + 7) / 7);
+
+	case wxT('w'):
+	  if (modifier == wxT('E'))
+	    goto bad_format;
+
+	  DO_NUMBER (1, tp->tm_wday);
+
+	case wxT('Y'):
+	  if (modifier == 'E')
+	    {
+#if HAVE_STRUCT_ERA_ENTRY
+	      struct era_entry *era = _nL_get_era_entry (tp HELPER_LOCALE_ARG);
+	      if (era)
+		{
+# ifdef COMPILE_WIDE
+		  subfmt = era->era_wformat;
+# else
+		  subfmt = era->era_format;
+# endif
+		  goto subformat;
+		}
+#else
+# if HAVE_STRFTIME
+	      goto underlying_strftime;
+# endif
+#endif
+	    }
+	  if (modifier == wxT('O'))
+	    goto bad_format;
+	  else
+	    DO_NUMBER (1, tp->tm_year + TM_YEAR_BASE);
+
+	case wxT('y'):
+	  if (modifier == wxT('E'))
+	    {
+#if HAVE_STRUCT_ERA_ENTRY
+	      struct era_entry *era = _nL_get_era_entry (tp HELPER_LOCALE_ARG);
+	      if (era)
+		{
+		  int delta = tp->tm_year - era->start_date[0];
+		  DO_NUMBER (1, (era->offset
+				 + delta * era->absolute_direction));
+		}
+#else
+# if HAVE_STRFTIME
+	      goto underlying_strftime;
+# endif
+#endif
+	    }
+	  DO_NUMBER (2, (tp->tm_year % 100 + 100) % 100);
+
+	case wxT('Z'):
+	  if (change_case)
+	    {
+	      to_uppcase = 0;
+	      to_lowcase = 1;
+	    }
+
+#if HAVE_TZNAME
+	  /* The tzset() call might have changed the value.  */
+	  if (!(zone && *zone) && tp->tm_isdst >= 0)
+	    zone = tzname[tp->tm_isdst];
+#endif
+	  if (! zone)
+	    zone = "";
+
+#ifdef COMPILE_WIDE
+	  {
+	    /* The zone string is always given in multibyte form.  We have
+	       to transform it first.  */
+	    wchar_t *wczone;
+	    size_t len;
+	    widen (zone, wczone, len);
+	    cpychars (len, wczone);
+	  }
+#else
+	  cpychars (strlen (zone), zone);
+#endif
+	  break;
+
+	case wxT('z'):
+	  if (tp->tm_isdst < 0)
+	    break;
+
+	  {
+	    int diff;
+#if HAVE_TM_GMTOFF
+	    diff = tp->tm_gmtoff;
+#else
+	    if (ut)
+	      diff = 0;
+	    else
+	      {
+		struct tm gtm;
+		struct tm ltm;
+		time_t lt;
+
+		ltm = *tp;
+		lt = mktime (&ltm);
+
+		if (lt == (time_t) -1)
+		  {
+		    /* mktime returns -1 for errors, but -1 is also a
+		       valid time_t value.  Check whether an error really
+		       occurred.  */
+		    struct tm tm;
+
+		    if (! __localtime_r (&lt, &tm)
+			|| ((ltm.tm_sec ^ tm.tm_sec)
+			    | (ltm.tm_min ^ tm.tm_min)
+			    | (ltm.tm_hour ^ tm.tm_hour)
+			    | (ltm.tm_mday ^ tm.tm_mday)
+			    | (ltm.tm_mon ^ tm.tm_mon)
+			    | (ltm.tm_year ^ tm.tm_year)))
+		      break;
+		  }
+
+		if (! __gmtime_r (&lt, &gtm))
+		  break;
+
+		diff = tm_diff (&ltm, &gtm);
+	      }
+#endif
+
+	    if (diff < 0)
+	      {
+		addnchars (1, *p = wxT('-'));
+		diff = -diff;
+	      }
+	    else
+	      addnchars (1, *p = wxT('+'));
+
+	    diff /= 60;
+	    DO_NUMBER (4, (diff / 60) * 100 + diff % 60);
+	  }
+
+	case wxT('\0'):		/* GNU extension: % at end of format.  */
+	    --f;
+	    /* Fall through.  */
+	default:
+	  /* Unknown format; output the format, including the '%',
+	     since this is most likely the right thing to do if a
+	     multibyte string has been misparsed.  */
+	bad_format:
+	  {
+	    int flen;
+	    for (flen = 1; f[1 - flen] != wxT('%'); flen++)
+	      continue;
+	    cpychars (flen, &f[1 - flen]);
+	  }
+	  break;
+	}
+    }
+
+  if (p && maxsize != 0)
+    *p = wxT('\0');
+  return i;
 }
+#ifdef _LIBC
+libc_hidden_def (my_strftime)
+#endif
 
-} // extern "C"
+
+#ifdef emacs
+/* For Emacs we have a separate interface which corresponds to the normal
+   strftime function and does not have the extra information whether the
+   TP arguments comes from a `gmtime' call or not.  */
+size_t
+emacs_strftime (s, maxsize, format, tp)
+      char *s;
+      size_t maxsize;
+      const char *format;
+      const struct tm *tp;
+{
+  return my_strftime (s, maxsize, format, tp, 0);
+}
+#endif
+
+#if defined _LIBC && !defined COMPILE_WIDE
+weak_alias (__strftime_l, strftime_l)
+#endif

 	  	 
