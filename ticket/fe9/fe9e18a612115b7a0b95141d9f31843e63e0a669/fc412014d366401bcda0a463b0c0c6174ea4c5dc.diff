diff -rbu2 --exclude=CVS --exclude=GTK --exclude=MSW --exclude=tiff --exclude=UNIV --exclude=notebook.* --exclude=files.lst --new-file ../wxWindows/include/wx/dbgrid.h ./include/wx/dbgrid.h
--- ../wxWindows/include/wx/dbgrid.h	Thu Jan  1 01:00:00 1970
+++ ./include/wx/dbgrid.h	Fri Jun  1 10:57:12 2001
@@ -0,0 +1,158 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        dbgrid.h
+// Purpose:     Displays a wxDbTable in a wxGrid.
+// Author:      Roger Gammans, Paul Gammans
+// Modified by:
+// Created:     
+// RCS-ID:      $Id:$
+// Copyright:   (c) 1999 The Computer Surgery (roger@computer-surgery.co.uk)
+// Licence:     wxWindows licence
+///////////////////////////////////////////////////////////////////////////////
+// Branched From : dbgrid.h,v 1.19 2001/03/28 11:16:01
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_GENERIC_DBGRID_H_
+#define _WX_GENERIC_DBGRID_H_
+
+#ifdef __GNUG__
+    #pragma interface "dbgrid.h"
+#endif
+
+#include "wx/log.h"
+#include "wx/dbtable.h"
+#include "wx/dynarray.h"
+#include "wx/grid.h"
+#include "wx/gkey.h"
+
+#define wxGRID_VALUE_DBAUTO     _T("dbauto")
+
+WX_DECLARE_OBJARRAY(GenericKey,keyarray);
+
+static const int wxUSE_QUERY=-1;
+
+class wxdbGridColInfoBase
+{
+public:
+    //Default ctor
+    wxdbGridColInfoBase() { }
+    wxdbGridColInfoBase(int colNo,
+        wxString type, wxString title) :
+        DbCol(colNo) , wxtypename(type) , Title(title) { }
+    //Copy Ctor
+    wxdbGridColInfoBase(const wxdbGridColInfoBase& ref)
+    {
+        DbCol=ref.DbCol;
+        wxtypename=ref.wxtypename;
+        Title=ref.Title;    
+    }
+    //Empty destructor for memeber obj's
+    ~wxdbGridColInfoBase() {}
+    
+    int       DbCol;
+    wxString  wxtypename;
+    wxString  Title;
+};
+
+
+class wxdbGridColInfo
+{
+public:
+    wxdbGridColInfo(int colNo,
+            wxString type,
+            wxString title,
+            wxdbGridColInfo* next) :
+        m_data(colNo,type,title)
+    {
+        m_next=next;
+    }
+
+    //Empty List
+    ~wxdbGridColInfo() { delete m_next; }
+
+    //Recurse to find length.
+    int Length() { return ( m_next ? m_next->Length() +1 :  1); }
+
+    protected:
+    wxdbGridColInfoBase m_data;
+    wxdbGridColInfo*    m_next;
+
+    friend class wxDbGridTableBase;
+};
+
+class wxDbGridCellAttrProvider : public wxGridCellAttrProvider
+{
+public:
+    wxDbGridCellAttrProvider();
+    wxDbGridCellAttrProvider(wxDbTable *tab, wxdbGridColInfoBase* ColInfo);
+    virtual ~wxDbGridCellAttrProvider();
+
+    virtual wxGridCellAttr *GetAttr(int row, int col,
+                                    wxGridCellAttr::wxAttrKind kind ) const;
+    virtual void AssignDbTable(wxDbTable *tab);
+private:
+    wxDbTable    *m_data;
+    wxdbGridColInfoBase* m_ColInfo;
+};
+
+
+
+class wxDbGridTableBase  : public  wxGridTableBase
+{
+public:
+    wxDbGridTableBase(wxDbTable *tab, wxdbGridColInfo*  ColInfo,
+              int count = wxUSE_QUERY, bool takeOwnership=TRUE );
+    ~wxDbGridTableBase();
+
+    virtual int GetNumberRows()
+    {
+        wxLogDebug(" GetNumberRows() = %i",m_rowtotal);
+        return m_rowtotal; 
+    }
+    virtual int GetNumberCols()
+    { 
+        wxLogDebug(" GetNumberCols() = %i",m_nocols);
+        return m_nocols; 
+    }
+    virtual bool IsEmptyCell( int row, int col ) ;
+    virtual wxString GetValue( int row, int col ) ;
+    virtual void SetValue( int row, int col, const wxString& value );
+    virtual bool CanHaveAttributes();
+    virtual wxString GetTypeName( int row, int col );
+    virtual bool CanGetValueAs( int row, int col, const wxString& typeName );
+    virtual bool CanSetValueAs( int row, int col, const wxString& typeName );
+    virtual long GetValueAsLong( int row, int col );
+    virtual double GetValueAsDouble( int row, int col );
+    virtual bool GetValueAsBool( int row, int col );
+    virtual void SetValueAsLong( int row, int col, long value );
+    virtual void SetValueAsDouble( int row, int col, double value );
+    virtual void SetValueAsBool( int row, int col, bool value );
+    virtual void* GetValueAsCustom( int row, int col, const wxString& typeName );
+    virtual void  SetValueAsCustom( int row, int col, const wxString& typeName, void* value );
+
+
+    virtual wxString wxDbGridTableBase::GetColLabelValue( int col );
+
+    virtual bool AssignDbTable(wxDbTable *tab, int count = wxUSE_QUERY, bool takeOwnership=TRUE );
+    virtual void ValidateRow(int row);
+    virtual bool UpdateRow(int row) const
+    {
+        if (m_row != row) { return true; }
+        else return Writeback();
+    }
+    
+private:
+    //Operates on the current row
+    bool Writeback() const;
+
+    typedef wxGridTableBase inherited;
+    keyarray    m_keys;
+    wxDbTable   *m_data;
+    bool        m_dbowner;
+    int         m_rowtotal;
+    int         m_nocols;
+    int         m_row;
+    wxdbGridColInfoBase* m_ColInfo;
+    bool        m_rowmodified;
+};
+
+#endif _WX_GENERIC_DBGRID_H_
diff -rbu2 --exclude=CVS --exclude=GTK --exclude=MSW --exclude=tiff --exclude=UNIV --exclude=notebook.* --exclude=files.lst --new-file ../wxWindows/include/wx/dbtable.h ./include/wx/dbtable.h
--- ../wxWindows/include/wx/dbtable.h	Thu May 17 10:39:12 2001
+++ ./include/wx/dbtable.h	Thu May  3 13:48:27 2001
@@ -46,4 +46,7 @@
 #endif
 
+#include "wx/variant.h"
+#include "wx/gkey.h"
+
 const int   wxDB_ROWID_LEN       = 24;  // 18 is the max, 24 is in case it gets larger
 const int   wxDB_DEFAULT_CURSOR  = 0;
@@ -321,5 +324,5 @@
     int             DB_STATUS(void) { return(pDb->DB_STATUS); }
 
-    bool            IsColNull(UWORD colNo);
+    bool            IsColNull(UWORD colNo) const;
     bool            SetColNull(UWORD colNo, bool set=TRUE);
     bool            SetColNull(const wxString &colName, bool set=TRUE);
@@ -332,4 +335,30 @@
     ULONG           GetTableID() { return tableID; }
 #endif
+
+
+		typedef	    	enum  { WX_ROW_MODE_QUERY , WX_ROW_MODE_INDIVIDUAL } rowmode_t;
+		virtual 	void 	    setRowMode(const rowmode_t rowmode);
+		virtual 	wxVariant   GetCol(const int Colno) const ;
+		virtual 	void	    SetCol(const int ColNo, const wxVariant value);
+		virtual 	GenericKey  GetKey(void);
+		virtual 	void        SetKey(const GenericKey& key);
+
+	private:
+		HSTMT*   	m_key;
+		rowmode_t	m_rowmode;
+		size_t      m_keysz;
+
+//		typedef enum {unmodified=0, UpdatePending, InsertPending } recStatus;
+
+//		recStatus  get_ModifiedStatus() { return m_recstatus; }
+		
+//		void modify() {
+//			if (m_recstatus==unmodified)
+//				m_recstatus=UpdatePending;
+//		}
+//	protected:
+//		void insertify() {m_recstatus=InsertPending; }
+//		void unmodify() {m_recstatus=unmodified; }
+//		recStatus m_recstatus;
 
 };  // wxDbTable
diff -rbu2 --exclude=CVS --exclude=GTK --exclude=MSW --exclude=tiff --exclude=UNIV --exclude=notebook.* --exclude=files.lst --new-file ../wxWindows/include/wx/gkey.h ./include/wx/gkey.h
--- ../wxWindows/include/wx/gkey.h	Thu Jan  1 01:00:00 1970
+++ ./include/wx/gkey.h	Fri Jun  1 11:35:08 2001
@@ -0,0 +1,37 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        dbgrid.h
+// Purpose:     Generic key support for wxDbTable
+// Author:      Roger Gammans
+// Modified by:
+// Created:     
+// RCS-ID:      $Id:$
+// Copyright:   (c) 1999 The Computer Surgery (roger@computer-surgery.co.uk)
+// Licence:     wxWindows licence
+///////////////////////////////////////////////////////////////////////////////
+// Branched From : gkey.h,v 1.3 2001/06/01 10:31:41
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_GKEY_H_
+#define _WX_GKEY_H_
+
+class GenericKey
+{
+public:
+    GenericKey(void* blk , size_t sz) { clone(blk,sz); }
+    GenericKey(const GenericKey& ref) { clone(ref.m_data,ref.m_sz); }
+    ~GenericKey() { free(m_data); }
+    void * GetBlk(void) const { return  m_data; }
+
+private:
+    void clone(void* blk , size_t sz)
+    {
+        m_data = malloc(sz);
+        memcpy(m_data,blk,sz);
+        m_sz=sz;
+    }
+
+    void*  m_data;
+    size_t m_sz;
+};
+
+#endif // _WX_GKEY_H_
diff -rbu2 --exclude=CVS --exclude=GTK --exclude=MSW --exclude=tiff --exclude=UNIV --exclude=notebook.* --exclude=files.lst --new-file ../wxWindows/include/wx/variant.h ./include/wx/variant.h
--- ../wxWindows/include/wx/variant.h	Sun Feb  6 19:11:06 2000
+++ ./include/wx/variant.h	Thu May 31 19:39:54 2001
@@ -26,7 +26,11 @@
     #include "wx/date.h"
 #endif // time/date
-
+#include "wx/datetime.h"
+#if wxUSE_ODBC
+    #include "wx/db.h"
+#endif //ODBC
 #include "wx/ioswrap.h"
 
+
 /*
  * wxVariantData stores the actual data in a wxVariant object,
@@ -98,5 +102,13 @@
 #endif
     wxVariant(void* ptr, const wxString& name = wxEmptyString); // void* (general purpose)
-    wxVariant(wxVariantData* data, const wxString& name = wxEmptyString); // User-defined data
+    wxVariant(const wxDateTime& val, const wxString& name = wxEmptyString); // Date
+    wxVariant(wxVariantData* data, const wxString& name = wxEmptyString); // DateTime
+
+#if wxUSE_ODBC
+    wxVariant(const DATE_STRUCT* valptr, const wxString& name = wxEmptyString); // DateTime
+    wxVariant(const TIME_STRUCT* valptr, const wxString& name = wxEmptyString); // DateTime
+    wxVariant(const TIMESTAMP_STRUCT* valptr, const wxString& name = wxEmptyString); // DateTime
+#endif
+
     wxVariant(const wxVariant& variant);
     ~wxVariant();
@@ -150,4 +162,12 @@
     void operator= (void* value) ;
 
+    bool operator== (const wxDateTime& value) const;
+    bool operator!= (const wxDateTime& value) const;
+    void operator= (const wxDateTime& value) ;
+    void operator= (const DATE_STRUCT* value) ;
+    void operator= (const TIME_STRUCT* value) ;
+    void operator= (const TIMESTAMP_STRUCT* value) ;
+
+
     // Treat a list variant as an array
     wxVariant operator[] (size_t idx) const;
@@ -169,4 +189,5 @@
 #endif
     inline operator void* () const {  return GetVoidPtr(); }
+    inline operator wxDateTime () const { return GetDateTime(); }
 
 // Accessors
@@ -207,4 +228,6 @@
 #endif
     void* GetVoidPtr() const ;
+    wxDateTime GetDateTime() const ;
+
 
 // Operations
@@ -243,4 +266,5 @@
     bool Convert(wxDate* value) const;
 #endif
+    bool Convert(wxDateTime* value) const;
 
 // Attributes
diff -rbu2 --exclude=CVS --exclude=GTK --exclude=MSW --exclude=tiff --exclude=UNIV --exclude=notebook.* --exclude=files.lst --new-file ../wxWindows/samples/db/dbtest.cpp ./samples/db/dbtest.cpp
--- ../wxWindows/samples/db/dbtest.cpp	Sat May 26 16:20:40 2001
+++ ./samples/db/dbtest.cpp	Fri Jun  1 10:39:59 2001
@@ -45,4 +45,9 @@
 //#include <wx/dbtable.h>             /* Has the wxDbTable object from which all data objects will inherit their data table functionality */
 
+#include <wx/grid.h>
+#include <wx/generic/gridctrl.h>
+#include <wx/dbgrid.h>
+
+#define CHOICEINT
 //extern wxDbList WXDLLEXPORT *PtrBegDbList;    /* from db.cpp, used in getting back error results from db connections */
 
@@ -397,4 +402,5 @@
     file_menu->Append(FILE_RECREATE_TABLE, wxT("&Recreate CONTACT table"));
     file_menu->Append(FILE_RECREATE_INDEXES, wxT("&Recreate CONTACT indexes"));
+    file_menu->Append(FILE_DBGRID_TABLE,  wxT("&Open DB Grid example"));
     file_menu->Append(FILE_EXIT, wxT("E&xit"));
 
@@ -576,4 +582,5 @@
     EVT_MENU(FILE_RECREATE_TABLE, DatabaseDemoFrame::OnRecreateTable)
     EVT_MENU(FILE_RECREATE_INDEXES, DatabaseDemoFrame::OnRecreateIndexes)
+    EVT_MENU(FILE_DBGRID_TABLE, DatabaseDemoFrame::OnDbGridTable)
     EVT_MENU(FILE_EXIT, DatabaseDemoFrame::OnExit)
     EVT_MENU(EDIT_PARAMETERS, DatabaseDemoFrame::OnEditParameters)
@@ -633,4 +640,15 @@
 
 
+void DatabaseDemoFrame::OnDbGridTable(wxCommandEvent& )
+{
+
+    DbGridFrame *frame = new DbGridFrame(this);
+    if (frame->Initialize())
+    {
+        frame->Show();
+    }
+}
+
+
 void DatabaseDemoFrame::OnExit(wxCommandEvent& event)
 {
@@ -2873,4 +2891,108 @@
             wxMessageBox(wxT("SUCCEEDED creating data source"),wxT("SUCCESS"));
 */
+
+
+BEGIN_EVENT_TABLE(DbGridFrame, wxFrame)
+ //   EVT_CLOSE(DbGridFrame::OnCloseWindow)
+END_EVENT_TABLE()
+
+DbGridFrame::DbGridFrame(wxWindow *parent)
+    : wxFrame (parent, -1, wxT("DataBase Table"),
+        wxDefaultPosition, wxSize(400, 325))
+{
+    initialized = FALSE;
+}
+
+void DbGridFrame::OnCloseWindow(wxCloseEvent& event)
+{
+    this->Destroy();
+}
+
+bool DbGridFrame::Initialize()
+{
+    wxGrid *grid = new wxGrid(this, -1, wxDefaultPosition);
+
+    grid->RegisterDataType(wxGRID_VALUE_DATETIME,
+                             new wxGridCellDateTimeRenderer(_T("%d %b %Y")),
+                             new wxGridCellTextEditor);
+#ifdef CHOICEINT
+    grid->RegisterDataType(wxGRID_VALUE_CHOICEINT,
+                             new wxGridCellEnumRenderer,
+                             new wxGridCellEnumEditor);
+                             
+    wxString NativeLangChoice( wxString::Format("%s:%s,%s,%s,%s,%s",wxGRID_VALUE_CHOICEINT, 
+                            wxT("English"),
+                            wxT("French"),
+                            wxT("German"),
+                            wxT("Spanish"),
+                            wxT("Other") )); 
+#endif
+
+    wxdbGridColInfo* cols = new wxdbGridColInfo(0,wxGRID_VALUE_STRING,wxT("Name"),
+        new wxdbGridColInfo(1,wxGRID_VALUE_STRING,wxT("Adderss 1"),
+        new wxdbGridColInfo(2,wxGRID_VALUE_STRING,wxT("Adderss 2"),
+        new wxdbGridColInfo(3,wxGRID_VALUE_STRING,wxT("City"),
+        new wxdbGridColInfo(4,wxGRID_VALUE_STRING,wxT("State"),
+        new wxdbGridColInfo(5,wxGRID_VALUE_STRING,wxT("PostCode"),
+        new wxdbGridColInfo(6,wxGRID_VALUE_STRING,wxT("Country"),
+        new wxdbGridColInfo(7,wxGRID_VALUE_DBAUTO,wxT("Join Date"),
+        new wxdbGridColInfo(8,wxGRID_VALUE_BOOL,wxT("Developer"),
+        new wxdbGridColInfo(9,wxGRID_VALUE_NUMBER,wxT("Contributions"),
+        new wxdbGridColInfo(10,wxGRID_VALUE_NUMBER,wxT("Lines Of Code"),
+#ifdef CHOICEINT
+        new wxdbGridColInfo(11,NativeLangChoice,wxT("Native Language"),NULL))))))))))));
+#else        
+        new wxdbGridColInfo(11,wxGRID_VALUE_NUMBER,wxT("Native Language"),NULL))))))))))));
+#endif
+
+
+
+    Ccontact *Contact = new Ccontact();
+    //wxGetApp().Contact
+
+    if (!Contact)
+    {
+        wxMessageBox(wxT("Unable to instantiate an instance of Ccontact"),wxT("Error..."),wxOK | wxICON_EXCLAMATION);
+        return FALSE;
+    }
+
+    if (!Contact->Open())
+    {
+
+        if (Contact->GetDb()->TableExists(CONTACT_TABLE_NAME, Contact->GetDb()->GetUsername(),
+                                          wxGetApp().DbConnectInf->GetDefaultDir()))
+        {
+            wxString tStr;
+            tStr.Printf(wxT("Unable to open the table '%s'.\n\n"),CONTACT_TABLE_NAME);
+            tStr += GetExtendedDBErrorMsg(Contact->GetDb(),__FILE__,__LINE__);
+            wxMessageBox(tStr,wxT("ODBC Error..."),wxOK | wxICON_EXCLAMATION);
+        }
+
+        return FALSE;
+
+    }
+
+    if (!Contact->Query())
+    {
+        wxString tStr;
+        tStr  = wxT("ODBC error during Query()\n\n");
+        tStr += GetExtendedDBErrorMsg(Contact->GetDb(),__FILE__,__LINE__);
+        wxMessageBox(tStr,wxT("ODBC Error..."),wxOK | wxICON_EXCLAMATION);
+        return FALSE;
+    }
+
+    wxDbGridTableBase* db = new wxDbGridTableBase( Contact , cols, wxUSE_QUERY, true);
+    grid->SetTable(db,true);
+    grid->SetMargins(0, 0);
+    grid->Fit();
+    wxSize size = grid->GetSize();
+    size.x += 10;
+    size.y += 10;
+    SetClientSize(size);
+    initialized = TRUE;
+    return TRUE;
+}
+
+
 
 
diff -rbu2 --exclude=CVS --exclude=GTK --exclude=MSW --exclude=tiff --exclude=UNIV --exclude=notebook.* --exclude=files.lst --new-file ../wxWindows/samples/db/dbtest.h ./samples/db/dbtest.h
--- ../wxWindows/samples/db/dbtest.h	Sat May 26 16:20:40 2001
+++ ./samples/db/dbtest.h	Thu May 31 22:58:24 2001
@@ -23,4 +23,5 @@
 #define FILE_RECREATE_TABLE   110
 #define FILE_RECREATE_INDEXES 120
+#define FILE_DBGRID_TABLE     130
 #define FILE_EXIT             199
 #define EDIT_PARAMETERS       200
@@ -167,5 +168,7 @@
         void    OnEditParameters(wxCommandEvent& event);
         void    OnAbout(wxCommandEvent& event);
+        void    OnDbGridTable( wxCommandEvent& );
 
+        void    CreateDataTable(bool recreate);
         void    BuildEditorDialog();
         void    BuildParameterDialog(wxWindow *parent);
@@ -535,4 +538,19 @@
 #define QUERY_DIALOG_HINT_GROUP         323
 #define QUERY_DIALOG_HINT_MSG           324
+
+// *************************** DBGridFrame ***************************
+
+class DbGridFrame : public wxFrame
+{
+public:
+    bool             initialized;
+
+    DbGridFrame(wxWindow *parent);
+    void    OnCloseWindow(wxCloseEvent& event);
+    bool    Initialize();
+
+DECLARE_EVENT_TABLE()
+};
+
 
 char * const langNO                        = "No";
diff -rbu2 --exclude=CVS --exclude=GTK --exclude=MSW --exclude=tiff --exclude=UNIV --exclude=notebook.* --exclude=files.lst --new-file ../wxWindows/src/common/dbtable.cpp ./src/common/dbtable.cpp
--- ../wxWindows/src/common/dbtable.cpp	Thu May 31 23:31:46 2001
+++ ./src/common/dbtable.cpp	Fri Jun  1 10:06:09 2001
@@ -38,5 +38,7 @@
 #endif
 
+#define DBDEBUG_CONSOLE
 #ifdef DBDEBUG_CONSOLE
+	#include "iostream.h"
     #include "wx/ioswrap.h"
 #endif
@@ -705,4 +707,13 @@
     wxString sqlStmt;
     wxString s;
+    int NrKeyCols=0;
+
+    m_keysz = 0;
+    for (i=0 ; i < noCols; i++ ) {
+        if (colDefs[i].KeyField) {
+            NrKeyCols++;
+            m_keysz+=colDefs[i].SzDataObj;
+        }
+    }
 
     s.Empty();
@@ -1316,17 +1327,17 @@
         {
             case DB_DATA_TYPE_VARCHAR:
-                cout << pDb->typeInfVarchar.TypeName << wxT("(") << colDefs[i].SzDataObj << wxT(")");
+                cout << pDb->GetTypeInfVarchar().TypeName << wxT("(") << colDefs[i].SzDataObj << wxT(")");
                 break;
             case DB_DATA_TYPE_INTEGER:
-                cout << pDb->typeInfInteger.TypeName;
+                cout << pDb->GetTypeInfInteger().TypeName;
                 break;
             case DB_DATA_TYPE_FLOAT:
-                cout << pDb->typeInfFloat.TypeName;
+                cout << pDb->GetTypeInfFloat().TypeName;
                 break;
             case DB_DATA_TYPE_DATE:
-                cout << pDb->typeInfDate.TypeName;
+                cout << pDb->GetTypeInfDate().TypeName;
                 break;
             case DB_DATA_TYPE_BLOB:
-                cout << pDb->typeInfBlob.TypeName;
+                cout << pDb->GetTypeInfBlob().TypeName;
                 break;
         }
@@ -1920,5 +1931,5 @@
 
 /********** wxDbTable::IsColNull() **********/
-bool wxDbTable::IsColNull(UWORD colNo)
+bool wxDbTable::IsColNull(UWORD colNo) const
 {
 /*
@@ -2460,4 +2471,181 @@
 
 }  // wxDbTable::DeleteCursor()
+
+
+
+void wxDbTable::setRowMode(const rowmode_t rowmode) {
+	m_rowmode = rowmode;
+	switch (m_rowmode) {
+		case WX_ROW_MODE_QUERY:
+			SetCursor(m_key);
+		break;
+		case WX_ROW_MODE_INDIVIDUAL:
+			SetCursor(hstmtDefault);
+		break;
+	}
+}
+
+wxVariant wxDbTable::GetCol(const int Colno) const {
+
+	wxVariant val;
+	if ( (Colno < noCols) && (! IsColNull(Colno)) ) {
+
+		switch (colDefs[Colno].SqlCtype) {
+			case SQL_CHAR:
+			case SQL_VARCHAR:
+				val = (char *)(colDefs[Colno].PtrDataObj);
+			break;
+			case SQL_C_LONG:
+			case SQL_C_SLONG:
+				val = *(long *)(colDefs[Colno].PtrDataObj);
+			break;
+			case SQL_C_SHORT:
+			case SQL_C_SSHORT:
+				val = (long int )(*(short *)(colDefs[Colno].PtrDataObj));
+			break;
+			case SQL_C_ULONG:
+				val = (long)(*(unsigned long *)(colDefs[Colno].PtrDataObj));
+			break;
+			case SQL_C_UTINYINT:
+			case SQL_C_USHORT:
+				val = (long)(*(unsigned short *)(colDefs[Colno].PtrDataObj));
+			break;
+			case SQL_C_DATE:
+				val = (DATE_STRUCT *)(colDefs[Colno].PtrDataObj);
+			break;
+			case SQL_C_TIME:
+				val = (TIME_STRUCT *)(colDefs[Colno].PtrDataObj);
+			break;
+			case SQL_C_TIMESTAMP:
+				val = (TIMESTAMP_STRUCT *)(colDefs[Colno].PtrDataObj);
+			break;
+			case SQL_C_DOUBLE:
+				val = *(double *)(colDefs[Colno].PtrDataObj);
+			break;
+		}
+	}
+	return val;
+}
+
+void csstrncpyt(char *s, const char *t, int n){
+	while((*s++ = *t++)	&& --n) ;
+	*s = '\0';
+}
+
+void
+wxDbTable::SetCol(const int Colno, const wxVariant val) {
+	//FIXME: Add proper wxDateTime support to wxVariant..
+	wxDateTime dateval;
+
+	SetColNull(Colno, val.IsNull() );
+
+	if (! val.IsNull()) {
+	
+     if (   (colDefs[Colno].SqlCtype == SQL_C_DATE) 
+	//     || (colDefs[Colno].SqlCtype == SQL_C_TIME)
+     //    || (colDefs[Colno].SqlCtype == SQL_C_TIMESTAMP)
+	    ) {
+					//Returns null if invalid!
+			if ( ! dateval.ParseDate(val.GetString()) ) {
+				SetColNull(Colno,true);
+			}
+
+	}				
+
+
+
+		switch (colDefs[Colno].SqlCtype) {
+			case SQL_CHAR:
+			case SQL_VARCHAR:
+				csstrncpyt((char *)(colDefs[Colno].PtrDataObj), val.GetString().c_str(), 
+												colDefs[Colno].SzDataObj-1);
+			break;
+			case SQL_C_LONG:
+			case SQL_C_SLONG:
+				*(long *)(colDefs[Colno].PtrDataObj) = val;
+			break;
+			case SQL_C_SHORT:
+			case SQL_C_SSHORT:
+				 *(short *)(colDefs[Colno].PtrDataObj) =  val.GetLong();
+			break;
+			case SQL_C_ULONG:
+				*(unsigned long *)(colDefs[Colno].PtrDataObj) = val.GetLong();
+			break;
+			case SQL_C_UTINYINT:
+			case SQL_C_USHORT:
+				*(unsigned short *)(colDefs[Colno].PtrDataObj) = val.GetLong();
+			break;
+		//FIXME: Add proper wxDateTime support to wxVariant..
+			case SQL_C_DATE: {
+					DATE_STRUCT * dataptr = (DATE_STRUCT *)colDefs[Colno].PtrDataObj;
+				
+					dataptr->year= dateval.GetYear();
+					dataptr->month= dateval.GetMonth()+1;
+					dataptr->day= dateval.GetDay();
+			}
+			break;
+/*			case SQL_C_TIME:{
+					TIME_STRUCT * dataptr = (TIME_STRUCT *)colDefs[Colno].PtrDataObj;
+				
+					dataptr->hour= dateval.GetHour();
+					dataptr->minute= dateval.GetMinute();
+					dataptr->second= dateval.GetSecond();
+			}
+			break;
+			case SQL_C_TIMESTAMP: {
+					TIMESTAMP_STRUCT * dataptr = (TIMESTAMP_STRUCT *)colDefs[Colno].PtrDataObj;
+					dataptr->year= dateval.GetYear();
+					dataptr->month= dateval.GetMonth()+1;
+					dataptr->day= dateval.GetDay();
+				
+					dataptr->hour= dateval.GetHour();
+					dataptr->minute= dateval.GetMinute();
+					dataptr->second= dateval.GetSecond();
+			}
+			break;
+*/			case SQL_C_DOUBLE:
+				*(double *)(colDefs[Colno].PtrDataObj) = val;
+		
+			break;
+			
+		}
+	}
+}
+
+GenericKey wxDbTable::GetKey() {
+	
+	void * blk;
+	char * blkptr;
+	
+	blk = malloc(m_keysz);
+	blkptr = (char *) blk;
+	
+	for (int i=0; i< noCols; i++) {
+		if (colDefs[i].KeyField) {
+			memcpy(blkptr,colDefs[i].PtrDataObj,colDefs[i].SzDataObj);
+			blkptr+=colDefs[i].SzDataObj;
+		}
+	}
+	return GenericKey(blk,m_keysz);
+}
+
+
+void wxDbTable::SetKey(const GenericKey& k) {
+	void * blk;
+	char * blkptr;
+	
+	blk = k.GetBlk();
+	blkptr = (char* )blk;
+	
+	for (int i=0; i < noCols; i++) {
+		if (colDefs[i].KeyField) {
+			SetColNull(i,false);
+			memcpy(colDefs[i].PtrDataObj,blkptr,colDefs[i].SzDataObj);
+			blkptr+=colDefs[i].SzDataObj;
+		}
+	}
+}
+
+
 
 #endif  // wxUSE_ODBC
diff -rbu2 --exclude=CVS --exclude=GTK --exclude=MSW --exclude=tiff --exclude=UNIV --exclude=notebook.* --exclude=files.lst --new-file ../wxWindows/src/common/variant.cpp ./src/common/variant.cpp
--- ../wxWindows/src/common/variant.cpp	Wed Apr 11 15:57:46 2001
+++ ./src/common/variant.cpp	Thu May 31 19:52:37 2001
@@ -1077,4 +1077,97 @@
 }
 
+/*
+ * wxVariantDataDateTime
+ */
+
+class wxVariantDataDateTime: public wxVariantData
+{
+ DECLARE_DYNAMIC_CLASS(wxVariantDataDateTime)
+public:
+    wxVariantDataDateTime() { }
+    wxVariantDataDateTime(const wxDateTime& value) { m_value = value; }
+#if wxUSE_ODBC
+   wxVariantDataDateTime(const TIME_STRUCT* valptr) { m_value = wxDateTime(
+       valptr->hour, valptr->minute, valptr->second);
+    }
+    wxVariantDataDateTime(const DATE_STRUCT* valptr) { m_value = wxDateTime(
+        valptr->day, (wxDateTime::Month) (valptr->month - 1),valptr->year);
+    }
+    wxVariantDataDateTime(const TIMESTAMP_STRUCT* valptr) { m_value = wxDateTime(
+        valptr->day, (wxDateTime::Month) (valptr->month - 1), valptr->year,
+        valptr->hour, valptr->minute, valptr->second, valptr->fraction );
+    }
+#endif //ODBC
+
+
+    inline wxDateTime GetValue() const { return m_value; }
+    inline void SetValue(const wxDateTime& value) { m_value = value; }
+
+    virtual void Copy(wxVariantData& data);
+    virtual bool Eq(wxVariantData& data) const;
+#if wxUSE_STD_IOSTREAM
+    virtual bool Write(ostream& str) const;
+#endif
+    virtual bool Write(wxString& str) const;
+#if wxUSE_STD_IOSTREAM
+    virtual bool Read(istream& str);
+#endif
+    virtual bool Read(wxString& str);
+    virtual wxString GetType() const { return wxT("datetime"); };
+    virtual wxVariantData* Clone() { return new wxVariantDataDateTime; }
+
+protected:
+    wxDateTime m_value;
+};
+
+IMPLEMENT_DYNAMIC_CLASS(wxVariantDataDateTime, wxVariantData)
+
+void wxVariantDataDateTime::Copy(wxVariantData& data)
+{
+    wxASSERT_MSG( (data.GetType() == wxT("datetime")), wxT("wxVariantDataDateTime::Copy: Can't copy to this type of data") );
+
+    wxVariantDataDateTime& otherData = (wxVariantDataDateTime&) data;
+
+    otherData.m_value = m_value;
+}
+
+bool wxVariantDataDateTime::Eq(wxVariantData& data) const
+{
+    wxASSERT_MSG( (data.GetType() == wxT("datetime")), wxT("wxVariantDataDateTime::Eq: argument mismatch") );
+
+    wxVariantDataDateTime& otherData = (wxVariantDataDateTime&) data;
+
+    return (otherData.m_value == m_value);
+}
+
+#if wxUSE_STD_IOSTREAM
+bool wxVariantDataDateTime::Write(ostream& str) const
+{
+    // Not implemented
+    return FALSE;
+}
+#endif
+
+bool wxVariantDataDateTime::Write(wxString& str) const
+{
+    str = m_value.Format();
+    return TRUE;
+}
+
+#if wxUSE_STD_IOSTREAM
+bool wxVariantDataDateTime::Read(istream& WXUNUSED(str))
+{
+    // Not implemented
+    return FALSE;
+}
+#endif
+
+bool wxVariantDataDateTime::Read(wxString& str)
+{
+    if(! m_value.ParseDateTime(str))
+        return FALSE;
+    return TRUE;
+}
+
 
 /*
@@ -1161,4 +1254,29 @@
 }
 
+wxVariant::wxVariant(const wxDateTime& val, const wxString& name) // Date
+{
+    m_data = new wxVariantDataDateTime(val);
+    m_name = name;
+}
+
+wxVariant::wxVariant(const TIME_STRUCT* valptr, const wxString& name) // Date
+{
+    m_data = new wxVariantDataDateTime(valptr);
+    m_name = name;
+}
+
+wxVariant::wxVariant(const TIMESTAMP_STRUCT* valptr, const wxString& name) // Date
+{
+    m_data = new wxVariantDataDateTime(valptr);
+    m_name = name;
+}
+
+wxVariant::wxVariant(const DATE_STRUCT* valptr, const wxString& name) // Date
+{
+    m_data = new wxVariantDataDateTime(valptr);
+    m_name = name;
+}
+
+
 wxVariant::wxVariant(const wxVariant& variant)
 {
@@ -1528,4 +1646,58 @@
 }
 
+bool wxVariant::operator== (const wxDateTime& value) const
+{
+    wxDateTime thisValue;
+    if (!Convert(&thisValue))
+        return FALSE;
+
+    return value.IsEqualTo(thisValue);
+}
+
+bool wxVariant::operator!= (const wxDateTime& value) const
+{
+    return (!((*this) == value));
+}
+
+void wxVariant::operator= (const wxDateTime& value)
+{
+    if (GetType() == wxT("datetime"))
+    {
+        ((wxVariantDataDateTime*)GetData())->SetValue(value);
+    }
+    else
+    {
+        if (m_data)
+            delete m_data;
+        m_data = new wxVariantDataDateTime(value);
+    }
+}
+
+
+void wxVariant::operator= (const DATE_STRUCT* value)
+{
+    if (m_data)
+        delete m_data;
+    m_data = new wxVariantDataDateTime(value);
+}
+
+
+void wxVariant::operator= (const TIME_STRUCT* value)
+{
+    if (m_data)
+        delete m_data;
+    m_data = new wxVariantDataDateTime(value);
+}
+
+
+void wxVariant::operator= (const TIMESTAMP_STRUCT* value)
+{
+    if (m_data)
+        delete m_data;
+    m_data = new wxVariantDataDateTime(value);
+}
+
+
+
 // Treat a list variant as an array
 wxVariant wxVariant::operator[] (size_t idx) const
@@ -1710,4 +1882,15 @@
 }
 
+wxDateTime wxVariant::GetDateTime() const
+{
+    wxDateTime value;
+    if (!Convert(& value))
+    {
+        wxFAIL_MSG(wxT("Could not convert to a datetime"));
+    }
+
+    return value;
+}
+
 wxList& wxVariant::GetList() const
 {
@@ -1902,5 +2085,15 @@
     return TRUE;
 }
-#endif
- // wxUSE_TIMEDATE
+#endif  // wxUSE_TIMEDATE
+
+bool wxVariant::Convert(wxDateTime* value) const
+{
+    wxString type(GetType());
+    if (type == wxT("datetime"))
+        *value = ((wxVariantDataDateTime*)GetData())->GetValue();
+    else
+        return FALSE;
+
+    return TRUE;
+}
 
diff -rbu2 --exclude=CVS --exclude=GTK --exclude=MSW --exclude=tiff --exclude=UNIV --exclude=notebook.* --exclude=files.lst --new-file ../wxWindows/src/generic/dbgrid.cpp ./src/generic/dbgrid.cpp
--- ../wxWindows/src/generic/dbgrid.cpp	Thu Jan  1 01:00:00 1970
+++ ./src/generic/dbgrid.cpp	Fri Jun  1 10:55:29 2001
@@ -0,0 +1,713 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        dbgrid.cpp
+// Purpose:     Displays a wxDbTable in a wxGrid.
+// Author:      Roger Gammans, Paul Gammans
+// Modified by: 
+// Created:     
+// RCS-ID:      $Id:$
+// Copyright:   (c) 1999 The Computer Surgery (roger@computer-surgery.co.uk)
+// Licence:     wxWindows licence
+///////////////////////////////////////////////////////////////////////////////
+// Branched From : dbgrid.cpp,v 1.18 2000/12/19 13:00:58
+///////////////////////////////////////////////////////////////////////////////
+
+#ifdef __GNUG__
+    #pragma implementation "dbgrid.h"
+#endif
+
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#ifndef WX_PRECOMP
+    #include "wx/textctrl.h"
+    #include "wx/dc.h"
+#endif // WX_PRECOMP
+
+#include "wx/generic/gridctrl.h"
+#include "wx/dbgrid.h"
+
+wxDbGridCellAttrProvider::wxDbGridCellAttrProvider()
+{
+    m_data=NULL;
+    m_ColInfo=NULL;
+}
+
+wxDbGridCellAttrProvider::wxDbGridCellAttrProvider(wxDbTable *tab, wxdbGridColInfoBase* ColInfo)
+{
+    m_data=tab;
+    m_ColInfo=ColInfo;
+}
+
+wxDbGridCellAttrProvider::~wxDbGridCellAttrProvider()
+{
+}
+
+wxGridCellAttr *wxDbGridCellAttrProvider::GetAttr(int row, int col,
+                                      wxGridCellAttr::wxAttrKind  kind ) const
+{
+    wxGridCellAttr *attr = wxGridCellAttrProvider::GetAttr(row,col,kind);
+
+    if (m_data && m_ColInfo && (m_data->GetNumberOfColumns() > m_ColInfo[col].DbCol))
+    {
+        //FIXME: this test could.
+        //  ??::InsertPending == m_data->get_ModifiedStatus()
+        //  and if InsertPending use colDef[].InsertAllowed
+        if(!(m_data->GetColDefs()[(m_ColInfo[col].DbCol)].Updateable))
+        {
+            switch(kind)
+            {
+                case (wxGridCellAttr::Any):
+                    if(!attr)
+                    {
+                        attr = new wxGridCellAttr;
+                        // Store so we don't keep creating / deleting this...
+                        wxDbGridCellAttrProvider * self = wxConstCast(this, wxDbGridCellAttrProvider ) ;
+                        attr->IncRef();
+                        self->SetColAttr(attr, col);
+                        attr->SetReadOnly();
+                    }
+                    else
+                    {
+                        //We now must check what we were returned. and do the right thing (tm)
+                        wxGridCellAttr::wxAttrKind attrkind = attr->GetKind();
+                        if( (attrkind == (wxGridCellAttr::Default)) || (attrkind == (wxGridCellAttr::Cell)) ||
+                            (attrkind == (wxGridCellAttr::Col)))
+                        {
+                                wxGridCellAttr *attrtomerge = attr;
+                                attr = new wxGridCellAttr;
+                                attr->SetKind(wxGridCellAttr::Merged);
+                                attr->MergeWith(attrtomerge);
+                                attr->SetReadOnly();
+                                attrtomerge->DecRef();
+                        }
+                        attr->SetReadOnly();
+                    }
+                break;
+                case (wxGridCellAttr::Col):
+                    //As we must have a Coll, and were setting Coll attributes
+                    // we can based on wxdbTable's so just set RO if attr valid
+                    if(!attr)
+                    {
+                        attr = new wxGridCellAttr;
+                        wxDbGridCellAttrProvider * self = wxConstCast(this, wxDbGridCellAttrProvider ) ;
+                        attr->IncRef();
+                        self->SetColAttr(attr, col);
+                    }
+                    attr->SetReadOnly();
+                break;
+                default:
+                    //Dont add RO for...
+                    //  wxGridCellAttr::Cell - Not required, will inherit on merge from row.
+                    //  wxGridCellAttr::Row - If wxDbtable ever supports row locking could add
+                    //                        support to make RO on a row basis also.
+                    //  wxGridCellAttr::Default - Don't edit this ! or all cell with a attr will become readonly
+                    //  wxGridCellAttr::Merged - This should never be asked for.
+                break;
+            }
+        }
+        
+    }
+    return attr;
+}
+
+void wxDbGridCellAttrProvider::AssignDbTable(wxDbTable *tab)
+{
+    m_data=tab;
+}
+
+wxDbGridTableBase::wxDbGridTableBase(wxDbTable *tab, wxdbGridColInfo*  ColInfo,
+                     int count, bool takeOwnership)  :
+    m_keys(), 
+    m_data(tab),
+    m_dbowner(takeOwnership),
+    m_rowmodified(false)
+{
+
+    if (count == wxUSE_QUERY )
+    {
+        m_rowtotal = m_data ? m_data->Count() : 0;
+    }
+    else
+    {
+        m_rowtotal  = count;
+    }
+//    m_keys.Size(m_rowtotal);
+    m_row =-1;
+    if (ColInfo)
+    {
+        m_nocols= ColInfo->Length();
+        m_ColInfo = new wxdbGridColInfoBase[m_nocols];
+        //Do Copy.
+        wxdbGridColInfo* ptr = ColInfo;
+        int i =0;
+        while(ptr && i < m_nocols )
+        {
+            m_ColInfo[i]=ptr->m_data;
+            ptr=ptr->m_next; i++;
+        }
+#ifdef __WXDEBUG__
+        if (ptr)
+        {
+            wxLogDebug("NoCols over length after traversing %i items",i);
+        }
+        if ( i < m_nocols)
+        {
+            wxLogDebug("NoCols under length after traversing %i items",i);
+        } 
+#endif
+    }
+}
+
+wxDbGridTableBase::~wxDbGridTableBase()
+{
+    wxDbGridCellAttrProvider *provider;
+
+    //Can't check for update here as 
+
+    //FIXME: should i remove m_ColInfo and m_data from m_attrProvider if a wxDbGridAttrProvider
+    if(( provider = dynamic_cast<wxDbGridCellAttrProvider *>( GetAttrProvider())))
+    {
+        provider->AssignDbTable(NULL);
+    }
+    delete [] m_ColInfo;
+    
+    Writeback();
+    if(m_dbowner)
+    {
+        delete m_data;
+    }
+}
+
+bool wxDbGridTableBase::CanHaveAttributes()
+{
+    if ( ! GetAttrProvider() )
+    {
+        // use the default attr provider by default
+        SetAttrProvider( new wxDbGridCellAttrProvider(m_data, m_ColInfo));
+    }
+    return TRUE;
+}
+
+
+bool wxDbGridTableBase::AssignDbTable(wxDbTable *tab, int count, bool takeOwnership)
+{
+    wxDbGridCellAttrProvider *provider;
+
+    //Remove Information from grid about old data
+    if ( GetView() )
+    {
+        wxGrid * grid = GetView();
+        grid->BeginBatch();
+        grid->ClearSelection();
+        if (grid->IsCellEditControlEnabled())
+        {
+            grid->DisableCellEditControl();
+        }
+        wxGridTableMessage msg( this, wxGRIDTABLE_NOTIFY_ROWS_DELETED,0,m_rowtotal);
+        grid->ProcessTableMessage( msg );
+    }
+
+    //reset our internals...
+    Writeback();
+    if(m_dbowner)
+    {
+        delete m_data;
+    }
+    m_keys.Empty();
+    m_data = tab;
+    //FIXME: Remove dynamic_cast before sumision to wxwin 
+    if(( provider = dynamic_cast<wxDbGridCellAttrProvider *> (GetAttrProvider())))
+    {
+        provider->AssignDbTable(m_data);
+    }
+    
+    if (count == wxUSE_QUERY )
+    {
+        m_rowtotal = m_data ? m_data->Count() : 0;
+    }
+    else
+    {
+         m_rowtotal  = count;
+    }
+    m_row =-1;
+
+    //Add Information to grid about new data
+    if ( GetView() )
+    {
+        wxGrid * grid = GetView();
+        wxGridTableMessage msg( this, wxGRIDTABLE_NOTIFY_ROWS_APPENDED, m_rowtotal );
+        grid->ProcessTableMessage( msg );
+        grid->EndBatch();
+    }
+    m_dbowner = takeOwnership;
+    m_rowmodified = false;
+    return true;
+}
+
+wxString wxDbGridTableBase::GetTypeName( int row, int col )
+{
+    if( GetNumberCols() > col)
+    {
+        if (m_ColInfo[col].wxtypename == wxGRID_VALUE_DBAUTO )
+        {
+            if (m_data->GetNumberOfColumns() <= m_ColInfo[col].DbCol)
+            {
+                wxFAIL_MSG (_T("You can not use wxGRID_VALUE_DBAUTO for virtual columns"));
+            }
+            switch(m_data->GetColDefs()[(m_ColInfo[col].DbCol)].SqlCtype)
+            {
+                case SQL_C_CHAR:
+                    return wxGRID_VALUE_STRING;
+                break;
+                case SQL_C_SSHORT:
+                    return wxGRID_VALUE_NUMBER;
+                break;
+                case SQL_C_USHORT:
+                    return wxGRID_VALUE_NUMBER;
+                break;
+                case SQL_C_SLONG:
+                    return wxGRID_VALUE_NUMBER;
+                break;
+                case SQL_C_ULONG:
+                    return wxGRID_VALUE_NUMBER;
+                break;
+                case SQL_C_FLOAT:
+                    return wxGRID_VALUE_FLOAT;
+                break;
+                case SQL_C_DOUBLE:
+                    return wxGRID_VALUE_FLOAT;
+                break;
+                case SQL_C_DATE:
+                    return wxGRID_VALUE_DATETIME;
+                break;
+                case SQL_C_TIME:
+                    return wxGRID_VALUE_DATETIME;
+                break;
+                case SQL_C_TIMESTAMP:
+                    return wxGRID_VALUE_DATETIME;
+                break;
+                default:
+                    return wxGRID_VALUE_STRING;
+                break;
+            }
+        }
+        else
+        {
+            return m_ColInfo[col].wxtypename;
+        }
+    }
+    wxFAIL_MSG (_T("unknown column"));
+    return wxString();
+}
+
+bool wxDbGridTableBase::CanGetValueAs( int row, int col, const wxString& typeName )
+{
+    wxLogDebug("CanGetValueAs() on %i,%i",row,col);
+    //Is this needed? As will be validated on GetValueAsXXXX
+    ValidateRow(row);
+
+    if( typeName == wxGRID_VALUE_STRING )
+    {
+        //FIXME ummm What about blob filed etc.
+        return TRUE;
+    }
+
+    if(m_data->IsColNull(m_ColInfo[col].DbCol))
+    {
+        return FALSE;
+    }
+
+    if (m_data->GetNumberOfColumns() <= m_ColInfo[col].DbCol)
+    {
+        //If a virtual column then we can't find it's type. we have to faulse to 
+        //get using wxVairent.
+        return FALSE;
+    }
+    int sqltype = m_data->GetColDefs()[(m_ColInfo[col].DbCol)].SqlCtype;
+    
+    if( typeName == wxGRID_VALUE_DATETIME )
+    {
+        if(    (sqltype == SQL_C_DATE) ||
+            (sqltype == SQL_C_TIME) || 
+            (sqltype == SQL_C_TIMESTAMP) )
+        {
+            return TRUE;
+        }
+        return FALSE;
+    }
+    if( typeName == wxGRID_VALUE_NUMBER )
+    {
+        if(    (sqltype == SQL_C_SSHORT) ||
+            (sqltype == SQL_C_USHORT) || 
+            (sqltype == SQL_C_SLONG) ||
+            (sqltype == SQL_C_ULONG) )
+        {
+            return TRUE;
+        }
+        return FALSE;
+    }
+    if( typeName == wxGRID_VALUE_FLOAT )
+    {
+        if(    (sqltype == SQL_C_SSHORT) ||
+            (sqltype == SQL_C_USHORT) || 
+            (sqltype == SQL_C_SLONG) ||
+            (sqltype == SQL_C_ULONG) ||
+            (sqltype == SQL_C_FLOAT) ||
+            (sqltype == SQL_C_DOUBLE) )
+        {
+            return TRUE;
+        }
+        return FALSE;
+    }
+    return FALSE;
+}
+
+bool wxDbGridTableBase::CanSetValueAs( int row, int col, const wxString& typeName )
+{
+    //Is this needed? As will be validated on SetValueAsXXXX
+    ValidateRow(row);
+
+    if(m_data->IsColNull(m_ColInfo[col].DbCol))
+    {
+        return FALSE;
+    }
+
+    if( typeName == wxGRID_VALUE_STRING )
+    {
+        //FIXME ummm What about blob filed etc.
+        return TRUE;
+    }
+
+    if(!(m_data->GetColDefs()[(m_ColInfo[col].DbCol)].Updateable))
+    {
+        return FALSE;
+    }
+
+    if (m_data->GetNumberOfColumns() <= m_ColInfo[col].DbCol)
+    {
+        //If a virtual column then we can't find it's type. we have to faulse to 
+        //get using wxVairent.
+        return FALSE;
+    }
+
+    int sqltype = m_data->GetColDefs()[(m_ColInfo[col].DbCol)].SqlCtype;
+    if( typeName == wxGRID_VALUE_DATETIME )
+    {
+        if(    (sqltype == SQL_C_DATE) ||
+            (sqltype == SQL_C_TIME) || 
+            (sqltype == SQL_C_TIMESTAMP) )
+        {
+            return TRUE;
+        }
+        return FALSE;
+    }
+    if( typeName == wxGRID_VALUE_NUMBER )
+    {
+        if(    (sqltype == SQL_C_SSHORT) ||
+            (sqltype == SQL_C_USHORT) || 
+            (sqltype == SQL_C_SLONG) ||
+            (sqltype == SQL_C_ULONG) )
+        {
+            return TRUE;
+        }
+        return FALSE;
+    }
+    if( typeName == wxGRID_VALUE_FLOAT )
+    {
+        if(    (sqltype == SQL_C_SSHORT) ||
+            (sqltype == SQL_C_USHORT) || 
+            (sqltype == SQL_C_SLONG) ||
+            (sqltype == SQL_C_ULONG) ||
+            (sqltype == SQL_C_FLOAT) ||
+            (sqltype == SQL_C_DOUBLE) )
+        {
+            return TRUE;
+        }
+        return FALSE;
+    }
+    return FALSE;
+}
+
+long wxDbGridTableBase::GetValueAsLong( int row, int col )
+{
+    ValidateRow(row);
+
+    if (m_data->GetNumberOfColumns() <= m_ColInfo[col].DbCol)
+    {
+        wxFAIL_MSG (_T("You can not use GetValueAsLong for virtual columns"));
+        return 0;
+    }
+    int sqltype = m_data->GetColDefs()[(m_ColInfo[col].DbCol)].SqlCtype;
+    if(    (sqltype == SQL_C_SSHORT) ||
+        (sqltype == SQL_C_USHORT) || 
+        (sqltype == SQL_C_SLONG) ||
+        (sqltype == SQL_C_ULONG) )
+    {
+        wxVariant val = m_data->GetCol(m_ColInfo[col].DbCol);
+        return val.GetLong();
+    }
+    wxFAIL_MSG (_T("unknown column, "));
+    return 0;
+}
+
+double wxDbGridTableBase::GetValueAsDouble( int row, int col )
+{
+    wxLogDebug("GetValueAsDouble() on %i,%i",row,col);
+    ValidateRow(row);
+
+    if (m_data->GetNumberOfColumns() <= m_ColInfo[col].DbCol)
+    {
+        wxFAIL_MSG (_T("You can not use GetValueAsDouble for virtual columns"));
+        return 0.0;
+    }
+    int sqltype = m_data->GetColDefs()[(m_ColInfo[col].DbCol)].SqlCtype;
+    if(    (sqltype == SQL_C_SSHORT) ||
+        (sqltype == SQL_C_USHORT) || 
+        (sqltype == SQL_C_SLONG) ||
+        (sqltype == SQL_C_ULONG) ||
+        (sqltype == SQL_C_FLOAT) ||
+        (sqltype == SQL_C_DOUBLE) )
+    {
+        wxVariant val = m_data->GetCol(m_ColInfo[col].DbCol);
+        return val.GetDouble();
+    }
+    wxFAIL_MSG (_T("unknown column"));
+    return 0.0;
+}
+
+bool wxDbGridTableBase::GetValueAsBool( int row, int col )
+{
+    wxLogDebug("GetValueAsBool() on %i,%i",row,col);
+    ValidateRow(row);
+
+    if (m_data->GetNumberOfColumns() <= m_ColInfo[col].DbCol)
+    {
+        wxFAIL_MSG (_T("You can not use GetValueAsBool for virtual columns"));
+        return 0;
+    }
+    int sqltype = m_data->GetColDefs()[(m_ColInfo[col].DbCol)].SqlCtype;
+    if(    (sqltype == SQL_C_SSHORT) ||
+        (sqltype == SQL_C_USHORT) || 
+        (sqltype == SQL_C_SLONG) ||
+        (sqltype == SQL_C_ULONG) )
+    {
+        wxVariant val = m_data->GetCol(m_ColInfo[col].DbCol);
+        return val.GetBool();
+    }
+    wxFAIL_MSG (_T("unknown column, "));
+    return 0;
+}
+
+void* wxDbGridTableBase::GetValueAsCustom( int row, int col, const wxString& typeName )
+{
+    wxLogDebug("GetValueAsCustom() on %i,%i",row,col);
+    ValidateRow(row);
+    
+    if (m_data->GetNumberOfColumns() <= m_ColInfo[col].DbCol)
+    {
+        wxFAIL_MSG (_T("You can not use GetValueAsCustom for virtual columns"));
+        return NULL;
+    }
+    if (m_data->IsColNull(m_ColInfo[col].DbCol)) return NULL;
+
+    if( typeName == wxGRID_VALUE_DATETIME )
+    {
+        int sqltype = m_data->GetColDefs()[(m_ColInfo[col].DbCol)].SqlCtype;
+        if( (sqltype == SQL_C_DATE) ||
+            (sqltype == SQL_C_TIME) ||
+            (sqltype == SQL_C_TIMESTAMP))
+        {
+            wxVariant val = m_data->GetCol(m_ColInfo[col].DbCol);
+            return new wxDateTime ( val.GetDateTime() );
+        }
+    }
+    wxFAIL_MSG (_T("unknown column data type "));
+    return NULL;
+}
+
+
+void wxDbGridTableBase::SetValueAsCustom( int row, int col, const wxString& typeName, void* value)
+{
+    wxLogDebug("SetValueAsCustom() on %i,%i",row,col);
+    ValidateRow(row);
+
+    if (m_data->GetNumberOfColumns() <= m_ColInfo[col].DbCol)
+    {
+        wxFAIL_MSG (_T("You can not use SetValueAsCustom for virtual columns"));
+        return;
+    }
+
+    if( typeName == wxGRID_VALUE_DATETIME )
+    {
+        int sqltype = m_data->GetColDefs()[(m_ColInfo[col].DbCol)].SqlCtype;
+        if( (sqltype == SQL_C_DATE) ||
+            (sqltype == SQL_C_TIME) ||
+            (sqltype == SQL_C_TIMESTAMP))
+        {
+            //FIXME: you can't dynamic_cast from (void *)
+            //wxDateTime *date = wxDynamicCast(value, wxDateTime);
+            wxDateTime *date = (wxDateTime *)value;
+            if (! date )
+            {
+                wxFAIL_MSG (_T("Failed to convert data"));
+                return;
+            }
+            wxVariant val(date);
+            m_rowmodified=true;
+            m_data->SetCol(m_ColInfo[col].DbCol,val);
+        }
+    }
+    wxFAIL_MSG (_T("unknown column data type"));
+    return ;
+}
+
+wxString wxDbGridTableBase::GetColLabelValue( int col )
+{
+    if( GetNumberCols() > col)
+    {
+        return m_ColInfo[col].Title;
+    }
+    wxFAIL_MSG (_T("unknown column"));
+    return wxString();
+}
+
+bool wxDbGridTableBase::IsEmptyCell( int row, int col )
+{
+    wxLogDebug("IsEmtpyCell on %i,%i",row,col);
+
+    ValidateRow(row);
+    return m_data->IsColNull(m_ColInfo[col].DbCol);
+}
+
+
+wxString wxDbGridTableBase::GetValue( int row, int col )
+{
+    wxLogDebug("GetValue() on %i,%i",row,col);
+    
+    ValidateRow(row);
+    wxVariant val = m_data->GetCol(m_ColInfo[col].DbCol);
+    wxLogDebug("\tReturning \"%s\"\n",val.GetString().c_str());
+    
+    return val.GetString(); 
+}
+
+
+void wxDbGridTableBase::SetValue( int row, int col,const wxString& value )
+{
+    wxLogDebug("SetValue() on %i,%i",row,col);
+
+    ValidateRow(row);
+    wxVariant val(value);
+
+    m_rowmodified=true;
+    m_data->SetCol(m_ColInfo[col].DbCol,val);
+}
+
+void wxDbGridTableBase::SetValueAsLong( int row, int col, long value )
+{
+    wxLogDebug("SetValueAsLong() on %i,%i",row,col);
+
+    ValidateRow(row);
+    wxVariant val(value);
+
+    m_rowmodified=true;
+    m_data->SetCol(m_ColInfo[col].DbCol,val);
+}
+
+void wxDbGridTableBase::SetValueAsDouble( int row, int col, double value )
+{
+    wxLogDebug("SetValueAsDouble() on %i,%i",row,col);
+
+    ValidateRow(row);
+    wxVariant val(value);
+
+    m_rowmodified=true;
+    m_data->SetCol(m_ColInfo[col].DbCol,val);
+
+}
+
+void wxDbGridTableBase::SetValueAsBool( int row, int col, bool value )
+{
+    wxLogDebug("SetValueAsBool() on %i,%i",row,col);
+
+    ValidateRow(row);
+    wxVariant val(value);
+
+    m_rowmodified=true;
+    m_data->SetCol(m_ColInfo[col].DbCol,val);
+}
+
+void wxDbGridTableBase::ValidateRow(int row)
+{
+    wxLogDebug("VaidateRow(%i) currently on %i - array len = %i",row,m_row,m_keys.GetCount());
+
+    if (row == m_row ) return;
+    Writeback();
+
+    //We add to row as Count is unsigned! ).
+    if ( (row+1) > m_keys.GetCount()  )
+    {
+        wxLogDebug("\trow key unknown");
+        // Extend Array , iterate through data filling with keys
+        m_data->setRowMode(wxDbTable::WX_ROW_MODE_QUERY);
+        for (int trow = m_keys.GetCount() ; trow <= row ; trow++ )
+        {
+            wxLogDebug("Fetching row %i..", trow);
+            bool ret= m_data->GetNext();
+            wxLogDebug(" ...success=(%i)",ret);
+            GenericKey k = m_data->GetKey();
+            m_keys.Add(k);
+        }
+        m_row = row;
+    }
+    else
+    {
+        wxLogDebug("\trow key known centring data");
+        GenericKey k = m_keys.Item(row);
+        m_data->setRowMode(wxDbTable::WX_ROW_MODE_INDIVIDUAL);
+        m_data->ClearMemberVars();    
+        m_data->SetKey(k);
+        m_data->QueryOnKeyFields();
+        m_data->GetNext();
+        m_row =row;
+    }
+    m_rowmodified=false;
+}
+
+bool wxDbGridTableBase::Writeback() const
+{
+    if (!m_rowmodified)
+    {
+        return true;
+    }
+
+    bool result=true;
+    wxLogDebug("\trow key unknown");
+
+// FIXME: this code requires  dbtable support for record status 
+#if 0
+    switch (m_data->get_ModifiedStatus())
+    {
+        case wxDbTable::UpdatePending:
+            result = m_data->Update();
+           break;
+        case wxDbTable::InsertPending:
+            result = (m_data->Insert() == SQL_SUCCESS);
+        break;
+        default:
+            //Nothing
+        break;
+    }
+#else
+    wxLogDebug("WARNING : Row writeback not implemented ");
+#endif
+    return result;
+}
+
+#include <wx/arrimpl.cpp>
+
+WX_DEFINE_OBJARRAY(keyarray);
+

 	  	 
