Index: src/stc/scintilla/include/Platform.h
===================================================================
--- src/stc/scintilla/include/Platform.h	(revision 76307)
+++ src/stc/scintilla/include/Platform.h	(working copy)
@@ -444,6 +444,16 @@
 	static DynamicLibrary *Load(const char *modulePath);
 };
 
+#if defined(__clang__)
+# if __has_feature(attribute_analyzer_noreturn)
+#  define CLANG_ANALYZER_NORETURN __attribute__((analyzer_noreturn))
+# else
+#  define CLANG_ANALYZER_NORETURN
+# endif
+#else
+# define CLANG_ANALYZER_NORETURN
+#endif
+
 /**
  * Platform class used to retrieve system wide parameters such as double click speed
  * and chrome colour. Not a creatable object, more of a module with several functions.
@@ -488,7 +498,7 @@
 	}
 	static void DebugPrintf(const char *format, ...);
 	static bool ShowAssertionPopUps(bool assertionPopUps_);
-	static void Assert(const char *c, const char *file, int line);
+	static void Assert(const char *c, const char *file, int line) CLANG_ANALYZER_NORETURN;
 	static int Clamp(int val, int minVal, int maxVal);
 };
 
Index: src/stc/scintilla/include/SciLexer.h
===================================================================
--- src/stc/scintilla/include/SciLexer.h	(revision 76307)
+++ src/stc/scintilla/include/SciLexer.h	(working copy)
@@ -125,6 +125,7 @@
 #define SCLEX_KVIRC 110
 #define SCLEX_RUST 111
 #define SCLEX_DMAP 112
+#define SCLEX_AS 113
 #define SCLEX_AUTOMATIC 1000
 #define SCE_P_DEFAULT 0
 #define SCE_P_COMMENTLINE 1
Index: src/stc/scintilla/include/Scintilla.h
===================================================================
--- src/stc/scintilla/include/Scintilla.h	(revision 76307)
+++ src/stc/scintilla/include/Scintilla.h	(working copy)
@@ -475,6 +475,7 @@
 #define SC_WRAP_NONE 0
 #define SC_WRAP_WORD 1
 #define SC_WRAP_CHAR 2
+#define SC_WRAP_WHITESPACE 3
 #define SCI_SETWRAPMODE 2268
 #define SCI_GETWRAPMODE 2269
 #define SC_WRAPVISUALFLAG_NONE 0x0000
@@ -883,6 +884,11 @@
 #define SCI_VCHOMEDISPLAYEXTEND 2653
 #define SCI_GETCARETLINEVISIBLEALWAYS 2654
 #define SCI_SETCARETLINEVISIBLEALWAYS 2655
+#define SC_LINE_END_TYPE_DEFAULT 0
+#define SC_LINE_END_TYPE_UNICODE 1
+#define SCI_SETLINEENDTYPESALLOWED 2656
+#define SCI_GETLINEENDTYPESALLOWED 2657
+#define SCI_GETLINEENDTYPESACTIVE 2658
 #define SCI_SETREPRESENTATION 2665
 #define SCI_GETREPRESENTATION 2666
 #define SCI_CLEARREPRESENTATION 2667
@@ -909,6 +915,16 @@
 #define SCI_PROPERTYTYPE 4015
 #define SCI_DESCRIBEPROPERTY 4016
 #define SCI_DESCRIBEKEYWORDSETS 4017
+#define SCI_GETLINEENDTYPESSUPPORTED 4018
+#define SCI_ALLOCATESUBSTYLES 4020
+#define SCI_GETSUBSTYLESSTART 4021
+#define SCI_GETSUBSTYLESLENGTH 4022
+#define SCI_GETSTYLEFROMSUBSTYLE 4027
+#define SCI_GETPRIMARYSTYLEFROMSTYLE 4028
+#define SCI_FREESUBSTYLES 4023
+#define SCI_SETIDENTIFIERS 4024
+#define SCI_DISTANCETOSECONDARYSTYLES 4025
+#define SCI_GETSUBSTYLEBASES 4026
 #define SC_MOD_INSERTTEXT 0x1
 #define SC_MOD_DELETETEXT 0x2
 #define SC_MOD_CHANGESTYLE 0x4
@@ -992,23 +1008,6 @@
 #define SCN_HOTSPOTRELEASECLICK 2027
 #define SCN_FOCUSIN 2028
 #define SCN_FOCUSOUT 2029
-#ifndef SCI_DISABLE_PROVISIONAL
-#define SC_LINE_END_TYPE_DEFAULT 0
-#define SC_LINE_END_TYPE_UNICODE 1
-#define SCI_SETLINEENDTYPESALLOWED 2656
-#define SCI_GETLINEENDTYPESALLOWED 2657
-#define SCI_GETLINEENDTYPESACTIVE 2658
-#define SCI_GETLINEENDTYPESSUPPORTED 4018
-#define SCI_ALLOCATESUBSTYLES 4020
-#define SCI_GETSUBSTYLESSTART 4021
-#define SCI_GETSUBSTYLESLENGTH 4022
-#define SCI_GETSTYLEFROMSUBSTYLE 4027
-#define SCI_GETPRIMARYSTYLEFROMSTYLE 4028
-#define SCI_FREESUBSTYLES 4023
-#define SCI_SETIDENTIFIERS 4024
-#define SCI_DISTANCETOSECONDARYSTYLES 4025
-#define SCI_GETSUBSTYLEBASES 4026
-#endif
 /* --Autogenerated -- end of section automatically generated from Scintilla.iface */
 
 /* These structures are defined to be exactly the same shape as the Win32
Index: src/stc/scintilla/include/Scintilla.iface
===================================================================
--- src/stc/scintilla/include/Scintilla.iface	(revision 76307)
+++ src/stc/scintilla/include/Scintilla.iface	(working copy)
@@ -468,7 +468,7 @@
 # Get is a style mixed case, or to force upper or lower case.
 get int StyleGetCase=2489(int style,)
 
-# Get the character set of the font in a style.
+# Get the character get of the font in a style.
 get int StyleGetCharacterSet=2490(int style,)
 
 # Get is a style visible or not.
@@ -1189,6 +1189,7 @@
 val SC_WRAP_NONE=0
 val SC_WRAP_WORD=1
 val SC_WRAP_CHAR=2
+val SC_WRAP_WHITESPACE=3
 
 # Sets whether text is word wrapped.
 set void SetWrapMode=2268(int mode,)
@@ -1286,7 +1287,7 @@
 # Append a string to the end of the document without changing the selection.
 fun void AppendText=2282(int length, string text)
 
-# Is drawing done in two phases with backgrounds drawn before foregrounds?
+# Is drawing done in two phases with backgrounds drawn before faoregrounds?
 get bool GetTwoPhaseDraw=2283(,)
 
 # In twoPhaseDraw mode, drawing is performed in two phases, first the background
@@ -2343,10 +2344,26 @@
 # Sets the caret line to always visible.
 set void SetCaretLineVisibleAlways=2655(bool alwaysVisible,)
 
+# Line end types which may be used in addition to LF, CR, and CRLF
+# SC_LINE_END_TYPE_UNICODE includes U+2028 Line Separator,
+# U+2029 Paragraph Separator, and U+0085 Next Line
+enu LineEndType=SC_LINE_END_TYPE_
+val SC_LINE_END_TYPE_DEFAULT=0
+val SC_LINE_END_TYPE_UNICODE=1
+
+# Set the line end types that the application wants to use. May not be used if incompatible with lexer or encoding.
+set void SetLineEndTypesAllowed=2656(int lineEndBitSet,)
+
+# Get the line end types currently allowed.
+get int GetLineEndTypesAllowed=2657(,)
+
+# Get the line end types currently recognised. May be a subset of the allowed types due to lexer limitation.
+get int GetLineEndTypesActive=2658(,)
+
 # Set the way a character is drawn.
 set void SetRepresentation=2665(string encodedCharacter, string representation)
 
-# Get the way a character is drawn.
+# Set the way a character is drawn.
 get int GetRepresentation=2666(string encodedCharacter, stringresult representation)
 
 # Remove a character representation.
@@ -2420,6 +2437,38 @@
 # Retrieve a '\n' separated list of descriptions of the keyword sets understood by the current lexer.
 fun int DescribeKeyWordSets=4017(, stringresult descriptions)
 
+# Bit set of LineEndType enumertion for which line ends beyond the standard
+# LF, CR, and CRLF are supported by the lexer.
+get int GetLineEndTypesSupported=4018(,)
+
+# Allocate a set of sub styles for a particular base style, returning start of range
+fun int AllocateSubStyles=4020(int styleBase, int numberStyles)
+
+# The starting style number for the sub styles associated with a base style
+get int GetSubStylesStart=4021(int styleBase,)
+
+# The number of sub styles associated with a base style
+get int GetSubStylesLength=4022(int styleBase,)
+
+# For a sub style, return the base style, else return the argument.
+get int GetStyleFromSubStyle=4027(int subStyle,)
+
+# For a secondary style, return the primary style, else return the argument.
+get int GetPrimaryStyleFromStyle=4028(int style,)
+
+# Free allocated sub styles
+fun void FreeSubStyles=4023(,)
+
+# Set the identifiers that are shown in a particular style
+set void SetIdentifiers=4024(int style, string identifiers)
+
+# Where styles are duplicated by a feature such as active/inactive code
+# return the distance between the two types.
+get int DistanceToSecondaryStyles=4025(,)
+
+# Get the set of base styles that can be extended with sub styles
+get int GetSubStyleBases=4026(, stringresult styles)
+
 # Notifications
 # Type of modification and the action which caused the modification.
 # These are defined as a bit mask to make it easy to specify which notifications are wanted.
@@ -2609,6 +2658,7 @@
 val SCLEX_KVIRC=110
 val SCLEX_RUST=111
 val SCLEX_DMAP=112
+val SCLEX_AS=113
 
 # When a lexer specifies its language as SCLEX_AUTOMATIC it receives a
 # value assigned in sequence from SCLEX_AUTOMATIC+1.
@@ -3198,8 +3248,9 @@
 val SCE_SCRIPTOL_TRIPLE=13
 val SCE_SCRIPTOL_CLASSNAME=14
 val SCE_SCRIPTOL_PREPROCESSOR=15
-# Lexical states for SCLEX_ASM
+# Lexical states for SCLEX_ASM, SCLEX_AS
 lex Asm=SCLEX_ASM SCE_ASM_
+lex As=SCLEX_AS SCE_ASM_
 val SCE_ASM_DEFAULT=0
 val SCE_ASM_COMMENT=1
 val SCE_ASM_NUMBER=2
@@ -4421,56 +4472,10 @@
 evt void FocusIn=2028(void)
 evt void FocusOut=2029(void)
 
+# There are no provisional features currently
+
 cat Provisional
 
-# Line end types which may be used in addition to LF, CR, and CRLF
-# SC_LINE_END_TYPE_UNICODE includes U+2028 Line Separator,
-# U+2029 Paragraph Separator, and U+0085 Next Line
-enu LineEndType=SC_LINE_END_TYPE_
-val SC_LINE_END_TYPE_DEFAULT=0
-val SC_LINE_END_TYPE_UNICODE=1
-
-# Set the line end types that the application wants to use. May not be used if incompatible with lexer or encoding.
-set void SetLineEndTypesAllowed=2656(int lineEndBitSet,)
-
-# Get the line end types currently allowed.
-get int GetLineEndTypesAllowed=2657(,)
-
-# Get the line end types currently recognised. May be a subset of the allowed types due to lexer limitation.
-get int GetLineEndTypesActive=2658(,)
-
-# Bit set of LineEndType enumertion for which line ends beyond the standard
-# LF, CR, and CRLF are supported by the lexer.
-get int GetLineEndTypesSupported=4018(,)
-
-# Allocate a set of sub styles for a particular base style, returning start of range
-fun int AllocateSubStyles=4020(int styleBase, int numberStyles)
-
-# The starting style number for the sub styles associated with a base style
-get int GetSubStylesStart=4021(int styleBase,)
-
-# The number of sub styles associated with a base style
-get int GetSubStylesLength=4022(int styleBase,)
-
-# For a sub style, return the base style, else return the argument.
-get int GetStyleFromSubStyle=4027(int subStyle,)
-
-# For a secondary style, return the primary style, else return the argument.
-get int GetPrimaryStyleFromStyle=4028(int style,)
-
-# Free allocated sub styles
-fun void FreeSubStyles=4023(,)
-
-# Set the identifiers that are shown in a particular style
-set void SetIdentifiers=4024(int style, string identifiers)
-
-# Where styles are duplicated by a feature such as active/inactive code
-# return the distance between the two types.
-get int DistanceToSecondaryStyles=4025(,)
-
-# Get the set of base styles that can be extended with sub styles
-get int GetSubStyleBases=4026(, stringresult styles)
-
 cat Deprecated
 
 # Deprecated in 2.21
Index: src/stc/scintilla/lexers/LexAsm.cxx
===================================================================
--- src/stc/scintilla/lexers/LexAsm.cxx	(revision 76307)
+++ src/stc/scintilla/lexers/LexAsm.cxx	(working copy)
@@ -150,8 +150,10 @@
 	WordList directives4foldend;
 	OptionsAsm options;
 	OptionSetAsm osAsm;
+	int commentChar;
 public:
-	LexerAsm() {
+	LexerAsm(int commentChar_) {
+		commentChar = commentChar_;
 	}
 	virtual ~LexerAsm() {
 	}
@@ -183,8 +185,12 @@
 	}
 
 	static ILexer *LexerFactoryAsm() {
-		return new LexerAsm();
+		return new LexerAsm(';');
 	}
+
+	static ILexer *LexerFactoryAs() {
+		return new LexerAsm('#');
+	}
 };
 
 int SCI_METHOD LexerAsm::PropertySet(const char *key, const char *val) {
@@ -342,7 +348,7 @@
 
 		// Determine if a new state should be entered.
 		if (sc.state == SCE_ASM_DEFAULT) {
-			if (sc.ch == ';'){
+			if (sc.ch == commentChar){
 				sc.SetState(SCE_ASM_COMMENT);
 			} else if (IsASCII(sc.ch) && (isdigit(sc.ch) || (sc.ch == '.' && IsASCII(sc.chNext) && isdigit(sc.chNext)))) {
 				sc.SetState(SCE_ASM_NUMBER);
@@ -457,4 +463,5 @@
 }
 
 LexerModule lmAsm(SCLEX_ASM, LexerAsm::LexerFactoryAsm, "asm", asmWordListDesc);
+LexerModule lmAs(SCLEX_AS, LexerAsm::LexerFactoryAs, "as", asmWordListDesc);
 
Index: src/stc/scintilla/lexers/LexCoffeeScript.cxx
===================================================================
--- src/stc/scintilla/lexers/LexCoffeeScript.cxx	(revision 76307)
+++ src/stc/scintilla/lexers/LexCoffeeScript.cxx	(working copy)
@@ -66,9 +66,8 @@
 	int pos = (int) sc.currentPos;
 	int currentLine = styler.GetLine(pos);
 	int lineStartPos = styler.LineStart(currentLine);
-	char ch;
 	while (--pos > lineStartPos) {
-		ch = styler.SafeGetCharAt(pos);
+		char ch = styler.SafeGetCharAt(pos);
 		if (ch != ' ' && ch != '\t') {
 			break;
 		}
@@ -185,7 +184,7 @@
 				break;
 			case SCE_COFFEESCRIPT_NUMBER:
 				// We accept almost anything because of hex. and number suffixes
-				if (!setWord.Contains(sc.ch)) {
+				if (!setWord.Contains(sc.ch) || sc.Match('.', '.')) {
 					sc.SetState(SCE_COFFEESCRIPT_DEFAULT);
 				}
 				break;
@@ -204,6 +203,13 @@
 					sc.SetState(SCE_COFFEESCRIPT_DEFAULT);
 				}
 				break;
+			case SCE_COFFEESCRIPT_WORD:
+			case SCE_COFFEESCRIPT_WORD2:
+			case SCE_COFFEESCRIPT_GLOBALCLASS:
+				if (!setWord.Contains(sc.ch)) {
+					sc.SetState(SCE_COFFEESCRIPT_DEFAULT);
+				}
+				break;
 			case SCE_COFFEESCRIPT_PREPROCESSOR:
 				if (sc.atLineStart && !continuationLine) {
 					sc.SetState(SCE_COFFEESCRIPT_DEFAULT);
Index: src/stc/scintilla/lexers/LexFortran.cxx
===================================================================
--- src/stc/scintilla/lexers/LexFortran.cxx	(revision 76307)
+++ src/stc/scintilla/lexers/LexFortran.cxx	(working copy)
@@ -316,7 +316,6 @@
 		isPrevLine = false;
 	}
 	char chNext = styler[startPos];
-	char chNextNonBlank;
 	int styleNext = styler.StyleAt(startPos);
 	int style = initStyle;
 	int levelDeltaNext = 0;
@@ -323,15 +322,11 @@
 	/***************************************/
 	int lastStart = 0;
 	char prevWord[32] = "";
-	char Label[6] = "";
-	// Variables for do label folding.
-	static int doLabels[100];
-	static int posLabel=-1;
 	/***************************************/
 	for (unsigned int i = startPos; i < endPos; i++) {
 		char ch = chNext;
 		chNext = styler.SafeGetCharAt(i + 1);
-		chNextNonBlank = chNext;
+		char chNextNonBlank = chNext;
 		bool nextEOL = false;
 		if (IsALineEnd(chNextNonBlank)) {
 			nextEOL = true;
@@ -427,7 +422,8 @@
 						}
 					}
 				} else {
-					levelDeltaNext += classifyFoldPointFortran(s, prevWord, chNextNonBlank);
+					int wordLevelDelta = classifyFoldPointFortran(s, prevWord, chNextNonBlank);
+					levelDeltaNext += wordLevelDelta;
 					if (((strcmp(s, "else") == 0) && (nextEOL || chNextNonBlank == '!')) ||
 						(strcmp(prevWord, "else") == 0 && strcmp(s, "where") == 0) || strcmp(s, "elsewhere") == 0) {
 						if (!isPrevLine) {
@@ -453,39 +449,17 @@
 						levelDeltaNext -= 2;
 					}
 
-					// Store the do Labels into array
+					// There are multiple forms of "do" loop. The older form with a label "do 100 i=1,10" would require matching
+					// labels to ensure the folding level does not decrease too far when labels are used for other purposes.
+					// Since this is difficult, do-label constructs are not folded.
 					if (strcmp(s, "do") == 0 && IsADigit(chNextNonBlank)) {
-						unsigned int k = 0;
-						for (i=j; (i<j+5 && i<endPos); i++) {
-							ch = styler.SafeGetCharAt(i);
-							if (IsADigit(ch))
-								Label[k++] = ch;
-							else
-								break;
+						// Remove delta for do-label
+						levelDeltaNext -= wordLevelDelta;
 						}
-						Label[k] = '\0';
-						posLabel ++;
-						doLabels[posLabel] = atoi(Label);
 					}
-				}
 				strcpy(prevWord, s);
 			}
-		} else if (style == SCE_F_LABEL) {
-			if(IsADigit(ch) && !IsADigit(chNext)) {
-				for(j = 0; ( j < 5 ) && ( j < i-lastStart+1 ); j++) {
-					ch = styler.SafeGetCharAt(lastStart + j);
-					if (IsADigit(ch) && styler.StyleAt(lastStart+j) == SCE_F_LABEL)
-						Label[j] = ch;
-					else
-						break;
 				}
-				Label[j] = '\0';
-				while (doLabels[posLabel] == atoi(Label) && posLabel > -1) {
-					levelCurrent--;
-					posLabel--;
-				}
-			}
-		}
 		if (atEOL) {
 			int lev = levelCurrent;
 			if (visibleChars == 0 && foldCompact)
Index: src/stc/scintilla/lexers/LexMarkdown.cxx
===================================================================
--- src/stc/scintilla/lexers/LexMarkdown.cxx	(revision 76307)
+++ src/stc/scintilla/lexers/LexMarkdown.cxx	(working copy)
@@ -118,10 +118,11 @@
 }
 
 static bool IsValidHrule(const unsigned int endPos, StyleContext &sc) {
-    int c, count = 1;
+    int count = 1;
     unsigned int i = 0;
-    while (++i) {
-        c = sc.GetRelative(i);
+    for (;;) {
+        ++i;
+        int c = sc.GetRelative(i);
         if (c == sc.ch)
             ++count;
         // hit a terminating character
@@ -140,7 +141,6 @@
             }
         }
     }
-    return false;
 }
 
 static void ColorizeMarkdownDoc(unsigned int startPos, int length, int initStyle,
Index: src/stc/scintilla/lexers/LexTxt2tags.cxx
===================================================================
--- src/stc/scintilla/lexers/LexTxt2tags.cxx	(revision 76307)
+++ src/stc/scintilla/lexers/LexTxt2tags.cxx	(working copy)
@@ -78,10 +78,11 @@
 
 // Separator line
 static bool IsValidHrule(const unsigned int endPos, StyleContext &sc) {
-    int c, count = 1;
+    int count = 1;
     unsigned int i = 0;
-    while (++i) {
-        c = sc.GetRelative(i);
+    for (;;) {
+        ++i;
+        int c = sc.GetRelative(i);
         if (c == sc.ch)
             ++count;
         // hit a terminating character
@@ -100,7 +101,6 @@
             }
         }
     }
-    return false;
 }
 
 static void ColorizeTxt2tagsDoc(unsigned int startPos, int length, int initStyle,
Index: src/stc/scintilla/lexlib/WordList.cxx
===================================================================
--- src/stc/scintilla/lexlib/WordList.cxx	(revision 76307)
+++ src/stc/scintilla/lexlib/WordList.cxx	(working copy)
@@ -237,3 +237,4 @@
 const char *WordList::WordAt(int n) const {
 	return words[n];
 }
+
Index: src/stc/scintilla/README.txt
===================================================================
--- src/stc/scintilla/README.txt	(revision 76307)
+++ src/stc/scintilla/README.txt	(working copy)
@@ -3,7 +3,7 @@
 needed to implement Scintilla on top of wxWidgets is located in the
 directory above this one.
 
-The current version of the Scintilla code is 3.3.9
+The current version of the Scintilla code is 3.4.1
 
 These are the basic steps needed to update the version of Scintilla used by wxSTC.  
 
Index: src/stc/scintilla/src/Catalogue.cxx
===================================================================
--- src/stc/scintilla/src/Catalogue.cxx	(revision 76307)
+++ src/stc/scintilla/src/Catalogue.cxx	(working copy)
@@ -80,6 +80,7 @@
 	LINK_LEXER(lmAbaqus);
 	LINK_LEXER(lmAda);
 	LINK_LEXER(lmAPDL);
+	LINK_LEXER(lmAs);
 	LINK_LEXER(lmAsm);
 	LINK_LEXER(lmAsn1);
 	LINK_LEXER(lmASY);
Index: src/stc/scintilla/src/Document.h
===================================================================
--- src/stc/scintilla/src/Document.h	(revision 76307)
+++ src/stc/scintilla/src/Document.h	(working copy)
@@ -191,9 +191,6 @@
 		bool operator==(const WatcherWithUserData &other) const {
 			return (watcher == other.watcher) && (userData == other.userData);
 		}
-		bool operator!=(const WatcherWithUserData &other) const {
-			return (watcher != other.watcher) || (userData != other.userData);
-		}
 	};
 
 private:
Index: src/stc/scintilla/src/Editor.cxx
===================================================================
--- src/stc/scintilla/src/Editor.cxx	(revision 76307)
+++ src/stc/scintilla/src/Editor.cxx	(working copy)
@@ -88,6 +88,10 @@
 Idler::Idler() :
 		state(false), idlerID(0) {}
 
+static int RoundXYPosition(XYPOSITION xyPos) {
+	return int(xyPos+0.5);
+}
+
 static inline bool IsControlCharacter(int ch) {
 	// iscntrl returns true for lots of chars > 127 which are displayable
 	return ch >= 0 && ch < ' ';
@@ -269,6 +273,8 @@
 			char c1[3] = { '\xc2',  static_cast<char>(0x80+j), 0 };
 			reprs.SetRepresentation(c1, repsC1[j]);
 		}
+		reprs.SetRepresentation("\xe2\x80\xa8", "LS");
+		reprs.SetRepresentation("\xe2\x80\xa9", "PS");
 	}
 
 	// UTF-8 invalid bytes
@@ -382,6 +388,10 @@
 	return wMain.GetClientPosition();
 }
 
+PRectangle Editor::GetClientDrawingRectangle() {
+	return GetClientRectangle();
+}
+
 PRectangle Editor::GetTextRectangle() {
 	PRectangle rc = GetClientRectangle();
 	rc.left += vs.textStart;
@@ -477,36 +487,17 @@
 	RefreshStyleData();
 	if (pos.Position() == INVALID_POSITION)
 		return pt;
-	int line = pdoc->LineFromPosition(pos.Position());
-	int lineVisible = cs.DisplayFromDoc(line);
+	const int line = pdoc->LineFromPosition(pos.Position());
+	const int lineVisible = cs.DisplayFromDoc(line);
 	//Platform::DebugPrintf("line=%d\n", line);
 	AutoSurface surface(this);
 	AutoLineLayout ll(llc, RetrieveLineLayout(line));
 	if (surface && ll) {
-		// -1 because of adding in for visible lines in following loop.
-		pt.y = (lineVisible - topLine - 1) * vs.lineHeight;
-		pt.x = 0;
-		unsigned int posLineStart = pdoc->LineStart(line);
+		const int posLineStart = pdoc->LineStart(line);
 		LayoutLine(line, surface, vs, ll, wrapWidth);
-		int posInLine = pos.Position() - posLineStart;
-		// In case of very long line put x at arbitrary large position
-		if (posInLine > ll->maxLineLength) {
-			pt.x = ll->positions[ll->maxLineLength] - ll->positions[ll->LineStart(ll->lines)];
-		}
-
-		for (int subLine = 0; subLine < ll->lines; subLine++) {
-			if ((posInLine >= ll->LineStart(subLine)) && (posInLine <= ll->LineStart(subLine + 1))) {
-				pt.x = ll->positions[posInLine] - ll->positions[ll->LineStart(subLine)];
-				if (ll->wrapIndent != 0) {
-					int lineStart = ll->LineStart(subLine);
-					if (lineStart != 0)	// Wrapped
-						pt.x += ll->wrapIndent;
-				}
-			}
-			if (posInLine >= ll->LineStart(subLine)) {
-				pt.y += vs.lineHeight;
-			}
-		}
+		const int posInLine = pos.Position() - posLineStart;
+		pt = ll->PointFromPosition(posInLine, vs.lineHeight);
+		pt.y += (lineVisible - topLine) * vs.lineHeight;
 		pt.x += vs.textStart - xOffset;
 	}
 	pt.x += pos.VirtualSpace() * vs.styles[ll->EndLineStyle()].spaceWidth;
@@ -558,58 +549,44 @@
 	int visibleLine = floor(pt.y / vs.lineHeight);
 	if (!canReturnInvalid && (visibleLine < 0))
 		visibleLine = 0;
-	int lineDoc = cs.DocFromDisplay(visibleLine);
+	const int lineDoc = cs.DocFromDisplay(visibleLine);
 	if (canReturnInvalid && (lineDoc < 0))
 		return SelectionPosition(INVALID_POSITION);
 	if (lineDoc >= pdoc->LinesTotal())
 		return SelectionPosition(canReturnInvalid ? INVALID_POSITION : pdoc->Length());
-	unsigned int posLineStart = pdoc->LineStart(lineDoc);
-	SelectionPosition retVal(canReturnInvalid ? INVALID_POSITION : static_cast<int>(posLineStart));
+	const int posLineStart = pdoc->LineStart(lineDoc);
 	AutoSurface surface(this);
 	AutoLineLayout ll(llc, RetrieveLineLayout(lineDoc));
 	if (surface && ll) {
 		LayoutLine(lineDoc, surface, vs, ll, wrapWidth);
-		int lineStartSet = cs.DisplayFromDoc(lineDoc);
-		int subLine = visibleLine - lineStartSet;
+		const int lineStartSet = cs.DisplayFromDoc(lineDoc);
+		const int subLine = visibleLine - lineStartSet;
 		if (subLine < ll->lines) {
-			int lineStart = ll->LineStart(subLine);
-			int lineEnd = ll->LineLastVisible(subLine);
-			XYPOSITION subLineStart = ll->positions[lineStart];
-
-			if (ll->wrapIndent != 0) {
-				if (lineStart != 0)	// Wrapped
+			const Range rangeSubLine = ll->SubLineRange(subLine);
+			const XYPOSITION subLineStart = ll->positions[rangeSubLine.start];
+			if (subLine > 0)	// Wrapped
 					pt.x -= ll->wrapIndent;
+			const int positionInLine = ll->FindPositionFromX(pt.x + subLineStart, rangeSubLine, charPosition);
+			if (positionInLine < rangeSubLine.end) {
+				return SelectionPosition(pdoc->MovePositionOutsideChar(positionInLine + posLineStart, 1));
 			}
-			int i = ll->FindBefore(pt.x + subLineStart, lineStart, lineEnd);
-			while (i < lineEnd) {
-				if (charPosition) {
-					if ((pt.x + subLineStart) < (ll->positions[i + 1])) {
-						return SelectionPosition(pdoc->MovePositionOutsideChar(i + posLineStart, 1));
-					}
-				} else {
-					if ((pt.x + subLineStart) < ((ll->positions[i] + ll->positions[i + 1]) / 2)) {
-						return SelectionPosition(pdoc->MovePositionOutsideChar(i + posLineStart, 1));
-					}
-				}
-				i++;
-			}
 			if (virtualSpace) {
 				const XYPOSITION spaceWidth = vs.styles[ll->EndLineStyle()].spaceWidth;
-				int spaceOffset = (pt.x + subLineStart - ll->positions[lineEnd] + spaceWidth / 2) /
+				const int spaceOffset = (pt.x + subLineStart - ll->positions[rangeSubLine.end] + spaceWidth / 2) /
 					spaceWidth;
-				return SelectionPosition(lineEnd + posLineStart, spaceOffset);
+				return SelectionPosition(rangeSubLine.end + posLineStart, spaceOffset);
 			} else if (canReturnInvalid) {
-				if (pt.x < (ll->positions[lineEnd] - subLineStart)) {
-					return SelectionPosition(pdoc->MovePositionOutsideChar(lineEnd + posLineStart, 1));
+				if (pt.x < (ll->positions[rangeSubLine.end] - subLineStart)) {
+					return SelectionPosition(pdoc->MovePositionOutsideChar(rangeSubLine.end + posLineStart, 1));
 				}
 			} else {
-				return SelectionPosition(lineEnd + posLineStart);
+				return SelectionPosition(rangeSubLine.end + posLineStart);
 			}
 		}
 		if (!canReturnInvalid)
 			return SelectionPosition(ll->numCharsInLine + posLineStart);
 	}
-	return retVal;
+	return SelectionPosition(canReturnInvalid ? INVALID_POSITION : posLineStart);
 }
 
 int Editor::PositionFromLocation(Point pt, bool canReturnInvalid, bool charPosition) {
@@ -619,6 +596,7 @@
 /**
  * Find the document position corresponding to an x coordinate on a particular document line.
  * Ensure is between whole characters when document is in multi-byte or UTF-8 mode.
+ * This method is used for rectangular selections and does not work on wrapped lines.
  */
 SelectionPosition Editor::SPositionFromLineX(int lineDoc, int x) {
 	RefreshStyleData();
@@ -627,33 +605,20 @@
 	//Platform::DebugPrintf("Position of (%d,%d) line = %d top=%d\n", pt.x, pt.y, line, topLine);
 	AutoSurface surface(this);
 	AutoLineLayout ll(llc, RetrieveLineLayout(lineDoc));
-	int retVal = 0;
 	if (surface && ll) {
-		unsigned int posLineStart = pdoc->LineStart(lineDoc);
+		const int posLineStart = pdoc->LineStart(lineDoc);
 		LayoutLine(lineDoc, surface, vs, ll, wrapWidth);
-		int subLine = 0;
-		int lineStart = ll->LineStart(subLine);
-		int lineEnd = ll->LineLastVisible(subLine);
-		XYPOSITION subLineStart = ll->positions[lineStart];
-		XYPOSITION newX = x;
-
-		if (ll->wrapIndent != 0) {
-			if (lineStart != 0)	// Wrapped
-				newX -= ll->wrapIndent;
+		const Range rangeSubLine = ll->SubLineRange(0);
+		const XYPOSITION subLineStart = ll->positions[rangeSubLine.start];
+		const int positionInLine = ll->FindPositionFromX(x + subLineStart, rangeSubLine, false);
+		if (positionInLine < rangeSubLine.end) {
+			return SelectionPosition(pdoc->MovePositionOutsideChar(positionInLine + posLineStart, 1));
 		}
-		int i = ll->FindBefore(newX + subLineStart, lineStart, lineEnd);
-		while (i < lineEnd) {
-			if ((newX + subLineStart) < ((ll->positions[i] + ll->positions[i + 1]) / 2)) {
-				retVal = pdoc->MovePositionOutsideChar(i + posLineStart, 1);
-				return SelectionPosition(retVal);
-			}
-			i++;
-		}
 		const XYPOSITION spaceWidth = vs.styles[ll->EndLineStyle()].spaceWidth;
-		int spaceOffset = (newX + subLineStart - ll->positions[lineEnd] + spaceWidth / 2) / spaceWidth;
-		return SelectionPosition(lineEnd + posLineStart, spaceOffset);
+		const int spaceOffset = (x + subLineStart - ll->positions[rangeSubLine.end] + spaceWidth / 2) / spaceWidth;
+		return SelectionPosition(rangeSubLine.end + posLineStart, spaceOffset);
 	}
-	return SelectionPosition(retVal);
+	return SelectionPosition(0);
 }
 
 int Editor::PositionFromLineX(int lineDoc, int x) {
@@ -690,6 +655,10 @@
 	}
 }
 
+void Editor::DiscardOverdraw() {
+	// Overridden on platforms that may draw outside visible area.
+}
+
 void Editor::Redraw() {
 	//Platform::DebugPrintf("Redraw all\n");
 	PRectangle rcClient = GetClientRectangle();
@@ -700,7 +669,10 @@
 }
 
 void Editor::RedrawSelMargin(int line, bool allAfter) {
-	if (!AbandonPaint()) {
+	bool abandonDraw = false;
+	if (!wMargin.GetID())	// Margin in main window so may need to abandon and retry
+		abandonDraw = AbandonPaint();
+	if (!abandonDraw) {
 		if (vs.maskInLine) {
 			Redraw();
 		} else {
@@ -1279,7 +1251,7 @@
   1  |   1    |   1   |   1  | No, kept out of UZ                         | moved to put caret at 3UZ of the margin
 */
 
-Editor::XYScrollPosition Editor::XYScrollToMakeVisible(const SelectionRange range, const XYScrollOptions options) {
+Editor::XYScrollPosition Editor::XYScrollToMakeVisible(const SelectionRange &range, const XYScrollOptions options) {
 	PRectangle rcClient = GetTextRectangle();
 	Point pt = LocationFromPosition(range.caret);
 	Point ptAnchor = LocationFromPosition(range.anchor);
@@ -2400,7 +2372,7 @@
 						        - posLineStart;
 						p = pdoc->MovePositionOutsideChar(p + 1 + posLineStart, 1) - posLineStart;
 						continue;
-					} else if (ll->styles[p] != ll->styles[p - 1]) {
+					} else if ((vstyle.wrapState == eWrapWord) && (ll->styles[p] != ll->styles[p - 1])) {
 						lastGoodBreak = p;
 					} else if (IsSpaceOrTab(ll->chars[p - 1]) && !IsSpaceOrTab(ll->chars[p])) {
 						lastGoodBreak = p;
@@ -2585,14 +2557,20 @@
 			char hexits[4];
 			const char *ctrlChar;
 			unsigned char chEOL = ll->chars[eolPos];
+			int styleMain = ll->styles[eolPos];
+			ColourDesired textBack = TextBackground(vsDraw, overrideBackground, background, eolInSelection, false, styleMain, eolPos, ll);
 			if (UTF8IsAscii(chEOL)) {
 				ctrlChar = ControlCharacterString(chEOL);
 			} else {
+				Representation *repr = reprs.RepresentationFromCharacter(ll->chars + eolPos, ll->numCharsInLine - eolPos);
+				if (repr) {
+					ctrlChar = repr->stringRep.c_str();
+					eolPos = ll->numCharsInLine;
+				} else {
 				sprintf(hexits, "x%2X", chEOL);
 				ctrlChar = hexits;
 			}
-			int styleMain = ll->styles[eolPos];
-			ColourDesired textBack = TextBackground(vsDraw, overrideBackground, background, eolInSelection, false, styleMain, eolPos, ll);
+			}
 			ColourDesired textFore = vsDraw.styles[styleMain].fore;
 			if (eolInSelection && vsDraw.selColours.fore.isSet) {
 				textFore = (eolInSelection == 1) ? vsDraw.selColours.fore : vsDraw.selAdditionalForeground;
@@ -3462,7 +3440,7 @@
 				bool caretAtEOL = false;
 				bool drawBlockCaret = false;
 				XYPOSITION widthOverstrikeCaret;
-				int caretWidthOffset = 0;
+				XYPOSITION caretWidthOffset = 0;
 				PRectangle rcCaret = rcLine;
 
 				if (posCaret.Position() == pdoc->Length()) {   // At end of document
@@ -3478,11 +3456,11 @@
 					widthOverstrikeCaret = 3;
 
 				if (xposCaret > 0)
-					caretWidthOffset = 1;	// Move back so overlaps both character cells.
+					caretWidthOffset = 0.51f;	// Move back so overlaps both character cells.
 				xposCaret += xStart;
 				if (posDrag.IsValid()) {
 					/* Dragging text, use a line caret */
-					rcCaret.left = xposCaret - caretWidthOffset;
+					rcCaret.left = RoundXYPosition(xposCaret - caretWidthOffset);
 					rcCaret.right = rcCaret.left + vsDraw.caretWidth;
 				} else if (inOverstrike && drawOverstrikeCaret) {
 					/* Overstrike (insert mode), use a modified bar caret */
@@ -3500,7 +3478,7 @@
 					}
 				} else {
 					/* Line caret */
-					rcCaret.left = xposCaret - caretWidthOffset;
+					rcCaret.left = RoundXYPosition(xposCaret - caretWidthOffset);
 					rcCaret.right = rcCaret.left + vsDraw.caretWidth;
 				}
 				ColourDesired caretColour = mainCaret ? vsDraw.caretcolour : vsDraw.additionalCaretColour;
@@ -5135,6 +5113,7 @@
 	// Remove non-main ranges
 	InvalidateSelection(sel.RangeMain(), true);
 	sel.SetSelection(sel.RangeMain());
+	sel.RangeMain().ClearVirtualSpace();
 
 	// Clear main range and insert line end
 	bool needGroupUndo = !sel.Empty();
@@ -6820,7 +6799,7 @@
 	// The start of the document line after the display line after the area
 	// This often means that the line after a modification is restyled which helps
 	// detect multiline comment additions and heals single line comments
-	int lineAfter = topLine + (rcArea.bottom - 1) / vs.lineHeight + 1;
+	int lineAfter = TopLineOfMain() + (rcArea.bottom - 1) / vs.lineHeight + 1;
 	if (lineAfter < cs.LinesDisplayed())
 		return pdoc->LineStart(cs.DocFromDisplay(lineAfter) + 1);
 	else
@@ -6830,7 +6809,7 @@
 // Style to a position within the view. If this causes a change at end of last line then
 // affects later lines so style all the viewed text.
 void Editor::StyleToPositionInView(Position pos) {
-	int endWindow = (vs.marginInside) ? (PositionAfterArea(GetClientRectangle())) : (pdoc->Length());
+	int endWindow = PositionAfterArea(GetClientDrawingRectangle());
 	if (pos > endWindow)
 		pos = endWindow;
 	int styleAtEnd = pdoc->StyleAt(pos-1);
@@ -6838,6 +6817,9 @@
 	if ((endWindow > pos) && (styleAtEnd != pdoc->StyleAt(pos-1))) {
 		// Style at end of line changed so is multi-line change like starting a comment
 		// so require rest of window to be styled.
+		DiscardOverdraw();	// Prepared bitmaps may be invalid
+		// DiscardOverdraw may have truncated client drawing area so recalculate endWindow
+		endWindow = PositionAfterArea(GetClientDrawingRectangle());
 		pdoc->EnsureStyledTo(endWindow);
 	}
 }
Index: src/stc/scintilla/src/Editor.h
===================================================================
--- src/stc/scintilla/src/Editor.h	(revision 76307)
+++ src/stc/scintilla/src/Editor.h	(working copy)
@@ -338,6 +338,7 @@
 	Point DocumentPointFromView(Point ptView);  // Convert a point from view space to document
 	int TopLineOfMain() const;   // Return the line at Main's y coordinate 0
 	virtual PRectangle GetClientRectangle();
+	virtual PRectangle GetClientDrawingRectangle();
 	PRectangle GetTextRectangle();
 
 	int LinesOnScreen();
@@ -357,6 +358,7 @@
 
 	bool AbandonPaint();
 	virtual void RedrawRect(PRectangle rc);
+	virtual void DiscardOverdraw();
 	virtual void Redraw();
 	void RedrawSelMargin(int line=-1, bool allAfter=false);
 	PRectangle RectangleFromRange(int start, int end);
@@ -412,7 +414,7 @@
 		xysVertical=0x2,
 		xysHorizontal=0x4,
 		xysDefault=xysUseMargin|xysVertical|xysHorizontal};
-	XYScrollPosition XYScrollToMakeVisible(const SelectionRange range, const XYScrollOptions options);
+	XYScrollPosition XYScrollToMakeVisible(const SelectionRange &range, const XYScrollOptions options);
 	void SetXYScroll(XYScrollPosition newXY);
 	void EnsureCaretVisible(bool useMargin=true, bool vert=true, bool horiz=true);
 	void ScrollRange(SelectionRange range);
@@ -437,12 +439,12 @@
 	ColourDesired SelectionBackground(ViewStyle &vsDraw, bool main) const;
 	ColourDesired TextBackground(ViewStyle &vsDraw, bool overrideBackground, ColourDesired background, int inSelection, bool inHotspot, int styleMain, int i, LineLayout *ll) const;
 	void DrawIndentGuide(Surface *surface, int lineVisible, int lineHeight, int start, PRectangle rcSegment, bool highlight);
-	void DrawWrapMarker(Surface *surface, PRectangle rcPlace, bool isEndMarker, ColourDesired wrapColour);
+	static void DrawWrapMarker(Surface *surface, PRectangle rcPlace, bool isEndMarker, ColourDesired wrapColour);
 	void DrawEOL(Surface *surface, ViewStyle &vsDraw, PRectangle rcLine, LineLayout *ll,
 		int line, int lineEnd, int xStart, int subLine, XYACCUMULATOR subLineStart,
 		bool overrideBackground, ColourDesired background,
 		bool drawWrapMark, ColourDesired wrapColour);
-	void DrawIndicator(int indicNum, int startPos, int endPos, Surface *surface, ViewStyle &vsDraw,
+	static void DrawIndicator(int indicNum, int startPos, int endPos, Surface *surface, ViewStyle &vsDraw,
 		int xStart, PRectangle rcLine, LineLayout *ll, int subLine);
 	void DrawIndicators(Surface *surface, ViewStyle &vsDraw, int line, int xStart,
 		PRectangle rcLine, LineLayout *ll, int subLine, int lineEnd, bool under);
Index: src/stc/scintilla/src/PerLine.cxx
===================================================================
--- src/stc/scintilla/src/PerLine.cxx	(revision 76307)
+++ src/stc/scintilla/src/PerLine.cxx	(working copy)
@@ -370,9 +370,9 @@
 }
 
 void LineAnnotation::RemoveLine(int line) {
-	if (annotations.Length() && (line < annotations.Length())) {
-		delete []annotations[line];
-		annotations.Delete(line);
+	if (annotations.Length() && (line > 0) && (line <= annotations.Length())) {
+		delete []annotations[line-1];
+		annotations.Delete(line-1);
 	}
 }
 
Index: src/stc/scintilla/src/PositionCache.cxx
===================================================================
--- src/stc/scintilla/src/PositionCache.cxx	(revision 76307)
+++ src/stc/scintilla/src/PositionCache.cxx	(working copy)
@@ -43,11 +43,6 @@
 using namespace Scintilla;
 #endif
 
-static inline bool IsControlCharacter(int ch) {
-	// iscntrl returns true for lots of chars > 127 which are displayable
-	return ch >= 0 && ch < ' ';
-}
-
 LineLayout::LineLayout(int maxLineLength_) :
 	lineStarts(0),
 	lenLineStarts(0),
@@ -132,6 +127,10 @@
 	}
 }
 
+Range LineLayout::SubLineRange(int subLine) const {
+	return Range(LineStart(subLine), LineLastVisible(subLine));
+}
+
 bool LineLayout::InLine(int offset, int line) const {
 	return ((offset >= LineStart(line)) && (offset < LineStart(line + 1))) ||
 		((offset == numCharsInLine) && (line == (lines-1)));
@@ -205,6 +204,47 @@
 	return lower;
 }
 
+
+int LineLayout::FindPositionFromX(XYPOSITION x, Range range, bool charPosition) const {
+	int pos = FindBefore(x, range.start, range.end);
+	while (pos < range.end) {
+		if (charPosition) {
+			if (x < (positions[pos + 1])) {
+				return pos;
+			}
+		} else {
+			if (x < ((positions[pos] + positions[pos + 1]) / 2)) {
+				return pos;
+			}
+		}
+		pos++;
+	}
+	return range.end;
+}
+
+Point LineLayout::PointFromPosition(int posInLine, int lineHeight) const {
+	Point pt;
+	// In case of very long line put x at arbitrary large position
+	if (posInLine > maxLineLength) {
+		pt.x = positions[maxLineLength] - positions[LineStart(lines)];
+	}
+
+	for (int subLine = 0; subLine < lines; subLine++) {
+		const Range rangeSubLine = SubLineRange(subLine);
+		if (posInLine >= rangeSubLine.start) {
+			pt.y = subLine*lineHeight;
+			if (posInLine <= rangeSubLine.end) {
+				pt.x = positions[posInLine] - positions[rangeSubLine.start];
+				if (rangeSubLine.start != 0)	// Wrapped lines may be indented
+					pt.x += wrapIndent;
+			}
+		} else {
+			break;
+		}
+	}
+	return pt;
+}
+
 int LineLayout::EndLineStyle() const {
 	return styles[numCharsBeforeEOL > 0 ? numCharsBeforeEOL-1 : 0];
 }
Index: src/stc/scintilla/src/PositionCache.h
===================================================================
--- src/stc/scintilla/src/PositionCache.h	(revision 76307)
+++ src/stc/scintilla/src/PositionCache.h	(working copy)
@@ -60,6 +60,7 @@
 	void Invalidate(validLevel validity_);
 	int LineStart(int line) const;
 	int LineLastVisible(int line) const;
+	Range SubLineRange(int line) const;
 	bool InLine(int offset, int line) const;
 	void SetLineStart(int line, int start);
 	void SetBracesHighlight(Range rangeLine, Position braces[],
@@ -66,6 +67,8 @@
 		char bracesMatchStyle, int xHighlight, bool ignoreStyle);
 	void RestoreBracesHighlight(Range rangeLine, Position braces[], bool ignoreStyle);
 	int FindBefore(XYPOSITION x, int lower, int upper) const;
+	int FindPositionFromX(XYPOSITION x, Range range, bool charPosition) const;
+	Point PointFromPosition(int posInLine, int lineHeight) const;
 	int EndLineStyle() const;
 };
 
Index: src/stc/scintilla/src/ScintillaBase.cxx
===================================================================
--- src/stc/scintilla/src/ScintillaBase.cxx	(revision 76307)
+++ src/stc/scintilla/src/ScintillaBase.cxx	(working copy)
@@ -417,16 +417,16 @@
 	// space
 	PRectangle rcClient = GetClientRectangle();
 	int offset = vs.lineHeight + rc.Height();
+	// adjust so it displays above the text.
+	if (rc.bottom > rcClient.bottom) {
+		rc.top -= offset;
+		rc.bottom -= offset;
+	}
 	// adjust so it displays below the text.
 	if (rc.top < rcClient.top) {
 		rc.top += offset;
 		rc.bottom += offset;
 	}
-	// adjust so it displays above the text.
-	if (rc.bottom > rcClient.bottom) {
-		rc.top -= offset;
-		rc.bottom -= offset;
-	}
 	// Now display the window.
 	CreateCallTipWindow(rc);
 	ct.wCallTip.SetPositionRelative(rc, wMain);
Index: src/stc/scintilla/src/ViewStyle.cxx
===================================================================
--- src/stc/scintilla/src/ViewStyle.cxx	(revision 76307)
+++ src/stc/scintilla/src/ViewStyle.cxx	(working copy)
@@ -310,9 +310,9 @@
 		styles[i].extraFontFlag = extraFontFlag;
 	}
 
-	CreateFont(styles[STYLE_DEFAULT]);
+	CreateAndAddFont(styles[STYLE_DEFAULT]);
 	for (unsigned int j=0; j<styles.size(); j++) {
-		CreateFont(styles[j]);
+		CreateAndAddFont(styles[j]);
 	}
 
 	for (FontMap::iterator it = fonts.begin(); it != fonts.end(); ++it) {
@@ -450,6 +450,9 @@
 	case SC_WRAP_CHAR:
 		wrapStateWanted = eWrapChar;
 		break;
+	case SC_WRAP_WHITESPACE:
+		wrapStateWanted = eWrapWhitespace;
+		break;
 	default:
 		wrapStateWanted = eWrapNone;
 		break;
@@ -495,7 +498,7 @@
 	}
 }
 
-void ViewStyle::CreateFont(const FontSpecification &fs) {
+void ViewStyle::CreateAndAddFont(const FontSpecification &fs) {
 	if (fs.fontName) {
 		FontMap::iterator it = fonts.find(fs);
 		if (it == fonts.end()) {
Index: src/stc/scintilla/src/ViewStyle.h
===================================================================
--- src/stc/scintilla/src/ViewStyle.h	(revision 76307)
+++ src/stc/scintilla/src/ViewStyle.h	(working copy)
@@ -56,7 +56,7 @@
 
 typedef std::map<FontSpecification, FontRealised *> FontMap;
 
-enum WrapMode { eWrapNone, eWrapWord, eWrapChar };
+enum WrapMode { eWrapNone, eWrapWord, eWrapChar, eWrapWhitespace };
 
 class ColourOptional : public ColourDesired {
 public:
@@ -178,7 +178,7 @@
 
 private:
 	void AllocStyles(size_t sizeNew);
-	void CreateFont(const FontSpecification &fs);
+	void CreateAndAddFont(const FontSpecification &fs);
 	FontRealised *Find(const FontSpecification &fs);
 	void FindMaxAscentDescent();
 	// Private so can only be copied through copy constructor which ensures font names initialised correctly
Index: src/stc/scintilla/src/XPM.cxx
===================================================================
--- src/stc/scintilla/src/XPM.cxx	(revision 76307)
+++ src/stc/scintilla/src/XPM.cxx	(working copy)
@@ -61,11 +61,9 @@
 }
 
 XPM::~XPM() {
-	Clear();
 }
 
 void XPM::Init(const char *textForm) {
-	Clear();
 	// Test done is two parts to avoid possibility of overstepping the memory
 	// if memcmp implemented strangely. Must be 4 bytes at least at destination.
 	if ((0 == memcmp(textForm, "/* X", 4)) && (0 == memcmp(textForm, "/* XPM */", 9))) {
@@ -81,7 +79,6 @@
 }
 
 void XPM::Init(const char *const *linesForm) {
-	Clear();
 	height = 1;
 	width = 1;
 	nColours = 1;
@@ -125,9 +122,6 @@
 	}
 }
 
-void XPM::Clear() {
-}
-
 void XPM::Draw(Surface *surface, PRectangle &rc) {
 	if (pixels.empty()) {
 		return;
Index: src/stc/scintilla/src/XPM.h
===================================================================
--- src/stc/scintilla/src/XPM.h	(revision 76307)
+++ src/stc/scintilla/src/XPM.h	(working copy)
@@ -30,7 +30,6 @@
 	~XPM();
 	void Init(const char *textForm);
 	void Init(const char *const *linesForm);
-	void Clear();
 	/// Decompose image into runs and use FillRectangle for each run
 	void Draw(Surface *surface, PRectangle &rc);
 	int GetHeight() const { return height; }
Index: src/stc/stc.cpp
===================================================================
--- src/stc/stc.cpp	(revision 76307)
+++ src/stc/stc.cpp	(working copy)
@@ -818,7 +818,7 @@
     return SendMsg(SCI_STYLEGETCASE, style, 0);
 }
 
-// Get the character set of the font in a style.
+// Get the character get of the font in a style.
 int wxStyledTextCtrl::StyleGetCharacterSet(int style) const
 {
     return SendMsg(SCI_STYLEGETCHARACTERSET, style, 0);
@@ -2235,7 +2235,7 @@
                     SendMsg(SCI_APPENDTEXT, wx2stclen(text, buf), (sptr_t)(const char*)buf);
 }
 
-// Is drawing done in two phases with backgrounds drawn before foregrounds?
+// Is drawing done in two phases with backgrounds drawn before faoregrounds?
 bool wxStyledTextCtrl::GetTwoPhaseDraw() const
 {
     return SendMsg(SCI_GETTWOPHASEDRAW, 0, 0) != 0;
@@ -4121,6 +4121,24 @@
     SendMsg(SCI_SETCARETLINEVISIBLEALWAYS, alwaysVisible, 0);
 }
 
+// Set the line end types that the application wants to use. May not be used if incompatible with lexer or encoding.
+void wxStyledTextCtrl::SetLineEndTypesAllowed(int lineEndBitSet)
+{
+    SendMsg(SCI_SETLINEENDTYPESALLOWED, lineEndBitSet, 0);
+}
+
+// Get the line end types currently allowed.
+int wxStyledTextCtrl::GetLineEndTypesAllowed() const
+{
+    return SendMsg(SCI_GETLINEENDTYPESALLOWED, 0, 0);
+}
+
+// Get the line end types currently recognised. May be a subset of the allowed types due to lexer limitation.
+int wxStyledTextCtrl::GetLineEndTypesActive() const
+{
+    return SendMsg(SCI_GETLINEENDTYPESACTIVE, 0, 0);
+}
+
 // Set the way a character is drawn.
 void wxStyledTextCtrl::SetRepresentation(const wxString& encodedCharacter, const wxString& representation)
 {
@@ -4127,7 +4145,7 @@
     SendMsg(SCI_SETREPRESENTATION, (sptr_t)(const char*)wx2stc(encodedCharacter), (sptr_t)(const char*)wx2stc(representation));
 }
 
-// Get the way a character is drawn.
+// Set the way a character is drawn.
 wxString wxStyledTextCtrl::GetRepresentation(const wxString& encodedCharacter) const {
          int msg = SCI_GETREPRESENTATION;
          int len = SendMsg(msg, (sptr_t)(const char*)wx2stc(encodedCharacter), (sptr_t)NULL);
@@ -4288,24 +4306,6 @@
          return stc2wx(buf);
 }
 
-// Set the line end types that the application wants to use. May not be used if incompatible with lexer or encoding.
-void wxStyledTextCtrl::SetLineEndTypesAllowed(int lineEndBitSet)
-{
-    SendMsg(SCI_SETLINEENDTYPESALLOWED, lineEndBitSet, 0);
-}
-
-// Get the line end types currently allowed.
-int wxStyledTextCtrl::GetLineEndTypesAllowed() const
-{
-    return SendMsg(SCI_GETLINEENDTYPESALLOWED, 0, 0);
-}
-
-// Get the line end types currently recognised. May be a subset of the allowed types due to lexer limitation.
-int wxStyledTextCtrl::GetLineEndTypesActive() const
-{
-    return SendMsg(SCI_GETLINEENDTYPESACTIVE, 0, 0);
-}
-
 // Bit set of LineEndType enumertion for which line ends beyond the standard
 // LF, CR, and CRLF are supported by the lexer.
 int wxStyledTextCtrl::GetLineEndTypesSupported() const
@@ -5317,7 +5317,7 @@
 
 /*static*/ wxVersionInfo wxStyledTextCtrl::GetLibraryVersionInfo()
 {
-    return wxVersionInfo("Scintilla", 3, 3, 9, "Scintilla 3.3.9");
+    return wxVersionInfo("Scintilla", 3, 4, 1, "Scintilla 3.4.1");
 }
 
 #endif // wxUSE_STC
Index: src/stc/stc.cpp.in
===================================================================
--- src/stc/stc.cpp.in	(revision 76307)
+++ src/stc/stc.cpp.in	(working copy)
@@ -1205,7 +1205,7 @@
 
 /*static*/ wxVersionInfo wxStyledTextCtrl::GetLibraryVersionInfo()
 {
-    return wxVersionInfo("Scintilla", 3, 3, 9, "Scintilla 3.3.9");
+    return wxVersionInfo("Scintilla", 3, 4, 1, "Scintilla 3.4.1");
 }
 
 #endif // wxUSE_STC
