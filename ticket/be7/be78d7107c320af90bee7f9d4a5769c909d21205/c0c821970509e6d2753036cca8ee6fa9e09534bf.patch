Index: build/bakefiles/files.bkl
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/build/bakefiles/files.bkl,v
retrieving revision 1.428
diff -u -B -r1.428 files.bkl
--- build/bakefiles/files.bkl	2007/04/05 06:27:06	1.428
+++ build/bakefiles/files.bkl	2007/04/06 20:52:20
@@ -769,6 +769,7 @@
     wx/palette.h
     wx/panel.h
     wx/pen.h
+    wx/position.h
     wx/radiobox.h
     wx/radiobut.h
     wx/renderer.h
Index: docs/latex/wx/classes.tex
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/docs/latex/wx/classes.tex,v
retrieving revision 1.223
diff -u -B -r1.223 classes.tex
--- docs/latex/wx/classes.tex	2007/03/15 17:25:06	1.223
+++ docs/latex/wx/classes.tex	2007/04/06 20:52:20
@@ -196,6 +196,7 @@
 \input hprovcnt.tex
 \input helpevt.tex
 \input helpprov.tex
+\input hscrolledwindow.tex
 \input htcell.tex
 \input htcolor.tex
 \input htcontnr.tex
@@ -217,6 +218,7 @@
 \input htwinprs.tex
 \input htwinhnd.tex
 \input http.tex
+\input hvscrolledwindow.tex
 \input hyperlink.tex
 \input icon.tex
 \input iconbndl.tex
@@ -294,6 +296,7 @@
 \input pickerbase.tex
 \input platinfo.tex
 \input point.tex
+\input position.tex
 \input postscpt.tex
 \input powerevt.tex
 \input prevwin.tex
@@ -430,10 +433,14 @@
 \input url.tex
 \input urldataob.tex
 \input validatr.tex
+\input varhscrollhelper.tex
+\input varhvscrollhelper.tex
 \input variant.tex
+\input varscrollhelperbase.tex
+\input varvscrollhelper.tex
 \input view.tex
 \input vlbox.tex
-\input vscroll.tex
+\input vscrolledwindow.tex
 \input window.tex
 \input wupdlock.tex
 \input createevt.tex
Index: include/wx/event.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/include/wx/event.h,v
retrieving revision 1.267
diff -u -B -r1.267 event.h
--- include/wx/event.h	2007/03/07 11:34:20	1.267
+++ include/wx/event.h	2007/04/06 20:52:21
@@ -23,6 +23,7 @@
 #endif
 
 #include "wx/thread.h"
+#include "wx/utils.h"
 
 #include "wx/dynarray.h"
 
@@ -682,6 +683,7 @@
     wxMouseEvent(wxEventType mouseType = wxEVT_NULL);
     wxMouseEvent(const wxMouseEvent& event)    : wxEvent(event)
         { Assign(event); }
+    wxMouseEvent(wxMouseState ms, wxEventType mouseType = wxEVT_NULL);
 
     // Was it a button event? (*doesn't* mean: is any button *down*?)
     bool IsButton() const { return Button(wxMOUSE_BTN_ANY); }
Index: include/wx/htmllbox.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/include/wx/htmllbox.h,v
retrieving revision 1.22
diff -u -B -r1.22 htmllbox.h
--- include/wx/htmllbox.h	2006/12/04 10:16:02	1.22
+++ include/wx/htmllbox.h	2007/04/06 20:52:21
@@ -305,8 +305,8 @@
     // wxSimpleHtmlListBox shouldn't be allowed to call them directly!
     virtual void SetItemCount(size_t count)
         { wxHtmlListBox::SetItemCount(count); }
-    virtual void SetLineCount(size_t count)
-        { wxHtmlListBox::SetLineCount(count); }
+    virtual void SetRowCount(size_t count)
+        { wxHtmlListBox::SetRowCount(count); }
 
     virtual wxString OnGetItem(size_t n) const
         { return m_items[n]; }
Index: include/wx/vlbox.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/include/wx/vlbox.h,v
retrieving revision 1.19
diff -u -B -r1.19 vlbox.h
--- include/wx/vlbox.h	2007/03/07 20:58:02	1.19
+++ include/wx/vlbox.h	2007/04/06 20:52:21
@@ -75,7 +75,7 @@
     // ---------
 
     // get the number of items in the control
-    size_t GetItemCount() const { return GetLineCount(); }
+    size_t GetItemCount() const { return GetRowCount(); }
 
     // does this control use multiple selection?
     bool HasMultipleSelection() const { return m_selStore != NULL; }
@@ -133,7 +133,7 @@
 
     // set the number of items to be shown in the control
     //
-    // this is just a synonym for wxVScrolledWindow::SetLineCount()
+    // this is just a synonym for wxVScrolledWindow::SetRowCount()
     virtual void SetItemCount(size_t count);
 
     // delete all items from the control
Index: include/wx/vscroll.h
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/include/wx/vscroll.h,v
retrieving revision 1.22
diff -u -B -r1.22 vscroll.h
--- include/wx/vscroll.h	2006/04/26 00:17:49	1.22
+++ include/wx/vscroll.h	2007/04/06 20:52:21
@@ -1,8 +1,8 @@
 /////////////////////////////////////////////////////////////////////////////
 // Name:        include/wx/vscroll.h
-// Purpose:     wxVScrolledWindow: generalization of wxScrolledWindow
+// Purpose:     Variable scrolled windows (wx[V/H/HV]ScrolledWindow)
 // Author:      Vadim Zeitlin
-// Modified by:
+// Modified by: Brad Anderson, Bryan Petty
 // Created:     30.05.03
 // RCS-ID:      $Id: vscroll.h,v 1.22 2006/04/26 00:17:49 VZ Exp $
 // Copyright:   (c) 2003 Vadim Zeitlin <vadim@wxwidgets.org>
@@ -12,137 +12,572 @@
 #ifndef _WX_VSCROLL_H_
 #define _WX_VSCROLL_H_
 
-#include "wx/panel.h"           // base class
+#include "wx/panel.h"
+#include "wx/position.h"
 
-// ----------------------------------------------------------------------------
-// wxVScrolledWindow
-// ----------------------------------------------------------------------------
+class WXDLLEXPORT wxVarScrollHelperEvtHandler;
+
+
+// Using the same techniques as the wxScrolledWindow class      |
+// hierarchy, the wx[V/H/HV]ScrolledWindow classes are slightly |
+// more complex (compare with the diagram outlined in           |
+// scrolwin.h) for the purpose of reducing code duplication     |
+// through the use of mix-in classes.                           |
+//                                                              |
+//                  wxVarScrollHelperBase                       |
+//                   /                 \                        |
+//                  /                   \                       |
+//                 V                     V                      |
+//  wxVarHScrollHelper                 wxVarVScrollHelper       |
+//       |          \                   /           |           |
+//       |           \                 /            |           |
+//       |            V               V             |           |
+//       |           wxVarHVScrollHelper            |           |
+//       |                      |                   |           |
+//       |                      |                   V           |
+//       |         wxPanel      |    wxVarVScrollLegacyAdaptor  |
+//       |         /  \  \      |                   |           |
+//       |        /    \  `-----|----------.        |           |
+//       |       /      \       |           \       |           |
+//       |      /        \      |            \      |           |
+//       V     V          \     |             V     V           |
+//  wxHScrolledWindow      \    |        wxVScrolledWindow      |
+//                          V   V                               |
+//                    wxHVScrolledWindow                        |
+//                                                              |
+//                                                              |
+//   Border added to suppress GCC multi-line comment warnings ->|
+
+
+// ===========================================================================
+// wxVarScrollHelperBase
+// ===========================================================================
+
+// Provides all base common scroll calculations needed for either orientation,
+// automatic scrollbar functionality, saved scroll positions, functionality
+// for changing the target window to be scrolled, as well as defining all
+// required virtual functions that need to be implemented for any orientation
+// specific work.
 
-/*
-   In the name of this class, "V" may stand for "variable" because it can be
-   used for scrolling lines of variable heights; "virtual" because it is not
-   necessary to know the heights of all lines in advance -- only those which
-   are shown on the screen need to be measured; or, even, "vertical" because
-   this class only supports scrolling in one direction currently (this could
-   and probably will change in the future however).
-
-   In any case, this is a generalization of the wxScrolledWindow class which
-   can be only used when all lines have the same height. It lacks some other
-   wxScrolledWindow features however, notably it currently lacks support for
-   horizontal scrolling; it can't scroll another window nor only a rectangle
-   of the window and not its entire client area.
- */
-class WXDLLEXPORT wxVScrolledWindow : public wxPanel
+class WXDLLEXPORT wxVarScrollHelperBase
 {
 public:
     // constructors and such
     // ---------------------
 
-    // default ctor, you must call Create() later
-    wxVScrolledWindow() { Init(); }
+    wxVarScrollHelperBase(wxWindow *winToScroll);
+    virtual ~wxVarScrollHelperBase();
 
-    // normal ctor, no need to call Create() after this one
+    // operations
+    // ----------
+
+    // with physical scrolling on, the device origin is changed properly when
+    // a wxPaintDC is prepared, children are actually moved and laid out
+    // properly, and the contents of the window (pixels) are actually moved
+    void EnablePhysicalScrolling(bool scrolling = true)
+        { m_physicalScrolling = scrolling; }
+
+    // wxNOT_FOUND if none, i.e. if it is below the last item
+    virtual int HitTest(wxCoord coord) const;
+
+    // recalculate all our parameters and redisplay all units
+    virtual void RefreshAll();
+
+    // accessors
+    // ---------
+
+    // get the first currently visible unit
+    size_t GetVisibleBegin() const { return m_unitFirst; }
+
+    // get the last currently visible unit
+    size_t GetVisibleEnd() const
+        { return m_unitFirst + m_nUnitsVisible; }
+
+    // is this unit currently visible?
+    bool IsVisible(size_t unit) const
+        { return unit >= m_unitFirst &&
+                 unit < GetVisibleEnd(); }
+
+    // translate between scrolled and unscrolled coordinates
+    int CalcScrolledPosition(int coord) const
+        {  return DoCalcScrolledPosition(coord); }
+    int CalcUnscrolledPosition(int coord) const
+        {  return DoCalcUnscrolledPosition(coord); }
+
+    virtual int DoCalcScrolledPosition(int coord) const;
+    virtual int DoCalcUnscrolledPosition(int coord) const;
+
+    // update the thumb size shown by the scrollbar
+    virtual void UpdateScrollbar();
+    void RemoveScrollbar();
+
+    // Normally the wxScrolledWindow will scroll itself, but in some rare
+    // occasions you might want it to scroll [part of] another window (e.g. a
+    // child of it in order to scroll only a portion the area between the
+    // scrollbars (spreadsheet: only cell area will move).
+    virtual void SetTargetWindow(wxWindow *target);
+    virtual wxWindow *GetTargetWindow() const { return m_targetWindow; }
+
+    // Override this function to draw the graphic (or just process EVT_PAINT)
+    //virtual void OnDraw(wxDC& WXUNUSED(dc)) { }
+
+    // change the DC origin according to the scroll position. To properly
+    // forward calls to wxWindow::Layout use WX_FORWARD_TO_SCROLL_HELPER()
+    // derived class
+    virtual void DoPrepareDC(wxDC& dc);
+
+    // the methods to be called from the window event handlers
+    void HandleOnScroll(wxScrollWinEvent& event);
+    void HandleOnSize(wxSizeEvent& event);
+#if wxUSE_MOUSEWHEEL
+    void HandleOnMouseWheel(wxMouseEvent& event);
+#endif // wxUSE_MOUSEWHEEL
+
+    // these functions must be overidden in the derived class to return
+    // orientation specific data (e.g. the width for vertically scrolling
+    // derivatives in the case of GetOrientationTargetSize())
+    virtual int GetOrientationTargetSize() const = 0;
+    virtual int GetNonOrientationTargetSize() const = 0;
+    virtual wxOrientation GetOrientation() const = 0;
+
+protected:
+    // all *Unit* functions are protected to be exposed by
+    // wxVarScrollHelperBase implementations (with appropriate names)
+
+    // get the number of units this window contains (previously set by
+    // SetUnitCount())
+    size_t GetUnitCount() const { return m_unitMax; }
+
+    // set the number of units the helper contains: the derived class must
+    // provide the sizes for all units with indices up to the one given here
+    // in its OnGetUnitSize()
+    void SetUnitCount(size_t count);
+
+    // redraw the specified unit
+    virtual void RefreshUnit(size_t unit);
+
+    // redraw all units in the specified range (inclusive)
+    virtual void RefreshUnits(size_t from, size_t to);
+
+    // scroll to the specified unit: it will become the first visible unit in
+    // the window
     //
-    // note that wxVSCROLL is always automatically added to our style, there is
-    // no need to specify it explicitly
-    wxVScrolledWindow(wxWindow *parent,
-                      wxWindowID id = wxID_ANY,
-                      const wxPoint& pos = wxDefaultPosition,
-                      const wxSize& size = wxDefaultSize,
-                      long style = 0,
-                      const wxString& name = wxPanelNameStr)
-    {
-        Init();
+    // return true if we scrolled the window, false if nothing was done
+    bool DoScrollToUnit(size_t unit);
 
-        (void)Create(parent, id, pos, size, style, name);
-    }
+    // scroll by the specified number of units/pages
+    virtual bool DoScrollUnits(int units);
+    virtual bool DoScrollPages(int pages);
 
-    // same as the previous ctor but returns status code: true if ok
+    // this function must be overridden in the derived class and it should
+    // return the size of the given unit in pixels
+    virtual wxCoord OnGetUnitSize(size_t n) const = 0;
+
+    // this function doesn't have to be overridden but it may be useful to do
+    // it if calculating the units' sizes is a relatively expensive operation
+    // as it gives the user code a possibility to calculate several of them at
+    // once
     //
-    // just as with the ctor above, wxVSCROLL style is always used, there is no
-    // need to specify it
-    bool Create(wxWindow *parent,
-                wxWindowID id = wxID_ANY,
-                const wxPoint& pos = wxDefaultPosition,
-                const wxSize& size = wxDefaultSize,
-                long style = 0,
-                const wxString& name = wxPanelNameStr)
+    // OnGetUnitsSizeHint() is normally called just before OnGetUnitSize() but you
+    // shouldn't rely on the latter being called for all units in the interval
+    // specified here. It is also possible that OnGetUnitHeight() will be
+    // called for the units outside of this interval, so this is really just a
+    // hint, not a promise.
+    //
+    // finally note that unitMin is inclusive, while unitMax is exclusive, as
+    // usual
+    virtual void OnGetUnitsSizeHint(size_t WXUNUSED(unitMin),
+                                    size_t WXUNUSED(unitMax)) const { }
+
+    // when the number of units changes, we try to estimate the total size
+    // of all units which is a rather expensive operation in terms of unit
+    // access, so if the user code may estimate the average size
+    // better/faster than we do, it should override this function to implement
+    // its own logic
+    //
+    // this function should return the best guess for the total size it may
+    // make
+    virtual wxCoord EstimateTotalSize() const { return DoEstimateTotalSize(); }
+
+    wxCoord DoEstimateTotalSize() const;
+
+    // find the index of the unit we need to show to fit the specified unit on
+    // the opposite side either fully or partially (depending on fullyVisible)
+    size_t FindFirstVisibleFromLast(size_t last,
+                                    bool fullyVisible = false) const;
+
+    // get the total size of the units between unitMin (inclusive) and
+    // unitMax (exclusive)
+    wxCoord GetUnitsSize(size_t unitMin, size_t unitMax) const;
+
+    // get the size of the target window
+    wxSize GetTargetSize() const { return m_targetWindow->GetClientSize(); }
+
+    void GetTargetSize(int *w, int *h)
     {
-        return wxPanel::Create(parent, id, pos, size, style | wxVSCROLL, name);
+        wxSize size = GetTargetSize();
+        if ( w )
+            *w = size.x;
+        if ( h )
+            *h = size.y;
     }
 
+    // calculate the new scroll position based on scroll event type
+    size_t GetNewScrollPosition(wxScrollWinEvent& event) const;
 
-    // operations
-    // ----------
+    // replacement implementation of wxWindow::Layout virtual method.  To
+    // properly forward calls to wxWindow::Layout use
+    // WX_FORWARD_TO_SCROLL_HELPER() derived class
+    bool ScrollLayout();
+
+#ifdef __WXMAC__
+    // queue mac window update after handling scroll event
+    virtual void UpdateMacScrollWindow() = 0;
+#endif // __WXMAC__
 
-    // set the number of lines the window contains: the derived class must
-    // provide the heights for all lines with indices up to the one given here
-    // in its OnGetLineHeight()
-    void SetLineCount(size_t count);
+    // change the target window
+    void DoSetTargetWindow(wxWindow *target);
 
-    // scroll to the specified line: it will become the first visible line in
-    // the window
-    //
-    // return true if we scrolled the window, false if nothing was done
-    bool ScrollToLine(size_t line);
+    // delete the event handler we installed
+    void DeleteEvtHandler();
 
-    // scroll by the specified number of lines/pages
-    virtual bool ScrollLines(int lines);
-    virtual bool ScrollPages(int pages);
+private:
 
-    // redraw the specified line
-    virtual void RefreshLine(size_t line);
+    // the window that receives the scroll events and the window to actually
+    // scroll, respectively
+    wxWindow    *m_win,
+                *m_targetWindow;
 
-    // redraw all lines in the specified range (inclusive)
-    virtual void RefreshLines(size_t from, size_t to);
+    // the total number of (logical) units
+    size_t m_unitMax;
 
-    // return the item at the specified (in physical coordinates) position or.
+    // the total (estimated) size
+    wxCoord m_sizeTotal;
 
-    // wxNOT_FOUND if none, i.e. if it is below the last item
-    int HitTest(wxCoord x, wxCoord y) const;
-    int HitTest(const wxPoint& pt) const { return HitTest(pt.x, pt.y); }
+    // the first currently visible unit
+    size_t m_unitFirst;
 
-    // recalculate all our parameters and redisplay all lines
-    virtual void RefreshAll();
+    // the number of currently visible units (including the last, possibly only
+    // partly, visible one)
+    size_t m_nUnitsVisible;
+
+    // accumulated mouse wheel rotation
+#if wxUSE_MOUSEWHEEL
+    int m_sumWheelRotation;
+#endif
+
+    // do child scrolling (used in DoPrepareDC())
+    bool m_physicalScrolling;
+
+    // handler injected into target window to forward some useful events to us
+    wxVarScrollHelperEvtHandler *m_handler;
+};
+
+
+
+// ===========================================================================
+// wxVarVScrollHelper
+// ===========================================================================
+
+// Provides public API functions targeted for vertical-specific scrolling,
+// wrapping the functionality of wxVarScrollHelperBase.
+
+class WXDLLEXPORT wxVarVScrollHelper : public wxVarScrollHelperBase
+{
+public:
+    // constructors and such
+    // ---------------------
+
+    // ctor must be given the associated window
+    wxVarVScrollHelper(wxWindow *winToScroll) : wxVarScrollHelperBase(winToScroll) { }
+
+    // operators
+
+    void SetRowCount(size_t rowCount)           { SetUnitCount(rowCount); }
+    bool ScrollToRow(size_t row)                { return DoScrollToUnit(row); }
+    virtual bool ScrollRows(int rows)           { return DoScrollUnits(rows); }
+    virtual bool ScrollRowPages(int pages)      { return DoScrollPages(pages); }
+    virtual void RefreshRow(size_t row)         { RefreshUnit(row); }
+    virtual void RefreshRows(size_t from, size_t to)
+                                                { RefreshUnits(from, to); }
+    virtual int HitTest(wxCoord y) const        { return wxVarScrollHelperBase::HitTest(y); }
+
+    // accessors
+
+    size_t GetRowCount() const                  { return GetUnitCount(); }
+    size_t GetVisibleRowsBegin() const          { return GetVisibleBegin(); }
+    size_t GetVisibleRowsEnd() const            { return GetVisibleEnd(); }
+    bool IsRowVisible(size_t row) const         { return IsVisible(row); }
+
+    virtual int GetOrientationTargetSize() const
+        { return GetTargetWindow()->GetClientSize().y; }
+    virtual int GetNonOrientationTargetSize() const
+        { return GetTargetWindow()->GetClientSize().x; }
+    virtual wxOrientation GetOrientation() const { return wxVERTICAL; }
+
+protected:
+    // this function must be overridden in the derived class and it should
+    // return the size of the given row in pixels
+    virtual wxCoord OnGetRowHeight(size_t n) const = 0;
+    wxCoord OnGetUnitSize(size_t n) const       { return OnGetRowHeight(n); }
+
+    virtual void OnGetRowsHeightHint(size_t WXUNUSED(rowMin),
+                                     size_t WXUNUSED(rowMax)) const { }
+
+    // forward calls to OnGetRowsHeightHint()
+    virtual void OnGetUnitsSizeHint(size_t unitMin, size_t unitMax) const
+        { return OnGetRowsHeightHint(unitMin, unitMax); }
+
+    // again, if not overridden, it will fall back on default method
+    virtual wxCoord EstimateTotalHeight() const { return DoEstimateTotalSize(); }
+
+    // forward calls to EstimateTotalHeight()
+    virtual wxCoord EstimateTotalSize() const { return EstimateTotalHeight(); }
+
+    wxCoord GetRowsHeight(size_t rowMin, size_t rowMax) const
+        { return GetUnitsSize(rowMin, rowMax); }
+};
+
+
+
+// ===========================================================================
+// wxVarHScrollHelper
+// ===========================================================================
 
+// Provides public API functions targeted for horizontal-specific scrolling,
+// wrapping the functionality of wxVarScrollHelperBase.
+
+class WXDLLEXPORT wxVarHScrollHelper : public wxVarScrollHelperBase
+{
+public:
+    // constructors and such
+    // ---------------------
+
+    // ctor must be given the associated window
+    wxVarHScrollHelper(wxWindow *winToScroll) : wxVarScrollHelperBase(winToScroll) { }
+
+    // operators
+
+    void SetColumnCount(size_t columnCount)         { SetUnitCount(columnCount); }
+    bool ScrollToColumn(size_t column)              { return DoScrollToUnit(column); }
+    virtual bool ScrollColumns(int columns)         { return DoScrollUnits(columns); }
+    virtual bool ScrollColumnPages(int pages)       { return DoScrollPages(pages); }
+    virtual void RefreshColumn(size_t column)       { RefreshUnit(column); }
+    virtual void RefreshColumns(size_t from, size_t to)
+                                                    { RefreshUnits(from, to); }
+    virtual int HitTest(wxCoord x) const            { return wxVarScrollHelperBase::HitTest(x); }
+
+    // accessors
+
+    size_t GetColumnCount() const                   { return GetUnitCount(); }
+    size_t GetVisibleColumnsBegin() const           { return GetVisibleBegin(); }
+    size_t GetVisibleColumnsEnd() const             { return GetVisibleEnd(); }
+    bool IsColumnVisible(size_t column) const       { return IsVisible(column); }
+
+
+    virtual int GetOrientationTargetSize() const
+        { return GetTargetWindow()->GetClientSize().x; }
+    virtual int GetNonOrientationTargetSize() const
+        { return GetTargetWindow()->GetClientSize().y; }
+    virtual wxOrientation GetOrientation() const   { return wxHORIZONTAL; }
+
+protected:
+    // this function must be overridden in the derived class and it should
+    // return the size of the given column in pixels
+    virtual wxCoord OnGetColumnWidth(size_t n) const = 0;
+    wxCoord OnGetUnitSize(size_t n) const        { return OnGetColumnWidth(n); }
+
+    virtual void OnGetColumnsWidthHint(size_t WXUNUSED(columnMin),
+                                        size_t WXUNUSED(columnMax)) const { }
+
+    // forward calls to OnGetColumnsWidthHint()
+    virtual void OnGetUnitsSizeHint(size_t unitMin, size_t unitMax) const
+        { return OnGetColumnsWidthHint(unitMin, unitMax); }
+
+    // again, if not overridden, it will fall back on default method
+    virtual wxCoord EstimateTotalWidth() const { return DoEstimateTotalSize(); }
+
+    // forward calls to EstimateTotalWidth()
+    virtual wxCoord EstimateTotalSize() const { return EstimateTotalWidth(); }
+
+    wxCoord GetColumnsWidth(size_t columnMin, size_t columnMax) const
+        { return GetUnitsSize(columnMin, columnMax); }
+};
+
+
+
+// ===========================================================================
+// wxVarHVScrollHelper
+// ===========================================================================
+
+// Provides public API functions targeted at functions with similar names in
+// both wxVScrollHelper and wxHScrollHelper so class scope doesn't need to be
+// specified (since we are using multiple inheritance). It also provides
+// functions to make changing values for both orientations at the same time
+// easier.
+
+class WXDLLEXPORT wxVarHVScrollHelper : public wxVarVScrollHelper,
+                                        public wxVarHScrollHelper
+{
+public:
+    // constructors and such
+    // ---------------------
+
+    // ctor must be given the associated window
+    wxVarHVScrollHelper(wxWindow *winToScroll)
+        : wxVarVScrollHelper(winToScroll), wxVarHScrollHelper(winToScroll) { }
+
+    // operators
+    // ---------
+
+    // set the number of units the window contains for each axis: the derived
+    // class must provide the widths and heights for all units with indices up
+    // to each of the one given here in its OnGetColumnWidth() and
+    // OnGetRowHeight()
+    void SetRowColumnCount(size_t rowCount, size_t columnCount);
+
+
+    // with physical scrolling on, the device origin is changed properly when
+    // a wxPaintDC is prepared, children are actually moved and laid out
+    // properly, and the contents of the window (pixels) are actually moved
+    void EnablePhysicalScrolling(bool vscrolling = true, bool hscrolling = true)
+    {
+        wxVarVScrollHelper::EnablePhysicalScrolling(vscrolling);
+        wxVarHScrollHelper::EnablePhysicalScrolling(hscrolling);
+    }
+
+    // scroll to the specified row/column: it will become the first visible cell in
+    // the window
+    //
+    // return true if we scrolled the window, false if nothing was done
+    bool ScrollToRowColumn(size_t row, size_t column);
+    bool ScrollToRowColumn(const wxPosition &pos)
+        { return ScrollToRowColumn(pos.GetRow(), pos.GetColumn()); }
+
+    // redraw the specified cell
+    virtual void RefreshRowColumn(size_t row, size_t column);
+    virtual void RefreshRowColumn(const wxPosition &pos)
+        { RefreshRowColumn(pos.GetRow(), pos.GetColumn()); }
+
+    // redraw the specified regions (inclusive).  If the target window for
+    // both orientations is the same the rectangle of cells is refreshed; if
+    // the target windows differ the entire client size opposite the
+    // orientation direction is refreshed between the specified limits
+    virtual void RefreshRowsColumns(size_t fromRow, size_t toRow,
+                                    size_t fromColumn, size_t toColumn);
+    virtual void RefreshRowsColumns(const wxPosition &from, const wxPosition &to)
+        { RefreshRowsColumns(from.GetRow(), to.GetRow(), from.GetColumn(), to.GetColumn()); }
+
+    // Override wxPanel::HitTest to use our version
+    virtual wxPosition HitTest(wxCoord x, wxCoord y) const;
+    virtual wxPosition HitTest(const wxPoint &pos) const
+        { return HitTest(pos.x, pos.y); }
+
+    // change the DC origin according to the scroll position. To properly
+    // forward calls to wxWindow::Layout use WX_FORWARD_TO_SCROLL_HELPER()
+    // derived class. We use this version to call both base classes' DoPrepareDC()
+    virtual void DoPrepareDC(wxDC& dc);
+
+    // replacement implementation of wxWindow::Layout virtual method.  To
+    // properly forward calls to wxWindow::Layout use
+    // WX_FORWARD_TO_SCROLL_HELPER() derived class. We use this version to
+    // call both base classes' ScrollLayout()
+    bool ScrollLayout();
 
     // accessors
     // ---------
+
+    // get the number of units this window contains (previously set by
+    // Set[Column/Row/RowColumn/Unit]Count())
+    wxSize GetRowColumnCount() const;
+
+    // get the first currently visible units
+    wxPosition GetVisibleBegin() const;
+    wxPosition GetVisibleEnd() const;
+
+    // is this cell currently visible?
+    bool IsVisible(size_t row, size_t column) const;
+    bool IsVisible(const wxPosition &pos) const
+        { return IsVisible(pos.GetRow(), pos.GetColumn()); }
+};
 
-    // get the number of lines this window contains (previously set by
-    // SetLineCount())
-    size_t GetLineCount() const { return m_lineMax; }
 
-    // get the first currently visible line
-    size_t GetVisibleBegin() const { return m_lineFirst; }
 
-    // get the first currently visible line
-    size_t GetVisibleEnd() const { return m_lineFirst + m_nVisible; }
+#if WXWIN_COMPATIBILITY_2_6 || WXWIN_COMPATIBILITY_2_8
+
+// ===========================================================================
+// wxVarVScrollLegacyAdaptor
+// ===========================================================================
+
+// Provides backwards compatible API for applications originally built using
+// wxVScrolledWindow in 2.6 or 2.8. Originally, wxVScrolledWindow referred
+// to scrolling "lines". We use "units" in wxVarScrollHelperBase to avoid
+// implying any orientation (since the functions are used for both horizontal
+// and vertical scrolling in derived classes). And in the new
+// wxVScrolledWindow and wxHScrolledWindow classes, we refer to them as
+// "rows" and "columns", respectively. This is to help clear some confusion
+// in not only those classes, but also in wxHVScrolledWindow where functions
+// are inherited from both.
 
-    // is this line currently visible?
-    bool IsVisible(size_t line) const
-        { return line >= GetVisibleBegin() && line < GetVisibleEnd(); }
+class WXDLLEXPORT wxVarVScrollLegacyAdaptor : public wxVarVScrollHelper
+{
+public:
+    // constructors and such
+    // ---------------------
+    wxVarVScrollLegacyAdaptor(wxWindow *winToScroll) : wxVarVScrollHelper(winToScroll) { }
 
+    // accessors
+    // ---------
 
-    // this is the same as GetVisibleBegin(), exists to match
+    // this is the same as GetVisibleRowsBegin(), exists to match
     // GetLastVisibleLine() and for backwards compatibility only
-    size_t GetFirstVisibleLine() const { return m_lineFirst; }
+    size_t GetFirstVisibleLine() const { return GetVisibleRowsBegin(); }
 
     // get the last currently visible line
     //
     // this function is unsafe as it returns (size_t)-1 (i.e. a huge positive
-    // number) if the control is empty, use GetVisibleEnd() instead, this one
+    // number) if the control is empty, use GetVisibleRowsEnd() instead, this one
     // is kept for backwards compatibility
-    size_t GetLastVisibleLine() const { return GetVisibleEnd() - 1; }
+    size_t GetLastVisibleLine() const { return GetVisibleRowsEnd() - 1; }
+
+    // "line" to "unit" compatibility functions
+    // ----------------------------------------
+
+    // get the number of lines this window contains (set by SetLineCount())
+    size_t GetLineCount() const { return GetRowCount(); }
+
+    // set the number of lines the helper contains: the derived class must
+    // provide the sizes for all lines with indices up to the one given here
+    // in its OnGetLineHeight()
+    void SetLineCount(size_t count) { SetRowCount(count); }
+
+    // redraw the specified line
+    virtual void RefreshLine(size_t line) { RefreshRow(line); }
+
+    // redraw all lines in the specified range (inclusive)
+    virtual void RefreshLines(size_t from, size_t to) { RefreshRows(from, to); }
+
+    // scroll to the specified line: it will become the first visible line in
+    // the window
+    //
+    // return true if we scrolled the window, false if nothing was done
+    bool ScrollToLine(size_t line) { return ScrollToRow(line); }
 
-    // layout the children (including the sizer if needed)
-    virtual bool Layout();
+    // scroll by the specified number of lines/pages
+    virtual bool ScrollLines(int lines) { return ScrollRows(lines); }
+    virtual bool ScrollPages(int pages) { return ScrollRowPages(pages); }
 
 protected:
     // this function must be overridden in the derived class and it should
-    // return the height of the given line in pixels
+    // return the height of the given row in pixels
     virtual wxCoord OnGetLineHeight(size_t n) const = 0;
 
+    // forwards the calls from base class pure virtual function to pure virtual
+    // OnGetLineHeight instead (backwards compatible name)
+    // note that we don't need to forward OnGetUnitSize() as it is already
+    // forwarded to OnGetRowHeight() in wxVarVScrollHelper
+    virtual wxCoord OnGetRowHeight(size_t n) const { return OnGetLineHeight(n); }
+
     // this function doesn't have to be overridden but it may be useful to do
     // it if calculating the lines heights is a relatively expensive operation
     // as it gives the user code a possibility to calculate several of them at
@@ -158,65 +593,245 @@
     // usual
     virtual void OnGetLinesHint(size_t WXUNUSED(lineMin),
                                 size_t WXUNUSED(lineMax)) const { }
-
-    // when the number of lines changes, we try to estimate the total height
-    // of all lines which is a rather expensive operation in terms of lines
-    // access, so if the user code may estimate the average height
-    // better/faster than we do, it should override this function to implement
-    // its own logic
-    //
-    // this function should return the best guess for the total height it may
-    // make
-    virtual wxCoord EstimateTotalHeight() const;
-
 
-    // the event handlers
-    void OnSize(wxSizeEvent& event);
-    void OnScroll(wxScrollWinEvent& event);
-#if wxUSE_MOUSEWHEEL
-    void OnMouseWheel(wxMouseEvent& event);
-#endif
+    // forwards the calls from base class pure virtual function to pure virtual
+    // OnGetLinesHint instead (backwards compatible name)
+    void OnGetRowsHeightHint(size_t rowMin, size_t rowMax) const
+        { return OnGetLinesHint(rowMin, rowMax); }
 
-    // find the index of the line we need to show at the top of the window such
-    // that the last (fully or partially) visible line is the given one
-    size_t FindFirstFromBottom(size_t lineLast, bool fullyVisible = false);
 
     // get the total height of the lines between lineMin (inclusive) and
     // lineMax (exclusive)
-    wxCoord GetLinesHeight(size_t lineMin, size_t lineMax) const;
+    wxCoord GetLinesHeight(size_t lineMin, size_t lineMax) const
+        { return GetRowsHeight(lineMin, lineMax); }
+};
 
-    // update the thumb size shown by the scrollbar
-    void UpdateScrollbar();
+#else
 
-    // remove the scrollbar completely because we don't need it
-    void RemoveScrollbar();
+// shortcut to avoid checking compatibility modes later
+// remove this and all references to wxVarVScrollLegacyAdapter once
+// wxWidgets 2.6 and 2.8 compatibility is removed
+typedef wxVarVScrollLegacyAdapter wxVarVScrollHelper;
 
-private:
-    // common part of all ctors
-    void Init();
+#endif // WXWIN_COMPATIBILITY_2_6 || WXWIN_COMPATIBILITY_2_8
 
 
-    // the total number of (logical) lines
-    size_t m_lineMax;
 
-    // the total (estimated) height
-    wxCoord m_heightTotal;
+#define WX_FORWARD_TO_VAR_SCROLL_HELPER()                                     \
+public:                                                                       \
+    virtual void PrepareDC(wxDC& dc) { DoPrepareDC(dc); }                     \
+    virtual bool Layout() { return ScrollLayout(); }
 
-    // the first currently visible line
-    size_t m_lineFirst;
 
-    // the number of currently visible lines (including the last, possibly only
-    // partly, visible one)
-    size_t m_nVisible;
 
-    // accumulated mouse wheel rotation
-#if wxUSE_MOUSEWHEEL
-    int m_sumWheelRotation;
-#endif
+// ===========================================================================
+// wxVScrolledWindow
+// ===========================================================================
+
+// In the name of this class, "V" may stand for "variable" because it can be
+// used for scrolling rows of variable heights; "virtual", because it is not
+// necessary to know the heights of all rows in advance -- only those which
+// are shown on the screen need to be measured; or even "vertical", because
+// this class only supports scrolling vertically.
+
+// In any case, this is a generalization of the wxScrolledWindow class which
+// can be only used when all rows have the same heights. It lacks some other
+// wxScrolledWindow features however, notably it can't scroll only a rectangle
+// of the window and not its entire client area.
+
+class WXDLLEXPORT wxVScrolledWindow : public wxPanel,
+                                      public wxVarVScrollLegacyAdaptor
+{
+public:
+    // constructors and such
+    // ---------------------
+
+    // default ctor, you must call Create() later
+    wxVScrolledWindow() : wxVarVScrollLegacyAdaptor(this) { }
+
+    // normal ctor, no need to call Create() after this one
+    //
+    // note that wxVSCROLL is always automatically added to our style, there is
+    // no need to specify it explicitly
+    wxVScrolledWindow(wxWindow *parent,
+                      wxWindowID id = wxID_ANY,
+                      const wxPoint& pos = wxDefaultPosition,
+                      const wxSize& size = wxDefaultSize,
+                      long style = 0,
+                      const wxString& name = wxPanelNameStr)
+    : wxVarVScrollLegacyAdaptor(this)
+    {
+        (void)Create(parent, id, pos, size, style, name);
+    }
+
+    // same as the previous ctor but returns status code: true if ok
+    //
+    // just as with the ctor above, wxVSCROLL style is always used, there is no
+    // need to specify it
+    bool Create(wxWindow *parent,
+                wxWindowID id = wxID_ANY,
+                const wxPoint& pos = wxDefaultPosition,
+                const wxSize& size = wxDefaultSize,
+                long style = 0,
+                const wxString& name = wxPanelNameStr)
+    {
+        return wxPanel::Create(parent, id, pos, size, style | wxVSCROLL, name);
+    }
+
+    // Make sure we prefer our version of HitTest rather than wxWindow's
+    int HitTest(wxCoord WXUNUSED(x), wxCoord y) const { return wxVarVScrollHelper::HitTest(y); }
+    int HitTest(const wxPoint& pt) const { return HitTest(pt.x, pt.y); }
+
+    WX_FORWARD_TO_VAR_SCROLL_HELPER()
 
-    DECLARE_EVENT_TABLE()
+#ifdef __WXMAC__
+protected:
+    virtual void UpdateMacScrollWindow() { Update(); }
+#endif // __WXMAC__
+
+private:
     DECLARE_NO_COPY_CLASS(wxVScrolledWindow)
     DECLARE_ABSTRACT_CLASS(wxVScrolledWindow)
+};
+
+
+
+// ===========================================================================
+// wxHScrolledWindow
+// ===========================================================================
+
+// In the name of this class, "H" stands for "horizontal" because it can be
+// used for scrolling columns of variable widths. It is not necessary to know
+// the widths of all columns in advance -- only those which are shown on the
+// screen need to be measured.
+
+// This is a generalization of the wxScrolledWindow class which can be only
+// used when all columns have the same width. It lacks some other
+// wxScrolledWindow features however, notably it can't scroll only a rectangle
+// of the window and not its entire client area.
+
+class WXDLLEXPORT wxHScrolledWindow : public wxPanel,
+                                      public wxVarHScrollHelper
+{
+public:
+    // constructors and such
+    // ---------------------
+
+    // default ctor, you must call Create() later
+    wxHScrolledWindow() : wxVarHScrollHelper(this) { }
+
+    // normal ctor, no need to call Create() after this one
+    //
+    // note that wxHSCROLL is always automatically added to our style, there is
+    // no need to specify it explicitly
+    wxHScrolledWindow(wxWindow *parent,
+                      wxWindowID id = wxID_ANY,
+                      const wxPoint& pos = wxDefaultPosition,
+                      const wxSize& size = wxDefaultSize,
+                      long style = 0,
+                      const wxString& name = wxPanelNameStr)
+    : wxVarHScrollHelper(this)
+    {
+        (void)Create(parent, id, pos, size, style, name);
+    }
+
+    // same as the previous ctor but returns status code: true if ok
+    //
+    // just as with the ctor above, wxHSCROLL style is always used, there is no
+    // need to specify it
+    bool Create(wxWindow *parent,
+                wxWindowID id = wxID_ANY,
+                const wxPoint& pos = wxDefaultPosition,
+                const wxSize& size = wxDefaultSize,
+                long style = 0,
+                const wxString& name = wxPanelNameStr)
+    {
+        return wxPanel::Create(parent, id, pos, size, style | wxHSCROLL, name);
+    }
+
+    // Make sure we prefer our version of HitTest rather than wxWindow's
+    int HitTest(wxCoord x, wxCoord WXUNUSED(y)) const { return wxVarHScrollHelper::HitTest(x); }
+    int HitTest(const wxPoint& pt) const { return HitTest(pt.x, pt.y); }
+
+    WX_FORWARD_TO_VAR_SCROLL_HELPER()
+
+#ifdef __WXMAC__
+protected:
+    virtual void UpdateMacScrollWindow() { Update(); }
+#endif // __WXMAC__
+
+private:
+    DECLARE_NO_COPY_CLASS(wxHScrolledWindow)
+    DECLARE_ABSTRACT_CLASS(wxHScrolledWindow)
+};
+
+
+
+// ===========================================================================
+// wxHVScrolledWindow
+// ===========================================================================
+
+// This window inherits all functionality of both vertical and horizontal
+// scrolled windows automatically handling everything needed to scroll both
+// axis simultaneously.
+
+class WXDLLEXPORT wxHVScrolledWindow : public wxPanel,
+                                       public wxVarHVScrollHelper
+{
+public:
+    // constructors and such
+    // ---------------------
+
+    // default ctor, you must call Create() later
+    wxHVScrolledWindow()
+        : wxPanel(),
+          wxVarHVScrollHelper(this) { }
+
+    // normal ctor, no need to call Create() after this one
+    //
+    // note that wxVSCROLL and wxHSCROLL are always automatically added to our
+    // style, there is no need to specify them explicitly
+    wxHVScrolledWindow(wxWindow *parent,
+                       wxWindowID id = wxID_ANY,
+                       const wxPoint& pos = wxDefaultPosition,
+                       const wxSize& size = wxDefaultSize,
+                       long style = 0,
+                       const wxString& name = wxPanelNameStr)
+        : wxPanel(),
+          wxVarHVScrollHelper(this) 
+    {
+        (void)Create(parent, id, pos, size, style, name);
+    }
+
+    // same as the previous ctor but returns status code: true if ok
+    //
+    // just as with the ctor above, wxVSCROLL and wxHSCROLL styles are always
+    // used, there is no need to specify them
+    bool Create(wxWindow *parent,
+                wxWindowID id = wxID_ANY,
+                const wxPoint& pos = wxDefaultPosition,
+                const wxSize& size = wxDefaultSize,
+                long style = 0,
+                const wxString& name = wxPanelNameStr)
+    {
+        return wxPanel::Create(parent, id, pos, size,
+                style | wxVSCROLL | wxHSCROLL, name);
+    }
+
+    // Make sure we prefer our version of HitTest rather than wxWindow's
+    wxPosition HitTest(wxCoord x, wxCoord y) const { return wxVarHVScrollHelper::HitTest(x, y); }
+    wxPosition HitTest(const wxPoint &pt) const { return HitTest(pt.x, pt.y); }
+
+    WX_FORWARD_TO_VAR_SCROLL_HELPER()
+
+#ifdef __WXMAC__
+protected:
+    virtual void UpdateMacScrollWindow() { Update(); }
+#endif // __WXMAC__
+
+private:
+    DECLARE_NO_COPY_CLASS(wxHVScrolledWindow)
+    DECLARE_ABSTRACT_CLASS(wxHVScrolledWindow)
 };
 
 #endif // _WX_VSCROLL_H_
Index: samples/vscroll/vstest.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/samples/vscroll/vstest.cpp,v
retrieving revision 1.13
diff -u -B -r1.13 vstest.cpp
--- samples/vscroll/vstest.cpp	2007/02/04 00:34:14	1.13
+++ samples/vscroll/vstest.cpp	2007/04/06 20:52:22
@@ -2,7 +2,7 @@
 // Name:        samples/vscroll/vstest.cpp
 // Purpose:     VScroll wxWidgets sample
 // Author:      Vadim Zeitlin
-// Modified by:
+// Modified by: Brad Anderson
 // Created:     04/01/98
 // RCS-ID:      $Id: vstest.cpp,v 1.13 2007/02/04 00:34:14 VZ Exp $
 // Copyright:   (c) 2003 Vadim Zeitlin <vadim@wxwidgets.org>
@@ -45,11 +45,17 @@
 #endif
 
 // ----------------------------------------------------------------------------
+// definitions
+// ----------------------------------------------------------------------------
+
+#define MAX_LINES 10000
+
+// ----------------------------------------------------------------------------
 // private classes
 // ----------------------------------------------------------------------------
 
 // Define a new application type, each program should derive a class from wxApp
-class VScrollApp : public wxApp
+class VarScrollApp : public wxApp
 {
 public:
     // create our main window
@@ -57,14 +63,17 @@
 };
 
 // Define a new frame type: this is going to be our main frame
-class VScrollFrame : public wxFrame
+class VarScrollFrame : public wxFrame
 {
 public:
     // ctor
-    VScrollFrame();
+    VarScrollFrame();
 
     // event handlers (these functions should _not_ be virtual)
     void OnQuit(wxCommandEvent& event);
+    void OnModeVScroll(wxCommandEvent& event);
+    void OnModeHScroll(wxCommandEvent& event);
+    void OnModeHVScroll(wxCommandEvent& event);
     void OnAbout(wxCommandEvent& event);
 
     void OnSize(wxSizeEvent& event)
@@ -82,6 +91,9 @@
     }
 
 private:
+    // either a wxVScrolledWindow or a wxHVScrolled window, depending on current mode
+    wxPanel *m_scrollWindow;
+
     // any class wishing to process wxWidgets events must use this macro
     DECLARE_EVENT_TABLE()
 };
@@ -93,8 +105,12 @@
     {
         m_frame = frame;
 
-        SetLineCount(200);
+        SetLineCount(MAX_LINES);
 
+        int i;
+        for ( i = 0; i < MAX_LINES; ++i )
+            m_heights[i] = rand()%25+16; // low: 15; high: 40
+
         m_changed = true;
     }
 
@@ -116,21 +132,23 @@
     {
         wxPaintDC dc(this);
 
-        dc.SetPen(*wxBLACK_DASHED_PEN);
+        dc.SetPen(*wxBLACK_PEN);
 
-        const size_t lineFirst = GetFirstVisibleLine(),
-                     lineLast = GetLastVisibleLine();
+        const size_t lineFirst = GetVisibleBegin(),
+                     lineLast = GetVisibleEnd();
 
         const wxCoord hText = dc.GetCharHeight();
 
+        wxSize clientSize = GetClientSize();
+
         wxCoord y = 0;
-        for ( size_t line = lineFirst; line <= lineLast; line++ )
+        for ( size_t line = lineFirst; line < lineLast; line++ )
         {
-            dc.DrawLine(0, y, 1000, y);
+            dc.DrawLine(0, y, clientSize.GetWidth(), y);
 
             wxCoord hLine = OnGetLineHeight(line);
             dc.DrawText(wxString::Format(_T("Line %lu"), (unsigned long)line),
-                        0, y + (hLine - hText) / 2);
+                        2, y + (hLine - hText) / 2);
 
             y += hLine;
             dc.DrawLine(0, y, 1000, y);
@@ -144,17 +162,27 @@
         event.Skip();
     }
 
+    void OnMouse(wxMouseEvent& event)
+    {
+        if(event.LeftDown())
+            CaptureMouse();
+        else if(event.LeftUp())
+            ReleaseMouse();
+        event.Skip();
+    }
 
     virtual wxCoord OnGetLineHeight(size_t n) const
     {
         wxASSERT( n < GetLineCount() );
 
-        return n % 2 ? 15 : 30; // 15 + 2*n
+        return m_heights[n];
     }
 
 private:
     wxFrame *m_frame;
 
+    int m_heights[MAX_LINES];
+
     bool m_changed;
 
     DECLARE_EVENT_TABLE()
@@ -164,6 +192,233 @@
     EVT_IDLE(VScrollWindow::OnIdle)
     EVT_PAINT(VScrollWindow::OnPaint)
     EVT_SCROLLWIN(VScrollWindow::OnScroll)
+    EVT_MOUSE_EVENTS(VScrollWindow::OnMouse)
+END_EVENT_TABLE()
+
+class HScrollWindow : public wxHScrolledWindow
+{
+public:
+    HScrollWindow(wxFrame *frame) : wxHScrolledWindow(frame, wxID_ANY)
+    {
+        m_frame = frame;
+
+        SetColumnCount(MAX_LINES);
+
+        int i;
+        for ( i = 0; i < MAX_LINES; ++i )
+            m_heights[i] = rand()%25+16; // low: 15; high: 40
+
+        m_changed = true;
+    }
+
+    void OnIdle(wxIdleEvent&)
+    {
+#if wxUSE_STATUSBAR
+        m_frame->SetStatusText(wxString::Format
+                               (
+                                    _T("Page size = %d, pos = %d, max = %d"),
+                                    GetScrollThumb(wxVERTICAL),
+                                    GetScrollPos(wxVERTICAL),
+                                    GetScrollRange(wxVERTICAL)
+                               ));
+#endif // wxUSE_STATUSBAR
+        m_changed = false;
+    }
+
+    void OnPaint(wxPaintEvent&)
+    {
+        wxPaintDC dc(this);
+
+        dc.SetPen(*wxBLACK_PEN);
+
+        const size_t lineFirst = GetVisibleBegin(),
+                     lineLast = GetVisibleEnd();
+
+        const wxCoord hText = dc.GetCharHeight();
+
+        wxSize clientSize = GetClientSize();
+
+        wxCoord x = 0;
+        for ( size_t line = lineFirst; line < lineLast; line++ )
+        {
+            dc.DrawLine(x, 0, x, clientSize.GetHeight());
+
+            wxCoord wLine = OnGetColumnWidth(line);
+            dc.DrawRotatedText(wxString::Format(_T("Line %lu"), (unsigned long)line),
+                               x + (wLine - hText) / 2, clientSize.GetHeight() - 5, 90);
+
+            x += wLine;
+            dc.DrawLine(x, 0, x, 1000);
+        }
+    }
+
+    void OnScroll(wxScrollWinEvent& event)
+    {
+        m_changed = true;
+
+        event.Skip();
+    }
+
+    void OnMouse(wxMouseEvent& event)
+    {
+        if(event.LeftDown())
+            CaptureMouse();
+        else if(event.LeftUp())
+            ReleaseMouse();
+        event.Skip();
+    }
+
+    virtual wxCoord OnGetColumnWidth(size_t n) const
+    {
+        wxASSERT( n < GetColumnCount() );
+
+        return m_heights[n];
+    }
+
+private:
+    wxFrame *m_frame;
+
+    int m_heights[MAX_LINES];
+
+    bool m_changed;
+
+    DECLARE_EVENT_TABLE()
+};
+
+BEGIN_EVENT_TABLE(HScrollWindow, wxHScrolledWindow)
+    EVT_IDLE(HScrollWindow::OnIdle)
+    EVT_PAINT(HScrollWindow::OnPaint)
+    EVT_SCROLLWIN(HScrollWindow::OnScroll)
+    EVT_MOUSE_EVENTS(HScrollWindow::OnMouse)
+END_EVENT_TABLE()
+
+class HVScrollWindow : public wxHVScrolledWindow
+{
+public:
+    HVScrollWindow(wxFrame *frame) : wxHVScrolledWindow(frame, wxID_ANY)
+    {
+        m_frame = frame;
+
+        SetRowColumnCount(MAX_LINES, MAX_LINES);
+        
+        int i;
+        for ( i = 0; i < MAX_LINES; ++i )
+        {
+            m_heights[i] = rand()%30+31; // low: 30; high: 60
+            m_widths[i] = rand()%30+61;  // low: 60; high: 90
+        }
+
+        m_changed = true;
+    }
+
+    void OnIdle(wxIdleEvent&)
+    {
+#if wxUSE_STATUSBAR
+        m_frame->SetStatusText(wxString::Format
+                               (
+                                    _T("Page size = %d rows %d columns; pos = row: %d, column: %d; max = %d rows, %d columns"),
+                                    GetScrollThumb(wxVERTICAL),
+                                    GetScrollThumb(wxHORIZONTAL),
+                                    GetScrollPos(wxVERTICAL),
+                                    GetScrollPos(wxHORIZONTAL),
+                                    GetScrollRange(wxVERTICAL),
+                                    GetScrollRange(wxHORIZONTAL)
+                               ));
+#endif // wxUSE_STATUSBAR
+        m_changed = false;
+    }
+
+    void OnPaint(wxPaintEvent&)
+    {
+        wxPaintDC dc(this);
+
+        dc.SetPen(*wxBLACK_PEN);
+
+        const size_t rowFirst = GetVisibleRowsBegin(),
+                     rowLast = GetVisibleRowsEnd();
+        const size_t columnFirst = GetVisibleColumnsBegin(),
+                     columnLast = GetVisibleColumnsEnd();
+        
+        const wxCoord hText = dc.GetCharHeight();
+
+        wxSize clientSize = GetClientSize();
+
+        wxCoord y = 0;
+        wxCoord x = 0;
+        for ( size_t row = rowFirst; row < rowLast; row++ )
+        {
+            wxCoord rowHeight = OnGetRowHeight(row);
+            dc.DrawLine(0, y, clientSize.GetWidth(), y);
+
+            x = 0;
+            for ( size_t col = columnFirst; col < columnLast; col++ )
+            {
+                wxCoord colWidth = OnGetColumnWidth(col);
+
+                if ( row == rowFirst )
+                    dc.DrawLine(x, 0, x, clientSize.GetHeight());
+
+                dc.DrawText(wxString::Format(_T("Row %lu"), (unsigned long)row),
+                            x + 2, y + rowHeight / 2 - hText);
+                dc.DrawText(wxString::Format(_T("Col %lu"), (unsigned long)col),
+                            x + 2, y + rowHeight / 2);
+                
+                x += colWidth;
+                if ( row == rowFirst)
+                    dc.DrawLine(x, 0, x, clientSize.GetHeight());
+            }
+            
+            y += rowHeight;
+            dc.DrawLine(0, y, clientSize.GetWidth(), y);
+        }
+    }
+
+    void OnScroll(wxScrollWinEvent& event)
+    {
+        m_changed = true;
+
+        event.Skip();
+    }
+
+    void OnMouse(wxMouseEvent& event)
+    {
+        if(event.LeftDown())
+            CaptureMouse();
+        else if(event.LeftUp())
+            ReleaseMouse();
+        event.Skip();
+    }
+
+    virtual wxCoord OnGetRowHeight(size_t n) const
+    {
+        wxASSERT( n < GetRowCount() );
+
+        return m_heights[n];
+    }
+
+    virtual wxCoord OnGetColumnWidth(size_t n) const
+    {
+        wxASSERT( n < GetColumnCount() );
+
+        return m_widths[n];
+    }
+
+private:
+    wxFrame *m_frame;
+
+    int m_heights[MAX_LINES];
+    int m_widths[MAX_LINES];
+
+    bool m_changed;
+
+    DECLARE_EVENT_TABLE()
+};
+
+BEGIN_EVENT_TABLE(HVScrollWindow, wxHVScrolledWindow)
+    EVT_IDLE(HVScrollWindow::OnIdle)
+    EVT_PAINT(HVScrollWindow::OnPaint)
+    EVT_SCROLLWIN(HVScrollWindow::OnScroll)
+    EVT_MOUSE_EVENTS(HVScrollWindow::OnMouse)
 END_EVENT_TABLE()
 
 // ----------------------------------------------------------------------------
@@ -179,7 +434,11 @@
     // it is important for the id corresponding to the "About" command to have
     // this standard value as otherwise it won't be handled properly under Mac
     // (where it is special and put into the "Apple" menu)
-    VScroll_About = wxID_ABOUT
+    VScroll_About = wxID_ABOUT,
+
+    VScroll_VScrollMode = wxID_HIGHEST + 1,
+    VScroll_HScrollMode,
+    VScroll_HVScrollMode
 };
 
 // ----------------------------------------------------------------------------
@@ -189,18 +448,21 @@
 // the event tables connect the wxWidgets events with the functions (event
 // handlers) which process them. It can be also done at run-time, but for the
 // simple menu events like this the static method is much simpler.
-BEGIN_EVENT_TABLE(VScrollFrame, wxFrame)
-    EVT_MENU(VScroll_Quit,  VScrollFrame::OnQuit)
-    EVT_MENU(VScroll_About, VScrollFrame::OnAbout)
-    EVT_SIZE(VScrollFrame::OnSize)
+BEGIN_EVENT_TABLE(VarScrollFrame, wxFrame)
+    EVT_MENU(VScroll_Quit,  VarScrollFrame::OnQuit)
+    EVT_MENU(VScroll_VScrollMode, VarScrollFrame::OnModeVScroll)
+    EVT_MENU(VScroll_HScrollMode, VarScrollFrame::OnModeHScroll)
+    EVT_MENU(VScroll_HVScrollMode, VarScrollFrame::OnModeHVScroll)
+    EVT_MENU(VScroll_About, VarScrollFrame::OnAbout)
+    EVT_SIZE(VarScrollFrame::OnSize)
 END_EVENT_TABLE()
 
 // Create a new application object: this macro will allow wxWidgets to create
 // the application object during program execution (it's better than using a
 // static object for many reasons) and also declares the accessor function
-// wxGetApp() which will return the reference of the right type (i.e. VScrollApp and
+// wxGetApp() which will return the reference of the right type (i.e. VarScrollApp and
 // not wxApp)
-IMPLEMENT_APP(VScrollApp)
+IMPLEMENT_APP(VarScrollApp)
 
 // ============================================================================
 // implementation
@@ -211,13 +473,13 @@
 // ----------------------------------------------------------------------------
 
 // 'Main program' equivalent: the program execution "starts" here
-bool VScrollApp::OnInit()
+bool VarScrollApp::OnInit()
 {
     if ( !wxApp::OnInit() )
         return false;
 
     // create the main application window
-    VScrollFrame *frame = new VScrollFrame;
+    VarScrollFrame *frame = new VarScrollFrame;
 
     // and show it (the frames, unlike simple controls, are not shown when
     // created initially)
@@ -232,12 +494,13 @@
 // ----------------------------------------------------------------------------
 
 // frame constructor
-VScrollFrame::VScrollFrame()
-            : wxFrame(NULL,
-                      wxID_ANY,
-                      _T("VScroll wxWidgets Sample"),
-                      wxDefaultPosition,
-                      wxSize(400, 350))
+VarScrollFrame::VarScrollFrame()
+               : wxFrame(NULL,
+                         wxID_ANY,
+                         _T("VScroll wxWidgets Sample"),
+                         wxDefaultPosition,
+                         wxSize(400, 350)),
+                 m_scrollWindow(NULL)
 {
     // set the frame icon
     SetIcon(wxICON(sample));
@@ -246,15 +509,36 @@
     // create a menu bar
     wxMenu *menuFile = new wxMenu;
 
+    wxMenu *menuMode = new wxMenu;
+
     // the "About" item should be in the help menu
     wxMenu *menuHelp = new wxMenu;
     menuHelp->Append(VScroll_About, _T("&About...\tF1"), _T("Show about dialog"));
 
+#ifdef wxHAS_RADIO_MENU_ITEMS
+    menuMode->AppendRadioItem(VScroll_VScrollMode, _T("&Vertical\tAlt-V"),
+                              _T("Vertical scrolling only"));
+    menuMode->AppendRadioItem(VScroll_HScrollMode, _T("&Horizontal\tAlt-H"),
+                              _T("Horizontal scrolling only"));
+    menuMode->AppendRadioItem(VScroll_HVScrollMode,
+                              _T("Hori&zontal/Vertical\tAlt-Z"),
+                              _T("Horizontal and vertical scrolling"));
+    menuMode->Check(VScroll_VScrollMode, true);
+#else
+    menuMode->Append(VScroll_VScrollMode, _T("&Vertical\tAlt-V"),
+                     _T("Vertical scrolling only"));
+    menuMode->Append(VScroll_HScrollMode, _T("&Horizontal\tAlt-H"),
+                     _T("Horizontal scrolling only"));
+    menuMode->Append(VScroll_HVScrollMode, _T("Hori&zontal/Vertical\tAlt-Z"),
+                     _T("Horizontal and vertical scrolling"));
+#endif
+
     menuFile->Append(VScroll_Quit, _T("E&xit\tAlt-X"), _T("Quit this program"));
 
     // now append the freshly created menu to the menu bar...
     wxMenuBar *menuBar = new wxMenuBar;
     menuBar->Append(menuFile, _T("&File"));
+    menuBar->Append(menuMode, _T("&Mode"));
     menuBar->Append(menuHelp, _T("&Help"));
 
     // ... and attach this menu bar to the frame
@@ -265,26 +549,62 @@
     // create a status bar just for fun (by default with 1 pane only)
     CreateStatusBar(2);
     SetStatusText(_T("Welcome to wxWidgets!"));
+    int widths[2];
+    widths[0] = -1;
+    widths[1] = 100;
+    SetStatusWidths(2, widths);
 #endif // wxUSE_STATUSBAR
 
     // create our one and only child -- it will take our entire client area
-    new VScrollWindow(this);
+    if ( menuMode->IsChecked(VScroll_VScrollMode) )
+        m_scrollWindow = new VScrollWindow(this);
+    else if ( menuMode->IsChecked(VScroll_HScrollMode) )
+        m_scrollWindow = new HScrollWindow(this);
+    else
+        m_scrollWindow = new HVScrollWindow(this);
 }
 
 // ----------------------------------------------------------------------------
 // event handlers
 // ----------------------------------------------------------------------------
 
-void VScrollFrame::OnQuit(wxCommandEvent& WXUNUSED(event))
+void VarScrollFrame::OnQuit(wxCommandEvent& WXUNUSED(event))
 {
     // true is to force the frame to close
     Close(true);
 }
+
+void VarScrollFrame::OnModeVScroll(wxCommandEvent& WXUNUSED(event))
+{
+    if ( m_scrollWindow )
+        m_scrollWindow->Destroy();
+    
+    m_scrollWindow = new VScrollWindow(this);
+    SendSizeEvent();
+}
+
+void VarScrollFrame::OnModeHScroll(wxCommandEvent& WXUNUSED(event))
+{
+    if ( m_scrollWindow )
+        m_scrollWindow->Destroy();
+    
+    m_scrollWindow = new HScrollWindow(this);
+    SendSizeEvent();
+}
+
+void VarScrollFrame::OnModeHVScroll(wxCommandEvent& WXUNUSED(event))
+{
+    if ( m_scrollWindow )
+        m_scrollWindow->Destroy();
+
+    m_scrollWindow = new HVScrollWindow(this);
+    SendSizeEvent();
+}
 
-void VScrollFrame::OnAbout(wxCommandEvent& WXUNUSED(event))
+void VarScrollFrame::OnAbout(wxCommandEvent& WXUNUSED(event))
 {
     wxMessageBox(_T("VScroll shows how to implement scrolling with\n")
-                 _T("variable line heights.\n")
+                 _T("variable line widths and heights.\n")
                  _T("(c) 2003 Vadim Zeitlin"),
                  _T("About VScroll"),
                  wxOK | wxICON_INFORMATION,
Index: src/common/event.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/common/event.cpp,v
retrieving revision 1.192
diff -u -B -r1.192 event.cpp
--- src/common/event.cpp	2007/03/07 11:34:43	1.192
+++ src/common/event.cpp	2007/04/06 20:52:23
@@ -32,6 +32,7 @@
     #include "wx/utils.h"
     #include "wx/stopwatch.h"
     #include "wx/module.h"
+    #include "wx/utils.h"
 
     #if wxUSE_GUI
         #include "wx/control.h"
@@ -533,6 +534,24 @@
     m_middleDown = false;
     m_x = 0;
     m_y = 0;
+    m_wheelRotation = 0;
+    m_wheelDelta = 0;
+    m_linesPerAction = 0;
+    m_wheelAxis = 0;
+}
+
+wxMouseEvent::wxMouseEvent(wxMouseState ms, wxEventType commandType)
+{
+    m_eventType = commandType;
+    m_metaDown = ms.MetaDown();
+    m_altDown = ms.AltDown();
+    m_controlDown = ms.ControlDown();
+    m_shiftDown = ms.ShiftDown();
+    m_leftDown = ms.LeftDown();
+    m_rightDown = ms.RightDown();
+    m_middleDown = ms.MiddleDown();
+    m_x = ms.GetX();
+    m_y = ms.GetY();
     m_wheelRotation = 0;
     m_wheelDelta = 0;
     m_linesPerAction = 0;
Index: src/generic/htmllbox.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/generic/htmllbox.cpp,v
retrieving revision 1.30
diff -u -B -r1.30 htmllbox.cpp
--- src/generic/htmllbox.cpp	2007/03/07 20:58:17	1.30
+++ src/generic/htmllbox.cpp	2007/04/06 20:52:23
@@ -327,14 +327,14 @@
 {
     m_cache->InvalidateRange(line, line);
 
-    wxVListBox::RefreshLine(line);
+    wxVListBox::RefreshRow(line);
 }
 
 void wxHtmlListBox::RefreshLines(size_t from, size_t to)
 {
     m_cache->InvalidateRange(from, to);
 
-    wxVListBox::RefreshLines(from, to);
+    wxVListBox::RefreshRows(from, to);
 }
 
 void wxHtmlListBox::RefreshAll()
Index: src/generic/vlbox.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/generic/vlbox.cpp,v
retrieving revision 1.33
diff -u -B -r1.33 vlbox.cpp
--- src/generic/vlbox.cpp	2007/03/11 01:28:06	1.33
+++ src/generic/vlbox.cpp	2007/04/06 20:52:23
@@ -111,7 +111,7 @@
         m_selStore->SetItemCount(count);
     }
 
-    SetLineCount(count);
+    SetRowCount(count);
 }
 
 // ----------------------------------------------------------------------------
@@ -312,7 +312,7 @@
     for ( size_t n = GetVisibleBegin(), end = GetVisibleEnd(); n < end; n++ )
     {
         if ( IsSelected(n) )
-            RefreshLine(n);
+            RefreshRow(n);
     }
 }
 
Index: src/generic/vscroll.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/generic/vscroll.cpp,v
retrieving revision 1.31
diff -u -B -r1.31 vscroll.cpp
--- src/generic/vscroll.cpp	2007/03/12 20:29:34	1.31
+++ src/generic/vscroll.cpp	2007/04/06 20:52:23
@@ -2,7 +2,7 @@
 // Name:        src/generic/vscroll.cpp
 // Purpose:     wxVScrolledWindow implementation
 // Author:      Vadim Zeitlin
-// Modified by:
+// Modified by: Brad Anderson
 // Created:     30.05.03
 // RCS-ID:      $Id: vscroll.cpp,v 1.31 2007/03/12 20:29:34 VZ Exp $
 // Copyright:   (c) 2003 Vadim Zeitlin <vadim@wxwindows.org>
@@ -30,348 +30,557 @@
 
 #include "wx/vscroll.h"
 
+// ============================================================================
+// wxVarScrollHelperEvtHandler declaration
+// ============================================================================
+
 // ----------------------------------------------------------------------------
-// event tables
+// wxScrollHelperEvtHandler: intercept the events from the window and forward
+// them to wxVarScrollHelperBase
 // ----------------------------------------------------------------------------
 
-BEGIN_EVENT_TABLE(wxVScrolledWindow, wxPanel)
-    EVT_SIZE(wxVScrolledWindow::OnSize)
-    EVT_SCROLLWIN(wxVScrolledWindow::OnScroll)
-#if wxUSE_MOUSEWHEEL
-    EVT_MOUSEWHEEL(wxVScrolledWindow::OnMouseWheel)
-#endif
-END_EVENT_TABLE()
+class WXDLLEXPORT wxVarScrollHelperEvtHandler : public wxEvtHandler
+{
+public:
+    wxVarScrollHelperEvtHandler(wxVarScrollHelperBase *scrollHelper)
+    {
+        m_scrollHelper = scrollHelper;
+    }
 
+    virtual bool ProcessEvent(wxEvent& event);
 
+private:
+    wxVarScrollHelperBase *m_scrollHelper;
+
+    DECLARE_NO_COPY_CLASS(wxVarScrollHelperEvtHandler)
+};
+
 // ============================================================================
-// implementation
+// wxVarScrollHelperEvtHandler implementation
 // ============================================================================
 
-IMPLEMENT_ABSTRACT_CLASS(wxVScrolledWindow, wxPanel)
+bool wxVarScrollHelperEvtHandler::ProcessEvent(wxEvent& event)
+{
+    wxEventType evType = event.GetEventType();
+
+    // pass it on to the real handler
+    bool processed = wxEvtHandler::ProcessEvent(event);
+
+    // always process the size events ourselves, even if the user code handles
+    // them as well, as we need to AdjustScrollbars()
+    //
+    // NB: it is important to do it after processing the event in the normal
+    //     way as HandleOnSize() may generate a wxEVT_SIZE itself if the
+    //     scrollbar[s] (dis)appear and it should be seen by the user code
+    //     after this one
+    if ( evType == wxEVT_SIZE )
+    {
+        m_scrollHelper->HandleOnSize((wxSizeEvent &)event);
+
+        return !event.GetSkipped();
+    }
+
+    if ( processed )
+    {
+        // normally, nothing more to do here - except if we have a command
+        // event
+        if ( event.IsCommandEvent() )
+        {
+            return true;
+        }
+    }
+
+    // reset the skipped flag (which might have been set to true in
+    // ProcessEvent() above) to be able to test it below
+    bool wasSkipped = event.GetSkipped();
+    if ( wasSkipped )
+        event.Skip(false);
+
+    // reset the skipped flag to false as it might have been set to true in
+    // ProcessEvent() above
+    event.Skip(false);
+
+    if ( evType == wxEVT_SCROLLWIN_TOP ||
+         evType == wxEVT_SCROLLWIN_BOTTOM ||
+         evType == wxEVT_SCROLLWIN_LINEUP ||
+         evType == wxEVT_SCROLLWIN_LINEDOWN ||
+         evType == wxEVT_SCROLLWIN_PAGEUP ||
+         evType == wxEVT_SCROLLWIN_PAGEDOWN ||
+         evType == wxEVT_SCROLLWIN_THUMBTRACK ||
+         evType == wxEVT_SCROLLWIN_THUMBRELEASE )
+    {
+        m_scrollHelper->HandleOnScroll((wxScrollWinEvent &)event);
+        if ( !event.GetSkipped() )
+        {
+            // it makes sense to indicate that we processed the message as we
+            // did scroll the window (and also notice that wxAutoScrollTimer
+            // relies on our return value for continuous scrolling)
+            processed = true;
+            wasSkipped = false;
+        }
+    }
+#if wxUSE_MOUSEWHEEL
+    else if ( evType == wxEVT_MOUSEWHEEL )
+    {
+        m_scrollHelper->HandleOnMouseWheel((wxMouseEvent &)event);
+    }
+#endif // wxUSE_MOUSEWHEEL
 
+    if ( processed )
+        event.Skip(wasSkipped);
+
+    return processed;
+}
+
+
+// ============================================================================
+// wxVarScrollHelperBase implementation
+// ============================================================================
+
 // ----------------------------------------------------------------------------
-// initialization
+// wxVarScrollHelperBase initialization
 // ----------------------------------------------------------------------------
 
-void wxVScrolledWindow::Init()
+wxVarScrollHelperBase::wxVarScrollHelperBase(wxWindow *win)
 {
-    // we're initially empty
-    m_lineMax =
-    m_lineFirst = 0;
-
-    // this one should always be strictly positive
-    m_nVisible = 1;
+    wxASSERT_MSG( win, _T("associated window can't be NULL in wxVarScrollHelperBase") );
 
-    m_heightTotal = 0;
-
 #if wxUSE_MOUSEWHEEL
     m_sumWheelRotation = 0;
 #endif
+
+    m_unitMax = 0;
+    m_sizeTotal = 0;
+    m_unitFirst = 0;
+
+    m_win =
+    m_targetWindow = (wxWindow *)NULL;
+
+    m_handler = NULL;
+
+    m_win = win;
+
+    // by default, the associated window is also the target window
+    DoSetTargetWindow(win);
+
 }
 
+wxVarScrollHelperBase::~wxVarScrollHelperBase()
+{
+    DeleteEvtHandler();
+}
+
 // ----------------------------------------------------------------------------
-// various helpers
+// wxVarScrollHelperBase various helpers
 // ----------------------------------------------------------------------------
 
-wxCoord wxVScrolledWindow::EstimateTotalHeight() const
+wxCoord wxVarScrollHelperBase::DoEstimateTotalSize() const
 {
     // estimate the total height: it is impossible to call
-    // OnGetLineHeight() for every line because there may be too many of
-    // them, so we just make a guess using some lines in the beginning,
+    // OnGetUnitSize() for every unit because there may be too many of
+    // them, so we just make a guess using some units in the beginning,
     // some in the end and some in the middle
-    static const size_t NUM_LINES_TO_SAMPLE = 10;
+    static const size_t NUM_UNITS_TO_SAMPLE = 10;
 
-    wxCoord heightTotal;
-    if ( m_lineMax < 3*NUM_LINES_TO_SAMPLE )
+    wxCoord sizeTotal;
+    if ( m_unitMax < 3*NUM_UNITS_TO_SAMPLE )
     {
-        // in this case calculating exactly is faster and more correct than
+        // in this case, full calculations are faster and more correct than
         // guessing
-        heightTotal = GetLinesHeight(0, m_lineMax);
+        sizeTotal = GetUnitsSize(0, m_unitMax);
     }
-    else // too many lines to calculate exactly
+    else // too many units to calculate exactly
     {
-        // look at some lines in the beginning/middle/end
-        heightTotal =
-            GetLinesHeight(0, NUM_LINES_TO_SAMPLE) +
-                GetLinesHeight(m_lineMax - NUM_LINES_TO_SAMPLE, m_lineMax) +
-                    GetLinesHeight(m_lineMax/2 - NUM_LINES_TO_SAMPLE/2,
-                                   m_lineMax/2 + NUM_LINES_TO_SAMPLE/2);
+        // look at some units in the beginning/middle/end
+        sizeTotal =
+            GetUnitsSize(0, NUM_UNITS_TO_SAMPLE) +
+                GetUnitsSize(m_unitMax - NUM_UNITS_TO_SAMPLE,
+                             m_unitMax) +
+                    GetUnitsSize(m_unitMax/2 - NUM_UNITS_TO_SAMPLE/2,
+                                 m_unitMax/2 + NUM_UNITS_TO_SAMPLE/2);
 
-        // use the height of the lines we looked as the average
-        heightTotal = (wxCoord)
-                (((float)heightTotal / (3*NUM_LINES_TO_SAMPLE)) * m_lineMax);
+        // use the height of the units we looked as the average
+        sizeTotal = (wxCoord)
+                (((float)sizeTotal / (3*NUM_UNITS_TO_SAMPLE)) * m_unitMax);
     }
 
-    return heightTotal;
+    return sizeTotal;
 }
 
-wxCoord wxVScrolledWindow::GetLinesHeight(size_t lineMin, size_t lineMax) const
+wxCoord wxVarScrollHelperBase::GetUnitsSize(size_t unitMin, size_t unitMax) const
 {
-    if ( lineMin == lineMax )
+    if ( unitMin == unitMax )
         return 0;
-    else if ( lineMin > lineMax )
-        return -GetLinesHeight(lineMax, lineMin);
-    //else: lineMin < lineMax
+    else if ( unitMin > unitMax )
+        return -GetUnitsSize(unitMax, unitMin);
+    //else: unitMin < unitMax
 
-    // let the user code know that we're going to need all these lines
-    OnGetLinesHint(lineMin, lineMax);
+    // let the user code know that we're going to need all these units
+    OnGetUnitsSizeHint(unitMin, unitMax);
 
-    // do sum up their heights
-    wxCoord height = 0;
-    for ( size_t line = lineMin; line < lineMax; line++ )
+    // sum up their sizes
+    wxCoord size = 0;
+    for ( size_t unit = unitMin; unit < unitMax; ++unit )
     {
-        height += OnGetLineHeight(line);
+        size += OnGetUnitSize(unit);
     }
 
-    return height;
+    return size;
 }
 
-size_t wxVScrolledWindow::FindFirstFromBottom(size_t lineLast, bool full)
+size_t wxVarScrollHelperBase::FindFirstVisibleFromLast(size_t unitLast, bool full) const
 {
-    const wxCoord hWindow = GetClientSize().y;
+    const wxCoord sWindow = GetOrientationTargetSize();
 
-    // go upwards until we arrive at a line such that lineLast is not visible
+    // go upwards until we arrive at a unit such that unitLast is not visible
     // any more when it is shown
-    size_t lineFirst = lineLast;
-    wxCoord h = 0;
+    size_t unitFirst = unitLast;
+    wxCoord s = 0;
     for ( ;; )
     {
-        h += OnGetLineHeight(lineFirst);
+        s += OnGetUnitSize(unitFirst);
 
-        if ( h > hWindow )
+        if ( s > sWindow )
         {
-            // for this line to be fully visible we need to go one line
+            // for this unit to be fully visible we need to go one unit
             // down, but if it is enough for it to be only partly visible then
-            // this line will do as well
+            // this unit will do as well
             if ( full )
             {
-                lineFirst++;
+                ++unitFirst;
             }
 
             break;
         }
 
-        if ( !lineFirst )
+        if ( !unitFirst )
             break;
 
-        lineFirst--;
+        --unitFirst;
     }
 
-    return lineFirst;
+    return unitFirst;
 }
 
-void wxVScrolledWindow::RemoveScrollbar()
+size_t wxVarScrollHelperBase::GetNewScrollPosition(wxScrollWinEvent& event) const
 {
-    m_lineFirst = 0;
-    m_nVisible = m_lineMax;
-    SetScrollbar(wxVERTICAL, 0, 0, 0);
+    wxEventType evtType = event.GetEventType();
+
+    if ( evtType == wxEVT_SCROLLWIN_TOP )
+    {
+        return 0;
+    }
+    else if ( evtType == wxEVT_SCROLLWIN_BOTTOM )
+    {
+        return m_unitMax;
+    }
+    else if ( evtType == wxEVT_SCROLLWIN_LINEUP )
+    {
+        return m_unitFirst ? m_unitFirst - 1 : 0;
+    }
+    else if ( evtType == wxEVT_SCROLLWIN_LINEDOWN )
+    {
+        return m_unitFirst + 1;
+    }
+    else if ( evtType == wxEVT_SCROLLWIN_PAGEUP )
+    {
+        return FindFirstVisibleFromLast(m_unitFirst);
+    }
+    else if ( evtType == wxEVT_SCROLLWIN_PAGEDOWN )
+    {
+        if( GetVisibleEnd() )
+            return GetVisibleEnd() - 1;
+        else
+            return GetVisibleEnd();
+    }
+    else if ( evtType == wxEVT_SCROLLWIN_THUMBRELEASE )
+    {
+        return event.GetPosition();
+    }
+    else if ( evtType == wxEVT_SCROLLWIN_THUMBTRACK )
+    {
+        return event.GetPosition();
+    }
+
+    // unknown scroll event?
+    wxFAIL_MSG( _T("unknown scroll event type?") );
+    return 0;
 }
 
-void wxVScrolledWindow::UpdateScrollbar()
+void wxVarScrollHelperBase::UpdateScrollbar()
 {
     // if there is nothing to scroll, remove the scrollbar
-    if ( !m_lineMax )
+    if ( !m_unitMax )
     {
         RemoveScrollbar();
         return;
     }
 
-    // see how many lines can we fit on screen
-    const wxCoord hWindow = GetClientSize().y;
+    // see how many units can we fit on screen
+    const wxCoord sWindow = GetOrientationTargetSize();
 
-    wxCoord h = 0;
-    size_t line;
-    for ( line = m_lineFirst; line < m_lineMax; line++ )
+    // do vertical calculations
+    wxCoord s = 0;
+    size_t unit;
+    for ( unit = m_unitFirst; unit < m_unitMax; ++unit )
     {
-        if ( h > hWindow )
+        if ( s > sWindow )
             break;
 
-        h += OnGetLineHeight(line);
+        s += OnGetUnitSize(unit);
     }
 
-    // if we still have remaining space below, maybe we can fit everything?
-    if ( h < hWindow )
+    m_nUnitsVisible = unit - m_unitFirst;
+
+    int unitsPageSize = m_nUnitsVisible;
+    if ( s > sWindow )
     {
-        wxCoord hAll = h;
-        for ( size_t lineFirst = m_lineFirst; lineFirst > 0; lineFirst-- )
-        {
-            hAll += OnGetLineHeight(m_lineFirst - 1);
-            if ( hAll > hWindow )
-                break;
-        }
+        // last unit is only partially visible, we still need the scrollbar and
+        // so we have to "fix" pageSize because if it is equal to m_unitMax
+        // the scrollbar is not shown at all under MSW
+        --unitsPageSize;
+    }
+
+    // set the scrollbar parameters to reflect this
+    m_win->SetScrollbar(GetOrientation(), m_unitFirst, unitsPageSize, m_unitMax);
+}
+
+void wxVarScrollHelperBase::RemoveScrollbar()
+{
+    m_unitFirst = 0;
+    m_nUnitsVisible = m_unitMax;
+    m_win->SetScrollbar(GetOrientation(), 0, 0, 0);
+}
 
-        if ( hAll < hWindow )
+void wxVarScrollHelperBase::DeleteEvtHandler()
+{
+    // search for m_handler in the handler list
+    if ( m_win && m_handler )
+    {
+        if ( m_win->RemoveEventHandler(m_handler) )
         {
-            // we don't need scrollbar at all
-            RemoveScrollbar();
-            return;
+            delete m_handler;
         }
+        //else: something is very wrong, so better [maybe] leak memory than
+        //      risk a crash because of double deletion
+
+        m_handler = NULL;
     }
+}
 
-    m_nVisible = line - m_lineFirst;
+void wxVarScrollHelperBase::DoSetTargetWindow(wxWindow *target)
+{
+    m_targetWindow = target;
+#ifdef __WXMAC__
+    target->MacSetClipChildren( true ) ;
+#endif
 
-    int pageSize = m_nVisible;
-    if ( h > hWindow )
+    // install the event handler which will intercept the events we're
+    // interested in (but only do it for our real window, not the target window
+    // which we scroll - we don't need to hijack its events)
+    if ( m_targetWindow == m_win )
     {
-        // last line is only partially visible, we still need the scrollbar and
-        // so we have to "fix" pageSize because if it is equal to m_lineMax the
-        // scrollbar is not shown at all under MSW
-        pageSize--;
-    }
+        // if we already have a handler, delete it first
+        DeleteEvtHandler();
 
-    // set the scrollbar parameters to reflect this
-    SetScrollbar(wxVERTICAL, m_lineFirst, pageSize, m_lineMax);
+        m_handler = new wxVarScrollHelperEvtHandler(this);
+        m_targetWindow->PushEventHandler(m_handler);
+    }
 }
 
 // ----------------------------------------------------------------------------
-// operations
+// wxVarScrollHelperBase operations
 // ----------------------------------------------------------------------------
 
-void wxVScrolledWindow::SetLineCount(size_t count)
+void wxVarScrollHelperBase::SetTargetWindow(wxWindow *target)
 {
-    // save the number of lines
-    m_lineMax = count;
+    wxCHECK_RET( target, wxT("target window must not be NULL") );
+
+    if ( target == m_targetWindow )
+        return;
+
+    DoSetTargetWindow(target);
+}
 
+void wxVarScrollHelperBase::SetUnitCount(size_t count)
+{
+    // save the number of units
+    m_unitMax = count;
+
     // and our estimate for their total height
-    m_heightTotal = EstimateTotalHeight();
+    m_sizeTotal = EstimateTotalSize();
 
-    // ScrollToLine() will update the scrollbar itself if it changes the line
+    // ScrollToUnit() will update the scrollbar itself if it changes the unit
     // we pass to it because it's out of [new] range
-    size_t oldScrollPos = m_lineFirst;
-    ScrollToLine(m_lineFirst);
-    if ( oldScrollPos == m_lineFirst )
+    size_t oldScrollPos = m_unitFirst;
+    DoScrollToUnit(m_unitFirst);
+    if ( oldScrollPos == m_unitFirst )
     {
         // but if it didn't do it, we still need to update the scrollbar to
-        // reflect the changed number of lines ourselves
+        // reflect the changed number of units ourselves
         UpdateScrollbar();
     }
 }
 
-void wxVScrolledWindow::RefreshLine(size_t line)
+void wxVarScrollHelperBase::RefreshUnit(size_t unit)
 {
-    // is this line visible?
-    if ( !IsVisible(line) )
+    // is this unit visible?
+    if ( !IsVisible(unit) )
     {
         // no, it is useless to do anything
         return;
     }
 
-    // calculate the rect occupied by this line on screen
+    // calculate the rect occupied by this unit on screen
     wxRect rect;
-    rect.width = GetClientSize().x;
-    rect.height = OnGetLineHeight(line);
-    for ( size_t n = GetVisibleBegin(); n < line; n++ )
+    if( GetOrientation() == wxVERTICAL )
+    {
+        rect.width    = GetNonOrientationTargetSize();
+        rect.height    = OnGetUnitSize(unit);
+    }
+    else if( GetOrientation() == wxHORIZONTAL )
     {
-        rect.y += OnGetLineHeight(n);
+        rect.width    = OnGetUnitSize(unit);
+        rect.height    = GetNonOrientationTargetSize();
     }
 
+    for ( size_t n = GetVisibleBegin(); n < unit; ++n )
+    {
+        if( GetOrientation() == wxVERTICAL )
+            rect.y += OnGetUnitSize(n);
+        else if( GetOrientation() == wxHORIZONTAL )
+            rect.x += OnGetUnitSize(n);
+    }
+
     // do refresh it
-    RefreshRect(rect);
+    m_targetWindow->RefreshRect(rect);
 }
 
-void wxVScrolledWindow::RefreshLines(size_t from, size_t to)
+void wxVarScrollHelperBase::RefreshUnits(size_t from, size_t to)
 {
-    wxASSERT_MSG( from <= to, _T("RefreshLines(): empty range") );
+    wxASSERT_MSG( from <= to, _T("RefreshUnits(): empty range") );
 
-    // clump the range to just the visible lines -- it is useless to refresh
+    // clump the range to just the visible units -- it is useless to refresh
     // the other ones
     if ( from < GetVisibleBegin() )
         from = GetVisibleBegin();
 
-    if ( to >= GetVisibleEnd() )
+    if ( to > GetVisibleEnd() )
         to = GetVisibleEnd();
-    else
-        to++;
 
-    // calculate the rect occupied by these lines on screen
-    wxRect rect;
-    rect.width = GetClientSize().x;
-    for ( size_t nBefore = GetVisibleBegin(); nBefore < from; nBefore++ )
+    // calculate the rect occupied by these units on screen
+    int orient_size, nonorient_size, orient_pos;
+    orient_size = nonorient_size = orient_pos = 0;
+
+    nonorient_size = GetNonOrientationTargetSize();
+
+    for ( size_t nBefore = GetVisibleBegin();
+          nBefore < from;
+          nBefore++ )
+    {
+        orient_pos += OnGetUnitSize(nBefore);
+    }
+
+    for ( size_t nBetween = from; nBetween <= to; nBetween++ )
     {
-        rect.y += OnGetLineHeight(nBefore);
+        orient_size += OnGetUnitSize(nBetween);
     }
 
-    for ( size_t nBetween = from; nBetween < to; nBetween++ )
+    wxRect rect;
+    if(GetOrientation() == wxVERTICAL)
     {
-        rect.height += OnGetLineHeight(nBetween);
+        rect.width    = nonorient_size;
+        rect.height    = orient_size;
+        rect.x        = 0;
+        rect.y        = orient_pos;
+    }
+    else if(GetOrientation() == wxHORIZONTAL)
+    {
+        rect.width    = orient_size;
+        rect.height    = nonorient_size;
+        rect.x        = orient_pos;
+        rect.y        = 0;
     }
 
     // do refresh it
-    RefreshRect(rect);
+    m_targetWindow->RefreshRect(rect);
 }
 
-void wxVScrolledWindow::RefreshAll()
+void wxVarScrollHelperBase::RefreshAll()
 {
     UpdateScrollbar();
 
-    Refresh();
+    m_targetWindow->Refresh();
 }
 
-bool wxVScrolledWindow::Layout()
+bool wxVarScrollHelperBase::ScrollLayout()
 {
-    if ( GetSizer() )
+    if(m_targetWindow->GetSizer() && m_physicalScrolling)
     {
         // adjust the sizer dimensions/position taking into account the
         // virtual size and scrolled position of the window.
 
-        int w = 0, h = 0;
-        GetVirtualSize(&w, &h);
+        int x, y, w, h;
+        x = y = 0;
 
-        // x is always 0 so no variable needed
-        int y = -GetLinesHeight(0, GetFirstVisibleLine());
+        if(GetOrientation() == wxVERTICAL)
+            y = -GetUnitsSize(0, GetVisibleBegin());
+        else if(GetOrientation() == wxHORIZONTAL)
+            x = -GetUnitsSize(0, GetVisibleBegin());
 
-        GetSizer()->SetDimension(0, y, w, h);
+        m_targetWindow->GetVirtualSize(&w, &h);
+        m_targetWindow->GetSizer()->SetDimension(x, y, w, h);
         return true;
     }
 
     // fall back to default for LayoutConstraints
-    return wxPanel::Layout();
+    return m_targetWindow->wxWindow::Layout();
 }
 
-int wxVScrolledWindow::HitTest(wxCoord WXUNUSED(x), wxCoord y) const
+int wxVarScrollHelperBase::HitTest(wxCoord coord) const
 {
-    const size_t lineMax = GetVisibleEnd();
-    for ( size_t line = GetVisibleBegin(); line < lineMax; line++ )
+    const size_t unitMax = GetVisibleEnd();
+    for ( size_t unit = GetVisibleBegin(); unit < unitMax; ++unit )
     {
-        y -= OnGetLineHeight(line);
-        if ( y < 0 )
-            return line;
+        coord -= OnGetUnitSize(unit);
+        if ( coord < 0 )
+            return unit;
     }
 
     return wxNOT_FOUND;
 }
 
 // ----------------------------------------------------------------------------
-// scrolling
+// wxVarScrollHelperBase scrolling
 // ----------------------------------------------------------------------------
 
-bool wxVScrolledWindow::ScrollToLine(size_t line)
+bool wxVarScrollHelperBase::DoScrollToUnit(size_t unit)
 {
-    if ( !m_lineMax )
+    if ( !m_unitMax )
     {
         // we're empty, code below doesn't make sense in this case
         return false;
     }
 
-    // determine the real first line to scroll to: we shouldn't scroll beyond
+    // determine the real first unit to scroll to: we shouldn't scroll beyond
     // the end
-    size_t lineFirstLast = FindFirstFromBottom(m_lineMax - 1, true);
-    if ( line > lineFirstLast )
-        line = lineFirstLast;
+    size_t unitFirstLast = FindFirstVisibleFromLast(m_unitMax - 1, true);
+    if ( unit > unitFirstLast )
+        unit = unitFirstLast;
 
     // anything to do?
-    if ( line == m_lineFirst )
+    if ( unit == m_unitFirst )
     {
         // no
         return false;
     }
 
 
-    // remember the currently shown lines for the refresh code below
-    size_t lineFirstOld = GetVisibleBegin(),
-           lineLastOld = GetVisibleEnd();
+    // remember the currently shown units for the refresh code below
+    size_t unitFirstOld = GetVisibleBegin(),
+           unitLastOld = GetVisibleEnd();
 
-    m_lineFirst = line;
+    m_unitFirst = unit;
 
 
     // the size of scrollbar thumb could have changed
@@ -376,55 +585,73 @@
 
     // the size of scrollbar thumb could have changed
     UpdateScrollbar();
-
 
-    // finally refresh the display -- but only redraw as few lines as possible
-    // to avoid flicker
-    if ( GetVisibleBegin() >= lineLastOld ||
-            GetVisibleEnd() <= lineFirstOld )
+    // finally refresh the display -- but only redraw as few units as possible
+    // to avoid flicker.  We can't do this if we have children because they
+    // won't be scrolled
+    if ( m_targetWindow->GetChildren().GetCount() == 0 &&
+         GetVisibleBegin() >= unitLastOld ||
+         GetVisibleEnd() <= unitFirstOld )
     {
-        // the simplest case: we don't have any old lines left, just redraw
+        // the simplest case: we don't have any old units left, just redraw
         // everything
-        Refresh();
+        m_targetWindow->Refresh();
     }
-    else // overlap between the lines we showed before and should show now
+    else
     {
-        ScrollWindow(0, GetLinesHeight(GetVisibleBegin(), lineFirstOld));
+        // finally, scroll the actual window contents vertically
+        if(m_physicalScrolling)
+        {
+            if(GetOrientation() == wxVERTICAL)
+                m_targetWindow->ScrollWindow(0, GetUnitsSize(GetVisibleBegin(),
+                                                             unitFirstOld));
+            else if(GetOrientation() == wxHORIZONTAL)
+                m_targetWindow->ScrollWindow(GetUnitsSize(GetVisibleBegin(),
+                                                          unitFirstOld), 0);
+        }
+        else
+        {
+            // we still need to invalidate but we can't use ScrollWindow
+            // because physical scrolling is disabled (the user either didn't
+            // want children scrolled and/or doesn't want pixels to be
+            // physically scrolled).
+            m_targetWindow->Refresh();
+        }
     }
 
     return true;
 }
 
-bool wxVScrolledWindow::ScrollLines(int lines)
+bool wxVarScrollHelperBase::DoScrollUnits(int units)
 {
-    lines += m_lineFirst;
-    if ( lines < 0 )
-        lines = 0;
+    units += m_unitFirst;
+    if ( units < 0 )
+        units = 0;
 
-    return ScrollToLine(lines);
+    return DoScrollToUnit(units);
 }
 
-bool wxVScrolledWindow::ScrollPages(int pages)
+bool wxVarScrollHelperBase::DoScrollPages(int pages)
 {
     bool didSomething = false;
 
     while ( pages )
     {
-        int line;
+        int unit;
         if ( pages > 0 )
         {
-            line = GetVisibleEnd();
-            if ( line )
-                line--;
-            pages--;
+            unit = GetVisibleEnd();
+            if ( unit )
+                --unit;
+            --pages;
         }
         else // pages < 0
         {
-            line = FindFirstFromBottom(GetVisibleBegin());
-            pages++;
+            unit = FindFirstVisibleFromLast(GetVisibleEnd());
+            ++pages;
         }
 
-        didSomething = ScrollToLine(line);
+        didSomething = DoScrollToUnit(unit);
     }
 
     return didSomething;
@@ -434,87 +661,271 @@
 // event handling
 // ----------------------------------------------------------------------------
 
-void wxVScrolledWindow::OnSize(wxSizeEvent& event)
+void wxVarScrollHelperBase::HandleOnSize(wxSizeEvent& event)
 {
     UpdateScrollbar();
 
     event.Skip();
 }
 
-void wxVScrolledWindow::OnScroll(wxScrollWinEvent& event)
+void wxVarScrollHelperBase::HandleOnScroll(wxScrollWinEvent& event)
 {
-    size_t lineFirstNew;
+    if(GetOrientation() != event.GetOrientation())
+    {
+        event.Skip();
+        return;
+    }
 
-    const wxEventType evtType = event.GetEventType();
+    DoScrollToUnit(GetNewScrollPosition(event));
 
-    if ( evtType == wxEVT_SCROLLWIN_TOP )
+#ifdef __WXMAC__
+    UpdateMacScrollWindow();
+#endif // __WXMAC__
+}
+
+void wxVarScrollHelperBase::DoPrepareDC(wxDC& dc)
+{
+    if(m_physicalScrolling)
     {
-        lineFirstNew = 0;
+        wxPoint pt = dc.GetDeviceOrigin();
+        if( GetOrientation() == wxVERTICAL )
+        {
+            dc.SetDeviceOrigin( pt.x,
+                                pt.y - GetUnitsSize(0, GetVisibleBegin()) );
+        }
+        else if( GetOrientation() == wxHORIZONTAL )
+        {
+            dc.SetDeviceOrigin( pt.x - GetUnitsSize(0, GetVisibleBegin()),
+                                pt.y );
+        }
     }
-    else if ( evtType == wxEVT_SCROLLWIN_BOTTOM )
+}
+
+int wxVarScrollHelperBase::DoCalcScrolledPosition(int coord) const
+{
+    if ( coord )
+        return coord - GetUnitsSize(0, GetVisibleBegin());
+    return 0;
+}
+
+int wxVarScrollHelperBase::DoCalcUnscrolledPosition(int coord) const
+{
+    if ( coord )
+        return coord + GetUnitsSize(0, GetVisibleBegin());
+    return 0;
+}
+
+#if wxUSE_MOUSEWHEEL
+
+void wxVarScrollHelperBase::HandleOnMouseWheel(wxMouseEvent& event)
+{
+    // we only want to process wheel events for vertical implementations.
+    // There is no way to determine wheel orientation (and on MSW horizontal
+    // wheel rotation just fakes scroll events, rather than sending a MOUSEWHEEL
+    // event).
+    if(GetOrientation() != wxVERTICAL)
+        return;
+
+    m_sumWheelRotation += event.GetWheelRotation();
+    int delta = event.GetWheelDelta();
+
+    // how much to scroll this time
+    int units_to_scroll = -(m_sumWheelRotation/delta);
+    if ( !units_to_scroll )
+        return;
+
+    m_sumWheelRotation += units_to_scroll*delta;
+
+    if ( !event.IsPageScroll() )
+        DoScrollUnits( units_to_scroll*event.GetLinesPerAction() );
+    else
+        // scroll pages instead of units
+        DoScrollPages( units_to_scroll );
+}
+
+#endif
+
+
+// ============================================================================
+// wxVarHVScrollHelper implementation
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// wxVarHVScrollHelper operations
+// ----------------------------------------------------------------------------
+
+void wxVarHVScrollHelper::SetRowColumnCount(size_t rowCount, size_t columnCount)
+{
+    SetRowCount(rowCount);
+    SetColumnCount(columnCount);
+}
+
+bool wxVarHVScrollHelper::ScrollToRowColumn(size_t row, size_t column)
+{
+    bool result = false;
+    result |= ScrollToRow(row);
+    result |= ScrollToColumn(column);
+    return result;
+}
+
+void wxVarHVScrollHelper::RefreshRowColumn(size_t row, size_t column)
+{
+    // is this unit visible?
+    if ( !IsRowVisible(row) || !IsColumnVisible(column) )
     {
-        lineFirstNew = m_lineMax;
+        // no, it is useless to do anything
+        return;
     }
-    else if ( evtType == wxEVT_SCROLLWIN_LINEUP )
+
+    // calculate the rect occupied by this cell on screen
+    wxRect v_rect, h_rect;
+    v_rect.height = OnGetRowHeight(row);
+    h_rect.width = OnGetColumnWidth(column);
+
+    size_t n;
+
+    for ( n = GetVisibleRowsBegin(); n < row; n++ )
     {
-        lineFirstNew = m_lineFirst ? m_lineFirst - 1 : 0;
+        v_rect.y += OnGetRowHeight(n);
     }
-    else if ( evtType == wxEVT_SCROLLWIN_LINEDOWN )
+
+    for ( n = GetVisibleColumnsBegin(); n < column; n++ )
     {
-        lineFirstNew = m_lineFirst + 1;
+        h_rect.x += OnGetColumnWidth(n);
     }
-    else if ( evtType == wxEVT_SCROLLWIN_PAGEUP )
+
+    // refresh but specialize the behavior if we have a single target window
+    if ( wxVarVScrollHelper::GetTargetWindow() == wxVarHScrollHelper::GetTargetWindow() )
     {
-        lineFirstNew = FindFirstFromBottom(m_lineFirst);
+        v_rect.x = h_rect.x;
+        v_rect.width = h_rect.width;
+        wxVarVScrollHelper::GetTargetWindow()->RefreshRect(v_rect);
     }
-    else if ( evtType == wxEVT_SCROLLWIN_PAGEDOWN )
+    else
     {
-        lineFirstNew = GetVisibleEnd();
-        if ( lineFirstNew )
-            lineFirstNew--;
+        v_rect.x = 0;
+        v_rect.width = wxVarVScrollHelper::GetNonOrientationTargetSize();
+        h_rect.y = 0;
+        h_rect.width = wxVarHScrollHelper::GetNonOrientationTargetSize();
+
+        wxVarVScrollHelper::GetTargetWindow()->RefreshRect(v_rect);
+        wxVarHScrollHelper::GetTargetWindow()->RefreshRect(h_rect);
     }
-    else if ( evtType == wxEVT_SCROLLWIN_THUMBRELEASE )
+}
+
+void wxVarHVScrollHelper::RefreshRowsColumns(size_t fromRow, size_t toRow,
+                                             size_t fromColumn, size_t toColumn)
+{
+    wxASSERT_MSG( fromRow <= toRow || fromColumn <= toColumn,
+        _T("RefreshRowsColumns(): empty range") );
+
+    // clump the range to just the visible units -- it is useless to refresh
+    // the other ones
+    if ( fromRow < GetVisibleRowsBegin() )
+        fromRow = GetVisibleRowsBegin();
+
+    if ( toRow > GetVisibleRowsEnd() )
+        toRow = GetVisibleRowsEnd();
+
+    if ( fromColumn < GetVisibleColumnsBegin() )
+        fromColumn = GetVisibleColumnsBegin();
+
+    if ( toColumn > GetVisibleColumnsEnd() )
+        toColumn = GetVisibleColumnsEnd();
+
+    // calculate the rect occupied by these units on screen
+    wxRect v_rect, h_rect;
+    size_t nBefore, nBetween;
+
+    for ( nBefore = GetVisibleRowsBegin();
+          nBefore < fromRow;
+          nBefore++ )
     {
-        lineFirstNew = event.GetPosition();
+        v_rect.y += OnGetRowHeight(nBefore);
     }
-    else if ( evtType == wxEVT_SCROLLWIN_THUMBTRACK )
+
+    for ( nBetween = fromRow; nBetween <= toRow; nBetween++ )
     {
-        lineFirstNew = event.GetPosition();
+        v_rect.height += OnGetRowHeight(nBetween);
     }
 
-    else // unknown scroll event?
+    for ( nBefore = GetVisibleColumnsBegin();
+          nBefore < fromColumn;
+          nBefore++ )
     {
-        wxFAIL_MSG( _T("unknown scroll event type?") );
-        return;
+        h_rect.x += OnGetColumnWidth(nBefore);
     }
 
-    ScrollToLine(lineFirstNew);
+    for ( nBetween = fromColumn; nBetween <= toColumn; nBetween++ )
+    {
+        h_rect.width += OnGetColumnWidth(nBetween);
+    }
 
-#ifdef __WXMAC__
-    Update();
-#endif // __WXMAC__
+    // refresh but specialize the behavior if we have a single target window
+    if ( wxVarVScrollHelper::GetTargetWindow() == wxVarHScrollHelper::GetTargetWindow() )
+    {
+        v_rect.x = h_rect.x;
+        v_rect.width = h_rect.width;
+        wxVarVScrollHelper::GetTargetWindow()->RefreshRect(v_rect);
+    }
+    else
+    {
+        v_rect.x = 0;
+        v_rect.width = wxVarVScrollHelper::GetNonOrientationTargetSize();
+        h_rect.y = 0;
+        h_rect.width = wxVarHScrollHelper::GetNonOrientationTargetSize();
+
+        wxVarVScrollHelper::GetTargetWindow()->RefreshRect(v_rect);
+        wxVarHScrollHelper::GetTargetWindow()->RefreshRect(h_rect);
+    }
 }
 
-#if wxUSE_MOUSEWHEEL
+wxPosition wxVarHVScrollHelper::HitTest(wxCoord x, wxCoord y) const
+{
+    return wxPosition(wxVarVScrollHelper::HitTest(y),
+                        wxVarHScrollHelper::HitTest(x));
+}
 
-void wxVScrolledWindow::OnMouseWheel(wxMouseEvent& event)
+void wxVarHVScrollHelper::DoPrepareDC(wxDC& dc)
 {
-    m_sumWheelRotation += event.GetWheelRotation();
-    int delta = event.GetWheelDelta();
+    wxVarVScrollHelper::DoPrepareDC(dc);
+    wxVarHScrollHelper::DoPrepareDC(dc);
+}
 
-    // how much to scroll this time
-    int units_to_scroll = -(m_sumWheelRotation/delta);
-    if ( !units_to_scroll )
-        return;
+bool wxVarHVScrollHelper::ScrollLayout()
+{
+    bool layout_result = false;
+    layout_result |= wxVarVScrollHelper::ScrollLayout();
+    layout_result |= wxVarHScrollHelper::ScrollLayout();
+    return layout_result;
+}
 
-    m_sumWheelRotation += units_to_scroll*delta;
+wxSize wxVarHVScrollHelper::GetRowColumnCount() const
+{
+    return wxSize(GetColumnCount(), GetRowCount());
+}
 
-    if ( !event.IsPageScroll() )
-        ScrollLines( units_to_scroll*event.GetLinesPerAction() );
-    else
-        // scroll pages instead of lines
-        ScrollPages( units_to_scroll );
+wxPosition wxVarHVScrollHelper::GetVisibleBegin() const
+{
+    return wxPosition(GetVisibleRowsBegin(), GetVisibleColumnsBegin());
 }
 
-#endif // wxUSE_MOUSEWHEEL
+wxPosition wxVarHVScrollHelper::GetVisibleEnd() const
+{
+    return wxPosition(GetVisibleRowsEnd(), GetVisibleColumnsEnd());
+}
+
+bool wxVarHVScrollHelper::IsVisible(size_t row, size_t column) const
+{
+    return IsRowVisible(row) && IsColumnVisible(column);
+}
+
+
+// ============================================================================
+// wx[V/H/HV]ScrolledWindow implementations
+// ============================================================================
+
+IMPLEMENT_ABSTRACT_CLASS(wxVScrolledWindow, wxPanel)
+IMPLEMENT_ABSTRACT_CLASS(wxHScrolledWindow, wxPanel)
+IMPLEMENT_ABSTRACT_CLASS(wxHVScrolledWindow, wxPanel)
 
Index: src/richtext/richtextfontpage.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/richtext/richtextfontpage.cpp,v
retrieving revision 1.7
diff -u -B -r1.7 richtextfontpage.cpp
--- src/richtext/richtextfontpage.cpp	2007/03/07 12:11:34	1.7
+++ src/richtext/richtextfontpage.cpp	2007/04/06 20:52:23
@@ -622,7 +622,7 @@
             {
                 if (arr[i].Mid(0, facename.Length()).Lower() == facename.Lower())
                 {
-                    m_faceListBox->ScrollToLine(i);
+                    m_faceListBox->ScrollToRow(i);
                     break;
                 }
             }
Index: src/richtext/richtextsymboldlg.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/richtext/richtextsymboldlg.cpp,v
retrieving revision 1.9
diff -u -B -r1.9 richtextsymboldlg.cpp
--- src/richtext/richtextsymboldlg.cpp	2007/03/07 12:11:35	1.9
+++ src/richtext/richtextsymboldlg.cpp	2007/04/06 20:52:24
@@ -832,7 +832,7 @@
     }
 
     if ( m_current != wxNOT_FOUND )
-        RefreshLine(SymbolValueToLineNumber(m_current));
+        RefreshRow(SymbolValueToLineNumber(m_current));
 
     m_current = current;
 
@@ -844,19 +844,19 @@
         // don't need to refresh it -- it will be redrawn anyhow
         if ( !IsVisible(lineNo) )
         {
-            ScrollToLine(lineNo);
+            ScrollToRow(lineNo);
         }
         else // line is at least partly visible
         {
             // it is, indeed, only partly visible, so scroll it into view to
             // make it entirely visible
             while ( unsigned(lineNo) == GetLastVisibleLine() &&
-                    ScrollToLine(GetVisibleBegin()+1) )
+                    ScrollToRow(GetVisibleBegin()+1) )
                 ;
 
             // but in any case refresh it as even if it was only partly visible
             // before we need to redraw it entirely as its background changed
-            RefreshLine(lineNo);
+            RefreshRow(lineNo);
         }
     }
 
@@ -1200,12 +1200,12 @@
     m_symbolsPerLine = sz.x/(m_cellSize.x+m_ptMargins.x);
     int noLines = (1 + SymbolValueToLineNumber(m_maxSymbolValue));
 
-    SetLineCount(noLines);
+    SetRowCount(noLines);
     Refresh();
 
     if (scrollToSelection && m_current != wxNOT_FOUND && m_current >= m_minSymbolValue && m_current <= m_maxSymbolValue)
     {
-        ScrollToLine(SymbolValueToLineNumber(m_current));
+        ScrollToRow(SymbolValueToLineNumber(m_current));
     }
 }
 
@@ -1214,7 +1214,7 @@
 {
     if (item != wxNOT_FOUND && item >= m_minSymbolValue && item <= m_maxSymbolValue)
     {
-        ScrollToLine(SymbolValueToLineNumber(item));
+        ScrollToRow(SymbolValueToLineNumber(item));
     }
 }
 

 	  	 
