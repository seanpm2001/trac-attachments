Index: src/gtk/private.cpp
===================================================================
--- src/gtk/private.cpp	(Revision 70939)
+++ src/gtk/private.cpp	(Arbeitskopie)
@@ -64,6 +64,20 @@
     return s_button;
 }
 
+GtkWidget *GetNotebookWidget()
+{
+    static GtkWidget *s_notebook = NULL;
+
+    if ( !s_notebook )
+    {
+        s_notebook = gtk_notebook_new();
+        gtk_container_add(GetContainer(), s_notebook);
+        gtk_widget_realize(s_notebook);
+    }
+
+    return s_notebook;
+}
+
 GtkWidget *GetCheckButtonWidget()
 {
     static GtkWidget *s_button = NULL;
Index: src/aui/tabmdi.cpp
===================================================================
--- src/aui/tabmdi.cpp	(Revision 70939)
+++ src/aui/tabmdi.cpp	(Arbeitskopie)
@@ -38,6 +38,7 @@
 #endif //WX_PRECOMP
 
 #include "wx/stockitem.h"
+#include "wx/aui/dockart.h"
 
 enum MDI_MENU_ID
 {
Index: src/aui/tabartgtk.cpp
===================================================================
--- src/aui/tabartgtk.cpp	(Revision 0)
+++ src/aui/tabartgtk.cpp	(Revision 0)
@@ -0,0 +1,534 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        src/aui/tabartgtk.cpp
+// Purpose:     implementation of the wxAuiGTKTabArt
+// Author:      Jens Lody
+// Modified by:
+// Created:     2012-03-21
+// RCS-ID:      $Id:$
+// Copyright:   (c) 2012 Jens Lody <jens@codeblocks.org>
+// Licence:     wxWindows licence
+///////////////////////////////////////////////////////////////////////////////
+
+// ============================================================================
+// declarations
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+// headers
+// ----------------------------------------------------------------------------
+
+// For compilers that support precompilation, includes "wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#if wxUSE_AUI
+
+#ifndef WX_PRECOMP
+    #include "wx/dc.h"
+    #include "wx/dcclient.h"
+    #include "wx/settings.h"
+    #include "wx/image.h"
+#endif
+
+#include "wx/gtk/dc.h"
+#include "wx/gtk/private.h"
+
+#include <gtk/gtk.h>
+
+#include "wx/aui/auibook.h"
+#include "wx/aui/tabartgtk.h"
+
+namespace
+{
+
+static int s_CloseIconSize = 16; // default size
+
+}
+
+wxAuiGtkTabArt::wxAuiGtkTabArt():
+    m_Xthickness(0),
+    m_Ythickness(0),
+    m_TabHBorder(0),
+    m_TabVBorder(0)
+
+{
+}
+
+wxAuiTabArt* wxAuiGtkTabArt::Clone()
+{
+    wxAuiGtkTabArt* clone = new wxAuiGtkTabArt();
+
+    clone->SetNormalFont(m_normalFont);
+    clone->SetSelectedFont(m_normalFont);
+    clone->SetMeasuringFont(m_normalFont);
+
+    return clone;
+}
+
+void wxAuiGtkTabArt::DrawBackground(wxDC& dc, wxWindow* wnd, const wxRect& rect)
+{
+    GtkStyle* style_notebook = gtk_widget_get_style(wxGTKPrivate::GetNotebookWidget());
+    GtkNotebook* notebook = GTK_NOTEBOOK (wxGTKPrivate::GetNotebookWidget());
+
+    // if one of the parameters have changed, the height needs to be recalculated, so we force it,
+    if(m_Xthickness  != style_notebook->xthickness ||
+       m_Ythickness  != style_notebook->ythickness ||
+       m_TabVBorder != notebook->tab_vborder ||
+       m_TabHBorder != notebook->tab_hborder)
+    {
+        m_Xthickness  = style_notebook->xthickness;
+        m_Ythickness  = style_notebook->ythickness;
+        m_TabVBorder = notebook->tab_vborder;
+        m_TabHBorder = notebook->tab_hborder;
+        wxAuiNotebook* nb = NULL;
+        if(wnd)
+             nb = (wxAuiNotebook*)wnd->GetParent();
+        if(nb)
+            nb->SetTabCtrlHeight(-1);
+    }
+    wxGTKDCImpl *impldc = (wxGTKDCImpl*) dc.GetImpl();
+    GdkWindow* window = impldc->GetGDKWindow();
+
+    gtk_style_apply_default_background(style_notebook, window, 1, GTK_STATE_NORMAL, NULL,
+                                       rect.x, rect.y, rect.width, rect.height);
+}
+
+wxRect DrawSimpleButton(wxDC& dc,
+                        GtkWidget *widget,
+                        int button_state,
+                        wxRect const &in_rect)
+{
+    wxRect r;
+
+    r.height = in_rect.height - 3 * gtk_widget_get_style(wxGTKPrivate::GetNotebookWidget())->ythickness;
+    r.width = r.height;
+    r.x = in_rect.x + in_rect.width - r.width;
+
+    wxGTKDCImpl *impldc = (wxGTKDCImpl*) dc.GetImpl();
+    GdkWindow* window = impldc->GetGDKWindow();
+
+    if (button_state == wxAUI_BUTTON_STATE_HOVER)
+    {
+        gtk_paint_box(gtk_widget_get_style(wxGTKPrivate::GetButtonWidget()), window,
+                      GTK_STATE_PRELIGHT, GTK_SHADOW_OUT, NULL, widget, "button",
+                      r.x, r.y, r.width, r.height);
+    }
+    else if (button_state == wxAUI_BUTTON_STATE_PRESSED)
+    {
+        gtk_paint_box(gtk_widget_get_style(wxGTKPrivate::GetButtonWidget()), window,
+                      GTK_STATE_ACTIVE, GTK_SHADOW_IN, NULL, widget, "button",
+                      r.x, r.y, r.width, r.height);
+    }
+
+    return r;
+}
+
+void ButtonStateAndShadow(int button_state, GtkStateType &state, GtkShadowType &shadow)
+{
+
+    if (button_state & wxAUI_BUTTON_STATE_DISABLED)
+    {
+        state = GTK_STATE_INSENSITIVE;
+        shadow = GTK_SHADOW_ETCHED_IN;
+    }
+    else if (button_state & wxAUI_BUTTON_STATE_HOVER)
+    {
+        state = GTK_STATE_PRELIGHT;
+        shadow = GTK_SHADOW_OUT;
+    }
+    else if (button_state & wxAUI_BUTTON_STATE_PRESSED)
+    {
+        state = GTK_STATE_ACTIVE;
+        shadow = GTK_SHADOW_IN;
+    }
+    else
+    {
+        state = GTK_STATE_NORMAL;
+        shadow = GTK_SHADOW_OUT;
+    }
+}
+
+wxRect DrawCloseButton(wxDC& dc,
+                       GtkWidget *widget,
+                       int button_state,
+                       wxRect const &in_rect,
+                       int orientation,
+                       GdkRectangle* clipRect)
+{
+    GtkStyle *style_button = gtk_widget_get_style(wxGTKPrivate::GetButtonWidget());
+    int xthickness = style_button->xthickness;
+    int ythickness = style_button->ythickness;
+
+    wxBitmap bmp;
+    bmp.SetPixbuf(gtk_widget_render_icon(widget, GTK_STOCK_CLOSE, GTK_ICON_SIZE_SMALL_TOOLBAR, "tab"));
+
+    if(bmp.GetWidth() != s_CloseIconSize || bmp.GetHeight() != s_CloseIconSize)
+    {
+        wxImage img = bmp.ConvertToImage();
+        img.Rescale(s_CloseIconSize, s_CloseIconSize);
+        bmp = img;
+    }
+
+    int button_size = s_CloseIconSize + 2 * xthickness;
+
+    wxRect out_rect;
+
+    if (orientation == wxLEFT)
+        out_rect.x = in_rect.x - ythickness;
+    else
+        out_rect.x = in_rect.x + in_rect.width - button_size - ythickness;
+
+    out_rect.y = in_rect.y + (in_rect.height - button_size) / 2;
+    out_rect.width = button_size;
+    out_rect.height = button_size;
+
+    wxGTKDCImpl *impldc = (wxGTKDCImpl*) dc.GetImpl();
+    GdkWindow* window = impldc->GetGDKWindow();
+
+    if (button_state == wxAUI_BUTTON_STATE_HOVER)
+    {
+        gtk_paint_box(style_button, window,
+                      GTK_STATE_PRELIGHT, GTK_SHADOW_OUT, clipRect, widget, "button",
+                     out_rect.x, out_rect.y, out_rect.width, out_rect.height);
+    }
+    else if (button_state == wxAUI_BUTTON_STATE_PRESSED)
+    {
+        gtk_paint_box(style_button, window,
+                      GTK_STATE_ACTIVE, GTK_SHADOW_IN, clipRect, widget, "button",
+                      out_rect.x, out_rect.y, out_rect.width, out_rect.height);
+    }
+
+
+    dc.DrawBitmap(bmp, out_rect.x + xthickness, out_rect.y + ythickness, true);
+
+    return out_rect;
+}
+
+void wxAuiGtkTabArt::DrawTab(wxDC& dc, wxWindow* wnd, const wxAuiNotebookPage& page,
+                             const wxRect& in_rect, int close_button_state, wxRect* out_tab_rect,
+                             wxRect* out_button_rect, int* x_extent)
+{
+    GtkWidget *widget = wnd->GetHandle();
+    GtkStyle *style_notebook = gtk_widget_get_style(wxGTKPrivate::GetNotebookWidget());
+
+    wxRect const &window_rect = wnd->GetRect();
+
+    int focus_width = 0;
+
+    gtk_widget_style_get(wxGTKPrivate::GetNotebookWidget(),
+                         "focus-line-width", &focus_width,
+                         NULL);
+
+    int gap_x = 0, gap_width = 0;
+    int tab_pos;
+    if (m_flags &wxAUI_NB_BOTTOM)
+        tab_pos = wxAUI_NB_BOTTOM;
+    else //if (m_flags & wxAUI_NB_TOP) {}
+        tab_pos = wxAUI_NB_TOP;
+
+    // TODO: else if (m_flags &wxAUI_NB_LEFT) {}
+    // TODO: else if (m_flags &wxAUI_NB_RIGHT) {}
+
+    // figure out the size of the tab
+    wxSize tab_size = GetTabSize(dc, wnd, page.caption, page.bitmap,
+                                    page.active, close_button_state, x_extent);
+
+    wxRect tab_rect = in_rect;
+    tab_rect.width = tab_size.x;
+    tab_rect.height = tab_size.y;
+    tab_rect.y += 2 * m_TabHBorder;
+
+    if (page.active)
+        tab_rect.height += 2 * m_TabHBorder;
+    // if no bitmap is set, we need a tiny correction
+    if (! page.bitmap.IsOk())
+        tab_rect.height += 1;
+
+    int gap_height = 6 * m_TabHBorder;
+    int gap_y = tab_rect.y - gap_height;
+
+    switch (tab_pos)
+    {
+        case wxAUI_NB_TOP:
+            tab_rect.y -= 2 * m_TabHBorder;
+            if (!page.active)
+                tab_rect.y += 2 * m_TabHBorder;
+            gap_y = tab_rect.y + tab_rect.height;
+            // fall through
+        case wxAUI_NB_BOTTOM:
+            gap_x = tab_rect.x - m_TabVBorder / 2;
+            gap_width = tab_rect.width;
+            break;
+    }
+    tab_rect.y += m_TabHBorder / 2;
+    gap_y += m_TabHBorder / 2;
+
+    int padding = focus_width + m_TabHBorder;
+
+    int clip_width = tab_rect.width;
+    if (tab_rect.x + tab_rect.width > in_rect.x + in_rect.width)
+        clip_width = (in_rect.x + in_rect.width) - tab_rect.x;
+
+    dc.SetClippingRegion(tab_rect.x, tab_rect.y - m_TabVBorder, clip_width, tab_rect.height + m_TabVBorder);
+
+    GdkRectangle area;
+    area.x = tab_rect.x - m_TabVBorder;
+    area.y = tab_rect.y - 2 * m_TabHBorder;
+    area.width = clip_width + m_TabVBorder;
+    area.height = tab_rect.height + 2 * m_TabHBorder;
+
+    wxGTKDCImpl *impldc = (wxGTKDCImpl*) dc.GetImpl();
+    GdkWindow* window = impldc->GetGDKWindow();
+
+    // if page is active, we draw a box without border, in some styles the gap is transparent (e.g. Human)
+    // and a line would be visible at the bottom of the tab
+//    gtk_paint_box(style_notebook, window, GTK_STATE_NORMAL,page.active?GTK_SHADOW_NONE:GTK_SHADOW_OUT,
+//                  NULL, widget, "notebook",
+//                  window_rect.x, in_rect.y + in_rect.height - 3 * m_Ythickness, window_rect.width, 4 * m_Ythickness);
+    if (tab_pos == wxAUI_NB_BOTTOM)
+    {
+        if (page.active)
+        {
+            gtk_paint_box_gap(style_notebook, window, GTK_STATE_NORMAL, GTK_SHADOW_OUT,
+                              NULL, widget, "notebook",
+                              window_rect.x, gap_y,
+                              window_rect.width, gap_height,
+                              GTK_POS_BOTTOM, gap_x , gap_width);
+        }
+        gtk_paint_extension(style_notebook, window,
+                           page.active ? GTK_STATE_NORMAL : GTK_STATE_ACTIVE, GTK_SHADOW_OUT,
+                           &area, widget, "tab",
+                           tab_rect.x, tab_rect.y,
+                           tab_rect.width, tab_rect.height,
+                           GTK_POS_TOP);
+    }
+    else
+    {
+        if (page.active)
+        {
+            gtk_paint_box_gap(style_notebook, window, GTK_STATE_NORMAL, GTK_SHADOW_OUT,
+                              NULL, widget, "notebook",
+                              window_rect.x, gap_y,
+                              window_rect.width, gap_height,
+                              GTK_POS_TOP, gap_x , gap_width);
+        }
+        gtk_paint_extension(style_notebook, window,
+                           page.active ? GTK_STATE_NORMAL : GTK_STATE_ACTIVE, GTK_SHADOW_OUT,
+                           &area, widget, "tab",
+                           tab_rect.x, tab_rect.y,
+                           tab_rect.width, tab_rect.height,
+                           GTK_POS_BOTTOM);
+    }
+
+    wxCoord textX = tab_rect.x + padding + m_Xthickness;
+
+    int bitmap_offset = 0;
+    if (page.bitmap.IsOk())
+    {
+        bitmap_offset = textX;
+
+        // draw bitmap
+        int bitmapY = tab_rect.y +(tab_rect.height - page.bitmap.GetHeight()) / 2;
+        if(!page.active)
+        {
+            if (tab_pos == wxAUI_NB_TOP)
+                bitmapY += m_Ythickness / 2;
+            else
+                bitmapY -= m_Ythickness / 2;
+        }
+        dc.DrawBitmap(page.bitmap,
+                      bitmap_offset,
+                      bitmapY,
+                      true);
+
+        textX += page.bitmap.GetWidth() + padding;
+    }
+
+    wxCoord textW, textH, textY;
+
+    dc.SetFont(m_normalFont);
+    dc.GetTextExtent(page.caption, &textW, &textH);
+    textY = tab_rect.y + (tab_rect.height - textH) / 2;
+    if(!page.active)
+    {
+        if (tab_pos == wxAUI_NB_TOP)
+            textY += m_Ythickness / 2;
+        else
+            textY -= m_Ythickness / 2;
+    }
+
+    // draw tab text
+    GdkColor text_colour = page.active ? style_notebook->fg[GTK_STATE_NORMAL] : style_notebook->fg[GTK_STATE_ACTIVE];
+    dc.SetTextForeground(wxColor(text_colour));
+    GdkRectangle focus_area;
+
+    int padding_focus = padding - focus_width;
+    focus_area.x = tab_rect.x + padding_focus;
+    focus_area.y = textY - focus_width;
+    focus_area.width = tab_rect.width - 2 * padding_focus;
+    focus_area.height = textH + 2 * focus_width;
+
+    if(page.active && (wnd->FindFocus() == wnd) && focus_area.x <= (area.x + area.width))
+    {
+        // clipping seems not to work here, so we we have to recalc the focus-area manually
+        if((focus_area.x + focus_area.width) > (area.x + area.width))
+            focus_area.width = area.x + area.width - focus_area.x + focus_width - m_TabVBorder;
+        gtk_paint_focus (style_notebook, window,
+                         GTK_STATE_ACTIVE, NULL, widget, "tab",
+                         focus_area.x, focus_area.y, focus_area.width, focus_area.height);
+    }
+
+    dc.DrawText(page.caption, textX, textY);
+
+    // draw close-button on tab (if enabled)
+    if (close_button_state != wxAUI_BUTTON_STATE_HIDDEN)
+    {
+        wxRect rect(tab_rect.x, tab_rect.y, tab_rect.width - m_Xthickness, tab_rect.height);
+        if(!page.active)
+        {
+            if (tab_pos == wxAUI_NB_TOP)
+                rect.y += m_Ythickness / 2;
+            else
+                rect.y -= m_Ythickness / 2;
+        }
+        *out_button_rect = DrawCloseButton(dc, widget, close_button_state, rect, wxRIGHT, &area);
+    }
+
+    tab_rect.width = std::min(tab_rect.width, clip_width);
+    *out_tab_rect = tab_rect;
+
+    dc.DestroyClippingRegion();
+}
+
+wxRect DrawSimpleArrow(wxDC& dc,
+                       GtkWidget *widget,
+                       int button_state,
+                       wxRect const &in_rect,
+                       int orientation,
+                       GtkArrowType arrow_type)
+{
+    int scroll_arrow_hlength, scroll_arrow_vlength;
+    gtk_widget_style_get(widget,
+                         "scroll-arrow-hlength", &scroll_arrow_hlength,
+                         "scroll-arrow-vlength", &scroll_arrow_vlength,
+                         NULL);
+
+    GtkStateType state;
+    GtkShadowType shadow;
+    ButtonStateAndShadow(button_state, state, shadow);
+
+    wxRect out_rect;
+
+    if (orientation == wxLEFT)
+        out_rect.x = in_rect.x;
+    else
+        out_rect.x = in_rect.x + in_rect.width - scroll_arrow_hlength;
+    out_rect.y = (in_rect.y + in_rect.height - 3 * gtk_widget_get_style(wxGTKPrivate::GetNotebookWidget())->ythickness - scroll_arrow_vlength) / 2;
+    out_rect.width = scroll_arrow_hlength;
+    out_rect.height = scroll_arrow_vlength;
+
+    wxGTKDCImpl *impldc = (wxGTKDCImpl*) dc.GetImpl();
+    GdkWindow* window = impldc->GetGDKWindow();
+    gtk_paint_arrow (gtk_widget_get_style(wxGTKPrivate::GetButtonWidget()), window, state, shadow, NULL, widget, "notebook",
+                     arrow_type, TRUE, out_rect.x, out_rect.y, out_rect.width, out_rect.height);
+
+    return out_rect;
+}
+
+wxRect MakeButtonScaledRect(wxRect const &button_rect,
+                            float scale)
+{
+    GtkStyle *style_button = gtk_widget_get_style(wxGTKPrivate::GetButtonWidget());
+    wxRect r;
+    r.width = (button_rect.width - 2 * style_button->xthickness);
+    r.height = (button_rect.height - 2 * style_button->ythickness);
+    r.x = button_rect.x + roundf(r.width * (1.0f - scale) / 2.0) + style_button->xthickness;
+    r.y = button_rect.y + roundf(r.height * (1.0f - scale) / 2.0) + style_button->ythickness;
+    r.width = roundf(r.width * scale);
+    r.height = roundf(r.height * scale);
+    return r;
+}
+
+void wxAuiGtkTabArt::DrawButton(wxDC& dc, wxWindow* wnd,
+                            const wxRect& in_rect,
+                            int bitmap_id,
+                            int button_state,
+                            int orientation,
+                            wxRect* out_rect)
+{
+    GtkWidget *widget = wnd->GetHandle();
+    wxRect rect;
+
+    switch (bitmap_id)
+    {
+        case wxAUI_BUTTON_CLOSE:
+            rect = in_rect;
+            rect.y -= 2 * gtk_widget_get_style(wxGTKPrivate::GetButtonWidget())->ythickness;
+            rect = DrawCloseButton(dc, widget, button_state, rect, orientation, NULL);
+            break;
+
+        case wxAUI_BUTTON_LEFT:
+            rect = DrawSimpleArrow(dc, widget, button_state, in_rect, orientation, GTK_ARROW_LEFT);
+            break;
+
+        case wxAUI_BUTTON_RIGHT:
+            rect = DrawSimpleArrow(dc, widget, button_state, in_rect, orientation, GTK_ARROW_RIGHT);
+            break;
+
+        case wxAUI_BUTTON_WINDOWLIST:
+            {
+                float const scale = 0.5f;
+
+                rect = DrawSimpleButton(dc, widget, button_state, in_rect);//, s_CloseIconSize);
+
+                wxRect const &arrow = MakeButtonScaledRect(rect, scale);
+                GtkStateType state;
+                GtkShadowType shadow;
+
+                ButtonStateAndShadow(button_state, state, shadow);
+
+                wxGTKDCImpl *impldc = (wxGTKDCImpl*) dc.GetImpl();
+                GdkWindow *window = impldc->GetGDKWindow();
+                gtk_paint_arrow(gtk_widget_get_style(wxGTKPrivate::GetNotebookWidget()), window, state,
+                                shadow, NULL, widget, "notebook",
+                                GTK_ARROW_DOWN, TRUE,
+                                arrow.x, arrow.y, arrow.width, arrow.height);
+            }
+            break;
+    }
+
+    *out_rect = rect;
+}
+
+
+int wxAuiGtkTabArt::GetBestTabCtrlSize(wxWindow* wnd,
+                                   const wxAuiNotebookPageArray& pages,
+                                   const wxSize& required_bmp_size)
+{
+    SetMeasuringFont(m_normalFont);
+    SetSelectedFont(m_normalFont);
+    int tab_height = 3 * gtk_widget_get_style(wxGTKPrivate::GetNotebookWidget())->ythickness + wxAuiGenericTabArt::GetBestTabCtrlSize(wnd, pages, required_bmp_size);
+    return tab_height;
+}
+
+wxSize wxAuiGtkTabArt::GetTabSize(wxDC& dc,
+                              wxWindow* wnd,
+                              const wxString& caption,
+                              const wxBitmap& bitmap,
+                              bool active,
+                              int close_button_state,
+                              int* x_extent)
+{
+    wxSize s = wxAuiGenericTabArt::GetTabSize(dc, wnd, caption, bitmap, active, close_button_state, x_extent);
+
+    int overlap = 0;
+    gtk_widget_style_get (wnd->GetHandle(),
+        "focus-line-width", &overlap,
+        NULL);
+    *x_extent -= overlap;
+    return s;
+}
+#endif  // wxUSE_AUI
Index: src/aui/auibook.cpp
===================================================================
--- src/aui/auibook.cpp	(Revision 70939)
+++ src/aui/auibook.cpp	(Arbeitskopie)
@@ -2,7 +2,7 @@
 // Name:        src/aui/auibook.cpp
 // Purpose:     wxaui: wx advanced user interface - notebook
 // Author:      Benjamin I. Williams
-// Modified by:
+// Modified by: Jens Lody
 // Created:     2006-06-28
 // Copyright:   (C) Copyright 2006, Kirix Corporation, All Rights Reserved
 // Licence:     wxWindows Library Licence, Version 3.1
@@ -24,14 +24,10 @@
 
 #ifndef WX_PRECOMP
     #include "wx/settings.h"
-    #include "wx/image.h"
-    #include "wx/menu.h"
+    #include "wx/clientdc.h"
 #endif
 
 #include "wx/aui/tabmdi.h"
-#include "wx/dcbuffer.h"
-
-#include "wx/renderer.h"
 
 #ifdef __WXMAC__
 #include "wx/osx/private.h"
@@ -63,1234 +59,6 @@
 IMPLEMENT_DYNAMIC_CLASS(wxAuiNotebookEvent, wxBookCtrlEvent)
 
 
-
-
-
-// these functions live in dockart.cpp -- they'll eventually
-// be moved to a new utility cpp file
-
-wxBitmap wxAuiBitmapFromBits(const unsigned char bits[], int w, int h,
-                             const wxColour& color);
-
-wxString wxAuiChopText(wxDC& dc, const wxString& text, int max_size);
-
-static void DrawButtons(wxDC& dc,
-                        const wxRect& _rect,
-                        const wxBitmap& bmp,
-                        const wxColour& bkcolour,
-                        int button_state)
-{
-    wxRect rect = _rect;
-
-    if (button_state == wxAUI_BUTTON_STATE_PRESSED)
-    {
-        rect.x++;
-        rect.y++;
-    }
-
-    if (button_state == wxAUI_BUTTON_STATE_HOVER ||
-        button_state == wxAUI_BUTTON_STATE_PRESSED)
-    {
-        dc.SetBrush(wxBrush(bkcolour.ChangeLightness(120)));
-        dc.SetPen(wxPen(bkcolour.ChangeLightness(75)));
-
-        // draw the background behind the button
-        dc.DrawRectangle(rect.x, rect.y, 15, 15);
-    }
-
-    // draw the button itself
-    dc.DrawBitmap(bmp, rect.x, rect.y, true);
-}
-
-static void IndentPressedBitmap(wxRect* rect, int button_state)
-{
-    if (button_state == wxAUI_BUTTON_STATE_PRESSED)
-    {
-        rect->x++;
-        rect->y++;
-    }
-}
-
-
-
-// -- GUI helper classes and functions --
-
-class wxAuiCommandCapture : public wxEvtHandler
-{
-public:
-
-    wxAuiCommandCapture() { m_lastId = 0; }
-    int GetCommandId() const { return m_lastId; }
-
-    bool ProcessEvent(wxEvent& evt)
-    {
-        if (evt.GetEventType() == wxEVT_COMMAND_MENU_SELECTED)
-        {
-            m_lastId = evt.GetId();
-            return true;
-        }
-
-        if (GetNextHandler())
-            return GetNextHandler()->ProcessEvent(evt);
-
-        return false;
-    }
-
-private:
-    int m_lastId;
-};
-
-
-// -- bitmaps --
-
-#if defined( __WXMAC__ )
- static const unsigned char close_bits[]={
-     0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFE, 0x03, 0xF8, 0x01, 0xF0, 0x19, 0xF3,
-     0xB8, 0xE3, 0xF0, 0xE1, 0xE0, 0xE0, 0xF0, 0xE1, 0xB8, 0xE3, 0x19, 0xF3,
-     0x01, 0xF0, 0x03, 0xF8, 0x0F, 0xFE, 0xFF, 0xFF };
-#elif defined( __WXGTK__)
- static const unsigned char close_bits[]={
-     0xff, 0xff, 0xff, 0xff, 0x07, 0xf0, 0xfb, 0xef, 0xdb, 0xed, 0x8b, 0xe8,
-     0x1b, 0xec, 0x3b, 0xee, 0x1b, 0xec, 0x8b, 0xe8, 0xdb, 0xed, 0xfb, 0xef,
-     0x07, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
-#else
- static const unsigned char close_bits[]={
-     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xf3, 0xcf, 0xf9,
-     0x9f, 0xfc, 0x3f, 0xfe, 0x3f, 0xfe, 0x9f, 0xfc, 0xcf, 0xf9, 0xe7, 0xf3,
-     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-#endif
-
-static const unsigned char left_bits[] = {
-   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xfe, 0x3f, 0xfe,
-   0x1f, 0xfe, 0x0f, 0xfe, 0x1f, 0xfe, 0x3f, 0xfe, 0x7f, 0xfe, 0xff, 0xfe,
-   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-
-static const unsigned char right_bits[] = {
-   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0x9f, 0xff, 0x1f, 0xff,
-   0x1f, 0xfe, 0x1f, 0xfc, 0x1f, 0xfe, 0x1f, 0xff, 0x9f, 0xff, 0xdf, 0xff,
-   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-
-static const unsigned char list_bits[] = {
-   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-   0x0f, 0xf8, 0xff, 0xff, 0x0f, 0xf8, 0x1f, 0xfc, 0x3f, 0xfe, 0x7f, 0xff,
-   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-
-
-
-
-
-
-// -- wxAuiDefaultTabArt class implementation --
-
-wxAuiDefaultTabArt::wxAuiDefaultTabArt()
-{
-    m_normalFont = *wxNORMAL_FONT;
-    m_selectedFont = *wxNORMAL_FONT;
-    m_selectedFont.SetWeight(wxBOLD);
-    m_measuringFont = m_selectedFont;
-
-    m_fixedTabWidth = 100;
-    m_tabCtrlHeight = 0;
-
-#if defined( __WXMAC__ ) && wxOSX_USE_COCOA_OR_CARBON
-    wxColor baseColour = wxColour( wxMacCreateCGColorFromHITheme(kThemeBrushToolbarBackground));
-#else
-    wxColor baseColour = wxSystemSettings::GetColour(wxSYS_COLOUR_3DFACE);
-#endif
-
-    // the baseColour is too pale to use as our base colour,
-    // so darken it a bit --
-    if ((255-baseColour.Red()) +
-        (255-baseColour.Green()) +
-        (255-baseColour.Blue()) < 60)
-    {
-        baseColour = baseColour.ChangeLightness(92);
-    }
-
-    m_activeColour = baseColour;
-    m_baseColour = baseColour;
-    wxColor borderColour = baseColour.ChangeLightness(75);
-
-    m_borderPen = wxPen(borderColour);
-    m_baseColourPen = wxPen(m_baseColour);
-    m_baseColourBrush = wxBrush(m_baseColour);
-
-    m_activeCloseBmp = wxAuiBitmapFromBits(close_bits, 16, 16, *wxBLACK);
-    m_disabledCloseBmp = wxAuiBitmapFromBits(close_bits, 16, 16, wxColour(128,128,128));
-
-    m_activeLeftBmp = wxAuiBitmapFromBits(left_bits, 16, 16, *wxBLACK);
-    m_disabledLeftBmp = wxAuiBitmapFromBits(left_bits, 16, 16, wxColour(128,128,128));
-
-    m_activeRightBmp = wxAuiBitmapFromBits(right_bits, 16, 16, *wxBLACK);
-    m_disabledRightBmp = wxAuiBitmapFromBits(right_bits, 16, 16, wxColour(128,128,128));
-
-    m_activeWindowListBmp = wxAuiBitmapFromBits(list_bits, 16, 16, *wxBLACK);
-    m_disabledWindowListBmp = wxAuiBitmapFromBits(list_bits, 16, 16, wxColour(128,128,128));
-
-    m_flags = 0;
-}
-
-wxAuiDefaultTabArt::~wxAuiDefaultTabArt()
-{
-}
-
-wxAuiTabArt* wxAuiDefaultTabArt::Clone()
-{
-    return new wxAuiDefaultTabArt(*this);
-}
-
-void wxAuiDefaultTabArt::SetFlags(unsigned int flags)
-{
-    m_flags = flags;
-}
-
-void wxAuiDefaultTabArt::SetSizingInfo(const wxSize& tab_ctrl_size,
-                                       size_t tab_count)
-{
-    m_fixedTabWidth = 100;
-
-    int tot_width = (int)tab_ctrl_size.x - GetIndentSize() - 4;
-
-    if (m_flags & wxAUI_NB_CLOSE_BUTTON)
-        tot_width -= m_activeCloseBmp.GetWidth();
-    if (m_flags & wxAUI_NB_WINDOWLIST_BUTTON)
-        tot_width -= m_activeWindowListBmp.GetWidth();
-
-    if (tab_count > 0)
-    {
-        m_fixedTabWidth = tot_width/(int)tab_count;
-    }
-
-
-    if (m_fixedTabWidth < 100)
-        m_fixedTabWidth = 100;
-
-    if (m_fixedTabWidth > tot_width/2)
-        m_fixedTabWidth = tot_width/2;
-
-    if (m_fixedTabWidth > 220)
-        m_fixedTabWidth = 220;
-
-    m_tabCtrlHeight = tab_ctrl_size.y;
-}
-
-
-void wxAuiDefaultTabArt::DrawBackground(wxDC& dc,
-                                        wxWindow* WXUNUSED(wnd),
-                                        const wxRect& rect)
-{
-    // draw background
-
-    wxColor top_color       = m_baseColour.ChangeLightness(90);
-    wxColor bottom_color   = m_baseColour.ChangeLightness(170);
-    wxRect r;
-
-   if (m_flags &wxAUI_NB_BOTTOM)
-       r = wxRect(rect.x, rect.y, rect.width+2, rect.height);
-   // TODO: else if (m_flags &wxAUI_NB_LEFT) {}
-   // TODO: else if (m_flags &wxAUI_NB_RIGHT) {}
-   else //for wxAUI_NB_TOP
-       r = wxRect(rect.x, rect.y, rect.width+2, rect.height-3);
-
-    dc.GradientFillLinear(r, top_color, bottom_color, wxSOUTH);
-
-
-   // draw base lines
-
-   dc.SetPen(m_borderPen);
-   int y = rect.GetHeight();
-   int w = rect.GetWidth();
-
-   if (m_flags &wxAUI_NB_BOTTOM)
-   {
-       dc.SetBrush(wxBrush(bottom_color));
-       dc.DrawRectangle(-1, 0, w+2, 4);
-   }
-   // TODO: else if (m_flags &wxAUI_NB_LEFT) {}
-   // TODO: else if (m_flags &wxAUI_NB_RIGHT) {}
-   else //for wxAUI_NB_TOP
-   {
-       dc.SetBrush(m_baseColourBrush);
-       dc.DrawRectangle(-1, y-4, w+2, 4);
-   }
-}
-
-
-// DrawTab() draws an individual tab.
-//
-// dc       - output dc
-// in_rect  - rectangle the tab should be confined to
-// caption  - tab's caption
-// active   - whether or not the tab is active
-// out_rect - actual output rectangle
-// x_extent - the advance x; where the next tab should start
-
-void wxAuiDefaultTabArt::DrawTab(wxDC& dc,
-                                 wxWindow* wnd,
-                                 const wxAuiNotebookPage& page,
-                                 const wxRect& in_rect,
-                                 int close_button_state,
-                                 wxRect* out_tab_rect,
-                                 wxRect* out_button_rect,
-                                 int* x_extent)
-{
-    wxCoord normal_textx, normal_texty;
-    wxCoord selected_textx, selected_texty;
-    wxCoord texty;
-
-    // if the caption is empty, measure some temporary text
-    wxString caption = page.caption;
-    if (caption.empty())
-        caption = wxT("Xj");
-
-    dc.SetFont(m_selectedFont);
-    dc.GetTextExtent(caption, &selected_textx, &selected_texty);
-
-    dc.SetFont(m_normalFont);
-    dc.GetTextExtent(caption, &normal_textx, &normal_texty);
-
-    // figure out the size of the tab
-    wxSize tab_size = GetTabSize(dc,
-                                 wnd,
-                                 page.caption,
-                                 page.bitmap,
-                                 page.active,
-                                 close_button_state,
-                                 x_extent);
-
-    wxCoord tab_height = m_tabCtrlHeight - 3;
-    wxCoord tab_width = tab_size.x;
-    wxCoord tab_x = in_rect.x;
-    wxCoord tab_y = in_rect.y + in_rect.height - tab_height;
-
-
-    caption = page.caption;
-
-
-    // select pen, brush and font for the tab to be drawn
-
-    if (page.active)
-    {
-        dc.SetFont(m_selectedFont);
-        texty = selected_texty;
-    }
-    else
-    {
-        dc.SetFont(m_normalFont);
-        texty = normal_texty;
-    }
-
-
-    // create points that will make the tab outline
-
-    int clip_width = tab_width;
-    if (tab_x + clip_width > in_rect.x + in_rect.width)
-        clip_width = (in_rect.x + in_rect.width) - tab_x;
-
-/*
-    wxPoint clip_points[6];
-    clip_points[0] = wxPoint(tab_x,              tab_y+tab_height-3);
-    clip_points[1] = wxPoint(tab_x,              tab_y+2);
-    clip_points[2] = wxPoint(tab_x+2,            tab_y);
-    clip_points[3] = wxPoint(tab_x+clip_width-1, tab_y);
-    clip_points[4] = wxPoint(tab_x+clip_width+1, tab_y+2);
-    clip_points[5] = wxPoint(tab_x+clip_width+1, tab_y+tab_height-3);
-
-    // FIXME: these ports don't provide wxRegion ctor from array of points
-#if !defined(__WXDFB__) && !defined(__WXCOCOA__)
-    // set the clipping region for the tab --
-    wxRegion clipping_region(WXSIZEOF(clip_points), clip_points);
-    dc.SetClippingRegion(clipping_region);
-#endif // !wxDFB && !wxCocoa
-*/
-    // since the above code above doesn't play well with WXDFB or WXCOCOA,
-    // we'll just use a rectangle for the clipping region for now --
-    dc.SetClippingRegion(tab_x, tab_y, clip_width+1, tab_height-3);
-
-
-    wxPoint border_points[6];
-    if (m_flags &wxAUI_NB_BOTTOM)
-    {
-        border_points[0] = wxPoint(tab_x,             tab_y);
-        border_points[1] = wxPoint(tab_x,             tab_y+tab_height-6);
-        border_points[2] = wxPoint(tab_x+2,           tab_y+tab_height-4);
-        border_points[3] = wxPoint(tab_x+tab_width-2, tab_y+tab_height-4);
-        border_points[4] = wxPoint(tab_x+tab_width,   tab_y+tab_height-6);
-        border_points[5] = wxPoint(tab_x+tab_width,   tab_y);
-    }
-    else //if (m_flags & wxAUI_NB_TOP) {}
-    {
-        border_points[0] = wxPoint(tab_x,             tab_y+tab_height-4);
-        border_points[1] = wxPoint(tab_x,             tab_y+2);
-        border_points[2] = wxPoint(tab_x+2,           tab_y);
-        border_points[3] = wxPoint(tab_x+tab_width-2, tab_y);
-        border_points[4] = wxPoint(tab_x+tab_width,   tab_y+2);
-        border_points[5] = wxPoint(tab_x+tab_width,   tab_y+tab_height-4);
-    }
-    // TODO: else if (m_flags &wxAUI_NB_LEFT) {}
-    // TODO: else if (m_flags &wxAUI_NB_RIGHT) {}
-
-    int drawn_tab_yoff = border_points[1].y;
-    int drawn_tab_height = border_points[0].y - border_points[1].y;
-
-
-    if (page.active)
-    {
-        // draw active tab
-
-        // draw base background color
-        wxRect r(tab_x, tab_y, tab_width, tab_height);
-        dc.SetPen(wxPen(m_activeColour));
-        dc.SetBrush(wxBrush(m_activeColour));
-        dc.DrawRectangle(r.x+1, r.y+1, r.width-1, r.height-4);
-
-        // this white helps fill out the gradient at the top of the tab
-        dc.SetPen(*wxWHITE_PEN);
-        dc.SetBrush(*wxWHITE_BRUSH);
-        dc.DrawRectangle(r.x+2, r.y+1, r.width-3, r.height-4);
-
-        // these two points help the rounded corners appear more antialiased
-        dc.SetPen(wxPen(m_activeColour));
-        dc.DrawPoint(r.x+2, r.y+1);
-        dc.DrawPoint(r.x+r.width-2, r.y+1);
-
-        // set rectangle down a bit for gradient drawing
-        r.SetHeight(r.GetHeight()/2);
-        r.x += 2;
-        r.width -= 3;
-        r.y += r.height;
-        r.y -= 2;
-
-        // draw gradient background
-        wxColor top_color = *wxWHITE;
-        wxColor bottom_color = m_activeColour;
-        dc.GradientFillLinear(r, bottom_color, top_color, wxNORTH);
-    }
-    else
-    {
-        // draw inactive tab
-
-        wxRect r(tab_x, tab_y+1, tab_width, tab_height-3);
-
-        // start the gradent up a bit and leave the inside border inset
-        // by a pixel for a 3D look.  Only the top half of the inactive
-        // tab will have a slight gradient
-        r.x += 3;
-        r.y++;
-        r.width -= 4;
-        r.height /= 2;
-        r.height--;
-
-        // -- draw top gradient fill for glossy look
-        wxColor top_color = m_baseColour;
-        wxColor bottom_color = top_color.ChangeLightness(160);
-        dc.GradientFillLinear(r, bottom_color, top_color, wxNORTH);
-
-        r.y += r.height;
-        r.y--;
-
-        // -- draw bottom fill for glossy look
-        top_color = m_baseColour;
-        bottom_color = m_baseColour;
-        dc.GradientFillLinear(r, top_color, bottom_color, wxSOUTH);
-    }
-
-    // draw tab outline
-    dc.SetPen(m_borderPen);
-    dc.SetBrush(*wxTRANSPARENT_BRUSH);
-    dc.DrawPolygon(WXSIZEOF(border_points), border_points);
-
-    // there are two horizontal grey lines at the bottom of the tab control,
-    // this gets rid of the top one of those lines in the tab control
-    if (page.active)
-    {
-        if (m_flags &wxAUI_NB_BOTTOM)
-            dc.SetPen(wxPen(m_baseColour.ChangeLightness(170)));
-        // TODO: else if (m_flags &wxAUI_NB_LEFT) {}
-        // TODO: else if (m_flags &wxAUI_NB_RIGHT) {}
-        else //for wxAUI_NB_TOP
-            dc.SetPen(m_baseColourPen);
-        dc.DrawLine(border_points[0].x+1,
-                    border_points[0].y,
-                    border_points[5].x,
-                    border_points[5].y);
-    }
-
-
-    int text_offset = tab_x + 8;
-    int close_button_width = 0;
-    if (close_button_state != wxAUI_BUTTON_STATE_HIDDEN)
-    {
-        close_button_width = m_activeCloseBmp.GetWidth();
-    }
-
-    int bitmap_offset = 0;
-    if (page.bitmap.IsOk())
-    {
-        bitmap_offset = tab_x + 8;
-
-        // draw bitmap
-        dc.DrawBitmap(page.bitmap,
-                      bitmap_offset,
-                      drawn_tab_yoff + (drawn_tab_height/2) - (page.bitmap.GetHeight()/2),
-                      true);
-
-        text_offset = bitmap_offset + page.bitmap.GetWidth();
-        text_offset += 3; // bitmap padding
-
-    }
-    else
-    {
-        text_offset = tab_x + 8;
-    }
-
-
-    wxString draw_text = wxAuiChopText(dc,
-                          caption,
-                          tab_width - (text_offset-tab_x) - close_button_width);
-
-    // draw tab text
-    dc.DrawText(draw_text,
-                text_offset,
-                drawn_tab_yoff + (drawn_tab_height)/2 - (texty/2) - 1);
-
-    // draw focus rectangle
-    if (page.active && (wnd->FindFocus() == wnd))
-    {
-        wxRect focusRectText(text_offset, (drawn_tab_yoff + (drawn_tab_height)/2 - (texty/2) - 1),
-            selected_textx, selected_texty);
-
-        wxRect focusRect;
-        wxRect focusRectBitmap;
-
-        if (page.bitmap.IsOk())
-            focusRectBitmap = wxRect(bitmap_offset, drawn_tab_yoff + (drawn_tab_height/2) - (page.bitmap.GetHeight()/2),
-                                            page.bitmap.GetWidth(), page.bitmap.GetHeight());
-
-        if (page.bitmap.IsOk() && draw_text.IsEmpty())
-            focusRect = focusRectBitmap;
-        else if (!page.bitmap.IsOk() && !draw_text.IsEmpty())
-            focusRect = focusRectText;
-        else if (page.bitmap.IsOk() && !draw_text.IsEmpty())
-            focusRect = focusRectText.Union(focusRectBitmap);
-
-        focusRect.Inflate(2, 2);
-
-        wxRendererNative::Get().DrawFocusRect(wnd, dc, focusRect, 0);
-    }
-
-    // draw close button if necessary
-    if (close_button_state != wxAUI_BUTTON_STATE_HIDDEN)
-    {
-        wxBitmap bmp = m_disabledCloseBmp;
-
-        if (close_button_state == wxAUI_BUTTON_STATE_HOVER ||
-            close_button_state == wxAUI_BUTTON_STATE_PRESSED)
-        {
-            bmp = m_activeCloseBmp;
-        }
-
-        int offsetY = tab_y-1;
-        if (m_flags & wxAUI_NB_BOTTOM)
-            offsetY = 1;
-
-        wxRect rect(tab_x + tab_width - close_button_width - 1,
-                    offsetY + (tab_height/2) - (bmp.GetHeight()/2),
-                    close_button_width,
-                    tab_height);
-
-        IndentPressedBitmap(&rect, close_button_state);
-        dc.DrawBitmap(bmp, rect.x, rect.y, true);
-
-        *out_button_rect = rect;
-    }
-
-    *out_tab_rect = wxRect(tab_x, tab_y, tab_width, tab_height);
-
-    dc.DestroyClippingRegion();
-}
-
-int wxAuiDefaultTabArt::GetIndentSize()
-{
-    return 5;
-}
-
-wxSize wxAuiDefaultTabArt::GetTabSize(wxDC& dc,
-                                      wxWindow* WXUNUSED(wnd),
-                                      const wxString& caption,
-                                      const wxBitmap& bitmap,
-                                      bool WXUNUSED(active),
-                                      int close_button_state,
-                                      int* x_extent)
-{
-    wxCoord measured_textx, measured_texty, tmp;
-
-    dc.SetFont(m_measuringFont);
-    dc.GetTextExtent(caption, &measured_textx, &measured_texty);
-
-    dc.GetTextExtent(wxT("ABCDEFXj"), &tmp, &measured_texty);
-
-    // add padding around the text
-    wxCoord tab_width = measured_textx;
-    wxCoord tab_height = measured_texty;
-
-    // if the close button is showing, add space for it
-    if (close_button_state != wxAUI_BUTTON_STATE_HIDDEN)
-        tab_width += m_activeCloseBmp.GetWidth() + 3;
-
-    // if there's a bitmap, add space for it
-    if (bitmap.IsOk())
-    {
-        tab_width += bitmap.GetWidth();
-        tab_width += 3; // right side bitmap padding
-        tab_height = wxMax(tab_height, bitmap.GetHeight());
-    }
-
-    // add padding
-    tab_width += 16;
-    tab_height += 10;
-
-    if (m_flags & wxAUI_NB_TAB_FIXED_WIDTH)
-    {
-        tab_width = m_fixedTabWidth;
-    }
-
-    *x_extent = tab_width;
-
-    return wxSize(tab_width, tab_height);
-}
-
-
-void wxAuiDefaultTabArt::DrawButton(wxDC& dc,
-                                    wxWindow* WXUNUSED(wnd),
-                                    const wxRect& in_rect,
-                                    int bitmap_id,
-                                    int button_state,
-                                    int orientation,
-                                    wxRect* out_rect)
-{
-    wxBitmap bmp;
-    wxRect rect;
-
-    switch (bitmap_id)
-    {
-        case wxAUI_BUTTON_CLOSE:
-            if (button_state & wxAUI_BUTTON_STATE_DISABLED)
-                bmp = m_disabledCloseBmp;
-            else
-                bmp = m_activeCloseBmp;
-            break;
-        case wxAUI_BUTTON_LEFT:
-            if (button_state & wxAUI_BUTTON_STATE_DISABLED)
-                bmp = m_disabledLeftBmp;
-            else
-                bmp = m_activeLeftBmp;
-            break;
-        case wxAUI_BUTTON_RIGHT:
-            if (button_state & wxAUI_BUTTON_STATE_DISABLED)
-                bmp = m_disabledRightBmp;
-            else
-                bmp = m_activeRightBmp;
-            break;
-        case wxAUI_BUTTON_WINDOWLIST:
-            if (button_state & wxAUI_BUTTON_STATE_DISABLED)
-                bmp = m_disabledWindowListBmp;
-            else
-                bmp = m_activeWindowListBmp;
-            break;
-    }
-
-
-    if (!bmp.IsOk())
-        return;
-
-    rect = in_rect;
-
-    if (orientation == wxLEFT)
-    {
-        rect.SetX(in_rect.x);
-        rect.SetY(((in_rect.y + in_rect.height)/2) - (bmp.GetHeight()/2));
-        rect.SetWidth(bmp.GetWidth());
-        rect.SetHeight(bmp.GetHeight());
-    }
-    else
-    {
-        rect = wxRect(in_rect.x + in_rect.width - bmp.GetWidth(),
-                      ((in_rect.y + in_rect.height)/2) - (bmp.GetHeight()/2),
-                      bmp.GetWidth(), bmp.GetHeight());
-    }
-
-    IndentPressedBitmap(&rect, button_state);
-    dc.DrawBitmap(bmp, rect.x, rect.y, true);
-
-    *out_rect = rect;
-}
-
-int wxAuiDefaultTabArt::ShowDropDown(wxWindow* wnd,
-                                     const wxAuiNotebookPageArray& pages,
-                                     int /*active_idx*/)
-{
-    wxMenu menuPopup;
-
-    size_t i, count = pages.GetCount();
-    for (i = 0; i < count; ++i)
-    {
-        const wxAuiNotebookPage& page = pages.Item(i);
-        wxString caption = page.caption;
-
-        // if there is no caption, make it a space.  This will prevent
-        // an assert in the menu code.
-        if (caption.IsEmpty())
-            caption = wxT(" ");
-
-        wxMenuItem* item = new wxMenuItem(NULL, 1000+i, caption);
-        if (page.bitmap.IsOk())
-            item->SetBitmap(page.bitmap);
-        menuPopup.Append(item);
-    }
-
-    // find out where to put the popup menu of window items
-    wxPoint pt = ::wxGetMousePosition();
-    pt = wnd->ScreenToClient(pt);
-
-    // find out the screen coordinate at the bottom of the tab ctrl
-    wxRect cli_rect = wnd->GetClientRect();
-    pt.y = cli_rect.y + cli_rect.height;
-
-    wxAuiCommandCapture* cc = new wxAuiCommandCapture;
-    wnd->PushEventHandler(cc);
-    wnd->PopupMenu(&menuPopup, pt);
-    int command = cc->GetCommandId();
-    wnd->PopEventHandler(true);
-
-    if (command >= 1000)
-        return command-1000;
-
-    return -1;
-}
-
-int wxAuiDefaultTabArt::GetBestTabCtrlSize(wxWindow* wnd,
-                                           const wxAuiNotebookPageArray& pages,
-                                           const wxSize& requiredBmp_size)
-{
-    wxClientDC dc(wnd);
-    dc.SetFont(m_measuringFont);
-
-    // sometimes a standard bitmap size needs to be enforced, especially
-    // if some tabs have bitmaps and others don't.  This is important because
-    // it prevents the tab control from resizing when tabs are added.
-    wxBitmap measureBmp;
-    if (requiredBmp_size.IsFullySpecified())
-    {
-        measureBmp.Create(requiredBmp_size.x,
-                           requiredBmp_size.y);
-    }
-
-
-    int max_y = 0;
-    size_t i, page_count = pages.GetCount();
-    for (i = 0; i < page_count; ++i)
-    {
-        wxAuiNotebookPage& page = pages.Item(i);
-
-        wxBitmap bmp;
-        if (measureBmp.IsOk())
-            bmp = measureBmp;
-        else
-            bmp = page.bitmap;
-
-        // we don't use the caption text because we don't
-        // want tab heights to be different in the case
-        // of a very short piece of text on one tab and a very
-        // tall piece of text on another tab
-        int x_ext = 0;
-        wxSize s = GetTabSize(dc,
-                              wnd,
-                              wxT("ABCDEFGHIj"),
-                              bmp,
-                              true,
-                              wxAUI_BUTTON_STATE_HIDDEN,
-                              &x_ext);
-
-        max_y = wxMax(max_y, s.y);
-    }
-
-    return max_y+2;
-}
-
-void wxAuiDefaultTabArt::SetNormalFont(const wxFont& font)
-{
-    m_normalFont = font;
-}
-
-void wxAuiDefaultTabArt::SetSelectedFont(const wxFont& font)
-{
-    m_selectedFont = font;
-}
-
-void wxAuiDefaultTabArt::SetMeasuringFont(const wxFont& font)
-{
-    m_measuringFont = font;
-}
-
-void wxAuiDefaultTabArt::SetColour(const wxColour& colour)
-{
-    m_baseColour = colour;
-    m_borderPen = wxPen(m_baseColour.ChangeLightness(75));
-    m_baseColourPen = wxPen(m_baseColour);
-    m_baseColourBrush = wxBrush(m_baseColour);
-}
-
-void wxAuiDefaultTabArt::SetActiveColour(const wxColour& colour)
-{
-    m_activeColour = colour;
-}
-
-// -- wxAuiSimpleTabArt class implementation --
-
-wxAuiSimpleTabArt::wxAuiSimpleTabArt()
-{
-    m_normalFont = *wxNORMAL_FONT;
-    m_selectedFont = *wxNORMAL_FONT;
-    m_selectedFont.SetWeight(wxBOLD);
-    m_measuringFont = m_selectedFont;
-
-    m_flags = 0;
-    m_fixedTabWidth = 100;
-
-    wxColour baseColour = wxSystemSettings::GetColour(wxSYS_COLOUR_3DFACE);
-
-    wxColour backgroundColour = baseColour;
-    wxColour normaltabColour = baseColour;
-    wxColour selectedtabColour = *wxWHITE;
-
-    m_bkBrush = wxBrush(backgroundColour);
-    m_normalBkBrush = wxBrush(normaltabColour);
-    m_normalBkPen = wxPen(normaltabColour);
-    m_selectedBkBrush = wxBrush(selectedtabColour);
-    m_selectedBkPen = wxPen(selectedtabColour);
-
-    m_activeCloseBmp = wxAuiBitmapFromBits(close_bits, 16, 16, *wxBLACK);
-    m_disabledCloseBmp = wxAuiBitmapFromBits(close_bits, 16, 16, wxColour(128,128,128));
-
-    m_activeLeftBmp = wxAuiBitmapFromBits(left_bits, 16, 16, *wxBLACK);
-    m_disabledLeftBmp = wxAuiBitmapFromBits(left_bits, 16, 16, wxColour(128,128,128));
-
-    m_activeRightBmp = wxAuiBitmapFromBits(right_bits, 16, 16, *wxBLACK);
-    m_disabledRightBmp = wxAuiBitmapFromBits(right_bits, 16, 16, wxColour(128,128,128));
-
-    m_activeWindowListBmp = wxAuiBitmapFromBits(list_bits, 16, 16, *wxBLACK);
-    m_disabledWindowListBmp = wxAuiBitmapFromBits(list_bits, 16, 16, wxColour(128,128,128));
-
-}
-
-wxAuiSimpleTabArt::~wxAuiSimpleTabArt()
-{
-}
-
-wxAuiTabArt* wxAuiSimpleTabArt::Clone()
-{
-    return new wxAuiSimpleTabArt(*this);
-}
-
-void wxAuiSimpleTabArt::SetFlags(unsigned int flags)
-{
-    m_flags = flags;
-}
-
-void wxAuiSimpleTabArt::SetSizingInfo(const wxSize& tab_ctrl_size,
-                                      size_t tab_count)
-{
-    m_fixedTabWidth = 100;
-
-    int tot_width = (int)tab_ctrl_size.x - GetIndentSize() - 4;
-
-    if (m_flags & wxAUI_NB_CLOSE_BUTTON)
-        tot_width -= m_activeCloseBmp.GetWidth();
-    if (m_flags & wxAUI_NB_WINDOWLIST_BUTTON)
-        tot_width -= m_activeWindowListBmp.GetWidth();
-
-    if (tab_count > 0)
-    {
-        m_fixedTabWidth = tot_width/(int)tab_count;
-    }
-
-
-    if (m_fixedTabWidth < 100)
-        m_fixedTabWidth = 100;
-
-    if (m_fixedTabWidth > tot_width/2)
-        m_fixedTabWidth = tot_width/2;
-
-    if (m_fixedTabWidth > 220)
-        m_fixedTabWidth = 220;
-}
-
-void wxAuiSimpleTabArt::SetColour(const wxColour& colour)
-{
-    m_bkBrush = wxBrush(colour);
-    m_normalBkBrush = wxBrush(colour);
-    m_normalBkPen = wxPen(colour);
-}
-
-void wxAuiSimpleTabArt::SetActiveColour(const wxColour& colour)
-{
-    m_selectedBkBrush = wxBrush(colour);
-    m_selectedBkPen = wxPen(colour);
-}
-
-void wxAuiSimpleTabArt::DrawBackground(wxDC& dc,
-                                       wxWindow* WXUNUSED(wnd),
-                                       const wxRect& rect)
-{
-    // draw background
-    dc.SetBrush(m_bkBrush);
-    dc.SetPen(*wxTRANSPARENT_PEN);
-    dc.DrawRectangle(-1, -1, rect.GetWidth()+2, rect.GetHeight()+2);
-
-    // draw base line
-    dc.SetPen(*wxGREY_PEN);
-    dc.DrawLine(0, rect.GetHeight()-1, rect.GetWidth(), rect.GetHeight()-1);
-}
-
-
-// DrawTab() draws an individual tab.
-//
-// dc       - output dc
-// in_rect  - rectangle the tab should be confined to
-// caption  - tab's caption
-// active   - whether or not the tab is active
-// out_rect - actual output rectangle
-// x_extent - the advance x; where the next tab should start
-
-void wxAuiSimpleTabArt::DrawTab(wxDC& dc,
-                                wxWindow* wnd,
-                                const wxAuiNotebookPage& page,
-                                const wxRect& in_rect,
-                                int close_button_state,
-                                wxRect* out_tab_rect,
-                                wxRect* out_button_rect,
-                                int* x_extent)
-{
-    wxCoord normal_textx, normal_texty;
-    wxCoord selected_textx, selected_texty;
-    wxCoord textx, texty;
-
-    // if the caption is empty, measure some temporary text
-    wxString caption = page.caption;
-    if (caption.empty())
-        caption = wxT("Xj");
-
-    dc.SetFont(m_selectedFont);
-    dc.GetTextExtent(caption, &selected_textx, &selected_texty);
-
-    dc.SetFont(m_normalFont);
-    dc.GetTextExtent(caption, &normal_textx, &normal_texty);
-
-    // figure out the size of the tab
-    wxSize tab_size = GetTabSize(dc,
-                                 wnd,
-                                 page.caption,
-                                 page.bitmap,
-                                 page.active,
-                                 close_button_state,
-                                 x_extent);
-
-    wxCoord tab_height = tab_size.y;
-    wxCoord tab_width = tab_size.x;
-    wxCoord tab_x = in_rect.x;
-    wxCoord tab_y = in_rect.y + in_rect.height - tab_height;
-
-    caption = page.caption;
-
-    // select pen, brush and font for the tab to be drawn
-
-    if (page.active)
-    {
-        dc.SetPen(m_selectedBkPen);
-        dc.SetBrush(m_selectedBkBrush);
-        dc.SetFont(m_selectedFont);
-        textx = selected_textx;
-        texty = selected_texty;
-    }
-    else
-    {
-        dc.SetPen(m_normalBkPen);
-        dc.SetBrush(m_normalBkBrush);
-        dc.SetFont(m_normalFont);
-        textx = normal_textx;
-        texty = normal_texty;
-    }
-
-
-    // -- draw line --
-
-    wxPoint points[7];
-    points[0].x = tab_x;
-    points[0].y = tab_y + tab_height - 1;
-    points[1].x = tab_x + tab_height - 3;
-    points[1].y = tab_y + 2;
-    points[2].x = tab_x + tab_height + 3;
-    points[2].y = tab_y;
-    points[3].x = tab_x + tab_width - 2;
-    points[3].y = tab_y;
-    points[4].x = tab_x + tab_width;
-    points[4].y = tab_y + 2;
-    points[5].x = tab_x + tab_width;
-    points[5].y = tab_y + tab_height - 1;
-    points[6] = points[0];
-
-    dc.SetClippingRegion(in_rect);
-
-    dc.DrawPolygon(WXSIZEOF(points) - 1, points);
-
-    dc.SetPen(*wxGREY_PEN);
-
-    //dc.DrawLines(active ? WXSIZEOF(points) - 1 : WXSIZEOF(points), points);
-    dc.DrawLines(WXSIZEOF(points), points);
-
-
-    int text_offset;
-
-    int close_button_width = 0;
-    if (close_button_state != wxAUI_BUTTON_STATE_HIDDEN)
-    {
-        close_button_width = m_activeCloseBmp.GetWidth();
-        text_offset = tab_x + (tab_height/2) + ((tab_width-close_button_width)/2) - (textx/2);
-    }
-    else
-    {
-        text_offset = tab_x + (tab_height/3) + (tab_width/2) - (textx/2);
-    }
-
-    // set minimum text offset
-    if (text_offset < tab_x + tab_height)
-        text_offset = tab_x + tab_height;
-
-    // chop text if necessary
-    wxString draw_text = wxAuiChopText(dc,
-                          caption,
-                          tab_width - (text_offset-tab_x) - close_button_width);
-
-    // draw tab text
-    dc.DrawText(draw_text,
-                 text_offset,
-                 (tab_y + tab_height)/2 - (texty/2) + 1);
-
-
-    // draw focus rectangle
-    if (page.active && (wnd->FindFocus() == wnd))
-    {
-        wxRect focusRect(text_offset, ((tab_y + tab_height)/2 - (texty/2) + 1),
-            selected_textx, selected_texty);
-
-        focusRect.Inflate(2, 2);
-
-        wxRendererNative::Get().DrawFocusRect(wnd, dc, focusRect, 0);
-    }
-
-    // draw close button if necessary
-    if (close_button_state != wxAUI_BUTTON_STATE_HIDDEN)
-    {
-        wxBitmap bmp;
-        if (page.active)
-            bmp = m_activeCloseBmp;
-        else
-            bmp = m_disabledCloseBmp;
-
-        wxRect rect(tab_x + tab_width - close_button_width - 1,
-                    tab_y + (tab_height/2) - (bmp.GetHeight()/2) + 1,
-                    close_button_width,
-                    tab_height - 1);
-        DrawButtons(dc, rect, bmp, *wxWHITE, close_button_state);
-
-        *out_button_rect = rect;
-    }
-
-
-    *out_tab_rect = wxRect(tab_x, tab_y, tab_width, tab_height);
-
-    dc.DestroyClippingRegion();
-}
-
-int wxAuiSimpleTabArt::GetIndentSize()
-{
-    return 0;
-}
-
-wxSize wxAuiSimpleTabArt::GetTabSize(wxDC& dc,
-                                     wxWindow* WXUNUSED(wnd),
-                                     const wxString& caption,
-                                     const wxBitmap& WXUNUSED(bitmap),
-                                     bool WXUNUSED(active),
-                                     int close_button_state,
-                                     int* x_extent)
-{
-    wxCoord measured_textx, measured_texty;
-
-    dc.SetFont(m_measuringFont);
-    dc.GetTextExtent(caption, &measured_textx, &measured_texty);
-
-    wxCoord tab_height = measured_texty + 4;
-    wxCoord tab_width = measured_textx + tab_height + 5;
-
-    if (close_button_state != wxAUI_BUTTON_STATE_HIDDEN)
-        tab_width += m_activeCloseBmp.GetWidth();
-
-    if (m_flags & wxAUI_NB_TAB_FIXED_WIDTH)
-    {
-        tab_width = m_fixedTabWidth;
-    }
-
-    *x_extent = tab_width - (tab_height/2) - 1;
-
-    return wxSize(tab_width, tab_height);
-}
-
-
-void wxAuiSimpleTabArt::DrawButton(wxDC& dc,
-                                   wxWindow* WXUNUSED(wnd),
-                                   const wxRect& in_rect,
-                                   int bitmap_id,
-                                   int button_state,
-                                   int orientation,
-                                   wxRect* out_rect)
-{
-    wxBitmap bmp;
-    wxRect rect;
-
-    switch (bitmap_id)
-    {
-        case wxAUI_BUTTON_CLOSE:
-            if (button_state & wxAUI_BUTTON_STATE_DISABLED)
-                bmp = m_disabledCloseBmp;
-            else
-                bmp = m_activeCloseBmp;
-            break;
-        case wxAUI_BUTTON_LEFT:
-            if (button_state & wxAUI_BUTTON_STATE_DISABLED)
-                bmp = m_disabledLeftBmp;
-            else
-                bmp = m_activeLeftBmp;
-            break;
-        case wxAUI_BUTTON_RIGHT:
-            if (button_state & wxAUI_BUTTON_STATE_DISABLED)
-                bmp = m_disabledRightBmp;
-            else
-                bmp = m_activeRightBmp;
-            break;
-        case wxAUI_BUTTON_WINDOWLIST:
-            if (button_state & wxAUI_BUTTON_STATE_DISABLED)
-                bmp = m_disabledWindowListBmp;
-            else
-                bmp = m_activeWindowListBmp;
-            break;
-    }
-
-    if (!bmp.IsOk())
-        return;
-
-    rect = in_rect;
-
-    if (orientation == wxLEFT)
-    {
-        rect.SetX(in_rect.x);
-        rect.SetY(((in_rect.y + in_rect.height)/2) - (bmp.GetHeight()/2));
-        rect.SetWidth(bmp.GetWidth());
-        rect.SetHeight(bmp.GetHeight());
-    }
-    else
-    {
-        rect = wxRect(in_rect.x + in_rect.width - bmp.GetWidth(),
-                      ((in_rect.y + in_rect.height)/2) - (bmp.GetHeight()/2),
-                      bmp.GetWidth(), bmp.GetHeight());
-    }
-
-
-    DrawButtons(dc, rect, bmp, *wxWHITE, button_state);
-
-    *out_rect = rect;
-}
-
-int wxAuiSimpleTabArt::ShowDropDown(wxWindow* wnd,
-                                    const wxAuiNotebookPageArray& pages,
-                                    int active_idx)
-{
-    wxMenu menuPopup;
-
-    size_t i, count = pages.GetCount();
-    for (i = 0; i < count; ++i)
-    {
-        const wxAuiNotebookPage& page = pages.Item(i);
-        menuPopup.AppendCheckItem(1000+i, page.caption);
-    }
-
-    if (active_idx != -1)
-    {
-        menuPopup.Check(1000+active_idx, true);
-    }
-
-    // find out where to put the popup menu of window
-    // items.  Subtract 100 for now to center the menu
-    // a bit, until a better mechanism can be implemented
-    wxPoint pt = ::wxGetMousePosition();
-    pt = wnd->ScreenToClient(pt);
-    if (pt.x < 100)
-        pt.x = 0;
-    else
-        pt.x -= 100;
-
-    // find out the screen coordinate at the bottom of the tab ctrl
-    wxRect cli_rect = wnd->GetClientRect();
-    pt.y = cli_rect.y + cli_rect.height;
-
-    wxAuiCommandCapture* cc = new wxAuiCommandCapture;
-    wnd->PushEventHandler(cc);
-    wnd->PopupMenu(&menuPopup, pt);
-    int command = cc->GetCommandId();
-    wnd->PopEventHandler(true);
-
-    if (command >= 1000)
-        return command-1000;
-
-    return -1;
-}
-
-int wxAuiSimpleTabArt::GetBestTabCtrlSize(wxWindow* wnd,
-                                          const wxAuiNotebookPageArray& WXUNUSED(pages),
-                                          const wxSize& WXUNUSED(requiredBmp_size))
-{
-    wxClientDC dc(wnd);
-    dc.SetFont(m_measuringFont);
-    int x_ext = 0;
-    wxSize s = GetTabSize(dc,
-                          wnd,
-                          wxT("ABCDEFGHIj"),
-                          wxNullBitmap,
-                          true,
-                          wxAUI_BUTTON_STATE_HIDDEN,
-                          &x_ext);
-    return s.y+3;
-}
-
-void wxAuiSimpleTabArt::SetNormalFont(const wxFont& font)
-{
-    m_normalFont = font;
-}
-
-void wxAuiSimpleTabArt::SetSelectedFont(const wxFont& font)
-{
-    m_selectedFont = font;
-}
-
-void wxAuiSimpleTabArt::SetMeasuringFont(const wxFont& font)
-{
-    m_measuringFont = font;
-}
-
-
-
-
 // -- wxAuiTabContainer class implementation --
 
 
Index: src/aui/tabart.cpp
===================================================================
--- src/aui/tabart.cpp	(Revision 0)
+++ src/aui/tabart.cpp	(Revision 0)
@@ -0,0 +1,1290 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        src/aui/tabart.cpp
+// Purpose:     wxaui: wx advanced user interface - notebook-art
+// Author:      Benjamin I. Williams
+// Modified by: Jens Lody (moved from auibook.cpp in extra file)
+// Created:     2012-03-21
+// RCS-ID:      $Id:$
+// Copyright:   (C) Copyright 2006, Kirix Corporation, All Rights Reserved
+// Licence:     wxWindows Library Licence, Version 3.1
+///////////////////////////////////////////////////////////////////////////////
+
+// ----------------------------------------------------------------------------
+// headers
+// ----------------------------------------------------------------------------
+
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#if wxUSE_AUI
+
+#ifndef WX_PRECOMP
+    #include "wx/dc.h"
+    #include "wx/dcclient.h"
+    #include "wx/settings.h"
+    #include "wx/bitmap.h"
+    #include "wx/menu.h"
+#endif
+
+#include "wx/renderer.h"
+#include "wx/aui/auibook.h"
+
+#ifdef __WXMAC__
+#include "wx/osx/private.h"
+#endif
+
+
+// -- GUI helper classes and functions --
+
+class wxAuiCommandCapture : public wxEvtHandler
+{
+public:
+
+    wxAuiCommandCapture() { m_lastId = 0; }
+    int GetCommandId() const { return m_lastId; }
+
+    bool ProcessEvent(wxEvent& evt)
+    {
+        if (evt.GetEventType() == wxEVT_COMMAND_MENU_SELECTED)
+        {
+            m_lastId = evt.GetId();
+            return true;
+        }
+
+        if (GetNextHandler())
+            return GetNextHandler()->ProcessEvent(evt);
+
+        return false;
+    }
+
+private:
+    int m_lastId;
+};
+
+
+// these functions live in dockart.cpp -- they'll eventually
+// be moved to a new utility cpp file
+
+wxBitmap wxAuiBitmapFromBits(const unsigned char bits[], int w, int h,
+                             const wxColour& color);
+
+wxString wxAuiChopText(wxDC& dc, const wxString& text, int max_size);
+
+static void DrawButtons(wxDC& dc,
+                        const wxRect& _rect,
+                        const wxBitmap& bmp,
+                        const wxColour& bkcolour,
+                        int button_state)
+{
+    wxRect rect = _rect;
+
+    if (button_state == wxAUI_BUTTON_STATE_PRESSED)
+    {
+        rect.x++;
+        rect.y++;
+    }
+
+    if (button_state == wxAUI_BUTTON_STATE_HOVER ||
+        button_state == wxAUI_BUTTON_STATE_PRESSED)
+    {
+        dc.SetBrush(wxBrush(bkcolour.ChangeLightness(120)));
+        dc.SetPen(wxPen(bkcolour.ChangeLightness(75)));
+
+        // draw the background behind the button
+        dc.DrawRectangle(rect.x, rect.y, 15, 15);
+    }
+
+    // draw the button itself
+    dc.DrawBitmap(bmp, rect.x, rect.y, true);
+}
+
+static void IndentPressedBitmap(wxRect* rect, int button_state)
+{
+    if (button_state == wxAUI_BUTTON_STATE_PRESSED)
+    {
+        rect->x++;
+        rect->y++;
+    }
+}
+
+
+
+//// -- GUI helper classes and functions --
+//
+//class wxAuiCommandCapture : public wxEvtHandler
+//{
+//public:
+//
+//    wxAuiCommandCapture() { m_lastId = 0; }
+//    int GetCommandId() const { return m_lastId; }
+//
+//    bool ProcessEvent(wxEvent& evt)
+//    {
+//        if (evt.GetEventType() == wxEVT_COMMAND_MENU_SELECTED)
+//        {
+//            m_lastId = evt.GetId();
+//            return true;
+//        }
+//
+//        if (GetNextHandler())
+//            return GetNextHandler()->ProcessEvent(evt);
+//
+//        return false;
+//    }
+//
+//private:
+//    int m_lastId;
+//};
+//
+
+// -- bitmaps --
+
+#if defined( __WXMAC__ )
+ static const unsigned char close_bits[]={
+     0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFE, 0x03, 0xF8, 0x01, 0xF0, 0x19, 0xF3,
+     0xB8, 0xE3, 0xF0, 0xE1, 0xE0, 0xE0, 0xF0, 0xE1, 0xB8, 0xE3, 0x19, 0xF3,
+     0x01, 0xF0, 0x03, 0xF8, 0x0F, 0xFE, 0xFF, 0xFF };
+#elif defined( __WXGTK__)
+ static const unsigned char close_bits[]={
+     0xff, 0xff, 0xff, 0xff, 0x07, 0xf0, 0xfb, 0xef, 0xdb, 0xed, 0x8b, 0xe8,
+     0x1b, 0xec, 0x3b, 0xee, 0x1b, 0xec, 0x8b, 0xe8, 0xdb, 0xed, 0xfb, 0xef,
+     0x07, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+#else
+ static const unsigned char close_bits[]={
+     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xf3, 0xcf, 0xf9,
+     0x9f, 0xfc, 0x3f, 0xfe, 0x3f, 0xfe, 0x9f, 0xfc, 0xcf, 0xf9, 0xe7, 0xf3,
+     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+#endif
+
+static const unsigned char left_bits[] = {
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xfe, 0x3f, 0xfe,
+   0x1f, 0xfe, 0x0f, 0xfe, 0x1f, 0xfe, 0x3f, 0xfe, 0x7f, 0xfe, 0xff, 0xfe,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+static const unsigned char right_bits[] = {
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0x9f, 0xff, 0x1f, 0xff,
+   0x1f, 0xfe, 0x1f, 0xfc, 0x1f, 0xfe, 0x1f, 0xff, 0x9f, 0xff, 0xdf, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+static const unsigned char list_bits[] = {
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x0f, 0xf8, 0xff, 0xff, 0x0f, 0xf8, 0x1f, 0xfc, 0x3f, 0xfe, 0x7f, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+
+
+
+
+
+// -- wxAuiGenericTabArt class implementation --
+
+wxAuiGenericTabArt::wxAuiGenericTabArt()
+{
+    m_normalFont = *wxNORMAL_FONT;
+    m_selectedFont = *wxNORMAL_FONT;
+    m_selectedFont.SetWeight(wxBOLD);
+    m_measuringFont = m_selectedFont;
+
+    m_fixedTabWidth = 100;
+    m_tabCtrlHeight = 0;
+
+#if defined( __WXMAC__ ) && wxOSX_USE_COCOA_OR_CARBON
+    wxColor baseColour = wxColour( wxMacCreateCGColorFromHITheme(kThemeBrushToolbarBackground));
+#else
+    wxColor baseColour = wxSystemSettings::GetColour(wxSYS_COLOUR_3DFACE);
+#endif
+
+    // the baseColour is too pale to use as our base colour,
+    // so darken it a bit --
+    if ((255-baseColour.Red()) +
+        (255-baseColour.Green()) +
+        (255-baseColour.Blue()) < 60)
+    {
+        baseColour = baseColour.ChangeLightness(92);
+    }
+
+    m_activeColour = baseColour;
+    m_baseColour = baseColour;
+    wxColor borderColour = baseColour.ChangeLightness(75);
+
+    m_borderPen = wxPen(borderColour);
+    m_baseColourPen = wxPen(m_baseColour);
+    m_baseColourBrush = wxBrush(m_baseColour);
+
+    m_activeCloseBmp = wxAuiBitmapFromBits(close_bits, 16, 16, *wxBLACK);
+    m_disabledCloseBmp = wxAuiBitmapFromBits(close_bits, 16, 16, wxColour(128,128,128));
+
+    m_activeLeftBmp = wxAuiBitmapFromBits(left_bits, 16, 16, *wxBLACK);
+    m_disabledLeftBmp = wxAuiBitmapFromBits(left_bits, 16, 16, wxColour(128,128,128));
+
+    m_activeRightBmp = wxAuiBitmapFromBits(right_bits, 16, 16, *wxBLACK);
+    m_disabledRightBmp = wxAuiBitmapFromBits(right_bits, 16, 16, wxColour(128,128,128));
+
+    m_activeWindowListBmp = wxAuiBitmapFromBits(list_bits, 16, 16, *wxBLACK);
+    m_disabledWindowListBmp = wxAuiBitmapFromBits(list_bits, 16, 16, wxColour(128,128,128));
+
+    m_flags = 0;
+}
+
+wxAuiGenericTabArt::~wxAuiGenericTabArt()
+{
+}
+
+wxAuiTabArt* wxAuiGenericTabArt::Clone()
+{
+    return new wxAuiGenericTabArt(*this);
+}
+
+void wxAuiGenericTabArt::SetFlags(unsigned int flags)
+{
+    m_flags = flags;
+}
+
+void wxAuiGenericTabArt::SetSizingInfo(const wxSize& tab_ctrl_size,
+                                       size_t tab_count)
+{
+    m_fixedTabWidth = 100;
+
+    int tot_width = (int)tab_ctrl_size.x - GetIndentSize() - 4;
+
+    if (m_flags & wxAUI_NB_CLOSE_BUTTON)
+        tot_width -= m_activeCloseBmp.GetWidth();
+    if (m_flags & wxAUI_NB_WINDOWLIST_BUTTON)
+        tot_width -= m_activeWindowListBmp.GetWidth();
+
+    if (tab_count > 0)
+    {
+        m_fixedTabWidth = tot_width/(int)tab_count;
+    }
+
+
+    if (m_fixedTabWidth < 100)
+        m_fixedTabWidth = 100;
+
+    if (m_fixedTabWidth > tot_width/2)
+        m_fixedTabWidth = tot_width/2;
+
+    if (m_fixedTabWidth > 220)
+        m_fixedTabWidth = 220;
+
+    m_tabCtrlHeight = tab_ctrl_size.y;
+}
+
+
+void wxAuiGenericTabArt::DrawBackground(wxDC& dc,
+                                        wxWindow* WXUNUSED(wnd),
+                                        const wxRect& rect)
+{
+    // draw background
+
+    wxColor top_color       = m_baseColour.ChangeLightness(90);
+    wxColor bottom_color   = m_baseColour.ChangeLightness(170);
+    wxRect r;
+
+   if (m_flags &wxAUI_NB_BOTTOM)
+       r = wxRect(rect.x, rect.y, rect.width+2, rect.height);
+   // TODO: else if (m_flags &wxAUI_NB_LEFT) {}
+   // TODO: else if (m_flags &wxAUI_NB_RIGHT) {}
+   else //for wxAUI_NB_TOP
+       r = wxRect(rect.x, rect.y, rect.width+2, rect.height-3);
+
+    dc.GradientFillLinear(r, top_color, bottom_color, wxSOUTH);
+
+
+   // draw base lines
+
+   dc.SetPen(m_borderPen);
+   int y = rect.GetHeight();
+   int w = rect.GetWidth();
+
+   if (m_flags &wxAUI_NB_BOTTOM)
+   {
+       dc.SetBrush(wxBrush(bottom_color));
+       dc.DrawRectangle(-1, 0, w+2, 4);
+   }
+   // TODO: else if (m_flags &wxAUI_NB_LEFT) {}
+   // TODO: else if (m_flags &wxAUI_NB_RIGHT) {}
+   else //for wxAUI_NB_TOP
+   {
+       dc.SetBrush(m_baseColourBrush);
+       dc.DrawRectangle(-1, y-4, w+2, 4);
+   }
+}
+
+
+// DrawTab() draws an individual tab.
+//
+// dc       - output dc
+// in_rect  - rectangle the tab should be confined to
+// caption  - tab's caption
+// active   - whether or not the tab is active
+// out_rect - actual output rectangle
+// x_extent - the advance x; where the next tab should start
+
+void wxAuiGenericTabArt::DrawTab(wxDC& dc,
+                                 wxWindow* wnd,
+                                 const wxAuiNotebookPage& page,
+                                 const wxRect& in_rect,
+                                 int close_button_state,
+                                 wxRect* out_tab_rect,
+                                 wxRect* out_button_rect,
+                                 int* x_extent)
+{
+    wxCoord normal_textx, normal_texty;
+    wxCoord selected_textx, selected_texty;
+    wxCoord texty;
+
+    // if the caption is empty, measure some temporary text
+    wxString caption = page.caption;
+    if (caption.empty())
+        caption = wxT("Xj");
+
+    dc.SetFont(m_selectedFont);
+    dc.GetTextExtent(caption, &selected_textx, &selected_texty);
+
+    dc.SetFont(m_normalFont);
+    dc.GetTextExtent(caption, &normal_textx, &normal_texty);
+
+    // figure out the size of the tab
+    wxSize tab_size = GetTabSize(dc,
+                                 wnd,
+                                 page.caption,
+                                 page.bitmap,
+                                 page.active,
+                                 close_button_state,
+                                 x_extent);
+
+    wxCoord tab_height = m_tabCtrlHeight - 3;
+    wxCoord tab_width = tab_size.x;
+    wxCoord tab_x = in_rect.x;
+    wxCoord tab_y = in_rect.y + in_rect.height - tab_height;
+
+
+    caption = page.caption;
+
+
+    // select pen, brush and font for the tab to be drawn
+
+    if (page.active)
+    {
+        dc.SetFont(m_selectedFont);
+        texty = selected_texty;
+    }
+    else
+    {
+        dc.SetFont(m_normalFont);
+        texty = normal_texty;
+    }
+
+
+    // create points that will make the tab outline
+
+    int clip_width = tab_width;
+    if (tab_x + clip_width > in_rect.x + in_rect.width)
+        clip_width = (in_rect.x + in_rect.width) - tab_x;
+
+/*
+    wxPoint clip_points[6];
+    clip_points[0] = wxPoint(tab_x,              tab_y+tab_height-3);
+    clip_points[1] = wxPoint(tab_x,              tab_y+2);
+    clip_points[2] = wxPoint(tab_x+2,            tab_y);
+    clip_points[3] = wxPoint(tab_x+clip_width-1, tab_y);
+    clip_points[4] = wxPoint(tab_x+clip_width+1, tab_y+2);
+    clip_points[5] = wxPoint(tab_x+clip_width+1, tab_y+tab_height-3);
+
+    // FIXME: these ports don't provide wxRegion ctor from array of points
+#if !defined(__WXDFB__) && !defined(__WXCOCOA__)
+    // set the clipping region for the tab --
+    wxRegion clipping_region(WXSIZEOF(clip_points), clip_points);
+    dc.SetClippingRegion(clipping_region);
+#endif // !wxDFB && !wxCocoa
+*/
+    // since the above code above doesn't play well with WXDFB or WXCOCOA,
+    // we'll just use a rectangle for the clipping region for now --
+    dc.SetClippingRegion(tab_x, tab_y, clip_width+1, tab_height-3);
+
+
+    wxPoint border_points[6];
+    if (m_flags &wxAUI_NB_BOTTOM)
+    {
+        border_points[0] = wxPoint(tab_x,             tab_y);
+        border_points[1] = wxPoint(tab_x,             tab_y+tab_height-6);
+        border_points[2] = wxPoint(tab_x+2,           tab_y+tab_height-4);
+        border_points[3] = wxPoint(tab_x+tab_width-2, tab_y+tab_height-4);
+        border_points[4] = wxPoint(tab_x+tab_width,   tab_y+tab_height-6);
+        border_points[5] = wxPoint(tab_x+tab_width,   tab_y);
+    }
+    else //if (m_flags & wxAUI_NB_TOP) {}
+    {
+        border_points[0] = wxPoint(tab_x,             tab_y+tab_height-4);
+        border_points[1] = wxPoint(tab_x,             tab_y+2);
+        border_points[2] = wxPoint(tab_x+2,           tab_y);
+        border_points[3] = wxPoint(tab_x+tab_width-2, tab_y);
+        border_points[4] = wxPoint(tab_x+tab_width,   tab_y+2);
+        border_points[5] = wxPoint(tab_x+tab_width,   tab_y+tab_height-4);
+    }
+    // TODO: else if (m_flags &wxAUI_NB_LEFT) {}
+    // TODO: else if (m_flags &wxAUI_NB_RIGHT) {}
+
+    int drawn_tab_yoff = border_points[1].y;
+    int drawn_tab_height = border_points[0].y - border_points[1].y;
+
+
+    if (page.active)
+    {
+        // draw active tab
+
+        // draw base background color
+        wxRect r(tab_x, tab_y, tab_width, tab_height);
+        dc.SetPen(wxPen(m_activeColour));
+        dc.SetBrush(wxBrush(m_activeColour));
+        dc.DrawRectangle(r.x+1, r.y+1, r.width-1, r.height-4);
+
+        // this white helps fill out the gradient at the top of the tab
+        dc.SetPen(*wxWHITE_PEN);
+        dc.SetBrush(*wxWHITE_BRUSH);
+        dc.DrawRectangle(r.x+2, r.y+1, r.width-3, r.height-4);
+
+        // these two points help the rounded corners appear more antialiased
+        dc.SetPen(wxPen(m_activeColour));
+        dc.DrawPoint(r.x+2, r.y+1);
+        dc.DrawPoint(r.x+r.width-2, r.y+1);
+
+        // set rectangle down a bit for gradient drawing
+        r.SetHeight(r.GetHeight()/2);
+        r.x += 2;
+        r.width -= 3;
+        r.y += r.height;
+        r.y -= 2;
+
+        // draw gradient background
+        wxColor top_color = *wxWHITE;
+        wxColor bottom_color = m_activeColour;
+        dc.GradientFillLinear(r, bottom_color, top_color, wxNORTH);
+    }
+    else
+    {
+        // draw inactive tab
+
+        wxRect r(tab_x, tab_y+1, tab_width, tab_height-3);
+
+        // start the gradent up a bit and leave the inside border inset
+        // by a pixel for a 3D look.  Only the top half of the inactive
+        // tab will have a slight gradient
+        r.x += 3;
+        r.y++;
+        r.width -= 4;
+        r.height /= 2;
+        r.height--;
+
+        // -- draw top gradient fill for glossy look
+        wxColor top_color = m_baseColour;
+        wxColor bottom_color = top_color.ChangeLightness(160);
+        dc.GradientFillLinear(r, bottom_color, top_color, wxNORTH);
+
+        r.y += r.height;
+        r.y--;
+
+        // -- draw bottom fill for glossy look
+        top_color = m_baseColour;
+        bottom_color = m_baseColour;
+        dc.GradientFillLinear(r, top_color, bottom_color, wxSOUTH);
+    }
+
+    // draw tab outline
+    dc.SetPen(m_borderPen);
+    dc.SetBrush(*wxTRANSPARENT_BRUSH);
+    dc.DrawPolygon(WXSIZEOF(border_points), border_points);
+
+    // there are two horizontal grey lines at the bottom of the tab control,
+    // this gets rid of the top one of those lines in the tab control
+    if (page.active)
+    {
+        if (m_flags &wxAUI_NB_BOTTOM)
+            dc.SetPen(wxPen(m_baseColour.ChangeLightness(170)));
+        // TODO: else if (m_flags &wxAUI_NB_LEFT) {}
+        // TODO: else if (m_flags &wxAUI_NB_RIGHT) {}
+        else //for wxAUI_NB_TOP
+            dc.SetPen(m_baseColourPen);
+        dc.DrawLine(border_points[0].x+1,
+                    border_points[0].y,
+                    border_points[5].x,
+                    border_points[5].y);
+    }
+
+
+    int text_offset = tab_x + 8;
+    int close_button_width = 0;
+    if (close_button_state != wxAUI_BUTTON_STATE_HIDDEN)
+    {
+        close_button_width = m_activeCloseBmp.GetWidth();
+    }
+
+    int bitmap_offset = 0;
+    if (page.bitmap.IsOk())
+    {
+        bitmap_offset = tab_x + 8;
+
+        // draw bitmap
+        dc.DrawBitmap(page.bitmap,
+                      bitmap_offset,
+                      drawn_tab_yoff + (drawn_tab_height/2) - (page.bitmap.GetHeight()/2),
+                      true);
+
+        text_offset = bitmap_offset + page.bitmap.GetWidth();
+        text_offset += 3; // bitmap padding
+
+    }
+    else
+    {
+        text_offset = tab_x + 8;
+    }
+
+
+    wxString draw_text = wxAuiChopText(dc,
+                          caption,
+                          tab_width - (text_offset-tab_x) - close_button_width);
+
+    // draw tab text
+    dc.DrawText(draw_text,
+                text_offset,
+                drawn_tab_yoff + (drawn_tab_height)/2 - (texty/2) - 1);
+
+    // draw focus rectangle
+    if (page.active && (wnd->FindFocus() == wnd))
+    {
+        wxRect focusRectText(text_offset, (drawn_tab_yoff + (drawn_tab_height)/2 - (texty/2) - 1),
+            selected_textx, selected_texty);
+
+        wxRect focusRect;
+        wxRect focusRectBitmap;
+
+        if (page.bitmap.IsOk())
+            focusRectBitmap = wxRect(bitmap_offset, drawn_tab_yoff + (drawn_tab_height/2) - (page.bitmap.GetHeight()/2),
+                                            page.bitmap.GetWidth(), page.bitmap.GetHeight());
+
+        if (page.bitmap.IsOk() && draw_text.IsEmpty())
+            focusRect = focusRectBitmap;
+        else if (!page.bitmap.IsOk() && !draw_text.IsEmpty())
+            focusRect = focusRectText;
+        else if (page.bitmap.IsOk() && !draw_text.IsEmpty())
+            focusRect = focusRectText.Union(focusRectBitmap);
+
+        focusRect.Inflate(2, 2);
+
+        wxRendererNative::Get().DrawFocusRect(wnd, dc, focusRect, 0);
+    }
+
+    // draw close button if necessary
+    if (close_button_state != wxAUI_BUTTON_STATE_HIDDEN)
+    {
+        wxBitmap bmp = m_disabledCloseBmp;
+
+        if (close_button_state == wxAUI_BUTTON_STATE_HOVER ||
+            close_button_state == wxAUI_BUTTON_STATE_PRESSED)
+        {
+            bmp = m_activeCloseBmp;
+        }
+
+        int offsetY = tab_y-1;
+        if (m_flags & wxAUI_NB_BOTTOM)
+            offsetY = 1;
+
+        wxRect rect(tab_x + tab_width - close_button_width - 1,
+                    offsetY + (tab_height/2) - (bmp.GetHeight()/2),
+                    close_button_width,
+                    tab_height);
+
+        IndentPressedBitmap(&rect, close_button_state);
+        dc.DrawBitmap(bmp, rect.x, rect.y, true);
+
+        *out_button_rect = rect;
+    }
+
+    *out_tab_rect = wxRect(tab_x, tab_y, tab_width, tab_height);
+
+    dc.DestroyClippingRegion();
+}
+
+int wxAuiGenericTabArt::GetIndentSize()
+{
+    return 5;
+}
+
+wxSize wxAuiGenericTabArt::GetTabSize(wxDC& dc,
+                                      wxWindow* WXUNUSED(wnd),
+                                      const wxString& caption,
+                                      const wxBitmap& bitmap,
+                                      bool WXUNUSED(active),
+                                      int close_button_state,
+                                      int* x_extent)
+{
+    wxCoord measured_textx, measured_texty, tmp;
+
+    dc.SetFont(m_measuringFont);
+    dc.GetTextExtent(caption, &measured_textx, &measured_texty);
+
+    dc.GetTextExtent(wxT("ABCDEFXj"), &tmp, &measured_texty);
+
+    // add padding around the text
+    wxCoord tab_width = measured_textx;
+    wxCoord tab_height = measured_texty;
+
+    // if the close button is showing, add space for it
+    if (close_button_state != wxAUI_BUTTON_STATE_HIDDEN)
+        tab_width += m_activeCloseBmp.GetWidth() + 3;
+
+    // if there's a bitmap, add space for it
+    if (bitmap.IsOk())
+    {
+        tab_width += bitmap.GetWidth();
+        tab_width += 3; // right side bitmap padding
+        tab_height = wxMax(tab_height, bitmap.GetHeight());
+    }
+
+    // add padding
+    tab_width += 16;
+    tab_height += 10;
+
+    if (m_flags & wxAUI_NB_TAB_FIXED_WIDTH)
+    {
+        tab_width = m_fixedTabWidth;
+    }
+
+    *x_extent = tab_width;
+
+    return wxSize(tab_width, tab_height);
+}
+
+
+void wxAuiGenericTabArt::DrawButton(wxDC& dc,
+                                    wxWindow* WXUNUSED(wnd),
+                                    const wxRect& in_rect,
+                                    int bitmap_id,
+                                    int button_state,
+                                    int orientation,
+                                    wxRect* out_rect)
+{
+    wxBitmap bmp;
+    wxRect rect;
+
+    switch (bitmap_id)
+    {
+        case wxAUI_BUTTON_CLOSE:
+            if (button_state & wxAUI_BUTTON_STATE_DISABLED)
+                bmp = m_disabledCloseBmp;
+            else
+                bmp = m_activeCloseBmp;
+            break;
+        case wxAUI_BUTTON_LEFT:
+            if (button_state & wxAUI_BUTTON_STATE_DISABLED)
+                bmp = m_disabledLeftBmp;
+            else
+                bmp = m_activeLeftBmp;
+            break;
+        case wxAUI_BUTTON_RIGHT:
+            if (button_state & wxAUI_BUTTON_STATE_DISABLED)
+                bmp = m_disabledRightBmp;
+            else
+                bmp = m_activeRightBmp;
+            break;
+        case wxAUI_BUTTON_WINDOWLIST:
+            if (button_state & wxAUI_BUTTON_STATE_DISABLED)
+                bmp = m_disabledWindowListBmp;
+            else
+                bmp = m_activeWindowListBmp;
+            break;
+    }
+
+
+    if (!bmp.IsOk())
+        return;
+
+    rect = in_rect;
+
+    if (orientation == wxLEFT)
+    {
+        rect.SetX(in_rect.x);
+        rect.SetY(((in_rect.y + in_rect.height)/2) - (bmp.GetHeight()/2));
+        rect.SetWidth(bmp.GetWidth());
+        rect.SetHeight(bmp.GetHeight());
+    }
+    else
+    {
+        rect = wxRect(in_rect.x + in_rect.width - bmp.GetWidth(),
+                      ((in_rect.y + in_rect.height)/2) - (bmp.GetHeight()/2),
+                      bmp.GetWidth(), bmp.GetHeight());
+    }
+
+    IndentPressedBitmap(&rect, button_state);
+    dc.DrawBitmap(bmp, rect.x, rect.y, true);
+
+    *out_rect = rect;
+}
+
+int wxAuiGenericTabArt::ShowDropDown(wxWindow* wnd,
+                                     const wxAuiNotebookPageArray& pages,
+                                     int /*active_idx*/)
+{
+    wxMenu menuPopup;
+
+    size_t i, count = pages.GetCount();
+    for (i = 0; i < count; ++i)
+    {
+        const wxAuiNotebookPage& page = pages.Item(i);
+        wxString caption = page.caption;
+
+        // if there is no caption, make it a space.  This will prevent
+        // an assert in the menu code.
+        if (caption.IsEmpty())
+            caption = wxT(" ");
+
+        wxMenuItem* item = new wxMenuItem(NULL, 1000+i, caption);
+        if (page.bitmap.IsOk())
+            item->SetBitmap(page.bitmap);
+        menuPopup.Append(item);
+    }
+
+    // find out where to put the popup menu of window items
+    wxPoint pt = ::wxGetMousePosition();
+    pt = wnd->ScreenToClient(pt);
+
+    // find out the screen coordinate at the bottom of the tab ctrl
+    wxRect cli_rect = wnd->GetClientRect();
+    pt.y = cli_rect.y + cli_rect.height;
+
+    wxAuiCommandCapture* cc = new wxAuiCommandCapture;
+    wnd->PushEventHandler(cc);
+    wnd->PopupMenu(&menuPopup, pt);
+    int command = cc->GetCommandId();
+    wnd->PopEventHandler(true);
+
+    if (command >= 1000)
+        return command-1000;
+
+    return -1;
+}
+
+int wxAuiGenericTabArt::GetBestTabCtrlSize(wxWindow* wnd,
+                                           const wxAuiNotebookPageArray& pages,
+                                           const wxSize& requiredBmp_size)
+{
+    wxClientDC dc(wnd);
+    dc.SetFont(m_measuringFont);
+
+    // sometimes a standard bitmap size needs to be enforced, especially
+    // if some tabs have bitmaps and others don't.  This is important because
+    // it prevents the tab control from resizing when tabs are added.
+    wxBitmap measureBmp;
+    if (requiredBmp_size.IsFullySpecified())
+    {
+        measureBmp.Create(requiredBmp_size.x,
+                           requiredBmp_size.y);
+    }
+
+
+    int max_y = 0;
+    size_t i, page_count = pages.GetCount();
+    for (i = 0; i < page_count; ++i)
+    {
+        wxAuiNotebookPage& page = pages.Item(i);
+
+        wxBitmap bmp;
+        if (measureBmp.IsOk())
+            bmp = measureBmp;
+        else
+            bmp = page.bitmap;
+
+        // we don't use the caption text because we don't
+        // want tab heights to be different in the case
+        // of a very short piece of text on one tab and a very
+        // tall piece of text on another tab
+        int x_ext = 0;
+        wxSize s = GetTabSize(dc,
+                              wnd,
+                              wxT("ABCDEFGHIj"),
+                              bmp,
+                              true,
+                              wxAUI_BUTTON_STATE_HIDDEN,
+                              &x_ext);
+
+        max_y = wxMax(max_y, s.y);
+    }
+
+    return max_y+2;
+}
+
+void wxAuiGenericTabArt::SetNormalFont(const wxFont& font)
+{
+    m_normalFont = font;
+}
+
+void wxAuiGenericTabArt::SetSelectedFont(const wxFont& font)
+{
+    m_selectedFont = font;
+}
+
+void wxAuiGenericTabArt::SetMeasuringFont(const wxFont& font)
+{
+    m_measuringFont = font;
+}
+
+void wxAuiGenericTabArt::SetColour(const wxColour& colour)
+{
+    m_baseColour = colour;
+    m_borderPen = wxPen(m_baseColour.ChangeLightness(75));
+    m_baseColourPen = wxPen(m_baseColour);
+    m_baseColourBrush = wxBrush(m_baseColour);
+}
+
+void wxAuiGenericTabArt::SetActiveColour(const wxColour& colour)
+{
+    m_activeColour = colour;
+}
+
+// -- wxAuiSimpleTabArt class implementation --
+
+wxAuiSimpleTabArt::wxAuiSimpleTabArt()
+{
+    m_normalFont = *wxNORMAL_FONT;
+    m_selectedFont = *wxNORMAL_FONT;
+    m_selectedFont.SetWeight(wxBOLD);
+    m_measuringFont = m_selectedFont;
+
+    m_flags = 0;
+    m_fixedTabWidth = 100;
+
+    wxColour baseColour = wxSystemSettings::GetColour(wxSYS_COLOUR_3DFACE);
+
+    wxColour backgroundColour = baseColour;
+    wxColour normaltabColour = baseColour;
+    wxColour selectedtabColour = *wxWHITE;
+
+    m_bkBrush = wxBrush(backgroundColour);
+    m_normalBkBrush = wxBrush(normaltabColour);
+    m_normalBkPen = wxPen(normaltabColour);
+    m_selectedBkBrush = wxBrush(selectedtabColour);
+    m_selectedBkPen = wxPen(selectedtabColour);
+
+    m_activeCloseBmp = wxAuiBitmapFromBits(close_bits, 16, 16, *wxBLACK);
+    m_disabledCloseBmp = wxAuiBitmapFromBits(close_bits, 16, 16, wxColour(128,128,128));
+
+    m_activeLeftBmp = wxAuiBitmapFromBits(left_bits, 16, 16, *wxBLACK);
+    m_disabledLeftBmp = wxAuiBitmapFromBits(left_bits, 16, 16, wxColour(128,128,128));
+
+    m_activeRightBmp = wxAuiBitmapFromBits(right_bits, 16, 16, *wxBLACK);
+    m_disabledRightBmp = wxAuiBitmapFromBits(right_bits, 16, 16, wxColour(128,128,128));
+
+    m_activeWindowListBmp = wxAuiBitmapFromBits(list_bits, 16, 16, *wxBLACK);
+    m_disabledWindowListBmp = wxAuiBitmapFromBits(list_bits, 16, 16, wxColour(128,128,128));
+
+}
+
+wxAuiSimpleTabArt::~wxAuiSimpleTabArt()
+{
+}
+
+wxAuiTabArt* wxAuiSimpleTabArt::Clone()
+{
+    return new wxAuiSimpleTabArt(*this);
+}
+
+void wxAuiSimpleTabArt::SetFlags(unsigned int flags)
+{
+    m_flags = flags;
+}
+
+void wxAuiSimpleTabArt::SetSizingInfo(const wxSize& tab_ctrl_size,
+                                      size_t tab_count)
+{
+    m_fixedTabWidth = 100;
+
+    int tot_width = (int)tab_ctrl_size.x - GetIndentSize() - 4;
+
+    if (m_flags & wxAUI_NB_CLOSE_BUTTON)
+        tot_width -= m_activeCloseBmp.GetWidth();
+    if (m_flags & wxAUI_NB_WINDOWLIST_BUTTON)
+        tot_width -= m_activeWindowListBmp.GetWidth();
+
+    if (tab_count > 0)
+    {
+        m_fixedTabWidth = tot_width/(int)tab_count;
+    }
+
+
+    if (m_fixedTabWidth < 100)
+        m_fixedTabWidth = 100;
+
+    if (m_fixedTabWidth > tot_width/2)
+        m_fixedTabWidth = tot_width/2;
+
+    if (m_fixedTabWidth > 220)
+        m_fixedTabWidth = 220;
+}
+
+void wxAuiSimpleTabArt::SetColour(const wxColour& colour)
+{
+    m_bkBrush = wxBrush(colour);
+    m_normalBkBrush = wxBrush(colour);
+    m_normalBkPen = wxPen(colour);
+}
+
+void wxAuiSimpleTabArt::SetActiveColour(const wxColour& colour)
+{
+    m_selectedBkBrush = wxBrush(colour);
+    m_selectedBkPen = wxPen(colour);
+}
+
+void wxAuiSimpleTabArt::DrawBackground(wxDC& dc,
+                                       wxWindow* WXUNUSED(wnd),
+                                       const wxRect& rect)
+{
+    // draw background
+    dc.SetBrush(m_bkBrush);
+    dc.SetPen(*wxTRANSPARENT_PEN);
+    dc.DrawRectangle(-1, -1, rect.GetWidth()+2, rect.GetHeight()+2);
+
+    // draw base line
+    dc.SetPen(*wxGREY_PEN);
+    dc.DrawLine(0, rect.GetHeight()-1, rect.GetWidth(), rect.GetHeight()-1);
+}
+
+
+// DrawTab() draws an individual tab.
+//
+// dc       - output dc
+// in_rect  - rectangle the tab should be confined to
+// caption  - tab's caption
+// active   - whether or not the tab is active
+// out_rect - actual output rectangle
+// x_extent - the advance x; where the next tab should start
+
+void wxAuiSimpleTabArt::DrawTab(wxDC& dc,
+                                wxWindow* wnd,
+                                const wxAuiNotebookPage& page,
+                                const wxRect& in_rect,
+                                int close_button_state,
+                                wxRect* out_tab_rect,
+                                wxRect* out_button_rect,
+                                int* x_extent)
+{
+    wxCoord normal_textx, normal_texty;
+    wxCoord selected_textx, selected_texty;
+    wxCoord textx, texty;
+
+    // if the caption is empty, measure some temporary text
+    wxString caption = page.caption;
+    if (caption.empty())
+        caption = wxT("Xj");
+
+    dc.SetFont(m_selectedFont);
+    dc.GetTextExtent(caption, &selected_textx, &selected_texty);
+
+    dc.SetFont(m_normalFont);
+    dc.GetTextExtent(caption, &normal_textx, &normal_texty);
+
+    // figure out the size of the tab
+    wxSize tab_size = GetTabSize(dc,
+                                 wnd,
+                                 page.caption,
+                                 page.bitmap,
+                                 page.active,
+                                 close_button_state,
+                                 x_extent);
+
+    wxCoord tab_height = tab_size.y;
+    wxCoord tab_width = tab_size.x;
+    wxCoord tab_x = in_rect.x;
+    wxCoord tab_y = in_rect.y + in_rect.height - tab_height;
+
+    caption = page.caption;
+
+    // select pen, brush and font for the tab to be drawn
+
+    if (page.active)
+    {
+        dc.SetPen(m_selectedBkPen);
+        dc.SetBrush(m_selectedBkBrush);
+        dc.SetFont(m_selectedFont);
+        textx = selected_textx;
+        texty = selected_texty;
+    }
+    else
+    {
+        dc.SetPen(m_normalBkPen);
+        dc.SetBrush(m_normalBkBrush);
+        dc.SetFont(m_normalFont);
+        textx = normal_textx;
+        texty = normal_texty;
+    }
+
+
+    // -- draw line --
+
+    wxPoint points[7];
+    points[0].x = tab_x;
+    points[0].y = tab_y + tab_height - 1;
+    points[1].x = tab_x + tab_height - 3;
+    points[1].y = tab_y + 2;
+    points[2].x = tab_x + tab_height + 3;
+    points[2].y = tab_y;
+    points[3].x = tab_x + tab_width - 2;
+    points[3].y = tab_y;
+    points[4].x = tab_x + tab_width;
+    points[4].y = tab_y + 2;
+    points[5].x = tab_x + tab_width;
+    points[5].y = tab_y + tab_height - 1;
+    points[6] = points[0];
+
+    dc.SetClippingRegion(in_rect);
+
+    dc.DrawPolygon(WXSIZEOF(points) - 1, points);
+
+    dc.SetPen(*wxGREY_PEN);
+
+    //dc.DrawLines(active ? WXSIZEOF(points) - 1 : WXSIZEOF(points), points);
+    dc.DrawLines(WXSIZEOF(points), points);
+
+
+    int text_offset;
+
+    int close_button_width = 0;
+    if (close_button_state != wxAUI_BUTTON_STATE_HIDDEN)
+    {
+        close_button_width = m_activeCloseBmp.GetWidth();
+        text_offset = tab_x + (tab_height/2) + ((tab_width-close_button_width)/2) - (textx/2);
+    }
+    else
+    {
+        text_offset = tab_x + (tab_height/3) + (tab_width/2) - (textx/2);
+    }
+
+    // set minimum text offset
+    if (text_offset < tab_x + tab_height)
+        text_offset = tab_x + tab_height;
+
+    // chop text if necessary
+    wxString draw_text = wxAuiChopText(dc,
+                          caption,
+                          tab_width - (text_offset-tab_x) - close_button_width);
+
+    // draw tab text
+    dc.DrawText(draw_text,
+                 text_offset,
+                 (tab_y + tab_height)/2 - (texty/2) + 1);
+
+
+    // draw focus rectangle
+    if (page.active && (wnd->FindFocus() == wnd))
+    {
+        wxRect focusRect(text_offset, ((tab_y + tab_height)/2 - (texty/2) + 1),
+            selected_textx, selected_texty);
+
+        focusRect.Inflate(2, 2);
+
+        wxRendererNative::Get().DrawFocusRect(wnd, dc, focusRect, 0);
+    }
+
+    // draw close button if necessary
+    if (close_button_state != wxAUI_BUTTON_STATE_HIDDEN)
+    {
+        wxBitmap bmp;
+        if (page.active)
+            bmp = m_activeCloseBmp;
+        else
+            bmp = m_disabledCloseBmp;
+
+        wxRect rect(tab_x + tab_width - close_button_width - 1,
+                    tab_y + (tab_height/2) - (bmp.GetHeight()/2) + 1,
+                    close_button_width,
+                    tab_height - 1);
+        DrawButtons(dc, rect, bmp, *wxWHITE, close_button_state);
+
+        *out_button_rect = rect;
+    }
+
+
+    *out_tab_rect = wxRect(tab_x, tab_y, tab_width, tab_height);
+
+    dc.DestroyClippingRegion();
+}
+
+int wxAuiSimpleTabArt::GetIndentSize()
+{
+    return 0;
+}
+
+wxSize wxAuiSimpleTabArt::GetTabSize(wxDC& dc,
+                                     wxWindow* WXUNUSED(wnd),
+                                     const wxString& caption,
+                                     const wxBitmap& WXUNUSED(bitmap),
+                                     bool WXUNUSED(active),
+                                     int close_button_state,
+                                     int* x_extent)
+{
+    wxCoord measured_textx, measured_texty;
+
+    dc.SetFont(m_measuringFont);
+    dc.GetTextExtent(caption, &measured_textx, &measured_texty);
+
+    wxCoord tab_height = measured_texty + 4;
+    wxCoord tab_width = measured_textx + tab_height + 5;
+
+    if (close_button_state != wxAUI_BUTTON_STATE_HIDDEN)
+        tab_width += m_activeCloseBmp.GetWidth();
+
+    if (m_flags & wxAUI_NB_TAB_FIXED_WIDTH)
+    {
+        tab_width = m_fixedTabWidth;
+    }
+
+    *x_extent = tab_width - (tab_height/2) - 1;
+
+    return wxSize(tab_width, tab_height);
+}
+
+
+void wxAuiSimpleTabArt::DrawButton(wxDC& dc,
+                                   wxWindow* WXUNUSED(wnd),
+                                   const wxRect& in_rect,
+                                   int bitmap_id,
+                                   int button_state,
+                                   int orientation,
+                                   wxRect* out_rect)
+{
+    wxBitmap bmp;
+    wxRect rect;
+
+    switch (bitmap_id)
+    {
+        case wxAUI_BUTTON_CLOSE:
+            if (button_state & wxAUI_BUTTON_STATE_DISABLED)
+                bmp = m_disabledCloseBmp;
+            else
+                bmp = m_activeCloseBmp;
+            break;
+        case wxAUI_BUTTON_LEFT:
+            if (button_state & wxAUI_BUTTON_STATE_DISABLED)
+                bmp = m_disabledLeftBmp;
+            else
+                bmp = m_activeLeftBmp;
+            break;
+        case wxAUI_BUTTON_RIGHT:
+            if (button_state & wxAUI_BUTTON_STATE_DISABLED)
+                bmp = m_disabledRightBmp;
+            else
+                bmp = m_activeRightBmp;
+            break;
+        case wxAUI_BUTTON_WINDOWLIST:
+            if (button_state & wxAUI_BUTTON_STATE_DISABLED)
+                bmp = m_disabledWindowListBmp;
+            else
+                bmp = m_activeWindowListBmp;
+            break;
+    }
+
+    if (!bmp.IsOk())
+        return;
+
+    rect = in_rect;
+
+    if (orientation == wxLEFT)
+    {
+        rect.SetX(in_rect.x);
+        rect.SetY(((in_rect.y + in_rect.height)/2) - (bmp.GetHeight()/2));
+        rect.SetWidth(bmp.GetWidth());
+        rect.SetHeight(bmp.GetHeight());
+    }
+    else
+    {
+        rect = wxRect(in_rect.x + in_rect.width - bmp.GetWidth(),
+                      ((in_rect.y + in_rect.height)/2) - (bmp.GetHeight()/2),
+                      bmp.GetWidth(), bmp.GetHeight());
+    }
+
+
+    DrawButtons(dc, rect, bmp, *wxWHITE, button_state);
+
+    *out_rect = rect;
+}
+
+int wxAuiSimpleTabArt::ShowDropDown(wxWindow* wnd,
+                                    const wxAuiNotebookPageArray& pages,
+                                    int active_idx)
+{
+    wxMenu menuPopup;
+
+    size_t i, count = pages.GetCount();
+    for (i = 0; i < count; ++i)
+    {
+        const wxAuiNotebookPage& page = pages.Item(i);
+        menuPopup.AppendCheckItem(1000+i, page.caption);
+    }
+
+    if (active_idx != -1)
+    {
+        menuPopup.Check(1000+active_idx, true);
+    }
+
+    // find out where to put the popup menu of window
+    // items.  Subtract 100 for now to center the menu
+    // a bit, until a better mechanism can be implemented
+    wxPoint pt = ::wxGetMousePosition();
+    pt = wnd->ScreenToClient(pt);
+    if (pt.x < 100)
+        pt.x = 0;
+    else
+        pt.x -= 100;
+
+    // find out the screen coordinate at the bottom of the tab ctrl
+    wxRect cli_rect = wnd->GetClientRect();
+    pt.y = cli_rect.y + cli_rect.height;
+
+    wxAuiCommandCapture* cc = new wxAuiCommandCapture;
+    wnd->PushEventHandler(cc);
+    wnd->PopupMenu(&menuPopup, pt);
+    int command = cc->GetCommandId();
+    wnd->PopEventHandler(true);
+
+    if (command >= 1000)
+        return command-1000;
+
+    return -1;
+}
+
+int wxAuiSimpleTabArt::GetBestTabCtrlSize(wxWindow* wnd,
+                                          const wxAuiNotebookPageArray& WXUNUSED(pages),
+                                          const wxSize& WXUNUSED(requiredBmp_size))
+{
+    wxClientDC dc(wnd);
+    dc.SetFont(m_measuringFont);
+    int x_ext = 0;
+    wxSize s = GetTabSize(dc,
+                          wnd,
+                          wxT("ABCDEFGHIj"),
+                          wxNullBitmap,
+                          true,
+                          wxAUI_BUTTON_STATE_HIDDEN,
+                          &x_ext);
+    return s.y+3;
+}
+
+void wxAuiSimpleTabArt::SetNormalFont(const wxFont& font)
+{
+    m_normalFont = font;
+}
+
+void wxAuiSimpleTabArt::SetSelectedFont(const wxFont& font)
+{
+    m_selectedFont = font;
+}
+
+void wxAuiSimpleTabArt::SetMeasuringFont(const wxFont& font)
+{
+    m_measuringFont = font;
+}
+
+#endif // wxUSE_AUI
Index: include/wx/gtk/private.h
===================================================================
--- include/wx/gtk/private.h	(Revision 70939)
+++ include/wx/gtk/private.h	(Arbeitskopie)
@@ -99,17 +99,18 @@
 //
 // the returned widgets shouldn't be destroyed, this is done automatically on
 // shutdown
-GtkWidget *GetButtonWidget();
-GtkWidget *GetCheckButtonWidget();
-GtkWidget *GetComboBoxWidget();
-GtkWidget *GetEntryWidget();
-GtkWidget *GetHeaderButtonWidgetFirst();
-GtkWidget *GetHeaderButtonWidgetLast();
-GtkWidget *GetHeaderButtonWidget();
-GtkWidget *GetRadioButtonWidget();
-GtkWidget *GetSplitterWidget();
-GtkWidget *GetTextEntryWidget();
-GtkWidget *GetTreeWidget();
+WXDLLIMPEXP_CORE GtkWidget *GetButtonWidget();
+WXDLLIMPEXP_CORE GtkWidget *GetNotebookWidget();
+WXDLLIMPEXP_CORE GtkWidget *GetCheckButtonWidget();
+WXDLLIMPEXP_CORE GtkWidget *GetComboBoxWidget();
+WXDLLIMPEXP_CORE GtkWidget *GetEntryWidget();
+WXDLLIMPEXP_CORE GtkWidget *GetHeaderButtonWidgetFirst();
+WXDLLIMPEXP_CORE GtkWidget *GetHeaderButtonWidgetLast();
+WXDLLIMPEXP_CORE GtkWidget *GetHeaderButtonWidget();
+WXDLLIMPEXP_CORE GtkWidget *GetRadioButtonWidget();
+WXDLLIMPEXP_CORE GtkWidget *GetSplitterWidget();
+WXDLLIMPEXP_CORE GtkWidget *GetTextEntryWidget();
+WXDLLIMPEXP_CORE GtkWidget *GetTreeWidget();
 
 } // wxGTKPrivate
 
Index: include/wx/aui/tabart.h
===================================================================
--- include/wx/aui/tabart.h	(Revision 0)
+++ include/wx/aui/tabart.h	(Revision 0)
@@ -0,0 +1,293 @@
+//////////////////////////////////////////////////////////////////////////////
+// Name:        wx/aui/tabart.h
+// Purpose:     wxaui: wx advanced user interface - notebook
+// Author:      Benjamin I. Williams
+// Modified by: Jens Lody (moved from auibook.h in extra file)
+// Created:     2012-03-21
+// RCS-ID:      $Id:$
+// Copyright:   (C) Copyright 2006, Kirix Corporation, All Rights Reserved.
+// Licence:     wxWindows Library Licence, Version 3.1
+///////////////////////////////////////////////////////////////////////////////
+
+
+
+#ifndef _WX_TABART_H_
+#define _WX_TABART_H_
+// ----------------------------------------------------------------------------
+// headers
+// ----------------------------------------------------------------------------
+
+#include "wx/defs.h"
+
+#if wxUSE_AUI
+
+#include "wx/colour.h"
+#include "wx/gdicmn.h"
+#include "wx/font.h"
+#include "wx/pen.h"
+#include "wx/brush.h"
+#include "wx/bitmap.h"
+
+
+//class wxAuiNotebook;
+class wxAuiNotebookPage;
+class wxAuiNotebookPageArray;
+class wxWindow;
+class wxDC;
+
+
+// tab art class
+
+class WXDLLIMPEXP_AUI wxAuiTabArt
+{
+public:
+
+    wxAuiTabArt() { }
+    virtual ~wxAuiTabArt() { }
+
+    virtual wxAuiTabArt* Clone() = 0;
+    virtual void SetFlags(unsigned int flags) = 0;
+
+    virtual void SetSizingInfo(const wxSize& tabCtrlSize,
+                               size_t tabCount) = 0;
+
+    virtual void SetNormalFont(const wxFont& font) = 0;
+    virtual void SetSelectedFont(const wxFont& font) = 0;
+    virtual void SetMeasuringFont(const wxFont& font) = 0;
+    virtual void SetColour(const wxColour& colour) = 0;
+    virtual void SetActiveColour(const wxColour& colour) = 0;
+
+    virtual void DrawBackground(
+                         wxDC& dc,
+                         wxWindow* wnd,
+                         const wxRect& rect) = 0;
+
+    virtual void DrawTab(wxDC& dc,
+                         wxWindow* wnd,
+                         const wxAuiNotebookPage& pane,
+                         const wxRect& inRect,
+                         int closeButtonState,
+                         wxRect* outTabRect,
+                         wxRect* outButtonRect,
+                         int* xExtent) = 0;
+
+    virtual void DrawButton(
+                         wxDC& dc,
+                         wxWindow* wnd,
+                         const wxRect& inRect,
+                         int bitmapId,
+                         int buttonState,
+                         int orientation,
+                         wxRect* outRect) = 0;
+
+    virtual wxSize GetTabSize(
+                         wxDC& dc,
+                         wxWindow* wnd,
+                         const wxString& caption,
+                         const wxBitmap& bitmap,
+                         bool active,
+                         int closeButtonState,
+                         int* xExtent) = 0;
+
+    virtual int ShowDropDown(
+                         wxWindow* wnd,
+                         const wxAuiNotebookPageArray& items,
+                         int activeIdx) = 0;
+
+    virtual int GetIndentSize() = 0;
+
+    virtual int GetBestTabCtrlSize(
+                         wxWindow* wnd,
+                         const wxAuiNotebookPageArray& pages,
+                         const wxSize& requiredBmpSize) = 0;
+};
+
+
+class WXDLLIMPEXP_AUI wxAuiGenericTabArt : public wxAuiTabArt
+{
+
+public:
+
+    wxAuiGenericTabArt();
+    virtual ~wxAuiGenericTabArt();
+
+    wxAuiTabArt* Clone();
+    void SetFlags(unsigned int flags);
+    void SetSizingInfo(const wxSize& tabCtrlSize,
+                       size_t tabCount);
+
+    void SetNormalFont(const wxFont& font);
+    void SetSelectedFont(const wxFont& font);
+    void SetMeasuringFont(const wxFont& font);
+    void SetColour(const wxColour& colour);
+    void SetActiveColour(const wxColour& colour);
+
+    void DrawBackground(
+                 wxDC& dc,
+                 wxWindow* wnd,
+                 const wxRect& rect);
+
+    void DrawTab(wxDC& dc,
+                 wxWindow* wnd,
+                 const wxAuiNotebookPage& pane,
+                 const wxRect& inRect,
+                 int closeButtonState,
+                 wxRect* outTabRect,
+                 wxRect* outButtonRect,
+                 int* xExtent);
+
+    void DrawButton(
+                 wxDC& dc,
+                 wxWindow* wnd,
+                 const wxRect& inRect,
+                 int bitmapId,
+                 int buttonState,
+                 int orientation,
+                 wxRect* outRect);
+
+    int GetIndentSize();
+
+    wxSize GetTabSize(
+                 wxDC& dc,
+                 wxWindow* wnd,
+                 const wxString& caption,
+                 const wxBitmap& bitmap,
+                 bool active,
+                 int closeButtonState,
+                 int* xExtent);
+
+    int ShowDropDown(
+                 wxWindow* wnd,
+                 const wxAuiNotebookPageArray& items,
+                 int activeIdx);
+
+    int GetBestTabCtrlSize(wxWindow* wnd,
+                 const wxAuiNotebookPageArray& pages,
+                 const wxSize& requiredBmpSize);
+
+protected:
+
+    wxFont m_normalFont;
+    wxFont m_selectedFont;
+    wxFont m_measuringFont;
+    wxColour m_baseColour;
+    wxPen m_baseColourPen;
+    wxPen m_borderPen;
+    wxBrush m_baseColourBrush;
+    wxColour m_activeColour;
+    wxBitmap m_activeCloseBmp;
+    wxBitmap m_disabledCloseBmp;
+    wxBitmap m_activeLeftBmp;
+    wxBitmap m_disabledLeftBmp;
+    wxBitmap m_activeRightBmp;
+    wxBitmap m_disabledRightBmp;
+    wxBitmap m_activeWindowListBmp;
+    wxBitmap m_disabledWindowListBmp;
+
+    int m_fixedTabWidth;
+    int m_tabCtrlHeight;
+    unsigned int m_flags;
+};
+
+
+class WXDLLIMPEXP_AUI wxAuiSimpleTabArt : public wxAuiTabArt
+{
+
+public:
+
+    wxAuiSimpleTabArt();
+    virtual ~wxAuiSimpleTabArt();
+
+    wxAuiTabArt* Clone();
+    void SetFlags(unsigned int flags);
+
+    void SetSizingInfo(const wxSize& tabCtrlSize,
+                       size_t tabCount);
+
+    void SetNormalFont(const wxFont& font);
+    void SetSelectedFont(const wxFont& font);
+    void SetMeasuringFont(const wxFont& font);
+    void SetColour(const wxColour& colour);
+    void SetActiveColour(const wxColour& colour);
+
+    void DrawBackground(
+                 wxDC& dc,
+                 wxWindow* wnd,
+                 const wxRect& rect);
+
+    void DrawTab(wxDC& dc,
+                 wxWindow* wnd,
+                 const wxAuiNotebookPage& pane,
+                 const wxRect& inRect,
+                 int closeButtonState,
+                 wxRect* outTabRect,
+                 wxRect* outButtonRect,
+                 int* xExtent);
+
+    void DrawButton(
+                 wxDC& dc,
+                 wxWindow* wnd,
+                 const wxRect& inRect,
+                 int bitmapId,
+                 int buttonState,
+                 int orientation,
+                 wxRect* outRect);
+
+    int GetIndentSize();
+
+    wxSize GetTabSize(
+                 wxDC& dc,
+                 wxWindow* wnd,
+                 const wxString& caption,
+                 const wxBitmap& bitmap,
+                 bool active,
+                 int closeButtonState,
+                 int* xExtent);
+
+    int ShowDropDown(
+                 wxWindow* wnd,
+                 const wxAuiNotebookPageArray& items,
+                 int activeIdx);
+
+    int GetBestTabCtrlSize(wxWindow* wnd,
+                 const wxAuiNotebookPageArray& pages,
+                 const wxSize& requiredBmpSize);
+
+protected:
+
+    wxFont m_normalFont;
+    wxFont m_selectedFont;
+    wxFont m_measuringFont;
+    wxPen m_normalBkPen;
+    wxPen m_selectedBkPen;
+    wxBrush m_normalBkBrush;
+    wxBrush m_selectedBkBrush;
+    wxBrush m_bkBrush;
+    wxBitmap m_activeCloseBmp;
+    wxBitmap m_disabledCloseBmp;
+    wxBitmap m_activeLeftBmp;
+    wxBitmap m_disabledLeftBmp;
+    wxBitmap m_activeRightBmp;
+    wxBitmap m_disabledRightBmp;
+    wxBitmap m_activeWindowListBmp;
+    wxBitmap m_disabledWindowListBmp;
+
+    int m_fixedTabWidth;
+    unsigned int m_flags;
+};
+
+#ifndef __WXUNIVERSAL__
+    #if defined(__WXGTK20__)
+        #define wxHAS_NATIVE_TABART
+        #include "wx/aui/tabartgtk.h"
+        #define wxAuiDefaultTabArt wxAuiGtkTabArt
+    #endif
+#endif // !__WXUNIVERSAL__
+
+#ifndef wxHAS_NATIVE_TABART
+    #define wxAuiDefaultTabArt wxAuiGenericTabArt
+#endif
+
+
+#endif  // wxUSE_AUI
+#endif  // _WX_TABART_H_
Index: include/wx/aui/tabartgtk.h
===================================================================
--- include/wx/aui/tabartgtk.h	(Revision 0)
+++ include/wx/aui/tabartgtk.h	(Revision 0)
@@ -0,0 +1,59 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        include/wx/aui/tabartgtk.h
+// Purpose:     declaration of the wxAuiGTKTabArt
+// Author:      Jens Lody
+// Modified by:
+// Created:     2012-03-21
+// RCS-ID:      $Id:$
+// Copyright:   (c) 2012 Jens Lody <jens@codeblocks.org>
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_TABARTGTK_H_
+#define _WX_TABARTGTK_H_
+
+// ----------------------------------------------------------------------------
+// headers
+// ----------------------------------------------------------------------------
+
+#include "wx/defs.h"
+
+#if wxUSE_AUI
+
+#include "wx/aui/tabart.h"
+#include "wx/gdicmn.h"
+
+class wxWindow;
+class wxDC;
+
+class WXDLLIMPEXP_AUI wxAuiGtkTabArt : public wxAuiGenericTabArt
+{
+public:
+    wxAuiGtkTabArt();
+
+    virtual wxAuiTabArt* Clone();
+    virtual void DrawBackground(wxDC& dc, wxWindow* wnd, const wxRect& rect);
+    virtual void DrawTab(wxDC& dc,
+                         wxWindow* wnd,
+                         const wxAuiNotebookPage& page,
+                         const wxRect& in_rect,
+                         int close_button_state,
+                         wxRect* out_tab_rect,
+                         wxRect* out_button_rect,
+                         int* x_extent);
+    void DrawButton(wxDC& dc, wxWindow* wnd, const wxRect& in_rect, int bitmap_id,
+                    int button_state, int orientation, wxRect* out_rect);
+    int GetBestTabCtrlSize(wxWindow* wnd, const wxAuiNotebookPageArray& pages,
+                            const wxSize& required_bmp_size);
+    virtual wxSize GetTabSize(wxDC& dc, wxWindow* wnd, const wxString& caption, const wxBitmap& bitmap, bool active,
+                              int close_button_state, int* x_extent);
+private:
+    int m_Xthickness;
+    int m_Ythickness;
+    int m_TabHBorder;
+    int m_TabVBorder;
+};
+
+
+#endif  // wxUSE_AUI
+#endif // _WX_TABARTGTK_H_
Index: include/wx/aui/auibook.h
===================================================================
--- include/wx/aui/auibook.h	(Revision 70939)
+++ include/wx/aui/auibook.h	(Arbeitskopie)
@@ -2,7 +2,7 @@
 // Name:        wx/aui/auibook.h
 // Purpose:     wxaui: wx advanced user interface - notebook
 // Author:      Benjamin I. Williams
-// Modified by:
+// Modified by: Jens Lody
 // Created:     2006-06-28
 // Copyright:   (C) Copyright 2006, Kirix Corporation, All Rights Reserved.
 // Licence:     wxWindows Library Licence, Version 3.1
@@ -21,9 +21,8 @@
 
 #if wxUSE_AUI
 
+#include "wx/aui/tabart.h"
 #include "wx/aui/framemanager.h"
-#include "wx/aui/dockart.h"
-#include "wx/aui/floatpane.h"
 #include "wx/bookctrl.h"
 
 
@@ -119,254 +118,6 @@
 #endif
 
 
-// tab art class
-
-class WXDLLIMPEXP_AUI wxAuiTabArt
-{
-public:
-
-    wxAuiTabArt() { }
-    virtual ~wxAuiTabArt() { }
-
-    virtual wxAuiTabArt* Clone() = 0;
-    virtual void SetFlags(unsigned int flags) = 0;
-
-    virtual void SetSizingInfo(const wxSize& tabCtrlSize,
-                               size_t tabCount) = 0;
-
-    virtual void SetNormalFont(const wxFont& font) = 0;
-    virtual void SetSelectedFont(const wxFont& font) = 0;
-    virtual void SetMeasuringFont(const wxFont& font) = 0;
-    virtual void SetColour(const wxColour& colour) = 0;
-    virtual void SetActiveColour(const wxColour& colour) = 0;
-
-    virtual void DrawBackground(
-                         wxDC& dc,
-                         wxWindow* wnd,
-                         const wxRect& rect) = 0;
-
-    virtual void DrawTab(wxDC& dc,
-                         wxWindow* wnd,
-                         const wxAuiNotebookPage& pane,
-                         const wxRect& inRect,
-                         int closeButtonState,
-                         wxRect* outTabRect,
-                         wxRect* outButtonRect,
-                         int* xExtent) = 0;
-
-    virtual void DrawButton(
-                         wxDC& dc,
-                         wxWindow* wnd,
-                         const wxRect& inRect,
-                         int bitmapId,
-                         int buttonState,
-                         int orientation,
-                         wxRect* outRect) = 0;
-
-    virtual wxSize GetTabSize(
-                         wxDC& dc,
-                         wxWindow* wnd,
-                         const wxString& caption,
-                         const wxBitmap& bitmap,
-                         bool active,
-                         int closeButtonState,
-                         int* xExtent) = 0;
-
-    virtual int ShowDropDown(
-                         wxWindow* wnd,
-                         const wxAuiNotebookPageArray& items,
-                         int activeIdx) = 0;
-
-    virtual int GetIndentSize() = 0;
-
-    virtual int GetBestTabCtrlSize(
-                         wxWindow* wnd,
-                         const wxAuiNotebookPageArray& pages,
-                         const wxSize& requiredBmpSize) = 0;
-};
-
-
-class WXDLLIMPEXP_AUI wxAuiDefaultTabArt : public wxAuiTabArt
-{
-
-public:
-
-    wxAuiDefaultTabArt();
-    virtual ~wxAuiDefaultTabArt();
-
-    wxAuiTabArt* Clone();
-    void SetFlags(unsigned int flags);
-    void SetSizingInfo(const wxSize& tabCtrlSize,
-                       size_t tabCount);
-
-    void SetNormalFont(const wxFont& font);
-    void SetSelectedFont(const wxFont& font);
-    void SetMeasuringFont(const wxFont& font);
-    void SetColour(const wxColour& colour);
-    void SetActiveColour(const wxColour& colour);
-
-    void DrawBackground(
-                 wxDC& dc,
-                 wxWindow* wnd,
-                 const wxRect& rect);
-
-    void DrawTab(wxDC& dc,
-                 wxWindow* wnd,
-                 const wxAuiNotebookPage& pane,
-                 const wxRect& inRect,
-                 int closeButtonState,
-                 wxRect* outTabRect,
-                 wxRect* outButtonRect,
-                 int* xExtent);
-
-    void DrawButton(
-                 wxDC& dc,
-                 wxWindow* wnd,
-                 const wxRect& inRect,
-                 int bitmapId,
-                 int buttonState,
-                 int orientation,
-                 wxRect* outRect);
-
-    int GetIndentSize();
-
-    wxSize GetTabSize(
-                 wxDC& dc,
-                 wxWindow* wnd,
-                 const wxString& caption,
-                 const wxBitmap& bitmap,
-                 bool active,
-                 int closeButtonState,
-                 int* xExtent);
-
-    int ShowDropDown(
-                 wxWindow* wnd,
-                 const wxAuiNotebookPageArray& items,
-                 int activeIdx);
-
-    int GetBestTabCtrlSize(wxWindow* wnd,
-                 const wxAuiNotebookPageArray& pages,
-                 const wxSize& requiredBmpSize);
-
-protected:
-
-    wxFont m_normalFont;
-    wxFont m_selectedFont;
-    wxFont m_measuringFont;
-    wxColour m_baseColour;
-    wxPen m_baseColourPen;
-    wxPen m_borderPen;
-    wxBrush m_baseColourBrush;
-    wxColour m_activeColour;
-    wxBitmap m_activeCloseBmp;
-    wxBitmap m_disabledCloseBmp;
-    wxBitmap m_activeLeftBmp;
-    wxBitmap m_disabledLeftBmp;
-    wxBitmap m_activeRightBmp;
-    wxBitmap m_disabledRightBmp;
-    wxBitmap m_activeWindowListBmp;
-    wxBitmap m_disabledWindowListBmp;
-
-    int m_fixedTabWidth;
-    int m_tabCtrlHeight;
-    unsigned int m_flags;
-};
-
-
-class WXDLLIMPEXP_AUI wxAuiSimpleTabArt : public wxAuiTabArt
-{
-
-public:
-
-    wxAuiSimpleTabArt();
-    virtual ~wxAuiSimpleTabArt();
-
-    wxAuiTabArt* Clone();
-    void SetFlags(unsigned int flags);
-
-    void SetSizingInfo(const wxSize& tabCtrlSize,
-                       size_t tabCount);
-
-    void SetNormalFont(const wxFont& font);
-    void SetSelectedFont(const wxFont& font);
-    void SetMeasuringFont(const wxFont& font);
-    void SetColour(const wxColour& colour);
-    void SetActiveColour(const wxColour& colour);
-
-    void DrawBackground(
-                 wxDC& dc,
-                 wxWindow* wnd,
-                 const wxRect& rect);
-
-    void DrawTab(wxDC& dc,
-                 wxWindow* wnd,
-                 const wxAuiNotebookPage& pane,
-                 const wxRect& inRect,
-                 int closeButtonState,
-                 wxRect* outTabRect,
-                 wxRect* outButtonRect,
-                 int* xExtent);
-
-    void DrawButton(
-                 wxDC& dc,
-                 wxWindow* wnd,
-                 const wxRect& inRect,
-                 int bitmapId,
-                 int buttonState,
-                 int orientation,
-                 wxRect* outRect);
-
-    int GetIndentSize();
-
-    wxSize GetTabSize(
-                 wxDC& dc,
-                 wxWindow* wnd,
-                 const wxString& caption,
-                 const wxBitmap& bitmap,
-                 bool active,
-                 int closeButtonState,
-                 int* xExtent);
-
-    int ShowDropDown(
-                 wxWindow* wnd,
-                 const wxAuiNotebookPageArray& items,
-                 int activeIdx);
-
-    int GetBestTabCtrlSize(wxWindow* wnd,
-                 const wxAuiNotebookPageArray& pages,
-                 const wxSize& requiredBmpSize);
-
-protected:
-
-    wxFont m_normalFont;
-    wxFont m_selectedFont;
-    wxFont m_measuringFont;
-    wxPen m_normalBkPen;
-    wxPen m_selectedBkPen;
-    wxBrush m_normalBkBrush;
-    wxBrush m_selectedBkBrush;
-    wxBrush m_bkBrush;
-    wxBitmap m_activeCloseBmp;
-    wxBitmap m_disabledCloseBmp;
-    wxBitmap m_activeLeftBmp;
-    wxBitmap m_disabledLeftBmp;
-    wxBitmap m_activeRightBmp;
-    wxBitmap m_disabledRightBmp;
-    wxBitmap m_activeWindowListBmp;
-    wxBitmap m_disabledWindowListBmp;
-
-    int m_fixedTabWidth;
-    unsigned int m_flags;
-};
-
-
-
-
-
-
-
-
-
 class WXDLLIMPEXP_AUI wxAuiTabContainer
 {
 public:
@@ -687,6 +438,18 @@
 };
 
 
+#ifndef __WXUNIVERSAL__
+    #if defined(__WXGTK20__)
+        #define wxHAS_NATIVE_TABART
+        #include "wx/aui/tabartgtk.h"
+        #define wxAuiDefaultTabArt wxAuiGtkTabArt
+    #endif
+#endif // !__WXUNIVERSAL__
+
+#ifndef wxHAS_NATIVE_TABART
+    #define wxAuiDefaultTabArt wxAuiGenericTabArt
+#endif
+
 
 
 // wx event machinery
Index: build/bakefiles/files.bkl
===================================================================
--- build/bakefiles/files.bkl	(Revision 70939)
+++ build/bakefiles/files.bkl	(Arbeitskopie)
@@ -3548,6 +3548,16 @@
 <!--                                  wxAUI                                 -->
 <!-- ====================================================================== -->
 
+<set var="AUI_GTK_SRC" hints="files">
+    <if cond="TOOLKIT=='GTK' and TOOLKIT_VERSION=='2'">
+        src/aui/tabartgtk.cpp
+    </if>
+</set>
+<set var="AUI_GTK_HDR" hints="files">
+    <if cond="TOOLKIT=='GTK' and TOOLKIT_VERSION=='2'">
+        wx/aui/tabartgtk.h
+    </if>
+</set>
 <set var="AUI_SRC" hints="files">
     src/aui/framemanager.cpp
     src/aui/dockart.cpp
@@ -3555,6 +3565,8 @@
     src/aui/auibook.cpp
     src/aui/auibar.cpp
     src/aui/tabmdi.cpp
+    src/aui/tabart.cpp
+    $(AUI_GTK_SRC)
 </set>
 <set var="AUI_HDR" hints="files">
     wx/aui/framemanager.h
@@ -3564,6 +3576,8 @@
     wx/aui/auibar.h
     wx/aui/tabmdi.h
     wx/aui/aui.h
+    wx/aui/tabart.h
+    $(AUI_GTK_HDR)
 </set>
 
 <!-- ====================================================================== -->
