diff -ruP tests.orig/streams/bstream.cpp tests/streams/bstream.cpp
--- tests.orig/streams/bstream.cpp	1970-01-01 01:00:00.000000000 +0100
+++ tests/streams/bstream.cpp	2004-03-29 20:51:41.000000000 +0200
@@ -0,0 +1,69 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        tests/streams/bstream.cpp
+// Purpose:     House the base stream test suite.
+// Author:      Hans Van Leemputten
+// RCS-ID:      $Id: formatconverter.cpp,v 1.1 2004/03/06 11:23:42 VS Exp $
+// Copyright:   (c) 2004 Hans Van Leemputten
+// Licence:     wxWidgets licence
+///////////////////////////////////////////////////////////////////////////////
+
+#if defined(__GNUG__) && !defined(__APPLE__)
+    #pragma implementation
+    #pragma interface
+#endif
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+// for all others, include the necessary headers
+#ifndef WX_PRECOMP
+    #include "wx/wx.h"
+#endif
+
+#include "wx/cppunit.h"
+#include "bstream.h"
+
+using namespace CppUnit;
+
+///////////////////////////////////////////////////////////////////////////////
+// Streams main test suite, it houses all stream test suites.
+//
+
+class StreamCase : public TestSuite
+{
+public:
+    StreamCase() 
+        :TestSuite("Streams") 
+    { /* Nothing extra */ }
+    static Test *suite();
+};
+
+Test *StreamCase::suite()
+{
+    TestSuite *suite = new StreamCase;
+
+    /*
+     * Register all sub stream test suites.
+     */
+    
+    STREAM_REGISTER_SUB_SUITE(memStream);
+    STREAM_REGISTER_SUB_SUITE(fileStream);
+    STREAM_REGISTER_SUB_SUITE(ffileStream);
+    STREAM_REGISTER_SUB_SUITE(zlibStream);
+
+    /* 
+    ** Add more stream subtests here
+    */
+
+    return suite;
+}
+
+// register in the unnamed registry so that these tests are run by default
+CPPUNIT_TEST_SUITE_REGISTRATION(StreamCase);
+// also include in it's own registry so that these tests can be run alone
+CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(StreamCase, STREAM_TEST_NAME);
+
diff -ruP tests.orig/streams/bstream.h tests/streams/bstream.h
--- tests.orig/streams/bstream.h	1970-01-01 01:00:00.000000000 +0100
+++ tests/streams/bstream.h	2004-03-29 21:05:20.000000000 +0200
@@ -0,0 +1,410 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        tests/streams/bstream.h
+// Purpose:     Template class for testing base stream functions.
+// Author:      Hans Van Leemputten
+// RCS-ID:      $Id: formatconverter.cpp,v 1.1 2004/03/06 11:23:42 VS Exp $
+// Copyright:   (c) 2004 Hans Van Leemputten
+// Licence:     wxWidgets licence
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_TESTBSTREAM_H__
+#define _WX_TESTBSTREAM_H__
+
+#include "wx/cppunit.h"
+using namespace CppUnit;
+
+///////////////////////////////////////////////////////////////////////////////
+// Some macros preventing use from typing too much ;-)
+//
+
+#define STREAM_TEST_NAME "Streams"
+#define STREAM_REGISTER_SUB_SUITE(Name) \
+    extern Test* Get##Name##Suite(); \
+    suite->addTest(Get##Name##Suite())
+#define STREAM_IMPLEMENT_SUB_REGISTRATION_ROUTINE(Name) \
+    Test* Get##Name##Suite() { return Name::suite(); }
+#define STREAM_TEST_SUBSUITE_NAMED_REGISTRATION(Name) \
+    CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( Name, STREAM_TEST_NAME "." #Name ); \
+    STREAM_IMPLEMENT_SUB_REGISTRATION_ROUTINE( Name )
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Template class that implements a test for all base stream functions.
+//
+
+template <class TStreamIn, class TStreamOut> class BaseStreamTestCase : public TestCase
+{
+protected:
+    typedef BaseStreamTestCase<TStreamIn, TStreamOut> StreamTestCase;
+
+    class CleanupHelper
+    {
+    public:
+        CleanupHelper(StreamTestCase *value)
+            :m_pCleanup(value)
+        {}
+        ~CleanupHelper()
+        { 
+            m_pCleanup->DeleteInStream();
+            m_pCleanup->DeleteOutStream();
+        }
+    private:
+        StreamTestCase   *m_pCleanup;
+    };
+    friend class CleanupHelper;
+
+public:
+    BaseStreamTestCase()
+        :m_bSimpleTellITest(false),
+         m_bSimpleTellOTest(false),
+         m_pCurrentIn(NULL),
+         m_pCurrentOut(NULL)
+    { /* Nothing extra */ }
+    virtual ~BaseStreamTestCase()
+    {
+        // Prevent mem leaks!
+        delete m_pCurrentIn;
+        delete m_pCurrentOut;
+    }   
+
+protected:
+    /*
+     * Input stream tests.
+     */
+
+    // Just try to perform a GetSize() on the input stream.
+    void Input_GetSize()
+    {
+        CleanupHelper cleanup(this);
+        const TStreamIn &stream_in = CreateInStream();
+        CPPUNIT_ASSERT(!stream_in.Eof());
+
+        // Size should be greater then zero.
+        // Note: streams not supporting this should register this test
+        //       with CPPUNIT_TEST_FAIL instead of CPPUNIT_TEST.
+        CPPUNIT_ASSERT(stream_in.GetSize() != 0);
+    }
+
+    // Just try to perform a GetC() on the input stream.
+    void Input_GetC()
+    {
+        CleanupHelper cleanup(this);
+        TStreamIn &stream_in = CreateInStream();
+        CPPUNIT_ASSERT(!stream_in.Eof());
+
+        // If no exception occurs the test is successful.
+        (void)stream_in.GetC();
+    }
+
+    // Just try to perform a Read() on the input stream.
+    void Input_Read()
+    {
+        CleanupHelper cleanup(this);
+        TStreamIn &stream_in = CreateInStream();
+        CPPUNIT_ASSERT(!stream_in.Eof());
+
+        // Note: the input stream should at least be of min size +10!
+
+        char buf[10];        
+        (void)stream_in.Read(buf, 10);
+
+        CPPUNIT_ASSERT(!stream_in.Eof());
+        CPPUNIT_ASSERT(stream_in.IsOk());
+
+        // Test the stream version aswell.
+        TStreamOut &stream_out = CreateOutStream();
+        (void)stream_in.Read(stream_out);
+
+        // The output stream should have read the input stream till the end.
+        CPPUNIT_ASSERT(stream_in.Eof());
+    }
+
+    // Test and see what happens to the EOF when we 
+    // read after EOF was encountered.
+    void Input_Eof()
+    {
+        CleanupHelper cleanup(this);
+        TStreamIn &stream_in = CreateInStream();
+        CPPUNIT_ASSERT(!stream_in.Eof());
+        // Double check to see if Eof it self doesn't changes the Eof status.
+        CPPUNIT_ASSERT(!stream_in.Eof());
+
+        // Travel to the end of the stream.
+        while(!stream_in.Eof())
+        {
+            // Double check to see if normal Eof works.
+            CPPUNIT_ASSERT_MESSAGE("Eof() doesn't return true when IsOk returns false!", stream_in.IsOk());
+            // Read, we move one byte along.
+            (void)stream_in.GetC();
+        }
+
+        // Ok we found the end, lets see if we can go past it.
+        for (size_t i = 0; i < 100; i++)
+            (void)stream_in.GetC();
+
+        // Check for EOF correctness.
+        CPPUNIT_ASSERT_MESSAGE("EOF is wrong when we read past EOF!", stream_in.Eof());
+    }
+
+    // Just try to perform a LastRead() on the input stream.
+    void Input_LastRead()
+    {
+        CleanupHelper cleanup(this);
+        TStreamIn &stream_in = CreateInStream();
+        CPPUNIT_ASSERT(!stream_in.Eof());
+
+        char buf[5];
+        (void)stream_in.Read(buf, 5);
+        CPPUNIT_ASSERT(stream_in.LastRead() == 5);
+        (void)stream_in.GetC();
+        CPPUNIT_ASSERT(stream_in.LastRead() == 1);
+    }
+
+    // Just try to perform a SeekI() on the input stream.
+    void Input_SeekI()
+    {
+        CleanupHelper cleanup(this);
+        TStreamIn &stream_in = CreateInStream();
+        CPPUNIT_ASSERT(!stream_in.Eof());
+
+        // Try to Seek in the stream...
+        // Note: streams not supporting this should register this test
+        //       with CPPUNIT_TEST_FAIL instead of CPPUNIT_TEST.
+        CPPUNIT_ASSERT(stream_in.SeekI(2, wxFromStart) == 2);
+        CPPUNIT_ASSERT(stream_in.SeekI(2, wxFromCurrent) == 4);
+        // Not sure the following line is correct, so test it differently.
+        //CPPUNIT_ASSERT(stream_in.SeekI(-2, wxFromEnd) == (off_t)stream_in.GetSize()-2);
+        CPPUNIT_ASSERT(stream_in.SeekI(-2, wxFromEnd) != wxInvalidOffset);
+        // Go beyond the stream size.
+        CPPUNIT_ASSERT(stream_in.SeekI(10, wxFromCurrent) == wxInvalidOffset);
+    }
+
+    // Just try to perform a TellI() on the input stream.
+    void Input_TellI()
+    {
+        CleanupHelper cleanup(this);
+        TStreamIn &stream_in = CreateInStream();
+        CPPUNIT_ASSERT(!stream_in.Eof());
+
+        // Try to Get the location in the stream...
+        CPPUNIT_ASSERT(stream_in.TellI() == 0);
+        (void)stream_in.GetC();
+        CPPUNIT_ASSERT(stream_in.TellI() == 1);
+        if (!m_bSimpleTellITest)
+        {
+            off_t pos = stream_in.SeekI(5, wxFromStart);
+            CPPUNIT_ASSERT(stream_in.TellI() == pos);
+            (void)stream_in.GetC();
+            CPPUNIT_ASSERT(stream_in.TellI() == 6);
+            pos = stream_in.SeekI(2, wxFromCurrent);
+            CPPUNIT_ASSERT(stream_in.TellI() == pos);
+            pos = stream_in.SeekI(5, wxFromStart);
+            CPPUNIT_ASSERT(stream_in.TellI() == pos);
+        }
+    }
+    
+    // Just try to perform a Peek() on the input stream.
+    void Input_Peek()
+    {
+        CleanupHelper cleanup(this);
+        TStreamIn &stream_in = CreateInStream();
+
+        // Test the full stream
+        while(!stream_in.Eof())
+        {
+            if (!stream_in.IsOk())
+                break;
+
+            char peekChar = stream_in.Peek();
+            char getChar = stream_in.GetC();
+            CPPUNIT_ASSERT(peekChar == getChar);
+        }
+    }
+
+    // Just try to perform a Ungetch() on the input stream.
+    void Input_Ungetch()
+    {
+        CleanupHelper cleanup(this);
+        TStreamIn &stream_in = CreateInStream();
+        CPPUNIT_ASSERT(!stream_in.Eof());
+        
+        const char *ungetstr = "test";
+        size_t ungetsize = stream_in.Ungetch(ungetstr, strlen(ungetstr) + 1);
+        if (ungetsize != 0)
+        {
+            CPPUNIT_ASSERT(ungetsize == strlen(ungetstr) + 1);
+            char buf[10];
+            (void)stream_in.Read(buf, ungetsize);
+            CPPUNIT_ASSERT(strcmp(buf, ungetstr) == 0);
+        }
+
+        if (stream_in.Ungetch('a'))
+        {
+            CPPUNIT_ASSERT(stream_in.GetC() == 'a');
+        }
+    }
+
+    /*
+     * Output stream tests.
+     */
+
+    // Just try to perform a PutC() on the output stream.
+    void Output_PutC()
+    {
+        CleanupHelper cleanup(this);
+        TStreamOut &stream_out = CreateOutStream();
+
+        char *buf = "Some text";
+        off_t i;
+        off_t len = (off_t) strlen(buf);
+        for (i = 0; i < len; i++)
+            stream_out.PutC(buf[i]);
+
+        CPPUNIT_ASSERT(i == stream_out.TellO());
+    }
+
+    // Just try to perform a Write() on the output stream.
+    void Output_Write()
+    {
+        CleanupHelper cleanup(this);
+        TStreamOut &stream_out = CreateOutStream();
+
+        // Do the buffer version.
+        char *buf = "Some text";
+        off_t len = (off_t) strlen(buf);
+        (void)stream_out.Write(buf, len);
+        CPPUNIT_ASSERT(stream_out.TellO() == len);
+
+        // Do the Stream version.
+        TStreamIn &stream_in = CreateInStream();
+        (void)stream_out.Write(stream_in);
+        CPPUNIT_ASSERT(stream_out.TellO() > len);
+    }
+
+    // Just try to perform a LastWrite() on the output stream.
+    void Output_LastWrite()
+    {
+        CleanupHelper cleanup(this);
+        TStreamOut &stream_out = CreateOutStream();
+
+        char *buf = "12345";
+        (void)stream_out.Write(buf, 5);
+        CPPUNIT_ASSERT(stream_out.LastWrite() == 5);
+        (void)stream_out.PutC('1');
+        CPPUNIT_ASSERT(stream_out.LastWrite() == 1);
+    }
+
+    // Just try to perform a SeekO() on the output stream.
+    void Output_SeekO()
+    {
+        CleanupHelper cleanup(this);
+        TStreamOut &stream_out = CreateOutStream();
+        
+        // First put some data in the stream, so it is not empty.
+        char *buf = "1234567890";
+        (void)stream_out.Write(buf, 10);
+
+        // Try to Seek in the stream...
+        // Note: streams not supporting this should register this test
+        //       with CPPUNIT_TEST_FAIL instead of CPPUNIT_TEST.
+        CPPUNIT_ASSERT(stream_out.SeekO(2, wxFromStart) == 2);
+        CPPUNIT_ASSERT(stream_out.SeekO(2, wxFromCurrent) == 4);
+        // Not sure the following line is correct, so test it differently.
+        //CPPUNIT_ASSERT(stream_out.SeekO(-2, wxFromEnd) == (off_t)stream_in.GetSize()-2);
+        CPPUNIT_ASSERT(stream_out.SeekO(-2, wxFromEnd) != wxInvalidOffset);
+        // Go beyond the stream size.
+        CPPUNIT_ASSERT(stream_out.SeekO(10, wxFromCurrent) == wxInvalidOffset);
+    }
+
+    // Just try to perform a TellO() on the output stream.
+    void Output_TellO()
+    {
+        CleanupHelper cleanup(this);
+        TStreamOut &stream_out = CreateOutStream();
+
+        // Try to Get the location in the stream...
+        CPPUNIT_ASSERT(stream_out.TellO() == 0);
+        (void)stream_out.PutC('1');
+        CPPUNIT_ASSERT(stream_out.TellO() == 1);
+        if (!m_bSimpleTellOTest)
+        {
+            // First put some extra data in the stream, so it's not empty.
+            char *buf = "1234567890";
+            (void)stream_out.Write(buf, 10);
+            
+            off_t pos = stream_out.SeekO(5, wxFromStart);
+            CPPUNIT_ASSERT(stream_out.TellO() == pos);
+            (void)stream_out.PutC('1');
+            CPPUNIT_ASSERT(stream_out.TellO() == 6);
+            pos = stream_out.SeekO(2, wxFromCurrent);
+            CPPUNIT_ASSERT(stream_out.TellO() == pos);
+            pos = stream_out.SeekO(5, wxFromStart);
+            CPPUNIT_ASSERT(stream_out.TellO() == pos);
+        }
+    }
+
+protected:
+    // Some tests can be configured... here you can find the config settings
+    bool m_bSimpleTellITest;    // if true, no SeekI will be used by the TellI test. 
+                                // Default false.
+    bool m_bSimpleTellOTest;    // if true, no SeekO will be used by the TellI test. 
+                                // Default false.
+
+protected:
+    TStreamIn &CreateInStream()
+    { 
+        if (m_pCurrentIn)
+        {
+            wxFAIL_MSG(_T("Error in test case, the previouse input stream needs to be delete first!"));
+        }
+
+        m_pCurrentIn = DoCreateInStream();
+        wxASSERT(m_pCurrentIn != NULL);
+        return *m_pCurrentIn;
+    }
+    TStreamOut &CreateOutStream()
+    { 
+        if (m_pCurrentOut)
+        {
+            wxFAIL_MSG(_T("Error in test case, the previouse output stream needs to be delete first!"));
+        }
+
+        m_pCurrentOut = DoCreateOutStream();
+        wxASSERT(m_pCurrentOut != NULL);
+        return *m_pCurrentOut;
+    }
+    
+    void DeleteInStream()
+    {
+        if (m_pCurrentIn == NULL)
+            return;
+        delete m_pCurrentIn;
+        m_pCurrentIn = NULL;
+        // Incase something extra needs to be done.
+        DoDeleteInStream();
+    }
+    void DeleteOutStream()
+    {
+        if (m_pCurrentOut == NULL)
+            return;
+        delete m_pCurrentOut;
+        m_pCurrentOut = NULL;
+        // Incase something extra needs to be done.
+        DoDeleteOutStream();
+    }
+
+protected:
+    // Items that need to be implemented by a derived class!
+    virtual TStreamIn  *DoCreateInStream() = 0;
+    virtual TStreamOut *DoCreateOutStream() = 0;
+    virtual void DoDeleteInStream()  { /* Depends on the base class */ }
+    virtual void DoDeleteOutStream() { /* Depends on the base class */ }
+
+private:
+    TStreamIn  *m_pCurrentIn;
+    TStreamOut *m_pCurrentOut;
+};
+
+#endif
+
+
diff -ruP tests.orig/streams/ffilestream.cpp tests/streams/ffilestream.cpp
--- tests.orig/streams/ffilestream.cpp	1970-01-01 01:00:00.000000000 +0100
+++ tests/streams/ffilestream.cpp	2004-03-29 20:51:41.000000000 +0200
@@ -0,0 +1,140 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        tests/streams/ffilestream.cpp
+// Purpose:     Test wxFFileInputStream/wxFFileOutputStream
+// Author:      Hans Van Leemputten
+// RCS-ID:      $Id: formatconverter.cpp,v 1.1 2004/03/06 11:23:42 VS Exp $
+// Copyright:   (c) 2004 Hans Van Leemputten
+// Licence:     wxWidgets licence
+///////////////////////////////////////////////////////////////////////////////
+
+#if defined(__GNUG__) && !defined(__APPLE__)
+    #pragma implementation
+    #pragma interface
+#endif
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+// for all others, include the necessary headers
+#ifndef WX_PRECOMP
+    #include "wx/wx.h"
+#endif
+
+#include "wx/cppunit.h"
+#include "wx/wfstream.h"
+
+#include "bstream.h"
+
+using namespace std;
+using namespace CppUnit;
+
+#define DATABUFFER_SIZE     1024
+
+static const wxString FILENAME_FFILEINSTREAM = _T("ffileinstream.test");
+static const wxString FILENAME_FFILEOUTSTREAM = _T("ffileoutstream.test");
+
+///////////////////////////////////////////////////////////////////////////////
+// The test case
+//
+// Try to fully test wxFFileInputStream and wxFFileOutputStream
+
+class ffileStream : public BaseStreamTestCase<wxFFileInputStream, wxFFileOutputStream>
+{
+public:
+    ffileStream();
+    virtual ~ffileStream();
+
+    CPPUNIT_TEST_SUITE(ffileStream);
+        // Base class stream tests the ffileStream supports.
+        CPPUNIT_TEST(Input_GetSize);
+        CPPUNIT_TEST(Input_GetC);
+        CPPUNIT_TEST(Input_Read);
+        CPPUNIT_TEST(Input_Eof);
+        CPPUNIT_TEST(Input_LastRead);
+        CPPUNIT_TEST(Input_SeekI);
+        CPPUNIT_TEST(Input_TellI);
+        CPPUNIT_TEST(Input_Peek);
+        CPPUNIT_TEST(Input_Ungetch);
+
+        CPPUNIT_TEST(Output_PutC);
+        CPPUNIT_TEST(Output_Write);
+        CPPUNIT_TEST(Output_LastWrite);
+        CPPUNIT_TEST(Output_SeekO);
+        CPPUNIT_TEST(Output_TellO);
+
+        // Other test specific for File stream test case.
+    CPPUNIT_TEST_SUITE_END();
+
+protected:
+    // Add own test here.
+
+private:
+    // Implement base class functions.
+    virtual wxFFileInputStream  *DoCreateInStream();  
+    virtual wxFFileOutputStream *DoCreateOutStream();
+    virtual void DoDeleteOutStream();
+
+private:
+    wxString GetInFileName() const;
+};
+
+ffileStream::ffileStream()
+{
+    /* Nothing extra */
+}
+
+ffileStream::~ffileStream()
+{
+    // Remove the temp test file...
+    ::wxRemoveFile(FILENAME_FFILEINSTREAM);
+    ::wxRemoveFile(FILENAME_FFILEOUTSTREAM);
+}
+
+wxFFileInputStream *ffileStream::DoCreateInStream()    
+{ 
+    wxFFileInputStream *pFileInStream = new wxFFileInputStream(GetInFileName());
+    CPPUNIT_ASSERT(pFileInStream->IsOk());
+    return pFileInStream;
+}
+wxFFileOutputStream *ffileStream::DoCreateOutStream()
+{ 
+    wxFFileOutputStream *pFileOutStream = new wxFFileOutputStream(FILENAME_FFILEOUTSTREAM);
+    CPPUNIT_ASSERT(pFileOutStream->IsOk());
+    return pFileOutStream;
+}
+
+void ffileStream::DoDeleteOutStream()
+{
+    ::wxRemoveFile(FILENAME_FFILEOUTSTREAM);
+}
+
+wxString ffileStream::GetInFileName() const
+{
+    static bool bFileCreated = false;
+    if (!bFileCreated)
+    {
+        // Create the file only once
+        bFileCreated = true;
+
+        // Make sure we have a input file...
+        char buf[DATABUFFER_SIZE];
+        wxFFileOutputStream out(FILENAME_FFILEINSTREAM);
+        
+        // Init the data buffer.
+        for (size_t i = 0; i < DATABUFFER_SIZE; i++)
+            buf[i] = (i % 0xFF);
+
+        // Save the data
+        out.Write(buf, DATABUFFER_SIZE);
+    }
+
+    return FILENAME_FFILEINSTREAM;
+}
+
+// Register the stream sub suite, by using some stream helper macro.
+// Note: Don't forget to connect it to the base suite (See: bstream.cpp => StreamCase::suite())
+STREAM_TEST_SUBSUITE_NAMED_REGISTRATION(ffileStream)
diff -ruP tests.orig/streams/filestream.cpp tests/streams/filestream.cpp
--- tests.orig/streams/filestream.cpp	1970-01-01 01:00:00.000000000 +0100
+++ tests/streams/filestream.cpp	2004-03-29 20:51:41.000000000 +0200
@@ -0,0 +1,140 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        tests/streams/filestream.cpp
+// Purpose:     Test wxFileInputStream/wxFileOutputStream
+// Author:      Hans Van Leemputten
+// RCS-ID:      $Id: formatconverter.cpp,v 1.1 2004/03/06 11:23:42 VS Exp $
+// Copyright:   (c) 2004 Hans Van Leemputten
+// Licence:     wxWidgets licence
+///////////////////////////////////////////////////////////////////////////////
+
+#if defined(__GNUG__) && !defined(__APPLE__)
+    #pragma implementation
+    #pragma interface
+#endif
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+// for all others, include the necessary headers
+#ifndef WX_PRECOMP
+    #include "wx/wx.h"
+#endif
+
+#include "wx/cppunit.h"
+#include "wx/wfstream.h"
+
+#include "bstream.h"
+
+using namespace std;
+using namespace CppUnit;
+
+#define DATABUFFER_SIZE     1024
+
+static const wxString FILENAME_FILEINSTREAM = _T("fileinstream.test");
+static const wxString FILENAME_FILEOUTSTREAM = _T("fileoutstream.test");
+
+///////////////////////////////////////////////////////////////////////////////
+// The test case
+//
+// Try to fully test wxFileInputStream and wxFileOutputStream
+
+class fileStream : public BaseStreamTestCase<wxFileInputStream, wxFileOutputStream>
+{
+public:
+    fileStream();
+    virtual ~fileStream();
+
+    CPPUNIT_TEST_SUITE(fileStream);
+        // Base class stream tests the fileStream supports.
+        CPPUNIT_TEST(Input_GetSize);
+        CPPUNIT_TEST(Input_GetC);
+        CPPUNIT_TEST(Input_Read);
+        CPPUNIT_TEST(Input_Eof);
+        CPPUNIT_TEST(Input_LastRead);
+        CPPUNIT_TEST(Input_SeekI);
+        CPPUNIT_TEST(Input_TellI);
+        CPPUNIT_TEST(Input_Peek);
+        CPPUNIT_TEST(Input_Ungetch);
+
+        CPPUNIT_TEST(Output_PutC);
+        CPPUNIT_TEST(Output_Write);
+        CPPUNIT_TEST(Output_LastWrite);
+        CPPUNIT_TEST(Output_SeekO);
+        CPPUNIT_TEST(Output_TellO);
+
+        // Other test specific for File stream test case.
+    CPPUNIT_TEST_SUITE_END();
+
+protected:
+    // Add own test here.
+
+private:
+    // Implement base class functions.
+    virtual wxFileInputStream  *DoCreateInStream();  
+    virtual wxFileOutputStream *DoCreateOutStream();
+    virtual void DoDeleteOutStream();
+
+private:
+    wxString GetInFileName() const;
+};
+
+fileStream::fileStream()
+{
+    /* Nothing extra */
+}
+
+fileStream::~fileStream()
+{
+    // Remove the temp test file...
+    ::wxRemoveFile(FILENAME_FILEINSTREAM);
+    ::wxRemoveFile(FILENAME_FILEOUTSTREAM);
+}
+
+wxFileInputStream *fileStream::DoCreateInStream()    
+{ 
+    wxFileInputStream *pFileInStream = new wxFileInputStream(GetInFileName());
+    CPPUNIT_ASSERT(pFileInStream->IsOk());
+    return pFileInStream;
+}
+wxFileOutputStream *fileStream::DoCreateOutStream()
+{ 
+    wxFileOutputStream *pFileOutStream = new wxFileOutputStream(FILENAME_FILEOUTSTREAM);
+    CPPUNIT_ASSERT(pFileOutStream->IsOk());
+    return pFileOutStream;
+}
+
+void fileStream::DoDeleteOutStream()
+{
+    ::wxRemoveFile(FILENAME_FILEOUTSTREAM);
+}
+
+wxString fileStream::GetInFileName() const
+{
+    static bool bFileCreated = false;
+    if (!bFileCreated)
+    {
+        // Create the file only once
+        bFileCreated = true;
+
+        // Make sure we have a input file...
+        char buf[DATABUFFER_SIZE];
+        wxFileOutputStream out(FILENAME_FILEINSTREAM);
+        
+        // Init the data buffer.
+        for (size_t i = 0; i < DATABUFFER_SIZE; i++)
+            buf[i] = (i % 0xFF);
+
+        // Save the data
+        out.Write(buf, DATABUFFER_SIZE);
+    }
+
+    return FILENAME_FILEINSTREAM;
+}
+
+// Register the stream sub suite, by using some stream helper macro.
+// Note: Don't forget to connect it to the base suite (See: bstream.cpp => StreamCase::suite())
+STREAM_TEST_SUBSUITE_NAMED_REGISTRATION(fileStream)
diff -ruP tests.orig/streams/memstream.cpp tests/streams/memstream.cpp
--- tests.orig/streams/memstream.cpp	1970-01-01 01:00:00.000000000 +0100
+++ tests/streams/memstream.cpp	2004-03-29 20:51:41.000000000 +0200
@@ -0,0 +1,117 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        tests/streams/memstream.cpp
+// Purpose:     Test wxMemoryInputStream/wxMemoryOutputStream
+// Author:      Hans Van Leemputten
+// RCS-ID:      $Id: formatconverter.cpp,v 1.1 2004/03/06 11:23:42 VS Exp $
+// Copyright:   (c) 2004 Hans Van Leemputten
+// Licence:     wxWidgets licence
+///////////////////////////////////////////////////////////////////////////////
+
+#if defined(__GNUG__) && !defined(__APPLE__)
+    #pragma implementation
+    #pragma interface
+#endif
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+// for all others, include the necessary headers
+#ifndef WX_PRECOMP
+    #include "wx/wx.h"
+#endif
+
+#include "wx/cppunit.h"
+#include "wx/mstream.h"
+
+#include "bstream.h"
+
+using namespace std;
+using namespace CppUnit;
+
+#define DATABUFFER_SIZE     256
+
+///////////////////////////////////////////////////////////////////////////////
+// The test case
+//
+// Try to fully test wxMemoryInputStream and wxMemoryOutputStream
+
+class memStream : public BaseStreamTestCase<wxMemoryInputStream, wxMemoryOutputStream>
+{
+public:
+    memStream();
+    virtual ~memStream();
+
+    CPPUNIT_TEST_SUITE(memStream);
+        // Base class stream tests the memStream supports.
+        CPPUNIT_TEST(Input_GetSize);
+        CPPUNIT_TEST(Input_GetC);
+        CPPUNIT_TEST(Input_Read);
+        CPPUNIT_TEST(Input_Eof);
+        CPPUNIT_TEST(Input_LastRead);
+        CPPUNIT_TEST(Input_SeekI);
+        CPPUNIT_TEST(Input_TellI);
+        CPPUNIT_TEST(Input_Peek);
+        CPPUNIT_TEST(Input_Ungetch);
+
+        CPPUNIT_TEST(Output_PutC);
+        CPPUNIT_TEST(Output_Write);
+        CPPUNIT_TEST(Output_LastWrite);
+        CPPUNIT_TEST(Output_SeekO);
+        CPPUNIT_TEST(Output_TellO);
+
+        // Other test specific for Memory stream test case.
+    CPPUNIT_TEST_SUITE_END();
+
+protected:
+    // Add own test here.
+
+private:
+    const char *GetDataBuffer();
+
+private:
+    // Implement base class functions.
+    virtual wxMemoryInputStream  *DoCreateInStream();  
+    virtual wxMemoryOutputStream *DoCreateOutStream();
+
+private:
+    char    m_DataBuffer[DATABUFFER_SIZE];
+};
+
+memStream::memStream()
+{
+    // Init the data buffer.
+    for (size_t i = 0; i < DATABUFFER_SIZE; i++)
+        m_DataBuffer[i] = (i % 0xFF);
+}
+
+memStream::~memStream()
+{
+    /* Nothing extra for now. */
+}
+
+const char *memStream::GetDataBuffer()
+{
+    return m_DataBuffer;
+}
+
+wxMemoryInputStream *memStream::DoCreateInStream()    
+{ 
+    wxMemoryInputStream *pMemInStream = new wxMemoryInputStream(GetDataBuffer(), DATABUFFER_SIZE);
+    CPPUNIT_ASSERT(pMemInStream->IsOk());
+    return pMemInStream;
+}
+wxMemoryOutputStream *memStream::DoCreateOutStream()
+{ 
+    wxMemoryOutputStream *pMemOutStream = new wxMemoryOutputStream();
+    CPPUNIT_ASSERT(pMemOutStream->IsOk());
+    return pMemOutStream;
+}
+
+
+// Register the stream sub suite, by using some stream helper macro.
+// Note: Don't forget to connect it to the base suite (See: bstream.cpp => StreamCase::suite())
+STREAM_TEST_SUBSUITE_NAMED_REGISTRATION(memStream)
diff -ruP tests.orig/streams/zlibstream.cpp tests/streams/zlibstream.cpp
--- tests.orig/streams/zlibstream.cpp	1970-01-01 01:00:00.000000000 +0100
+++ tests/streams/zlibstream.cpp	2004-03-29 20:51:41.000000000 +0200
@@ -0,0 +1,404 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        tests/streams/zlibstream.cpp
+// Purpose:     Test wxZlibInputStream/wxZlibOutputStream
+// Author:      Hans Van Leemputten
+// RCS-ID:      $Id: formatconverter.cpp,v 1.1 2004/03/06 11:23:42 VS Exp $
+// Copyright:   (c) 2004 Hans Van Leemputten
+// Licence:     wxWidgets licence
+///////////////////////////////////////////////////////////////////////////////
+
+#if defined(__GNUG__) && !defined(__APPLE__)
+    #pragma implementation
+    #pragma interface
+#endif
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+// for all others, include the necessary headers
+#ifndef WX_PRECOMP
+    #include "wx/wx.h"
+#endif
+
+#include "wx/cppunit.h"
+#include "wx/zstream.h"
+#include "wx/wfstream.h"
+#include "wx/mstream.h"
+
+#include "bstream.h"
+
+using namespace std;
+using namespace CppUnit;
+
+#define DATABUFFER_SIZE 1024
+
+static const wxString FILENAME_GZ = _T("zlibtest.gz");
+
+///////////////////////////////////////////////////////////////////////////////
+// The test case
+//
+// Try to fully test wxZlibInputStream and wxFileOutputStream
+
+class zlibStream : public BaseStreamTestCase<wxZlibInputStream, wxZlibOutputStream>
+{
+public:
+    zlibStream();
+    virtual ~zlibStream();
+
+    CPPUNIT_TEST_SUITE(zlibStream);
+        // Base class stream tests the zlibstream supports.
+        CPPUNIT_TEST_FAIL(Input_GetSize);
+        CPPUNIT_TEST(Input_GetC);
+        CPPUNIT_TEST(Input_Read);
+        CPPUNIT_TEST(Input_Eof);
+        CPPUNIT_TEST(Input_LastRead);
+        CPPUNIT_TEST_FAIL(Input_SeekI);
+        CPPUNIT_TEST(Input_TellI);
+        CPPUNIT_TEST(Input_Peek);
+        CPPUNIT_TEST(Input_Ungetch);
+
+        CPPUNIT_TEST(Output_PutC);
+        CPPUNIT_TEST(Output_Write);
+        CPPUNIT_TEST(Output_LastWrite);
+        CPPUNIT_TEST_FAIL(Output_SeekO);
+        CPPUNIT_TEST(Output_TellO);
+
+        // Other test specific for zlib stream test case.
+        CPPUNIT_TEST(TestStream_NoHeader_Default);
+        CPPUNIT_TEST(TestStream_NoHeader_NoComp);
+        CPPUNIT_TEST(TestStream_NoHeader_SpeedComp);
+        CPPUNIT_TEST(TestStream_NoHeader_BestComp);
+        CPPUNIT_TEST(TestStream_ZLib_Default);
+        CPPUNIT_TEST(TestStream_ZLib_NoComp);
+        CPPUNIT_TEST(TestStream_ZLib_SpeedComp);
+        CPPUNIT_TEST(TestStream_ZLib_BestComp);
+        CPPUNIT_TEST(TestStream_GZip_Default);
+        CPPUNIT_TEST(TestStream_GZip_NoComp);
+        CPPUNIT_TEST(TestStream_GZip_SpeedComp);
+        CPPUNIT_TEST(TestStream_GZip_BestComp);
+        CPPUNIT_TEST(TestStream_ZLibGZip);
+        CPPUNIT_TEST(Decompress_BadData);
+        CPPUNIT_TEST(Decompress_wx24Data);
+    CPPUNIT_TEST_SUITE_END();
+
+protected:
+    // Test different stream construct settings.
+    void TestStream_NoHeader_Default();
+    void TestStream_NoHeader_NoComp();
+    void TestStream_NoHeader_SpeedComp();
+    void TestStream_NoHeader_BestComp();
+    void TestStream_ZLib_Default();
+    void TestStream_ZLib_NoComp();
+    void TestStream_ZLib_SpeedComp();
+    void TestStream_ZLib_BestComp();
+    void TestStream_GZip_Default();
+    void TestStream_GZip_NoComp();
+    void TestStream_GZip_SpeedComp();
+    void TestStream_GZip_BestComp();
+    void TestStream_ZLibGZip();
+    // Try to decompress bad data.
+    void Decompress_BadData();
+    // Decompress a data file created with wx 2.4.
+    // Note: This test is limited in testing range!
+    void Decompress_wx24Data();
+
+private:
+    const char *GetDataBuffer();
+    const unsigned char *GetCompressedData();
+    void doTestStreamData(int input_flag, int output_flag, int compress_level);
+
+private:
+    // Implement base class functions.
+    virtual wxZlibInputStream  *DoCreateInStream();  
+    virtual wxZlibOutputStream *DoCreateOutStream();
+    virtual void DoDeleteInStream();
+    virtual void DoDeleteOutStream();
+
+private:
+    char            m_DataBuffer[DATABUFFER_SIZE];
+    size_t          m_SizeCompressedData;
+    unsigned char  *m_pCompressedData;
+
+    // Used by the base Creat[In|Out]Stream and Delete[In|Out]Stream.
+    wxMemoryInputStream  *m_pTmpMemInStream;
+    wxMemoryOutputStream *m_pTmpMemOutStream;
+};
+
+zlibStream::zlibStream()
+    :m_SizeCompressedData(0),
+     m_pCompressedData(NULL),
+     m_pTmpMemInStream(NULL),
+     m_pTmpMemOutStream(NULL)
+{
+    // Init the data buffer.
+    for (size_t i = 0; i < DATABUFFER_SIZE; i++)
+        m_DataBuffer[i] = (i % 0xFF);
+
+    // Set extra base config settings.
+    m_bSimpleTellITest = true;
+    m_bSimpleTellOTest = true;
+}
+
+zlibStream::~zlibStream()
+{
+    delete m_pCompressedData;
+
+    delete m_pTmpMemInStream;
+    delete m_pTmpMemOutStream;
+}
+
+void zlibStream::TestStream_NoHeader_Default()
+{
+    doTestStreamData(wxZLIB_NO_HEADER, wxZLIB_NO_HEADER, wxZ_DEFAULT_COMPRESSION);
+}
+void zlibStream::TestStream_NoHeader_NoComp()
+{
+    doTestStreamData(wxZLIB_NO_HEADER, wxZLIB_NO_HEADER, wxZ_NO_COMPRESSION);
+}
+void zlibStream::TestStream_NoHeader_SpeedComp()
+{
+    doTestStreamData(wxZLIB_NO_HEADER, wxZLIB_NO_HEADER, wxZ_BEST_SPEED);
+}
+void zlibStream::TestStream_NoHeader_BestComp()
+{
+    doTestStreamData(wxZLIB_NO_HEADER, wxZLIB_NO_HEADER, wxZ_BEST_COMPRESSION);
+}
+
+void zlibStream::TestStream_ZLib_Default()
+{
+    doTestStreamData(wxZLIB_ZLIB, wxZLIB_ZLIB, wxZ_DEFAULT_COMPRESSION);
+}
+void zlibStream::TestStream_ZLib_NoComp()
+{
+    doTestStreamData(wxZLIB_ZLIB, wxZLIB_ZLIB, wxZ_NO_COMPRESSION);
+}
+void zlibStream::TestStream_ZLib_SpeedComp()
+{
+    doTestStreamData(wxZLIB_ZLIB, wxZLIB_ZLIB, wxZ_BEST_SPEED);
+}
+void zlibStream::TestStream_ZLib_BestComp()
+{
+    doTestStreamData(wxZLIB_ZLIB, wxZLIB_ZLIB, wxZ_BEST_COMPRESSION);
+}
+
+void zlibStream::TestStream_GZip_Default()
+{
+    doTestStreamData(wxZLIB_GZIP, wxZLIB_GZIP, wxZ_DEFAULT_COMPRESSION);
+}
+void zlibStream::TestStream_GZip_NoComp()
+{
+    doTestStreamData(wxZLIB_GZIP, wxZLIB_GZIP, wxZ_NO_COMPRESSION);
+}
+void zlibStream::TestStream_GZip_SpeedComp()
+{
+    doTestStreamData(wxZLIB_GZIP, wxZLIB_GZIP, wxZ_BEST_SPEED);
+}
+void zlibStream::TestStream_GZip_BestComp()
+{
+    doTestStreamData(wxZLIB_GZIP, wxZLIB_GZIP, wxZ_BEST_COMPRESSION);
+}
+
+void zlibStream::TestStream_ZLibGZip()
+{
+    // Only use default compression level, as this test is 
+    // for testing if the streams can determine the stream type info them self...
+    doTestStreamData(wxZLIB_ZLIB|wxZLIB_GZIP, wxZLIB_ZLIB, wxZ_DEFAULT_COMPRESSION);
+    doTestStreamData(wxZLIB_ZLIB|wxZLIB_GZIP, wxZLIB_GZIP, wxZ_DEFAULT_COMPRESSION);
+}
+
+void zlibStream::Decompress_BadData()
+{
+    // Setup the bad data stream and the zlib stream.
+    wxMemoryInputStream memstream_in(GetDataBuffer(), DATABUFFER_SIZE);
+    CPPUNIT_ASSERT(memstream_in.IsOk());
+    wxZlibInputStream zstream_in(memstream_in);
+    CPPUNIT_ASSERT(zstream_in.IsOk()); // We did not yet read from the stream 
+                                       // so it should still be OK.
+    // Try to force the stream to go to bad status.
+    CPPUNIT_ASSERT(!zstream_in.Eof());
+    if (zstream_in.IsOk())
+        zstream_in.GetC();
+
+    // Because of the bad data in the input stream the zlib
+    // stream should be marked as NOT OK.
+    CPPUNIT_ASSERT(!zstream_in.IsOk());
+}
+
+void zlibStream::Decompress_wx24Data()
+{
+    // The wx24_value was used in a wxWidgets 2.4(.2) 
+    // application to produce wx24_data, using wxZlibOutputStream.
+    const unsigned char wx24_data[] = {120,156,242,72,205,201,201,87,40,207,47,202,73,97,0,0,0,0,255,255,0};
+    const char *wx24_value = "Hello world";
+    // Size of the value and date items.
+    const size_t data_size = sizeof(wx24_data);
+    const size_t value_size = strlen(wx24_value);
+
+    const unsigned char *buf = GetCompressedData();
+    m_pTmpMemInStream = new wxMemoryInputStream(buf, m_SizeCompressedData);
+
+    wxMemoryInputStream memstream_in(wx24_data, data_size);
+    CPPUNIT_ASSERT(memstream_in.IsOk());
+    wxZlibInputStream zstream_in(memstream_in);
+    CPPUNIT_ASSERT(zstream_in.IsOk());
+
+    size_t i;
+    for (i = 0; !zstream_in.Eof(); i++)
+    {
+        char last_value = zstream_in.GetC();
+        if (last_value != wx24_value[i])
+            break;
+
+        // Don't go over the end of the value buffer...
+        if (wx24_value[i] == '\0')
+        {
+            // And if we do then try to see how long the stream actually is.
+            for (/* nothing */; !zstream_in.Eof(); i++)
+            {
+                // Move one item along in the stream.
+                (void)zstream_in.GetC();
+                
+                // Check if we are in an infinite loop by multiplying value_size
+                // by 5 to have a *much* bigger range then the real range.
+                // Note: Incase you ask your self, why 5, the answer is no reason... 
+                //       it is not to big and not to small a size, nothing more 
+                //       nothing less to it.
+                if (i > (value_size*5)) 
+                {
+                    // Note: Please make sure Input_Eof test passed.
+                    CPPUNIT_FAIL("Infinite stream detected, breaking the infinite loop");
+                    return;
+                }
+            }
+
+            break;
+        }
+    }
+
+    CPPUNIT_ASSERT_MESSAGE("Could not decompress data that was compressed with wxWidgets 2.4.x", i == (value_size + 1));
+}
+
+const char *zlibStream::GetDataBuffer()
+{
+    return m_DataBuffer;
+}
+
+const unsigned char *zlibStream::GetCompressedData()
+{
+    if (!m_pCompressedData)
+    {
+#if 1
+        // Construct the compressed data live.
+        wxMemoryOutputStream memstream_out;
+        {
+            const char *buf = "01234567890123456789012345678901234567890123456789"; /* = 50 */
+            wxZlibOutputStream zstream_out(memstream_out);
+            zstream_out.Write(buf, strlen(buf));
+        }
+
+        // Copy the to the 
+        m_SizeCompressedData = memstream_out.GetSize();
+        m_pCompressedData = new unsigned char[m_SizeCompressedData];
+        memstream_out.CopyTo(m_pCompressedData, m_SizeCompressedData);
+#else
+        // Or use recorded compressed data.
+        const unsigned char tmp[] = {120,218,51,48,52,50,54,49,53,51,183,176,52,32,142,197,0,0,3,229,10,9,0};
+        m_SizeCompressedData = sizeof(tmp);
+        m_pCompressedData = new unsigned char[m_SizeCompressedData+1];
+        memcpy(m_pCompressedData, tmp, m_SizeCompressedData);
+#endif
+    }
+
+    CPPUNIT_ASSERT(m_pCompressedData != NULL);    
+    return m_pCompressedData;
+}
+
+void zlibStream::doTestStreamData(int input_flag, int output_flag, int compress_level)
+{
+    size_t fail_pos = 0;
+    char last_value = 0;
+    bool bWasEOF = true;
+
+    {   // Part one: Create a compressed file.
+        wxFileOutputStream fstream_out(FILENAME_GZ);
+        CPPUNIT_ASSERT(fstream_out.IsOk());
+        wxZlibOutputStream zstream_out(fstream_out, compress_level, output_flag);
+        if (!zstream_out.IsOk())
+        {
+            if (output_flag == wxZLIB_GZIP)
+                CPPUNIT_FAIL("Could not create the gzip output stream. Note: gzip requires zlib 1.2+!");
+            else
+                CPPUNIT_FAIL("Could not create the output stream");
+        }
+
+        // Next: Compress some data so the file is containing something.
+        zstream_out.Write(GetDataBuffer(), DATABUFFER_SIZE);
+    }
+
+    {   // Part two: Verify that the compressed data when uncompressed 
+        //           matches the original data.
+        wxFileInputStream fstream_in(FILENAME_GZ);
+        CPPUNIT_ASSERT(fstream_in.IsOk());
+        wxZlibInputStream zstream_in(fstream_in, input_flag);
+        CPPUNIT_ASSERT_MESSAGE("Could not create the input stream", zstream_in.IsOk());
+
+        // Next: Check char per char if the returned data is valid.
+        const char *pbuf = GetDataBuffer();
+        for (fail_pos = 0; !zstream_in.Eof(); fail_pos++)
+        {
+            last_value = zstream_in.GetC();
+            if (last_value != pbuf[fail_pos])
+                break;
+        }
+
+        bWasEOF = zstream_in.Eof();
+    }
+
+    // Remove the temp file...
+    ::wxRemoveFile(FILENAME_GZ);
+
+    // Check state of the verify action.
+    if (fail_pos != DATABUFFER_SIZE || !bWasEOF)
+    {
+        wxString msg(wxString::Format(_T("Wrong data item at pos %d (Org_val %d != Zlib_val %d), with compression level %d"), 
+                                            fail_pos, GetDataBuffer()[fail_pos], last_value, compress_level));
+        CPPUNIT_FAIL(string(msg.mb_str()));
+    }
+}
+
+wxZlibInputStream *zlibStream::DoCreateInStream()    
+{ 
+    const unsigned char *buf = GetCompressedData();
+    m_pTmpMemInStream = new wxMemoryInputStream(buf, m_SizeCompressedData);
+    CPPUNIT_ASSERT(m_pTmpMemInStream->IsOk());
+    wxZlibInputStream *pzstream_in = new wxZlibInputStream(*m_pTmpMemInStream);
+    CPPUNIT_ASSERT(pzstream_in->IsOk());
+    return pzstream_in;
+}
+wxZlibOutputStream *zlibStream::DoCreateOutStream()
+{ 
+    m_pTmpMemOutStream = new wxMemoryOutputStream();
+    CPPUNIT_ASSERT(m_pTmpMemOutStream->IsOk());
+    wxZlibOutputStream *pzstream_out = new wxZlibOutputStream(*m_pTmpMemOutStream);
+    CPPUNIT_ASSERT(pzstream_out->IsOk());
+    return pzstream_out;
+}
+void zlibStream::DoDeleteInStream()  
+{ 
+    delete m_pTmpMemInStream;
+    m_pTmpMemInStream = NULL;
+}
+void zlibStream::DoDeleteOutStream() 
+{ 
+    delete m_pTmpMemOutStream;
+    m_pTmpMemOutStream = NULL;
+}
+
+// Register the stream sub suite, by using some stream helper macro.
+// Note: Don't forget to connect it to the base suite (See: bstream.cpp => StreamCase::suite())
+STREAM_TEST_SUBSUITE_NAMED_REGISTRATION(zlibStream)
+
diff -ruP tests.orig/test.bkl tests/test.bkl
--- tests.orig/test.bkl	2004-03-30 10:54:31.000000000 +0200
+++ tests/test.bkl	2004-03-29 20:50:03.000000000 +0200
@@ -13,6 +13,11 @@
             formatconverter/formatconverter.cpp
             regex/regex.cpp
             filesys/filesys.cpp
+            streams/bstream.cpp
+            streams/ffilestream.cpp
+            streams/filestream.cpp
+            streams/memstream.cpp
+            streams/zlibstream.cpp
         </sources>
         <wx-lib>base</wx-lib>
     </exe>

 	  	 
