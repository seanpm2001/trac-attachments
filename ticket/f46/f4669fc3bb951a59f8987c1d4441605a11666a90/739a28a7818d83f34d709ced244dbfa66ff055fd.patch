Index: include/wx/defs.h
===================================================================
--- include/wx/defs.h	(revision 49274)
+++ include/wx/defs.h	(working copy)
@@ -1771,6 +1771,9 @@
 /*  Standard menu IDs */
 enum
 {
+    wxID_AUTO_LOWEST = -25000,
+    wxID_AUTO_HIGHEST = -200,
+    
     /* no id matches this one when compared to it */
     wxID_NONE = -3,
 
Index: include/wx/window.h
===================================================================
--- include/wx/window.h	(revision 49274)
+++ include/wx/window.h	(working copy)
@@ -27,6 +27,7 @@
 #include "wx/utils.h"
 #include "wx/intl.h"
 
+
 #include "wx/validate.h"        // for wxDefaultValidator (always include it)
 
 #if wxUSE_PALETTE
@@ -221,9 +222,19 @@
 
         // generate a control id for the controls which were not given one by
         // user
-    static int NewControlId() { return --ms_lastControlId; }
+    static wxWindowID NewControlId(int count = 1);
+    static void ReleaseControlId(wxWindowID id);
+    
+        // should the control id be automatically freed
+    void FreeId(bool freeId = true) { m_freeId = freeId; }
+    void DontFreeId() { FreeId(false); }
+    
         // get the id of the control following the one with the given
         // (autogenerated) id
+        
+    // Since the ID manager is being used, these functions would not
+    // work.  After looking though the source, they don't appear to be
+    // used anywhere. 
     static int NextControlId(int winid) { return winid - 1; }
         // get the id of the control preceding the one with the given
         // (autogenerated) id
@@ -1514,8 +1525,15 @@
     int DoGetPopupMenuSelectionFromUser(wxMenu& menu, int x, int y);
 #endif // wxUSE_MENUS
 
-    // contains the last id generated by NewControlId
-    static int ms_lastControlId;
+    // contains the next control id and control id bitmap
+    static wxWindowID ms_nextControlId;
+    static wxByte ms_controlIdBitmap[];
+    
+    static void SetIdState(wxWindowID id, bool state);
+    static bool GetIdState(wxWindowID id);
+    
+    // should this window id be released
+    bool m_freeId;
 
     // the stack of windows which have captured the mouse
     static struct WXDLLIMPEXP_FWD_CORE wxWindowNext *ms_winCaptureNext;
Index: src/common/wincmn.cpp
===================================================================
--- src/common/wincmn.cpp	(revision 49274)
+++ src/common/wincmn.cpp	(working copy)
@@ -89,13 +89,6 @@
 // static data
 // ----------------------------------------------------------------------------
 
-#if defined(__WXPALMOS__)
-int wxWindowBase::ms_lastControlId = 32767;
-#elif defined(__WXPM__)
-int wxWindowBase::ms_lastControlId = 2000;
-#else
-int wxWindowBase::ms_lastControlId = -200;
-#endif
 
 IMPLEMENT_ABSTRACT_CLASS(wxWindowBase, wxEvtHandler)
 
@@ -242,11 +235,21 @@
     // ids are limited to 16 bits under MSW so if you care about portability,
     // it's not a good idea to use ids out of this range (and negative ids are
     // reserved for wxWidgets own usage)
-    wxASSERT_MSG( id == wxID_ANY || (id >= 0 && id < 32767),
+    wxASSERT_MSG( id == wxID_ANY || (id >= 0 && id < 32767) ||
+                  (id >= wxID_AUTO_LOWEST && id <= wxID_AUTO_HIGHEST),
                   _T("invalid id value") );
 
     // generate a new id if the user doesn't care about it
-    m_windowId = id == wxID_ANY ? NewControlId() : id;
+    if(id == wxID_ANY)
+    {
+        m_windowId = NewControlId();
+        m_freeId = true;
+    }
+    else
+    {
+        m_windowId = id;
+        m_freeId = false;
+    }
 
     // don't use SetWindowStyleFlag() here, this function should only be called
     // to change the flag after creation as it tries to reflect the changes in
@@ -301,6 +304,10 @@
 wxWindowBase::~wxWindowBase()
 {
     wxASSERT_MSG( GetCapture() != this, wxT("attempt to destroy window with mouse capture") );
+    
+    // Release the ID if needed
+    if(m_freeId)
+        ReleaseControlId(m_windowId);
 
     // FIXME if these 2 cases result from programming errors in the user code
     //       we should probably assert here instead of silently fixing them
@@ -3179,3 +3186,107 @@
     return x;
 }
 
+// ----------------------------------------------------------------------------
+// Control IDs, can be used for any window ID, not just child controls 
+// ----------------------------------------------------------------------------
+#define ID_BYTE_COUNT (((wxID_HIGHEST - wxID_LOWEST + 1) / 8) + 1)
+
+// Static members
+wxWindowID wxWindowBase::ms_nextControlId = wxID_AUTO_LOWEST;
+wxByte wxWindowBase::ms_controlIdBitmap[ID_BYTE_COUNT] = { 0 };
+
+// Generate a new ID or sequence of IDs
+wxWindowID wxWindowBase::NewControlId(int count)
+{
+    // Find a free position
+    if(ms_nextControlId + count - 1 <= wxID_AUTO_HIGHEST)
+    {
+        // The ID manager hasn't reached the end yet, so it is known that these
+        // ID values are free
+        wxWindowID id = ms_nextControlId;
+        ms_nextControlId += count;
+      
+        while(count--)
+            SetIdState(id + count, true);
+        
+        return id;
+    }
+    else
+    {
+        // The ID manager has reached the end, so a search must be done for
+        // free ID values
+        int found = 0;
+        
+        for(wxWindowID pos = wxID_AUTO_LOWEST; pos <= wxID_AUTO_HIGHEST; pos++)
+        {
+            if(!GetIdState(pos))
+            {
+                // Increase the number of consecutive free values found
+                found++;
+                if(found == count)
+                {
+                  // Found 'count' consecutive free ID values
+                  wxWindowID id = pos - count + 1;
+                  
+                  while(count--)
+                  {
+                      SetIdState(id + count, true);
+                  }
+                  
+                  return id;
+                }
+            }
+            else
+            {
+                // Reset the number of consecutive free values found
+                found = 0;
+            }
+        }
+    }
+
+    // No free IDs found
+    return wxID_NONE;
+}
+
+// Release an id
+void wxWindowBase::ReleaseControlId(wxWindowID id)
+{
+    wxASSERT(id >= wxID_AUTO_LOWEST && id <= wxID_AUTO_HIGHEST);
+        
+    SetIdState(id, false);
+}
+
+// Set the ID state
+void wxWindowBase::SetIdState(wxWindowID id, bool state)
+{
+    // Adjust id for the starting value
+    id -= wxID_AUTO_LOWEST;
+    
+    size_t theByte = id / 8;
+    size_t theBit = id % 8;
+    
+    if(state)
+    {
+        // Mark it as used
+        ms_controlIdBitmap[theByte] |= (0x01 << theBit);
+    }
+    else
+    {
+        // Mark it as unused
+        ms_controlIdBitmap[theByte] &= ~(0x01 << theBit);
+    }
+}
+
+// Get the ID state
+bool wxWindowBase::GetIdState(wxWindowID id)
+{
+    // Adjust for starting value
+    id -= wxID_AUTO_LOWEST;
+
+    size_t theByte = id / 8;
+    size_t theBit = id % 8;
+    
+    return (ms_controlIdBitmap[theByte] & (0x01 << theBit)) != 0x00;
+}
+
+
Index: src/xrc/xmlres.cpp
===================================================================
--- src/xrc/xmlres.cpp	(revision 49274)
+++ src/xrc/xmlres.cpp	(working copy)
@@ -47,6 +47,7 @@
 
 #include "wx/xml/xml.h"
 
+
 class wxXmlResourceDataRecord
 {
 public:
@@ -1610,7 +1611,10 @@
         }
         else
         {
-            (*rec_var)->id = wxWindow::NewControlId();
+            // Since the item will be created with this id and 
+            // not wxID_ANY, the item will not have the
+            // style wxWS_EX_AUTO_RELEASE_ID set
+            (*rec_var)->id = wxWindowBase::NewControlId();
         }
     }
 
@@ -1639,6 +1643,14 @@
     if (rec)
     {
         CleanXRCID_Record(rec->next);
+        
+        // Only release the ID if it is in the auto-id range
+        // and not any other.  This is because several ids are 
+        // automatically added to the list, including special ids,
+        // xml items with direct ids, etc
+        if(rec->id >= wxID_AUTO_LOWEST && rec->id <= wxID_AUTO_HIGHEST)
+            wxWindowBase::ReleaseControlId(rec->id);
+        
         free(rec->key);
         delete rec;
     }

 	  	 
